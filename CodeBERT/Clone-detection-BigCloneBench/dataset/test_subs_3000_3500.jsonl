{"id1": "6190356", "id2": "4750967", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 0, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForOldM5", " hashPasswordForOldM3", " hashPasswordForNewM512", " hashPasswordForOldM512", " hashPasswordForNewMD5", " hashPasswordForOldMC5", " hashPasswordForOldmd4", " hashPasswordForNewM3", " hashPasswordForOldM4", " hashPasswordForOldMC3", " hashPasswordForOldMD3", " hashPasswordForOldmd5", " hashPasswordForOldmd3", " hashPasswordForNewMD512", " hashPasswordForNewMD4", " hashPasswordForOldMD512", " hashPasswordForOldMC512", " hashPasswordForNewM5", " hashPasswordForOldMD4", " hashPasswordForOldMC4", " hashPasswordForNewM4", " hashPasswordForOldmd512", " hashPasswordForNewMD3"], "password": ["pass", "words", "username", "token", "seed", "sword", "string", "word", "secret", "input", "Password", "PASS", "wallet", "path", "key", " passwords", "auth", "pad", "wd", "content", "address", "p", " Password", "phrase", "array", "code", "value", "hash", "result", "data", "account", "message", "pattern", "buffer", "crypt", "text", "name", "encrypted", "padding"], "md": ["dc", "df", "mb", "mp", "pd", "pm", "od", "mand", "clean", "mac", "Cmd", "m", "pg", "rm", "um", " MD", "km", "d", "hm", "di", "MD", "bd", "meta", "wd", "hd", "vm", "dd", "mc", "cd", "mod", "cmd", "mag", "ma", "f", "am", "gd", "ind", "dm", "nm", "amd", "managed", "rpm", "dig", "mm", "metadata", "vd", "grad", "mt", "mo"], "messageDigest": ["messageDest", "MessageAddest", "messageDester", " messageDigester", "messageDigse", "messageModests", "messageModEST", " messageModests", "MessageDigester", "messageAddse", "messagedigest", "messageDigester", "messagedigse", "messagedigester", "messageModester", "MessageAddester", "messageDigEST", " messageDigests", "messageAddester", "MessageAddse", "MessageDigEST", "messagedigEST", " messageModest", "messageDigests", "messagedigests", "messageAddests", "messageAddEST", "MessageModse", "MessageModester", "MessageModest", "messageDEST", "MessageDigest", " messageModester", "messageDse", "MessageAddEST", "messageModest", "MessageModEST", "MessageDigse", "messageAddest", "messageModse", " messageDigEST", " messageModEST"], "hexString": ["crossFunction", "stringService", " hexFile", "tempstring", "hashString", "stringString", "tempFunction", "sumFile", "transformBuffer", "hexstring", "hexFile", "transformString", "hashService", "crossString", "hashSection", " hexstring", "sumstring", "octString", "transformArray", "hexSection", " hexBuffer", "stringSection", "hexArray", " hexArray", "hexBuffer", "hexService", "stringArray", "tempFile", "transformStr", "sumString", "octArray", "hexStr", " hexService", "tempString", "crossStr", "hexFunction", "octBuffer", "octStr", "tempStr", "sumStr", "crossstring", " hexFunction", "hashArray", " hexSection", " hexStr"], "i": ["si", "qi", "ip", "u", "multi", "n", "c", "ii", "m", "pi", "k", "o", "d", "ci", "di", "io", "slice", "ji", "ui", "length", "ri", "bi", "p", "l", "phi", "s", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "a", "h", "v", "ti", "ai", "r", "b", "xi", "t", "id", "info", "uri", "ix"], "hex": ["temp", "cmp", "ip", "nexus", "full", "string", "cache", "utf", "zero", "host", "rh", "ex", "exp", "http", "shift", "str", "character", "pixel", "transform", "path", "none", "char", "bit", "json", "length", "letter", "lit", "cookie", "batch", "alpha", "default", "oct", "orig", "hello", "pex", "he", "serial", " Hex", "rex", "comp", "sex", "hash", "h", "format", "result", "data", "raw", "digit", "null", "pack", "hack", "buff", "pattern", "binary", "text", "form"]}}
{"id1": "17716716", "id2": "14794404", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "label": 1, "substitutes": {"plainToMD": [" string2String", " inputToMD", " stringToString", " stringtoString", " stringToDER", " stringToMD", " input2MD", " stringtoMD", " inputToHash", " stringtoHash", " string2MD", " inputToString", " stringTOHash", " string2DER", " input2DER", " inputToDER", " string2Hash", " input2String", " stringTODER", " input2Hash", " stringTOString", " stringToHash", " stringTOMD", " stringtoDER"], "loggerCol": ["loglerCollection", "progerCol", "loggingCol", "loggeeCor", "loggingColumn", "loglerColumn", "loggeeDr", "progercol", "pluggerDr", "loggerCor", "pluggerCol", "loglerCol", "loggingCollection", "logorerCollection", "logorercol", "loggerCollection", "progingCollection", "progingColumn", "loggeDr", "loggeeCol", "loggerColumn", "pluggingCor", "progerCollection", "pluggerCor", "loggecol", "loggeecol", "loggerDr", "logorerColumn", "loggeCol", "loglercol", "pluggingCol", "pluggercol", "progerColumn", "logorerCol", "loggeCor", "loggercol", "loggingDr", "progingcol", "loggingCor", "progingCol", "pluggingcol", "pluggingDr", "loggingcol"], "input": ["temp", "plus", "container", "string", "instance", "IN", "context", "request", "xml", "str", "state", "path", "empty", "list", "in", "dict", "alpha", "audio", "connection", "base", "model", "cmd", "url", "config", "Input", "password", "image", "format", "inf", "ssl", "output", "reader", "data", "raw", "null", "source", "buffer", "text", "form", "file"], "byteHash": ["bitBlock", "bithash", "ByteHash", "bitHash", "wordSum", " byteBlock", " byteArray", "bytesHash", " byteSalt", "ByteBlock", "byteshash", "byteSum", "stringSalt", "wordArray", "byteArray", "bytesSalt", "stringhash", "bytesArray", "blockhash", "Bytehash", " bytehash", " byteSum", "stringArray", "byteSalt", "wordHash", "byteBlock", "stringHash", "blockBlock", "ByteSum", "bitSum", "bitArray", "wordhash", "bytehash", "blockSum", "blockHash"], "md": ["df", "mb", "mg", "mp", "pd", "ms", "pm", "mand", "cm", "mac", "Cmd", "m", "rm", "sm", " MD", "um", "d", "hm", "msg", "di", "MD", "bd", "meta", "doc", "ad", "dd", "cc", "mc", "ph", "cd", "mod", "cmd", "mn", "dh", "dr", "ma", "mag", "f", "pkg", "am", "Msg", "dm", "hash", "nm", "amd", "dig", "rpm", "mm", "metadata", "mt", "mu", "mo"], "md5result": ["md4result", "md6results", "md7result", "md53runner", " md25data", "md6Result", "md5Result", " md5report", "mddownresult", "md25result", " md5data", "md305response", "md6report", "md7results", "md4response", "md305results", "mddownResult", "md53response", " md7results", "md25Result", " md5results", "md305runner", " md7result", " md305response", "md53result", "mddownpackage", "md7Result", "md5response", "md5report", "md5runner", " md25Result", "md6result", "md5data", " md305result", "md512result", "md512report", "md7report", " md25result", "md512results", "md6data", "md305result", " md5response", " md5package", " md305runner", "md25package", " md5runner", " md7report", "md4runner", "md25data", "md53results", " md5Result", "md6package", " md7Result", "md512Result", "mddowndata", "md4results", "md5package", " md305results", "md5results", " md25package"], "i": ["hi", "si", "qi", "u", "multi", "n", "c", "ii", "pi", "o", "d", "ci", "di", "io", "z", "key", "ji", "ui", "ri", "length", "bi", "p", "l", "s", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "h", "v", "gi", "ti", "ai", "r", "b", "xi", "zi", "id", "uri", "mu"]}}
{"id1": "838844", "id2": "411595", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "subverting", "unverted", "Conversion", "converted", "CONverted", "unception", "CONverting", "conversion", " deconverting", "Convert", " deconvert", "conception", " deconverted", "subversion", "oconverted", "Conception", "subverted", "CONception", "oconvert", "oconversion", "subvert", "unvert", "CONversion", "CONvert", "converting", " deconversion", "unversion", "Converted", "oconverting"], "src": ["resource", "scene", "stage", "sth", "username", "cmp", "SourceFile", "string", "href", "Source", "spec", "cpp", "dist", "input", "ource", "path", "inst", "ctx", "sc", "buf", "slice", "sys", "attr", "rl", "download", "impl", "fn", "loc", "proc", "video", "gb", "s", "rc", "storage", "upload", "tmp", "url", "component", "load", "sn", "config", "sb", "code", "gz", "filename", "sin", "Dest", "fp", "cb", "ssl", "img", "reader", "st", "RC", "supp", "secure", "obj", "req", "feat", "rb", "prot", "back", "source", "stream", "uri", "sel", "name", "sit", "file", "ref"], "dest": ["dc", "txt", "temp", "class", " dst", "dat", "dist", "bin", "path", "di", "disk", "dir", "fn", "orig", "tmp", "home", "lib", "Dest", "std", "img", "test", "obj", "target", "null", " destination", "source", "cont"], "in": ["In", "inas", "pass", "ini", "n", "IN", "ex", "is", "d", "din", "bin", "input", "as", "io", "pin", "ins", "doc", "inn", "err", "up", "isin", "win", "f", "i", "a", "inf", "val", "login", "reader", "data", "r", "ps", "t", "inc", "source", "stream", "file"], "p": ["pc", "cop", "pd", "pm", "g", "c", "pr", "pi", "op", "py", "pb", "pg", "o", "m", "d", "np", "pp", "bp", "tp", "wp", "l", "part", "s", "pe", "cp", "pa", "j", "sp", "per", "f", "e", "lp", "i", "pre", "h", "fp", "v", "P", "jp", "r", "po", "ps", "t", "parser", "b"], "ds": ["dc", "hs", "words", "dl", "gs", "da", "obs", "s", "icks", "ges", "dm", "ts", "sts", "db", "df", "js", "pd", "bs", "ys", "dat", "lines", "dos", "d", "utils", "ads", "styles", " props", " sd", "amps", "ld", "ans", "Ds", "lp", "ns", "data", "posts", "parts", "docs", "ps", "DS", "ss", "dp", "scripts", "uds", "di", "os", "sync", "sys", "ins", "xs", "tests", "dds", "ls", "dt", "cs", "des", "nas", " DS", "ups", "ks", "eps", "dist", "cons", "ays", "tools", "ants", "groups", "plugins", "dd", "qs", "vs", "services", "dates", "ths", "els", "gd", "ded", "vals", "points", "ils", " ps", "ipes", "rs", "models"], "format": ["struct", "class", "function", "at", "act", "string", "host", "table", "spec", "version", "language", "atter", "path", "fd", "api", "magic", "letter", "unit", "handler", "fn", "frame", "nat", "scale", "tag", "part", "layout", "Format", "model", "prefix", "ant", "url", "config", "f", "sche", "filename", "record", "fp", "filter", "data", "type", "feat", "style", "plugin", "t", "parser", "pattern", "source", "form", "name", "file", "template"], "hasPixelData": ["showsPixeldata", "haspixeldata", "showsPixelDATA", "hasByteDATA", "hasPixeldata", "hasPixelDATA", "showsPixelStyle", " hasPixelSize", " hasPixeldata", "showsBytedata", "showsByteStyle", "haspixelSize", "showsPixelData", "hasByteData", "hasByteStyle", "hasBytedata", "haspixelData", "hasPixelStyle", "showsByteData", "hasPicturedata", "hasByteSize", "hasPictureSize", "hasPixelSize", "hasPictureData", "showsByteDATA"], "inflate": ["inFlated", "inadequating", "infloace", "insflode", "InFlate", "infolATE", "inadequode", "insvenATE", "inFlate", "insflating", "InFlace", "insflATE", "inffated", "inflation", "invenate", "inflace", "infolode", "inFlation", "infloate", "insvenate", "invenATE", "infloated", "inffation", "invenating", "InFlated", "insvenating", "insflate", "inflATE", "inflating", "Inflace", "infface", "inFlace", "infolate", "Inflated", "inffate", "Inflate", "inadequate", "insvenode", "inflated", "infolating", "infloation", "inflode", "invenode", "Inflation", "InFlation", "inadequATE"], "pxlen": ["fxdata", "pnglen", "pxlin", "mxln", "axlon", "pxcount", "fxln", "pglen", "txln", "pcln", "ppl", "pxlon", "txlin", "camlen", "fxl", "pgden", "pngsize", "axlin", "mxlen", "camln", "fxden", "xplength", "ppLen", "mxdata", "pxLen", "pxdata", "pclen", "pclin", "axln", "pxln", "axlen", "txlen", "pngcount", "campos", "mxpos", "fxLen", "xpsize", "xpcount", "pxsize", "pgl", "pxpos", "ppden", "pgLen", "fxpos", "pxlength", "fxlen", "mxlength", "mxcount", "xplen", "mxsize", "camdata", "pxden", "pclon", "pplen", "pxl", "pnglength", "txlon"], "out": ["group", "line", "again", "cache", "step", "inter", "state", "Out", "copy", "log", "io", "outs", "list", "co", "post", "sys", "pad", "user", "conn", "store", "err", "up", "server", "query", "work", "cli", "session", "dump", "lib", "v", "page", "output", "gen", "error", "obj", "OUT", "point", "parent", "lock", "re"]}}
{"id1": "8024375", "id2": "11005804", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"getRandomGUID": ["getRandomGCid", "getRandomGID", "getRandGID", "getRandomUid", "getRandomIGUID", "getRandomUID", "getRandomGCID", "getRandomGCuid", "getRandomIGuid", "getRandGuid", "getRandUuid", "getRandUID", "getRandGid", "getRandomIGid", "getRandomUuid", "getRandomUUID", "getRandGUID", "getRandomGid", "getRandomGuid", "getRandomIGID", "getRandomGCUID", "getRandUid", "getRandUUID"], "secure": ["timeout", "external", "use", "secondary", "seed", "zip", "exclusive", "host", "secret", "depth", "proxy", "safe", "service", "Secure", "protect", "https", "force", "sr", "sensitive", "active", " insecure", "ce", "random", "pure", "weak", "server", "security", "config", "sec", "confirmed", "session", "allow", "remote", "ssl", "unsigned", "stable", "require", "debug", "deep", "encrypted", "smart"], "md5": ["cmdql", "mdql", "MD2", "MD5", " MD11", " MD3", " MD500", "MDql", "md11", "md2", "cmd3", " md11", " md2", " MD5", " md500", "MD500", "MD11", " mdql", "md512", "cmd512", "md500", " MD2", " md512", "MD512", "md3", "MD3", " md3", "cmd5"], "sbValueBeforeMD5": ["sbValueGivenmd3", "sbValueAfterMS20", "sbValueBeforeMD005", "sbValueBeforeMD20", "sbValueBeforeMP1", "sbValueBeforeMR3", "sbValueAfterMD5", "sbValueBeforeAMD3", "sbValueAfterMD0", "sbValueAfterMS65", "sbValueBeforeMS20", "sbValueBeforeMD375", "sbValueBeforeD75", "sbValueBeforeDER3", "sbValueBeforeMP3", "sbValuebeforeSD005", "sbValueAfterMS95", "sbValueGivenmd512", "sbValueBeforeMS65", "sbValueBeforeMD65", "sbValueBeforeMD512", "sbValueBeforemd3", "sbValueAfterMS55", "sbValueBeforeMP5", "sbValueBeforeMC375", "sbValuebeforeMD005", "sbValueBeforeMI3", "sbValueAfterMD75", "sbValueGivenMD5", "sbValueBeforeMR25", "sbValueAfterMS3", "sbValueBeforeDER1", "sbValueBeforeMS0", "sbValueBeforeMC5", "sbValueBeforeD65", "sbValueBeforeDER0", "sbValueBeforeMP7", "sbValueBeforeMS75", "sbValueBeforeSD1", "sbValueBeforeSD20", "sbValueAfterMD3", "sbValueAfterMP5", "sbValueAfterMS5", "sbValueBeforeMD1", "sbValueBeforeSD005", "sbValueAfterMS25", "sbValueAfterMS75", "sbValueGivenMD375", "sbValueBeforeD5", "sbValueBeforeMD25", "sbValueBeforeMD55", "sbValueBeforeD3", "sbValueBeforeMC3", "sbValueBeforeMS1", "sbValueBeforeMI5", "sbValueBeforeMD95", "sbValueBeforeSHA1", "sbValuebeforeMD5", "sbValueAfterMD20", "sbValueGivenMD512", "sbValueBeforeMI7", "sbValueBeforeMI1", "sbValueBeforeMR5", "sbValueAfterMS1", "sbValueBeforeMS95", "sbValueBeforeMS7", "sbValueGivenmd5", "sbValueBeforeSD5", "sbValuebeforeSD20", "sbValueBeforemd5", "sbValueBeforeMS512", "sbValueBeforemd95", "sbValueAfterMP1", "sbValueBeforeMD7", "sbValuebeforeSD5", "sbValueAfterMD95", "sbValueBeforemd25", "sbValueBeforeDER005", "sbValueBeforemd65", "sbValueBeforeSHA005", "sbValueBeforemd375", "sbValueBeforeMD75", "sbValueBeforeMS375", "sbValueGivenMD3", "sbValueBeforeDER20", "sbValueBeforeMI20", "sbValueBeforeMS5", "sbValueAfterMD25", "sbValueBeforeMAC55", "sbValueAfterMP7", "sbValueBeforemd75", "sbValueBeforeMAC0", "sbValueBeforeMS3", "sbValueBeforeMR95", "sbValueAfterMS0", "sbValueBeforeMS25", "sbValueBeforeMAC3", "sbValueBeforemd512", "sbValueBeforeMD0", "sbValueAfterMD7", "sbValueGivenmd375", "sbValueAfterMD55", "sbValuebeforeSD1", "sbValueAfterMD65", "sbValueBeforeMAC5", "sbValueBeforeMC512", "sbValueBeforeAMD5", "sbValueBeforeSHA20", "sbValueBeforeMS55", "sbValuebeforeMD1", "sbValueBeforeSHA5", "sbValueBeforeAMD1", "sbValueBeforeDER55", "sbValueAfterMD1", "sbValueBeforeMD3", "sbValueAfterMP3", "sbValuebeforeMD20", "sbValueBeforeAMD20", "sbValueBeforeDER5"], "time": ["timeout", "etime", "seed", "speed", "times", "host", "hour", "depth", "version", "money", "delay", "cost", "year", "slice", "length", "user", "random", "mode", "tz", "count", "loc", "rate", "event", "work", "clock", "size", "name", "date", "TIME", "value", "start", "tim", "counter", "ime", "type", "error", "duration", "id", "timer", "offset", "race", "Time"], "rand": ["root", "chance", "seed", "bot", "clean", "rh", "raid", "depth", "winner", "right", "delay", "year", "rage", "bit", "min", "random", "pick", "count", "alpha", "cr", "lang", "rule", "ng", "ro", "win", "order", "rc", "rate", "reg", "max", "Rand", "rank", "index", "serial", "q", "res", "range", "gen", "error", "type", "rol", "rr", "r", "risk", "id", "round", "mid", "version"], "valueBeforeMD5": ["valueAfterMD53", "valueBeforeMP2", "valueBeforeAMD3", "valueBeforeMC2", "valueBeforeMC5", "valueBeforemd2", "valueAfterAMD5", "valueInsideMD85", "valueInsideMD3", "valueBeforeMD3", "valueAfterMD3", "valueInsideMD2", "valueAfterAMD2", "valueBeforeMD85", "valueBeforemd5", "valueBeforeMD2", "valueBeforeMC85", "valueBeforeMD53", "valueAfterMD2", "valueBeforeMP5", "valueBeforeAMD5", "valueAfterAMD3", "valueBeforemd85", "valueBeforemd3", "valueBeforeAMD53", "valueAfterAMD53", "valueBeforeMP3", "valueBeforeMC3", "valueBeforeAMD2", "valueBeforeMP53", "valueInsideMD5"], "array": ["integer", "row", "section", "function", "string", "cache", "instance", "vector", "ray", "view", "expression", "area", "angle", "shape", "api", "list", "number", "Array", "database", "pair", "our", "object", "address", "archive", "sample", "batch", "audio", "app", "storage", "element", "arr", "air", "value", "allow", "feature", "image", "any", "record", "result", "range", "error", "data", "message", "arrow", "binary", "collection"], "sb": ["ib", "mb", "usb", "bh", "nb", "sth", "si", "bs", "ob", "pb", "sf", "ruby", "src", "stab", "bt", "buf", "sa", "nn", "obb", "bsp", "bp", "SB", "eb", "orb", "xb", "lr", "bl", "lab", "lb", "abb", "gb", "s", "rob", "bc", "sl", "sbm", "lp", "zb", "BB", " SB", "kb", "cb", "bb", "sg", "bj", "sv", "fb", "bf", "buffer", "binary", "wb", "ab", "bm", "rb", "sq"], "j": ["ch", "js", "k", "ii", "g", "c", "n", "pr", "y", "jl", "dy", "o", "d", "J", "z", "key", "jo", "ji", "jj", "num", "length", "ie", "p", "br", "adj", "uj", "l", "part", "out", "x", "index", "f", "e", "code", "i", "q", "li", "ja", "v", "jp", "bj", "obj", "job", "aj", "ij", "end"], "b": ["ib", "mb", "nb", "ob", "n", "c", "B", "bs", "k", "pb", "y", "d", "bin", "be", "bit", "bi", "orb", "eb", "bug", "p", "br", "lb", "l", "x", "bc", "f", "bar", "e", "i", "BB", "a", "cb", "bb", "bf", "fb", "job", "binary", "ab", "rb", "db"], "valueAfterMD5": ["valueAfterAMD7", "valueBeforeMP2", "valueAfterMP5", "valueAfterVM3", "valueAfterAMD5", "valueAfterMP7", "valueAfterVM2", "valueBeforeMD3", "valueAfterMD3", "valueAfterVM7", "valueAfterAMD2", "valueAfterMP3", "valueBeforeMD2", "valueAfterMD2", "valueBeforeMP5", "valueBeforeMD7", "valueAfterAMD3", "valueAfterMP2", "valueBeforeMP3", "valueAfterVM5", "valueBeforeMP7", "valueAfterMD7"]}}
{"id1": "6421904", "id2": "18211588", "code1": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"addRecord": ["addrecord", " addFile", "appendFile", "createRec", "appendrecord", "appendRecord", "createRecord", "createFile", "addRec", "addFile", " addRec", "createrecord", " addrecord", "appendRec"], "input": ["resource", "temp", "media", "current", "instance", "context", "request", "xml", "http", "this", "active", "progress", "conn", "audio", "up", "document", "out", "storage", "exec", "load", "config", "php", "Input", "session", "hole", "value", "image", "inf", "reader", "data", "error", "raw", "null", "buffer", "stream", "text", "source", "form", "back", "flow"], "temporary": ["timemporary", "formporal", "emporal", "typorary", "separmanent", "temmanent", "exporary", "Temporary", "timperature", "tmermanent", "transolute", "destporary", "tempemporary", "tempperature", "exolute", "semporary", "formtemp", "tmperature", "theporal", "tmtemp", "separperature", "separporary", "tempporal", "tmemporary", "tememporary", "Temperature", "tomperature", "temperature", "mporal", "mporary", "temacher", "temtemp", "tommanent", "typoral", "emporary", "transporal", "tomporal", "tporal", "emperature", "theemporary", "temolute", "tytemp", "destporal", "transperature", "semperature", "semporal", "tmporal", "tymanent", "temptemp", "theermanent", "theporary", "timporary", "theperature", "formmanent", "tacher", "transporary", "destemporary", "separporal", "exporal", "destacher", "Temporal", "semmanent", "mperature", "timolute", "timermanent", "experature", "tomporary", "temporal", "formporary", "Temmanent", "tempporary", "typerature", "temermanent", "tmporary", "timporal", "Temtemp", "tmacher", "tporary", "thetemp"], "tempId": ["TempName", "fakeid", "TempPath", "fakeName", " tempid", "TempID", "tempPath", "Tempid", "tempID", "tempName", "tmpId", "tempid", "tmpID", "inputPath", "inputid", "poraryid", "inputID", " tempName", "TempId", "fakeId", "poraryId", "tmpid", "tmpPath", "inputId"], "length": ["distance", "section", "library", "position", "ob", "string", "description", "full", "capacity", "volume", "limit", "version", "total", "angle", "time", "shape", "path", "Length", "open", "sequence", "key", "slice", "number", "driver", "json", "download", "content", "count", "loc", "audio", "l", "width", "url", "load", "size", "read", "array", "code", "len", "value", "filename", "result", "ext", "range", "type", "write", "data", "style", "duration", "id", "offset", "lock", "text", "name"], "digest": ["signEST", " Digester", "fest", "decEST", "fests", " digests", "generEST", "Digester", "digraph", "signest", "Digested", "generist", " digEST", "digested", "digester", "decest", "DigEST", " digester", " digested", "generest", "signester", "fraph", "signraph", "decist", "digEST", " digraph", "Digist", " Digest", "generested", "signests", "decested", "signested", "digests", " DigEST", "Digest", "digist", "fester"], "output": ["resource", "temp", "application", "external", "exit", "channel", "response", "copy", "cut", "log", "tube", "outer", "export", "operation", "queue", "object", "letter", "address", "unit", "connection", "document", "out", "config", "office", "other", "control", "image", "socket", "writer", "plain", "result", "data", "write", "put", "target", "null", "message", "source", "web", "binary", "console", "Output"], "file": ["resource", "fe", "use", "function", "full", "current", "view", "http", "time", "log", "force", "place", "letter", "dir", "p", "l", "rule", "url", "pool", "image", "auto", "socket", "plain", "po", "uri", "or", "local", "cache", "comment", "feed", "this", "let", "user", "single", "play", "connection", "pe", "model", "per", "FILE", "other", "code", "real", "filename", "fp", "page", "data", "picture", "null", "message", "File", "folder", "live", "class", "entity", "word", "open", "queue", "document", "get", "work", "complete", "f", "home", "lib", "type", "id", "binary", "lock", "name", "temp", "line", "zip", "string", "self", "path", "object", "child", "unit", "handler", "it", "up", "base", "show", "future", "server", "php", "e", "directory", "style", "source", "buffer", "ile", "create"], "parent": ["resource", "temp", "large", "root", "or", "Parent", "class", "container", "full", "and", "cache", "current", "parents", "copy", "path", "fat", "key", "child", "dir", "unit", "handler", "p", "create", "part", "base", "out", "pa", "port", "location", "per", "home", "image", "to", "remote", "directory", "data", "type", "null", " Parent", "id", "source", "master", "block", "name"], "now": ["currently", "or", "NOW", "day", "cycle", "cmp", "not", "night", "current", "low", "hour", "view", "Now", "node", "time", "ci", "co", "from", "this", "post", "first", "ct", "active", " NOW", "age", "since", "cur", "max", "load", "wait", "size", "date", "comp", "set", "lim", "start", "today", "auto", "next", "last", "gen", "type", "id", "always", "info", "ow", "once"]}}
{"id1": "1141361", "id2": "11305840", "code1": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "label": 1, "substitutes": {"makeRead": [" makeREAD", "doREAD", "doRead", " executePut", " executeAdd", "executeAdd", "doPut", "executeREAD", "doAdd", "executePut", " executeRead", " executeREAD", " makeAdd", "executeRead", " makePut"], "user": ["item", "row", "token", "username", "use", "owner", "project", "blog", "string", "host", "word", "comment", "uid", "log", "post", "meta", "mode", "creator", "custom", "bug", "USER", "install", "server", "url", "usr", "date", "field", "admin", "password", "User", "author", "write", "pod", "human", "job", "users", "alias", "name", "db"], "databaseID": [" databaseid", "tableID", "DatabaseUID", " databaseName", "dbName", "DatabaseName", "databaseUID", "databaseid", "tableid", " databaseKey", "connectionid", " databaseUID", "connectionID", "DatabaseID", "databaseName", "databaseKey", "dbId", "DatabaseId", " databaseId", "tableKey", "dbID", "dbUID", "databaseId", "connectionKey"], "time": ["timeout", "times", "string", "instance", "host", "hour", "table", "depth", "str", "comment", "money", "path", "year", "post", "length", "Time", "mode", "tz", "month", "rate", "port", "clock", "size", "read", "date", "TIME", "value", "set", "home", "tim", "ime", "type", "id", "timer", "message", "source", "text", "name", "end"], "query": ["timeout", "function", "string", "join", "execute", "table", "request", "Query", "select", "script", "comment", "call", "report", "qu", "search", "sequence", "post", "database", "sql", "command", "connection", "work", "commit", "code", "q", "filter", "error", "question", "module", "ql", "eries", "message", "id", "update", "name", "db", "sq"], "statement": ["slave", "status", "study", "si", "use", "media", "section", "function", "string", "instance", "note", "execute", "join", "volume", "table", "expression", "str", "comment", "language", "state", "response", "di", "jo", "post", "this", "database", "sql", "opened", "unit", "command", "batch", "rule", "connection", "document", "s", "init", "agent", "storage", "server", "commit", "ma", "machine", "session", "usage", "ment", "i", "password", "journal", "stat", "result", "memory", "joined", "st", "Statement", "style", "parser", "message", "general", "mt", "alias", "builder"], "count": ["cache", "table", "depth", "limit", "total", "state", "more", "sum", "log", "Count", "number", "force", "list", "process", "length", "content", "child", "err", "batch", "cc", "part", "connection", "base", "cond", "expected", "size", "index", "code", "start", "check", "handle", "counter", "diff", "error", "type", "found", "id", "inc", "offset"]}}
{"id1": "3309233", "id2": "14598566", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doUsingAsync", " doAsyncConsole", "buildInAsync", " doAsBackground", " doAsyncAsync", "buildUsingStudio", "buildInStudio", " doAsConsole", "buildUsingConsole", " doUsingConsole", " doAsyncStudio", "buildInConsole", "buildUsingBackground", " doAsyncBackground", "buildInBackground", " doAsAsync", " doAsStudio", "buildUsingAsync", " doUsingBackground", " doUsingStudio", " doInConsole", " doInStudio", " doInAsync"], "params": ["reports", "names", "pm", "resources", "py", "lines", "values", "results", "eps", "options", "ctx", "objects", "Param", "details", "files", "json", "properties", "address", "arms", "p", "s", "ams", "pins", "Parameters", "ls", "los", "phrase", "strings", "sp", "config", "settings", "keys", "services", "i", "ds", "types", "Par", "page", "parts", "parse", "type", "posts", "data", "ps", "comments", "source", "par", "mes"], "param": ["temp", "pc", "aram", "pm", "project", "pri", "cm", "mand", "string", "channel", "iam", "pb", "option", " parameter", "km", "comment", "prem", "Parameter", "path", "ctx", "gram", "mor", "Param", "conn", "object", "address", "single", "p", "vm", "default", "proc", "connection", "amp", "part", "ams", "cp", "model", "contract", "ram", "config", "pool", "am", "rem", "arm", "password", "page", "prom", "meter", "null", "mm", "conf", "parent", "camp", "par", "name", "monitor", "lc"], "client": ["resource", "project", "cm", "c", "channel", "host", "request", "http", "proxy", "service", "response", "self", "con", "api", "force", "ce", "conn", "handler", "p", "bird", "cl", "app", "connection", "base", "cp", "server", "url", "help", "config", "cli", "comp", "session", "connect", "google", "ssl", "secure", "plugin", "apache", "Client"], "post": ["entry", "send", "zip", "c", "push", "and", "op", "pb", "request", "POST", "http", "comment", "response", "api", "patch", "feed", "add", "json", "pp", "wp", "p", "dd", "proc", "part", "base", "pos", "install", "upload", "server", "query", "load", "Post", "f", "e", "posted", "set", "head", "pre", "next", "pod", "submit", "put", "hop", "body", "form", "create"], "resp": ["resource", "Response", "status", "rep", "fc", "serv", "respond", "rec", "rh", "request", "reply", "http", "response", " response", "api", "json", "download", "conn", "content", "handler", "rel", "err", "exec", "server", "sp", "par", "enc", "e", "success", "received", "Resp", "res", "page", "error", "obj", "req", "comm", "body", "re", "ref"], "entity": ["resource", "body", "entry", "status", "attribute", "line", "string", "instance", "xml", "response", "node", "json", "object", "content", "conn", "translation", "unit", "connection", "base", "agent", "element", "event", "model", "ity", "coll", "article", "enc", "e", "code", "el", "output", "data", "obj", "ent", "ec", "Entity", "activity", "person"], "result": ["property", "resource", "entry", "row", "status", "line", "Result", "description", "string", "instance", "results", "response", "report", "desc", "match", "details", "place", "json", "object", "content", "address", "ret", "translation", "default", "url", "location", "name", "value", "success", "record", "res", "page", "output", "data", "message", "source", "text"]}}
{"id1": "13421722", "id2": "13362846", "code1": "    public static long getFileSize(String address) {\n        URL url = null;\n        try {\n            url = new URL(address);\n            System.err.println(\"Indirizzo valido - \" + url.toString().substring(0, 10) + \"...\");\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Indirizzo non valido!\");\n        }\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=0-\");\n            connection.connect();\n            return connection.getContentLength();\n        } catch (IOException ioe) {\n            System.err.println(\"I/O error!\");\n            return 0;\n        }\n    }\n", "code2": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getFileSize": ["getByteSize", " getfileInfo", "getFileBytes", " getfileBytes", "getFilesSize", "getFileLength", "getFilesBytes", "getByteBytes", " getFileBytes", "getfileLength", "getfileBytes", "getFileInfo", "getByteInfo", "getByteLength", " getfileLength", " getFileInfo", " getFileLength", "getfileSize", "getFilesLength", "getFilesInfo", " getfileSize", "getfileInfo"], "address": ["resource", "attribute", "route", "ip", "position", "string", "host", "Address", "request", "str", "path", "report", "number", "network", "email", "object", "content", "base", "prefix", "port", "server", "addr", "location", "config", "size", "array", "code", "localhost", "format", "output", "type", "data", "point", "target", "message", "offset", "uri", "source", "name", "reference"], "url": ["resource", "ob", "string", "channel", "host", "http", "xml", "str", "proxy", "service", "www", "URL", "path", "ll", "log", "ur", "api", "feed", "io", "Url", "impl", "object", "conn", "user", "orb", "bug", "loc", "lr", "build", "l", "base", "server", "location", "config", "sl", "f", "e", "session", "image", "lib", "socket", "page", "ssl", "html", "result", "found", "job", "web", "uri", "client", "org", "file"], "connection": ["resource", "or", "application", "entry", "use", "section", "function", "position", "c", "Connection", "channel", "current", "context", "environment", "request", "http", "proxy", "character", "service", "condition", "response", "con", "io", "open", "database", "relation", "conn", "object", "handler", "out", "event", "communication", "server", "config", "bc", "control", "session", "wrapper", "connect", "socket", "to", "connected", "info", "uri", "client", "collection", "version", "reference"]}}
{"id1": "15797402", "id2": "14758866", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"parse": [" transform", "wrap", "processing", "pc", "scan", " rewrite", "request", "view", "xml", "http", "cover", "service", "transform", "report", "patch", "process", " split", "print", " parsing", "rate", "replace", " parser", "fork", "Parser", " serve", "load", "read", "php", " analyse", "arse", "set", "worker", "split", " dispatch", "handle", "apply", "se", " convert", "save", "raw", " process", "pack", "parser"], "stream": ["resource", "temp", "draw", "channel", "view", "http", "inner", "src", "input", "response", "down", "feed", "in", "download", "content", "iterator", "sample", "video", "document", "Stream", "upload", "server", "url", "load", "loader", "read", "image", "through", "writer", "handle", "remote", "reader", "data", "raw", "stack", "message", "source", "client", "form", "file"], "handler": ["application", "function", "channel", "host", "pointer", "phase", "service", "response", "layer", "manager", "ctx", "di", "driver", "hand", "Handler", "default", "connection", "base", "event", "server", "loader", "processor", "controller", "wrapper", "writer", "format", "handle", "h", "reader", "data", "handled", "parser", "info", "parent", "client", "collection", "monitor"], "metadata": ["property", "resource", "attribute", "subject", "map", "management", "mx", "m", "xml", "state", "manager", "ctx", "params", "di", "meta", "database", "json", "properties", "content", "header", "runtime", "document", "metry", "connection", "storage", "component", "config", "processor", "adata", "material", "directory", "managed", "data", "mi", "mon", "md", "module", "plugin", "parser", "message", "info", "mt", "uri", "source", "collection", "met", "monitor", "template"], "context": ["resource", "txt", "entry", " Context", "subject", "cmp", "instance", "Context", "environment", "method", "request", "xml", "proxy", "scope", "concept", "manager", "ctx", "content", " contexts", "object", "translation", "command", "document", "mc", "connection", "element", "event", "component", "system", "config", "processor", "tx", "reader", "data", "kernel", "message", "parent", "text", "collection"], "name": ["Name", "names", "resource", "action", "large", "route", "class", "full", "n", "string", "m", "word", "call", "version", "comment", "named", "old", "time", "path", "label", "search", "api", "key", "none", "sync", "in", "active", "on", "no", "object", "address", "child", "missing", "default", "part", "base", "connection", "prefix", "model", "url", "work", "size", "code", "filename", "image", "ame", "NAME", "type", "data", "null", "id", "message", "job", "source", "alias", "file", "common"], "out": ["resource", "temp", "window", "line", "again", "instance", "channel", "o", "ex", "ray", "exp", "bin", "Out", "copy", "path", "manager", "io", "outs", "sync", "in", "object", "conn", "child", "user", "err", "connection", "server", "url", "cos", "pool", "image", "lib", "socket", "writer", "plain", "result", "page", "ext", "output", "data", "obj", "OUT", "null", "flush", "source", "client", "builder", "file", "extra"]}}
{"id1": "21092340", "id2": "88047", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addToAdaptives", "addtoArchIVE", "addToSlIVE", "addtoAsively", "addToArchively", "addToAdaptive", "addtoArchively", "addToArchIVE", "addToAdaptIVE", "addtoArchive", "addToAsIVE", "addToSlively", "addToAsively", "addToAsives", "addtoAsIVE", "addtoAsive", "addtoAsives", "addToSlives", "addtoArchives", "addToArchives", "addToAdaptively", "addToSlive", "addToAsive"], "pod": ["Pod", "pc", "od", "project", "zip", "cache", "host", "pi", "table", "pid", "pl", "node", "cer", "post", "pad", "ce", "object", "child", "ad", "p", "proc", "part", "pe", "tmp", "plug", "component", "pot", "loader", "bean", "per", "pkg", "peer", "product", "ods", "po", "module", "plugin"], "podArchiveOutputStream": ["podArchiveIOResource", "podArchiveByteStream", "podArchivingWriteStream", "podArchivingOutputFile", "podArchiveFileFile", "podArchivingOutputSteam", "podArchiveInputFile", "podArchivingOutputPath", "podArchiveWriteSteam", "podArchivesOutputSteam", "podArchIVEInputStream", "podArchivesFileFile", "podArchIVEInputDirectory", "podArchiveIOStream", "podArchiveIODirectory", "podArchiveInputSteam", "podArchiveWriteFile", "podArchiveFilePath", "podArchIVEOutputDirectory", "podArchivingWriteFile", "podArchiveOperationResource", "podArchiveOperationFile", "podArchiveIOSteam", "podArchIVEOutputSteam", "podArchiveWritePath", "podArchivesFileSteam", "podArchiveByteDirectory", "podArchiveOperationSteam", "podArchiveInputPath", "podArchivesFileResource", "podArchiveFileSteam", "podArchivingOutputStream", "podArchiveIOFile", "podArchiveOutputPath", "podArchiveFileResource", "podArchiveByteFile", "podArchIVEInputSteam", "podArchIVEInputFile", "podArchivesOutputStream", "podArchiveOperationStream", "podArchiveByteSteam", "podArchiveOutputSteam", "podArchivesFileStream", "podArchivingWriteSteam", "podArchIVEOutputFile", "podArchivesOutputFile", "podArchiveInputDirectory", "podArchIVEOutputStream", "podArchivesOutputResource", "podArchivingWritePath", "podArchiveFileStream", "podArchiveFileDirectory", "podArchiveOutputResource", "podArchiveInputStream", "podArchiveWriteStream", "podArchiveOutputFile", "podArchiveOutputDirectory"], "filename": ["folder", "il", "property", "application", "route", "subject", "username", "SourceFile", "string", "word", "sf", "title", "Filename", "named", "path", "kn", "label", "fil", "sequence", "platform", "files", "database", "ppa", "download", "archive", "fn", "alias", "l", "prefix", "ename", "url", "location", "loader", "f", "FILE", "dll", "fp", "nil", "directory", "module", "kl", "uri", "binary", "name", "which", "file"], "source": ["resource", "slave", "use", "seed", "zip", "string", "Source", "proxy", "service", "input", "copy", "ource", "path", "slice", "driver", "archive", "unit", "connection", "document", "url", "config", "loader", "sl", "image", "SOURCE", "result", "reader", "output", "target", "stack", "parent", "stream", "text", "uri", "src", "file"], "entry": ["resource", "row", "or", "line", "zip", "string", "pointer", "Entry", "ge", "path", "feed", "add", "post", "this", "object", "child", "address", "letter", "archive", "iterator", "ie", "it", "connection", "element", "event", "index", "article", "e", "image", "auto", "record", "result", "reader", "se", "data", "obj", "r", "parent", "stream", "file"]}}
{"id1": "3801655", "id2": "732800", "code1": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"helper": ["shp", "scheper", "helpler", "helppherd", "Helper", "sher", "heller", "Heler", "harler", "harpherd", "Help", "helpHelper", "shmer", "workper", "scheler", "schepherd", "helpherd", "shper", "helpper", "workp", "heler", "help", "worker", "scheHelper", "helmer", "helHelper", "Helmer", "harHelper", "harper", "workmer"], "dataset": [" DatASet", "datAset", "DatASET", "datasert", "datASheet", "DatasET", "datapset", "metaset", "datASets", "datastET", "metasET", "datAsets", "datassET", "metassert", "datassets", "datraset", " DatasET", "datrasET", "datASET", " Dataset", "datassheet", "datasET", " DatASheet", "DatASets", "metassET", " Datasets", "datastets", "Dataseter", "DatASeter", "datapsert", "datacet", "datapsheet", " DatASets", "metassheet", "datacET", "datacert", "datacheet", "metasert", " Datasheet", "Datasets", "datassert", "datapsET", "datASet", " DatASET", "datAsheet", "datrasets", "metasheet", "datasteter", "datASeter", "dataseter", "datAsET", "datasset", "Dataset", "datasheet", "metasset", "DatASet", "datraseter", "datastet", "datasets"], "zip": ["folder", "pipe", "wrap", "window", "pdf", "ip", "py", "xml", "service", "copy", "java", "io", "z", "slice", "tar", "zone", "Zip", "dir", "archive", "handler", "bug", "p", "bag", "out", "sea", "system", "sl", "f", "flat", "pkg", "code", "gz", "split", "ssl", "se", "secure", "data", "parse", "directory", "plugin", "pack", "jar", "git", "lock", "binary", "loop", "source", "file"], "entries": ["delements", "ENTrees", "ntents", "entlines", "entslections", "itrys", " entlines", "entrants", "itries", "iterries", " entlements", "intlements", "ENTries", "intities", "deents", "inflines", "deries", "entsries", "contrys", "contries", "ntries", "infities", "infrees", "entrees", "intries", "ENTlections", " entities", "entsrants", "itents", "contents", "entrys", "entryents", "itry", "entities", "ntrys", "ntry", "iterlements", "entents", "inflements", "iterents", "intlines", "inflections", "contry", "ENTrants", "entsrees", "infries", "entryries", "entlements", "entrylements", "entlections", "infrants"], "performance": [" writers", "slave", "each", "stats", "union", " ratio", "U", " unit", "Unit", "util", " units", "ui", " split", "unit", "book", "it", " Units", "exec", "work", "rank", "its", "ul", "units", " Unit", " u", " result", "runner", " group", " output", " suite"], "index": ["position", "depth", "limit", "Index", "path", "key", "number", "num", "length", "count", "unit", "order", "pos", "x", "iter", "i", "value", "head", "page", "level", "type", "write", "id", "offset", "name"], "entry": ["folder", "row", "or", "route", "ry", "section", "si", "xml", "Entry", "inner", "service", "input", "export", "feed", "key", "add", "post", "in", "child", "archive", "ie", "it", "connection", "part", "cell", "element", "pe", "install", "server", "office", "e", "her", "record", "result", "nt", "se", "data", "write", "obj", "parse", "r", "style", "pattern", "info", "uri", "stream", "cel", "file", "lc"], "temp": ["folder", "wrap", "txt", "pipe", "local", "full", "clean", "cache", "context", "table", "http", " temporary", "input", "copy", "path", "partial", "io", "ctx", "empty", "dest", "original", "archive", "single", "p", "store", "valid", "part", "w", "base", "out", "storage", "layout", "tmp", "thread", "tem", "config", "office", "fake", "f", "flat", "iter", "session", "emp", "tc", "test", "output", "Temp", "data", "directory", "stable", "porary", "parent", "lock", "binary", "cel", "file", "template"], "writer": ["riter", "or", "war", "writers", "player", "wer", "inner", "ler", "layer", "log", "outer", "manager", "Writer", "io", "engine", "wave", "key", "feed", "driver", "handler", "er", "wire", "w", "sw", "out", "element", "server", "loader", "ws", "per", "iter", "holder", "rw", "wrapper", "worker", "editor", "wr", "output", "writing", "write", "written", "author", "r", "stream", "builder", "file"], "reader": ["or", "ry", "ter", "reading", "upper", "oder", "http", "inner", "ler", "input", "io", "ner", "feed", "driver", "ri", "handler", "er", "iterator", "element", "server", "loader", "Reader", "iter", "rer", "per", "f", "wrapper", "i", "worker", "editor", "ser", "write", "rr", "r", "rar", "stream", "builder", "file"], "buffer": ["resource", "row", "seed", "position", "channel", "initial", "capacity", "table", "uffer", "limit", "character", "input", "layer", "wave", "sequence", "feed", "buf", "queue", "slice", "length", "address", "header", "batch", "document", "device", "server", "size", "Buffer", "iter", "bytes", "transfer", "result", "memory", "data", "write", "null", "buff", "flush", "message", "offset", "source", "binary", "reference"], "read": ["reads", "pass", "run", "use", "send", "g", "k", "readable", "current", "reading", "view", "fill", "select", "sleep", "available", "input", "copy", "READ", "old", "report", "open", "feed", "process", "eval", "add", "text", "skip", "sync", "download", "length", "child", "count", "book", "build", "print", "Read", "play", "ad", "seek", "default", "exec", "find", "get", "load", "work", "config", "size", "max", "x", "wait", "iter", "allow", "ind", "check", "start", "close", "ride", "next", "save", "parse", "write", "data", "type", "se", "raw", "id", "connect", "create", "end"], "outfile": ["inline", "Outline", " outline", "logdata", "logfile", "Outf", " outFile", "againfile", "outline", "outdir", " outf", "infile", "outdata", "outfilename", " outdata", "instream", " outfilename", "Outfile", "againdir", "outf", "logFile", "inFile", "indata", "logfilename", "inf", "outFile", "againline", "Outdir", "infilename", "Outstream", " outstream", "indir", "outstream", "againstream"], "line": ["item", "inline", "look", "band", "pass", "status", "row", "section", "ip", "string", "lines", "word", "LINE", "ine", "str", "comment", "le", "Line", "side", "log", "sync", "on", "object", "letter", "header", "frame", "l", "lin", "cell", "url", "link", "code", "cle", "strip", "el", "split", "val", "page", "filter", "range", "error", "data", "parse", "type", "style", "lf", "job", "sel", "text", "block", "column", "name", "file", "end"], "parser": ["class", "function", "string", "oder", "xml", "ler", "manager", "params", "umper", "angler", "driver", "er", "handler", "book", "p", "cher", "server", "Parser", "system", "loader", "processor", "pool", "per", "lp", "wrapper", "worker", "plan", "arser", "test", "parse", "data", "type", "plugin", "r", "pattern", "par", "builder"], "list": ["group", "and", "map", "join", "table", "right", "can", "match", "listed", "er", "p", "LIST", "l", "part", "base", "all", "out", "chain", "get", "left", "array", "pool", "other", "lp", "best", "li", "set", "plan", "val", "v", "result", "test", "filter", "data", "type", "member", "r", "lists", "info", "parent", "collection"], "rule": ["item", "row", "group", "class", "function", "ule", "table", "str", "ee", "service", "layer", "match", "tree", "Rule", "rl", "ri", "header", "er", "lr", "dict", "base", "rate", "pe", "model", "event", "per", "field", "li", "ul", "record", "val", "rules", "range", "data", "rol", "parse", "style", "r", "plugin"], "measure": ["Measured", "speasure", "measured", "speasures", "Measure", "feasuring", "measuring", "speasured", "feasured", "feasure", "feasures", "Measuring", "Measures", "speasuring", "measures"]}}
{"id1": "838844", "id2": "4716110", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "subverting", "unverted", "Conversion", "converted", "CONverted", "unception", "CONverting", "conversion", " deconverting", "Convert", " deconvert", "conception", " deconverted", "subversion", "oconverted", "Conception", "subverted", "CONception", "oconvert", "oconversion", "subvert", "unvert", "CONversion", "CONvert", "converting", " deconversion", "unversion", "Converted", "oconverting"], "src": ["resource", "scene", "stage", "sth", "username", "cmp", "SourceFile", "string", "href", "Source", "spec", "cpp", "dist", "input", "ource", "path", "inst", "ctx", "sc", "buf", "slice", "sys", "attr", "rl", "download", "impl", "fn", "loc", "proc", "video", "gb", "s", "rc", "storage", "upload", "tmp", "url", "component", "load", "sn", "config", "sb", "code", "gz", "filename", "sin", "Dest", "fp", "cb", "ssl", "img", "reader", "st", "RC", "supp", "secure", "obj", "req", "feat", "rb", "prot", "back", "source", "stream", "uri", "sel", "name", "sit", "file", "ref"], "dest": ["dc", "txt", "temp", "class", " dst", "dat", "dist", "bin", "path", "di", "disk", "dir", "fn", "orig", "tmp", "home", "lib", "Dest", "std", "img", "test", "obj", "target", "null", " destination", "source", "cont"], "in": ["In", "inas", "pass", "ini", "n", "IN", "ex", "is", "d", "din", "bin", "input", "as", "io", "pin", "ins", "doc", "inn", "err", "up", "isin", "win", "f", "i", "a", "inf", "val", "login", "reader", "data", "r", "ps", "t", "inc", "source", "stream", "file"], "p": ["pc", "cop", "pd", "pm", "g", "c", "pr", "pi", "op", "py", "pb", "pg", "o", "m", "d", "np", "pp", "bp", "tp", "wp", "l", "part", "s", "pe", "cp", "pa", "j", "sp", "per", "f", "e", "lp", "i", "pre", "h", "fp", "v", "P", "jp", "r", "po", "ps", "t", "parser", "b"], "ds": ["dc", "hs", "words", "dl", "gs", "da", "obs", "s", "icks", "ges", "dm", "ts", "sts", "db", "df", "js", "pd", "bs", "ys", "dat", "lines", "dos", "d", "utils", "ads", "styles", " props", " sd", "amps", "ld", "ans", "Ds", "lp", "ns", "data", "posts", "parts", "docs", "ps", "DS", "ss", "dp", "scripts", "uds", "di", "os", "sync", "sys", "ins", "xs", "tests", "dds", "ls", "dt", "cs", "des", "nas", " DS", "ups", "ks", "eps", "dist", "cons", "ays", "tools", "ants", "groups", "plugins", "dd", "qs", "vs", "services", "dates", "ths", "els", "gd", "ded", "vals", "points", "ils", " ps", "ipes", "rs", "models"], "format": ["struct", "class", "function", "at", "act", "string", "host", "table", "spec", "version", "language", "atter", "path", "fd", "api", "magic", "letter", "unit", "handler", "fn", "frame", "nat", "scale", "tag", "part", "layout", "Format", "model", "prefix", "ant", "url", "config", "f", "sche", "filename", "record", "fp", "filter", "data", "type", "feat", "style", "plugin", "t", "parser", "pattern", "source", "form", "name", "file", "template"], "hasPixelData": ["showsPixeldata", "haspixeldata", "showsPixelDATA", "hasByteDATA", "hasPixeldata", "hasPixelDATA", "showsPixelStyle", " hasPixelSize", " hasPixeldata", "showsBytedata", "showsByteStyle", "haspixelSize", "showsPixelData", "hasByteData", "hasByteStyle", "hasBytedata", "haspixelData", "hasPixelStyle", "showsByteData", "hasPicturedata", "hasByteSize", "hasPictureSize", "hasPixelSize", "hasPictureData", "showsByteDATA"], "inflate": ["inFlated", "inadequating", "infloace", "insflode", "InFlate", "infolATE", "inadequode", "insvenATE", "inFlate", "insflating", "InFlace", "insflATE", "inffated", "inflation", "invenate", "inflace", "infolode", "inFlation", "infloate", "insvenate", "invenATE", "infloated", "inffation", "invenating", "InFlated", "insvenating", "insflate", "inflATE", "inflating", "Inflace", "infface", "inFlace", "infolate", "Inflated", "inffate", "Inflate", "inadequate", "insvenode", "inflated", "infolating", "infloation", "inflode", "invenode", "Inflation", "InFlation", "inadequATE"], "pxlen": ["fxdata", "pnglen", "pxlin", "mxln", "axlon", "pxcount", "fxln", "pglen", "txln", "pcln", "ppl", "pxlon", "txlin", "camlen", "fxl", "pgden", "pngsize", "axlin", "mxlen", "camln", "fxden", "xplength", "ppLen", "mxdata", "pxLen", "pxdata", "pclen", "pclin", "axln", "pxln", "axlen", "txlen", "pngcount", "campos", "mxpos", "fxLen", "xpsize", "xpcount", "pxsize", "pgl", "pxpos", "ppden", "pgLen", "fxpos", "pxlength", "fxlen", "mxlength", "mxcount", "xplen", "mxsize", "camdata", "pxden", "pclon", "pplen", "pxl", "pnglength", "txlon"], "out": ["group", "line", "again", "cache", "step", "inter", "state", "Out", "copy", "log", "io", "outs", "list", "co", "post", "sys", "pad", "user", "conn", "store", "err", "up", "server", "query", "work", "cli", "session", "dump", "lib", "v", "page", "output", "gen", "error", "obj", "OUT", "point", "parent", "lock", "re"]}}
{"id1": "18891988", "id2": "310182", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["downloadFile", "downloadfile", "loadFilename", "GetFile", "loadString", "GetFilename", "downloadFilename", "Getfile", "getString", "getfile", "getFilename", "GetString", "loadFile", "downloadString", "loadfile"], "serviceName": [" servicename", " servicePath", " serviceType", "ServiceUrl", "projectUrl", "projectName", "packagename", "ServiceName", "Servicename", "ServicePath", "servicename", "packagePath", "packageUrl", "ServiceType", "projectPath", "projectType", "servicePath", " serviceUrl", "packageName", "serviceType", "serviceUrl"], "wsdlLocation": ["wllFolder", "wsdlAddress", "wdlAddress", "wsDLUrl", "wslDirectory", "wdlFile", "awsdlUrl", "wsDLDirectory", "wsDLFile", "wsllDirectory", "awslFile", "awsdlDirectory", "wdlLocation", "awslLocation", "wssdFolder", "wslpFolder", "wslpDirectory", "wsllFolder", "wddlFile", "wsslFile", "wsllLocation", "wdlDirectory", "wsllFile", "wllLocation", "wslFile", "wdlFolder", "wssdFile", "wddlLocation", "wsslFolder", "wsdlDirectory", "wslUrl", "wslpFile", "wddlDirectory", "wsslAddress", "wsdlUrl", "awsdlFile", "wsdlFolder", "awsdlLocation", "wsllUrl", "wsslLocation", "wsdlFile", "wslLocation", "wsllAddress", "awslUrl", "wslpLocation", "wllAddress", "wddlFolder", "awslDirectory", "wssdLocation", "wslFolder", "wssdAddress", "wllFile", "wsDLLocation"], "endpoint": ["endsocol", "ENDpoint", "startaddress", "Endpoints", "endaddress", "ENDination", "startpointer", "Endword", "Endocol", "endocol", "startpoint", "Endpo", "enination", " endpointer", " endpo", "endspo", "enPoint", "endspoint", "enpoints", "enpointer", "endsword", "EndPoint", " endaddress", "ENDpoints", " endword", "endination", "endword", "ENDPoint", "Endpoint", "endpoints", "Endination", "enaddress", "enpoint", "endPoint", " endocol", " endPoint", "endpointer", "startPoint", "endpo"], "fileLocation": ["FileUrl", "fileDirectory", "FileURI", "fileUrl", " fileDirectory", "FILELocation", " fileURI", "FILEURI", "FILEDirectory", " fileUrl", "fileURI", "FileDirectory", "FileLocation", "FILEUrl"], "tempDir": [" temporaryDirectory", "tempdir", " temporaryVer", " tempDirectory", " tempPath", "TempPath", "tmpVer", "TempDir", "tmpdir", "tempVer", "tempPath", " tempdir", " temporaryPath", "tempDirectory", " tempVer", " temporaryDir", "tmpDir", "tmpDirectory", "Tempdir", "TempDirectory", "tmpPath"], "url": ["pull", "string", "channel", "host", "http", "service", "www", "URL", "log", "ll", "path", "ur", "io", "open", "contact", "Url", "download", "conn", "address", "l", "connection", "base", "ls", "server", "coll", "config", "sl", "f", "ul", "el", "image", "socket", "ssl", "fl", "web", "uri", "stream", "client", "source", "file"], "WSDLFile": ["WSDLLPath", "WSDLLFile", "WINDLFolder", "WSDlfile", "WSDlPath", "WDDlPath", "WDDlFile", "WSDELFiles", "WSDLLfile", "WSDELFile", "WSDLLFolder", "WSDDLPath", "WSDDLSourceFile", "WSDLFolder", "WSDLLFiles", "WSDDLFolder", "WDDlBase", "WINDELPath", "WSDLLBase", "WDDlfile", "WSDLPath", "WSDELFolder", "WSDLSourceFile", "WDDlFolder", "WDDLfile", "WDDLPath", "WINDELFolder", "WDDLFolder", "WINDELFile", "WDDlSourceFile", "WSDDLFile", "WSDELPath", "WSDLLSourceFile", "WDDLFile", "WINDLFile", "WSDLfile", "WINDLFiles", "WINDLPath", "WSDlSourceFile", "WSDlFolder", "WDDLBase", "WSDLBase", "WSDLFiles", "WSDDLfile", "WSDlBase", "WSDlFile", "WDDLSourceFile", "WINDELFiles", "WSDDLBase", "WSDDLFiles"], "tmpWSDLFile": ["tmpWDDLUrl", "tmpWSDDLFile", "tmpWSDLLFolder", "tmpWDDlFolder", "tmpWSDLLUrl", "tmpWDDlFiles", "tmpWDDLFiles", "tmpWSDlFile", "tmpWDDLLocation", "tmpWSDlFiles", "tmpWSDELFile", "tmpWSDLLFiles", "tmpWSDLUrl", "tmpWSDELFolder", "tmpWDDlFile", "tmpWDDELFile", "tmpWSDlFolder", "tmpWSDDLUrl", "tmpWSDELUrl", "tmpWSDLLocation", "tmpWSDLLFile", "tmpWSDELFiles", "tmpWDDELUrl", "tmpWSDELLocation", "tmpWSDDLFiles", "tmpWSDlLocation", "tmpWDDELFiles", "tmpWDDlUrl", "tmpWSDlUrl", "tmpWSDDLLocation", "tmpWDDELLocation", "tmpWSDLFiles", "tmpWDDLFile", "tmpWDDLFolder", "tmpWSDLFolder"], "inputFile": ["inDir", " inputDir", "Inputfile", " inputPage", " inputPlace", " inputfile", "outputFile", " inputStream", "tempBuffer", "inputStream", "inputUrl", "requestfile", " inputUrl", "inputFiles", "infile", "requestFile", "tempBase", "inPage", " inputFiles", "inputFactory", " inputBase", "InputFactory", "inputBuffer", "InputBase", "InputFile", "requestFiles", "InputFiles", "tempFile", "InputPlace", "InputPage", "inputDir", "outputDir", "inputfile", "inFile", " inputBuffer", "InputBuffer", "tempfile", "tempPage", "inputPage", " inputFactory", "outputfile", "tempUrl", "inputBase", "outputFiles", "InputUrl", "requestStream", "inputPlace", "InputStream", "tempPlace", "tempFactory", "InputDir"], "tmpFile": ["tempFiles", "uploadFile", " tmpPage", " tmpDirectory", "tempDocument", "uploadFiles", "uploadStream", "inputStream", "TempPage", "tempStream", "tmpPage", "inputFiles", "TempFiles", "tmpFiles", "inputDocument", "tempFile", "tmpStream", "tempDirectory", " tmpFiles", "tempPage", "TempFile", "tmpDirectory", "uploadDocument", "TempDirectory"], "in": ["In", "again", "c", "IN", "m", "is", "inner", "din", "bin", "input", "pin", "ins", "impl", "on", "conn", "inn", "p", "up", "l", "connection", "init", "win", "lin", "gin", "f", "image", "socket", "login", "ssl", "reader", "data", "r", "inc", "id", "source", "lock", "client", "file"], "out": ["timeout", "In", "ch", "group", "line", "again", "c", "channel", "IN", "cache", "o", "inner", "bin", "Out", "input", "conv", "copy", "outer", "log", "io", "can", "outs", "co", "sync", "on", "conn", "err", "up", "connection", "net", "part", "server", "image", "socket", "writer", "to", "output", "error", "OUT", "inc", "conf", "parent", "source", "client", "name", "file"], "con": ["ch", "ctrl", "fc", "cm", "c", "channel", "IN", "rec", "inner", "Conn", "conv", "can", "open", "co", "sync", "ins", "client", "ran", "conn", "kin", "connection", "win", "cn", "rc", "gin", "bc", "thin", "CON", "Con", "socket", "uc", "close", "plain", "ssl", "en", "inc", "nc", "conf", "com", "connect", "un"], "fileLength": ["FileLen", "fileSize", " fileSize", "FileWidth", "filelength", "channelLen", "contentLength", "contentLen", "contentlength", "Filelength", " fileLen", "channelSize", "contentSize", " fileWidth", "fileWidth", " filelength", "FileSize", "fileLen", "channelWidth", "FileLength", "channelLength"], "channelIn": [" channelIN", "ChannelOut", "characterin", "connectionin", "Channelin", " channelConn", "characterIn", "resourceIn", "connectionIn", " channelin", "resourceOut", "characterIN", "ChannelIn", "resourcein", "resourceIN", "ChannelIN", "connectionOut", "channelConn", "ChannelConn", "channelIN", "channelin", "connectionConn", "characterOut"], "channelOut": ["canOutside", " channelout", "canOUT", "ChannelOut", "ChannelOUT", "canOut", "channelOUT", "connectionOutput", "connectionout", "connectionIn", " channelOutput", "connectionOutside", "chanOUT", "Channelout", "channelOutside", "chanIn", "chanOutside", "ChannelIn", "connectionOut", "canIn", "chanOut", "ChannelOutside", "channelOutput", "chanout", "channelout", "ChannelOutput"], "tmpDocument": ["newFile", "tmpContent", "mpDocument", "tempDocument", "tmpDoc", "tmDocument", "tmdocument", "newdocument", " tmpContent", "mpFile", "tempdocument", "newDocument", "tmFile", " tmpdocument", "tmpdocument", "tempFile", " tmpNode", "tempNode", "tempContent", "tmpNode", "newContent", "tmNode", "mpDoc", " tmpDoc", "tempDoc", "mpNode"], "nl1": ["nn0", "NL0", "ln2", "kl1", "arlone", "arl1", "dl0", "kl5", "dl2", "nn2", "nlone", "ln11", "arlFirst", "arl5", "ln1", "NL11", "jl5", "ln6", "nl5", "NL6", "nl2", "nl6", "jlFirst", "nn6", "nlFirst", "NL2", "nn1", "dl1", "klone", "nl0", "nl11", "jlone", "klFirst", "NL1", "nn11", "jl1"], "i": ["iu", "hi", "si", "chi", "qi", "ip", "u", "multi", "ini", "ii", "n", "m", "pi", "y", "o", "d", "abi", "ci", "di", "io", "z", "slice", "ji", "ui", "ri", "bi", "ie", "p", "it", "l", "part", "phi", "j", "I", "fi", "uli", "eni", "index", "f", "e", "oi", "li", "ni", "v", "gi", "ti", "mi", "ai", "yi", "b", "xi", "id", "info", "uri", "ix", "mu"], "node1": ["node0", "layer91", "packageone", "shape91", "package91", "n1", "Node0", "Node2", " nodeOne", "nodeOne", "node91", "NodeOne", "Node91", "packageOne", "n0", "layer1", "package1", " node0", "layer2", " node2", "nodeone", "shapeone", "node2", " nodeone", "nOne", "layerOne", " node91", "shape1", "n2", "shapeOne", "Node1"], "tmpOut": ["tmpWriter", "tempOUT", " tmpWriter", "tmpout", "tmpOUT", " tmpIn", "txtout", "tempOut", "tempOutput", "tmpIn", "vmIn", "tempout", "cacheOUT", "ptyOutput", "txtWriter", "cacheIn", " tmpOUT", "cacheOut", " tmpOutput", "txtOut", "ptyout", "vmOut", "cacheFile", "tmpOutput", " tmpout", "tempFile", "ptyIn", "tempIn", "tempWriter", "ptyOut", "vmOUT", "txtOutput", "vmout"], "retVal": ["valObj", " retval", "RETVal", "valVal", "valRet", "RETObj", " retObj", "RETval", " retRet", "retObj", "retval", "RETRet", "retRet", "valval"]}}
{"id1": "13439950", "id2": "11334468", "code1": "    public String readRemoteFile() throws IOException {\n        String response = \"\";\n        boolean eof = false;\n        URL url = new URL(StaticData.remoteFile);\n        InputStream is = url.openStream();\n        BufferedReader br = new BufferedReader(new InputStreamReader(is));\n        String s;\n        s = br.readLine();\n        response = s;\n        while (!eof) {\n            try {\n                s = br.readLine();\n                if (s == null) {\n                    eof = true;\n                    br.close();\n                } else response += s;\n            } catch (EOFException eo) {\n                eof = true;\n            } catch (IOException e) {\n                System.out.println(\"IO Error : \" + e.getMessage());\n            }\n        }\n        return response;\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"readRemoteFile": ["readStaticfile", "loadremotefile", "loadremoteResponse", "loadRemoteResponse", "readLocalFile", "readStaticFile", "readLocalResponse", "readStaticResponse", "loadremoteFiles", "loadRemotefile", "readremoteFiles", "readRemoteFiles", "readRemoteResponse", "loadRemoteFile", "readremoteResponse", "readStaticFiles", "readRemotefile", "readremoteFile", "loadremoteFile", "readremotefile", "loadRemoteFiles", "readLocalFiles", "readLocalfile"], "response": ["Response", "resource", "application", "status", "line", "description", "respond", "respons", "string", "site", "reply", "request", "http", "results", "service", "answer", "api", "feed", "onse", "json", "content", "object", "resp", "offer", "ception", "out", "server", "array", "e", "i", "value", "example", "res", "result", "next", "output", "error", "data", "message", "uri", "body", "ss"], "url": ["resource", "ob", "zip", "host", "http", "str", "URL", "ur", "open", "io", "Url", "rl", "impl", "bel", "browser", "l", "base", "ls", "server", "plug", "sl", "f", "i", "remote", "file", "ssl", "r", "b", "jar", "web", "uri", "stream", "org", "fr", "ref"], "is": ["ib", "or", "ip", "ios", "bs", "ir", "http", "str", "was", "has", "as", "api", "ais", "io", "os", "IS", "sr", "in", "ri", "are", "it", "fs", "Is", "out", "iso", "ar", "iss", "sp", "its", "i", "close", "res", "bis", "r", "b", "id", "es", "info", "uri", "src", "ris", "fr"], "br": ["ib", "body", "ch", "bh", "serv", "ob", "http", "str", "ber", "be", "io", "os", "buf", "rt", "sr", "bro", "BR", "tr", "mr", "bridge", "gr", "orb", "er", "err", "rel", "bl", "browser", "cr", "arr", "sp", "dr", "iter", "bar", "i", "res", "cb", "result", "bb", "reader", "img", "hr", "obj", "r", "b", "fb", "bed", "stream", "ab", "rb", "fr"], "s": ["resource", "status", "js", "si", "S", "u", "ses", "n", "string", "c", "m", "g", "lines", "o", "results", "sym", "sf", "str", "d", "input", "os", "details", "sr", "content", "single", "sample", "p", "l", "strings", "ls", "shell", "ws", "sl", "f", "services", "sb", "e", "su", "session", "i", "ns", "bytes", "res", "result", "ssl", "v", "data", "raw", "sv", "r", "b", "ps", "t", "message", "es", "rs", "source", "null", "site", "ss"], "eof": ["eoh", "eeoh", "oeof", "eif", "Eom", "Eok", "eol", "oeoh", "eeok", "geif", "eeef", "yeof", "eef", " eol", "EOF", "oeol", "ueom", "eaf", "Eoh", "yeOF", "ueof", "geore", "oeok", "eom", "Eaf", " eom", "eeol", "ueaf", "geOF", "ueOF", "geof", "eore", "eeaf", "Eef", "eok", "eeof", "Eif", " eaf", "Eore", "eOF", " eef", "yeif", "Eol", "yeore", " eOF", "Eof"]}}
{"id1": "7872659", "id2": "19739421", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndmovieindexfile", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndMovieindexPath", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndmovieIndexfile", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndMovieIndexPath"], "completePath": [" CompleteHome", "successPath", " completePoint", "completeDir", "completeCh", "correctPoint", "progressLoader", "itepath", "progresspath", "completeFile", "correctRoot", " CompleteFile", "donePath", "execLoader", " completepath", "donepath", "successMusic", " completeCorp", " completeRoot", "CompletePath", "completeLoader", "completepath", "flatPoint", "itePath", "progressVol", "successpath", "correctCorp", "iteCh", " completeDir", "execPath", " completeMusic", "CompleteFile", "execVol", "doneLoader", "completeVol", "completeMusic", "completeRoot", "iteMusic", "execpath", "flatCorp", "completeCorp", "CompleteDir", "correctPath", " CompleteDir", "flatPath", " completeFile", " completeHome", "progressPath", "completePoint", " CompletePath", "flatRoot", "CompleteHome", "doneVol", "successCh", " completeCh", "completeHome"], "masterFile": ["cacheFILE", "masterName", "mastersFILE", "MasterFilename", "configName", "masterFilename", "MasterName", "mastersFile", "MasterFile", "configPath", "configFilename", "MasterPath", "mastersPath", "masterFILE", "masterPath", " masterPath", "cacheFile", "masterFiles", "configFile", "cacheFiles", "MasterFiles", "mastersFiles", " masterFilename", "cachePath", "MasterFILE", " masterName"], "CustRatingFileName": ["CustRateFilenameSize", "CustIndexFileName", "CustIndexFileVersion", "CustRatingLineName", "CustIndexFilesName", "CustRateFilePath", "CustIndexFileType", "CustRatingLineVersion", "CustRateFilenameDesc", "CustRatingClassPath", "CustIndexFilesType", "CustRatingFullDesc", "CustRatingFileType", "CustRatingFullPath", "CustRatingLinePath", "CustRatingLineType", "CustRatingFilenamePath", "CustRatingClassVersion", "CustRateFileSize", "CustRatingFilenameName", "CustRatingFileSize", "CustRatingClassName", "CustRatingFileDesc", "CustRateFilenameName", "CustRatingFilesPath", "CustRatingFilesDesc", "CustRatingFilesType", "CustRatingFilesName", "CustRatingFullSize", "CustRateFileName", "CustRateFileDesc", "CustIndexFilesVersion", "CustRatingClassType", "CustRatingFilesSize", "CustRateFilenamePath", "CustIndexFilePath", "CustRatingFilenameSize", "CustRatingFullName", "CustRatingFileVersion", "CustRatingFilePath", "CustIndexFilesPath", "CustRatingFilesVersion", "CustRatingFilenameDesc"], "MovieIndexFileName": ["MovieEditFUrl", "MovieConfigFileName", "MovieIndexFolderFile", "MovieIndexFName", "MovieIndexFSize", "MovieEditFileName", "MovieConfigFileFile", "MovieIndexClassSize", "MovieConfigFileVersion", "MovieIndexFolderName", "MovieIndexFILEFile", "MovieEditFileUrl", "MovieIndexFUrl", "MovieIndexClassName", "MovieConfigFolderVersion", "MovieEditFSize", "MovieIndexPlaceVersion", "MovieEditFileSize", "MovieIndexPlaceFile", "MovieIndexClassname", "MovieIndexFileFile", "MovieIndexFileVersion", "MovieEditFname", "MovieIndexClassUrl", "MovieIndexFileUrl", "MovieIndexFilesName", "MovieEditFilename", "MovieConfigFileHandle", "MovieIndexFilesname", "MovieConfigFolderName", "MovieIndexFilesUrl", "MovieIndexPlaceName", "MovieConfigFolderFile", "MovieIndexPlaceHandle", "MovieIndexFilename", "MovieIndexFILEHandle", "MovieIndexFname", "MovieIndexFileHandle", "MovieIndexFILEVersion", "MovieIndexFolderHandle", "MovieIndexFolderVersion", "MovieEditFName", "MovieIndexFILEName", "MovieIndexFileSize", "MovieConfigFolderHandle", "MovieIndexFilesSize"], "inFile": ["outfile", "outSourceFile", "incSourceFile", "inputFile", " infile", "outC", "InSourceFile", "inputSourceFile", "inF", " inF", "infile", "incC", "Infile", "InF", "InFile", "inputfile", " inSourceFile", "inSourceFile", "outFile", "inputF", "incFile", "incfile"], "inC": ["inCI", "outCL", " inCL", " inCC", "inputFile", "inputC", "innerCI", "outC", "inB", "InB", " inB", "inF", " inF", "inCC", "innerCC", "InCI", "InF", "innerC", "outF", "InFile", "outCC", "InC", "outFile", "InCC", "inputF", "inputCC", "outCI", "inCL", "outB", "innerFile", "InCL"], "outFile1": ["outPath1", "againCFirst", "outPlace1", "outputfileId", "outF2", "outputfile2", "outputFileId", "outFilesFirst", "outPath2", "outfile1", "outFName", "againFile2", "outFiles3", "outFiles2", "outFId", "againC3", "outPathFirst", "outfile2", "againC1", "outputFileName", "outputfile1", "outPlaceId", "outF1", "outFiles1", "outFileId", "outFileName", "outputFile1", "outC3", "outputfileName", "againC2", "outPlace2", "outPlaceName", "againFile3", "againFile1", "outCFirst", "outfileId", "outFile3", "outFileFirst", "againFileFirst", "outfileName", "outputFile2", "outPath3"], "outC1": ["outF8", "newc81", "outFOne", "againB2", "outCFOne", "outB2", "outF2", "outB8", "outDOne", "newC81", "againB8", "outcFirst", "newcOne", "outD81", "outCOne", "againC8", "outD1", "outB1", "outD8", "newc1", "againC1", "outBOne", "outC81", "outF1", "newC1", "newCFirst", "outD2", "againC2", "outDFirst", "outc81", "againCOne", "newCOne", "outCFFirst", "againB1", "outCFirst", "outCF1", "outC8", "newcFirst", "againBOne", "outc1", "outCF81", "outcOne"], "outFile2": ["againLine2", "outputfileTwo", "outputFile5", "outChannel1", "outfile5", "outFiles4", "outFilesTwo", "outChannel6", "outputfile2", "outLine6", "outLine1", "againFileTwo", "outFiles6", "outDirectory5", "outputfile5", "outDirectoryTwo", "outFiles2", "outDirectory2", "outChannel2", "againFile2", "againLine1", "outFile5", "outfile4", "againFile6", "outfile2", "outFile6", "outfileTwo", "outFiles1", "outChannelTwo", "againLineTwo", "outFiles5", "outputFileTwo", "outFile4", "againFile1", "outputfile4", "outLineTwo", "outFileTwo", "outLine2", "againLine6", "outDirectory4", "outputFile4", "outputFile2"], "outC2": ["OutC4", "OutC1", "againB4", "againB2", "outB2", "outF2", "againCTwo", "outCache4", "againC4", "outC4", "OutCII", "outFileII", "outB1", "outCII", "againC1", "outF1", "outCache1", "outB4", "outFII", "againC2", "outCache2", "outBTwo", "OutFII", "outFile4", "outCTwo", "againB1", "outCacheII", "OutF1", "OutF4", "OutC2", "outFileTwo", "OutF2", "againBTwo", "outF4", "outFTwo"], "fileSize": [" fileAddress", "fileSIZE", " fileLength", "resourceSIZE", " fileMode", "bufferSize", "bufferLength", "fileLength", "imageSIZE", "FileAddress", "resourceSize", "resourceAddress", "FileSIZE", " fileSIZE", "imageSize", "FileSize", "FileMode", "bufferMode", "FileLength", "fileAddress", "fileMode", "imageLength"], "totalNoDataRows": ["totalNoPageRues", "totalNoDataLues", "totalNoPageLrows", "totalNoDataLrows", "totalNoPageLues", "totalNoDataCues", "totalNoDataChrows", "totalNoPageLOWS", "totalNoDataRues", "totalNoPageLows", "totalNoDataChues", "totalNoPageROWS", "totalNoDataCrows", "totalNoDataLows", "totalNoPageRows", "totalNoDataChows", "totalNoDataCows", "totalNoDataChOWS", "totalNoDataRrows", "totalNoDataLOWS", "totalNoDataROWS", "totalNoPageRrows", "totalNoDataCOWS"], "mappedBuffer": ["mappedStream", "mapedBuffer", "machedChannel", "machedbuffer", "MappingChannel", "mapedStream", "MachedURL", "machedBuffer", "mashedChannel", "MappedURL", "mapedURL", "mippedStream", "machedURL", "MappedBuff", "MappingFile", "mppedStream", "MappingBuffer", "mactedbuffer", "mippedBuffer", "mappingBuffer", "MachedStream", "machedStream", "mactedBuffer", "mippedBuff", "machedFile", "Machedbuffer", "mactedBuff", "MachedBuff", "mappedbuffer", "mippedURL", "machedBuff", "mappingChannel", "MappingBuff", "MappedChannel", "mashedFile", "mactedStream", "MappedBuffer", "MappedStream", "MachedBuffer", "mashedBuffer", "mapedFile", "mappingbuffer", "Mappedbuffer", "mappingStream", "mappingFile", "MappedFile", "mappedChannel", "mapedBuff", "mappedFile", "MachedChannel", "mappedURL", "mppedBuff", "mappingBuff", "MachedFile", "mppedBuffer", "mappedBuff", "mashedBuff", "mppedChannel"], "startIndex": ["startindex", "startOffset", "initInfo", "endindex", "endSection", "useindex", "stopIndex", "startingIndex", "startingPosition", "startCode", " startindex", "StartInfo", "useIndex", " startSection", "usePosition", "stopRow", " startCode", " startPoint", " startInfo", "startInfo", "StartIndex", "startSection", "endInfo", "StartPosition", "startingSection", "initIndex", " startRow", "startingPoint", "StartOffset", "endIndex", "endCode", "stopindex", "initOffset", "endPosition", "startPosition", "endPoint", "Startindex", "initindex", "useInfo", "stopCode", "startPoint", " startPosition", "startRow", "endRow", " startOffset"], "count": ["group", "c", "current", "cache", "col", "call", "depth", "limit", "total", "more", "self", "sum", "time", "old", "Count", "number", "key", "force", "add", "first", "list", "length", "child", "weight", "part", "order", "all", "coll", "find", "thread", "max", "size", "index", "pool", "other", "code", "len", "i", "allow", "ind", "start", "close", "counter", "test", "follow", "type", "found", "id", "loop", "name", "keep"], "currentMovie": ["currentlyMusic", " currentMusic", "parentMovie", "currentFilm", "validMovie", "thismovie", "reportedMusic", "currentmovie", "currentPicture", "CurrentFilm", "parentFilm", "CurrentTheme", "CurrentMovie", "reportedFilm", "reportedMovie", "Currentmovie", "thisMovie", "defaultImage", "validFilm", "currentTheme", "reportedPicture", "defaultMovie", "reportedTheme", "validmovie", "currentImage", "defaultFilm", "parentPicture", "reportedImage", "currentMusic", "reportedmovie", "currentlyMovie", "defaultMusic", " currentFilm", " currentPicture", "thisPicture", "currentlyPicture", " currentImage", "thisFilm", "parentmovie", " currentmovie", "validTheme"], "movieName": ["moviename", "camFamily", " movieInfo", " movieId", "filmFamily", "filmname", "movieId", "filmName", "voiceId", "moneyNumber", "voiceInfo", "movieInfo", " movieFamily", "MovieName", "filmNumber", " moviename", "camName", "moneyName", "movieNumber", "movieFamily", "voicename", "camname", "MovieInfo", "voiceName", "MovieNumber", "MovieFamily", "Moviename", "MovieId", "moneyFamily"], "customer": ["ustomor", "ustomers", " customeri", " customER", "mixER", "CustomER", "ustomer", "Customers", "Customer", "customER", "customor", "mixor", " customers", "ustomER", "customers", "mixer", "customeri", "Customor", "ustomeri", "Customeri", "mixers"], "rating": ["resource", "Rating", "setting", "attribute", "ranking", "string", "packing", "reading", "http", "ruby", "comment", "number", "rage", "ring", "ing", "missing", "alpha", "including", "rate", "rc", "url", "score", "rank", "rice", "value", "feature", "rolling", "writer", "RC", "rated", "reader", "range", "type", "data", "writing", "error", "rr", "r", "rates", "id", "info", "radius", "padding"], "outBuf1": ["outBum1", "outFuf1", "outBuf01", "outBbuf11", "outDuff3", "outBummerCloud", "outBiff1", "outDuf3", "outBuff0", "outBaf1", "outKbuffOne", "outBuffn", "outBuff2", "outBbufOne", "outDuffn", "outBuf3", "outCuf1", "outCuf0", "outBummerOne", "outBalth2", "outKbuf1", "outBbuffOne", "outFufOne", "outKuf1", "outBuff1", "outBbuf1", "outBafOne", "outBufOne", "outKbuff1", "outBufn", "outKbuff8", "outKuf2", "outDuf11", "outFuf91", "outBuf8", "outBaf8", "outBbufn", "outFafOne", "outBbuf91", "outBaf3", "outFuf01", "outBaft1", "outBuffCloud", "outBum91", "outBbuff0", "outBuff8", "outBuff3", "outBuff11", "outBbuff1", "outCuff0", "outFaf1", "outFbuf01", "outBafCloud", "outBbuf2", "outKbuf2", "outBum01", "outBbuff8", "outBalth1", "outCuffOne", "outBuf0", "outKbuff3", "outBiff01", "outKufOne", "outFufCloud", "outBummer1", "outKbuf3", "outBiff91", "outBiffOne", "outBuf91", "outFbuf91", "outKuf3", "outFbufOne", "outBumOne", "outBalth3", "outKuf8", "outDuff11", "outBaf0", "outFbuf1", "outDufn", "outCufOne", "outBuf11", "outDuff1", "outBbuff3", "outBaftn", "outBbuf01", "outCuff1", "outBufCloud", "outBaft3", "outBaft11", "outBbuf3", "outDuf1", "outFafCloud", "outBuffOne"], "outBuf2": ["outFbuff2", "outFufB", "outFuf4", "outBuf12", "outBuf200", "outWBuff8", "outWBuff4", "outFbuff1", "outFuf1", "outBuf20", "outBum82", "outFuf20", "outBait4", "outFuf12", "outWBuff2", "outWBuf0", "outBbufTwo", "outBbuffer4", "outFbuffTwo", "outWBuf4", "outBuff0", "outBoff8", "outWBbuff8", "outBbuff4", "outFbuf12", "outFbuff4", "outWBuf8", "outFuf8", "outBuff2", "outBuf4", "outWBbuff2", "outBait200", "outBbuff2", "outWBbuffTwo", "outBbuffTwo", "outFbuff8", "outFbuff82", "outBbuff200", "outBuffTwo", "outBbuf12", "outBait2", "outFuf2", "outBbuff20", "outBufB", "outBuff1", "outBum8", "outBbuf1", "outBufTwo", "outBuf8", "outBbufB", "outFbuff20", "outBbuffer2", "outBbuff0", "outBuff8", "outBait8", "outBbuff1", "outBum20", "outBbuf2", "outBbuff8", "outBuf0", "outBoffTwo", "outBuber82", "outWBuff0", "outFufTwo", "outBuff4", "outWBuf2", "outBum2", "outBoff2", "outFbufB", "outBbuff82", "outBbufferB", "outFuf82", "outBuber8", "outBoff200", "outBuber2", "outBbuffer12", "outBuf82", "outBaitTwo", "outBait0", "outFbuf4", "outFbuf2", "outWBbuff200", "outBbuf4", "outWBuf200", "outWBufTwo", "outBuff12", "outBuffB", "outBuber20"], "endOfIndexFile": ["endOfindexfile", "endOfLinkDir", "endOfindexTime", "endOfindexFolder", "endofIndexDir", "endofLinkFile", "endedfile", "endOfClientTime", "endOfClientFile", "endOfIndexfile", "endOfImageTime", "endOfindexFiles", "endOfIndexFolder", "endofindexFile", "endOfDataFile", "endOfLinkFiles", "End\n", "endOfindexDir", "end\n", "endofIndexFiles", "endOfIndexTime", "endOfindexFile", "endfile", "Endfile", "endOfLinkFile", "endofIndexTime", "endOfLinkfile", " end\n", "endofindexTime", "endofLinkTime", "endOfIndexDir", "endOfImageFiles", "endOfDataTime", "endOfImageFile", "endOfClientFiles", "endOfLinkTime", " endfile", "endofLinkDir", "endofindexFolder", "endofindexFiles", "endofIndexFolder", "endOfImageFolder", "endOfDatafile", "endofLinkFiles", "ended\n", "endOfIndexFiles", "endofIndexFile", "endOfClientDir", "endOfDataDir"]}}
{"id1": "14865947", "id2": "9033639", "code1": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"execute": ["action", "run", "exit", "send", "call", "ute", "invoke", "open", "process", "command", "task", " executing", "exec", "load", "complete", "evaluate", "start", "transfer", "test", "submit", "message", "loop", "launch", "Submit", "create"], "event": ["vent", "g", "context", "ex", "te", "ents", " Event", " EVENT", "ctx", "events", "object", "exec", "exc", "x", " events", "f", "other", "Event", "image", "ext", "v", "test", "ev", "ent", "t", "message", "ec"], "shell": ["il", "mail", "tty", "live", "ml", "window", "sh", "bot", "site", "environment", "o", "gui", "xml", "tool", "log", "ll", "lex", "tools", "search", "edit", "sol", "ui", "sync", "sql", "child", "build", "Shell", "bash", "cl", "l", "cell", "layout", "model", "exec", "cmd", "server", "sole", "system", "help", "math", "sl", "pool", "cli", "sb", "session", "hell", "dll", "nl", "home", "el", "lib", "cel", "kernel", "null", "prof", "pty", "loop", "lock", "console", " Shell"], "view": ["row", "views", "window", "container", "View", " layout", "gui", "service", "screen", "review", "display", "list", " overview", "tree", "VIEW", "ui", "visual", "summary", "object", "user", "book", "l", " preview", "show", "layout", "model", "iew", "url", "f", "control", "pool", "session", "image", "widget", "page", "v", "plugin", "web", "sel", "lock", "console", "version", "flow"], "rootFolder": [" rootArea", "RootZip", "bottomFile", "homeCenter", "shellDir", "rootFile", "parentFile", "mainfolder", "RootWindow", "rootWindow", "RootFolder", "shellFolder", " rootCenter", "homeFolder", "homeDirectory", " rootDir", " rootOrg", " rootFlow", "parentFlow", "mainFolder", " rootFile", " rootWindow", "RootDirectory", "bottomDirectory", " rootDirectory", "rootOrg", "shellArea", "RootOrg", "shellWindow", "rootFlow", "RootCenter", "rootDir", "rootDirectory", "rootfolder", "parentDirectory", "Rootfolder", "RootFile", "bottomFlow", "RootDir", "bottomFolder", "rootZip", "rootCenter", " rootfolder", "parentFolder", "parentZip", "RootArea", "rootArea", "mainOrg", "mainFile", " rootZip"], "dialog": ["clogg", "clect", "protogg", "logDialog", "challogging", "logogue", "challDialog", "dialogg", "challock", "logock", "challogs", "dialogs", "diffDialog", "diffock", "protect", "logog", "dialock", "dialect", "diffogue", "dialDialog", "dialogging", "logogs", "clogs", "diffog", "dialOG", "clogging", "challogue", "challogg", "protog", "challect", "protogging", "challOG", "dialogue", "logOG", "logogg", "clOG", "clog", "challog"], "password": ["resource", "pass", "root", "token", "username", "words", "sword", "description", "string", "mac", "channel", "pg", "word", "volume", "secret", "language", "Password", "sum", "wallet", "path", "PASS", "params", "patch", "key", "auth", "pad", "database", "wd", "email", "content", "mode", "address", "handler", "command", "p", "connection", "device", "cmd", "phrase", "prefix", "definition", "config", "size", "confirmed", "session", "value", "hash", "page", "diff", "directory", "data", "picture", "account", "message", "pattern", "source", "crypt", "text", "column", "name", "encrypted", "padding"], "md5": ["mand15", "mand2", "md50", "mand5", "MD2", "mg40", "MD40", "dd5", "MD5", " mddown", " md15", "mddown", "md2", "mg2", "mg50", "cmd2", "MDdown", "md15", "md4", " md4", " md2", "manddown", "dd2", "md40", "cmd4", "md512", "MD50", "MD15", "MD4", " md512", "cmd512", "MD512", "dd40", "dd50", "mg5", "mand512", "cmd5"], "md": ["df", "mb", "mg", "mp", "pd", "ms", "pm", "od", "mand", "mac", "m", "sm", " MD", "d", "sha", "sum", "msg", "MD", " ma", "bd", " digest", "meta", "wd", " sd", "mode", "ad", "M", "dd", "mc", "cd", "mod", "cmd", " dd", "ma", "mag", "nd", " cmd", "pkg", " mm", "dm", "hash", "html", " Md", "amd", "nm", "kg", "dig", "sd", "mm", "metadata", "bf", "mo"]}}
{"id1": "21308543", "id2": "421042", "code1": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copiedContent", " copyFiles", " copyContent", "transferFile", "transferStream", "copyContent", " copiedStream", " copiedFile", "transferContent", "transferFiles", "copyFiles", " copyStream", " copiedFiles", "copyStream"], "src": ["resource", "scene", "js", "media", "project", "string", "href", "http", "ruby", "input", "ource", "path", "inst", "sc", "slice", "this", "attr", "dest", "download", "loc", "rc", "ls", "upload", "server", "url", "sci", "code", "filename", "image", "sin", "inf", "remote", "img", "feat", "rs", "source", "stream", "uri", "sit", "rb", "sel", "core"], "target": ["resource", "temp", "large", "external", "project", "effect", "master", "path", "fat", "dest", "arget", "compatible", "object", "content", "loc", "it", "rel", "goal", "base", "out", "port", "url", "director", "eth", "tx", "top", "Target", "remote", "writer", "to", "nt", "output", "next", "type", "arg", "secure", "result", "prot", "parent", "source", "text", "name", "reference"], "ic": ["ib", "icc", "ics", "pc", "fc", "ip", "nic", "c", "pic", "irc", "cin", "ick", "aci", "IC", "ci", "xc", "io", "cci", "mic", "ct", "ac", "loc", "it", "ico", "cc", "cl", "mc", "vc", "rc", "aic", "exec", "bc", "enc", "sci", "isc", "i", "iac", "ici", "cit", "ai", "acl", "inc", "ec", "ix", "ik", "lc", "voc"], "oc": ["soc", "pc", "fc", "nic", "alloc", "c", "ocr", "pic", "irc", "o", "abc", "ci", "xc", "io", "sc", "co", "mic", "oci", "ac", "AC", "acs", "loc", "oca", "cc", "mc", "vc", "rc", "exec", "OC", "ocol", "cs", "bc", "anc", "enc", "other", "isc", "aco", "arc", "uc", "bb", "output", "ec", "iv", "roc", "toc", "ace", "org", "voc"]}}
{"id1": "693636", "id2": "22503685", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "label": 0, "substitutes": {"createEmptyCart": ["createTempShipping", " createNewCart", " createNewSpot", " createEmptySpot", "createTempSpot", "createCreateSpot", "createNewSpot", "createEmptySpot", "createEmptycart", "createCreatecart", "createCreateCart", "createCreateShipping", "createEmptyShipping", "createNewcart", "createNewShipping", " createNewcart", "createNewCart", "createTempcart", " createEmptyShipping", "createTempCart", " createEmptycart", " createNewShipping"], "SHOPPING_ID": ["SHOPPINGPOIDs", "SHOPPIPIDIDS", "SHOPPINGINGid", "SHOPPIPIDIDs", "SHOPPIPIDId", "SHOPPING_id", "SHOPPINGIDIDs", "SHOPPIP_IDs", "SHOPPINGPOID", "SHOPPYING_IDS", "SHOPPIPIDID", "SHOPPYING_Id", "SHOPPING_IDs", "SHOPPING_Id", "SHOPPIP_id", "SHOPPING_IDS", "SHOPPINGIDID", "SHOPPYING_ID", "SHOPPYING_IDs", "SHOPPTING_Id", "SHOPPINGIDId", "SHOPPINGIDid", "SHOPPTING_ID", "SHOPPIP_Id", "SHOPPINGPOId", "SHOPPINGPOIDS", "SHOPPINGIDIDS", "SHOPPIPIDid", "SHOPPTING_id", "SHOPPIP_IDS", "SHOPPIP_ID", "SHOPPINGINGID", "SHOPPINGINGId"], "con": ["fa", "row", "ctrl", "pc", "fc", "cm", "act", "c", "cas", "cache", "ca", "col", "ex", "cons", "Conn", "ann", "conv", "ci", "log", "ctx", "can", "co", "cf", "ac", "client", "conn", "ran", "loc", "cc", "cr", "connection", "mc", "win", "cn", "cond", "rc", "exec", "coll", "cur", "wan", "reg", "commit", "fac", "bc", "pool", "session", "CON", "Con", "uc", "close", "en", "conf", "com", "ec", "pen", "inc", "connect", "db", "un"], "insert_cart": [" insert_pod", "insert_Cart", "install_container", "insert_center", "exec_cart", "insertencycle", "insertencenter", "insert_ox", "insert_pod", "insert_cycle", " insert_cycle", "install_cart", " insert_center", "insert_part", "insert_cat", " insert_ox", "insert_payment", "insert_conn", " insert_cat", "insert_container", "exec_Cart", "insertencart", "insertencat", "install_part", "exec_payment", " insert_conn"]}}
{"id1": "18005010", "id2": "20939940", "code1": "    private void setProfile(String loginName, SimpleUserProfile profile) throws MM4UCannotStoreUserProfileException {\n        try {\n            OutputStream outStream = null;\n            URL url = new URL(this.profileURI + profile.getID() + FILE_SUFFIX);\n            if (url.getProtocol().equals(\"file\")) {\n                File file = new File(url.getFile());\n                outStream = new FileOutputStream(file);\n            } else {\n                URLConnection connection = url.openConnection();\n                connection.setDoOutput(true);\n                outStream = connection.getOutputStream();\n            }\n            OutputStreamWriter writer = new OutputStreamWriter(outStream);\n            Enumeration myEnum = profile.keys();\n            while (myEnum.hasMoreElements()) {\n                String key = myEnum.nextElement().toString();\n                if (key != \"id\") writer.write(key + \"=\" + profile.getStringValue(key) + System.getProperty(\"line.separator\"));\n            }\n            writer.flush();\n            writer.close();\n        } catch (Exception e) {\n            throw new MM4UCannotStoreUserProfileException(this, \"setProfile\", e.toString());\n        }\n    }\n", "code2": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "label": 0, "substitutes": {"setProfile": ["Setprofile", "SetRole", "updateProfile", "SetAccount", "SetProfile", "updateRole", "setAccount", "updateprofile", "setRole", " setAccount", " setRole", "updateAccount", "setprofile", " setprofile"], "loginName": ["displayUrl", "displayName", " friendlyName", " screenName", "displayID", " friendlyID", " friendlyPath", " screenPath", " screenUrl", " profileName", "displayPath", " profileUrl", " profileID", " screenID", " friendlyUrl", " profilePath"], "profile": ["property", "resource", "role", "application", "phy", "username", "shadow", "line", "project", "position", "history", "site", "environment", "photo", "option", "proxy", "character", "family", "report", "path", "phone", "display", "network", "queue", "summary", "user", "object", "header", "p", "base", "pe", "config", "settings", "office", "FILE", "password", "feature", "image", "Profile", "page", "result", "data", "type", "picture", "style", "plugin", "prof", "account", "job", "buffer", "name", "person"], "outStream": ["OutFile", "outputSteam", "outWriter", "OutSteam", "OutStream", "outputFile", " outFile", "intFile", "intSteam", "outputPath", "inSteam", "outputStream", "outPath", " outWriter", "instream", "inStream", "outSteam", "OutWriter", "OutPath", "inFile", " outSteam", "inWriter", "outFile", "Outstream", " outstream", "intstream", " outPath", "outputstream", "intStream", "outstream"], "url": ["resource", "entry", "pull", "or", "large", "function", "position", "zip", "string", "channel", "host", "http", "proxy", "service", "www", "URL", "log", "path", "api", "open", "feed", "this", "Url", "email", "impl", "download", "client", "conn", "address", "loc", "browser", "l", "base", "out", "server", "coll", "location", "plug", "sl", "f", "link", "e", "hub", "image", "socket", "page", "ssl", "data", "b", "id", "web", "uri", "stream", "source", "buffer", "org"], "file": ["File", "resource", "folder", "fe", "class", "use", "line", "function", "entity", "full", "zip", "channel", "http", "le", "path", "log", "io", "feed", "files", "place", "content", "unit", "loc", "l", "part", "base", "out", "pe", "get", "f", "FILE", "per", "filename", "image", "lib", "plain", "fp", "page", "output", "data", "b", "binary", "stream", "body", "name"], "connection": ["resource", "application", "section", "function", "position", "c", "Connection", "channel", "cache", "union", "proxy", "character", "response", "conv", "ctx", "con", "io", "open", "co", "driver", "relation", "conn", "object", "creator", "handler", "loc", "part", "out", "communication", "server", "config", "bc", "control", "session", "director", "password", "connect", "socket", "to", "directory", "connected", "stream", "client", "which"], "writer": ["entry", "riter", "writ", "function", "writers", "string", "later", "word", "xml", "inner", "ee", "walker", "outer", "Writer", "engine", "this", "driver", "er", "handler", "w", "wire", "out", "element", "event", "server", "work", "loader", "office", "per", "e", "wrapper", "worker", "editor", "to", "widget", "socket", "runner", "reader", "output", "writing", "write", "data", "buffer", "master", "builder"], "myEnum": ["myenum", "myLenumeric", "yourEncum", "myRenation", "myENum", "myenumber", "myenumer", "myEncation", "yourEnumer", "myLenumer", "myEnation", "yourEnque", "myEncum", "MyENumeric", "myEumb", "yourEncumer", "yourEnum", "myEncUM", "myEnUM", "myEncque", " myEnumb", "myEUM", "myENums", "myENumer", "yourEncumber", "MyEnumer", "myEnumeric", " myEum", "myRenum", "myenque", "myEation", "myEnque", "yourEncque", "MyEnum", " myEnation", "MyEnums", "myEnums", "myEncumber", " myEUM", "MyENums", "myRenumb", "myEncumb", "MyENum", "myENumeric", "myLenums", "myEnumer", "myENque", "myEncumer", "myEnumber", "MyEnumeric", " myEation", " myEnUM", "yourEnumber", "myRenUM", " myEumb", "myENumber", "myLenum", "myEnumb", "myEum", "MyENumer"], "key": ["item", "entry", "row", "ask", "section", "Key", "ip", "k", "string", "act", "step", "col", "exp", "ex", "str", "match", "KEY", "co", "box", "char", "sign", "child", "my", "weight", "ie", "cookie", "rule", "part", "base", "fix", "element", "pe", "nice", "load", "keys", "link", "field", "code", "value", "by", "feature", "any", "check", "val", "result", "page", "member", "change", "ice", "type", "point", "id", "hop", "info", "source", "ver", "me", "ace", "form", "name", "lock"]}}
{"id1": "10214218", "id2": "23517481", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["enrypt", " encress", "deccrypt", "enress", "decrypt", "decress", "enccrypt", "encipher", " enccrypt", "decipher", " encipher", "enipher", "encress"], "plaintext": [" plaintxt", "battxt", "plainText", "plainstruct", "maintext", "battext", "mainsource", "batsource", "anytxt", " plainText", "batText", " plainstruct", "plainsource", " plainsource", "plaintxt", "anystruct", "anytext", "mainText", "anyText", "mainstruct", "batstruct"], "md": ["mb", "mg", "mp", "pd", "mage", "pm", "od", "ms", "mand", "cm", "mac", "Cmd", "m", "em", "pg", "sm", " MD", "d", "sha", "hm", "MD", "bd", "key", "meta", "wd", "ad", "dd", "ld", "mc", "mod", "cmd", "dh", "dr", "mag", "ma", "am", "arm", "dm", "nm", "amd", "data", "dig", "kg", "mm", "metadata", "message", "mad", "mt", "mu", "db", "mo"], "raw": ["row", "words", "full", "clean", "instance", "initial", "unknown", "input", "wave", "feed", "hex", "buf", "none", " RAW", "content", "original", "ack", "good", "ng", "rc", "rew", "load", "array", "enc", "Raw", "serial", "wrapper", "image", "bytes", "unsigned", "data", "null", "pack", "RAW", "binary", "buffer", "text", "block", "message", "dec"], "hash": ["hed", "sh", "mac", "cache", "Hash", "rh", "secret", "ruby", "sha", "response", "sum", "abi", "log", " hex", "hex", "key", "ashes", "header", "kh", "alpha", "ha", "base", "url", "ash", "array", "code", "her", "image", "h", "html", "data", "id", "message", "block", "version"]}}
{"id1": "4593011", "id2": "1508161", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "label": 0, "substitutes": {"loadDDL": ["loadDDML", "loadCDML", "loadSDE", "LoadDDML", "loadDDLL", "loadSDL", "LoadCDLL", "LoadDDL", "loadCDE", "loadODL", "LoadCDML", "LoadCDE", "loadCDL", "loadCDLL", "loadODML", "loadSDLL", "loadDDE", "LoadDDLL", "LoadCDL", "loadODE", "LoadDDE", "loadODLL", "loadSDML"], "stmt": ["stmd", "STmt", "sttt", "stm", "estmr", "strmt", "rmt", "estmb", "STmb", "rm", "Stmb", "stgr", " stgr", " stdb", "constmt", "stmp", "Stmt", "tmd", "stpr", " sttr", "estm", "estmd", "constmn", "STmr", "strgr", "constdb", "Stmd", " stmn", "Stmp", "rmd", "STtr", "estmp", "Stmn", "tmt", "stmr", "Stdb", "strtr", "STpr", "strpr", "stmb", " stmd", "tdb", "Stm", " sttt", "stmn", "STgr", " stpr", "Sttt", "esttt", " stm", "tm", "STmp", "sttr", "stdb", "constm", "Stmr", "estmt", "rdb"], "qry": ["eqrys", "equry", "qri", "qrys", "qries", "qurys", "quries", "quury", "qRY", "Qries", "eqry", "quri", "Qrys", "quRY", "eqRY", "Qri", " qrys", "Qry", " qury", " qri", "qury", " qRY", " qries"], "q": ["ch", "requ", "n", "c", "k", "qa", "request", "select", "d", " query", "qu", "key", "queue", "qq", "iq", "Q", "p", "quant", "qs", "qt", "query", "config", " req", " p", "f", "quest", "e", "i", "v", " sq", "dq", "req", "r", "b", "ql", "id", "t", "sq", "eq"]}}
{"id1": "17791385", "id2": "19006212", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public void Load(String fname) throws Exception {\n        File f = null;\n        try {\n            if (\"\".equals(fname) || fname == null) throw new Exception();\n            System.out.println(\"Loading mapfile \" + fname);\n        } catch (Exception e) {\n            throw new Exception(\"File not found\");\n        }\n        aType = null;\n        fieldtype.clear();\n        creatures.clear();\n        aElement = new String(\"\");\n        content = null;\n        Ax = -1;\n        Ay = -1;\n        aTemplate = -1;\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        data_read = 0;\n        URL url = this.game.mainClass.getClassLoader().getResource(fname);\n        if (url == null) {\n            throw new Exception(\"Can't load map from : \" + fname);\n        }\n        try {\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(url.openStream(), this);\n        } catch (Exception e) {\n            System.out.println(\"Can't open XML : \" + e);\n        }\n        for (int i = 0; i < fieldtype.size(); i++) {\n            System.out.println((MapField) fieldtype.get(i));\n        }\n        game.player.setpos(start_x, start_y);\n        System.out.println(\"Player starting position set\");\n        start_x = -1;\n        start_y = -1;\n        System.out.println(\"Map \\\"\" + fname + \"\\\" loaded\");\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "src": ["resource", "txt", "http", "dist", "input", "inst", "sc", "dest", "ins", "files", "ipl", "loc", "sup", "s", "rc", "ls", "upload", "url", "config", "sb", "sl", "filename", "image", "sin", "inf", "img", "st", "obj", "b", "back", "source", "stream", "uri", "sit", "rb", "sel", "file"], "dst": ["stst", "dsp", "ddest", "ddfd", "dfd", "stdest", "fdst", "ststs", " dsts", "Dlt", "pdfd", "pdst", "Dst", "fdfd", "ddft", "dsts", "Ddest", "ddsp", "ddst", " dlt", " ddest", "dft", "fdsp", "dlt", "fdft", "pdft", "Dsts", "pdsp", "stlt"], "in": ["In", "pull", "again", "n", "ini", "oin", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "as", "con", "pin", "ins", "impl", "conn", "inn", "err", "kin", "init", "win", "rin", "lin", "url", "gin", "f", "inside", "i", "nin", "h", "sin", "socket", "login", "reader", "data", "r", "inc", "id", "ln", "file"], "out": ["temp", "line", "at", "again", "n", "cache", "o", "ex", "exp", "bin", "Out", "self", "copy", "outer", "io", "outs", "post", "sync", "conn", "err", "up", "part", "net", "w", "s", "exec", "server", "x", "f", "other", "off", "i", "writer", "plain", "ext", "output", "raw", "obj", "OUT", "null", "inc", "parent", "client", "file"], "buf": ["bh", "vec", "cat", "c", "bin", "fd", "ctx", "bd", "queue", "pad", "length", "seq", "count", "loc", "batch", "br", "bl", "bag", "ff", "base", "rc", "cmd", "cur", "bc", "off", "lim", "cap", "uf", "uc", "bytes", "cb", "val", "v", "bb", "data", "fl", "raw", "b", "bf", "buff", "fb", "buffer", "wb", "rb"], "len": ["lt", "line", "n", "c", "fin", "bin", "le", "Len", "ll", "fd", "length", "no", "count", "err", "l", "part", "cl", "base", "pos", "all", "lin", "size", "sl", "f", "i", "li", "ind", "cap", "el", "split", "lim", "val", "nt", "data", "fl", "en", "lf", "rev", "ix", "ln", "name", "lc", "end"]}}
{"id1": "10391753", "id2": "14733078", "code1": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": [" encress", "Encrypt", "deccrypt", "Encipher", "decrypt", "decress", "enccrypt", "encipher", " enccrypt", "Enccrypt", "decipher", "Encress", " encipher", "encress"], "text": ["txt", "class", "token", "string", "Text", "word", "str", "input", "path", "hex", "key", "length", "content", "object", "letter", "crypt", "connection", "out", "prefix", "contract", "config", "code", "password", "image", "format", "bytes", "TEXT", "plain", "ext", "test", "output", "data", "message", "pattern", "buffer", "source", "name", "encrypted"], "toEncrypt": ["toEncract", " toExecrypt", "toExecrypt", " toExecryption", " toEncract", "toExecript", " toDecract", "toCCrypt", "toCcrypt", "toEncript", "toDiscract", "toDiscrypt", "toExecrypted", " toCryption", "toDecipher", " toEncCrypt", " toCrypted", " toDecert", "toRecrypt", "toDecract", "toAcrypt", " toExeccrypt", "toEncert", "toCrypted", " toDecrypt", " toEncrypted", " toEnccrypt", "toAcipher", "toDecCrypt", " toEncript", "toDiscert", "toExecCrypt", "toAcract", "toExeccrypt", " toEncipher", " toCCrypt", " toEncryption", " toDecipher", "toEncCrypt", " toCrypt", "toEncrypted", "toDecrypt", " toExecript", "toEncipher", "toDecryption", "toCryption", "toRecryption", "toCrypt", "toRecript", "toDecrypted", "toAcert", "toDiscipher", "toDecert", " toEncert", "toCript", "toEnccrypt", "toExecryption", "toReccrypt", "toEncryption"], "hexString": ["hashText", " hexList", "shortBuffer", "hashString", "stringString", "stringUnit", "hashList", "hexstring", "shortString", "shortArray", "textArray", "hashBuffer", " hexstring", "indexArray", "hashstring", "indexstring", "hexUnit", " hexBuffer", " hexUnit", "hexText", " hexText", "hexArray", " hexArray", "indexString", "indexText", "hexBuffer", "textUnit", "stringArray", "shortList", "textString", "hexList", "textstring", "hashArray", "stringstring"], "dig": ["dc", "wrap", "fe", "or", "grab", "rep", "draw", "pm", " dec", " mod", "est", "im", "push", " Dig", "and", "prep", "exp", "um", "d", "fin", "rand", "log", "Dig", "add", "cod", "driver", "hex", "div", "alg", "build", "cr", " comb", "comb", "ng", "lab", "cd", "mod", "rob", "del", "dd", "destruct", "define", "find", "get", "du", "mix", "enc", "her", "hash", "ssl", "test", "gen", "diff", "de", "sign", "loop", "neg", "grad", "dim", "ig", "db", "pro", "dec"], "pw": ["pwh", "lpwd", " pow", "ppaw", "PW", "Pwd", "Pwh", " pW", "Pow", " paw", "Pws", " pwd", "paw", "lpw", "prw", "pwa", "praw", " pye", "pws", "cws", " pwh", "cW", "pW", "pow", "lpow", "cw", " pwa", "lpW", "pye", "prye", "ppw", " pws", "ppye", "ppwa", "prwa", "Pw", "cwh", "pwd"], "i": ["hi", "si", "qi", "chi", "ip", "u", "n", "ii", "k", "c", "pi", "m", "ini", "o", "y", "d", "ci", "di", "io", "z", "key", "slice", "ui", "in", "ei", "ri", "length", "bi", "p", "it", "l", "w", "phi", "j", "I", "x", "index", "f", "e", "oi", "li", "a", "start", "h", "v", "gi", "ti", "data", "ai", "mi", "r", "b", "xi", "t", "id", "uri", "ix", "mu", "lc", "end"], "digest": ["Diggest", "labesting", "signEST", " digestamp", "labest", "hashest", "delEST", "debuggest", " digests", "Digester", "Digested", "signest", " digesting", "digested", "delest", "digester", " digEST", "DigEST", "delestamp", " digester", "codester", " digested", "signester", "hashester", " diggest", "labests", "codests", "codesting", "labester", "Digestamp", "digEST", "debugested", "debugester", "hashEST", "diggest", "signested", "digestamp", "digests", "digesting", "Digest", "debugest", "delester", "codest", "hashested"], "digestLength": ["DigesterLine", "digesterLine", "diffestLoop", "DigesterStr", "digestLen", "digestationLoop", "DigesterLen", "DigestLen", "digestlength", "digusterLength", "DigestLength", "diffestlength", "digESTLine", "digesterLen", "diffesterlength", "digestStr", "digESTStr", "digesterlength", "digestLoop", "digestationlength", "digstLoop", "digESTLength", "diffesterLoop", "digestLine", "DigesterLength", "digusterStr", "digusterLine", "digusterLen", "diffestType", "digesterType", "digstLength", "DigestStr", "digesterLength", "digestationType", "digesterLoop", "digstlength", "diffestLength", "digestationLength", "digESTLen", "digesterStr", "digestType", "diffesterType", "DigestLine", "digstType", "diffesterLength"]}}
{"id1": "18238468", "id2": "3767903", "code1": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testLoadSource": ["TestloadSource", "testloadSources", "testloadSource", "TestLoadSource", "TestloadSourceFile", "testReadSources", "testloadSourceFile", "testReadSourceFile", "testLoadSourceFile", "testAddSourceFile", "testAddFormat", "testAddSource", "TestloadFormat", "TestLoadSourceFile", "testLoadSources", "TestLoadSources", "testloadFormat", "testReadSource", "testLoadFormat", "TestloadSources", "testAddSources", "testReadFormat", "TestLoadFormat"], "metadata": ["df", "attribute", "media", "pdf", "map", "m", "xml", "manager", "ctx", "params", "np", "sheet", "this", "meta", "database", "summary", "json", "properties", "content", "music", "header", "my", "generic", "iterator", "sample", "default", "ami", "document", "tmp", "definition", "loader", "journal", "adata", "auto", "filename", "material", "reader", "data", "md", "module", "tt", "message", "info", "parser", "stream", "artist", "source", "collection", "general", "mo", "template"], "inputStream": ["outputForm", "outputSteam", "InputForm", "rawStream", " inputSteam", "outputWriter", "inputFile", "inputWriter", "rawSteam", "inputSource", " inputFile", "outputStreamer", "outputFile", " inputForm", "inputstream", "inputForm", "streamStreamer", "rawStreamer", "InputWriter", " inputstream", "InputSource", "rawstream", "outputStream", "streamstream", "inputStreamer", "InputSteam", "InputFile", "Inputstream", "streamStream", "outputSource", " inputSource", "streamSteam", " inputWriter", "InputStream", "outputstream", "inputSteam"], "writer": ["temp", "riter", "usher", "writ", "words", "external", "writers", "string", "cache", "word", "pointer", "inner", "ler", "winner", "master", "walker", "Writer", "key", "WR", "driver", "creator", "keeper", "handler", "RW", "document", "w", "out", "settings", "per", "code", "rw", "wrapper", "director", "worker", "her", "editor", "format", "widget", "wr", "reader", "output", "writing", "write", "data", "written", "author", "r", "null", "ana", "buffer", "text", "builder"], "contents": ["constent", "CONTENTS", "Contents", "Contacts", "contacts", "contENTS", "constented", "contentacts", "CONTent", "CONTented", "content", "CONTacts", "Content", "contences", "Contented", "ContENTS", "contentences", "CONTents", "contentent", "contentents", "Contences", "constents", "constENTS", "contented", "CONTences"]}}
{"id1": "3430784", "id2": "7499186", "code1": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"decodeBody": [" decodedStream", "decodedPart", "decodingFile", "decodesPart", "decodesFile", " decodeStream", "decodeFile", "decodeStream", "decodingBody", "decodingStream", "decodePart", " decodedPart", "decodingPart", " decodedFile", " decodeFile", " decodedBody", "decodedFile", "decodesBody", " decodePart", "decodedBody", "decodedStream", "decodesStream"], "in": ["resource", "In", "inas", "pass", "again", "serv", "ini", "c", "IN", "m", "cin", "ex", "request", "is", "inner", "din", "bin", "input", "as", "con", "ins", "ac", "content", "min", "inn", "conn", "into", "err", "it", "connection", "init", "isin", "win", "exec", "url", "get", "load", "gin", "config", "loader", "read", "work", "f", "session", "inside", "i", "nin", "image", "socket", "login", "file", "reader", "data", "r", "b", "inc", "id", "source", "buffer", "body", "src", "version"], "contentTransferEncoding": ["contentTransferencording", "contentTransferEncryption", "contentTransferEnaming", "contentTransferAcoding", "contentTransferEncaming", "contentTransferEncoder", "contentTransferEnearing", "contentTransferEnoding", "contentTransferEnording", "contentTransferAcasing", "contentTransferencitting", "contentPartEncryption", "contentPartEoder", "contentTransferEncearing", "contentRestEnording", "contentTransferCearing", "contentTransferEncitting", "contentTransferEoding", "contentTransferEngoding", "contentTransferEcoder", "contentTransferCording", "contentRestEncoding", "contentRestEncaming", "contentTransferEosing", "contentPartEncoder", "contentTransferAcosing", "contentTransferEoder", "contentTransferEngearing", "contentTransferEnasing", "contentTransferEncoded", "contentTransferencoding", "contentTransferCaming", "contentRestEncoder", "contentTransferEngoded", "contentTransferEndasing", "contentTransferEnitting", "contentPartEryption", "contentRestEncording", "contentPartEncoding", "contentTransferEasing", "contentRestEnoder", "contentTransferEcoding", "contentTransferEndoding", "contentTransferEnoded", "contentTransferEndoder", "contentTransferEngasing", "contentTransferencoder", "contentTransferEncosing", "contentTransferCasing", "contentTransferEnosing", "contentTransferEndoded", "contentPartEncasing", "contentPartEoding", "contentTransferCryption", "contentTransferEnoder", "contentTransferAcoder", "contentTransferCoder", "contentTransferCoding", "contentTransferCoded", "contentTransferEcitting", "contentTransferEncasing", "contentRestEnaming", "contentTransferEcaming", "contentTransferEncording", "contentRestEnoding", "contentPartEasing", "contentTransferEcording", "contentTransferEryption", "contentTransferEnryption"], "tempBody": ["tmpCore", "outputbody", "outputFile", "tempCore", "tmpFile", "TempBody", " tempFile", "outputBody", " tempbody", "Tempbody", "tmpLife", "tempFile", "TempFile", "outputLife", "tmpBody", " tempCore", "tempLife", "tempbody", "tmpbody", " tempLife", "TempCore"], "out": ["resource", "temp", "line", "again", "c", "cache", "channel", "o", "ex", "inner", "bin", "Out", "copy", "path", "io", "outs", "this", "sync", "object", "conn", "user", "err", "app", "connection", "init", "base", "exec", "pool", "off", "i", "a", "socket", "writer", "page", "ext", "output", "data", "raw", "obj", "OUT", "null", "parent", "source", "client", "body", "file", "extra"]}}
{"id1": "8983517", "id2": "2834524", "code1": "    public User getUser(String userlogin) {\n        UserDAO userDAO = new UserDAO();\n        User user = null;\n        try {\n            user = userDAO.load(userlogin);\n            if (user == null) {\n                URL url = Thread.currentThread().getContextClassLoader().getResource(\"users.cfg\");\n                BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                String linea = br.readLine();\n                while (linea != null) {\n                    StringTokenizer st = new StringTokenizer(linea, \":\");\n                    if (st.countTokens() == 3) {\n                        String login = st.nextToken();\n                        String password = st.nextToken();\n                        String profile = st.nextToken();\n                        if (login.equals(userlogin)) {\n                            user = new User(login, password, profile);\n                            userDAO.save(user);\n                        }\n                    } else {\n                    }\n                    linea = br.readLine();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return user;\n    }\n", "code2": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "label": 0, "substitutes": {"getUser": ["newuser", "getUsers", "readUsers", "newCustomer", "readUser", "getuser", "newUser", "createUsers", "createCustomer", "createuser", "newUsers", "readuser", "createUser", "readCustomer", "getCustomer"], "userlogin": [" useruser", "username", "customauth", "bugLogin", " userline", "courseuser", " userauth", "buglogin", " userLogin", "uselogin", " userpassword", "custompassword", "coursepassword", "pluginname", "bugline", "courselogin", "verusername", "useLogin", "useruser", "pluginpassword", "bugusername", "userLogin", "userauth", "pluginusername", " userusername", "userline", "useusername", "userusername", "userpassword", "customlogin", "pluginlogin", "verlogin", "vername", "verpassword", " username", "courseauth", "customuser", "useline"], "userDAO": [" userRAOB", "UserMAOO", "userDSB", "userAB", "usernameDAB", "usernameDSOB", "UserDAOs", "userDAOO", "userDSo", " userDAB", "usernameDSo", " userRAB", "usernameDAo", "UserDAOB", "userTAOO", "userDSOB", "UserMAO", "UserMAOB", "userDAo", "UserDAO", "userAo", " userRAO", "userAO", "userRAOB", "userDAB", "userTAO", "userMAOB", "userTAB", "userAOB", "userMAB", "userDKO", "userDSOO", " userDAOO", "usernameDSO", " userDAOB", "userDKB", "userRAO", "userMAOO", "UserMAOs", "userDAOB", "userDAOs", "userDKOB", "UserDAOO", "userRAOO", "usernameDAOB", "userTAOB", "userDSO", "usernameDAO", "userRAB", "userDSOs", "userDKo", "userMAOs", "usernameDSB", " userRAOO", "userMAO"], "user": ["resource", "use", "who", "full", "blog", "current", "state", "manager", "log", "match", "auth", "rule", "html", "v", "po", "parent", "ver", "db", "item", "or", "username", "usa", "cache", "str", "comment", "facebook", "io", "USER", "bug", "dict", "model", "per", "other", "record", "page", "member", "data", "oo", "one", "class", "ee", "creator", "er", "default", "sp", "usr", "home", "uc", "author", "ou", "type", "account", "lock", "name", "person", "group", "u", "um", "service", "response", "key", "object", "up", "config", "session", "e", "User", "result", "claim", "plugin", "job", "users", "info", "me"], "url": ["resource", "fr", "string", "blog", "href", "host", "channel", "http", "str", "URL", "path", "ur", "io", "feed", "gl", "org", "Url", "address", "bel", "orb", "lr", "rel", "browser", "l", "connection", "base", "server", "plug", "coll", "loader", "sl", "ssl", "fl", "r", "b", "account", "uri", "stream", "source", "src", "file"], "br": ["Br", "ch", "bh", "HR", "brush", "str", "bm", "ler", "ber", "ner", "bd", "yr", "buf", "rt", "sr", "bro", "BR", "tr", "mr", "lr", "browser", "bl", "cr", "err", "arr", "sp", "dr", "bc", "sl", "bar", "vr", "cb", "result", "bb", "reader", "img", "hr", "rr", "r", "b", "bf", "fb", "jar", "bed", "buffer", "stream", "bt", "body", "src", "rb", "db", "fr", "ref"], "linea": ["linesa", "linas", "linp", " linean", "linkva", "framea", " lineaf", "frameA", " linep", "lina", "linaf", "linan", "LINEp", "linsa", "linka", "lineA", "seea", " lineas", "linva", "linep", "LINEsa", "frameas", " lineva", "sean", " lineaa", " linesa", "lineaf", "seas", "lineas", "linean", "lineva", "sea", "frameaa", " lineea", "lineea", "linkaf", "linaa", "LINEa", "LINEas", "linA", "lineaa", " lineA", "linkA"], "st": ["fe", "lt", "sth", "stri", "sh", "est", "string", "rest", "sm", "ost", "sf", "str", "d", "ist", "ft", "ST", "be", "sc", "pt", "sa", "rt", "first", "ct", "STR", "ste", "bl", "ld", "cl", "l", "trans", "s", "sn", "sp", "ast", "sl", "sta", "nd", "sb", "td", "set", "start", "St", "std", "sts", "se", "ser", "sv", "b", "stack", "t", "rd", "mt", "fr"], "login": ["resource", "pass", "status", "token", "username", "line", "blog", "string", "site", "register", "join", "photo", "secret", "title", "service", "facebook", "log", "phone", "display", "pin", "Login", "auth", "email", "summary", "connection", "layout", "security", "gin", "config", "license", "company", "home", "filename", "stat", "joined", "mobile", "picture", "plugin", "account", "id", "inc", "lock", "alias", "name"], "password": ["resource", "pass", "token", "username", "fax", "sword", "string", "access", "sudo", "secret", "service", "sha", "money", "Password", "PASS", "screen", "phone", "auth", "database", "email", "wd", "pad", "phrase", "security", "config", "session", "picture", "style", "account", "pattern", "alias", "mask", "name", "padding"], "profile": ["property", "role", "pass", "class", "username", "photo", "option", "secret", "title", "money", "family", "platform", "phone", "key", "summary", "email", "theme", "settings", "pocket", "name", "company", "filename", "mobile", "Profile", "type", "picture", "style", "module", "prof", "account", "alias", "site", "file", "person"]}}
{"id1": "14865947", "id2": "23335922", "code1": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 1, "substitutes": {"execute": ["action", "run", "exit", "send", "call", "ute", "invoke", "open", "process", "command", "task", " executing", "exec", "load", "complete", "evaluate", "start", "transfer", "test", "submit", "message", "loop", "launch", "Submit", "create"], "event": ["vent", "g", "context", "ex", "te", "ents", " Event", " EVENT", "ctx", "events", "object", "exec", "exc", "x", " events", "f", "other", "Event", "image", "ext", "v", "test", "ev", "ent", "t", "message", "ec"], "shell": ["il", "mail", "tty", "live", "ml", "window", "sh", "bot", "site", "environment", "o", "gui", "xml", "tool", "log", "ll", "lex", "tools", "search", "edit", "sol", "ui", "sync", "sql", "child", "build", "Shell", "bash", "cl", "l", "cell", "layout", "model", "exec", "cmd", "server", "sole", "system", "help", "math", "sl", "pool", "cli", "sb", "session", "hell", "dll", "nl", "home", "el", "lib", "cel", "kernel", "null", "prof", "pty", "loop", "lock", "console", " Shell"], "view": ["row", "views", "window", "container", "View", " layout", "gui", "service", "screen", "review", "display", "list", " overview", "tree", "VIEW", "ui", "visual", "summary", "object", "user", "book", "l", " preview", "show", "layout", "model", "iew", "url", "f", "control", "pool", "session", "image", "widget", "page", "v", "plugin", "web", "sel", "lock", "console", "version", "flow"], "rootFolder": [" rootArea", "RootZip", "bottomFile", "homeCenter", "shellDir", "rootFile", "parentFile", "mainfolder", "RootWindow", "rootWindow", "RootFolder", "shellFolder", " rootCenter", "homeFolder", "homeDirectory", " rootDir", " rootOrg", " rootFlow", "parentFlow", "mainFolder", " rootFile", " rootWindow", "RootDirectory", "bottomDirectory", " rootDirectory", "rootOrg", "shellArea", "RootOrg", "shellWindow", "rootFlow", "RootCenter", "rootDir", "rootDirectory", "rootfolder", "parentDirectory", "Rootfolder", "RootFile", "bottomFlow", "RootDir", "bottomFolder", "rootZip", "rootCenter", " rootfolder", "parentFolder", "parentZip", "RootArea", "rootArea", "mainOrg", "mainFile", " rootZip"], "dialog": ["clogg", "clect", "protogg", "logDialog", "challogging", "logogue", "challDialog", "dialogg", "challock", "logock", "challogs", "dialogs", "diffDialog", "diffock", "protect", "logog", "dialock", "dialect", "diffogue", "dialDialog", "dialogging", "logogs", "clogs", "diffog", "dialOG", "clogging", "challogue", "challogg", "protog", "challect", "protogging", "challOG", "dialogue", "logOG", "logogg", "clOG", "clog", "challog"], "password": ["resource", "pass", "root", "token", "username", "words", "sword", "description", "string", "mac", "channel", "pg", "word", "volume", "secret", "language", "Password", "sum", "wallet", "path", "PASS", "params", "patch", "key", "auth", "pad", "database", "wd", "email", "content", "mode", "address", "handler", "command", "p", "connection", "device", "cmd", "phrase", "prefix", "definition", "config", "size", "confirmed", "session", "value", "hash", "page", "diff", "directory", "data", "picture", "account", "message", "pattern", "source", "crypt", "text", "column", "name", "encrypted", "padding"], "md5": ["mand15", "mand2", "md50", "mand5", "MD2", "mg40", "MD40", "dd5", "MD5", " mddown", " md15", "mddown", "md2", "mg2", "mg50", "cmd2", "MDdown", "md15", "md4", " md4", " md2", "manddown", "dd2", "md40", "cmd4", "md512", "MD50", "MD15", "MD4", " md512", "cmd512", "MD512", "dd40", "dd50", "mg5", "mand512", "cmd5"], "md": ["df", "mb", "mg", "mp", "pd", "ms", "pm", "od", "mand", "mac", "m", "sm", " MD", "d", "sha", "sum", "msg", "MD", " ma", "bd", " digest", "meta", "wd", " sd", "mode", "ad", "M", "dd", "mc", "cd", "mod", "cmd", " dd", "ma", "mag", "nd", " cmd", "pkg", " mm", "dm", "hash", "html", " Md", "amd", "nm", "kg", "dig", "sd", "mm", "metadata", "bf", "mo"]}}
{"id1": "12055086", "id2": "20375440", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copyDeleing", " copyDeleteting", " copydeleter", " copyDequeting", " copyDeleteging", " copyDeleteter", " copyDeletter", " copydeleting", " copyDequeing", " copyDequeter", " copyDeletting", " copydeletting", " copydeleging", " copyDeleter", " copydeletging", " copyDeleteing", " copyDequeging", " copyDeletging", " copydeletter", " copyDeleging", " copydeleing"], "source": ["resource", "route", "use", "cache", "Source", "view", "inner", "service", "input", "copy", "ource", "down", "path", "from", "archive", "ie", "connection", "base", "s", "storage", "config", "f", "iter", "e", "i", "image", "SOURCE", "sin", "remote", "reader", "ources", "target", "stream", "master", "src", "site", "file"], "dest": ["folder", "pipe", "temp", "done", "slave", "class", "exit", "opt", "dist", "bin", "master", "destroy", "desc", "path", "die", "slice", "content", "dir", "comb", "default", "trans", "orig", "destruct", "tmp", "thin", "flat", "home", "Dest", "result", "img", "target", " destination", "de", "null", "wb", "src", "later", "file"], "buf": ["txt", "bh", "vec", "append", "cv", "ctx", "bd", "feed", "queue", "pad", "length", "seq", "bp", "loc", "batch", "br", "bag", "ff", "base", "pos", "rc", "cp", "cmd", "port", "tmp", "config", "bc", "Buffer", "code", "len", "off", "uf", "uc", "bytes", "cb", "result", "img", "data", "raw", "feat", "b", "bf", "buff", "fb", "buffer", "src", "rb"], "in": ["In", "plus", "stream", "again", "n", "c", "ini", "IN", "is", "din", "inner", "bin", "input", "con", "io", "pin", "ins", "min", "conn", "inn", "p", "up", "isin", "init", "win", "rin", "exec", "url", "gin", "read", "thin", "f", "inside", "i", "nin", "image", "socket", "sin", "login", "file", "reader", "data", "b", "inc", "id", "tin", "src"], "out": ["again", "at", "n", "o", "ex", "exp", "inner", "bin", "Out", "outer", "down", "io", "outs", "sync", "conn", "err", "up", "app", "part", "w", "win", "exec", "f", "pool", "i", "image", "lib", "socket", "writer", "ext", "img", "output", "obj", "OUT", "b", "inc", "parent", "buffer", "client", "file"], "count": ["ch", "use", "n", "c", "cache", "current", "zip", "depth", "limit", "sum", "path", "feed", "Count", "number", "key", "num", "length", "child", "weight", "part", "base", "all", "cond", "coll", "max", "size", "read", "index", "f", "pool", "code", "len", "allow", "ind", "start", "close", "val", "handle", "type", "b", "id", "lock", "offset", "parent", "buffer", "name"]}}
{"id1": "1769771", "id2": "14877116", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "copyChannel", "CopyFiles", "copyfile", "transferFiles", "copyFiles", "CopyChannel", " copyChannel", "CopyFile", "transferChannel", "transferfile"], "in": ["In", "again", "c", "IN", "m", "ex", "inner", "bin", "input", "io", "pin", "ins", "min", "inn", "l", "win", "base", "lin", "url", "query", "work", "config", "index", "f", "i", "image", "login", "reader", "diff", "data", "inc", "id", "source", "lock", "name", "file"], "out": ["resource", "external", "again", "n", "c", "string", "cache", "o", "ex", "call", "Out", "io", "outs", "conn", "user", "p", "up", "default", "w", "base", "prefix", "exec", "server", "x", "off", "image", "plain", "writer", "dot", "ext", "v", "output", "write", "OUT", "point", "b", "target", "name", "file", "extra"], "inChannel": [" inchannel", "insChan", "outchannel", "inputChannel", "inputStream", "winchannel", "winChannel", "binChan", "INStream", " inStream", "InChan", "inchannel", "winStream", "insClient", "binchannel", "InClient", "inStream", "winChan", "outStream", "insStream", "binClient", "INChannel", "inChan", "binChannel", "insChannel", "inClient", "INChan", "INchannel", "outChan", " inClient", "outClient", "inputChan", "InStream", "InChannel", " inChan", "Inchannel", "inputchannel", "binStream"], "outChannel": ["outputchannel", "outputChannel", " outChan", "outchannel", "inputChannel", "OutChannel", "OutConnection", "nStream", "Outchannel", " outManager", "inCh", "outManager", "inchannel", "outputStream", "outputController", "outputChan", "inStream", "nChan", "outStream", " outConnection", "inController", " outCh", "inChan", "inputController", "outCh", "outChan", "OutChan", " outchannel", "nManager", "inConnection", "outConnection", "inputChan", "outputCh", "nChannel", " outStream", "inputchannel", "inManager", "outController"]}}
{"id1": "6613944", "id2": "5135688", "code1": "    public static String installOvalDefinitions(final String xml_location) {\n        InputStream in_stream = null;\n        try {\n            URL url = _toURL(xml_location);\n            if (url == null) {\n                in_stream = new FileInputStream(xml_location);\n            } else {\n                in_stream = url.openStream();\n            }\n        } catch (IOException ex) {\n            throw new OvalException(ex);\n        }\n        Class<OvalDefinitions> type = OvalDefinitions.class;\n        OvalDefinitions object = _unmarshalObject(type, in_stream);\n        String pid = _getDatastore().save(type, object);\n        return pid;\n    }\n", "code2": "    private boolean saveNodeMeta(NodeInfo info, int properties) {\n        boolean rCode = false;\n        String query = mServer + \"save.php\" + (\"?id=\" + info.getId());\n        try {\n            URL url = new URL(query);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            byte[] body = Helpers.EncodeString(Helpers.ASCII, createURLEncodedPropertyString(info, properties));\n            conn.setAllowUserInteraction(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            setCredentials(conn);\n            conn.setDoOutput(true);\n            conn.getOutputStream().write(body);\n            rCode = saveNode(info, conn);\n        } catch (Exception ex) {\n            System.out.println(\"Exception: \" + ex.toString());\n        }\n        return rCode;\n    }\n", "label": 0, "substitutes": {"installOvalDefinitions": [" saveOvalRefaults", " saveOvaldefines", " saveOvalFplates", " saveOvalRefines", " saveOvalDefplates", " saveOvalRefplates", " saveOptDefinitions", " saveOvaldefplates", " saveOptDefines", " saveOptDefaults", " saveOvaldefaults", " saveOvalDefaults", " saveOvalRefinitions", " saveOptdefines", " saveOvalDefines", " saveOvalFines", " saveOptDefplates", " saveOptdefinitions", " saveOvalFinitions", " saveOptdefaults", " saveOvaldefinitions", " saveOptdefplates", " saveOvalFaults", " saveOvalDefinitions"], "xml_location": [" xml_path", " xml_area", "http_location", "xml_area", "xml_directory", "xml67loc", "xmlFilelocation", "xmlFilefilename", " xml_type", "xmlFilearea", "xml67path", "xml67location", "xml_filename", "http_loc", " xml_loc", "xml_path", "xml_type", " xml_filename", "xmlFileLocation", "xml_loc", " xml_Location", "xml67type", "http_directory", "xml_Location"], "in_stream": ["inc_cont", "in_channel", "thin67channel", " in_stack", "in67clean", "in67struct", "inc_stream", "in_cont", " in_url", "in_clean", "thin67stream", "in_stack", " in_trans", "thin_stream", "in_trans", "in_sw", "in_ream", "in67channel", "inc_clean", "inc_ream", " in_form", "in67sw", "thin_sw", "in67cont", "in67stream", "thin67struct", "in_form", "thin_struct", "thin_channel", "in67ream", "in_struct", "thin67sw", "in_url"], "url": ["resource", "stream", "ob", "string", "blog", "host", "http", "xml", "str", "www", "URL", "path", "ll", "log", "api", "open", "feed", "Url", "impl", "address", "bel", "bug", "loc", "browser", "l", "connection", "base", "ls", "coll", "location", "server", "sl", "f", "image", "socket", "html", "ssl", "bb", "page", "data", "fl", "obj", "b", "web", "source", "uri", "org", "file", "ref"], "type": ["group", "class", "function", "kind", "instance", "py", "o", "method", "http", "xml", "tool", "copy", "path", "platform", "key", "address", "single", "unit", "handler", "p", "part", "base", "tag", "pe", "element", "model", "port", "like", "category", "python", "link", "TYPE", "types", "format", "pod", "file", "Type", "product", "obj", "style", "module", "plugin", "null", "ype", "parser", "t", "info", "id", "parent", "collection", "name", "core", "ref"], "object": [" error", "class", "function", "project", "string", "instance", "oid", " obj", "o", "pointer", "version", "node", "objects", "os", "number", " python", "address", " structure", "document", "base", "part", "element", "model", "config", "array", "value", "result", "nt", "data", "product", "obj", "target", "id", "info", "parent", "name"], "pid": ["ping", "root", "pc", "pd", "sid", "oid", "pb", "pointer", "pse", "proxy", "ids", "bin", "uid", "abi", "pac", "pin", "pp", "pak", " tid", "p", "proc", "phi", "pos", "pins", "pa", "port", "phrase", "processor", "pkg", "lp", " pin", "iana", "product", "vid", " PID", "plugin", "ps", "jp", "pty", "id", "parent"]}}
{"id1": "6470716", "id2": "20920051", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"st": ["struct", "fe", "stage", "sth", "class", "est", "string", "rest", "ust", "sf", "ost", "str", "d", "ist", "www", "ft", "ST", "inst", "sc", "pt", "ct", "const", "ste", "ld", "cl", "s", "stress", "ast", "sb", "f", "sta", "code", "start", "St", "std", "sts", "r", "put", "t", "id", "tt", "Str", "src", "fr"], "url": ["or", "fr", "ob", "zip", "string", "blog", "host", "http", "tool", "pl", "www", "URL", "log", "path", "ll", "ur", "open", "feed", "gl", "Url", "impl", "download", "user", "address", "bel", "bug", "loc", "build", "err", "cl", "l", "connection", "base", "ls", "server", "coll", "sl", "f", "link", "hub", "ul", "image", "html", "ssl", "bb", "page", "fl", "b", "id", "web", "uri", "stream", "source", "org", "file"], "fis": ["afIs", "fips", "fIS", "flIs", "biss", "Fiss", "lils", "flos", "fli", "afis", " fips", "flils", "flris", "liss", "lris", "fils", "fIs", " fiss", "bos", "fris", "bi", "zris", "afiss", " fi", "FIS", "fi", " fris", "FIs", " fIS", "flis", "Fis", "zips", "fliss", " fils", "Fos", "bis", "lis", "afos", "Fris", "Fips", "fiss", "zIS"], "zis": ["zits", "ziss", " zais", "zeisa", "qbis", "qi", "zais", "zeIS", " ziss", "zisa", "zenis", " zisa", "zeips", "zipisi", " zips", "Ziss", "zipi", "zipits", " zits", "zipis", "qiss", " zisi", " zbis", "qis", "zenisi", "Zais", " zois", "zenais", "ezisa", "zbis", "zipois", "zipbis", "Zits", "zips", "zois", "zipais", " zIS", "ezIS", "zenois", "Zis", "ezis", "zisi", "zeis", "zipiss", "zi", " zi", "zIS", "ezips"], "entry": ["dc", "row", "or", "je", "fr", "ry", "country", "si", "line", "cat", "zip", "exp", "spec", "Entry", "comment", "inner", "ge", "feed", "match", "key", "la", "enter", "in", "object", "address", "archive", "ie", "part", "cell", "pe", "element", "rc", "sea", "sec", "ident", "index", "e", "ries", "session", "li", "image", "auto", "record", "result", "nt", "se", "next", "reader", "parse", "obj", "ent", "r", "de", "inc", "info", "ace", "cel", "file", "lc", "extra"], "count": ["use", "line", "c", "cache", "current", "depth", "limit", "more", "sum", "log", "feed", "Count", "list", "number", "add", "skip", "length", "child", "default", "part", "base", "max", "load", "size", "read", "index", "code", "len", "allow", "i", "ind", "start", "check", "_", "val", "counter", "type", "write", "en", "id", "parent", "buffer", "offset", "name", "file", "end"], "data": ["string", "cache", "zero", "dat", "shift", "results", "d", "str", "area", "input", "feed", "empty", "buf", "number", "length", "content", "p", "alpha", "batch", "load", "DATA", "size", "read", "block", "code", "len", "i", "value", "image", "start", "a", "bytes", "result", "reader", "error", "raw", "message", "info", "buffer", "text", "body"], "fos": ["Fol", "fnos", "fol", "zol", "frosh", "flos", "efoses", "froses", "fosh", "dfos", "efosh", "dfosi", "dfosh", "fros", "flOS", "flnos", "efos", "fOS", "fosi", "foses", "efosi", "frosi", "flol", "Fos", "FOS", "dfoses", "zos", "znos", "Fnos", "zOS"], "dest": ["dc", "cdn", "temp", "done", "txt", "wh", "exit", "zip", "rest", "dat", "dist", "inner", "transform", "sum", "desc", "di", "outer", "south", "die", "slice", "sync", "dev", "coord", "const", "loc", "sup", "trans", "default", "comb", "flash", "out", "tmp", "des", "home", "writer", "Dest", "result", "std", "img", "output", "test", "style", "target", "prop", "de", "source", "stream", "wb", "cont", "src", "later", "end"]}}
{"id1": "15799935", "id2": "20100809", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedBody", "saveAppensionFile", "saveAttachedbody", "saveAppachmentBody", "saveAppensionPart", "saveAppachmentPart", "saveAttensionPart", "saveAppachmentbody", "saveAppachmentFile", "saveAttachmentbody", "saveAttensionBody", "saveAttachmentPart", "saveAppensionbody", "saveAppensionBody", "saveAttensionbody", "saveAttPartbody", "saveAttachmentFile", "saveAttachedFile", "saveAttensionFile", "saveAttPartFile", "saveAttachedPart", "saveAttPartBody", "saveAttPartPart"], "context": ["resource", "subject", "media", "container", "support", "project", "front", "c", "cache", "Context", "host", "ca", "request", "present", "current", "view", "environment", "service", "state", "concept", "input", "cca", "manager", "ctx", "contact", "text", "queue", "network", "cms", "driver", "cf", "ce", "content", "translation", "document", "mc", "connection", "event", "coll", "component", "definition", "config", "system", "processor", "center", "reader", "kernel", "channel", "message", "parent", "community", "client", "collection", "version", "template"], "part": ["or", "section", "media", "position", "Part", "channel", "area", "comment", "phase", "service", "state", "partial", "Parts", "patch", "from", "place", "object", " Part", "mission", "translation", "p", "app", "connection", "base", "chapter", "upload", "component", "event", "per", "block", "pre", "image", "start", " parts", "plan", "to", "PART", "html", "parts", "type", "pod", "point", "po", "message", "parent", "source", "body", "name", "art", "file"], "localAttachment": ["localAddail", "localExtention", "localAddachment", "LocalAssachment", "localAttment", " localExtachment", "localPartachment", "localAddention", "localAssention", "localInstribution", "LocalAttment", "localAssachment", "localAttachacher", "localExtacement", "localAttachachment", " localExtacher", "localAttacement", "localattrollment", "localAddment", " localAttrollment", "localInstension", "localAttachribution", "localArtention", " localAttacement", " localAttachachment", "localAssment", "localAvacher", "localAssail", "localAttacher", "LocalAttention", "localAttachension", "LocalAssail", "localattment", "localAttribution", " localAttribution", "localattachment", " localPartention", "localPartension", "LocalAssention", "localAttachacement", "localAvachment", "localAvention", "localattention", "localAvacement", "localAttrollment", "localAttail", "localArtachment", "LocalAttail", "LocalAttachment", " localPartachment", " localAttention", " localPartribution", "LocalAssment", "localPartention", "localArtail", "localAddrollment", " localExtacement", " localAttension", "localInstachment", " localExtention", "localExtachment", "localAttachention", " localAttachrollment", "localAttention", "localExtacher", " localAttachention", " localAttacher", " localAttment", "localPartribution", "localArtment", "localAttachrollment", " localPartension", "localInstention", "localAttension"], "accountId": ["AccountName", "accountName", "feedName", "accId", "jobName", "accInfo", "jobid", "appID", "contractid", "contactId", "jobId", "feedId", "jobID", "AccountID", "appInfo", "accid", "feedid", "accountInfo", " accountInfo", "feedID", "contactid", "accID", "contactName", " accountid", "accountid", " accountID", " accountName", "appId", "Accountid", "AccountId", "accountID", "contractId", "contractName", "appid"], "attachmentId": ["attentionInfo", "attachmentID", "attentionid", "extensionid", "attachmentUrl", "attmissionId", "addentionUrl", "attachmentName", "attentionIndex", "attagramID", "attmissionID", "attmentID", "attentionID", "atachmentReference", "attmentName", "attachmentSource", "attociationID", "atachmentName", "adentionId", "attptionId", "attachmentType", "extensionID", "attensionid", "attociationName", "attachedID", "adentionIndex", "attptionIndex", "extensionId", "attmentReference", "atociationName", "adentionID", "adachmentIndex", "extachmentId", "extachmentSource", "attlementId", "attentionId", "attlementReference", "atociationId", "atachmentId", "addentionId", "attachedType", "attachmentInfo", "addachmentID", "extachmentID", "attentionType", "attociationReference", "adachmentId", "attptionID", "attagramIndex", "atachmentID", "attensionId", "attagramInfo", "attentionSource", "addentionType", "addachmentType", "attentionUrl", "extachmentid", "attmissionSource", "attachmentIndex", "atociationReference", "attensionID", "attachedId", "attmissionid", "adachmentID", "addentionID", "addachmentId", "attachedUrl", "attmentId", "attachmentid", "extensionSource", "attlementName", "attagramId", "atociationID", "attachmentReference", "attlementID", "attociationId", "adachmentInfo", "adentionInfo", "addachmentUrl", "attensionSource", "attociationUrl", "attptionInfo", "attociationType"], "in": ["In", "or", "pull", "plus", "pass", "again", "ini", "IN", "cin", "is", "inner", "din", "bin", "input", "copy", "as", "con", "slice", "pin", "ins", "ac", "conn", "inn", "p", "err", "it", "up", "init", "url", "load", "gin", "f", "inside", "i", "nin", "a", "image", "socket", "login", "reader", "data", "inc", "id", "info", "source", "file"], "saveIn": ["writein", "aveIn", "stageAs", "aveOut", "aveAs", "saveIns", "savIn", "savin", " savein", "writeIN", "stageIn", "saveOut", "stageIns", "SaveAs", "SaveOut", "SaveIn", " saveOut", "aveIN", "savAs", "writeOut", "stageOut", "savein", "writeIn", "saveIN", "savOut", " saveIns", "SaveIns", "avein", " saveIN"], "saveAs": ["createAt", "createAS", "createFile", "saveFile", "openFile", "SaveAS", "saveAt", "saveOut", " saveFile", "SaveAs", "SaveOut", "openAt", "SaveIn", "copyIn", " saveOut", " saveAS", "writeAS", "copyas", "Saveas", " saveAt", "writeAs", "writeOut", "openAS", "writeIn", "openAs", "saveas", "copyAs", "copyAS", "saveAS", " saveas", "createAs"], "out": ["temp", "plus", "line", "at", "again", "string", "c", "cache", "o", "ex", "inner", "bin", "Out", "copy", "as", "path", "outer", "io", "outs", "this", "sync", "conn", "err", "up", "default", "init", "s", "exec", "other", "off", "a", "image", "to", "writer", "v", "page", "output", "ext", "data", "OUT", "null", "inc", "source", "client", "name", "file", "flow"], "copySize": ["savesize", "byteSize", "CopyTime", "lesize", "openSIZE", "openSize", "copyTime", " copyTime", "copyLength", "byteTime", "byteAddress", "leSize", "CopyLength", "bytesize", "leLength", "leSIZE", "copySIZE", " copyAddress", "CopySize", " copyLength", "saveLength", " copysize", "openLength", "copyAddress", "copysize", "opensize", "saveAddress", "saveSize", "byteLength", " copySIZE", "Copysize"], "contentUriString": ["contentUiostring", "contentUpiStr", "contentIriNumber", "contentUriUnit", "contentUridUnit", "contentUuriStr", "contentUrisUnit", "contentUrisString", "contentIriUnit", "contentUpiInt", "contentUiString", "contentUuriString", "contentUrisStr", "contentUiniString", "contentIiStr", "contentIrisInt", "contentUridStr", "contentIiByte", "contentIriStr", "contentUristring", "contentIriInt", "contentIriByte", "contentUuriNumber", "contentIristring", "contentIrisStr", "contentUiNumber", "contentUiniStr", "contentUiUnit", "contentIiString", "contentUiniNumber", "contentUriNumber", "contentUriInt", "contentUrisstring", "contentIrisstring", "contentUiStr", "contentUridString", "contentUioString", "contentIiNumber", "contentIriString", "contentUriByte", "contentUiByte", "contentIrisString", "contentUioStr", "contentUpiString", "contentUioInt", "contentIrisUnit", "contentUriStr", "contentUiniByte", "contentUpistring", "contentUrisInt", "contentUuriByte"], "mSize": ["iName", "cName", "pLength", "iLength", "cSize", "cCount", "cLength", "iSize", "iCount", "mCount", "pCount", "mLength", "pName", "mName", "pSize"], "mContentUri": ["mResourceUci", "mResourceIris", "mContentOUric", "mContentUrri", "mContentUris", "mResourceUris", "mContentOUci", "mContentIci", "mContentUrris", "mContentUci", "mContentUrric", "mResourceIric", "mResourceUric", "mContentIri", "mContentOUris", "mContentOUri", "mResourceUri", "mContentIris", "mContentUric", "mContentUrci", "mResourceIri", "mResourceIci", "mContentIric"], "cv": ["VC", "que", "ctrl", "auc", "nv", "fc", "cm", "GV", "c", "vv", "ca", "pb", "um", "cover", "CV", "conv", "xc", "ctx", "sc", "co", "buf", "uv", "cf", "cu", "iq", "content", "loc", "vm", "cc", "cr", "mc", "cd", "vc", "csv", "rc", "vs", "cp", "coll", "cs", "bc", "enc", "lv", "av", "cap", "vr", "uc", "cb", "fp", "v", "lc", "sv", "nc", "iv", "ov", "keep", "core", "vp"], "uri": [" scheme", "resource", " ur", "attribute", "route", "qi", "username", " Uri", "string", "href", "pi", "oid", "environment", "universal", "http", "proxy", "uid", "ci", "path", "api", "ui", "ri", "address", "URI", "gb", "base", " URI", "storage", "prefix", "url", "query", "location", "cli", " url", "i", "iri", "format", "range", "mi", "data", "point", "metadata", "id", "iv", "uni"]}}
{"id1": "1180878", "id2": "13063241", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchUrldata", "fetchUrlDATA", "fetchHTTPDATA", "fetchHTTPdata", "fetchUrlData", "frieveURLdata", "frieveUrlData", "frieveUrlDATA", "fetchURLdata", "fetchJSONData", "fetchURLDATA", "fetchJSONDATA", "fetchHTTPData", "fetchJSONdata", "frieveURLData", "frieveUrldata", "frieveURLDATA"], "url": ["resource", "username", "string", "host", "href", "view", "http", "xml", "www", "URL", "path", "ur", "api", "feed", "gl", "Url", "download", "user", "address", "loc", "l", "connection", "base", "ls", "server", "location", "sl", "f", "filename", "image", "el", "page", "html", "ssl", "data", "fl", "uri", "source", "text", "src", "name", "file"], "proxyHost": ["ProxyDomain", "Proxyhost", "ProxyServer", " proxyAddress", "cachehost", "proxyHead", "ProxyAddress", "baseHead", "baseHost", " proxyPath", "serverHost", "proxyAddress", "proxyDomain", "ProxyPort", "serverServer", "serverPath", "proxyServer", "baseDomain", "remoteHead", "serverAddress", "cacheHost", "ProxyHead", "ProxyHost", "remoteHost", "baseAddress", " proxyhost", "cachePort", "remoteDomain", "remoteAddress", "cacheAddress", " proxyServer", "proxyPath", "ProxyPath", "proxyhost"], "proxyPort": [" proxyport", "ProxyServer", " proxyAddress", "ProxyAddress", "proxyport", "proxyAddress", "Proxyport", "httpServer", "ProxyPort", "httpPort", "httpHost", "proxyServer", "cacheHost", "ProxyHost", "cachePort", "cacheport", "cacheAddress", "httpAddress", " proxyServer"], "con": ["ch", "ctrl", "pc", "ca", "http", "ci", "can", "out", "fac", "don", "pub", "socket", "gen", "ai", "fl", "ec", "ver", "fa", "an", "c", "cache", "rec", "cone", "fun", "xc", "pin", "cc", "cl", "connection", "mc", "win", "cn", "cp", "ocon", "cur", "x", "per", "pre", "login", "en", "conf", "sub", "connect", "re", "cm", "n", "act", "go", "conv", "open", "co", "sync", "cf", "ac", "min", "cr", "part", "rc", "ls", "f", "Con", "uc", "fan", "com", "run", "fc", "cas", "cons", "func", "canon", "ran", "conn", "on", "exec", "syn", "bc", "CON", "close", "remote", "change", "inc", "pen", "un", "common"], "is": ["ib", "il", "ics", "or", "js", "us", "si", "isa", "ios", "im", "serv", "bs", "isl", "act", "ir", "was", "state", "iris", "oss", "has", "as", "ci", "api", "can", "ais", "os", "IS", "abs", "cms", "in", "ri", "conn", "are", "does", "ie", "it", "p", "fs", "isin", "s", "Is", "out", "vs", "iss", "iso", "ar", "get", "sp", "ops", "cos", "its", "ws", "cs", "isi", "isc", "i", "ori", "bis", "mis", "lis", "ai", "isu", "ps", "id", "es", "info", "ris"], "u": ["iu", "us", "uci", "c", "ru", "m", "o", "http", "U", "ur", "io", "api", "os", "yu", "ue", "ui", "uv", "cu", "user", "conn", "p", "up", "l", "ut", "f", "fu", "su", "i", "q", "ul", "h", "uc", "hu", "file", "v", "ou", "tu", "b", "uri", "nu", "client", "lu", "un"], "proxy": ["resource", "timeout", "fe", "pc", "cop", "plus", "shadow", "ip", "zip", "c", "cache", "host", "http", "roxy", "pse", "copy", "api", "phone", "force", "pin", "xy", "address", " proxies", "p", "l", "connection", "pe", "pa", "port", "server", "Proxy", "clone", "x", "config", "bean", "pool", "f", "wrapper", " Proxy", "lib", "socket", "remote", "ssl", "type", "web", "XY", "uri", "prot", "client", "create"], "baos": ["abis", "caOS", "aas", "caos", "boas", "paOS", "abos", "bao", "Baros", "bolos", "bais", "baas", "balos", "paos", "baOs", "BAOs", "alos", "pais", "aos", "Bais", "BAis", "calos", "boos", "haOS", "Baos", "baOS", "baros", "caas", "hais", "aOS", "BAos", "haos", "hao", "BAOS", "BAros", "abros", "BaOs", "pao", "boOS", "abOs", "BAo"]}}
{"id1": "3046085", "id2": "822452", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"s": ["S", "ses", "n", "string", "g", "m", "str", "is", "sets", "gs", "path", "south", "params", "in", "content", "sound", "sample", "p", "w", "strings", "sb", "f", "services", "e", "i", "ns", "a", "speech", "v", "joined", "data", "parts", "r", "b", "t", "es", "source", "text", "name", "ss"], "tokenizer": [" tokenizable", "tokenzer", "widgetizable", "tokener", " tokenner", " tokenize", " tokenization", "optiminer", "initializable", "tokeniser", "generizer", " tokenizers", "Tokenister", "okenizers", "widgetizer", " tokeniser", "statiter", "generiser", "Tokeniner", "okeniner", "tokenener", "generize", "toolize", "Tokener", "okenizer", "tokenner", "Tokenize", "tokenization", " tokenator", "tokenize", "initialization", "tunzer", "logizable", "okeniser", "tokenized", "tokenizers", "statator", "normalize", " tokenized", "finizable", "tokenator", "okenzer", "normalizer", "okenener", "okener", "okenator", "toolizable", "finize", "initializer", " tokener", "initialiner", "finer", "finizer", "logizer", "optimiser", "okeniter", "tunizer", " tokenzer", "Tokenizers", "Tokenener", "widgetiser", "initialiser", "Tokenizer", " tokenister", "generized", "tuner", " tokeniter", "tokenizable", "tokenister", " tokenener", "Tokenizable", "Tokenized", "tokeniter", "tooliner", "optimizer", "okenization", "okenner", "tokeniner", "toolizer", "statizers", "tunner", "initialize", "normaliner", "logize", "okenize", "loginer", "Tokeniser", "okenizable", "normalizable", "widgetiner", "statizer", "optimizable", "okenister"], "title": ["resource", "Title", "media", "username", "team", "owner", "description", "bot", "string", "layer", "label", "meta", "summary", "music", "theme", "genre", "profile", "audio", "tag", "prefix", "url", "license", "company", "filename", "format", "editor", "author", "type", "song", "data", "metadata", "source", "text", "name", "art", "album"], "artist": ["track", "voice", "media", "username", "player", "piece", "photo", "cover", "winner", "master", "layer", "patch", "music", "theme", "creator", "archive", "alias", "audio", "Artist", "genre", "video", "tag", "prefix", " artists", "episode", "season", "filename", "image", "author", "song", "target", "metadata", "source", "chart", "art", "album"], "location": ["media", "position", "description", "gallery", "photo", "motion", "area", "region", "language", "time", "layer", "path", "length", "content", "theme", "address", "loc", "audio", "lang", "tag", "layout", "Location", "url", "image", "mobile", "level", "message", "album"], "rating": ["tracking", "scoring", "training", "live", "ranking", "rising", "media", "boarding", "description", "breaking", "repeat", "random", "weight", "alpha", "genre", "audio", "rate", "score", "rank", "sharing", "playing", "game", "season", "resolution", "style", "fps", "album", "padding"], "overplay": ["offload", "offlay", "offledge", "overload", "reledge", "offplay", "overledge", "reload", "overlay", "replay", "opplay", "relay", "opledge", "oplay", "opload"], "temp": ["track", "txt", "stage", "media", "string", "cache", "current", "str", " temporary", "path", "partial", "sequence", "pt", "list", "empty", "content", "music", "original", "unit", "loc", "part", "tag", "base", "layout", "prefix", "tmp", "fake", "flat", " tmp", "emp", "format", "test", "Temp", "data", "type", "stable", "testing", "style", "message", "source", "font", "body", "name", "tc", "template"], "tags": ["reports", "names", "packages", "words", "stats", "bugs", "resources", "videos", "bots", "authors", "ids", "terms", "relations", "images", "styles", "files", "events", "notes", "properties", "plugins", "tests", "strings", "fields", "dates", "stars", "tracks", "thumbnails", "types", "phones", "features", "archives", "Tags", "comments", "users", "products", "sections", "assets", "modules"], "bytes": ["pages", "Bytes", "words", "fee", "codes", "bps", "lines", "videos", "values", "errors", "gets", "params", "bits", "outs", "objects", "letters", "articles", "files", "notes", "seconds", "tes", "pieces", "strings", "balls", "size", "keys", "blocks", "units", "ips", "parts", "data", "comments", "es", "les", "body"], "hasher": ["hahers", "haveher", "hanhr", " haser", "hasumper", "hashest", "hanest", "haest", "havehr", "hashher", "haveest", "Hasest", "hashumper", " hashers", "haveer", "hadher", "hashed", "hanher", "hashandler", "hashhandler", "Hashers", " hashed", " hashr", "hashr", "haner", "hadest", "hashers", "haer", "havehandler", "haser", "haher", "Hashed", "hadumper", "hadhandler", "Haser", "hahed", " hasest", "haveumper", "hasest", "Hasher"]}}
{"id1": "5061606", "id2": "20011285", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNequessnecessary", "createSettingsIfNececary", "createSettingsIfNecessarily", "createSettingsIfNeceseless", "createSettingsIfNequessarily", "createSettingsIfNequccessnecessary", "createSettingsIfNequessary", "createSettingsIfNecesarily", "createSettingsIfNececnecessary", "createSettingsIfNecesseless", "createSettingsIfNecesary", "createSettingsIfNecccessary", "createSettingsIfNecccessarily", "createSettingsIfNececeless", "createSettingsIfNecccesseless", "createSettingsIfNequccessarily", "createSettingsIfNequesseless", "createSettingsIfNececarily", "createSettingsIfNecccessnecessary", "createSettingsIfNequccesseless", "createSettingsIfNequccessary", "createSettingsIfNecessnecessary", "createSettingsIfNecesnecessary"], "out": ["timeout", "group", "window", "exit", "again", "at", "cache", "channel", "o", "ex", "bin", "Out", "copy", "path", "log", "io", "outs", "this", "sync", "conn", "object", "user", "cookie", "err", "up", "app", "connection", "net", "init", "model", "exec", "server", "prefix", "url", "config", "array", "pool", "index", "off", "i", "password", "by", "image", "a", "socket", "writer", "editor", "plain", "result", "page", "output", "error", "data", "write", "obj", "OUT", "null", "plugin", "flush", "parent", "source", "lock", "client", "name", "file"], "fSettings": ["fileSetting", "fmSetting", "rfSettings", "fJs", " fSetting", "fmSetup", " fettings", "fmConfig", "FConfig", "fSetting", "rfFs", "filesettings", "fileSettings", " fJs", "FSetup", "fSetup", "fsSettings", "sfettings", "fileettings", "rfConfig", "fsSetup", "fsConfig", "FSettings", "sfsettings", " fFs", "sfSettings", "sfSetting", "sfJs", "Fsettings", "fConfig", "fmSettings", " fsettings", "rfSetting", "FJs", "fsSetting", "fettings", "fsettings", "fsFs", "FSetting", "fFs", " fConfig"], "src": ["ctr", "route", "string", "str", "dist", "ource", "path", "lower", "sc", "text", "sr", "attr", "dest", "ins", "loc", "gb", "base", "rc", "storage", "tmp", "url", "cur", "config", "settings", "sl", "sb", "filename", "uc", "fp", "cb", "ssl", "img", "st", "req", "b", "prot", "sub", "source", "stream", "uri", "sel", "rb", "file", "ref"], "in": ["In", "again", "ini", "n", "c", "IN", "inner", "din", "bin", "input", "copy", "path", "con", "ins", "inn", "err", "kin", "l", "connection", "init", "win", "s", "rin", "url", "gin", "thin", "f", "index", "i", "image", "sin", "login", "reader", "data", "r", "b", "inc", "id", "source", "stream", "file"]}}
{"id1": "6190356", "id2": "2009072", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "label": 0, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForOldM5", " hashPasswordForOldM3", " hashPasswordForNewM512", " hashPasswordForOldM512", " hashPasswordForNewMD5", " hashPasswordForOldMC5", " hashPasswordForOldmd4", " hashPasswordForNewM3", " hashPasswordForOldM4", " hashPasswordForOldMC3", " hashPasswordForOldMD3", " hashPasswordForOldmd5", " hashPasswordForOldmd3", " hashPasswordForNewMD512", " hashPasswordForNewMD4", " hashPasswordForOldMD512", " hashPasswordForOldMC512", " hashPasswordForNewM5", " hashPasswordForOldMD4", " hashPasswordForOldMC4", " hashPasswordForNewM4", " hashPasswordForOldmd512", " hashPasswordForNewMD3"], "password": ["pass", "words", "username", "token", "seed", "sword", "string", "word", "secret", "input", "Password", "PASS", "wallet", "path", "key", " passwords", "auth", "pad", "wd", "content", "address", "p", " Password", "phrase", "array", "code", "value", "hash", "result", "data", "account", "message", "pattern", "buffer", "crypt", "text", "name", "encrypted", "padding"], "md": ["dc", "df", "mb", "mp", "pd", "pm", "od", "mand", "clean", "mac", "Cmd", "m", "pg", "rm", "um", " MD", "km", "d", "hm", "di", "MD", "bd", "meta", "wd", "hd", "vm", "dd", "mc", "cd", "mod", "cmd", "mag", "ma", "f", "am", "gd", "ind", "dm", "nm", "amd", "managed", "rpm", "dig", "mm", "metadata", "vd", "grad", "mt", "mo"], "messageDigest": ["messageDest", "MessageAddest", "messageDester", " messageDigester", "messageDigse", "messageModests", "messageModEST", " messageModests", "MessageDigester", "messageAddse", "messagedigest", "messageDigester", "messagedigse", "messagedigester", "messageModester", "MessageAddester", "messageDigEST", " messageDigests", "messageAddester", "MessageAddse", "MessageDigEST", "messagedigEST", " messageModest", "messageDigests", "messagedigests", "messageAddests", "messageAddEST", "MessageModse", "MessageModester", "MessageModest", "messageDEST", "MessageDigest", " messageModester", "messageDse", "MessageAddEST", "messageModest", "MessageModEST", "MessageDigse", "messageAddest", "messageModse", " messageDigEST", " messageModEST"], "hexString": ["crossFunction", "stringService", " hexFile", "tempstring", "hashString", "stringString", "tempFunction", "sumFile", "transformBuffer", "hexstring", "hexFile", "transformString", "hashService", "crossString", "hashSection", " hexstring", "sumstring", "octString", "transformArray", "hexSection", " hexBuffer", "stringSection", "hexArray", " hexArray", "hexBuffer", "hexService", "stringArray", "tempFile", "transformStr", "sumString", "octArray", "hexStr", " hexService", "tempString", "crossStr", "hexFunction", "octBuffer", "octStr", "tempStr", "sumStr", "crossstring", " hexFunction", "hashArray", " hexSection", " hexStr"], "i": ["si", "qi", "ip", "u", "multi", "n", "c", "ii", "m", "pi", "k", "o", "d", "ci", "di", "io", "slice", "ji", "ui", "length", "ri", "bi", "p", "l", "phi", "s", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "a", "h", "v", "ti", "ai", "r", "b", "xi", "t", "id", "info", "uri", "ix"], "hex": ["temp", "cmp", "ip", "nexus", "full", "string", "cache", "utf", "zero", "host", "rh", "ex", "exp", "http", "shift", "str", "character", "pixel", "transform", "path", "none", "char", "bit", "json", "length", "letter", "lit", "cookie", "batch", "alpha", "default", "oct", "orig", "hello", "pex", "he", "serial", " Hex", "rex", "comp", "sex", "hash", "h", "format", "result", "data", "raw", "digit", "null", "pack", "hack", "buff", "pattern", "binary", "text", "form"]}}
{"id1": "15797402", "id2": "19322946", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    @Test\n    public void test_lookupType_FullSearch_MatchingWordInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupType/cluster\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":29055,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":29056,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29065,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":29066,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29069,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":29070,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29095,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":29096,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":21013,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Sensor Cluster\\\",\\\"icon\\\":\\\"54_03\\\"},{\\\"itemTypeID\\\":21014,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":32241,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Drive Cluster EDF-285\\\",\\\"icon\\\":\\\"24_11\\\"},{\\\"itemTypeID\\\":5279,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"F-23 Reciprocal Sensor Cluster Link\\\",\\\"icon\\\":\\\"03_09\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11534,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":17340,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11536,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":17333,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11535,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":17345,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6218,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6222,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected LADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6226,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6230,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Multi-Frequency Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6234,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected RADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":7895,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7893,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7914,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7896,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Omni Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7892,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Radar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11537,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":17336,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Gravimetric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6241,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed LADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Magnetometric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6239,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Multi-Frequency Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6225,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed RADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":20238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20244,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20250,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20260,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20240,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20246,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20252,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20262,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":21722,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Sleeper Nanite Cluster\\\",\\\"icon\\\":\\\"55_15\\\"},{\\\"itemTypeID\\\":20242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20248,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20254,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20264,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"parse": [" transform", "wrap", "processing", "pc", "scan", " rewrite", "request", "view", "xml", "http", "cover", "service", "transform", "report", "patch", "process", " split", "print", " parsing", "rate", "replace", " parser", "fork", "Parser", " serve", "load", "read", "php", " analyse", "arse", "set", "worker", "split", " dispatch", "handle", "apply", "se", " convert", "save", "raw", " process", "pack", "parser"], "stream": ["resource", "temp", "draw", "channel", "view", "http", "inner", "src", "input", "response", "down", "feed", "in", "download", "content", "iterator", "sample", "video", "document", "Stream", "upload", "server", "url", "load", "loader", "read", "image", "through", "writer", "handle", "remote", "reader", "data", "raw", "stack", "message", "source", "client", "form", "file"], "handler": ["application", "function", "channel", "host", "pointer", "phase", "service", "response", "layer", "manager", "ctx", "di", "driver", "hand", "Handler", "default", "connection", "base", "event", "server", "loader", "processor", "controller", "wrapper", "writer", "format", "handle", "h", "reader", "data", "handled", "parser", "info", "parent", "client", "collection", "monitor"], "metadata": ["property", "resource", "attribute", "subject", "map", "management", "mx", "m", "xml", "state", "manager", "ctx", "params", "di", "meta", "database", "json", "properties", "content", "header", "runtime", "document", "metry", "connection", "storage", "component", "config", "processor", "adata", "material", "directory", "managed", "data", "mi", "mon", "md", "module", "plugin", "parser", "message", "info", "mt", "uri", "source", "collection", "met", "monitor", "template"], "context": ["resource", "txt", "entry", " Context", "subject", "cmp", "instance", "Context", "environment", "method", "request", "xml", "proxy", "scope", "concept", "manager", "ctx", "content", " contexts", "object", "translation", "command", "document", "mc", "connection", "element", "event", "component", "system", "config", "processor", "tx", "reader", "data", "kernel", "message", "parent", "text", "collection"], "name": ["Name", "names", "resource", "action", "large", "route", "class", "full", "n", "string", "m", "word", "call", "version", "comment", "named", "old", "time", "path", "label", "search", "api", "key", "none", "sync", "in", "active", "on", "no", "object", "address", "child", "missing", "default", "part", "base", "connection", "prefix", "model", "url", "work", "size", "code", "filename", "image", "ame", "NAME", "type", "data", "null", "id", "message", "job", "source", "alias", "file", "common"], "out": ["resource", "temp", "window", "line", "again", "instance", "channel", "o", "ex", "ray", "exp", "bin", "Out", "copy", "path", "manager", "io", "outs", "sync", "in", "object", "conn", "child", "user", "err", "connection", "server", "url", "cos", "pool", "image", "lib", "socket", "writer", "plain", "result", "page", "ext", "output", "data", "obj", "OUT", "null", "flush", "source", "client", "builder", "file", "extra"]}}
{"id1": "14877116", "id2": "15465293", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"Usage:  URLDumper <URL> <file>\");\n            System.exit(1);\n        }\n        String location = args[0];\n        String file = args[1];\n        URL url = new URL(location);\n        FileOutputStream fos = new FileOutputStream(file);\n        byte[] bytes = new byte[4096];\n        InputStream is = url.openStream();\n        int read;\n        while ((read = is.read(bytes)) != -1) {\n            fos.write(bytes, 0, read);\n        }\n        is.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"cpFile": [" copyfile", " copyFiles", "Copyfile", "cpCode", " cpFiles", "cpfile", " cpCode", " cpfile", "CopyFiles", " copyCode", "CopyCode", " copyFile", "CopyFile", "cpFiles"], "source": ["resource", "scene", "route", "subject", "use", "token", "seed", "project", "zip", "string", "current", "site", "host", "context", "Source", "view", "table", "channel", "service", "scope", "self", "node", "ource", "path", "from", "force", "slice", "this", "dest", "database", "ce", "object", "archive", "unit", "template", "grade", "connection", "base", "document", "element", "server", "url", "component", "config", "iter", "SOURCE", "start", "image", "Target", "remote", "se", "directory", "secure", "ources", "type", "null", "parent", "stream", "client", "name", "file", "reference"], "target": ["folder", "resource", "root", "route", "token", "external", "owner", "project", "global", "current", "host", "site", "table", "proxy", "service", "self", "copy", "transform", "ource", "path", "force", "tail", "sync", "dest", "arget", "database", "download", "client", "object", "content", "origin", "boot", "archive", "alias", "it", "connection", "base", "port", "server", "url", "component", "config", "other", "iter", "director", "home", "top", "format", "Target", "to", "remote", "result", "next", "reference", "nt", "type", "range", "output", "null", "parent", "master", "name", "tor", "file", "template"], "replace": ["inline", "root", "share", "route", "align", "use", "rm", "include", "append", "reply", "fill", "cover", "remove", "copy", "same", "protect", "match", "move", "only", "force", "add", "sync", "place", "compatible", "repeat", "re", "store", "insert", "rel", "flash", "placed", "delete", "complete", "array", "other", "allow", "hide", "split", "repl", "apply", "change", "range", "reset", "follow", "write", "multiple", "update", "stall"], "bufferSize": ["queueSize", "byteSize", "queueCount", " buffersize", "byteLen", "serversize", "bufferLen", "bufferSIZE", " bufferSIZE", "queueLen", "queuesize", " bufferLen", "bytesize", "flushSize", "buffersize", "flushSIZE", "serverSIZE", "bufferCount", "flushLen", "serverLen", " bufferCount", "serverSize", "flushsize", "byteCount"], "src": ["resource", "sh", "zip", "rec", "Source", "ruby", "proxy", "input", "copy", "ource", "ctx", "inst", "sc", "sr", "sys", "dest", "sync", "rt", "in", "archive", "fn", "loc", "flash", "proc", "gb", "reflect", "rc", "tmp", "server", "cur", "url", "bc", "sl", "sb", "gz", "start", "socket", "cb", "result", "RC", "ssl", "secure", "ser", "ources", "obj", "req", "sub", "stream", "sel", "rb", "sq"], "tarn": ["etarn", " tarm", "yern", "taran", "ttron", "tharo", "etreen", "yaran", "tarm", "taro", "thern", " tern", "Tarm", "wtarm", "tron", "ttaron", "Treen", " tron", "yarn", "taron", "ttaro", "etann", "ntaron", " taur", "ttarp", " treen", "taur", "wtern", "tarp", " tann", "ttarn", "Tann", "tann", "ntarn", "Trn", "trn", "tern", "thaur", " trn", "wtaran", "Taran", "Tron", "treen", "Tarn", "tharn", "wtarn", "ttaur", "ttrn", "etaran", "ttarm", "ntann", " taran", "yarm", "ttann", " taron", "ntarp", " tarp", " taro", "ttern"], "tardir": ["tardsdir", "tildiri", "sardir", "Tartir", "Tardiri", "Tardir", "tildart", "tildar", "Tartar", "Tardirs", "sardirt", "tartirt", "tardar", "tarpirt", "tartiri", "tardsar", "sardsar", "tardire", "tartir", "tarddir", "tardsire", "tardsir", "tartart", "sardsir", "sardsirt", "Tartirs", "tarpar", "Tardar", "Tartart", "tarart", "sardire", "sardar", "tarpir", "tardart", "tarpire", "tariri", "tardedpath", "tartire", "tartar", "Tardart", "Tartiri", "tartpath", "tardedirs", "tarar", "tardiri", "tardeddir", "tardpath", "tardedir", "tardsirt", "tardspath", "tardirt", "tarir", "Tartdir", "tartdir", "tardirs", "sardsire", "tildir", "Tartpath", "Tarddir", "tartirs", "tardsirs", "Tardpath"], "n": [" i", "nb", "pn", "u", "nw", "N", "k", "c", "g", "m", "o", "d", "na", "dn", "z", "norm", "none", "number", "nn", "in", "num", "min", "nor", "conn", "fn", "p", "l", "ng", "cn", "j", "mn", "coll", "sn", "x", "e", "ns", "nl", "i", "ni", "rn", "ne", "v", "nt", "en", "nc", "nu", "ln", "un"], "tar": ["temp", "large", "cloud", "war", "cat", "sh", "zip", "ca", "ray", "safe", "raf", "sum", "copy", "shr", "tg", "shape", "tan", "di", "box", "sr", "dest", "skip", "tr", "cro", "archive", "ra", "trans", "flash", "cr", "tf", "tif", "csv", "tmp", "ar", "dr", "cos", "gz", "tc", "transfer", "test", "sv", "pack", "jar", "rar", "car", "buffer", "par", "Tar", "file"], "bytes": ["pages", "reads", "Bytes", "classes", "words", "bs", "bps", "resources", "lines", "ones", "values", "eps", "io", "bits", "outs", "bles", "os", "objects", "files", "boot", "seconds", "tes", "steps", "nets", "pieces", "cells", "out", "vs", "ls", "ops", "keys", "blocks", "frames", "vals", "data", "runs", "items", "ipes", "b", "ps", "es", "les", "rows"], "readn": ["findne", "findlen", "findN", " readlen", "Readn", "writelen", "ReadN", "writeno", "passN", "readne", " readne", "writen", "readl", "passno", " readN", "Readlen", "readlen", "writeN", "readns", "runl", "writens", "runno", "readno", "runlen", "passns", "runn", " readl", "Readl", "runns", "runN", "readN", "writene", "passn", "findn"]}}
{"id1": "22401746", "id2": "9267602", "code1": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"sendRequest": ["sendResponse", "processResponse", " sendResponse", "submitrequest", " sendrequest", "processrequest", "processObject", "sendrequest", " sendObject", "sendObject", "submitResponse", "submitRequest", "processRequest", "submitObject"], "servletName": ["servletonVersion", "servletsPath", "servletNames", " servleName", "servletUrl", "servleUrl", "servletsUrl", "servletsName", "servleVersion", " servleVersion", " servleNames", "servletVersion", " servletname", "servleName", "servletonNames", "servLETVersion", "servletonPath", " servlePath", " servletNames", "servletname", "servLETUrl", " servletPath", "servlename", " servletUrl", "servLETName", " servletVersion", " servleUrl", "servletsname", "servletPath", "servLETNames", " servlename", "servleNames", "servLETname", "servletsVersion", "servletonName", "servLETPath", "servlePath", "servletsNames"], "request": ["resource", "application", "string", "xml", "method", "Request", "response", "input", "report", "path", "queue", "json", "content", "object", "address", "header", "frame", "document", "hello", "server", "query", "config", "complete", "python", "q", "result", "data", "type", "req", "message", "info", "uri", "buffer", "text", "name", "create"], "reqxml": ["Requestdoc", "requestdocument", "Requestdocument", " reqdocument", "reqdocument", "Requestxml", "requestdoc", "requestxml", "reqdoc", " reqdoc"], "retdoc": [" resultdata", " retconf", " backdata", " backdoc", " retdata", "retdata", " resultxml", " resultdoc", " resultconf", " backconf", " backxml", "retxml", "retconf", " retxml"], "myurl": [" myaddress", " myURL", "Myaddress", " myUrl", "Myurl", "yourhost", "yourUrl", "myhost", "Myhost", "yourURL", "youraddress", " myhost", "MyURL", "MyUrl", "serveraddress", "yoururl", "myURL", "serverurl", "myUrl", "myaddress", "serverhost"], "myport": ["myPort", "somePort", "someort", "serverphone", "memberPort", "somehost", "Myurl", "serverport", "memberip", "MyPORT", "MYhost", "myhost", "Myport", "Myhost", " myPORT", "memberport", "MYPort", "Myort", "yourPort", "MyPort", "memberurl", " myhost", "somePORT", "myphone", "yourphone", "yoururl", "someip", "someport", "MYPORT", " myPort", "yourip", "serverPort", " myphone", "someurl", " myort", "myip", "myPORT", "MYurl", "serverurl", "yourport", "MYport", "myort"], "codebase": ["forebase", "codeBase", "CodeBase", "forebas", "foreBase", "codeurl", "codebas", " codebas", "codeb", "Codebas", "codBase", "Codeb", "foreurl", "Codeurl", "codb", " codeurl", " codeb", "codbase", " codeBase", "Codebase", "foreb"], "serverURL": ["serverUrl", "hostURI", "siteUrl", "slaveUrl", "serverFolder", " serverUrl", "localhostPage", "sitePage", " serverID", "siteDirectory", "myURL", "databaseURI", "localhostURL", "remoteBUG", "slaveURL", "hosturl", "remoteURL", "testURL", "serverBUG", "serverJSON", "erverBUG", "serverLocation", "erverFolder", " serverBUG", "testURI", "serverAddress", "localhostUrl", "testUrl", "siteURI", "testLocation", "erverPage", "erverurl", "myID", "serverLevel", "hostURL", " serverJSON", "siteurl", "serverURI", "siteAddress", "remoteUrl", "localhostDirectory", "myURI", "slaveFolder", "erverUrl", "erverJSON", "remoteURI", "siteFolder", "hostUrl", "myLevel", "slaveAddress", "serverPage", " serverURI", "testurl", "siteLocation", "erverLevel", "serverDirectory", " serverurl", "databaseURL", "erverDirectory", "databaseUrl", " serverLocation", "myJSON", "serverID", "siteID", "erverAddress", "erverURL", "siteURL", "serverurl", " serverLevel", "remoteurl", "myUrl"], "ipdig": ["ppcr", "IPdb", "IPdone", "ppDig", "ipsDig", "ipplug", "IPdiff", "ipsdb", "ipcomb", " ipcomb", " ipdone", "ipDig", "ipsdig", "IPgen", " ipplug", " ipgen", "IPdig", " ipDig", "IPcr", "idplug", "opdig", "idDig", " ipcr", "ipdb", "ipdiff", "ppdig", "opcomb", "ppplug", " ipdiff", "iddig", "iddone", "ipdone", "IPDig", "ipgen", "ipcr", "IPplug", "opdiff", "IPcomb", "ipsgen", "opDig", " ipdb"], "url": ["resource", "pull", "class", "host", "http", "str", "www", "URL", "path", "log", "ll", "util", "gl", "key", "Url", "object", "conn", "user", " http", "browser", "rel", "cl", "l", "connection", "ls", "event", "server", "twitter", "coll", "config", " curl", "sl", "f", "page", "ssl", "fl", "req", "web", "uri", "update", "client", "org", "name", "file"], "urlconn": ["flcon", "webconn", "sslconn", "urlConn", "httpConn", "urlconf", "httpconf", "llconnection", "flConn", "slcon", "webconv", " urlconnection", "urlclient", " urlcon", " urlConn", "sslConn", "httpcn", "sslconf", "flconn", " urlconv", "llcon", "webclient", "slclient", "urlcon", "llconn", "urlconnection", "flcn", " urlconf", "httpcon", " urlclient", "flconnection", "llConn", "slconv", "httpconnection", "httpconn", " urlcn", "sslcon", "urlcn", "webcon", "urlconv", "slconn"], "os": ["or", "us", "ms", "bs", "so", "op", "o", "is", "oss", "as", "io", "fs", "pos", "vs", "ls", "ops", "ot", "Os", "ns", "ds", "res", "ips", "obj", "ps", "es", "rs", "OS"], "req1xml": ["req2x", "req1request", "req0request", "req1x", "request1x", "req0x", "req2request", "request1xml", "req0txt", "req_xml", "request2request", "req1txt", "request2txt", "request2x", "request1txt", "req0xml", "req2txt", "req_txt", "req_request", "request1request", "req2xml", "request2xml", "req_x"], "cos": [" iss", " compression", " ss", " rc", "is", " repo", " temp", "outs", " enc", " ro", " pos", " downloads", " outs", " bos", " fo", " cs", " ze", "pos", " socks", "cs", " dd", " contents", " bytes", " tar", " po", " zipper", " compress", " cc"]}}
{"id1": "21425787", "id2": "18613870", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "in": ["In", "or", "again", "at", "ini", "c", "IN", "m", "ex", "inner", "bin", "input", "io", "ins", "ac", "min", "inn", "up", "connection", "base", "exec", "url", "work", "index", "i", "image", "a", "login", "reader", "data", "b", "inc", "id", "source", "name", "file"], "out": ["temp", "again", "at", "n", "c", "cache", "o", "ex", "call", "Out", "io", "outs", "dest", "conn", "object", "user", "p", "up", "connection", "w", "base", "part", "prefix", "exec", "server", "x", "off", "to", "writer", "v", "result", "output", "data", "OUT", "point", "b", "target", "inc", "source", "client", "name", "file"], "sourceChannel": [" sourceSocket", "srcChan", "SourceStream", "srcConnection", "ourceChan", "Sourcechannel", "resourceConnection", "ourceSocket", "targetChan", "targetStream", "srcSocket", "resourceChannel", " sourcechannel", "ourcechannel", " sourceConnection", "SourceChan", "resourcechannel", "resourceChan", "ourceConnection", " sourceChan", "sourcechannel", "SourceChannel", "SourceConnection", "sourceSocket", "ourceChannel", "targetchannel", "targetChannel", "sourceStream", "srcChannel", " sourceStream", "sourceChan", "sourceConnection"], "destinationChannel": ["destinatedChan", "DestinatorConnection", "destinatorchannel", "destinatorManager", "destinatorStream", "destinatingManager", "DestinatingChannel", "Destinatorchannel", "destinateChan", "DestinationChannel", "destinatingChannel", "DestinationConnection", "destinationchannel", "destinatorFile", "destructionConnection", "DestinatingChan", "destinatedchannel", "DestinationStream", "destructionChan", "destinationFile", "destructionChannel", "destinatingStream", "destinationStream", "destinateChannel", "destinateConnection", "DestinationChan", "destinationChan", "DestinatorFile", "destinatorChan", "Destinationchannel", "DestinationManager", "destinatorChannel", "DestinatorChannel", "destationchannel", "destinatedConnection", "destationConnection", "DestinatingManager", "DestinatingStream", "destinationManager", "DestinationFile", "destationFile", "destinatedChannel", "destationChannel", "destinatedStream", "destinatorConnection", "destinationConnection", "destinatedFile", "destinatingChan", "DestinatorChan", "destinatedManager"]}}
{"id1": "21821404", "id2": "15822137", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    public TableDirectory(RandomAccessFile raf) throws IOException {\n        version = raf.readInt();\n        numTables = raf.readShort();\n        searchRange = raf.readShort();\n        entrySelector = raf.readShort();\n        rangeShift = raf.readShort();\n        entries = new DirectoryEntry[numTables];\n        for (int i = 0; i < numTables; i++) {\n            entries[i] = new DirectoryEntry(raf);\n        }\n        boolean modified = true;\n        while (modified) {\n            modified = false;\n            for (int i = 0; i < numTables - 1; i++) {\n                if (entries[i].getOffset() > entries[i + 1].getOffset()) {\n                    DirectoryEntry temp = entries[i];\n                    entries[i] = entries[i + 1];\n                    entries[i + 1] = temp;\n                    modified = true;\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getWebPage": ["parsewebpage", "getwebpages", "parsewebPage", "getVirtualPage", "getVirtualpages", "getwebpage", "getWebpage", "parseWebpages", "parsewebpages", "parseWebpage", "getVirtualpage", "parseWebPage", "getwebPage", "getWebpages"], "urlObj": [" urlObject", "URLobj", "resourceObject", "urlExt", "httpobj", "blogobj", "URLObject", "UrlObj", "Urlobj", "urlobj", " urlExt", "URLObj", " urlobj", "strobj", "strObject", "blogObj", "httpOb", "resourceobj", "resourceObj", "URLExt", " urlInst", "blogInst", " urlOb", "strObj", "strInst", "resourceExt", "UrlOb", "urlInst", "urlOb", "httpObj", "urlObject", "blogObject"], "content": ["resource", "online", "section", "clean", "string", "c", "css", "lines", "comment", "response", "core", "java", "continue", "report", "cont", "feed", "empty", "json", "object", "address", "header", "document", "out", "model", "server", "Content", "url", "load", "coll", "work", "array", "code", "value", "page", "result", "html", "output", "data", "write", "raw", "comments", "message", "source", "buffer", "text", "body", "file"], "is": ["il", "or", "isp", "ires", "us", "isa", "ip", "ios", "im", "ois", "isl", "est", "you", "rest", "site", "ir", "irc", "was", "iris", "as", "be", "io", "ais", "abs", "os", "IS", "ui", "cms", "in", "ins", "ri", "does", "ie", "it", "fs", "s", "Is", "out", "iss", "iso", "ar", "ops", "x", "its", "isi", "isc", "i", "any", "mis", "bis", "lis", "ser", "ai", "al", "nis", "r", "ps", "id", "es", "info", "stream", "ris", "ise", "problem"], "reader": ["or", "row", "actor", " Reader", "reading", "oder", "inner", "ler", "io", "ner", "driver", "in", "ri", "er", "handler", "bird", "ro", "l", "rc", "server", "x", "loader", "read", "Reader", "iter", "rer", "e", "director", "i", "worker", "h", "writer", "editor", "ser", "rr", "r", "parser", "rar", "buffer", "stream", "rx"], "line": ["item", "inline", "entry", "row", "pass", "section", "string", "col", "word", "lines", "ine", "LINE", "str", "character", "comment", "Line", " inline", "response", "char", "key", "object", "user", "cr", "cl", "l", "part", "connection", "lin", "cell", "out", "server", "url", "block", "link", "f", "code", "cle", "strip", "page", "data", "lf", "message", "buffer", "source", "text", "body", "column", "name", "file", "lc"]}}
{"id1": "5543349", "id2": "22875895", "code1": "    public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) {\n        String code = \"\";\n        UserFunction function = null;\n        ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\");\n        try {\n            URL url = new URL(codeBase, directoryAndFile);\n            InputStream in = url.openStream();\n            BufferedReader inReader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = inReader.readLine()) != null) {\n                code += line + \"\\n\";\n            }\n            inReader.close();\n        } catch (Exception e) {\n            Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");\n        }\n        ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\");\n        FunctionParser funcParser = new FunctionParser();\n        function = funcParser.parseFunction(code);\n        function.setName(mFileName);\n        ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\");\n        return function;\n    }\n", "code2": "    private void readVersion() {\n        URL url = ClassLoader.getSystemResource(\"version\");\n        if (url == null) {\n            return;\n        }\n        BufferedReader reader = null;\n        String line = null;\n        try {\n            reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((line = reader.readLine()) != null) {\n                if (line.startsWith(\"Version=\")) {\n                    version = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Revision=\")) {\n                    revision = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Date=\")) {\n                    String sSec = (line.split(\"=\"))[1];\n                    Long lSec = Long.valueOf(sSec);\n                    compileDate = new Date(lSec);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"loadMFileViaWeb": ["loadMFilesviaWeb", "loadMFilesViaWeb", "loadMFileViaweb", "loadMFileUsingweb", "loadMFileUsingWeb", "loadMFilesViaweb", "loadMFileviaWeb", "loadMFilesviaweb", "loadMFileviaweb"], "codeBase": ["codebase", "CodeFile", "CodeBase", " codeFile", "knowledgeName", "knowledgeUrl", "addressUrl", "knowledgeBase", "codeFile", "codeName", "CodeLocation", " codebase", "addressBase", "codeUrl", "knowledgeLocation", "codeLocation", "addressbase", "knowledgeFile", "CodeUrl", "CodeName", "addressName", " codeLocation", "knowledgebase", "Codebase"], "directoryAndFile": ["directoryFromfile", "directoryFromFile", "filenameandFiles", "directoryandFilename", "directoryWithfile", "directoryAndfile", "DirectoryOrfile", "DirectoryAndFilename", "directoryAndSourceFile", "DirectoryOrFilename", "DirectoryAndFile", "filenameAndFilename", "directoryandSourceFile", "filenameAndFile", "filenameandFile", "directoryFromSourceFile", "directoryWithFile", "directoryOrFilename", "directoryOrSourceFile", "directoryOrFiles", "directoryOrFile", "filenameandFilename", "DirectoryAndSourceFile", "directoryAndFiles", "DirectoryAndfile", "directoryAndFilename", "DirectoryOrFile", "filenameAndfile", "filenameandfile", "directoryandFile", "directoryFromFilename", "directoryWithFiles", "directoryWithFilename", "directoryandFiles", "directoryOrfile", "DirectoryOrSourceFile", "directoryandfile", "filenameAndFiles"], "mFileName": ["mFilenameHandle", "mFileYear", "pFileName", "mClassPath", "pFunctionInfo", "cmFilesname", "pFunctionName", "mLibraryYear", "mClassFile", "mClassName", "mStringKey", "MSourceFilePath", "pFilePath", "mFunctionInfo", "mFilenameFile", "mClassKey", "mBasePath", "MSourceFileName", "MSourceFileYear", "mSourceFileYear", "mLibraryName", "mFilesname", "MFileName", "mClassInfo", "mFilesInfo", "mBaseData", "mClassType", "mBaseFile", "MFileFile", "mClassData", "pFileInfo", "mFunctionPath", "mFilesPath", "MClassData", "mFilesType", "cmFilesName", "MClassPath", "mFunctionType", "cmFilesPath", "mFilenamePath", "mClassname", "cmFileKey", "mFileFile", "mStringPath", "mStringname", "MSourceFileHandle", "mFilesKey", "mFilePath", "mSourceFileHandle", "mFileHandle", "mStringName", "mFilesName", "mFilename", "mFilenameYear", "mFilenameName", "mFilenameData", "cmFilePath", "mLibraryHandle", "MFilePath", "MFileYear", "cmFilename", "mFunctionName", "mFileData", "MClassName", "pFileType", "mFileKey", "cmFilesKey", "pFunctionPath", "cmFileName", "mBaseName", "mSourceFileName", "pFunctionType", "mLibraryPath", "MFileData", "mFileType", "MClassFile", "mFileInfo", "mSourceFilePath", "MFileHandle"], "code": ["done", "status", "use", "call", "ce", "address", "count", "xxx", "check", "error", "text", "body", "file", "escape", "c", "expression", "comment", "cod", " Code", "length", "header", "x", "now", "page", "data", "module", "message", "class", "fore", "codes", "n", "go", "Code", "co", "content", "frame", "coded", "f", "callback", "type", "id", "loop", "name", "cause", "zip", "string", "method", "script", "func", "java", "key", "number", "age", "exec", "result", "test", "closure", "info", "buffer", "create"], "function": [" object", "action", "role", "lambda", "class", "section", "library", " functionality", "string", "instance", "word", "call", "expression", "service", "fun", "func", "operation", "number", "object", "handler", "fn", "unit", "ctor", "rule", "document", "connection", "element", "event", " module", "variable", "component", " library", "array", "f", "python", "value", "feature", "callback", "lib", "fp", "result", "Function", "output", "error", "module", "functional", "job", "form", "file"], "url": ["resource", "string", "channel", "blog", "http", "URL", "log", "path", "ur", "feed", "key", "Url", "download", "user", "address", "bel", "er", "browser", "l", "connection", "base", "server", "plug", "loader", "sl", "f", "i", "image", "socket", "page", "ssl", "reader", "data", "ball", "r", "b", "jar", "web", "uri", "stream", "source", "update", "file"], "in": ["In", "fr", "serv", "ini", "c", "IN", "is", "din", "inner", "bin", "input", "as", "io", "ins", "ac", "inn", "er", "err", "out", "ar", "gin", "loader", "read", "f", "Reader", "af", "i", "a", "image", "socket", "arin", "ssl", "login", "reader", "data", "r", "b", "inc", "buffer", "stream", "client", "file"], "inReader": ["INReader", "InRead", "outWriter", "InParser", "INFile", "inRead", " inRead", "inParser", "InReader", "outReader", "INRead", " inStream", "incReader", "incParser", "inStream", "outStream", "outParser", "INWriter", "InFile", "inFile", "InWriter", " inFile", "inWriter", " inWriter", "incRead", "InStream", "incWriter", " inParser"], "line": ["inline", "entry", "row", "pass", "string", "c", "include", "col", "word", "LINE", "lines", "str", "comment", "character", "Line", "key", "number", "char", "column", "content", "letter", "cr", "frame", "l", "liner", "part", "cl", "connection", "lin", "pe", "cell", "model", "sl", "link", "e", "lined", "i", "record", "page", "error", "data", "type", "write", "r", "id", "message", "lf", "source", "text", "re", "name", "file", "lc"], "end": ["ended", "append", "open", "add", "begin", "init", "pos", "all", "ending", "load", "complete", "e", "set", "stop", "start", "END", "en", "End", "id", "info", "block", "name", "create"]}}
{"id1": "11082670", "id2": "6558022", "code1": "    @SuppressWarnings(\"unchecked\")\n    public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException {\n        StringBuilder json = new StringBuilder();\n        String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n        try {\n            URL url = new URL(requestUrl.toString());\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                json.append(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            throw new GtugsException(e);\n        }\n        List<Event> events = new ArrayList<Event>();\n        JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString());\n        JSONArray results = (JSONArray) jsonObj.get(\"results\");\n        for (int i = 0; i < results.size(); i++) {\n            JSONObject result = (JSONObject) results.get(i);\n            Event e = new Event();\n            e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\")));\n            e.setCity((String) result.get(\"venue_city\"));\n            e.setDescription((String) result.get(\"description\"));\n            e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\")));\n            e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\")));\n            e.setName((String) result.get(\"name\"));\n            Date myDate = null;\n            String time = (String) result.get(\"time\");\n            try {\n                myDate = meetupDateFormat.parse(time);\n                e.setStartTime(timeDateFormat.format(myDate));\n                e.setEndTime(timeDateFormat.format(myDate));\n                e.setStartDate(myDate);\n                e.setEndDate(myDate);\n                String tz = tzDateFormat.format(myDate);\n                if (tz != null && tz.startsWith(\"+\")) {\n                    tz = tz.substring(1);\n                }\n                e.setTimeZone(Integer.toString(Integer.parseInt(tz) / 100));\n            } catch (ParseException ex) {\n                ex.printStackTrace();\n                continue;\n            }\n            e.setState((String) result.get(\"venue_state\"));\n            StringBuilder addressBuilder = new StringBuilder();\n            if (result.get(\"venue_address1\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address1\") + \" \");\n            }\n            if (result.get(\"venue_address2\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address2\") + \" \");\n            }\n            if (result.get(\"venue_address3\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address3\") + \" \");\n            }\n            if (result.get(\"venue_address4\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address4\"));\n            }\n            e.setStreetAddress(addressBuilder.toString().trim());\n            e.setZipCode((String) result.get(\"venue_zip\"));\n            e.setUrl((String) result.get(\"event_url\"));\n            events.add(e);\n        }\n        return events;\n    }\n", "code2": "    public static String CheckUrl(String urlvalue) {\n        String inputLine = \"\";\n        try {\n            URL url = new URL(urlvalue);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            inputLine = in.readLine().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return inputLine;\n    }\n", "label": 1, "substitutes": {"lookupFutureEvents": ["lookUpupItems", "lookupFutureEvent", "lookupFutureItems", "lookUpFutureEvents", "lookupRequestEvents", "lookupAllEvent", "lookupupEvent", "lookupupItems", "lookupRequestItems", "lookUpupEvents", "lookupRequestEvent", "lookUpFutureItems", "lookUpFutureEvent", "lookUpupEvent", "lookupAllEvents", "lookupAllItems", "lookupupEvents"], "groupIdentifier": ["groupSequifer", " groupIdentizer", "groupIdizer", "groupSequifier", "groupIdifer", "groupidentifiers", "groupidentifier", "groupidentizer", "groupSequification", "groupIdentifer", " groupIdentification", " groupIdentifiers", "groupSequifiers", "groupIdentification", "groupidentification", " groupIdentifer", "groupIdentifiers", "groupIdentizer", "groupIdifier", "groupidentifer", "groupIdifiers"], "json": ["struct", "rss", "txt", "status", "js", "token", "JSON", " JSON", "description", "zip", "string", "jack", "request", "photo", "http", "xml", "response", "input", "api", "io", "key", "list", "son", "sql", "build", "j", "server", "query", "twitter", "array", "value", "journal", "html", "ssl", "output", "data", "obj", "id", "message", "info", "text", "body"], "requestUrl": ["responseUrl", "responseName", " requestName", "requestAddress", "downloadUrl", "requestURL", "responseStr", " requestAddress", "downloadURL", " requestURL", "RequestURL", "downloadAddress", " requestUr", "responseURL", "requestName", "RequestUrl", "requestUr", "downloadUr", "RequestName", " requestStr", "RequestAddress", "RequestUr", "RequestStr", "requestStr"], "url": ["resource", "string", "channel", "http", "service", "input", "URL", "path", "api", "open", "io", "gl", "Url", "client", "rl", "user", "address", "l", "connection", "rule", "base", "event", "server", "sl", "f", "hub", "image", "socket", "ssl", "data", "web", "uri", "stream", "buffer", "source", "org", "file"], "in": ["In", "line", "again", "serv", "ini", "c", "IN", "is", "din", "inner", "bin", "input", "io", "ins", "impl", "min", "inn", "er", "into", "err", "l", "init", "s", "lin", "out", "gin", "read", "f", "image", "login", "ssl", "reader", "data", "r", "b", "inc", "id", "buffer", "stream", "source", "re", "fr"], "inputLine": ["InputLine", "controlLine", "audioLine", "eventText", " inputline", "inputText", "eventStream", " inputL", " inputStream", "inputStream", "outputline", "requestLine", "inputUrl", "inputL", " inputUrl", "eventline", "outputStream", "inputBlock", "eventLine", "controlStream", "audioUrl", "inputline", "requestBlock", "outputBlock", "outputText", "audioL", " inputText", "controlL", "InputUrl", "InputL", "requestStream", "requestL", "outputLine", "controlBlock", "outputL"], "events": ["reports", "pages", "views", "times", "lines", "errors", "ents", "files", "groups", "members", "plugins", "forms", "tests", "effects", "actions", "Events", "services", "dates", "fires", "features", "archives", "items", "comments", "es", "lists", "issues", "rows"], "jsonObj": ["JSONObject", "JSONExt", "sonObj", "xmlObject", "jsonobj", "xmlAct", "jsonExt", "jsonArray", "responseAct", "responseObject", "responseobj", "jsonObject", "JSONObj", "JSONAct", "JSONobj", "sonArray", "responseObj", "jsonAct", "xmlObj", "xmlExt", "xmlobj", "xmlArray", "sonobj", "JSONArray", "sonExt"], "results": ["reports", "pages", "words", "ings", "Result", "stats", "times", " Results", "resources", "values", "errors", "roads", "terms", "response", "objects", "details", "shows", "Results", "groups", "changes", "RESULTS", "successful", "tests", "ventures", "qs", "Events", "its", "dates", "vers", "ries", "ions", "res", "features", "vals", "output", "rules", "data", "items", "r", "es", "products", "runs", "rows"], "i": ["iu", "hi", "si", "chi", "qi", "ip", "u", "multi", "n", "ii", "c", "ini", "pi", "inner", "ci", "di", "io", "slice", "vi", "ui", "ji", "ri", "bi", "ie", "p", "phi", "j", "I", "fi", "x", "eni", "index", "f", "oi", "li", "ori", "h", "v", "gi", "ti", "ai", "yi", "b", "xi", "id", "info", "uri", "ix", "mu", "uni"], "result": ["resource", "entry", "row", "role", "plus", "status", "section", "function", "Result", "particip", "rh", "request", "venture", "view", "comment", "response", "report", "manager", "search", "ner", "match", "details", "sr", "user", "err", "goal", "profile", "successful", "rule", "default", "part", "order", "element", "event", "query", "game", "complete", "date", "session", "success", "feature", "record", "res", "page", "output", "error", "data", "product", "term", "found", "r", "style", "job", "message", "info", "back", "ver"], "e": ["eu", "fe", "g", "m", "none", "enter", "ce", "p", "l", "s", "E", "ne", "v", "error", "de", "t", "ec", "es", "or", "entry", "c", "oe", "o", "y", "d", "die", "ea", "pe", "element", "exc", "ga", "office", "ep", "ae", "eve", "esi", "en", "one", "end", "je", "entity", "n", "see", "te", "ee", "ed", "er", "ie", "ception", "j", "complete", "f", "ele", "ze", "ev", "r", "line", "u", "le", "ge", "be", "eb", "err", "it", "ente", "event", "ffe", "ite", "ye", "el", "se", "b", "me"], "myDate": ["homeDate", "myYear", "MYDat", "MYDay", "homedate", " myTime", "MYTime", "myDat", "anyDate", "myTime", "anyTime", "yourDate", "yourTime", "myDay", "homeTime", "MyDate", "yourDat", "anyDat", "MYDate", "homeDat", "MyDay", " myDat", "MyDat", "MyTime", " myYear", "yourdate", " myDay", "yourDay", "mydate", "yourYear", "anyYear", "anydate"], "time": ["timeout", "live", "etime", "times", "string", "host", "hour", "depth", "money", "week", "year", "length", "Time", "loc", "rate", "location", "work", "clock", "size", "price", "date", "TIME", "code", "am", "value", "home", "rice", "image", "start", "tim", "ime", "data", "type", "duration", "id", "message", "timer", "text", "name"], "tz": [" offset", " zones", " loc", "etime", "Clock", "hour", "UTC", "hh", "z", " hour", "zone", " zone", "Offset", " clock", " schedule", "loc", " timestamp", "Zone", "clock", " interval", " GMT", "Timeout", "Delta", " locale", "GMT", "zz", "offset", "Z", "tc"]}}
{"id1": "14001795", "id2": "804637", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyOverWarFile": ["copyOverWebFile", "copyOverWarfile", "copyOverWARPath", "copyoverwarPath", "copyOverwarPath", "copyOverwarFiles", "copyOverWARFiles", "copyOverwarFile", "copyoverWarFiles", "copyOverWebPath", "copyoverWarFile", "copyoverwarfile", "copyOverwarfile", "copyoverWarPath", "copyOverWARFile", "copyOverWARfile", "copyOverWebfile", "copyoverwarFile", "copyoverWarfile", "copyOverWebFiles", "copyOverWarPath", "copyoverwarFiles", "copyOverWarFiles"], "dir": ["folder", "df", "dc", "group", "local", "class", "window", "keep", "zip", "clean", "cache", "ir", "http", "dist", "d", "log", "fd", "manager", "dn", "desc", "feed", "di", "doc", "wd", "download", "DIR", "handler", "def", "build", "store", "loc", "up", "part", "coll", "url", "cur", "work", "dr", "config", "pkg", "director", "direct", "Dir", " directory", "lib", "draft", "handle", "directory", "direction", "data", "md", "r", "plugin", "parent", "lock", "db", "file"], "ff": ["df", "fe", "fff", "sf", "cpp", "xff", " buff", "aff", "fx", "ft", "uff", "fd", "bd", "FF", "feed", "buf", "cf", "fam", "fold", "pp", "ef", "dd", "TF", "cl", "ph", "fw", "iff", "ffe", "now", "fox", "eph", "uf", "fed", "eff", "upp", "cb", "fp", "bb", "fl", "fb", "bf", "ffff", "lf", "buff", "rf", "flow"], "files": ["fa", "pages", "names", "fe", "classes", "bs", "lines", "apps", "results", "images", "sections", "objects", "events", "ums", "groups", "plugins", "locks", "fs", "s", "ls", "balls", "keys", "blocks", "split", "features", "flows", "data", "fl", "items", "Files", "ps", "iles", "rows", "users", "jobs", "file", "models"], "f": ["fa", "fe", "fr", "F", "fc", "of", "n", "c", "sf", "d", "aff", "fd", " fa", "feed", "cf", "fold", "fn", "handler", "p", "fs", "l", "tf", "part", "x", "flat", "e", " file", "i", "filename", "fp", "fen", "v", "inf", "fl", "fb", "bf", "t", "lf", "info", "name", "file", "rf"], "newFile": ["updatefile", "oldDir", "NewFolder", " newFolder", "smallfile", "oldFiles", "smallDir", " newLine", "updateF", "NewFile", "oldF", "newFiles", "andfile", "andFile", " newF", " newDir", "updateLine", " newfile", "NewFiles", "nextFile", "andDir", "newLine", "existingLine", "NewF", "existingF", "nextFiles", "newFolder", "updateFile", "nextFolder", "newfile", "nextDir", "existingfile", "oldFile", "existingFile", "NewDir", "smallFile", " newFiles", "newDir", "newF"], "fi": ["fa", "fy", "fe", "wi", "si", "qi", "fc", "uci", "ini", "ii", "pi", "py", "sf", "afe", "fin", "abi", "ifi", "cci", "flo", "cf", "ifa", "afi", "shi", "bi", "ife", "fs", "ico", "fine", "fw", "ffe", "sci", "isi", "i", "fp", "Fi", "FI", "zi", "xi", "fb", "lf", "info", "fr"], "fo": ["fa", "fe", "si", "so", "wo", "o", "sf", "ko", "afe", "obo", "ofi", "ato", "di", "obi", "io", "os", "co", "flo", "cf", "osa", "tto", "afi", "shi", "ico", "fw", "ki", "ho", "FO", "zo", "uf", "xf", "ni", "bo", "inf", "lo", "po", "oo", "info", "olo", "mo"]}}
{"id1": "8983517", "id2": "10176678", "code1": "    public User getUser(String userlogin) {\n        UserDAO userDAO = new UserDAO();\n        User user = null;\n        try {\n            user = userDAO.load(userlogin);\n            if (user == null) {\n                URL url = Thread.currentThread().getContextClassLoader().getResource(\"users.cfg\");\n                BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                String linea = br.readLine();\n                while (linea != null) {\n                    StringTokenizer st = new StringTokenizer(linea, \":\");\n                    if (st.countTokens() == 3) {\n                        String login = st.nextToken();\n                        String password = st.nextToken();\n                        String profile = st.nextToken();\n                        if (login.equals(userlogin)) {\n                            user = new User(login, password, profile);\n                            userDAO.save(user);\n                        }\n                    } else {\n                    }\n                    linea = br.readLine();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return user;\n    }\n", "code2": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "label": 0, "substitutes": {"getUser": ["newuser", "getUsers", "readUsers", "newCustomer", "readUser", "getuser", "newUser", "createUsers", "createCustomer", "createuser", "newUsers", "readuser", "createUser", "readCustomer", "getCustomer"], "userlogin": [" useruser", "username", "customauth", "bugLogin", " userline", "courseuser", " userauth", "buglogin", " userLogin", "uselogin", " userpassword", "custompassword", "coursepassword", "pluginname", "bugline", "courselogin", "verusername", "useLogin", "useruser", "pluginpassword", "bugusername", "userLogin", "userauth", "pluginusername", " userusername", "userline", "useusername", "userusername", "userpassword", "customlogin", "pluginlogin", "verlogin", "vername", "verpassword", " username", "courseauth", "customuser", "useline"], "userDAO": [" userRAOB", "UserMAOO", "userDSB", "userAB", "usernameDAB", "usernameDSOB", "UserDAOs", "userDAOO", "userDSo", " userDAB", "usernameDSo", " userRAB", "usernameDAo", "UserDAOB", "userTAOO", "userDSOB", "UserMAO", "UserMAOB", "userDAo", "UserDAO", "userAo", " userRAO", "userAO", "userRAOB", "userDAB", "userTAO", "userMAOB", "userTAB", "userAOB", "userMAB", "userDKO", "userDSOO", " userDAOO", "usernameDSO", " userDAOB", "userDKB", "userRAO", "userMAOO", "UserMAOs", "userDAOB", "userDAOs", "userDKOB", "UserDAOO", "userRAOO", "usernameDAOB", "userTAOB", "userDSO", "usernameDAO", "userRAB", "userDSOs", "userDKo", "userMAOs", "usernameDSB", " userRAOO", "userMAO"], "user": ["resource", "use", "who", "full", "blog", "current", "state", "manager", "log", "match", "auth", "rule", "html", "v", "po", "parent", "ver", "db", "item", "or", "username", "usa", "cache", "str", "comment", "facebook", "io", "USER", "bug", "dict", "model", "per", "other", "record", "page", "member", "data", "oo", "one", "class", "ee", "creator", "er", "default", "sp", "usr", "home", "uc", "author", "ou", "type", "account", "lock", "name", "person", "group", "u", "um", "service", "response", "key", "object", "up", "config", "session", "e", "User", "result", "claim", "plugin", "job", "users", "info", "me"], "url": ["resource", "fr", "string", "blog", "href", "host", "channel", "http", "str", "URL", "path", "ur", "io", "feed", "gl", "org", "Url", "address", "bel", "orb", "lr", "rel", "browser", "l", "connection", "base", "server", "plug", "coll", "loader", "sl", "ssl", "fl", "r", "b", "account", "uri", "stream", "source", "src", "file"], "br": ["Br", "ch", "bh", "HR", "brush", "str", "bm", "ler", "ber", "ner", "bd", "yr", "buf", "rt", "sr", "bro", "BR", "tr", "mr", "lr", "browser", "bl", "cr", "err", "arr", "sp", "dr", "bc", "sl", "bar", "vr", "cb", "result", "bb", "reader", "img", "hr", "rr", "r", "b", "bf", "fb", "jar", "bed", "buffer", "stream", "bt", "body", "src", "rb", "db", "fr", "ref"], "linea": ["linesa", "linas", "linp", " linean", "linkva", "framea", " lineaf", "frameA", " linep", "lina", "linaf", "linan", "LINEp", "linsa", "linka", "lineA", "seea", " lineas", "linva", "linep", "LINEsa", "frameas", " lineva", "sean", " lineaa", " linesa", "lineaf", "seas", "lineas", "linean", "lineva", "sea", "frameaa", " lineea", "lineea", "linkaf", "linaa", "LINEa", "LINEas", "linA", "lineaa", " lineA", "linkA"], "st": ["fe", "lt", "sth", "stri", "sh", "est", "string", "rest", "sm", "ost", "sf", "str", "d", "ist", "ft", "ST", "be", "sc", "pt", "sa", "rt", "first", "ct", "STR", "ste", "bl", "ld", "cl", "l", "trans", "s", "sn", "sp", "ast", "sl", "sta", "nd", "sb", "td", "set", "start", "St", "std", "sts", "se", "ser", "sv", "b", "stack", "t", "rd", "mt", "fr"], "login": ["resource", "pass", "status", "token", "username", "line", "blog", "string", "site", "register", "join", "photo", "secret", "title", "service", "facebook", "log", "phone", "display", "pin", "Login", "auth", "email", "summary", "connection", "layout", "security", "gin", "config", "license", "company", "home", "filename", "stat", "joined", "mobile", "picture", "plugin", "account", "id", "inc", "lock", "alias", "name"], "password": ["resource", "pass", "token", "username", "fax", "sword", "string", "access", "sudo", "secret", "service", "sha", "money", "Password", "PASS", "screen", "phone", "auth", "database", "email", "wd", "pad", "phrase", "security", "config", "session", "picture", "style", "account", "pattern", "alias", "mask", "name", "padding"], "profile": ["property", "role", "pass", "class", "username", "photo", "option", "secret", "title", "money", "family", "platform", "phone", "key", "summary", "email", "theme", "settings", "pocket", "name", "company", "filename", "mobile", "Profile", "type", "picture", "style", "module", "prof", "account", "alias", "site", "file", "person"]}}
{"id1": "647224", "id2": "6501291", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"uploadFile": [" uploadfile", " uploadDir", "UploadFiles", "processFiles", "uploadDir", "UploadDir", "uploadFiles", "processDir", "UploadFile", "Uploadfile", " uploadFiles", "processfile", "processFile", "uploadfile"], "inputFile": [" inputFolder", "targetFolder", "InputType", " inputDir", "Inputfile", " inputPage", "sourcefile", " inputfile", " inputStream", "targetLog", "inputStream", "sourcePage", "initialFolder", "inputFiles", "InputFolder", "sourceLog", " inputType", " inputFiles", "inputFolder", " inputFilename", "initialFile", "targetFiles", "targetFilename", "initialFilename", "sourceFolder", "InputFile", "inputFilename", "sourceFile", " inputLog", "InputFiles", "inputLog", "targetPage", "inputDir", "inputfile", "sourceType", "inputPage", "initialStream", "inputType", "sourceStream", "InputStream", "targetfile", "targetDir", "targetStream", "InputDir"], "targetFile": ["externalName", " targetPath", " targetfile", " targetPlace", "TargetDir", "Targetfile", "targetPath", "sourcePlace", " targetLine", "outputPath", "externalFile", " targetFiles", "TargetLine", "targetFiles", "externalPath", "TargetFile", "targetPlace", " targetDir", "sourceFile", "targetName", "TargetPath", "inputPath", "sourcePath", "TargetName", "inputDir", "outputDir", " targetName", "sourceDir", "targetLine", "externalfile", "outputFiles", "TargetFiles", "inputPlace", "outputName", "outputLine", "targetfile", "targetDir"], "outputFile": ["outfile", "outFolder", " outputfile", "writePage", "outDirectory", "outputPlace", "outPlace", " outputPage", "inputDirectory", "targetPath", "inputStream", "OutputFile", " outputFolder", "inputUrl", " targetQueue", "Outputfile", "outputPage", "inputFiles", "writeFile", "currentfile", "OutputFolder", "targetQueue", " outputUrl", "currentFile", " outputFiles", "outputPath", "OutputDir", "outputFolder", " targetFiles", " outputDirectory", "outputStream", "inputFolder", " targetDirectory", " outputPlace", "targetFiles", "outPath", "outputDirectory", "inputPath", "writeUrl", " outputPath", " outputDir", "outputDir", "inputDir", "inputfile", " outputStream", "inputPage", "outputQueue", "outFile", "writeStream", "outputfile", "currentPlace", "currentFolder", "outputFiles", "outputUrl", "inputQueue", "targetfile", "targetDirectory"], "in": ["In", "pull", "pass", "issue", "again", "serv", "ini", "IN", "rec", "cin", "is", "din", "inner", "bin", "input", "con", "io", "pin", "ins", "ac", "inn", "err", "kin", "up", "isin", "init", "win", "s", "lin", "rin", "url", "read", "inside", "i", "nin", "login", "reader", "diff", "data", "r", "inc", "id", "sub", "source", "stream"], "out": ["ger", "again", "println", "n", "cache", "o", "table", "inter", "ex", "inner", "bin", "state", "Out", "copy", "report", "log", "outer", "io", "outs", "co", "this", "sys", "sync", "user", "conn", "err", "print", "up", "net", "s", "base", "cmd", "exec", "dump", "off", "by", "image", "writer", "to", "plain", "page", "ext", "output", "error", "data", "write", "OUT", "r", "point", "inc", "lock", "source", "client", "console", "one", "file"], "line": ["inline", "entry", "row", "pass", "string", "lines", "word", "LINE", "ine", "limit", "comment", "le", "Line", "log", "char", "sync", "header", "unit", "frame", "rule", "part", "base", "lin", "cell", "pe", "url", "link", "e", "code", "split", "page", "range", "error", "data", "type", "write", "lf", "job", "buffer", "lock", "block", "name", "file", "lc"], "bytes": ["pages", "reads", "Bytes", "classes", "words", "codes", "bs", "zip", "bps", " lines", "lines", "ones", "values", "eps", "bits", "outs", "os", "number", "files", "length", "groups", "seconds", "tes", "steps", "count", "s", "pos", "cycles", "ls", "size", "ines", "code", "len", "i", "blocks", " cycles", "units", "ips", "items", "comments", "es", "binary", "les", "odes", "rows"]}}
{"id1": "21013026", "id2": "21608109", "code1": "    private InputStream getPageStream(String query) throws MalformedURLException, IOException {\n        URL url = new URL(baseUrl + query + \"&rhtml=no\");\n        URLConnection connection = url.openConnection();\n        connection.connect();\n        InputStream in = connection.getInputStream();\n        BufferedInputStream bis = new BufferedInputStream(in);\n        return bis;\n    }\n", "code2": "    public static boolean loadContentFromURL(String fromURL, String toFile) {\n        try {\n            URL url = new URL(\"http://bible-desktop.com/xml\" + fromURL);\n            File file = new File(toFile);\n            URLConnection ucon = url.openConnection();\n            InputStream is = ucon.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            ByteArrayBuffer baf = new ByteArrayBuffer(50);\n            int current = 0;\n            while ((current = bis.read()) != -1) {\n                baf.append((byte) current);\n            }\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(baf.toByteArray());\n            fos.close();\n        } catch (IOException e) {\n            Log.e(TAG, e);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"getPageStream": ["downloadpageForm", "getRequestChannel", "getPageSteam", "downloadPageChannel", "getOutputSteam", "getOutputForm", "downloadpageChannel", "getOutputChannel", "getPageForm", "getRequestForm", "downloadpageStream", "downloadPageStream", "getpageStream", "getRequestSteam", "getPageChannel", "getpageChannel", "downloadPageSteam", "getOutputStream", "getRequestStream", "downloadpageSteam", "getpageSteam", "downloadPageForm", "getpageForm"], "query": ["resource", "timeout", "qi", "string", "request", "Query", "http", "str", "script", "comment", "options", "path", "params", "qu", "search", "qq", "iq", "ri", "content", "build", "qs", "tag", "prefix", "i", "q", "password", "start", "format", "result", "filter", "data", "type", "question", "term", "id", "uri", "source", "text", "body", "name", "sq"], "IOException": [" IOError", " IOceptions", "SocketError", "IOError", "ConnectionException", "Connectionceptions", "Socketceptions", "ConnectionError", "SocketException", "IOceptions"], "url": ["resource", "use", "position", "string", "c", "channel", "http", "proxy", "URL", "api", "open", "Url", "conn", "object", "user", "address", "bug", "l", "base", "ls", "server", "config", "sl", "f", "link", "article", "e", "i", "image", "page", "ssl", "bb", "plugin", "b", "id", "web", "uri", "client", "db", "file"], "connection": ["application", "section", "function", "position", "c", "Connection", "channel", "context", "union", "http", "proxy", "character", "condition", "response", "ion", "ci", "con", "io", "open", "ctx", "database", "relation", "client", "conn", "handler", "loc", "l", "out", "cond", "communication", "coll", "server", "bc", "f", "director", "wrapper", "socket", "reader", "b", "connected", "uri", "connect", "db", "lc"], "in": ["In", "inas", "ini", "c", "IN", "din", "inner", "bin", "input", "con", "io", "ins", "conn", "inn", "kin", "isin", "s", "rin", "lin", "out", "init", "gin", "f", "i", "nin", "a", "image", "socket", "sin", "login", "reader", "data", "inc", "source", "uri", "body"], "bis": ["inas", "us", "ses", "ios", "bs", "bps", "board", "cus", "is", "bin", "inos", "uds", "oss", "iris", "abi", "series", "ubis", "di", "abs", "ais", "bits", "inet", "bles", "obb", "boot", "bos", "bi", " bos", "isin", "pins", "iss", "BBC", "idis", "sb", "oi", " cis", "lis", "nis", "lins", "binary", "ris"]}}
{"id1": "21491791", "id2": "536614", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"run": ["Run", "execute", "call", "invoke", "func", "log", "process", "unit", "build", "command", "app", "running", "all", "exec", "fork", "work", "code", "worker", "start", "apply", "runner", "test", "spawn", "job", "loop", "create"], "input": ["resource", "entry", "readable", "instance", "initial", "context", "request", "reading", "view", "inner", "state", "io", "feed", "text", "driver", "in", "active", "client", "user", "conn", "address", "iterator", "audio", "up", "connection", "out", "storage", "work", "config", "loader", "read", "index", "control", "Input", "worker", "internal", "image", "data", "raw", "parser", "stream", "source", "form", "file", "flow"], "output": ["resource", "temp", "application", "exit", "writers", "cache", "environment", "response", "log", "path", "outer", "Writer", "queue", "operation", "network", "user", "letter", "object", "unit", "connection", "document", "out", "config", "office", "index", "control", "filename", "image", "page", "data", "write", "written", "writing", "put", "target", "job", "web", "parent", "source", "generated", "text", "console", "later", "file", "Output", "end"], "reader": ["resource", "entry", "riter", "row", "slave", "owner", "context", "reading", "request", "oder", "view", "inner", "manager", "io", "ner", "driver", "in", "ri", "handler", "er", "book", "audio", "server", "system", "loader", "read", "Reader", "rer", "wrapper", "worker", "peer", "image", "author", "r", "parser", "rator", "stream", "client", "source", "builder"], "writer": ["or", "riter", "entry", "writ", "war", "nw", "writers", "player", "ter", "word", "request", "wer", "inner", "outer", "manager", "Writer", "ner", "engine", "wa", "driver", "ew", "creator", "maker", "er", "wire", "w", "connection", "out", "wan", "work", "ws", "office", "rw", "wrapper", "worker", "her", "editor", "wr", "author", "writing", "write", "written", "data", "r", "wb", "builder"], "pump": ["cumping", "mumps", "ppumps", "pprint", "cumper", "prump", "pumps", " pumps", "prumper", " pumping", "pram", "Pdump", "Pam", "humps", "cump", "dmp", "hump", "pumper", "Pump", "pmp", "mumper", "dumper", "pumping", "ppump", "pdump", "prdump", "mump", " pamp", "humper", "pamp", "dumps", " pam", "Pamp", "ppumping", "dump", " pmp", "mprint", "pam", "ppumper", " pumper", "Pprint", "hprint", "Pumper", "camp", "Pumping", "Pumps", " pdump", "Pmp"], "counter": ["entry", "row", "ver", "ger", "seed", "instance", "ter", "current", "step", "zero", "inter", "pointer", "version", "currency", "comment", "inner", "continue", "walker", "trace", "layer", "outer", "ner", "sequence", "number", "enter", "num", "second", "repeat", "keeper", "Counter", "progress", "const", "count", "er", "cookie", "ener", "lr", "starter", "ception", "order", "hello", "collection", "consumer", "server", "url", "rew", "builder", "clock", "loader", "now", "index", "processor", "code", "worker", "center", "page", "result", "author", "runner", "meter", "r", "timer", "loop", "master", "race", "parent", "offset", "keep"], "buffer": ["resource", "entry", "position", "channel", "uffer", "limit", "layer", "buf", "queue", "length", "address", "header", "batch", "document", "base", "port", "server", "url", "loader", "Buffer", "iter", "uf", "page", "data", "buff", "message", "source", "text", "binary", "file", "reference"], "off": ["of", "low", "opt", "o", "unknown", "oa", "area", "inner", "down", "open", "ui", "on", "Offset", "flow", "ff", "less", "offer", "pos", "eno", "out", "fail", "addr", "left", "now", "ord", "head", "set", "offs", "start", "auto", "own", "OFF", "Off", "offset", "info", "art", "ref", "end"], "len": ["lt", "line", "n", "limit", "fin", "bin", "ler", "den", "log", "Len", "layer", "ll", "fd", "in", "length", "on", "lit", "count", "loc", "ld", "l", "pos", "lin", "all", "url", "size", "li", "lim", "el", "lan", "lib", "val", "gen", "lc", "elt", "fl", "en", "lf", "lon", "lock", "body", "ln", "name", "width", "ref", "end"], "rd": ["rss", "rm", "ru", "rh", "rid", "raid", "d", "rand", "dra", "fd", "rt", "rl", "rf", "RD", "nr", "ra", "lr", "dd", "cr", " r", "ld", "db", "rc", "rob", "ud", "RR", "dr", "red", "nd", "ord", "rw", "ds", "ind", "val", "rn", "rod", "adr", "hr", "rr", "r", "rs", "rx", "rb", " prod", "fr", "xd"]}}
{"id1": "12883117", "id2": "16621503", "code1": "    public PhoneSetImpl(URL url) throws IOException {\n        BufferedReader reader;\n        String line;\n        phonesetMap = new HashMap();\n        reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        line = reader.readLine();\n        lineCount++;\n        while (line != null) {\n            if (!line.startsWith(\"***\")) {\n                parseAndAdd(line);\n            }\n            line = reader.readLine();\n        }\n        reader.close();\n    }\n", "code2": "    public static ArrayList<String> loadURLToStrings(URL url, int maxLines, String userAgent, int timeout) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (userAgent != null && userAgent.trim().length() > 0) {\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n        } else {\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (compatible; astrominer/1.0;)\");\n        }\n        if (timeout > 0) {\n            connection.setConnectTimeout(timeout);\n        }\n        connection.connect();\n        return loadURLToStrings(connection, maxLines);\n    }\n", "label": 0, "substitutes": {"url": ["resource", "http", "str", "service", "URL", "path", "ur", "io", "feed", "gl", "this", "Url", "object", "address", "lr", "l", "connection", "base", "server", "location", "config", "loader", "sl", "f", " URL", "image", "page", "ssl", "data", "r", "b", "uri", "stream", "buffer", "source", "org", "name", "file"], "reader": ["resource", "or", "row", "entry", "ger", "player", "reading", "oder", "inner", "ler", "input", "layer", "io", "ner", "feed", "slice", "this", "driver", "in", "keeper", "er", "handler", "connection", "element", "server", "dr", "loader", "read", "Reader", "iter", "per", "rer", "i", "worker", "editor", "writer", "socket", "result", "author", "data", "rr", "r", "parser", "loop", "buffer", "stream", "rx", "source", "builder", "file"], "line": ["item", "inline", "body", "entry", "row", "look", "day", "zip", "string", "lines", "word", "LINE", "str", "comment", "le", "Line", "layer", "log", "feed", "key", "number", "sync", "no", "user", "letter", "object", "header", "unit", "valid", "frame", "rule", "l", "liner", "part", "connection", "lin", "pe", "cell", "element", "link", "e", "code", "len", "li", "strip", "page", "error", "data", "write", "parse", "style", "point", "lf", "message", "source", "text", "block", "name", "file", "lc", "end"], "phonesetMap": [" phonessetMap", "phonesSetCache", "phonesetTable", "phonesetList", "phonesetCache", "phonesSetTable", "phonesetsTable", "phonessetTable", " phonessetList", "phonessetMap", " phonesetCache", "phonessetList", "phonesSetList", " phonesetList", "phonesSetMap", "phonesetsCache", "phonesetsMap", "phonesetsList", "phonessetCache", " phonessetTable", " phonessetCache", " phonesetTable"], "lineCount": ["pageIndex", "lineIndex", " lineIndex", "Linecount", "linecount", "pagecount", "LineIndex", "LineCount", " linecount", "pageCount"]}}
{"id1": "4618237", "id2": "20306677", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "label": 0, "substitutes": {"writeFileToFile": ["writeFileAndFile", "writeFileAsStream", "writeFile2File", "writeFilesAsStream", "writeFile2Channel", "writeFileAsFiles", "writeFilesToFile", "writeFilesToChannel", "writeFileAsChannel", "writeFileToStream", "writeFileToFiles", "writeFileAndFiles", "writeFile2Stream", "writeFilesAsFiles", "writeFileAndChannel", "writeFilesToStream", "writeFilesAsChannel", "writeFileAndStream", "writeFilesAsFile", "writeFileToChannel", "writeFile2Files", "writeFilesToFiles", "writeFileAsFile"], "fin": ["fa", "inv", "ini", "include", "din", "raf", "Fin", "fd", "fat", "nir", "pin", "rt", "conn", "inn", "fn", "kin", "ris", "fine", "init", "rin", "lin", "pins", "fi", "thin", "f", "fm", "ori", "fen", "fp", "inf", "file", "arin", "en", "ln", "FIN", "fr", "rf"], "fout": [" fOut", "Fout", "rfOut", "fint", "bin", "rfint", "fOut", "bout", "Fin", " fint", " foff", "boff", "bOut", "rfin", "FOut", "Foff", "foff", "Fint", "rfout"], "append": ["ended", "send", "push", "string", "want", "padding", "pend", "spread", "remove", "adjust", "open", "atten", "protect", "add", "only", "pad", "printf", "batch", "app", "except", "fail", "ending", "future", "enc", "flat", "password", "apply", "ext", "save", "vert", "optional", "null", "flush", "pack", "update", "text", "leaf", "opp", "end"], "inChannel": [" inchannel", "innerStream", "outQueue", "outchannel", "inputChannel", "loginChannel", "inputStream", "INQueue", "INStream", "loginchannel", " inStream", "InChan", "inchannel", "innerchannel", "innchannel", "innerChannel", "INConnection", "inStream", "outStream", "INChannel", "inChan", "innStream", "loginStream", "INChan", "INchannel", "inQueue", "outChan", "innerConnection", "inConnection", " inQueue", "inputChan", "innChannel", "InStream", "InChannel", "inputConnection", "Inchannel", "innerChan"], "outChannel": ["externalchannel", "outputchannel", "externalChannel", "outputChannel", "externalChan", "externalSocket", "OutStream", " outChan", "outchannel", "ioChan", "OutChannel", "outputSocket", "Outchannel", "outSocket", " outContext", "iochannel", "inchannel", "ioStream", "outputChan", "ioChannel", "inStream", "outStream", "inChan", "OutContext", "outChan", "OutChan", " outchannel", "inSocket", "inContext", "outContext"]}}
{"id1": "15262411", "id2": "14464131", "code1": "    String fetch_pls(String pls) {\n        InputStream pstream = null;\n        if (pls.startsWith(\"http://\")) {\n            try {\n                URL url = null;\n                if (running_as_applet) {\n                    url = new URL(getCodeBase(), pls);\n                } else {\n                    url = new URL(pls);\n                }\n                URLConnection urlc = url.openConnection();\n                pstream = urlc.getInputStream();\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        if (pstream == null && !running_as_applet) {\n            try {\n                pstream = new FileInputStream(System.getProperty(\"user.dir\") + System.getProperty(\"file.separator\") + pls);\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        String line = null;\n        while (true) {\n            try {\n                line = readline(pstream);\n            } catch (Exception e) {\n            }\n            if (line == null) {\n                break;\n            }\n            if (line.startsWith(\"File1=\")) {\n                byte[] foo = line.getBytes();\n                int i = 6;\n                for (; i < foo.length; i++) {\n                    if (foo[i] == 0x0d) {\n                        break;\n                    }\n                }\n                return line.substring(6, i);\n            }\n        }\n        return null;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://hostname:80\");\n            URLConnection conn = url.openConnection();\n            for (int i = 0; ; i++) {\n                String headerName = conn.getHeaderFieldKey(i);\n                String headerValue = conn.getHeaderField(i);\n                if (headerName == null && headerValue == null) {\n                    break;\n                }\n                if (headerName == null) {\n                }\n            }\n        } catch (Exception e) {\n        }\n    }\n", "label": 0, "substitutes": {"fetch_pls": ["fetch_pullss", "fetch_plp", "fetch_Plp", "fetch_Pla", "fetch_plss", "fetch_Plss", "fetch_pulla", "fetch_pla", "fetch_Pls", "fetch_pullp", "fetch_pulls"], "pls": ["plses", "pts", "Plses", "Plf", " plts", "splses", "PLS", "PLs", "splS", "splb", " plgs", "pli", " Plgs", "plts", " Pls", "ptS", "plf", "ptss", "splp", "plS", "plss", "splts", "spls", "splss", " pli", " plS", " Pli", "yls", "replb", " plb", " plss", "blgs", "replS", "plp", "bls", "ylp", "ylses", "splf", "PLss", "bli", "plgs", "Pls", "ylf", "repls", "replss", "Plp", "ylts", " plp", "plb"], "pstream": ["pfeed", "pchannel", "PStream", "perchannel", "pstring", "pengine", "psw", "spsw", "Pengine", "psStream", "pbody", "perstream", "ipstring", "frow", "fstring", "parrow", "spunk", "tbody", "tchannel", " pStream", "tstream", "fstream", "perbody", "ipsource", " pfeed", "Pchannel", "spStream", "ppstring", "fchannel", "ppath", " pchannel", "punk", "parstream", "psource", " pstring", "ppstream", "ppsource", "tsource", "Punk", "parpath", "spstream", "ipstream", "Psw", "fengine", "ipfeed", "psengine", "persource", "fStream", "Pstream", " psw", " ppath", "ppfeed", " psource", "prow", "psstream", " punk", " pbody", "pStream", " prow", "fpath", "parstring", "pschannel"], "url": ["resource", "pull", "ob", "string", "c", "blog", "host", "http", "service", "www", "URL", "log", "ll", "path", "api", "ur", "feed", "open", "gl", "Url", "rl", "impl", "conn", "address", "bel", "bug", "loc", "build", "rel", "l", "connection", "base", "ls", "server", "coll", "sl", "f", "control", "link", "hub", "ul", "image", "page", "ssl", "fl", "b", "web", "uri", "source", "client", "org", "file"], "urlc": [" urlf", "webci", "Urlc", "urlf", "URLc", "URLconn", "bbn", "webf", "webn", " urlconn", "urln", "Urll", "urlci", " urlci", "urlconn", "urlp", "bbc", "Urlconn", " urln", "URLp", "urll", "URLl", "webc", "bbf", " urll", "Urlp", "bbci", " urlp"], "line": ["inline", "look", "entry", "row", "pass", "day", "string", "lines", "word", "LINE", "ine", "comment", "le", "Line", "response", "log", "co", "key", "sync", "object", "no", "header", "frame", "l", "rule", "base", "lin", "pe", "cell", "load", "definition", "sl", "block", "link", "e", "code", "value", "home", "strip", "el", "nl", "val", "lo", "page", "next", "error", "data", "parse", "write", "style", "b", "lf", "message", "one", "source", "lock", "text", "body", "name", "file", "lc", "end"], "foo": ["que", "fe", "done", "floor", "token", "day", "front", "dirty", "string", "qa", "py", "stuff", "oa", "fun", "key", "buf", "la", "flo", "header", "bug", "xxxx", "hello", "pos", "nice", "prefix", "office", "f", "bar", "company", "field", "code", "value", "home", "date", "bo", "page", "little", "data", "type", "oo", "fb", "something", "goo", "po", "info", "name", "file"], "i": ["hi", "si", "qi", "ip", "u", "multi", "ini", "ii", "c", "k", "pi", "o", "limit", "d", "is", "abi", "ci", "di", "io", "vi", "ui", "in", "ri", "bi", "p", "l", "ki", "j", "I", "fi", "x", "eni", "index", "f", "e", "oi", "li", "start", "ni", "v", "gi", "ti", "mi", "ai", "b", "xi", "id", "info", "uri", "ix", "mu", "end"]}}
{"id1": "6963063", "id2": "5620792", "code1": "    public static void main(String args[]) {\n        int[] mas = { 3, 5, 6, 9, 1, -3, -4, -88 };\n        int sort = 0;\n        for (int j = 0; j < (mas.length); j++) {\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    sort = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = sort;\n                }\n            }\n        }\n        for (int i = 0; i < mas.length; i++) {\n            System.out.print(\" \" + mas[i]);\n        }\n    }\n", "code2": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"mas": ["fa", "faces", "names", "lambda", "inas", "central", "ms", "ama", "asa", "cas", "ima", "lam", "mos", "spec", "sha", "as", "mat", "params", "phas", "images", " ma", "os", "sa", "la", "meta", "ins", "ums", "ias", "amps", "afi", "xs", "Las", "months", "ra", "MA", "forms", "missing", "alpha", "mc", "phi", "ams", "pos", "ta", "amas", "pa", "ls", "ga", "ia", "mast", "ma", "astics", "asia", "cs", "bas", "mag", "space", "marks", "a", "features", "mis", "rules", "cats", "data", "parts", "nas", "mm", "ras", "las", "mad", "ages", "asm", "mes"], "sort": ["use", "cmp", "position", "g", "ii", "o", "ist", "master", "adjust", "lower", "label", "search", "edit", "list", "slice", "ji", "place", "ort", "num", "orient", "min", "seq", "loc", "alias", "err", "alpha", "default", "l", "part", "init", "order", "pos", "replace", "scale", "s", "size", "index", "ul", "pre", "hide", "split", "axis", "lib", "start", "ind", "filter", "diff", "parse", "type", "alt", "style", "vert", "Sort", "sign", "id", "parent", "offset", "update", "par"], "j": ["js", "si", "u", "n", "k", "ii", "m", "pi", "y", "o", "d", "is", "ci", "J", "z", "ji", "ui", "num", "bi", "ie", "p", "it", "l", "I", "x", "f", "oi", "li", "ind", "q", "a", "h", "v", "jp", "b", "xi", "jc", "ij"], "i": ["iu", "hi", "temp", "si", "qi", "ip", "u", "multi", "ini", "ii", "k", "m", "pi", "c", "o", "inner", "abi", "ci", "ij", "di", "io", "api", "z", "slice", "ji", "ui", "in", "ri", "bi", "ie", "it", "phi", "init", "I", "fi", "x", "uli", "index", "f", "cli", "e", "oi", "li", "ori", "a", "ni", "h", "gi", "v", "ti", "mi", "ai", "yi", "jp", "data", "b", "xi", "id", "info", "uri", "ix", "mu", "ik", "lc"]}}
{"id1": "2113444", "id2": "19134229", "code1": "    private VelocityEngine newVelocityEngine() {\n        VelocityEngine velocityEngine = null;\n        InputStream is = null;\n        try {\n            URL url = ClassPathUtils.getResource(VELOCITY_PROPS_FILE);\n            is = url.openStream();\n            Properties props = new Properties();\n            props.load(is);\n            velocityEngine = new VelocityEngine(props);\n            velocityEngine.init();\n        } catch (Exception e) {\n            throw new RuntimeException(\"can not find velocity props file, file=\" + VELOCITY_PROPS_FILE, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n        return velocityEngine;\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"newVelocityEngine": ["newVelocityServer", "newvelantomEngine", "newVelisionDriver", "newVelysicsServer", "newvelantomServer", "newvelantomInstance", "newVelantomEngine", "newVelysicsInstance", "newVelisionServer", "newVelantomServer", "newVelysicsDriver", "newvelocityInstance", "newVelocityDriver", "newVelisionInstance", "newvelocityServer", "newvelocityEngine", "newvelantomDriver", "newVelocityInstance", "newVelisionEngine", "newVelysicsEngine", "newVelantomDriver", "newVelantomInstance", "newvelocityDriver"], "velocityEngine": ["velocityModel", "velantomNode", "velocolServer", "velisionController", "velisionCore", "velocityServer", "velvelServer", "velantomEngine", "collocityServer", "velosityEngine", "velvelModule", " velocityController", "VelocityModel", "velocityCase", "velosityCase", "VeloService", "velisionCase", "velocityDriver", " velisionCore", "velvelCase", "velityEngine", "velityDriver", "velosityNode", "explocityNode", "velosityCore", "velocityController", "collisionServer", "collocityEngine", "velvelNode", "velotionEngine", " velisionController", "veloModel", "explosityModule", "VeloEngine", "velosityModule", "velocolController", "velosityController", "explocityServer", "velvelImpl", "velocityCore", "velantomServer", "velisionServer", "VelocityEngine", "velocityService", "veloDriver", "VeloDriver", "velocityModule", "explosityNode", "velityModel", "velityService", "collocityController", "velotionDriver", "veloEngine", "velocolImpl", "collisionController", "velisionEngine", "explosityServer", " velocityCore", "veloService", "velvelController", " velisionCase", "collisionEngine", "collocityImpl", "velocolEngine", "velvelEngine", "VelocityService", " velisionEngine", "VeloModel", "explocityEngine", " velocityCase", "explocityModule", "velvelCore", "velotionService", "velosityServer", "explosityEngine", "velisionImpl", "velocityNode", "velantomModule", "velotionModel", "collisionImpl", "velocityImpl", "VelocityDriver"], "is": ["ib", "resource", "il", "or", "si", "us", "ip", "isa", "ios", "im", "ois", "isl", "http", "was", "state", "iris", "has", "as", "api", "ais", "abs", "os", "IS", "io", "ui", "in", "address", "does", "ie", "it", "err", "fs", "init", "s", "Is", "out", "iss", "iso", "ar", "get", "its", "iter", "isi", "isc", "i", "ori", "close", "res", "mis", "bis", "lis", "ai", "nis", "ps", "id", "es", "info", "uri", "stream", "src", "ris"], "url": ["resource", "il", "string", "host", "http", "xml", "str", "service", "URL", "path", "ur", "api", "feed", "io", "Url", "address", "loc", "l", "base", "server", "location", "config", "loader", "sl", "f", "e", "i", "image", "page", "ssl", "data", "r", "b", "id", "uri", "stream", "source", "src", "file"], "props": ["prfs", "probs", "preps", "protfs", " prods", "profs", " proPS", " properties", "protps", "prob", "preds", "proPS", "promcs", "propfs", "propps", "properties", "prperties", "crods", "procs", "Probs", "prps", "propperties", "ProPS", "crops", " procs", "prods", "Props", "croperties", "crofs", "prb", "promps", "Prods", "propPS", "protperties", "propcs", "Procs", "prombs", "protb", "propbs", "promds", "propb", " probs", "preperties", " profs", "prefs"]}}
{"id1": "13783898", "id2": "23452437", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFiletoString", "encodeFile2File", "encodeString2File", "encodeFiletoStream", "encodeFiletoFile", "encodeStringToString", "encodeFileToString", "encodeFileToStream", "encodeStringToFiles", "encodeStringToFile", "encodeFile2Files", "encodeString2String", "encodeFileFromFiles", "encodeFileFromString", "encodeStringToStream", "encodeFileFromStream", "encodeString2Stream", "encodeString2Files", "encodeFileToFiles", "encodeFile2String", "encodeFile2Stream", "encodeFiletoFiles", "encodeFileFromFile"], "infile": [" infp", "inputfilename", "infp", "inputFile", "outfiles", " infiles", "Infilename", "inputfp", "inputfiles", "outfilename", "Infile", "outfp", " infilename", "InFile", "inFile", "inputfile", "Infiles", "outFile", "infiles", "infilename"], "outfile": [" outname", "OutFile", "outfolder", "infp", "newFile", "Outname", "newname", "outname", " outFile", "newfolder", "outfilename", "outfp", " outfilename", " outfolder", "Outfile", "outputfp", "Outfolder", "newfile", "infolder", "outputfolder", "outFile", "outputfile", "outputfilename", " outfp", "infilename"], "in": ["In", "inas", "pass", "again", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "ic", "as", "con", "pin", "ins", "ac", "min", "conn", "inn", "into", "err", "isin", "init", "win", "s", "base", "rin", "gin", "thin", "inside", "i", "nin", "a", "image", "socket", "sin", "login", "reader", "data", "vin", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "In", "or", "exit", "again", "line", "cache", "o", "ex", "inner", "bin", "Out", "copy", "outer", "io", "outs", "co", "post", "sync", "on", "conn", "no", "err", "up", "net", "base", "exec", "work", "name", "session", "off", "home", "image", "lib", "socket", "to", "writer", "output", "error", "ou", "write", "obj", "OUT", "point", "job", "inc", "parent", "source", "client", "one", "file"], "buffer": ["seed", "cache", "uffer", "limit", "padding", "input", "layer", "wave", "feed", "buf", "slice", "queue", "length", "address", "count", "batch", "base", "server", "url", "size", "Buffer", "iter", "len", "value", "split", "bytes", "transfer", "result", "border", "bb", "reader", "data", "write", "type", "raw", "null", "b", "fb", "buff", "flush", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", "tell", " Read", "use", "ip", " skip", "send", "n", " write", "current", "reading", "fill", "limit", "select", "input", "copy", "READ", "lex", "io", "feed", "add", "slice", "sync", "length", " count", "count", "seek", "play", "Read", "ad", "exec", "find", "get", "load", "x", "wait", "size", "work", "f", "iter", "len", "i", "allow", "ind", "_", "start", "ride", "close", "connect", "check", "reader", " copy", "parse", "write", "next", "se", "raw", "inc", "id", "sleep", "end"], "success": ["rolled", "done", "pass", "status", "again", "respons", "initial", "method", "results", "failed", "comment", "winner", " Success", "continue", "response", "func", "fast", "right", "path", "open", "Success", "modified", "ceed", "primary", "first", "warning", "construct", "content", "ccess", "growth", "roll", "good", "valid", "successful", "flash", " successful", "default", "danger", "model", "fail", " succeed", "complete", " succ", "value", "rolling", "result", "better", "true", "error", "data", "follow", "xx", "null", "successfully", "message", "cess"]}}
{"id1": "19549489", "id2": "942693", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["Cop", "paste", "cop", " copies", "zip", "Copy", "io", "move", "Transfer", "sync", "download", "p", "create", " Copy", "all", " transfer", "upload", "clone", "delete", " move", "split", "transfer", "write", " copied", "source", " copying", "file"], "sourceFile": ["resourceFile", "sourceFiles", "serviceFilename", " sourcefile", "SourceFile", "sourcefile", " sourceFilename", " sourceDirectory", "resourceFiles", "SourceDirectory", "SourceFiles", "sourceFILE", "sourceFilename", "serviceFiles", "resourceDirectory", "siteFile", "searchFile", "Sourcefile", "sourceDirectory", "servicefile", "siteFILE", "searchFilename", " sourceFILE", "siteDirectory", " sourceFiles", "resourcefile", "searchfile", "searchFiles", "siteFiles", "SourceFILE", "serviceFile"], "destinationFile": ["destinationFiles", "distinationFiles", "destinatorDirectory", "destinatedfile", "DestinationDir", "DestinationFiles", "destinationDirectory", "distinationImage", "Destinatorfile", "destinationfile", "destinationImage", "destationfile", "destinatorDir", "destinatorFiles", "DestinatorFiles", "DestinatorDir", "destinatorFile", "destationImage", "destationDir", "distinatedFiles", "destinatorImage", "distinatedImage", "destinatorfile", "distinatedFile", "distinatedDirectory", "destinatedDirectory", "distinationFile", "destinatedImage", "DestinatorFile", "destationDirectory", "destationFiles", "distinationDirectory", "DestinationFile", "destinatedFiles", "destinatedDir", "destationFile", "Destinationfile", "destinationDir", "destinatedFile"], "sourceFileChannel": ["sourceFilechannel", " sourceFileContext", "sourceDirectoryChan", "sourceFilesChannel", "ourceFileStream", "sourceStreamContext", "sourceDirchannel", " sourceFilesContext", "sourceStreamConnection", "sourceDirectoryClient", "sourceStreamChan", "sourceFileContext", "sourceLibrarySocket", "sourceLibraryChan", "ourceStreamStream", "ourceFilechannel", "sourceFilesService", " sourceFileService", "sourceFileService", "sourceStreamService", "sourceLinechannel", "ourceStreamChan", " sourceFilesService", "sourceDirStream", "sourceDirectorySocket", "sourceDirectoryChannel", "sourceStreamStream", "sourceDirChannel", "sourceLineClient", "sourceFunctionService", "sourceLineChannel", "sourceLibraryClient", "ourceFileChannel", "sourceFunctionChannel", "sourceFilesContext", "targetFileClient", "targetLibraryChan", "sourceFileClient", "targetFileChan", " sourceFilesConnection", "sourceFileStream", "ourceStreamChannel", " sourceFileConnection", "ourceFileChan", "sourceLineStream", "sourceLibraryChannel", "sourceLineChan", "targetLibrarySocket", "sourceFileConnection", "sourceFileChan", "sourceFilesConnection", "sourceLineSocket", "targetFileSocket", "sourceFunctionContext", "sourceFunctionConnection", " sourceFilesChannel", "sourceDirChan", "targetFileChannel", "sourceFileSocket", "targetLibraryClient", "sourceStreamChannel", "ourceStreamchannel", "targetLibraryChannel", "sourceStreamchannel"], "destinationFileChannel": ["destinationIOClient", "destinationFileCache", "destinatorFileHandler", "destinationLineChannel", "destinationFilesService", "destinationIOCache", "destinationFilesHandler", "destinatorFileChan", "destinatorFilesService", "destinationFileChan", "destinationFilesChannel", "destinatorFileCache", "destinatorFileConnection", "destinationDirectoryConnection", "destinationIOService", "destinationDirectoryClient", "destinationDirectoryChan", "destinatorFileService", "destinatorFilesCache", "destinatorFilesChannel", "destinatorFilesClient", "destinationFilesClient", "destinationLineConnection", "destinationIOChannel", "destinationFileClient", "destinationLineHandler", "destinationDirectoryCache", "destinatorFilesConnection", "destinationFilesConnection", "destinationFileConnection", "destinationLineClient", "destinationLineService", "destinatorFilesChan", "destinationDirectoryHandler", "destinationFilesChan", "destinationFilesCache", "destinationFileHandler", "destinationLineChan", "destinationDirectoryService", "destinationDirectoryChannel", "destinatorFilesHandler", "destinatorFileChannel", "destinationFileService", "destinatorFileClient"]}}
{"id1": "1097146", "id2": "9846843", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getMessagedigester", "getContentdigester", "getMessageDigifier", "getContentDigifier", "getMessagedigests", "getMessagedigifier", "getMessageEncester", "getMessageEncests", "getContentDigest", "getContentdigifier", "getMessageSignest", "getContentDigester", "getMessageEncifier", "getMessageEncest", "getMessageSignester", "getMessageDigests", "getMessagedigest", "getMessageSignests", "getMessageDigester", "getMessageSignifier", "getContentDigests", "getContentdigests", "getContentdigest"], "input": ["temp", "plus", "accept", "stream", "container", "string", "instance", "context", "request", "xml", "str", "inner", "state", "self", "empty", "list", "this", "in", "content", "object", "address", "audio", "amp", "document", "out", "element", "model", "definition", "config", "now", "array", "Input", "i", "password", "image", "inf", "output", "argument", "data", "type", "raw", "submit", "parse", "null", "reader", "target", "message", "parent", "source", "buffer", "text", "binary", "form"], "md": ["dc", "df", "mb", "mg", "mp", "ms", "pm", "od", "mand", "cm", "mac", "rm", "m", "sm", " MD", "um", "d", "sha", "di", "MD", "bd", "meta", "wd", "M", "dd", "mc", "mod", "cmd", "mn", "dr", "ma", "mag", "am", "gd", "dm", "nm", "amd", "rpm", "mm", "metadata", "vd", "bf", "mad", "mt", "me", "bm", "mo"], "bytes": ["pages", "Bytes", "classes", "words", "codes", "bs", "bps", "string", "ies", "lines", "values", "bits", "outs", "bles", "files", "groups", "seconds", "address", "tes", "pieces", "gb", "base", "s", "strings", "keys", "its", "blocks", "units", "vals", "data", "parts", "ipes", "b", "null", "es", "binary", "les", "body", "odes", "rows"]}}
{"id1": "4593011", "id2": "19910627", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public String getData(DefaultHttpClient httpclient) {\n        try {\n            HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\");\n            get.setHeader(\"Content-Type\", \"application/json\");\n            get.setHeader(\"Accept\", \"*/*\");\n            HttpResponse response = httpclient.execute(get);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            responseMessage = read(instream);\n            if (instream != null) instream.close();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return responseMessage;\n    }\n", "label": 0, "substitutes": {"loadDDL": ["loadDDML", "loadCDML", "loadSDE", "LoadDDML", "loadDDLL", "loadSDL", "LoadCDLL", "LoadDDL", "loadCDE", "loadODL", "LoadCDML", "LoadCDE", "loadCDL", "loadCDLL", "loadODML", "loadSDLL", "loadDDE", "LoadDDLL", "LoadCDL", "loadODE", "LoadDDE", "loadODLL", "loadSDML"], "stmt": ["stmd", "STmt", "sttt", "stm", "estmr", "strmt", "rmt", "estmb", "STmb", "rm", "Stmb", "stgr", " stgr", " stdb", "constmt", "stmp", "Stmt", "tmd", "stpr", " sttr", "estm", "estmd", "constmn", "STmr", "strgr", "constdb", "Stmd", " stmn", "Stmp", "rmd", "STtr", "estmp", "Stmn", "tmt", "stmr", "Stdb", "strtr", "STpr", "strpr", "stmb", " stmd", "tdb", "Stm", " sttt", "stmn", "STgr", " stpr", "Sttt", "esttt", " stm", "tm", "STmp", "sttr", "stdb", "constm", "Stmr", "estmt", "rdb"], "qry": ["eqrys", "equry", "qri", "qrys", "qries", "qurys", "quries", "quury", "qRY", "Qries", "eqry", "quri", "Qrys", "quRY", "eqRY", "Qri", " qrys", "Qry", " qury", " qri", "qury", " qRY", " qries"], "q": ["ch", "requ", "n", "c", "k", "qa", "request", "select", "d", " query", "qu", "key", "queue", "qq", "iq", "Q", "p", "quant", "qs", "qt", "query", "config", " req", " p", "f", "quest", "e", "i", "v", " sq", "dq", "req", "r", "b", "ql", "id", "t", "sq", "eq"]}}
{"id1": "22135199", "id2": "8815137", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "label": 1, "substitutes": {"testCodingEmptyFile": ["testCodingNoFiles", "testCodingOfStream", "testCodingOfSourceFile", "testCachingEmptyFiles", "testCachingOfFiles", "testCodingZeroSourceFile", "testCodingNoStream", "testCachingEmptyFile", "testCodingOfFile", "testCachingOfStream", "testCodingZeroFile", "testCodingZeroStream", "testCachingOfFile", "testCodingOfFiles", "testCachingEmptyStream", "testCodingNoSourceFile", "testCodingNoFile", "testCodingZeroFiles", "testCodingEmptyFiles", "testCachingEmptySourceFile", "testCachingOfSourceFile", "testCodingEmptyStream", "testCodingEmptySourceFile"], "baos": ["kao", "kaoa", "pao", "BaoS", "waOs", "bioS", "paoa", "paOS", "bao", "aaaaOs", "bioes", "buoa", "bios", "baOs", "paos", "kaos", "Baotes", " baotes", " baoes", " baoS", "waoS", "buo", "BaOS", "Baos", "baOS", "buos", "baoa", "aaaaOS", "buOS", "baoes", "biotes", "BaOs", "baoS", "aaaaos", "kaOS", "waos", "Baoes", "baotes", "aaaaoS", "waOS"], "channel": ["an", "ch", "cho", "group", "container", "c", "context", "chan", "service", "self", "log", "io", "sc", "can", "feed", "queue", "conn", "handler", "Channel", "annels", "video", "connection", "out", "server", "url", "sea", "system", "config", "camera", "bean", "cam", "socket", "reader", "data", "parent", "source", "stream", "client", "console", "flow"], "params": ["cmp", "stats", "css", "http", " param", "cpu", "options", "ctx", "api", "Param", "param", "cms", "conn", "proc", "ams", "Parameters", "ops", "config", "settings", "processor", "size", " parameters", "tx", "Par", "null", "mm", "ps", "parser", "par"], "outbuf": ["outbuff", " outbuffer", "outputbuffer", "outqueue", " outbuff", "outbuffer", "outputqueue", "outbag", "outputbuf", "Outbuff", "Outbuffer", " outqueue", "inputbag", "inputbuff", "outputcb", " outcb", "inputqueue", "outputbuff", " outbag", "outcb", "Outcb", "outputbag", "Outbuf", "inputbuf"], "metrics": ["Metrics", "matrics", " metrix", "matric", "monras", "Metric", " metric", "monics", "matrix", "metrix", "monric", " metras", "metals", "matals", " metics", "Metals", "metics", "Metrix", "metras", "monrics", "metric", " metals", "Metics", "Metras"], "encoder": [" encoser", "ecipher", "ecode", "Encipher", " encode", "enoded", "Encler", "encipher", "ecoding", " encipher", "Encode", "enode", " encoded", "ecoded", "ecressor", " enccode", "enressor", " encler", "encoded", "Encoded", "ecler", " encoding", "encode", "enoder", "encler", "encoding", "Encoding", "encoser", "Encoser", "ecoser", "enoser", "Encoder", "eccode", " encressor", "encressor", "ecoder", "enccode"], "tmpFile": ["tempFiles", "mpPage", "mpPath", "vtFilename", "poraryfile", "vtDir", "txtfile", " tmpPath", "mpfile", "mpFiles", "tmpPage", " tmpDir", "tmpFiles", "tempPath", " tmpfile", "poraryFile", "mpFile", "txtFunction", "txtFile", "testFile", "mpFunction", "mpFilename", "vtfile", "tempFile", "tmpFilename", " tmpFiles", "tempFolder", "poraryPage", "tmpfile", "testFolder", "tmpFunction", "testFiles", "tempfile", "tmpDir", "testfile", "mpDir", "vtFile", "poraryFunction", " tmpFilename", "tmpPath", "tmpFolder", " tmpFolder", "txtPage"], "fout": [" ffile", "Fout", "sffile", "fragain", "fio", "sfio", "frurl", "Fchannel", "sfchannel", "fwrite", "fagain", "frwrite", "fdurl", "fdwrite", "flagain", "furl", "flout", "flurl", "flwrite", " fio", "Fio", "Ffile", "frout", "sfout", "ffile", "fdout", "fdagain"], "wrtout": [" wrtouter", "wRTn", " wrcout", "wadrin", "Wrtwriter", "wrdwriter", "wrcout", "wrn", "wrcin", "wrdout", "wrcouter", "wrout", "wrtouter", " wrtin", "wrdouter", " wrcagain", "wrtn", "wrtagain", "WrtOut", "wrtin", " wrtagain", "WRTn", "wrcn", " wrcin", "WRTouter", "wRTagain", "WRTOut", "Wrtin", "WRTwriter", "wadrout", "wRTwriter", "wRTout", " wrcouter", "wrdin", "wRTOut", "Wrtouter", "Wrtout", "wadrouter", "wrtwriter", "wadrwriter", "WRTout", "wRTouter", "wadragain", "wrtOut", "wRTin", "Wrtn", "wrcOut", "WRTin", "wrcagain", "wrOut", "wrin"], "fchannel": ["pchannel", "pconn", "fcontainer", "fresource", "fconn", "fstream", "fenstream", "bchan", "bcontainer", "bconn", "hqueue", "fqueue", "pqueue", "hchannel", "fenresource", "pcontainer", "fenchannel", "bchannel", "pchan", "hstream", "presource", "hresource", "pstream", " fcontainer", " fchan", "fenqueue", "fchan", " fconn"], "s": ["js", "ms", "ings", "u", "S", "ses", "g", "string", "c", "m", "n", "o", "gs", "abs", "os", "ins", "p", "l", "qs", "strings", "ls", "settings", "f", "services", "e", "su", "i", "ns", "v", "ts", "states", "r", "b", "ps", "t", "es", "ss"]}}
{"id1": "20208819", "id2": "19235551", "code1": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    protected BufferedImage handleFCLAException() {\n        if (params.uri.startsWith(\"http://image11.fcla.edu/cgi\")) try {\n            params.uri = params.uri.substring(params.uri.indexOf(\"q1=\") + 3);\n            params.uri = params.uri.substring(0, params.uri.indexOf(\"&\"));\n            params.uri = \"http://image11.fcla.edu/m/map/thumb/\" + params.uri.substring(params.uri.length() - 3, params.uri.length() - 2) + \"/\" + params.uri.substring(params.uri.length() - 2, params.uri.length() - 1) + \"/\" + params.uri.substring(params.uri.length() - 1, params.uri.length()) + \"/\" + params.uri + \".jpg\";\n            URL url = new URL(params.uri);\n            URLConnection connection = url.openConnection();\n            return processNewUri(connection);\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"hash": ["SHA", "string", "Hash", "str", "sum", "copy", "num", "build", " hashes", "print", " hashing", "get", "mix", "code", "dump", "format", "check", "output", "parse", "raw", "pack", "update", " Hash"], "input": ["temp", "plus", "accept", "seed", "string", "instance", "current", "context", "request", "str", "inner", "feed", "in", "length", "address", "audio", "upload", "url", "config", "array", "Input", "image", "inf", "output", "reader", "data", "addin", "raw", "null", "parent", "source", "buffer", "text", "binary", "form"], "algorithm": ["calgebra", "aligebra", "aligorithm", " alphabet", " algebra", "aligo", "Algorithm", "Algorith", "algorith", "calgorith", "alphabet", "calgo", "Algebra", " algo", "calgorithm", "algebra", " algorith", "aliphabet", "Alphabet", "algo", "Algo"], "dig": ["rg", "wrap", "fe", "grab", "cmp", "pm", "im", "g", "push", "prep", "and", "dat", "exp", "ex", "um", "d", "rand", "imag", "tool", "log", "Dig", "add", "cod", "pin", "num", "div", "alg", "build", "ag", "comb", "ld", "lab", "ng", "init", "cd", "dim", "rob", "mod", "del", "get", "mix", "enc", "sem", "test", "gen", "de", "sign", "rd", "grad", "me", "ig", "db", "dec"], "result": ["df", "group", "root", "ger", "function", "Result", "global", "string", "current", "results", "cover", "response", "sum", "report", "manager", "api", "match", "card", "this", "dest", "json", "length", "user", "our", "ret", "db", "up", "valid", "default", "future", "consumer", "url", "work", "array", "iter", "su", "value", "success", "format", "res", "record", "page", "output", "runner", "data", "test", "member", "counter", "diff", "null", "message", "buffer", "source", "master", "uri", "re", "builder"], "digest": ["bigest", "digse", "signEST", "signse", "bigested", " Digester", "bigester", " digests", "generEST", "Digester", " digse", "Digested", "signest", "digested", " digEST", "digester", "DigEST", " digester", " digested", "generest", " Dige", "signester", "dige", "generester", "digEST", " Digest", "bigests", "Digests", "digests", " DigEST", "Digest", "Dige", " dige", "Digse", "generests"], "hex": ["temp", "row", "ctr", "wh", "zip", "utf", "string", "zero", "rh", "ex", "shift", "pixel", "bin", "transform", "sum", "ticket", "char", "bit", "num", "length", "address", "header", "ph", "oct", "uint", "throw", "pex", "mix", "array", "index", "iter", "hess", "rex", "head", "sex", "cube", "xf", "h", "format", "check", "data", "digit", "null", "buff", "pattern", "text", "form"], "i": ["iu", "hi", "si", "qi", "multi", "n", "ii", "c", "pi", "o", "y", "d", "abi", "ci", "di", "io", "z", "ui", "ri", "bi", "p", "it", "l", "phi", "j", "I", "x", "uli", "index", "f", "e", "oi", "li", "a", "h", "v", "gi", "ti", "ai", "b", "xi", "t", "id", "info", "uri", "ix", "mu"], "u": ["iu", "bu", "us", "uu", "c", "string", "ru", "o", "d", "uid", "U", "ue", "ur", "yu", "char", "ui", "uv", "cu", "num", "mu", "sup", "p", "l", "up", "pu", "cur", "chu", "x", "du", "f", "fu", "e", "su", "q", "ul", "uf", "h", "hu", "uc", "v", "ou", "tu", "b", "back", "nu", "uri", "uni", "lu", "un"], "highCount": ["largeC", "hiCode", "lowCast", "lowSize", "higherCode", "highC", "HighC", "fullCast", "highercount", "highCode", "lowcount", "fullCount", "largeCode", "lowLength", "HighCount", "hiCount", "hiSize", "fullcount", "largeCount", "higherSize", "lowCode", "hiLength", "HighCode", "highLength", "HighSize", "highSize", "higherC", "higherCast", "higherCount", "largeSize", "highCast", "HighLength", "highcount"], "lowCount": ["lowerLength", "LowC", "lowerCount", "lowCast", "lowSize", "slowCount", "highC", "LowCast", "highSum", "lowerCast", "lowerSum", "lowLength", "lowerC", "slowLength", "LowCount", "slowSum", "highLength", "lowSum", "lowC", "highSize", "slowCast", "LowSize", "lowerSize", "highCast"]}}
{"id1": "7118860", "id2": "8665321", "code1": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"getEncoding": ["getencoder", " getencoder", "getEndryption", "getencryption", "getEnoding", " getEncoder", "getEncoder", "getEndoder", "getencoding", " getEncoded", "getEncoded", "getEnryption", "getEndoding", "getencoded", " getencryption", " getencoded", "getEnoded", "getEnoder", " getEncryption", " getencoding", "getEndoded", "getEncryption"], "reader": ["resource", "row", "ry", "stream", "container", "seed", "library", "context", "reading", "pointer", "oder", "inner", "ler", "input", "copy", "right", "io", "ner", "feed", "driver", "in", "ri", "er", "handler", "server", "url", "load", "loader", "read", "Reader", "iter", "rer", "per", "director", "i", "worker", "editor", "writer", "result", "error", "data", "parse", "rr", "r", "parser", "rar", "info", "buffer", "source", "client", "parent", "builder", "file"], "encoding": ["encryption", "engosing", "explasing", "enoded", " encetting", "encoder", "enosing", "execoder", "enging", "encging", "installoding", "engryption", "enode", "Encging", "Encryption", " encoder", " encoded", "Encasing", " encryption", "engoded", "explcel", "engoding", "expletting", "incode", " enccel", "enhryption", "encoded", "execode", "enhode", "engoder", "encetting", "encode", "enoder", "Encoded", "exploding", "enhoding", "Encoding", "installetting", " encasing", "enoding", "installcel", "engasing", "incoder", "Encoder", "encasing", "execoded", "encosing", "extoder", "extoding", "incryption", "enhoded", "enhoder", "incoding", "installasing", "execoding", "extoded", "enccel", "enasing", " encosing", "enryption", "extging"], "connection": ["resource", "application", "section", "container", "function", "position", "c", "Connection", "channel", "context", "method", "http", "character", "service", "condition", "response", "con", "io", "open", "database", "relation", "conn", "creator", "handler", "document", "communication", "server", "url", "system", "config", "index", "link", "session", "wrapper", "connect", "writer", "directory", "connected", "uri", "client", "body"], "header": ["row", "group", "section", "container", "map", "channel", "host", "table", "title", "headers", "response", "layer", "key", "heading", "json", "first", "content", "handler", "er", "dict", "document", "Header", "event", "server", "url", "dr", "index", "head", "record", "writer", "h", "filter", "page", "data", "metadata", "message", "buffer", "body", "column", "file"], "entry": ["row", "or", "application", "ry", "section", "owner", "entity", "string", "exp", "str", "Entry", "inner", "ge", "feed", "match", "key", "add", "enter", "letter", "translation", "ie", "it", "cell", "element", "pe", "expected", "array", "index", "field", "e", "value", "her", "auto", "record", "page", "result", "next", "se", "data", "parse", "member", "ent", "error", "term", "inc", "info", "file"], "item": ["or", "attribute", "section", "ip", "container", "string", "instance", "word", "str", "area", "character", "layer", "key", "ct", "Item", "content", "object", "letter", "atom", "unit", "om", "it", "app", "base", "element", "coll", "url", "server", "article", "anything", "bar", "other", "value", "li", "image", "val", "member", "type", "data", "items", "r", "id", "hop", "info", "source", "sel", "text", "uri", "name", "file"], "line": ["inline", "look", "row", "or", "pass", "section", "ip", "string", "lines", "word", "LINE", "str", "character", "comment", "le", "Line", "ge", "layer", "log", "key", "sync", "content", "user", "object", "letter", "no", "unit", "single", "cl", "l", "part", "rule", "base", "frame", "lin", "cell", "pe", "shell", "url", "load", "non", "sl", "link", "code", "value", "strip", "el", "lo", "page", "data", "write", "parse", "style", "point", "lf", "message", "id", "source", "text", "block", "column", "name", "file", "lc", "end"]}}
{"id1": "3330775", "id2": "21438069", "code1": "    public static JSONObject getJSONData(String url) throws JSONException {\n        JSONObject jObject = null;\n        InputStream data = null;\n        DefaultHttpClient httpClient = new DefaultHttpClient();\n        URI uri;\n        try {\n            uri = new URI(url);\n            HttpGet httpGet = new HttpGet(uri);\n            HttpResponse response = httpClient.execute(httpGet);\n            data = response.getEntity().getContent();\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader;\n            reader = new BufferedReader(new InputStreamReader(data), 8192);\n            while ((line = reader.readLine()) != null) builder.append(line);\n            reader.close();\n            jObject = (JSONObject) new JSONTokener(builder.toString()).nextValue();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return jObject;\n    }\n", "code2": "    public ProjectDeploymentConfiguration createNewProjectDeploymentConfig(int projectID, String name, String description) throws AdaptationException {\n        ProjectDeploymentConfiguration config = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProjectDeploymentConfigurations\" + \"(projectID, name, description) VALUES (\" + projectID + \", '\" + name + \"', '\" + description + \"')\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProjectDeploymentConfigurations WHERE \" + \" projectID   = \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create \" + \"ProjectDeploymentConfiguration failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            config = getProjectDeploymentConfiguration(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProjectDeploymentConfig\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return config;\n    }\n", "label": 0, "substitutes": {"getJSONData": ["loadJResponse", "getJObject", "getJSdata", "getJdata", "getjsondata", "loadJdata", "getJSObject", "loadJObject", "getJResponse", "loadJSONResponse", "loadJSONObject", "loadJData", "getJSONObject", "getjsonObject", "getjsonData", "getJSONResponse", "getJSData", "getJSResponse", "getjsonResponse", "loadJSONData", "getJData", "getJSONdata", "loadJSONdata"], "url": ["resource", "route", "username", "full", "string", "href", "host", "request", "xml", "http", "str", "proxy", "input", "URL", "path", "ll", "api", "ur", "feed", "Url", "json", "address", "l", "connection", "base", "ls", "server", "location", "coll", "like", "sl", "i", "filename", "image", "html", "ssl", "style", "id", "buffer", "source", "name", "file"], "jObject": [" jObj", "ojJSON", " jData", "jObj", "jiData", "jiobject", " jobject", "jobObj", "jJSON", "JObject", "JData", "Jobject", "ojobject", "ojData", "jobData", "ojObject", "JObj", "jData", "ojObj", " jJSON", "jobobject", "JJSON", "jiJSON", "jobject", "jobObject", "jiObject"], "data": ["resource", "entry", "done", "media", "stream", "zip", "cache", "dat", "results", "input", "as", "partial", "api", "feed", "text", "slice", "post", "json", "database", "client", "download", "content", "address", "handler", "ad", "dd", "part", "base", "storage", "server", "load", "DATA", "i", "image", "record", "to", "writer", "plain", "result", "html", "error", "bytes", "memory", "style", "message", "info", "buffer", "source", "body", "file"], "httpClient": [" httpC", " httpclient", "HttpCall", " httpConnect", "HttpClient", "ttpGet", "HttpConnect", "httpC", "HttpCl", "urlclient", "httpConnect", "HttpC", "ttpCall", "ttpC", "httpclient", "httpCall", "HttpGet", " httpCl", " httpCall", "Httpclient", "httpCl", "ttpClient", "urlClient", "urlConnect", "urlCl"], "uri": ["folder", "resource", "route", "si", "qi", "string", "cache", "API", "pi", "request", "http", "service", "api", "ur", "io", "ui", "absolute", "database", "ri", "address", "handler", "URI", "connection", "base", " URI", "server", "location", "query", "cli", "i", "iri", "range", "mi", "id", "source", "client", "uni", "file", "reference"], "httpGet": ["HttpPut", "ttpQuery", "httpReturn", " httpget", "ttpGet", " httpPut", "apiget", "jsonGet", "httpget", "ttpPut", "apiClient", "httpQuery", "jsonget", "jsonClient", "HttpGet", "apiReturn", "httpPut", "HttpQuery", " httpReturn", "jsonReturn", " httpQuery", "apiGet"], "response": ["Response", "resource", "status", "respond", "reply", "request", "http", "results", "report", "api", "feed", "onse", "json", "object", "resp", "connection", "document", "server", "query", "e", "received", "writer", "res", "result", "page", "next", "output", "message", "stream", "client", "body", "file"], "line": ["inline", "entry", "row", "pass", "ip", "string", "lines", "LINE", "str", "character", "comment", "le", "Line", "layer", "feed", "char", "number", "jo", "key", "content", "object", "letter", "header", "unit", "cl", "l", "liner", "part", "base", "lin", "cell", "link", "e", "code", "len", "i", "li", "el", "val", "page", "type", "point", "style", "id", "message", "lf", "buffer", "one", "text", "column", "name", "file", "lc", "end"], "builder": ["or", "row", "entry", "string", "upper", "oder", "inner", "layer", "builders", "number", "driver", "database", "obb", "length", "object", "creator", "keeper", "letter", "er", "build", "handler", "ener", "address", "db", "up", "base", "office", "sb", "array", "building", "iter", "wrapper", "worker", "Builder", "editor", "writer", "result", "runner", "type", "null", "b", "r", "parser", "buffer", "built"], "reader": ["resource", "or", "row", "entry", "ry", "rh", "reading", "oder", "ler", "input", "io", "ner", "feed", "driver", "ri", "client", "keeper", "er", "iterator", "ra", "handler", "bird", "ro", "server", "loader", "read", "Reader", "iter", "rer", "per", "i", "worker", "editor", "writer", "finder", "runner", "rr", "r", "rx", "parser", "rar", "buffer", "stream", "source", "file"]}}
{"id1": "6457199", "id2": "19251426", "code1": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"doRequest": ["runCall", "DoProxy", " doResponse", "runProxy", "runResponse", "DoResponse", "doResponse", "runRequest", " doCall", " doProxy", "doProxy", "DoRequest", "doCall", "DoCall"], "request": ["application", "route", "string", "instance", "context", "method", "call", "http", "Request", "view", "xml", "right", "report", "queue", "json", "object", "user", "hello", "event", "server", "query", "url", "complete", "session", "result", "reader", "error", "req", "message", "uri", "buffer", "client", "re", "name", "reference"], "response": ["Response", "application", "status", "route", "respond", "respons", "site", "host", "reply", "results", "view", "http", "service", "more", "report", "api", "feed", "onse", "json", "object", "template", "resp", "document", "connection", "out", "model", "server", " Response", "index", "success", "writer", "result", "page", "v", "output", "error", "message", "parent", "client", "body", "re", "reference"], "path": ["walk", "route", "token", "full", "string", "host", "Path", "context", "method", "http", "pointer", "inner", "self", "right", "partial", "api", "patch", "text", "key", "slice", "content", "child", "object", "dir", "p", "part", "base", "prefix", "port", "url", "location", "left", "work", "anc", "index", "code", "ath", "ith", "arc", "image", "relative", "type", "data", "PATH", "id", "message", "info", "uri", "source", "alias", "end", "pattern", "name", "template"], "internal": ["inline", "background", "local", "route", "external", "central", "outside", "string", "exclusive", "join", "initial", "context", "http", "inner", "Internal", "actual", "api", "primary", "international", "attr", "absolute", "impl", "custom", "foreign", "original", "shared", "single", "special", "intern", "base", "normal", "rc", "storage", "prefix", "url", "system", "standard", "x", "ident", "inside", "regular", "personal", "remote", "relative", "rx", "parent", "uri", "binary", "alias", "source", "re", "name", "origin"], "resource": ["route", "external", "media", "use", "string", "rest", "resources", "context", "pointer", "http", "ruby", "src", "ource", "manager", "api", "this", "sr", "Resource", "relation", "address", "re", "rule", "connection", "base", "rc", "server", "url", "real", "image", "record", "resolution", "res", "rera", "result", "range", "r", "uri", "stream", "client", "source", "buffer", "file", "reference"], "mimeType": ["mimeTypes", "mimeInfo", "mipType", "pimePath", "modName", "mIMEtype", "smimetype", "mpePath", "pipTypes", "smIMEName", "mimeName", "milePath", "mileInfo", "manceTypes", "smIMEInfo", "modInfo", "miptype", "maxInfo", "mimesInfo", " mimeInfo", "smIMEType", "piptype", "modType", "mpeType", "mimePath", "smimeName", "pimetype", "mpeInfo", "mIMEType", "mileTypes", "manceType", "mancetype", "monsetype", " mileInfo", "mancePath", " mimeTypes", "mIMEName", "mpeTypes", "pipType", "monseType", "modtype", "mimesType", "pimeType", "mileType", " mimePath", "smimeType", "monseTypes", "mIMEInfo", "maxtype", "maxType", "pimeTypes", " mileType", "mimetype", "smIMEtype", " mileTypes", "pipPath", "smimeInfo", "mimesPath", "mipTypes", " milePath", "maxName", "mimesTypes", "mipPath", "monsePath"], "is": ["or", "us", "ip", "isa", "ios", "serv", "im", "ois", "ir", "http", "was", "iris", "as", "api", "ais", "IS", "ui", "in", "ri", "are", "fs", "Is", "vs", "iso", "iss", "ops", "its", "isi", "sis", "isc", "i", "ori", "res", "bis", "lis", "nis", "ps", "ras", "info", "uri", "ris"], "os": ["us", "ios", "so", "bs", "osi", "ies", "o", "dos", "opens", "oss", "as", "io", "ais", "outs", "aos", "bos", "oes", "acs", "ose", "s", "nos", "oS", "los", "iso", "vs", "ops", "cos", "cs", "Os", "ori", "oses", "ros", "res", "ols", "ps", "OS", "ows"]}}
{"id1": "20426057", "id2": "9846843", "code1": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 0, "substitutes": {"createKeyStore": ["getkeyStore", "getKeystore", "createkeystore", "createSecretChain", "createTrustStore", "createKeystore", "createTrustFactory", "getkeystore", "createSecretstore", "createkeyFactory", "getKeyFactory", "createTruststore", "createSecretFactory", "getkeyFactory", "getKeyChain", "createkeyChain", "createTrustChain", "getKeyStore", "createKeyFactory", "getkeyChain", "createSecretStore", "createkeyStore", "createKeyChain"], "url": ["resource", "entry", "plus", "class", "stream", "ob", "zip", "string", "host", "http", "xml", "str", "proxy", "service", "www", "URL", "log", "path", "ll", "api", "manager", "feed", "org", "text", "key", "gl", "Url", "email", "client", "address", "loc", "store", "l", "connection", "base", "server", "location", "coll", "config", "loader", "sl", "f", " URL", "filename", "image", "lib", "el", "page", "ssl", "html", "data", "id", "uri", "source", "buffer", "src", "db", "file", "ref"], "password": ["pass", "attribute", "token", "username", "words", "seed", "sword", "fax", "string", "channel", "word", "secret", "language", "Password", "PASS", "wallet", "path", "params", "api", "patch", "key", " passwords", "auth", "pad", "wd", "address", "p", "prefix", "phrase", "work", "help", "array", "hash", "data", "press", "pattern", "crypt", "alias", "column", "name", "padding"], "keystore": ["keyserver", " keyserver", "lockstore", "keytool", " keybase", "truststorage", "Keybase", " keytool", "keybase", "truststore", "Keystore", "lockbase", " keyStore", "signstorage", "kcache", "kstore", "Keystorage", "keystorage", "webserver", " keystorage", " keycache", "Keytool", "signtool", "lockstorage", "keycache", "kbase", "KeyStore", "webstore", "keyStore", "signbase", "trustspace", "Keycache", "trustbase", "keyspace", "webstorage", "kserver", " keyspace", "signstore", "Keyserver", "kStore", "lockspace", "webStore"]}}
{"id1": "659316", "id2": "2511579", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"argv": ["paramv", "Argf", "argb", "argver", "argsc", "argumentve", " argV", "ArgV", "argumentc", "argl", "argc", " argf", "interc", "Argve", "argve", " argc", " argl", "argV", "argsf", "Argver", "Argv", " argver", " argb", "interV", "paramV", "Argb", "paramb", "argumentver", "argumentv", "Argc", "interl", "paraml", "argsl", "argf", "Argl", "argsv", "interv", " argve"], "sources": ["psides", "sides", "vesores", " sors", "statences", "sores", "tides", "vesigs", "issors", "issources", "sors", "sresources", "sences", "tource", "statores", "fource", "vesources", "issides", "sesources", "psource", "psources", "issource", "tources", "fources", "psresources", "sesigs", "sesences", "sigs", "tresources", "vesences", "fresources", "statources", "fors", " sides", "sesores", "fides", "statigs"], "targets": ["taxes", "taxets", "tanget", " tokets", "Tanglets", "Targels", " taxes", "tangets", "taxels", " toket", "targends", "targes", "Targlets", "Targens", "tampels", "tiges", "targels", "tagnet", "tanglets", "tampets", "taxens", "tanges", " taxens", "tangels", "tigens", "toket", "tokencies", "targens", " tokencies", "Tangels", " targes", "tokets", " taxets", " tokens", "tigets", "tigends", " targends", "tokens", " taxends", "tamplets", "tagnencies", "tangends", "tangencies", " targens", "tagnens", "taxlets", "targlets", "Targets", "tampens", "taxends", "Tangens", " targencies", "targencies", "tagnets", "Tangets", "tangens"], "srclen": [" srcloen", "srploen", "rsceln", "srselens", "srclens", " srploen", "rscelen", " srclength", "srClEN", "srcln", "srctength", "srcteno", "srseln", "srclEN", "rsclEN", "rscln", "rscelens", "srCLeno", "srceln", "srcloen", " srcleno", "rscelEN", "srCln", "srClens", " srplen", "srclength", "srplength", "srcleno", " srpleno", "srCLoen", "srselEN", "srClen", "srpleno", "srcelen", "srcelens", "rsclens", " srplength", "rsclen", "srcten", "srctoen", "srplen", "srselen", "srCLen", "srcelEN", "srCLength"], "source": ["resource", "use", "seed", "channel", "current", "cache", "Source", "view", "proxy", "service", "scope", "input", "copy", "ource", "self", "path", "slice", "force", "driver", "dest", "in", "client", "unit", "single", "s", "rc", "out", "event", "model", "url", "get", "component", "config", "size", "sl", "link", "image", "start", "SOURCE", "remote", "ssl", "reader", "secure", "type", "ources", "id", "parent", "stream", "uri", "src", "create"], "tgt": ["tnt", "tgz", " tgz", " targ", "ptgt", "lnt", "targ", " tnt", "hgt", "bitgt", "tgs", "tch", "lret", " tbuster", " tkt", "biticket", "tret", "ticket", "tbuster", "Ticket", "lbuster", " tch", " ticket", "Tgs", "bitgh", "hret", "hgz", "tkt", "ptbuster", "rch", "hnt", "rkt", "tgh", "Tgh", "bitarg", "rgs", "lgt", " tret", "Tch", "Tgt", "rgt", " tgs", "lgz", "larg", "Tkt", " tgh", "ptarg", "ptnt", "Targ"], "target": ["resource", "slave", "route", "external", "cross", "project", "channel", "current", "view", "service", "master", "path", "manager", "io", "open", "match", "force", "tail", "driver", "dest", "arget", "download", "conn", "object", "child", "archive", "unit", "handler", "it", "rel", "goal", "connection", "base", "out", "event", "port", "url", "component", "session", "director", "image", "Target", "to", "result", "member", "next", "output", "nt", "remote", "point", "mount", "null", "plugin", "parent", "client", "core"], "deletes": ["kesleted", "degrades", " dedates", "desletes", "deists", "delletes", "deles", "downgrades", "exdates", "disists", "deises", "kesouts", "deleted", "exgrades", "desires", "desles", "Deires", " deouts", "disles", " delete", "desists", "delises", "exletes", "delouts", "kesises", "deires", "delete", "deouts", "exlete", "Deles", "kesletes", "Deletes", " degrades", "disletes", "dedates", "Deists", " deises", "delleted", "downletes", "downlete", "disires", "downdates", " deleted"], "del": ["pull", "local", "Delete", "clean", "d", "dl", "remove", "copy", "delay", "down", "ll", "add", "skip", "download", "dir", "def", " delete", "err", "rel", "bl", "up", "base", "fail", "install", "model", "coll", "delete", "get", "syn", "nl", "ul", "el", " Del", "diff", "se", "data", "change", "fl", "null", "de", "id", "update", "sel", "neg", "lock", "name", "file", "Del", "dec"]}}
{"id1": "18451704", "id2": "9479502", "code1": "    public boolean isValidPage(BookPage page) {\n        boolean isValid = false;\n        try {\n            if (page.getType() == BookPage.TYPE_RESOURCE) {\n                BookPagePreviewPanel panel = new BookPagePreviewPanel(dControl, true);\n                panel.setCurrentBookPage(page);\n                isValid = !page.getUri().equals(\"\") && panel.isValid();\n            } else if (page.getType() == BookPage.TYPE_URL) {\n                URL url = new URL(page.getUri());\n                url.openStream().close();\n                isValid = true;\n            } else if (page.getType() == BookPage.TYPE_IMAGE) {\n                if (page.getUri().length() > 0) isValid = true;\n            }\n        } catch (Exception e) {\n            isValid = false;\n        }\n        return isValid;\n    }\n", "code2": "    private File unpackZIP(URL url, String dirName) {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof JarURLConnection) {\n                File destDir = new File(getExtensionsDirectory() + EGEConstants.fS + dirName);\n                destDir.mkdirs();\n                EGEIOUtils.unzipFile(((JarURLConnection) connection).getJarFile(), destDir);\n                return destDir;\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Could not unzip jar file.\", e);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"isValidPage": ["IsValidContent", "isAvailableBook", "isAvailablepage", "isLegalBook", "isAvailablePage", "IsInvalidPage", "IsInvalidpage", "isAvailableContent", "isLegalpage", "isLegalPage", "isValidpage", "isInvalidpage", "IsValidBook", "IsValidPage", "isLegalContent", "IsValidpage", "isInvalidBook", "isValidBook", "isValidContent", "isInvalidPage", "isInvalidContent", "IsInvalidBook", "IsInvalidContent"], "page": ["resource", "route", "current", "view", "http", "pl", "manager", "book", "p", "image", "html", "filter", "next", "parent", "version", "file", "pages", "player", "cache", "pb", "request", "comment", "facebook", "about", "this", "user", "profile", "pe", "model", "office", "admin", "button", "data", "module", "message", "block", "class", "section", "project", "instance", "channel", "pg", "xml", "language", "www", "display", "content", "frame", "document", "f", "home", "type", "menu", "account", "client", "chart", "name", "site", "wiki", "title", "platform", "object", "child", "app", "base", "server", "config", "settings", "Page", "article", "e", "result", "change", "plugin"], "panel": ["pan", "group", "row", "window", "paper", "player", "map", "channel", "table", "view", "board", "area", "tool", "circle", "wall", "screen", "label", "list", "conference", "square", "book", "browser", " Panel", "frame", "part", "layout", "coll", "server", "settings", "bean", "pal", "bar", "tab", "journal", "el", "plan", "widget", "button", "filter", "Panel", "menu", "data", "plugin", "info", "flower", "plane", "chart", "block"], "isValid": ["itvalid", "hasvalid", " isOpen", "isActive", "osVal", "ISValid", " isInvalid", " isVal", "osValid", "ISvalid", "osvalid", "asActive", "asValid", "isOk", "isaValid", " isLegal", "isaActive", "IsValid", " isOk", "itValid", " isvalid", "ISVal", "sValid", "hasInvalid", "isvalid", "idLegal", "hasValid", "IsLegal", "isInvalid", "ISInvalid", "isaInvalid", "itInvalid", "isOpen", "sInvalid", "IsInvalid", " isActive", "isLegal", "Isvalid", "svalid", "hasLegal", "asOpen", "ISLegal", "idValid", "idvalid", "sLegal", "isVal", "asOk", "osInvalid", "asInvalid", "asLegal", "asvalid", "isaOpen", "idOk"], "url": ["resource", "large", "album", "blog", "channel", "string", "http", "www", "URL", "path", "layer", "open", "feed", "Url", "user", "object", "address", "bel", "browser", "l", "connection", "base", "server", "location", "plug", "sl", "f", "control", "image", "ssl", "follow", "fl", "ball", "r", "b", "web", "uri", "stream", "source", "file"]}}
{"id1": "23273706", "id2": "411595", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectDocumentMeta", "getProjectTreeInfo", "getProjecttreeData", "getprojecttreeInfo", "getprojecttreeDATA", "getProjectPageData", "getprojectTreeData", "getProjecttreeDATA", "getProjectTreeDATA", "getProjecttreeInfo", "getProjecttreeMeta", "getprojectTreeDATA", "getProjectPageInfo", "getprojectTreeMeta", "getprojecttreeData", "getprojecttreeMeta", "getProjectTreeMeta", "getProjectDocumentData", "getprojectTreeInfo", "getProjectPageMeta", "getProjectDocumentInfo", "getProjectPageDATA", "getProjectDocumentDATA"], "treeData": ["treeDec", "reeArray", "bodyDat", "TreeInfo", " treeText", "treeString", "reeString", "storyData", "monkeyArray", "bodyList", "storyDec", "reeData", "contentDat", "treeText", "TreeArray", " treeDec", "treeList", "contentInfo", "storyArray", "TreeData", " treeArray", "bodyData", " treeString", "reeText", "bodyString", "treeInfo", " treeList", "reeInfo", " treeInfo", "reeDat", "contentText", " treeDat", "monkeyDat", "TreeString", "treeDat", "storyDat", "monkeyDec", "monkeyData", "treeArray", "TreeList", "reeList", "contentData"], "filename": ["folder", "txt", "username", "SourceFile", "string", "jpg", "kj", "xml", "title", "Filename", "path", "kn", "fd", "fil", "sheet", "whatever", "files", "database", "ppa", "framework", "fn", "prefix", "tmp", "upload", "url", "location", "dylib", "FILE", "dll", "password", "journal", "figure", "fp", "ername", "directory", "nil", "data", "wav", "metadata", "kl", "uri", "name", "file"], "urlString": ["URLstring", "addressStr", "URLUrl", "locationUrl", "locationString", "urlStr", "addressURL", "addressString", " urlURL", "locationStr", "URLStr", "addressstring", "URLString", " urlstring", "URLURL", "urlUrl", " urlStr", "locationstring", " urlUrl", "urlstring", "urlURL"], "urldata": ["urlddata", "URldata", "URlfdata", " urLDATA", "URldATA", "urLDdata", "urlfdata", "urlledta", "urlledata", "urldATA", "urledata", "urlfat", "urLDta", "urleddata", "urLDat", "urlleddata", "urlfATA", "urlldata", "urledATA", "urlfata", " urLDta", " urlddata", "URlfat", "urLDATA", "URldat", "urLData", " urldta", "urldat", "URlddata", " urldATA", "urllATA", " urLData", "urlledATA", "URlfata", " urLDdata", "urllat", "URlfATA", "urldta", "urledta", "urllata"], "factory": [" flier", "ufictionary", "confFactory", "cFactory", "fault", "cfFactory", "fFactory", " filler", "cfiller", "liller", "lactory", "ufiller", "confiller", "filler", "cflier", "luild", "pault", " fault", "cactory", "flier", "pFactory", "fictionary", "ufactory", "lictionary", " fuild", "cfactory", " fictionary", " fFactory", "ufuild", "cault", "ciller", "pactory", "conflier", "fuild", "confactory", "piller"], "parser": ["root", "ger", "pdf", "library", "string", "instance", "jack", "xml", "http", "utils", "raf", "manager", "api", "util", "monkey", "driver", "json", "er", "handler", "p", "up", "l", "ph", "s", "Parser", "loader", "fruit", "lp", "auto", "arser", "writer", "reader", "se", "parse", "r", "b", "plugin", "t", "parent", "uri", "builder"], "u": ["iu", "eu", " ur", "us", "uu", "c", "ru", "o", "http", "universal", "d", "U", "ur", "io", "util", "yu", "ui", "uv", "cu", "p", "l", "s", "plug", "url", "su", "uf", "ul", "hu", "ou", "tu", "b", "uri", "nu", "uni", "lu"], "is": ["ib", "or", "us", "isa", "ip", "ios", "serv", "ob", "isl", "pi", "ir", "http", "iris", "has", "as", "gets", "io", "api", "ais", "IS", "abs", "ui", "in", "ri", "are", "ie", "p", "fs", "it", "obs", "init", "s", "Is", "iso", "iss", "ar", "ops", "its", "ori", "mis", "bis", "lis", "isu", "ai", "es", "info", "uri", "ris"], "os": ["or", "us", "ms", "ol", "ios", "so", "bs", "ens", "ob", "osi", "o", "dos", "opens", "http", "oa", "fits", "oss", "as", "gets", "io", "sys", "aos", "bos", "oes", "oos", "fs", "ose", "obs", "s", "pos", "los", "iso", "ops", "cos", "Os", "oses", "ros", "bis", "ils", "ps", "es", "OS"], "iBufSize": ["iBytebufSize", "iLlfSt", "iLlfsize", "iBytebufsize", "iBytebufLength", "iBlfLen", "iBlfLength", "iByteufSize", "iBufferLength", "iBytebufLen", "iBufferSt", "iLlfLength", "iBufLen", "iByteufLen", "iLufSize", "iByteufLength", "iBufsize", "iBbufSize", "iBlfSt", "iLlfSize", "iBbufLen", "iBuffLength", "iBlfSize", "iBuffSt", "iBuffsize", "iBufSt", "iBufferSize", "iBuffersize", "iBbufLength", "iByteufsize", "iBlfsize", "iBufLength", "iLufsize", "iLufSt", "iBbufsize", "iLufLength", "iBuffLen", "iBuffSize"], "inBuf": ["outBuffbuf", "inBbuf", "inCuff", "outBuffub", "outBub", "outBuffuf", "inBlump", "inFbuf", "inBuffump", "inBunk", "inFaf", "inDbuf", "inBuff", "inCbuf", "inbuf", "inCunk", "inPlunk", " inBump", "inCump", "inDuf", "inBump", " inCbuf", "inFuff", " inBunk", " inFaf", "inPlbuf", "inBluf", " inFuff", "outBump", " inBaf", " inBbuf", "inBlbuf", "inBuffuf", "inbub", "inPluf", "inCuf", "inFuf", "inDuff", "inBub", "inBuffbuf", "inPlump", " inCunk", "inbump", "inBlub", "outBuffump", "inDaf", " inCuf", " inBuff", "outBuf", "inCaf", "inBlunk", " inFbuf", "inBuffub", "outBbuf", "inBaf", "inbbuf", " inCump", " inFuf"], "iNumRead": ["iValBuild", "iChanBuild", "pNumWritten", "iChanRead", "pNumread", "qiNumBuild", "qiValBuild", "iFatWritten", "iNumberBuild", "qiNumRead", "inumWritten", "inumRead", "qiNumREAD", "pNumberRead", "pNumberWritten", "iNumberREAD", " iFatWrite", "pNumWrite", "iNumberWrite", "iLenWritten", "iNumread", "qiValread", "inumread", "iLenRead", "iChanread", "iNumberWritten", "iFatRead", " iFatWritten", "inumWrite", "iNumWritten", "pNumberread", "iNumberRead", "iValread", " iNumWrite", "iChanREAD", "qiNumread", "iNumBuild", "pNumRead", "iLenWrite", "iNumWrite", "qiValREAD", "pNumberWrite", " iFatRead", "iValRead", "iNumREAD", "qiValRead", " iNumWritten", "iFatWrite", "iValREAD", "iNumberread"], "f": ["fa", "df", "fe", "fr", "F", "fc", "full", "g", "c", "n", "m", "o", "sf", "d", "fd", "io", "feed", "fn", "handler", "p", "fs", "l", "ff", "s", "j", "fi", "e", "uf", "h", "fp", "v", "r", "b", "t", "file", "rf"], "inputstream": ["outputchannel", "inputsystem", "inputsw", " inputStream", "inputStream", "contentsw", "outputStream", "Inputsystem", "Inputchannel", "contentstream", "Inputstream", " inputchannel", "contentStream", " inputsw", "InputStream", "contentsystem", "outputstream", " inputsystem", "Inputsw", "inputchannel"], "document": ["window", "media", "container", "project", "n", "m", "context", "xml", "d", "language", "node", "response", "list", "tree", "doc", "Document", "content", " documents", "object", "p", "l", "Documents", " documentation", "office", "e", "director", "dom", "record", "page", "html", "output", "DOM", "data", "directory", "docs", "ocument", "null", "t", "info", "source", "parent", "collection", "file"], "nodelist": ["Nodemark", "NODestyle", "nonedette", " nodeselist", "nodeestate", "Nodestyle", "nonedename", " nodesename", "nozelist", "snodselist", "anodedelist", "anodedestate", "anodedeme", "nODeline", "nozels", "anodata", "nozemark", "nodesh", "nODestyle", "nodeeme", "nodeata", " nodename", "anodeme", "nODesh", "nodedestyle", "nodename", "nodeelist", "nondeme", "nodesels", "snodeline", "anodedata", "nodeline", "nondelist", "Nodesh", "nodeme", "nondestate", "nodedata", "Nodelist", "nodata", " nodesels", "nonedels", "nodedlist", "snodelist", " nodels", "nodedeline", "NODelist", "nodlist", "nodsette", "nonedelist", "nozestyle", "nozename", "nodestate", "nODemark", "nozette", "nodselist", "nODette", "nODlist", "nodeselist", "anodestate", "snodette", "nODelist", "NODemark", "nodedeme", " nodette", "nodels", "nodestyle", "snodsette", "snodlist", "anodelist", "nodette", "nodseline", "nondata", "nozesh", "nodedelist", "nodesename", " nodesette", "snodslist", "snodseline", "nodedesh", "nodedette", "nodedemark", "nodedestate", "NODesh", "nodemark", "nodslist", "nodesette"], "num": ["span", "temp", "nb", "multi", "n", "zero", "m", "col", "um", "total", "mult", "node", "sum", "con", "np", "norm", "number", "NUM", "div", "umi", "nr", "mu", "count", "unit", "Num", "loc", "om", "comb", "part", "net", "init", "pos", "max", "index", "len", "ul", "nom", "lim", "dom", "tri", "mon", "en", "nam", "inc", "nu", "uri", "dim", "uni"], "i": ["iu", "hi", "si", "qi", "chi", "ip", "multi", "g", "ii", "ini", "c", "pi", "col", "o", "y", "m", "d", "ci", "di", "io", "slice", "ji", "ui", "in", "ri", "bi", "ie", "p", "it", "l", "part", "phi", "j", "I", "eni", "fi", "x", "index", "cli", "isi", "oi", "li", "ori", "a", "start", "v", "gi", "ti", "mi", "ai", "yi", "b", "xi", "id", "info", "uri", "iv", "ix", "mu", "ik"]}}
{"id1": "20675046", "id2": "339517", "code1": "    public Object getContent(ContentProducerContext context, String ctxAttrName, Object ctxAttrValue) {\n        try {\n            URL url = (getURL() != null) ? new URL(getURL().toExternalForm()) : new URL(((URL) ctxAttrValue).toExternalForm());\n            InputStream reader = url.openStream();\n            int available = reader.available();\n            byte contents[] = new byte[available];\n            reader.read(contents, 0, available);\n            reader.close();\n            return new String(contents);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return ex.toString();\n        }\n    }\n", "code2": "    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n        URL url = getClass().getResource(name);\n        InputStream in = url.openStream();\n        try {\n            return ClassFile.read(in);\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["createContents", "newContent", "newResource", "getResource", "newcontent", "getcontent", "getContents", "loadcontent", "loadContents", "createContent", "createResource", "createcontent", "loadResource", "loadContent", "newContents"], "context": ["resource", "temp", "class", "instance", "Context", "channel", "path", "ctx", "manager", "this", "content", "object", "proc", "document", "connection", "consumer", "event", "component", "config", "bc", "processor", "comp", "tx", "writer", "data", "stream", "text", "name"], "ctxAttrName": ["ctxAttrsKey", "ctxAttributePath", "ctxAttributeKey", "ctxAddrPath", "ctxAddrName", "ctxAddributePath", "ctxAttributeValue", "ctxAttrsPath", "ctxAddrKey", "ctxAddributeValue", "ctxAttrsValue", "ctxAttribKey", "ctxAttribValue", "ctxAddributeName", "ctxAddrValue", "ctxAttribPath", "ctxAttribName", "ctxAttrKey", "ctxAttrsName", "ctxAttributeName", "ctxAttrPath", "ctxAddributeKey"], "ctxAttrValue": ["ctxAttratorvalue", "ctxAttorVALUE", "ctxAttbVal", "ctxAttbvalue", "ctxAttributeKey", "ctxAttrivalue", "ctxAttributeriVALUE", "ctxAttributeValue", "ctxAttributerVALUE", "ctxAttratorValue", "ctxAttriName", "ctxAttributeriValue", "ctxAddributevalue", "ctxAttributevalue", "ctxAddrKey", "ctxAddributeValue", "ctxAttriVALUE", "ctxAttorName", "ctxAddrvalue", "ctxAttmValue", "ctxAddributeVal", "ctxAttributerivalue", "ctxAttbValue", "ctxAttributervalue", "ctxAttrVALUE", "ctxAttbKey", "ctxAttriValue", "ctxAddrValue", "ctxAttributeriName", "ctxAttributerValue", "ctxAttmvalue", "ctxAttorvalue", "ctxAttorValue", "ctxAttratorName", "ctxAttmKey", "ctxAttrVal", "ctxAttributeVal", "ctxAttrKey", "ctxAttributerName", "ctxAddrVal", "ctxAttrvalue", "ctxAttratorVALUE", "ctxAttmVal", "ctxAddributeKey"], "url": ["resource", "entry", "string", "channel", "blog", "host", "http", "service", "ler", "www", "URL", "path", "ur", "api", "feed", "io", "Url", "object", "user", "address", "build", "lr", "browser", "l", "connection", "base", "server", "location", "loader", "sl", "per", "image", "writer", "ssl", "bb", "uri", "stream", "source", "buffer", "org", "file"], "reader": ["resource", "entry", " Reader", "reading", "http", "oder", "ler", "ender", "input", "layer", "io", "feed", "driver", "in", "ri", "keeper", "er", "handler", "iterator", "browser", "bird", "l", "connection", "rc", "server", "loader", "read", "Reader", "per", "f", "iter", "rer", "worker", "tx", "editor", "writer", "result", "data", "rr", "r", "rx", "parser", "rar", "buffer", "stream", "uri", "source", "builder"], "available": ["ready", "allowed", "resource", "enough", "bound", "created", "able", "existing", "closed", "external", "position", "full", "readable", "availability", "current", "instance", "published", "capacity", "channel", "total", "visible", "input", "open", "empty", "supported", "active", "length", "opened", "content", "quality", "good", "missing", "valid", "enabled", "default", "running", "all", "release", "selected", "array", "accessible", "used", "free", "memory", "unsigned", "next", "error", "found", "null", "connected", "Available", "buffer", "version", "loaded"], "contents": ["explents", " contings", "extences", "extings", " contures", "contContents", "containingensions", "loadences", " contences", "contures", "CONTent", "explens", "contapes", "containingent", "explent", "loadContents", "content", "loadents", "intent", "extContents", "CONTures", "contens", " content", "contensions", "sequent", "intapes", "sequensions", "explures", "sequapes", "containingents", "intensions", "loadings", "containingapes", "contences", " contens", "CONTens", " contContents", "CONTents", "intents", "contings", "extents", "sequents"]}}
{"id1": "22366505", "id2": "10436471", "code1": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "code2": "    @Override\n    public Cal3dModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        Cal3dModel model = new Cal3dModel(getFlags());\n        loadCal3dModel(getBaseURL(), url.toExternalForm(), new InputStreamReader(url.openStream()), model);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "label": 0, "substitutes": {"incluir": ["inCLuire", "inclituir", "inclurir", "inCLuear", "incluriro", "inclUear", "inCLuiro", "inclituire", "inCLUiro", "inclituear", "inclUir", "inCLUear", "inclurire", "inclituiro", "inCLUire", "incluiro", "incluire", "inCLUir", "inclUire", "inCLuir", "incluear", "inclUiro", "inclurear"], "igreja": ["igr\u00e9je", "ligrej", "igruji", " igrej", "igrujas", " iggrej", "ligr\u00e9j", "ligrejas", "igruza", " igreraji", "igcreji", "igruj", "ligreja", "iggreza", "iggreje", "igruja", "igr\u00e9j", " igreji", "igereJa", "iggreja", "igr\u00e9jas", "igrej", "igruya", "igrejas", " igreraza", "igcrej", "ligreje", "ligr\u00e9je", "igreji", "igerej", "igreJa", "igreza", "iggrej", "igreraza", " igreza", " igreraja", " iggreja", " iggreji", "iggrejas", "ligr\u00e9jas", "ligr\u00e9ja", "igcreja", "iggreJa", "igereja", "igreraji", "igruje", "igreje", "igcreJa", " iggreJa", "igereji", "igr\u00e9ja", "igreraja", "igreraya", " igreraya", " igreya", "igreya", " igreJa", "iggreya", "iggreji"], "connection": ["application", "section", " Connection", "function", "position", "description", "c", "Connection", "cache", "statement", "context", "table", "environment", "union", "option", "condition", "ion", "ctx", "con", "manager", "BC", "engine", "cf", "database", "relation", "client", "conn", "loc", "cc", "document", "event", "communication", "server", "query", "system", "config", "bc", "index", "pool", "machine", "session", "graph", "socket", "directory", "error", "connected", "lock", "connect", "collection", "db", "core"], "sql": ["section", "seed", "function", "string", "join", "statement", "spec", "select", "eps", "dl", "log", "params", "sol", "sys", "sync", "database", "printf", "conn", "seq", "fn", "s", "csv", "setup", "ls", "query", "url", "sl", "sb", "session", "nl", "filename", "socket", "stat", "ssl", "term", "null", "ql", "id", "SQL", "ln", "db", "sq"], "sql2": ["sqlII", " sqlII", "ssl02", "sql1", "url1", "qlII", "sql02", "ssl2", " sql02", "sqltwo", "ql02", "ql2", "urltwo", "sslII", " sqltwo", "ql1", " sql1", "ssl1", "qltwo", "url2"], "stmt": ["stmd", "stst", "ostmr", "tpt", "STmt", "tmr", "stm", "strmt", "sth", "strh", " stmb", "stql", "STmb", "Stmb", "frmn", "istmt", " stpt", "strdb", " stdb", "stpt", "Stmt", "frmt", "Stql", " sttr", "istconn", "ostmt", "fmt", "frtr", " stmn", "fh", "Stmd", "strmd", " stconn", "Stmn", "tmt", "Stst", "stmr", "frconn", "STmd", "fmd", "ostmn", " stst", "stmb", "Stpt", " stmd", "STst", "fdb", "stconn", " sth", "ostmd", "Stm", "istmn", "stmn", " stmr", " stql", "ostql", " stm", "tm", "sttr", "stdb", "Stmr", "isttr"], "stmt2": ["stmr02", "stmp02", "stmn2", "stbm02", "stbm1", " stmp4", " stmrTwo", " stmp3", "stmr2", "stmn4", " stmr02", " stmt3", "stmnTwo", "stmd4", "stmdTwo", " stmr2", "stmt4", "stmtTwo", "ctmtTwo", " stmr1", " stmp1", "stmr3", "stmt02", "stmd1", " stmp2", "stmd3", "stmp2", "stmd2", " stmt1", "stmrTwo", "ctmp1", "stmp4", "stmr4", "stm2", "ctmt1", "stbm2", "stm1", "stmp1", " stmtTwo", "stmn1", " stmt02", "stm4", "ctmp2", "stmt1", " stmpTwo", "ctmpTwo", "stmr1", "stbmTwo", "stmpTwo", "ctmt2", "stmt3", " stmt4", "stmp3"], "rs": ["rss", "hs", "ks", "row", "ms", "ys", "pr", "results", "errors", "Rs", "gs", "relations", "params", "sr", "details", "rys", "ins", "mr", "conn", "xs", "cr", "s", "qs", "rc", "ls", "ars", "cs", "vers", "ds", "ros", "eers", "res", "ts", "ss", "rr", "RS", "r", "ps", "rates", "ras", "rd", "runs", "ris", "ows", "rows"], "retorno": ["retorn", "retago", "resporno", " retago", "retro", "Retro", "Retorn", "ntorn", "ntorno", "respro", " retour", "respago", "resporn", "Retour", " retorn", "ntro", " retro", "ntour", "Retago", "retour", "Retorno"]}}
{"id1": "12055086", "id2": "411595", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copyDeleing", " copyDeleteting", " copydeleter", " copyDequeting", " copyDeleteging", " copyDeleteter", " copyDeletter", " copydeleting", " copyDequeing", " copyDequeter", " copyDeletting", " copydeletting", " copydeleging", " copyDeleter", " copydeletging", " copyDeleteing", " copyDequeging", " copyDeletging", " copydeletter", " copyDeleging", " copydeleing"], "source": ["resource", "route", "use", "cache", "Source", "view", "inner", "service", "input", "copy", "ource", "down", "path", "from", "archive", "ie", "connection", "base", "s", "storage", "config", "f", "iter", "e", "i", "image", "SOURCE", "sin", "remote", "reader", "ources", "target", "stream", "master", "src", "site", "file"], "dest": ["folder", "pipe", "temp", "done", "slave", "class", "exit", "opt", "dist", "bin", "master", "destroy", "desc", "path", "die", "slice", "content", "dir", "comb", "default", "trans", "orig", "destruct", "tmp", "thin", "flat", "home", "Dest", "result", "img", "target", " destination", "de", "null", "wb", "src", "later", "file"], "buf": ["txt", "bh", "vec", "append", "cv", "ctx", "bd", "feed", "queue", "pad", "length", "seq", "bp", "loc", "batch", "br", "bag", "ff", "base", "pos", "rc", "cp", "cmd", "port", "tmp", "config", "bc", "Buffer", "code", "len", "off", "uf", "uc", "bytes", "cb", "result", "img", "data", "raw", "feat", "b", "bf", "buff", "fb", "buffer", "src", "rb"], "in": ["In", "plus", "stream", "again", "n", "c", "ini", "IN", "is", "din", "inner", "bin", "input", "con", "io", "pin", "ins", "min", "conn", "inn", "p", "up", "isin", "init", "win", "rin", "exec", "url", "gin", "read", "thin", "f", "inside", "i", "nin", "image", "socket", "sin", "login", "file", "reader", "data", "b", "inc", "id", "tin", "src"], "out": ["again", "at", "n", "o", "ex", "exp", "inner", "bin", "Out", "outer", "down", "io", "outs", "sync", "conn", "err", "up", "app", "part", "w", "win", "exec", "f", "pool", "i", "image", "lib", "socket", "writer", "ext", "img", "output", "obj", "OUT", "b", "inc", "parent", "buffer", "client", "file"], "count": ["ch", "use", "n", "c", "cache", "current", "zip", "depth", "limit", "sum", "path", "feed", "Count", "number", "key", "num", "length", "child", "weight", "part", "base", "all", "cond", "coll", "max", "size", "read", "index", "f", "pool", "code", "len", "allow", "ind", "start", "close", "val", "handle", "type", "b", "id", "lock", "offset", "parent", "buffer", "name"]}}
{"id1": "2668634", "id2": "11933797", "code1": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"inputName": ["inputAddress", "inputFile", " inputAddress", "imageAddress", " inputFile", "outputFile", "InputName", "InputAddress", "inputUrl", " inputUrl", " inputPath", "InputPath", "outputPath", "imageFile", " inputname", "imageName", "inputname", "InputFile", "inputPath", "Inputname", "imagename", "InputUrl", "outputUrl"], "outputName": ["inputFile", "applicationFile", "outputFile", "OutputFile", "outputname", "outputPath", "OutputDir", "applicationDir", "applicationPath", "inputPath", " outputDir", "inputDir", "outputDir", " outputFile", "OutputPath", "applicationname", "OutputName", "applicationName", "Outputname", " outputname"], "stripLoggers": ["stripLogters", "striploggers", "stripDebugging", " stripLogters", " striplogger", "stripDebugters", "stripColger", "striplogger", " striploggers", "stripColters", "striplogging", " stripLogging", " stripLogger", "stripLogger", "stripColgers", "stripColging", "stripDebugger", "striplogters", " striplogging", " striplogters", "stripDebuggers", "stripLogging"], "tempFile": [" tempStream", " temporaryFile", "tempFiles", "inputFile", "TempDir", "poraryfile", "tempStream", "tmpPage", "tmpFile", "TempMessage", "TempFiles", " tempPage", "tmpFiles", " temporaryfile", " tempFiles", " tempMessage", "poraryFile", "TempStream", "tempMessage", "Tempfile", "inputDir", "tempPage", "inputfile", "tmpfile", "TempFile", "tempfile", "tmpDir", "inputPage", " tempDir", " temporaryFiles", " tempfile", "tempDir", " temporaryStream", "poraryFiles", "poraryMessage"], "jin": ["NJ", "unin", " Jin", "Intern", "ini", "zip", "john", "zin", "cin", "jack", "lu", "din", "zn", "bin", "sin", "raf", "hin", "Kit", "inx", "fil", "util", "pillar", "nir", "pin", "jen", "in", "Mu", "zik", "kin", "rin", "lin", "gin", "cos", "Mos", "thin", "cli", "su", "jing", "nin", "Ru", "Js", "ja", "ni", "lib", "NI", "hn", "jun", "arin", "rio", "jan", "icer", "vin", "fen", "jp", "plugin", "spin", "zon", "sit", "tin", "nu", "irin", "ln", "Skin", "jl", "skin"], "jout": ["Jouter", "nOUT", " jarray", "jetOut", " jOUT", "jetout", "jarray", "nout", "ujouter", "jouter", "Jout", "nOut", "ujOut", "jOut", " jOut", "ujout", "JOut", " jouter", "narray", "jetarray", "jOUT", "jetOUT"], "srcChannel": [" srcCh", "rcchannel", "sourceCh", "rcChannel", "srcChan", "sourceChannel", " srcChan", "sourcechannel", "srcchannel", " srcchannel", "srcCh", "rcCh", "sourceChan", "rcChan"], "dstChannel": ["ddestchannel", " ddestchannel", "dstCh", "dndCh", "dspChannel", "ddestCh", "dspchannel", "dspChan", "dndChannel", "ddestChan", " ddestChan", " dstCh", " dstchannel", "dndchannel", "ddestChannel", "dstChan", "dstchannel", "dndChan", " ddestCh", " ddestChannel", "dspCh", " dstChan"], "portletApplicationName": ["portletPlatformCode", "portalApplicationUrl", "portletsApplicationName", "portletsAppPath", "portletApplicationCode", "portletsApplicationInfo", "portalPlatformUrl", "portletAppType", "portletPlatformType", "portalApplicationType", "portletApplicationPath", "portalApplicationPath", "portletAppUrl", "portletApplicationsPath", "portletapplicationType", "portletApplicationsName", "portletPlatformInfo", "portletPlatformPath", "portletApplicationsCode", "portletAppInfo", "portalPlatformType", "portletapplicationPath", "portletapplicationUrl", "portletsAppName", "portletAppPath", "portletAppName", "portletApplicationsInfo", "portalPlatformName", "portletsAppInfo", "portalPlatformPath", "portletApplicationUrl", "portletApplicationInfo", "portletApplicationType", "portletapplicationName", "portletsApplicationPath", "portletPlatformUrl", "portletsAppCode", "portletsApplicationCode", "portletAppCode", "portalApplicationName", "portletPlatformName"], "webXml": ["webClass", "contextXli", "webWorkML", "contextXML", "WebXpl", "webWorkxml", " webXMml", "webXaml", "contextXlass", "webXli", "contextCrossul", "webxlass", "webEcML", "contextCrossML", "webWorkli", "webWorkml", "WebXMml", "webXul", "webXMML", "webCml", "webEcpl", "webCrossli", "contextCrossml", "webHpl", "webWorkul", "webXMiel", "webXMxml", "WebXMiel", "contextXul", "webXMml", "webXxml", " webXaml", "webxaml", "webHml", "webWorkaml", " webXMML", "webCrossML", "webxML", "webEcml", "contextClass", "webHiel", "webHML", " webXML", " webXMaml", "webXlass", "webEciel", "webxxml", "WebXiel", "contextCML", " webXMxml", "WebXML", "webXiel", "webXpl", "contextCxml", "webCrossml", "webCrossul", "webCxml", "webCML", "contextXxml", "webXML", "webXMpl", "WebXMML", "webXMaml", "webxml", "contextCml", "WebXMpl", "WebXml", " webXxml", "contextCrossli"], "portletXml": ["portletSyaml", "portleXml", "portleSyaml", "portletSyml", "portletSyncml", "portletsXmal", "portletXMtml", "portletXMxml", "portletCml", "portleXxml", "portleSyml", "portletsYml", "portletHML", "portletCML", "portletCmos", "portfileHmos", "portletYML", "portletEng", "portfileXml", "portleSytml", "portletSyncaml", "portletEML", "portletxml", "portfileXML", "portletXMml", "portletXMng", "portletxmos", "portletXtml", "portletxML", "portletXng", "portletXmal", "portletEmal", "portletsYmal", "portletXML", "portfileHml", "portfileXxml", "portletSytml", "portletHxml", "portletsXML", "portletHmos", "portletsYML", "portletXMaml", "portletXxml", "portleXtml", "portletYmal", "portletXMML", "portleXaml", "portletSynctml", "portletYml", "portletHml", "portletXaml", "portfileXmos", "portletXMmal", "portletCxml", "portletXmos", "portletsXml", "portfileHML", "portletSyncxml", "portleSyxml", "portletsXng", "portletSyxml", "portfileHxml", "portletxxml", "portletYng", "portletsYng", "portletEml"], "contextXml": ["contextxaml", "contextHaml", "contextXaml", "contextXxml", "contextXML", "contextExml", "contextXMxml", " contextAxl", "contextExl", "contextxml", "contextAxml", "conceptXml", " contextAxla", " contextAxML", "contextAxl", "contextXMwl", "contextXwl", "conceptXaml", "conceptHml", " contextXla", "contextExla", "contextXMml", "conceptHaml", "contextxxml", "contextAxML", "conceptXwl", "contextXla", "contextHml", "contextXl", "contextUl", "contextUla", "contextExML", "contextHxml", "contextUML", "contextAxla", "conceptXxml", "conceptHwl", "conceptHxml", "contextXMaml", "contextUml", " contextXl", " contextXML", "contextxwl", "contextHwl", " contextAxml"], "src": ["resource", "rss", "entry", "bh", "username", "ses", "zip", "rest", "host", "rec", "href", "Source", "spec", "ruby", "http", "dist", "ource", "inst", "lower", "ur", "sc", "cont", "ctx", "slice", "sr", "sync", "dest", "in", "rl", "ri", "lit", "loc", "ie", "rel", "sup", "gb", "s", "rc", "rin", "url", "sn", "cur", "config", "sl", "sb", "comp", "gz", "i", "SOURCE", "socket", "sin", "uc", "result", "ssl", "img", "st", "ser", "secure", "obj", "req", "r", "jar", "sub", "sit", "rs", "uri", "sel", "rb", "prot", "sq"], "source": ["resource", "status", "token", "use", "function", "zip", "string", "resources", "channel", "context", "Source", "view", "xml", "spec", "proxy", "inner", "service", "scope", "input", "ource", "from", "slice", "sr", "text", "driver", "in", "this", "form", "client", "ce", "unit", "handler", "ie", "kin", "connection", "rc", "out", "storage", "url", "get", "sp", "component", "size", "loader", "sl", "thin", "iter", "comp", "e", "wrapper", "session", "i", "SOURCE", "start", "sin", "fp", "result", "file", "reader", "gen", "secure", "ources", "null", "stack", "sit", "stream", "uri", "parent", "reason", "core"], "zipEntries": [" zipEntrys", "zipEnrys", "zipCurlements", "sliceEries", "zipEntry", "ZipEntrys", "zipCurions", "ZipEntlements", "zipEndlines", "zipentions", "zipIntegrations", "zipEntions", "sliceEntry", "zipEntrys", "ZipEntries", "sliceEntresses", "zipentries", "zipEntlements", "zipEndresses", "zipentlements", "zipEnlines", "zipEries", "zipEnry", "zipEndries", "zipEntresses", "zipentrys", "zipEntlines", "zipEnresses", "sliceEntries", "sliceElines", "zipIntegries", "zipEnrations", "zipEnries", "zipCurries", "sliceEry", " zipEntry", "zipEresses", "sliceEresses", "zipCurrys", " zipEntrations", "sliceEntlines", "zipIntegrys", "zipElines", "ZipEntions", "zipIntegry", "zipEntrations", "zipEry", "zipEndry"], "target": ["resource", "wrong", "bh", "route", "class", "external", "project", "string", "current", "host", "href", "context", "site", "method", "scope", "path", "platform", "match", "tail", "dest", "arget", "compatible", "content", "object", "address", "theme", "unit", "loc", "rel", "it", "goal", "tag", "prefix", "location", "component", "config", "flat", "value", "filename", "top", "format", "Target", "remote", "nt", "output", "next", "type", "data", "feat", "style", "hop", "name", "file", "template"], "webRewriter": ["webReporter", "application", "webResrite", " webrewrite", "webrewitcher", "webreworter", " webrewitcher", "http", "Entry", "webRewrite", "webReworter", " webreworter", "this", " webRewitcher", "app", "webrewrite", "webrewriter", "s", "webResriter", " webReworter", "_", "New", "webRepriter", "webReprite", "webResorter", "webRepitcher", "webRewitcher", "webResitcher", " webRewrite", " webrewriter"]}}
{"id1": "13421722", "id2": "23611770", "code1": "    public static long getFileSize(String address) {\n        URL url = null;\n        try {\n            url = new URL(address);\n            System.err.println(\"Indirizzo valido - \" + url.toString().substring(0, 10) + \"...\");\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Indirizzo non valido!\");\n        }\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=0-\");\n            connection.connect();\n            return connection.getContentLength();\n        } catch (IOException ioe) {\n            System.err.println(\"I/O error!\");\n            return 0;\n        }\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 0, "substitutes": {"getFileSize": ["getByteSize", " getfileInfo", "getFileBytes", " getfileBytes", "getFilesSize", "getFileLength", "getFilesBytes", "getByteBytes", " getFileBytes", "getfileLength", "getfileBytes", "getFileInfo", "getByteInfo", "getByteLength", " getfileLength", " getFileInfo", " getFileLength", "getfileSize", "getFilesLength", "getFilesInfo", " getfileSize", "getfileInfo"], "address": ["resource", "attribute", "route", "ip", "position", "string", "host", "Address", "request", "str", "path", "report", "number", "network", "email", "object", "content", "base", "prefix", "port", "server", "addr", "location", "config", "size", "array", "code", "localhost", "format", "output", "type", "data", "point", "target", "message", "offset", "uri", "source", "name", "reference"], "url": ["resource", "ob", "string", "channel", "host", "http", "xml", "str", "proxy", "service", "www", "URL", "path", "ll", "log", "ur", "api", "feed", "io", "Url", "impl", "object", "conn", "user", "orb", "bug", "loc", "lr", "build", "l", "base", "server", "location", "config", "sl", "f", "e", "session", "image", "lib", "socket", "page", "ssl", "html", "result", "found", "job", "web", "uri", "client", "org", "file"], "connection": ["resource", "or", "application", "entry", "use", "section", "function", "position", "c", "Connection", "channel", "current", "context", "environment", "request", "http", "proxy", "character", "service", "condition", "response", "con", "io", "open", "database", "relation", "conn", "object", "handler", "out", "event", "communication", "server", "config", "bc", "control", "session", "wrapper", "connect", "socket", "to", "connected", "info", "uri", "client", "collection", "version", "reference"]}}
{"id1": "16851955", "id2": "20924119", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"testTrainingBackprop": ["testTrainingFrontprop", "testTrainBackdrop", "testTrainingFrontdrop", "testTrainingBACKpointer", "testTrainingBACKdrop", "testTrainingBackpointer", "testTrainingBACKpressure", "testTrainBACKpressure", "testTrainBackprop", "testTrainingFrontpointer", "testTrainBackpressure", "testTrainingBackpressure", "testTrainBACKprop", "testTrainBackpointer", "testTrainingBACKprop", "testTrainBACKdrop", "testTrainingBackdrop", "testTrainBACKpointer", "testTrainingFrontpressure"], "temp": ["folder", "txt", "wrap", "pipe", "local", "pdf", "container", "full", "zip", "clean", "cache", "current", "dat", "ex", "http", "input", "copy", "path", "io", "empty", "this", "dest", "form", "archive", "base", "out", "storage", "model", "tmp", "tem", "config", "fake", "f", "flat", "session", "emp", "writer", "v", "test", "output", "Temp", "data", "directory", "save", "stable", "porary", "mount", "parent", "buffer", "lock", "font", "cel", "file", "template"], "layers": ["lobs", " lients", "lowers", "slowers", "dlayers", "nlayers", "slays", "licikes", "placks", "Layers", "lasks", "backs", " languages", "lacks", "liayers", "slacks", "fllements", "planguages", "languages", "blayers", " lowers", "bowers", "players", "flasses", "lients", "lagers", "liacks", "liores", "gients", "lasses", " lays", "dlasks", "flanguages", "flayers", "liibraries", "likes", "licayers", "dlacks", "gayers", "Lobs", " likes", " lasks", "licagers", "bllements", " lobs", "Lients", "lores", "blanguages", "nlibraries", " lagers", "llements", "nlagers", "slayers", " libraries", "dlores", "licibraries", " lasses", "gobs", "lays", "nlikes", "plasks", "bays", "bayers", "libraries", "dlibraries", " lores", "dlanguages", " llements", " lacks", "blasses"], "fann": ["larn", "sfannon", "fain", "xfanny", "elfnn", "gana", "garn", "elfann", "fanny", "lnn", "fana", "fnn", "lann", "Fannon", "xfann", "xfannon", "lana", "xfain", "elfana", "sfann", "Fanny", "gann", "farn", "elfarn", "Fann", "gnn", "sfanny", "sfain", "Fain", "fannon"], "trainer": ["strainer", "tacker", "striner", "tracer", "rain", "Triner", "retacer", "traacer", "Tracker", "tracker", "triner", "stracker", "racker", "racer", "Trainer", "retiner", "traacker", "traainer", " tracker", "strayer", "rainer", "trayer", "stracer", " train", "tacer", "train", "retainer", "retayer", "trarain", " tracer", "trrain", "strain", "Tracer", "Trrain", "Trayer", "tainer"], "desiredError": ["desirableSize", "deservedOrder", "desciredError", "despectedProblem", "DesireException", "desidedFailure", "desizedException", "desiringError", "DesireSize", "reservedOrder", "desivedError", "desiredEvent", "descirederror", "desirableOrder", "desivedSize", "descidedFailure", "deservedError", "despectederror", "DesiredException", "reservedEvent", "resiredOrder", "desiredException", "despectedError", "descidederror", "resiredError", "desiringFailure", "designedError", "desiredFailure", "desciredFailure", "desizedSize", "descidedError", "desidedProblem", "DesiredSize", "designedOrder", "desivedException", "desirableEvent", "desirederror", "desireError", "resiredEvent", "desiredProblem", "descidedProblem", "desidedError", "desciredProblem", "despectedFailure", "desizedError", "DesiredError", "desirableError", "desiredOrder", "deservedEvent", "reservedSize", "desiredSize", "desireSize", "desireException", "DesireError", "desidederror", "desiringerror", "desiringProblem", "resiredSize", "deservedSize", "designedSize", "designedEvent", "reservedError"], "mse": ["fmce", "gmse", "fmte", "mce", " mSE", " mce", "gmge", "mte", "fmze", "Mte", "MSE", "Mze", "fSE", "fce", " mge", "fse", " mte", "mge", "gmSE", "Mse", "Mce", "fmse", "mze", " mze", "gmce", "fge", "Mge", "mSE"]}}
{"id1": "19335986", "id2": "18693224", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["uncatchedexc", "unchandledexc", "Catchedexc", "uncatchedEvent", "uncatchedException", "CaughtEvent", "unchandledEvent", "unchandledException", "Caughtexc", "uncaughtexc", "uncachedException", "CatchedException", "CatchedEvent", "uncachedexc", "uncachedEvent", "uncaughtEvent", "CaughtException"], "t": [" td", "ty", "n", "c", "g", "m", "te", "d", "title", "tree", " T", "let", "ed", "tr", "ing", "p", "it", "l", "w", "s", "out", "f", "tx", "ts", "type", "r", "T"], "e": ["eu", "fe", "c", "oe", "m", "environment", "o", "d", "ee", "ge", "be", "enter", "ce", "ed", "er", "eb", "ie", "Exception", "err", "p", "ception", "s", "element", "pe", "event", "j", "exc", "f", "E", "ele", "ep", "code", "i", "el", "example", "ne", "se", "error", "data", "ae", "ev", "diff", "r", "esi", "en", "de", "es", "ec", "me", "ace"], "display": ["fe", "dis", "status", "window", "container", "position", "description", "host", "panel", "view", "d", "report", "screen", "platform", "process", "this", "design", "summary", "content", "object", "Display", "play", "p", "profile", "default", "app", "show", "layout", "config", "scroll", "hide", "image", "page", "style", "de", "me", "body", "console", "monitor"], "shell": ["mail", "status", "live", "ml", "container", "sh", "m", "host", "environment", "gui", "xml", "sym", "tool", "copy", "log", "tools", "process", "child", "sound", "Shell", "bash", "cl", "l", "app", "exec", "clone", "server", "math", "system", "help", "sb", "machine", "cli", "hell", "el", "image", "h", "kernel", "echo", "b", "loop", "launch", "lock", "buffer", "body", "console", " Shell", "poll"], "message": [" exception", "mail", "application", "status", "media", "description", "management", "m", "request", " messenger", "view", "xml", "response", "copy", "essage", "msg", "log", "report", "queue", "mess", "summary", "email", "object", "content", "address", "header", "translation", "flash", "document", "model", "event", "server", "Message", "value", "image", "page", "member", "result", "output", "error", "data", "meter", "buffer", "update", "body", "console", "monitor"], "e1": ["exc8", "exc1", "E2", " e2", "e8", "E8", "e2", "exc2", "exc3", " e8", " e3", "e3", "E1", "E3"]}}
{"id1": "13012591", "id2": "17111859", "code1": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 1, "substitutes": {"getPasswordHash": ["getPasswordhash", "getHashSum", " getPasswordSum", " getPasswordSecret", "getHashHash", "getPasswordSecret", "getStringhash", "getPasswordSum", "getpasswordHash", " getPasswordhash", " getpasswordHash", "getStringSum", "getStringHash", "getpasswordhash", "getHashSecret", " getpasswordhash", "getpasswordSum", "getpasswordSecret", "getStringSecret", "getHashhash", " getpasswordSum", " getpasswordSecret"], "password": ["pass", "attribute", "token", "username", "words", "sword", "string", "cache", "word", "secret", "input", "Password", "PASS", "path", "key", "number", " passwords", "auth", "database", "email", "wd", "user", "content", "address", "p", "prefix", "phrase", "security", "config", "array", "confirmed", "code", "data", "account", "message", "pattern", "buffer", "crypt", "text", "source", "name", "padding"], "md": ["dc", "mb", "mg", "mp", "pd", "mage", "pm", "ms", "od", "mand", "cm", "mac", "map", "m", "mem", "sm", " MD", "d", "sha", "hm", "MD", "bd", "meta", "alg", "hd", "ad", "dd", "ld", "mc", "amp", "gb", "mod", "cmd", "dh", "dr", "ma", "mag", "pkg", "arm", "gd", "gm", "dm", "material", "nm", "amd", "dig", "mm", "metadata", "vd", "mt", "mu", "bm", "db", "mo"], "hash": ["body", "row", "mask", "bh", "hed", "sh", "mac", "cache", "map", "Hash", "host", "secret", "total", "cover", "sha", "sum", "search", "match", "hex", "key", "number", "ashes", "length", "address", "square", "header", "kh", "build", "count", "batch", "carry", "ha", "url", "query", "ash", "array", "index", "code", "image", "h", "check", "dot", "html", "filter", "handle", "diff", "error", "data", "dig", "message", "block"], "buf": ["bh", "nb", "aux", " buffer", "cas", "pb", "cv", "bin", "src", "conv", "abi", "ctx", "abs", "box", "pad", "cf", "bp", "ab", "book", "br", "bag", "ff", "tmp", "bc", "sb", "Buffer", "f", "array", "af", "pkg", "home", "uf", "cap", "h", "cb", "fp", "v", "bb", "img", "data", "Buff", "b", "fb", "buff", "bf", "buffer", "va", "rb", "db", "ref"], "i": ["hi", "si", "chi", "qi", "ip", "u", "multi", "k", "c", "ii", "m", "pi", "o", "d", "abi", "ci", "di", "io", "vi", "ui", "ji", "ri", "length", "bi", "p", "it", "l", "phi", "s", "j", "I", "eni", "x", "uli", "fi", "index", "f", "field", "e", "oi", "li", "h", "v", "gi", "ti", "data", "ai", "r", "b", "xi", "t", "id", "uri", "mu", "end"]}}
{"id1": "9872346", "id2": "22734545", "code1": "    public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException {\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\");\n        Document document = null;\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            factory.setCoalescing(true);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDefaultUseCaches(false);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"User-Agent\", \"eXchaNGeR/\" + System.getProperty(\"xngr.version\") + \" (http://xngr.org/)\");\n            connection.connect();\n            InputStream stream = connection.getInputStream();\n            document = factory.newDocumentBuilder().parse(stream);\n            stream.close();\n            connection.disconnect();\n        } catch (SAXException e) {\n            if (e instanceof SAXParseException) {\n                throw (SAXParseException) e;\n            }\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \") [\" + document + \"]\");\n        return document;\n    }\n", "code2": "    public void generate(String urlString, String target) throws Exception {\n        URL url = new URL(urlString);\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        BufferedInputStream inputStream = new BufferedInputStream(urlConnection.getInputStream());\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target));\n        byte[] buf = new byte[10 * 1024];\n        int len;\n        while ((len = inputStream.read(buf, 0, buf.length)) != -1) {\n            outputStream.write(buf, 0, len);\n        }\n        inputStream.close();\n        outputStream.close();\n        urlConnection.disconnect();\n    }\n", "label": 0, "substitutes": {"readRemoteDocument": ["readServerdocument", "loadLocalDocument", "loadRemotedocument", "readExternalDocument", "readLocalDocuments", "loadLocaldocument", "readServerDocuments", "readLocaldocument", "readServerDocument", "readLocalDocument", "readRemoteDocuments", "loadRemoteDocuments", "readRemotedocument", "loadLocalDocuments", "loadRemoteDocument", "readExternalDocuments", "readExternaldocument"], "url": ["resource", "entry", "username", "position", "string", "channel", "host", "http", "xml", "version", "service", "www", "URL", "path", "layer", "ll", "ur", "feed", "Url", "email", "rl", "download", "user", "address", "loc", "store", "l", "base", "server", "location", "load", "config", "sl", "f", "link", " URL", "filename", "image", "socket", "remote", "page", "ssl", "uri", "source", "client", "org", "name", "file", "lc"], "validate": ["validated", "Valate", "verated", " validation", "verating", "validating", "Valation", "validation", "Valated", "verate", "veration", " validating", "Valating", " validated"], "document": ["resource", "df", "application", "media", "container", "project", "function", "word", "degree", "view", "xml", "expression", "request", "language", "service", "response", "node", "doc", "database", "design", "Document", "content", "object", "dict", "valid", "video", " documentation", "model", "port", "location", "system", "office", "index", "f", "session", "value", "graph", "image", "record", "material", "result", "page", "output", "data", "ocument", "null", "metadata", "message", "parent", "source", "text", "collection"], "factory": ["fluent", "biller", "efluent", "fade", "fault", " folver", "bixture", "Filler", "fFactory", " filler", "sfluent", "dade", "hiller", "affactory", "sfault", "filler", "bactory", "efixture", "Folver", "pluent", "FFactory", "folver", "infiller", "pault", "dactory", "fsolver", "efactory", "Factory", "affault", "infade", "infactory", "future", "hade", "efiller", "fixture", "sfixture", "bluent", "affixture", "sfactory", "infuture", "fsFactory", " fFactory", "affluent", "diller", "pixture", "pactory", "duture", "hactory", "fsactory", "fsiller", "piller", "huture"], "connection": ["resource", "application", "use", "container", "section", "function", "position", "c", "Connection", "channel", "cache", "context", "current", "union", "http", "proxy", "character", "service", "condition", "response", "con", "io", "open", "driver", "database", "relation", "conn", "user", "creator", "translation", "handler", "default", "out", "communication", "server", "port", "system", "config", "index", "link", "session", "wrapper", "password", "image", "connect", "socket", "writer", "reader", "error", "connected", "info", "uri", "client", "collection", "version", "builder", "common"], "stream": ["resource", "or", "row", "entry", "media", "container", "string", "channel", "context", "view", "response", "input", "transform", "path", "io", "sc", "feed", "cont", "object", "translation", "handler", "trans", "video", "sw", "out", "Stream", "model", "upload", "server", "coll", "load", "system", "loader", "sl", "f", "per", "image", "writer", "result", "v", "reader", "output", "data", "raw", "stack", "source", "client", "body", "form", "version", "file"]}}
{"id1": "6009527", "id2": "6371589", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadAssments", "doFinishLoadInstortion", "doFinishLoadInstachment", "doFinishloadAttments", "doFinishLoadAttment", "doFinishLoadInstment", "doFinishloadAttment", "doFinishLoadAssment", "doFinishloadAttachment", "doFinishLoadAttachments", "doFinishLoadAttachortion", "doFinishloadAttachachment", "doFinishLoadAttments", "doFinishLoadInstments", "doFinishloadAttachments", "doFinishLoadAttortion", "doFinishloadAttortion", "doFinishLoadAttachachment", "doFinishloadAttachortion", "doFinishLoadAssachment", "doFinishLoadAssortion"], "attachmentId": ["attentionInfo", "attimageID", "attimageInfo", "attachmentID", "adachmentId", "adociationPath", "attachmentid", "attachmentPath", "adociationInfo", "attentionid", "attplementationId", "attplementationID", "AttachmentId", "attimagePath", "ttociationid", "ttociationId", "Attachmentid", "ttachmentID", "attlementID", "attociationid", "AttachmentID", "attociationId", "adachmentInfo", "attociationInfo", "attentionID", "attlementId", "attentionPath", "AttachmentType", "attentionId", "attociationID", "ttociationID", "ttachmentId", "adachmentPath", "attlementType", "attlementid", "attimageId", "attachmentInfo", "ttachmentid", "adachmentID", "attachmentType", "attociationPath", "adociationID", "adociationId", "attentionType", "attplementationid"], "attachment": ["attment", "attachruction", "adment", "appachment", "appment", "attruction", "attention", "attachached", " attention", "attachachment", "assention", "instment", "attached", "assached", " adaptociation", " attment", "association", "attociation", " adaptachment", "appruction", "adached", "attachention", "assachment", "instachment", "assment", "adention", " attociation", " adaptention", "instention", " adaptment", "appention", "adachment", "instruction"], "attachmentUri": ["attmentIri", "attachmentUris", "attachmentCuURI", "attachedAti", "attachmentEri", "attachmentSuris", "attachmentIuri", "attachedURI", "attachmentSuri", "attachmentSuti", "attachmentSuuri", "attachmentIURI", "attachedUti", "attachmentSuRI", "attachedAuri", "attachmentAri", "attachmentEuri", "attachmentUti", "attachedUri", "attachmentIris", "attmentUURI", "attachmentSuURI", "attmentUri", "attachmentERI", "attachedARI", "attachmentUuri", "attachedUuri", "attachmentCuuri", "attachedAri", "attachmentAuri", "attachmentEti", "attachmentAti", "attachmentCuri", "attachmentIri", "attachmentUURI", "attmentIURI", "attachmentCuris", "attmentIuri", "attmentUuri", "attmentIris", "attachmentURI", "attachmentARI", "attmentUris"], "contentUri": ["contentUsris", "contentIi", "contentURuri", "contentUuri", " contentSudi", " contentSuRI", " contentURI", "contentSuRI", "resourceIri", "contentSuri", "resourceURI", "contentIri", "resourceUris", "contentCRI", "contentFileris", "contentURi", "resourceUri", "contentURI", "contentURris", "resourceIuri", "resourceIRI", "contentUsdi", "contentUdi", "contentCuri", "contentUsRI", "resourceUi", " contentUris", "contentUi", "contentCi", "resourceIi", " contentUdi", " contentSuri", "contentUsuri", "contentCris", "resourceUuri", "contentCdi", "resourceIris", "contentCri", "contentFileri", "contentSudi", "contentFileRI", "contentUsri", "contentFileuri", "contentIuri", "contentIRI", "contentUris", "contentSuris", "contentIris", " contentSuris", "contentURri"], "file": ["File", "folder", "resource", "able", "local", "ger", "use", "stream", "line", "entity", "zip", "cache", "view", "le", "input", "copy", "path", "log", "io", "via", "this", "files", "object", "child", "letter", "content", "unit", "book", "single", "handler", "up", "create", "connection", "base", "pe", "model", "upload", "url", "get", "work", "load", "f", "FILE", "filename", "image", "auto", "socket", "to", "fp", "output", "reader", "data", "picture", "b", "source", "uri", "binary", "buffer", "name"], "in": ["In", "pull", "or", "again", "ini", "c", "IN", "m", "o", "din", "inner", "bin", "input", "copy", "as", "con", "io", "this", "pin", "sync", "ins", "ac", "conn", "inn", "err", "up", "connection", "init", "s", "win", "url", "gin", "f", "cli", "e", "i", "nin", "a", "image", "socket", "login", "reader", "data", "r", "b", "inc", "id", "source", "binary"], "out": ["resource", "In", "line", "again", "cache", "IN", "o", "ex", "view", "inner", "bin", "Out", "copy", "log", "outer", "io", "outs", "this", "sync", "on", "conn", "err", "up", "connection", "net", "s", "base", "init", "exec", "cli", "i", "by", "nin", "image", "socket", "to", "writer", "page", "ext", "output", "data", "OUT", "null", "b", "inc", "source", "lock", "client", "one"], "intent": ["action", "entry", "advert", "vent", "acc", "entity", "effect", "act", "context", "request", "xml", "language", "ents", "concept", "response", "ani", "ctx", "inst", "contact", "this", "activate", " Intent", "content", "object", "it", "intention", "animate", "document", "init", "agent", "element", "spirit", "event", "ant", "anc", "enc", "impact", "category", "eng", "anim", "ink", "feature", "Activity", "term", "feat", "ent", "activation", "text", "activity", "focus", "android"]}}
{"id1": "13122204", "id2": "10451698", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["unarchiveProject", "unpackmodel", "UnarchiveFile", "unpatchModel", "UnzipProject", "unzipFile", "UnarchiveModel", "unarchiveModel", "unpackProject", "unpatchFile", "unzipProject", "UnzipModel", "unpackModel", "unarchivemodel", "unzipmodel", "unarchiveFile", "unpatchProject", "UnzipFile", "Unzipmodel", "unpatchmodel", "unpackFile", "UnarchiveProject", "Unarchivemodel"], "filename": ["folder", "File", "il", "jet", "txt", "username", "string", "SourceFile", "utf", "title", "Filename", "fits", "path", "fd", "fil", "files", "database", "download", "fn", "loc", "l", "model", "url", "location", "f", "FILE", "fp", "nil", "directory", "module", "bf", "kl", "source", "uri", "src", "name", "file"], "tempdir": ["Tempfolder", "TempDir", "tmpdir", " tempdirectory", "temdir", "temdirectory", "temfolder", "tmpfolder", "tmpDIR", "tempath", "tempDIR", "temDir", "TempDIR", "temppath", "Tempdirectory", "tmpDir", " temppath", " tempDir", "tempfolder", " tempDIR", "tmpdirectory", "tmppath", "tempdirectory", " tempfolder", "tempDir", "Tempdir"], "dest": ["dc", "walk", "txt", "temp", "done", "cdn", "folder", "exit", "zip", "rest", "opt", "dat", "dist", "inner", "walker", "transform", " Dest", "desc", "di", "log", "export", "die", "ui", "sync", "tar", "dir", "handler", "loc", "sup", "store", "trans", "comb", "proc", "default", "tmp", "builder", "delete", "usr", "flat", "session", "home", "Dest", "transfer", "result", "std", "nt", "output", "test", "gen", "st", "obj", "target", "prop", "de", "source", "wb", "cont", "src", "later", "file"], "fis": ["fsis", "fileisa", " fid", "filebis", "filei", "liss", " fiss", "fileid", "fsiss", "fsbis", "fileis", " fi", "fsisa", "fi", "flbis", "fisa", "fbis", "fileiss", "flis", "li", "fliss", "flisa", "fid", "lid", "lis", "fiss"], "BUFFER": ["BUFIX", "TAVER", "BOPER", "CUPER", "CUFFER", "BOFIX", "BUFF", "SAVER", "BUPER", "MAFIX", "SAUCK", "UPVEN", "CUUCK", "BOFFER", " BUVEN", "MAPER", "BUUCK", "UPFFER", " BUUCK", "SAFFER", "UPVER", "BUFER", "CUFF", "MAFFER", "BOFER", "BUVEN", "TAPER", "SAPER", "MAFER", " BUFF", "CUVEN", "CUVER", " BUFER", "BUVER", " BUPER", " BUVER", "TAFFER", " BUFIX", "UPFF", "TAUCK"], "zis": ["ziss", "dis", "jis", "zii", " ziss", " zins", "zisa", "zin", "xos", " zisa", "zipins", "xists", "jos", "zipis", "Zisa", "ji", " zbis", "diss", "zists", "jists", "zIS", "zipIS", " zii", "zins", "zas", "Zins", "zipisa", "yin", "zbis", " zists", "xis", "yisa", "zipas", "yIS", " zin", "xiss", "yis", "dii", "dbis", "xii", " zIS", "Zas", "Zis", "zos", "xbis", "xi", "zipin", "zi", " zi", " zas", " zos"], "entry": ["row", "or", "je", "ry", "si", "line", "cat", "zip", "spec", "Entry", "inner", "ge", "feed", "match", "jo", "la", "enter", "ce", "archive", "iterator", "ie", "valid", "part", "porter", "connection", "rc", "element", "pe", "way", "server", "ident", "e", "ries", "li", "her", "image", "record", "result", "nt", "se", "next", "reader", "ou", "ent", "module", "pack", "de", "inc", "id", "info", "source", "ace", "cel", "name", "file", "lc", "end"], "count": ["use", "line", "c", "cache", "current", "low", "limit", "core", "sum", "time", "log", "feed", "Count", "list", "number", "key", "add", "in", "length", "weight", "part", "base", "pos", "cond", "coll", "max", "size", "read", "index", "f", "iter", "e", "code", "len", "allow", "i", "ind", "start", "_", "val", "writer", "counter", "next", "last", "type", "write", "b", "id", "buffer", "name", "file", "end"], "data": ["media", "zero", "dat", "shift", "str", "d", "input", "feed", "number", "la", "length", "content", "batch", "alpha", "base", "pos", "load", "DATA", "size", "array", "block", "read", "index", "len", "value", "image", "a", "record", "bytes", "format", "result", "start", "next", "reader", "write", "raw", "pack", "id", "message", "info", "buffer", "body", "name"], "fos": ["bops", "xops", "dfoos", "xos", "afis", " fops", " fOS", "xoes", " foos", "dfos", "foos", "bOS", "afOS", "bos", "afops", "fops", "xoos", "foes", "fOS", "bis", "afos", "dfoes", "dfops", " foes"]}}
{"id1": "19050432", "id2": "9450274", "code1": "    private static InputStream openNamedResource(String name) throws java.io.IOException {\n        InputStream in = null;\n        boolean result = false;\n        boolean httpURL = true;\n        URL propsURL = null;\n        try {\n            propsURL = new URL(name);\n        } catch (MalformedURLException ex) {\n            httpURL = false;\n            propsURL = null;\n        }\n        if (propsURL == null) {\n            propsURL = UserProperties.class.getResource(name);\n        }\n        if (propsURL != null) {\n            URLConnection urlConn = propsURL.openConnection();\n            if (httpURL) {\n                String hdrVal = urlConn.getHeaderField(0);\n                if (hdrVal != null) {\n                    String code = HTTPUtilities.getResultCode(hdrVal);\n                    if (code != null) {\n                        if (!code.equals(\"200\")) {\n                            throw new java.io.IOException(\"status code = \" + code);\n                        }\n                    }\n                }\n            }\n            in = urlConn.getInputStream();\n        }\n        return in;\n    }\n", "code2": "    public void seeURLConnection() throws Exception {\n        URL url = new URL(\"http://wantmeet.iptime.org\");\n        URLConnection uc = url.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n        String s = null;\n        StringBuffer sb = new StringBuffer();\n        while ((s = br.readLine()) != null) {\n            sb.append(s);\n        }\n        br.close();\n        log.debug(\"sb=[\" + sb.toString() + \"]\");\n    }\n", "label": 0, "substitutes": {"openNamedResource": ["openNamingResources", "openNnamedResources", "openParamingResources", "openNamingresource", "openNamedresource", "openParamedResources", "openParamingresource", "openParamedresource", "openNnamedURI", "openNnamedResource", "openNestedURI", "openNamingResource", "openParamingURI", "openNamingURI", "openParamedResource", "openParamedURI", "openNamedURI", "openNestedresource", "openNestedResources", "openNamedResources", "openParamingResource", "openNnamedresource", "openNestedResource"], "name": ["Name", "names", "resource", "class", "username", "full", "n", "string", "word", "str", "version", "named", "old", "path", "key", "address", "part", "base", "prefix", "url", "sea", "definition", "size", "value", "filename", "ame", "NAME", "type", "data", "id", "info", "uri", "source", "parent", "file"], "in": ["resource", "In", "pc", "token", "fc", "again", "oin", "ini", "IN", "rec", "cin", "inner", "din", "bin", "input", "ic", "as", "con", " out", "pin", "ins", "ac", "conn", "inn", "err", "kin", "connection", "win", "rin", "out", "url", "get", "gin", "thin", "f", "i", "nin", "socket", "edIn", "val", "login", "result", "reader", "data", "vin", "r", "b", "inc", "source"], "propsURL": ["protsFile", " prolsSSL", "propsCL", "PropsSSL", " proportsUR", "proopsUrl", "prorsurl", " propsSSL", "pronsUrl", "proopsLL", "prorsUR", "ProsURL", "pronsLL", "propsFile", "proopsUR", " propsURI", "prodsUrl", "pronsURL", "prolsurl", "propsURI", "progsURL", "PropsURI", "prodsFile", "prorsURL", "PropsUrl", " propsCL", "prodsURL", " prolsurl", "proppsURL", "prorsFile", " proportsURL", "procsurl", "probsUrl", "procsSSL", "proportsSSL", "protsurl", "proportsUrl", "prosSSL", " prodsurl", "proopsELF", "proportsLL", " prodsURL", " propsUR", "prodsURI", "progsCL", "propsUR", "propsELF", "proportsurl", "proportsELF", "progsurl", " proportsUrl", "perrsURL", "probsLL", "proppsUR", "proportsUR", "proopsURL", "ProsSSL", "proopsCL", "perpsFile", "proportsUL", "prolsURI", "perpsurl", "perrsurl", "prodsCL", "ProsUrl", "proportsURL", "prodsUR", "perrsFile", " proportsLL", "propdsURL", "prorsELF", " prolsURI", "propsUrl", "propdsUR", "protsURL", " propsLL", "procsUrl", " propsUrl", "prodsSSL", "procsURI", " propsurl", "proppsLL", "prodsLL", " propsELF", "pronsUR", "ProsURI", "prosUrl", " proportsUL", "proppsUrl", "procsURL", "propsUL", " prodsURI", "probsURL", "perpsURL", " prolsURL", " prodsCL", "propsurl", "prosURI", "prosURL", "propsLL", "prorsUrl", "prosUL", " proportsELF", "propsSSL", " propsUL", "proopsURI", "propdsLL", "PropsURL", "probsUL", "prosLL", "prolsSSL", "progsURI", "prolsURL", "propdsUrl", "prodsurl", "proopsurl", "proportsURI"], "urlConn": ["sslconn", "httpConn", "httpContext", "urlCond", "sslConnect", " urlconn", "httpCod", "URLConf", " urlCmd", "urlCmd", "urlconn", "sslConn", "httpConnect", " urlConf", "sslCod", "sslCmd", " urlCod", " urlConnect", "urlConf", "URLContext", "httpConf", " urlContext", "fileCmd", " urlCond", "sslCond", "urlCod", "httpconn", "URLConnect", "fileConnect", "fileConn", "urlConnect", "URLConn", "fileCond", "urlContext"], "httpURL": ["HttpUrl", " httpUrl", "autoURL", "httpsURI", "httpsUrl", "httpUrl", "apiURL", " httpurl", "autoSSL", "httpsURL", "httpUR", " httpUR", "httpML", "HttpML", "HttpURI", "apiUR", " httpML", "autoUrl", " httpURI", "autourl", "HttpURL", "httpSSL", " httpSSL", "apiML", "HttpUR", "httpurl", "httpsurl", "apiUrl", "httpURI", "httpsUR", "httpsSSL"], "hdrVal": ["hdrval", "hrStr", "hheaderVal", "hdval", "HhrDef", "hdrVol", "hndValue", "HhrValues", "hreqVol", "hndBu", "HdrDef", "hndVal", "Hhrval", "hdrValue", "hdrValues", "hhrValues", "hheaderStr", "hrVal", "hrValue", "hreqStr", " hheaderValue", "hdrStr", "hhrValue", " hheaderStr", "HhrValue", "hDRValues", "hheaderValue", "hheaderVol", "hreqVal", " hdrVol", " hdrStr", "HdrBu", "hdrBu", "HhrVal", " hdrValue", "HdrValues", "hrcVal", "hhrBu", "hrcValue", "hrcBu", "Hdrval", "hdVal", "HdrVal", "hreqValue", "hrVol", "hhrval", "hdValues", "hDRVal", "hDRValue", "hrcDef", "hhrVal", "hndDef", "hhrDef", "HdrValue", "hdValue", "HhrBu", " hheaderVal", "hdrDef", " hheaderVol", "hDRval"], "code": ["status", "pc", "class", "line", "cat", "codes", "zip", "c", "string", "go", "see", "version", "comment", "state", "ge", "Code", "response", "msg", "desc", "co", "key", "number", "cod", "text", "zone", "ce", "content", "no", "ack", "mode", "header", "count", "age", "ie", "cc", "grade", "rule", "coded", "rate", "pe", "rc", "fail", "expected", "score", "url", "index", "category", "e", "value", "success", "check", "result", "test", "level", "charge", "data", "type", "error", "xx", "id", "ec", "message", "info", "const", "ode", "reason", "core", "one"]}}
{"id1": "6371607", "id2": "8135072", "code1": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 0, "substitutes": {"removeRealm": ["deleterealms", "deleteRealm", "delBroadM", "removeRelam", "removeRelM", "removeRelms", "delBroadms", "delRealms", "deleterealm", "removeScheme", "deleterealM", "removerealam", "removeSchems", "delRealme", "removeRealms", "delBroadme", "deleteRealms", "removeBroadm", "delRealM", "removeRealme", "removerealms", "removeSchem", "removeBroadms", "deleterealam", "removeLocalam", "removeBroadM", "deleteRealM", "delRealm", "removeLocalm", "removeBroadme", "removerealme", "removeLocalms", "removeRelm", "delBroadm", "removeScheM", "removeRealam", "removeRealM", "removeLocalM", "removerealM", "removerealm", "deleteRealam"], "realmIds": ["realmByIdes", "realmByIdls", "realmPaths", "realMIdids", "realmRefls", "realmIdList", "realmRefos", "realmIntids", "realmByIdList", "realMIdList", "realmIntes", "realmIDls", "realmByIds", "realmRefes", "realMIdls", "realMIds", "realMPaths", "realmPathos", "realMPathos", "realmPathids", "realmIntos", "realmIDes", "realmIdls", "realmInts", "realMPathes", "realmRefids", "realMPathids", "realMByIds", "realmRefList", "realMByIdes", "realmPathes", "realmIdes", "realMIdes", "realMByIdList", "realmIDList", "realMByIdls", "realMIdos", "realmIdids", "realmRefs", "realmIdos", "realmIDs"], "psImpl": ["epsIter", "dsImpl", "epsExpl", " psIter", "csimpl", "qsImpl", "cssExpl", "qsHelper", " psimpl", " psHelper", "psimpl", "epsimpl", " psExpl", "cssIter", "dsHelper", "qsimpl", "psIter", "epsImpl", "csImpl", "cssimpl", "psHelper", "dsimpl", "psExpl", "cssImpl", "epsHelper", "csHelper"], "iter": ["entry", "line", "ter", "ir", "inter", "upper", "ator", "former", "limit", "inner", "ler", "walker", "cer", "outer", "ner", "list", "apper", "enter", "in", "er", "iterator", "izer", "it", "ie", "err", "cher", "loc", "init", "coll", "index", "itter", "ite", "e", "i", "el", "page", "finder", "reader", "next", "parse", "Iter", "gener", "inc", "loop", "sort", "end"], "realmId": [" realmnHash", "realfId", "realrmID", "realdmConfig", "realmid", "workmid", "RealmPath", "realmeId", "workfid", "realmsId", "workfNum", "realmaRef", "realamNum", "ironmID", "realmrHash", "ironmInt", "realmrID", "realmOffset", " realmnConfig", " realmHash", "realmsName", "realarmName", "RealmsId", "ironmaId", "realmcRef", "realmaInt", "realmHash", "realmcID", "realfid", "realmNum", "realdmId", " realmOffset", "realmrid", "RealmsName", "ironmId", "realmePath", "realmnHash", "RealmsID", "realamId", "realmcInt", "realmeID", "realmRef", "realfID", "realamid", "workmNum", " realmnOffset", " realmnId", "realmaId", "realrmId", "realmsPath", "realmeName", "realrmInt", "realrmRef", "workfId", "realmnOffset", "realfNum", "ironmaInt", "realmnId", "realamID", "realmsID", "RealmName", " realmConfig", "realmInt", "RealmID", "realmID", "RealmId", "ironmaRef", "realarmId", "realdmOffset", "realarmPath", "realmrNum", "realmPath", "workmId", "workmID", "realmcId", "realmName", "ironmaID", "workfID", "realmrConfig", "RealmsPath", "realmaID", "realmrId", "ironmRef", "realarmID", "realmnConfig", "realmrOffset", "realmConfig", "realdmHash"]}}
{"id1": "5998352", "id2": "11562165", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 1, "substitutes": {"testStandardTee": ["testStandardFees", "teststandardTae", "testStandardTeed", "testStandardTees", "testStandardBae", "testStandardFeed", "testStandardBee", "testStandardFee", "testStandardMees", "teststandardTees", "teststandardTee", "testStandardMee", "testStandardBees", "testStandardBeed", "testStandardTae", "testStandardMae", "teststandardMae", "teststandardMee", "teststandardMeed", "teststandardMees", "teststandardTeed", "testStandardFae", "testStandardMeed"], "reference": ["resource", "distance", "attribute", "external", "description", "string", "c", "request", "pointer", "see", "forward", "version", "proxy", "copy", "path", "report", "primary", "sequence", "Reference", "number", "compatible", "database", "pair", "relation", "length", "address", "ference", "re", "single", "archive", "connection", "document", "hello", "REF", "order", "prefix", "server", "url", "location", " Reference", "variable", "index", "rice", "code", "filename", "References", "format", "remote", "relative", "test", "directory", "output", "type", "memory", "target", "message", "buffer", "binary", "specified", "collection", "name", "uri", "ref"], "source": ["resource", "fe", "temp", "g", "string", "context", "Source", "table", "view", "proxy", "service", "input", "copy", "ource", "io", "slice", "driver", "ce", "object", "ie", "connection", "server", "url", "config", "iter", "e", "code", "i", "SOURCE", "writer", "result", "reader", "se", "output", "target", "r", "parent", "buffer", "text", "src", "ref"], "destination1": ["destinator01", "constinator1", "Destension0", "destribution0", "Destension1", "DestinationOnce", "destentionOnce", "constination01", "destinationOne", "DestinateOnce", "constination2", "destension1", "destaration0", "destaration1", "destinate01", "constinatorOne", "destinate2", "Destination1", "destribution1", "destension0", "DestinateOne", "destention1", "destinationsOne", "destination01", "destributionOne", "destinate1", "constinator2", "destinationOnce", "Destinate1", "destinateOne", "destensionOne", "Destination0", "destentionOne", "destinatorOne", "destinations2", "constinator01", "destinator1", "destarationOne", "destinations1", "constination1", "destination0", "constinationOne", "destinator2", "DestensionOne", "DestinationOne", "destinations01", "destinatorOnce", "destinateOnce"], "destination2": ["destation1", "destinate02", "descination2", "destination02", "coordinationSecond", "destinationsSecond", "destication2", "destignmentSecond", "destignment02", "destignment2", "destribution2", "destinatingtwo", "Destination4", "destinateSecond", "descination02", "Destinationtwo", "descinations1", "destinationtwo", "destination4", "destinate2", "Destination1", "Destinate2", "destation2", "descinations02", "descinations2", "desticationSecond", "destinate22", "destinating2", "destation4", "destinate1", "Destinatetwo", "descinationSecond", "coordination2", "destination22", "Destinate4", "destationtwo", "coordination22", "destributionSecond", "coordinate22", "coordinateSecond", "destinating1", "Destinate1", "coordinate8", "destinate8", "destignment1", "destribution8", "destinations2", "destication22", "destination8", "destinatetwo", "coordination8", "destinate4", "destinating4", "destication8", "destinations1", "destribution22", "destinationSecond", "descinationsSecond", "coordinate2", "Destination2", "destinations02", "descination1"], "tee": [" teea", " tec", "chee", "seee", "TEc", "etteee", "teea", "seae", "etteae", "tei", " tef", "lee", "TEe", "see", "chepe", " tei", "teec", "tec", "chei", " teee", "ettef", "leffe", "teae", " teec", "eeee", "eeec", "tepe", "ceea", "TEee", "teee", "eeffe", "sef", "ettee", " tepe", "ceee", "leee", "lepe", " teffe", "teffe", "cee", "lei", "chef", "TEea", " teae", "cec", "lef", "tef", "eee", "leec"]}}
{"id1": "9261777", "id2": "8754809", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"source": ["resource", "token", "use", "seed", "project", "zip", "string", "Source", "request", "view", "spec", "proxy", "inner", "service", "scope", "comment", "input", "options", "ource", "copy", "path", "empty", "slice", "force", "dest", "in", "original", "address", "shared", "single", "unit", "sample", "missing", "rule", "base", "element", "prefix", "url", "query", "config", "size", "name", "index", "flat", "sl", "session", "strip", "SOURCE", "image", "start", "sin", "result", "secure", "se", "data", "parse", "style", "target", "null", "id", "parent", "uri", "text", "info", "src", "site", "file", "sort", "template"], "destination": ["dominated", "desturation", " destinating", " destipping", "destinations", "domination", " destinator", "dependension", "coordinating", "destinating", "destipping", " destension", "homeignment", "Destinations", "destinator", "Destinator", "Destinating", "coordination", "Destination", "homeinated", "databaseuration", "destinated", "Destinated", "homeination", " destignment", "Destinate", "homeinator", "destinate", "distipping", "Destignment", "coordinate", "dependination", "dependipping", "dependinated", "domuration", "databaseinated", " destinated", "dominations", "destignment", "distension", "distinated", "coordinator", " destinate", "distination", "databaseinations", "databaseination", "Desturation", "destension"], "is": ["ib", "ics", "or", "us", "ip", "isa", "ios", "serv", "zip", "bs", "ens", "isl", "ois", "osi", "ir", "ob", "act", "ii", "was", "iris", "oss", "ci", "as", "ic", "api", "abs", "ais", "IS", "io", "ui", "in", "ins", "ri", "are", "ie", "fs", "obs", "init", "s", "Is", "out", "iss", "iso", "ar", "ops", "eni", "cos", "get", "isi", "isc", "sis", "i", "ori", "sin", "close", "mis", "bis", "se", "lis", "ai", "nis", "esi", "id", "es", "info", "src", "ris"], "os": ["or", "ks", "js", "us", "ol", "ios", "so", "bs", "ens", "ob", "osi", "op", "ies", "o", "mos", "dos", "oa", "oss", "as", "oise", "io", "ais", "sys", "aos", "boot", "bos", "oes", "acs", "ose", "fs", "obs", "s", "nos", "pos", "out", "oS", "vs", "ls", "los", "ops", "cos", "ot", "Os", "i", "ds", "ori", "oses", "ros", "socket", "ou", "es", "ends", "OS", "ss", "ow"], "buffer": ["seed", "position", "string", "channel", "uffer", "limit", "padding", "copy", "layer", "wave", "sequence", "feed", "buf", "slice", "queue", "number", "pad", "address", "header", "batch", "base", "server", "url", "size", "read", "Buffer", "iter", "value", "image", "writer", "bytes", "transfer", "page", "border", "result", "reader", "bb", "data", "null", "b", "buff", "flush", "binary", "reference"], "length": ["distance", "row", "section", "line", "of", "position", "ob", "string", "full", "volume", "depth", "limit", "character", "total", "shape", "lower", "Length", "power", "partial", "division", "match", "sequence", "slice", "number", "feed", "key", "ring", "object", "address", "count", "age", "weight", "l", "part", "url", "get", "load", "left", "size", "index", "code", "len", "value", "strip", "split", "start", "quote", "last", "level", "reader", "type", "data", "range", "point", "style", "duration", "id", "offset", "lock", "block", "width", "end"]}}
{"id1": "14567939", "id2": "21555906", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"baseHash": [" generateHash", "basehash", " generateSecret", " chainhash", "BaseFile", "Basehash", "baseFile", "BaseHash", " chainHash", "baseSecret", " generatehash", " chainFile", " chainSecret", " generateFile", "BaseSecret"], "name": ["Name", "names", "resource", "class", "n", "string", "host", "word", "secret", "named", "path", "key", "user", "object", "address", "create", "part", "base", "normal", "hello", "prefix", "definition", "image", "ame", "NAME", "hash", "member", "type", "data", "style", "account", "id", "parent", "alias", "file"], "password": ["pass", "attribute", "paste", "token", "username", "words", "seed", "sword", "string", "word", "secret", "priv", "input", "Password", "PASS", "wallet", "path", "key", "stroke", "auth", "wd", "profile", "device", "prefix", "phrase", "security", "code", "value", "hash", "diff", "data", "account", "pattern", "source", "crypt", "text", "padding"], "digest": ["modest", "Digr", "decEST", "digusher", " diger", "mdest", "decr", "Digester", " digusher", "signest", "Digested", "digr", " digger", "digested", "digester", "decest", "signer", "Digusher", "modester", "modested", "DigEST", " digester", "signusher", " digested", "moder", "signester", "digEST", "Diger", "diger", "Digger", "digger", "mdester", "Digest", "mdr", "mdEST", "decester", "signger"]}}
{"id1": "8000624", "id2": "1097146", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"CopyTo": ["copyFile", " copyTo", " transferFrom", " transferTo", "copyto", "CopyFrom", "Copyto", " copyFrom", " transferFile", " copyFile", " copyto", "copyTo", " transferto", "CopyFile", "copyFrom"], "dest": ["folder", "txt", "temp", "done", "class", "exit", "rest", "opt", "table", "dist", "bin", "destroy", "transform", " Dest", "path", "desc", "die", "object", "content", "sup", "comb", "w", "orig", "tmp", "delete", "flat", "filename", "Dest", "img", "output", "test", "data", "write", "them", "obj", "target", " destination", "source", "wb", "cont", "src", "name", "later", "file"], "in": ["fa", "In", "pull", "pass", "plus", "issue", "again", "n", "ini", "IN", "m", "cin", "inner", "din", "bin", "input", "as", "con", "wave", "pin", "ins", "ac", "conn", "inn", "kin", "up", "l", "connection", "init", "win", "s", "rin", "lin", "isin", "x", "gin", "thin", "f", "inside", "i", "nin", "image", "lib", "h", "sin", "login", "reader", "ax", "ln", "vin", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "temp", "or", "plus", "external", "not", "again", "outside", "n", "cache", "o", "ex", "call", "inner", "bin", "Out", "copy", "outer", "io", "outs", "this", "sync", "pin", "conn", "no", "user", "object", "our", "err", "up", "app", "part", "w", "net", "exec", "url", "x", "other", "off", "i", "nin", "image", "lib", "socket", "writer", "ext", "file", "output", "data", "ou", "OUT", "vert", "b", "target", "inc", "client", "name", "one"], "c": ["dc", "ch", "pc", "fc", "u", "cm", "n", "m", "col", "o", "ca", "pointer", "d", "comment", "abc", "ci", "ic", "xc", "sc", "char", "ct", "cf", "cu", "ac", "ce", "content", "C", "oc", "p", "cr", "cl", "cc", "l", "rc", "exc", "x", "config", "bc", "f", "enc", "e", "code", "i", "arc", "uc", "cb", "v", "r", "t", "cy", "ec", "esc", "buffer", "lc"]}}
{"id1": "18211588", "id2": "15645004", "code1": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"copyTextFile": [" copyLogSource", " copyLogContent", " copyLogSourceFile", "downloadTextSource", "downloadTextContent", " copyStringFile", " copyLogFile", " copyStringSourceFile", " copyStringSource", "downloadLogSourceFile", " copyBufferSourceFile", " copyTextContent", "downloadTextSourceFile", " copyStringContent", " copyBufferSource", " copyBufferFile", "downloadLogSource", "downloadLogContent", " copyBufferContent", " copyTextSource", " copyTextSourceFile", "downloadLogFile", "downloadTextFile"], "src": ["rss", "txt", "bh", "bs", "front", "spec", "ruby", "path", "ur", "sc", "dest", "rl", "loc", "gb", "s", "rc", "rob", "upload", "server", "url", "config", "sb", "sl", "filename", "sin", "img", "st", "ssl", "ources", "b", "sit", "source", "stream", "sel", "uri", "rb", "file"], "dst": ["drd", "sdrd", "fdrc", "ddest", "ndbl", "pnd", " dnd", "sdrc", "ndst", "pdest", "fdst", "snd", "sost", "drc", "fdrd", "post", "sdest", "sdst", "dbl", "ndrd", "pst", "dost", " dost", "dnd", "sst", "fdbl", " ddest", "sdbl", "ndrc"], "bis": ["oris", "bh", "ios", "bs", "ois", "bps", "ob", "osi", "obos", "http", "is", "inner", "rots", "iris", "abi", "ubis", "ais", "bits", "os", "banks", "obb", "ri", "boot", "bi", "fs", "obs", "pins", "BUS", "opus", "bes", "los", "ls", "phys", "cos", "bas", "bid", "sis", "ros", "sin", "bb", "lis", "parts", "fb", "tis", "bus", "lins", "binary", "ris"], "bos": ["ses", "ios", "ois", "bs", "osi", "DOS", "oks", "bps", "obos", "dos", "oops", "mos", "obo", "fits", "rots", "bin", "oss", "ubis", "bits", "os", "aos", "obb", "boot", "bi", "ubs", "oos", "oids", "obs", "opus", "bes", "los", "cos", "zo", "bas", "ob", "bott", "oses", "ros", "bys", "mis", "zos", "bies", "tis", "buff", "lins", "bones"], "buf": ["font", "bh", "grab", "vec", "c", "cas", "pb", "cv", "bin", "func", "fd", "bd", "feed", "box", "la", "pad", "length", "seq", "ab", "loc", "br", "comb", "bag", "ff", "lb", "orig", "rc", "tmp", "plug", "cur", "bc", "len", "blocks", "lim", "uf", "cap", "home", "uc", "bytes", "cb", "bb", "data", "feat", "b", "fb", "buff", "bf", "buffer", "wb", "rb"], "readsize": ["writename", "playname", "writeize", "blockSize", "readingempty", "readname", "writesize", " readaddress", "blockname", "playSize", "blockize", "rowspeed", "readempty", "readaddress", "readSize", " readspeed", "readingsize", "rowSize", "playspeed", " readize", "playsize", "writeempty", "blocksize", " readname", "readize", "writeaddress", "readingaddress", "rowname", " readSize", "readspeed", "readingSize", "writeSize", " readempty", "rowsize"]}}
{"id1": "4830847", "id2": "19096138", "code1": "    @Override\n    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {\n        final Connection connection = this.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id =  \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \";\n            if (contextName != null) {\n                queryString = queryString + \" context_name LIKE ? AND \";\n            }\n            if (dateFrom != null) {\n                queryString = queryString + \" start_timestamp >= ? AND \";\n            }\n            if (dateTo != null) {\n                queryString = queryString + \" start_timestamp <= ? AND \";\n            }\n            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);\n            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);\n            int indexCounter = 1;\n            if (contextName != null) {\n                preparedStatement.setString(indexCounter, contextName);\n                indexCounter = indexCounter + 1;\n            }\n            if (dateFrom != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            if (dateTo != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            preparedStatement.executeUpdate();\n            preparedStatement.close();\n            connection.commit();\n        } catch (final SQLException e) {\n            try {\n                connection.rollback();\n            } catch (final SQLException ex) {\n                JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex);\n            }\n            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());\n            throw new DatabaseException(\"Error deleting JVM statistics.\", e);\n        } finally {\n            this.releaseConnection(connection);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"deleteJvmStatistics": ["deletejVMStats", "deleteJVMConfiguration", "deleteJvmConfiguration", "deletejVMStatistics", "deleteJvmStats", "deleteJVMStatistics", "deletejvmConfiguration", "deletejvmHistory", "deleteJmiStatistics", "deleteJmiConfiguration", "deletejVMConfiguration", "deleteJmiStats", "deletejvmStats", "deleteJMXHistory", "deleteJVMStats", "deletejvmStatistics", "deleteJMXConfiguration", "deleteJVMHistory", "deleteJvmHistory", "deletejVMHistory", "deleteJMXStats", "deleteJMXStatistics", "deleteJmiHistory"], "contextName": [" contextDescription", "documentName", "ctxName", "sourceDescription", "ctxname", "conceptInfo", "sourceContext", "contextDescription", "languageName", "ctxContext", "channelType", "languagename", " contextAddress", "sourcename", "channelInfo", "documentInfo", "contextContext", "ctxInfo", " contextData", " contextInfo", "contextType", "ctxType", "contextData", "contextInfo", "conceptType", "ctxDescription", " contextname", " contextContext", "documentAddress", "contextname", "contextAddress", "conceptName", "languageData", "channelName", "ContextData", "Contextname", "sourceName", "ContextName", "conceptAddress"], "dateFrom": ["DateBetween", " dateRange", " dateBetween", "dayFrom", "dateBefore", "updatefrom", "moduleTo", "DateStart", "dateRange", "moduleBefore", "moduleFrom", "updateTo", "DateFrom", "Datefrom", "timeFrom", " dateBefore", "rangeTo", "dayTo", "datFrom", "DateRange", "timeStart", "updateStart", "rangeRange", "modulefrom", "rangeBetween", "updateFrom", "DateTo", "dateBetween", "timeTo", "datefrom", " datefrom", "dateStart", "dayfrom", "rangeFrom", "timefrom", "datBefore", "datTo"], "dateTo": ["gradeto", "gradeUntil", "dayFrom", "resourceTO", "DateUntil", "Dateto", "dateTO", "dayTO", "resourceUntil", "DateTarget", "datesTO", "resourceFrom", "DateFrom", "resourceTo", "dateUntil", "dateTarget", " dateUntil", "dataTo", " dateto", "dayTo", "dayUntil", "DateTO", "dataTO", "dataUntil", "gradeTo", "datato", " dateTarget", "DateTo", "dateto", "gradeTO", "gradeFrom", "datesTo", "datesUntil", "gradeTarget", "datesto", " dateTO"], "connection": ["application", "class", "subject", "section", " Connection", "function", "description", "position", "c", "Connection", "management", "environment", "context", "statement", "table", "channel", "character", "condition", "ion", "log", "con", "manager", "BC", "engine", "driver", "cf", "database", "relation", "client", "conn", "handler", "mc", "document", "communication", "server", "query", "builder", "commit", "config", "index", "e", "session", "socket", "writer", "result", "directory", "connected", "message", "lock", "connect", "collection", "db", "reference"], "queryString": ["qStr", "scriptstring", "QueryArray", "workstring", " queryInformation", "updateString", "querySet", "querySite", "modulestring", "scriptString", "viewStatement", "QuerySingle", "reportSite", "answerPassword", " queryStatement", " querySite", " queryText", "questionArray", "updateArray", "viewstring", " queryArray", "queryPassword", "scriptFloat", "QueryText", "reportInformation", "featurestring", "featureString", "qstring", " querySet", "workStatement", "updatestring", "questionString", "qText", "QueryStr", "featureSQL", "updateText", "qString", "queryText", "featureStream", " querySQL", "reportPassword", "QueryString", "querySingle", "reportstring", "reportStr", "workSQL", "scriptStream", "QueryInformation", " queryStr", "queryStatement", "moduleStr", "queryArray", "questionSet", "qInformation", "querySQL", "queryInformation", "querystring", "QueryStatement", "featureStatement", "updateSet", "queryStream", "qSingle", "viewArray", "moduleStatement", " querystring", "reportString", "queryStr", "queryFloat", " querySingle", "updateStr", "workString", "updateInformation", "answerString", "Querystring", " queryFloat", "questionstring", "featureFloat", " queryPassword", "moduleString", "answerSite", "viewString", " queryStream", "answerstring"], "preparedStatement": ["conparedPool", "prepasterParser", "preparedString", "prequalifiedstatement", "preressedComment", "prechedStatement", "convenStatement", "preasterstatement", "refparedstatement", "prenamedstatement", "preapedName", "prearedTransaction", "PreqlSession", "preparedParser", "promchedStatement", "preachedstatement", "preferredStat", "preparedstatement", "prequalifiedAlias", "preressedParser", "preparedSession", "preapedStatement", "PreparedTransaction", "preliedPool", "prepasterstatement", "preasterStatement", "preiledstatement", "typeifiedstatement", "preifiedstatement", "preparedModule", "prechedName", "preferredString", "preparedName", "promparedName", "prepasterStatement", "prepparedComment", "preferredPool", "typeparedstatement", "prenamedStat", "preliedStatement", "preachedStatement", "promchedName", "preparedBody", "prepasterComment", "preliedString", "prevenStat", "prevenPool", "conparedString", "refapedStat", "preressedstatement", "PreqlModule", "preapedInsert", "refapedStatement", "prearedStatement", "prevertedStatement", "typeparedStatement", "preparedInsert", "preqlTransaction", "PreparedModule", "prevertedModule", "preplannedstatement", "prevenString", "preparedAlias", "preapedStat", "refapedstatement", "prenamedStatement", "preasterParser", "conparedStatement", "promparedStatement", "preparedStat", "prequalifiedStatement", "preferredStatement", "preparedTransaction", "prearedModule", "prevertedTransaction", "prechedstatement", "preifiedStatement", "preiledInsert", "preliedStat", "prevenStatement", "convenString", "preifiedBody", "prepparedParser", "prepparedStatement", "prepparedstatement", "PreparedSession", "promparedInsert", "preqlModule", "preqlSession", "typeparedAlias", "convenPool", "preqlStatement", "promparedstatement", "preplannedParser", "refparedStatement", "preplannedStatement", "prevertedSession", "promchedstatement", "typeifiedBody", "convenStat", "preifiedAlias", "preachedStat", "prearedSession", "preressedStatement", "prechedAlias", "preapedstatement", "promchedInsert", "prequalifiedBody", "prechedBody", "typeifiedAlias", "preparedPool", "typeifiedStatement", "preasterComment", "preiledName", "preiledStatement", "conparedStat", "prechedInsert", "preplannedComment", "PreparedStatement", "preparedComment", "refparedStat", "PreqlTransaction", "typeparedBody", "PreqlStatement"], "indexCounter": ["objectcounter", "sliceCounter", "lengthCounter", "indexStore", "siteMaster", "indexOffset", "runCounter", "positionCenter", "lengthClock", "viewParser", "positionOffset", "positionVector", "objectCounter", "IndexCounter", "indexVector", "objectCenter", " indexBar", "siteParser", "positionClock", "runMaster", "lengthOffset", "matchClock", "contextNumber", "searchCounter", "showClock", "styleStore", "intVector", "siteCenter", "indexMaster", "matchCounter", "dateClock", "viewCounter", "viewCenter", "indcounter", "pullcounter", " indexClock", "searchNumber", "indexController", "intcounter", "showCounter", "exampleCounter", "positioncounter", "positionCounter", "IndexClock", "lengthcounter", "requestCounter", "IndexMaster", "indexNumber", "examplecounter", "dateCounter", "dateStore", "indexcounter", "searchcounter", "Indexcounter", "datecounter", "stylecounter", "intCounter", "dateCenter", "exampleOffset", "pullClock", "sliceCenter", "sliceClock", " indexController", "indexClock", "indexBar", " indexOffset", "sliceMaster", "positionMaster", "requestcounter", "siteCounter", "searchClock", " indexcounter", "contextClock", "pullCounter", "positionBar", "exampleBar", "indCounter", "showOffset", "indexCenter", "indexParser", "pullStore", "matchOffset", "showController", "viewcounter", "styleCounter", "runcounter", " indexNumber", "styleClock", "requestVector", "indCenter", "IndexParser", "matchController", "contextcounter", "contextCounter", "IndexCenter", "viewMaster"]}}
{"id1": "10131427", "id2": "22536033", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "copyChannel", "CopyFiles", "copyfile", "transferFiles", "copyFiles", "CopyChannel", " copyChannel", "CopyFile", "transferChannel", "transferfile"], "in": ["resource", "In", "or", "again", "at", "ini", "c", "IN", "m", "ex", "inner", "bin", "input", "copy", "io", "ins", "ac", "min", "inn", "base", "url", "work", "config", "index", "i", "image", "a", "login", "reader", "diff", "data", "b", "inc", "id", "source", "buffer", "name", "file"], "out": ["temp", "external", "at", "n", "c", "string", "cache", "o", "ex", "Out", "copy", "io", "outs", "dest", "conn", "object", "p", "part", "w", "base", "connection", "prefix", "exec", "x", "off", "image", "writer", "v", "output", "data", "OUT", "point", "target", "source", "buffer", "client", "name", "file"], "sourceChannel": [" sourceSocket", "srcChan", "SourceStream", "srcConnection", "Sourcechannel", "ourceChan", "targetChan", "srcSocket", "SourceManager", " sourcechannel", "ourceStream", "ourcechannel", "srcQueue", " sourceQueue", "sourceConnection", " sourceConnection", "SourceChan", "srcStream", "srcManager", " sourceChan", "sourcechannel", "SourceChannel", "SourceConnection", "sourceSocket", "SourceSocket", "sourceQueue", "sourceManager", "ourceChannel", "targetchannel", "SourceQueue", "sourceStream", "targetChannel", "srcChannel", " sourceStream", " sourceManager", "sourceChan", "targetStream"], "destinationChannel": ["destinatedChan", "DestinatorConnection", "destationChan", "DestinatorCh", "destinatorchannel", "destinationsStream", "destinatorStream", "Destinatorchannel", "DestinationConnection", "DestinationChannel", "destinationchannel", "DestinationCh", "destinationCh", "destinateChannel", "DestinationStream", "destinationsConnection", "destinatedCh", "destinationStream", "destinateConnection", "DestinationChan", "destinationChan", "destinatorChan", "Destinationchannel", "destinationsChannel", "destinatorChannel", "DestinatorChannel", "destationCh", "destationchannel", "destinatedConnection", "destinateStream", "destationConnection", "DestinatorStream", "destinationschannel", "destinatorCh", "destinatedChannel", "destationChannel", "destinatorConnection", "destinatechannel", "destinationConnection", "DestinatorChan"]}}
{"id1": "6963063", "id2": "6371607", "code1": "    public static void main(String args[]) {\n        int[] mas = { 3, 5, 6, 9, 1, -3, -4, -88 };\n        int sort = 0;\n        for (int j = 0; j < (mas.length); j++) {\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    sort = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = sort;\n                }\n            }\n        }\n        for (int i = 0; i < mas.length; i++) {\n            System.out.print(\" \" + mas[i]);\n        }\n    }\n", "code2": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"mas": ["fa", "faces", "names", "lambda", "inas", "central", "ms", "ama", "asa", "cas", "ima", "lam", "mos", "spec", "sha", "as", "mat", "params", "phas", "images", " ma", "os", "sa", "la", "meta", "ins", "ums", "ias", "amps", "afi", "xs", "Las", "months", "ra", "MA", "forms", "missing", "alpha", "mc", "phi", "ams", "pos", "ta", "amas", "pa", "ls", "ga", "ia", "mast", "ma", "astics", "asia", "cs", "bas", "mag", "space", "marks", "a", "features", "mis", "rules", "cats", "data", "parts", "nas", "mm", "ras", "las", "mad", "ages", "asm", "mes"], "sort": ["use", "cmp", "position", "g", "ii", "o", "ist", "master", "adjust", "lower", "label", "search", "edit", "list", "slice", "ji", "place", "ort", "num", "orient", "min", "seq", "loc", "alias", "err", "alpha", "default", "l", "part", "init", "order", "pos", "replace", "scale", "s", "size", "index", "ul", "pre", "hide", "split", "axis", "lib", "start", "ind", "filter", "diff", "parse", "type", "alt", "style", "vert", "Sort", "sign", "id", "parent", "offset", "update", "par"], "j": ["js", "si", "u", "n", "k", "ii", "m", "pi", "y", "o", "d", "is", "ci", "J", "z", "ji", "ui", "num", "bi", "ie", "p", "it", "l", "I", "x", "f", "oi", "li", "ind", "q", "a", "h", "v", "jp", "b", "xi", "jc", "ij"], "i": ["iu", "hi", "temp", "si", "qi", "ip", "u", "multi", "ini", "ii", "k", "m", "pi", "c", "o", "inner", "abi", "ci", "ij", "di", "io", "api", "z", "slice", "ji", "ui", "in", "ri", "bi", "ie", "it", "phi", "init", "I", "fi", "x", "uli", "index", "f", "cli", "e", "oi", "li", "ori", "a", "ni", "h", "gi", "v", "ti", "mi", "ai", "yi", "jp", "data", "b", "xi", "id", "info", "uri", "ix", "mu", "ik", "lc"]}}
{"id1": "1443205", "id2": "20602651", "code1": "    private void redirect(TargetApp app, HttpServletRequest request, HttpServletResponse response) throws IOException {\n        URL url = new URL(app.getUrl() + request.getRequestURI());\n        s_log.debug(\"Redirecting to \" + url);\n        URLConnection urlConnection = url.openConnection();\n        Map<String, List<String>> fields = urlConnection.getHeaderFields();\n        for (String key : fields.keySet()) {\n            StringBuffer values = new StringBuffer();\n            boolean comma = false;\n            for (String value : fields.get(key)) {\n                if (comma) {\n                    values.append(\", \");\n                }\n                values.append(value);\n                comma = true;\n            }\n            if (key != null) {\n                response.setHeader(key, values.toString());\n            } else {\n                response.setStatus(Integer.parseInt(values.toString().split(\" \")[1]));\n            }\n        }\n        InputStream in = urlConnection.getInputStream();\n        try {\n            ServletOutputStream out = response.getOutputStream();\n            byte[] buff = new byte[1024];\n            int len;\n            while ((len = in.read(buff)) != -1) {\n                out.write(buff, 0, len);\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    protected void readURL(URL url) {\n        InputStream istream = null;\n        InputStreamReader isr = null;\n        BufferedReader in = null;\n        try {\n            istream = url.openStream();\n            isr = new InputStreamReader(istream);\n            in = new BufferedReader(isr);\n            String line = in.readLine();\n            while (null != line) {\n                System.out.println(line);\n                line = in.readLine();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            IOUtilities.close(in);\n            IOUtilities.close(isr);\n            IOUtilities.close(istream);\n        }\n    }\n", "label": 0, "substitutes": {"redirect": [" Redirection", "redrict", " Redrict", "Redicate", " Redicate", "Redrict", "rewrict", " Redirect", "Redirection", "rewirection", "redicate", "rewicate", "Redirect", "rewirect", "redirection"], "app": ["resource", "App", "application", "Application", "container", "ip", "project", "instance", "host", "APP", "apps", "context", "http", "service", "self", "api", "auth", "framework", "pp", "build", "browser", "base", "install", "model", "server", "config", "session", "admin", "page", "plugin", "web", "client", "ace", "form", "db"], "request": ["resource", "application", "requ", "position", "instance", "rec", "method", "view", "Request", "xml", "input", "self", "report", "queue", "user", "child", "object", "connection", "model", "event", "server", "query", "config", "complete", "session", "record", "remote", "result", "page", "data", "req", "web", "message", "info", "buffer", "client", "version", "create"], "response": ["Response", "resource", "application", "status", "function", "serv", "description", "full", "respond", "cache", "respons", "site", "host", "reply", "http", "view", "proxy", "service", "report", "wave", "feed", "onse", "json", "object", "re", "resp", "connection", "document", "model", "server", "index", "pool", "session", "success", "image", "res", "result", "page", "output", "error", "req", "message", "uri", "client", "body", "collection", "fire"], "url": ["resource", "zip", "host", "http", "proxy", "service", "www", "URL", "log", "ll", "path", "api", "Url", "impl", "object", "address", "bel", "loc", "l", "connection", "base", "ls", "server", "location", "config", "sl", "f", "link", "image", "page", "ssl", "bb", "b", "web", "uri", "client", "db", "file"], "urlConnection": [" urlClosure", "stringClosure", "controlConnection", "urlConn", "httpConn", "sslconnection", " urlConstruction", "webconnection", " urlClient", "sslConnect", "sslConnection", "httpConnection", "stringClient", "urlConstruction", " urlconnection", "URLconnection", " urlConn", "webConnection", "controlConnect", "urlClosure", "stringConn", "urlconnection", " urlConnect", "controlConstruction", "httpClosure", "controlconnection", "stringConnection", "URLConnect", "webConnect", "urlClient", "httpClient", "sslConstruction", "urlConnect", "URLConnection"], "fields": ["views", "classes", "pps", "maps", "lines", "loads", "ids", "headers", "forces", "guards", "drivers", "relations", "objects", "details", "styles", "files", "events", "players", "groups", "members", "plugins", "properties", "ums", "locks", "forms", "limits", "qs", "cells", "strings", "keys", "balls", "field", "services", "frames", "types", "phones", "owners", "ips", "rules", "features", "states", "flows", "data", "models", "holders", "comments", "lists", "users", "checks", "rows"], "key": ["property", "entry", "row", "section", "ip", "Key", "k", "string", "zip", "host", "step", "col", "word", "title", "version", "service", "money", "path", "label", "match", "KEY", "patch", "length", "letter", "header", "count", "cookie", "alpha", "default", "rule", "part", "base", "order", "tax", "element", "prefix", "query", "variable", "keys", "index", "foo", "field", "link", "code", "date", "q", "feature", "i", "check", "val", "data", "type", "point", "id", "pattern", "cy", "uri", "source", "ace", "name", "reason"], "values": ["pages", "boxes", "ks", "views", "words", "codes", "maps", "bs", "lines", "ones", "results", "errors", "headers", "Values", "options", "gets", "params", "objects", "versions", "files", "events", "ins", "groups", "properties", "changes", "forms", "limits", "roots", "s", "cells", "strings", "vs", "als", "ops", "keys", "settings", "ports", "its", "services", "blocks", "frames", "bytes", "v", "vals", "rules", "states", "data", "items", "ps", "es", "lists", "iv", "ends", "rows"], "value": ["property", "resource", "item", "entry", "attribute", "string", "current", "option", "version", "comment", "service", "language", "search", "object", "letter", "default", "element", "variable", "field", "Value", "format", "val", "v", "member", "VALUE", "data", "write", "style", "null", "end", "message", "source", "name", "reference"], "comma": ["lamenta", "coma", " commas", "cyenta", "cyntax", "comenta", "COMma", "comment", "compada", "ombo", "Coma", "Combo", "lamma", "ompa", "commas", "cypa", "lamntax", " comment", "compma", "comada", "ucpa", "COMmas", "cyma", "lampa", "oma", "ucbo", "omma", "conma", "Comma", "conpa", "comntax", "ucma", "compmas", "compment", "COMment", "COMada", "conntax", "combo", "Compa", "compa", "uca", " comada", "conenta"], "in": ["In", "again", "serv", "ini", "c", "IN", "ex", "is", "din", "inner", "bin", "input", "ic", "as", "con", "pin", "ins", "ac", "min", "inn", "err", "isin", "init", "win", "s", "lin", "gin", "read", "f", "inside", "i", "nin", "a", "socket", "login", "file", "reader", "data", "r", "b", "inc", "id", "client"], "out": ["exit", "again", "serv", "o", "exp", "ex", "inner", "bin", "Out", "copy", "sum", "down", "io", "outs", "sync", "ins", "conn", "user", "err", "up", "net", "w", "exec", "off", "res", "ext", "output", "data", "raw", "obj", "OUT", "b", "inc", "extra"], "buff": ["mb", "txt", "ch", "fe", "grab", "ob", "uff", "feed", "char", "buf", "cod", "pad", "qq", "length", "pp", "boot", "batch", "bl", "comb", "ph", "ff", "fab", "gb", "bag", "cell", "cond", "cp", "cmd", "load", "now", "sb", "f", "uf", "cb", "bb", "data", "Buff", "fb", "b", "pack", "flush", "back", "buffer", "lock", "text", "bf", "rb"], "len": ["line", "n", "limit", "str", "fin", "ler", "bin", "le", "Len", "num", "length", "min", "count", "err", "l", "pos", "lin", "all", "coll", "size", "read", "iter", "li", "pre", "lim", "el", "cap", "ind", "val", "off", "type", "data", "fl", "en", "id", "lf", "rev", "ln", "db", "end"]}}
{"id1": "11616716", "id2": "8320469", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 0, "substitutes": {"getCMSResultAsStream": ["getCMSResultAsSteam", "getCMSResultasStream", "getCMSResultInSteam", "getCMSResponseAsStream", "getCMSResultWithStream", "getCMSResponseasReader", "getCMSResponseasStream", "getCMSResultasReader", "getCMSResultInFile", "getCMSResponseasFile", "getCMSResponseAsFile", "getCMSResponseAsReader", "getCMSResponseAsSteam", "getCMSResultAsFile", "getCMSResponseasSteam", "getCMSResultInStream", "getCMSResultasSteam", "getCMSResultasFile", "getCMSResultWithReader", "getCMSResultWithSteam", "getCMSResultInReader", "getCMSResultAsReader", "getCMSResultWithFile"], "rqlQuery": [" rsqlQuery", "srqlquery", " rqlquery", "rqlQ", "rSQLQu", "rqlquery", "rsqlQuery", "riliQu", "srQLQu", " rsqlMethod", "riliquery", " rqlQu", "rQLQ", "rsqlquery", "rSQLquery", "rqlMethod", "rSQLMethod", "srQLquery", "rQLMethod", "rSQLQuery", "rsqlQu", "srqlQu", "rqlQu", "rQLQu", " rqlMethod", " rsqlQu", "riliQ", "rQLQuery", "riliQuery", "rsqlMethod", "srQLQuery", "srQLQ", "rQLquery", " rsqlquery", "srqlQuery", "srqlQ", "rsqlQ"], "osr": ["cosrt", "opsR", "ysr", "ysrt", " osrm", "cosfr", "yscr", "osfr", "oswer", "usrr", "ossr", "osrw", "iosr", "osserr", "otsr", "obsr", "ossrw", "OSrt", "osrr", "osspr", " ospr", "ossrm", "usrs", "otsrm", "iosrw", "osrm", "cosr", "losfr", "uspr", "otssr", "OSrr", "osssr", "ossrs", "otspr", "oscr", "bosR", "ossrt", "usrt", "usrw", "opsrar", " osfr", "oserr", "obsrar", "usr", "osrt", "ossrar", "losrr", "userr", "losrt", "obsR", "osR", "OSr", " osrar", "cosrr", "losr", " osrt", "bosrar", "ysrar", " oscr", "obswer", "ospr", " osrr", "osrar", "bosr", "boswer", "osscr", " ossr", "OSerr", "osrs", "iosrs", "iospr", "opsr", "ossrr", "opswer"], "url": ["resource", "ob", "string", "channel", "host", "blog", "http", "www", "URL", "path", "ll", "open", "Url", "rl", "l", "connection", "base", "ls", "server", "config", "sl", "f", "nl", "socket", "page", "ssl", "fl", "r", "b", "fb", "web", "uri", "source", "client", "org", "file", "lc"], "conn": ["dc", "ch", "pc", "n", "c", "Connection", "pr", "act", "ca", "col", "http", "Conn", "ann", "oss", "conv", "ci", "ctx", "con", "open", "rt", "sync", "attr", "ct", "client", "fn", "loc", "p", "err", "cr", "l", "connection", "net", "cn", "rc", "cp", "exec", "server", "coll", "cur", "reg", "f", "enc", "wrapper", "h", "cb", "rn", "ssl", "nt", "en", "nc", "ec", "connect", "org", "db", "lc"]}}
{"id1": "17475530", "id2": "942693", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"testAddLinkToImage": ["testAddLinkOfLink", "testAddLinkstoFile", "testAddLinksToImage", "testAddLinkOfImage", "testAddLinkstoPicture", "testAddLinkOfPicture", "testAddLinkstoImage", "testAddLinkstoLink", "testAddLinkFromImage", "testAddLinkOfFile", "testAddLinktoImage", "testAddLinktoLink", "testAddLinkToLink", "testAddLinkToFile", "testAddLinksToLink", "testAddLinksToFile", "testAddLinkToPicture", "testAddLinktoPicture", "testAddLinkFromPicture", "testAddLinksToPicture", "testAddLinktoFile", "testAddLinkFromLink", "testAddLinkFromFile"], "in": ["resource", "In", "or", "pass", "token", "stream", "again", "serv", "at", "ini", "n", "IN", "m", "cin", "ex", "exp", "xml", "is", "din", "version", "bin", "with", "input", "copy", "as", "path", "con", "pin", "ins", "doc", "ac", "min", "conn", "inn", "err", "isin", "connection", "win", "rin", "out", "exec", "url", "get", "work", "gin", "index", "f", "i", "nin", "el", "image", "socket", "val", "login", "ssl", "reader", "diff", "data", "ax", "r", "inc", "id", "source", "uri", "name", "file"]}}
{"id1": "20028790", "id2": "7846688", "code1": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public void postData(String protocol, String host, String form, String data) throws Exception {\n        if ((protocol == null) || (protocol.equals(\"\"))) {\n            protocol = DEFAULT_PROTOCOL;\n        }\n        if ((host == null) || (host.equals(\"\"))) {\n            host = DEFAULT_HOST;\n        }\n        if (form == null) {\n            form = DEFAULT_FORM;\n        }\n        if (data == null) {\n            throw new IllegalArgumentException(\"Invalid data\");\n        }\n        URL url = new URL(protocol, host, form);\n        URLConnection con = url.openConnection();\n        con.setDoOutput(true);\n        con.setDoInput(true);\n        con.setUseCaches(false);\n        con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"Content-length\", String.valueOf(data.length()));\n        PrintStream out = new PrintStream(con.getOutputStream(), true);\n        out.print(data);\n        out.close();\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        while (in.readLine() != null) {\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"setBundleInfoName": ["setBundleIdList", "setBindingIdPart", "setBindingIdName", "setBundleInformationDefault", "setBundleInfoPart", "setBindingIdList", "setBundleIdPart", "setBundleInformationList", "setBundleInformationName", "setBindingIdDefault", "setBundleInformationPart", "setBundleIdDefault", "setBundleIdName", "setBindingInfoDefault", "setBundleDirPart", "setBindingInfoPart", "setBundleDirList", "setBindingInfoList", "setBundleInfoList", "setBundleDirDefault", "setBindingInfoName", "setBundleInfoDefault", "setBundleDirName"], "location": ["folder", "resource", "library", "position", "description", "string", "href", "LOC", "xml", "area", "station", "region", "language", "node", "URL", "path", "database", "content", "address", "loc", "l", "base", "layout", "Location", "server", "loader", "link", "localhost", "filename", "remote", "directory", "data", "type", "point", "message", "selection", "uri", "site", "file"], "list": ["entry", "group", "there", "we", "keep", "string", "table", "see", "sequence", "listed", "queue", "tree", "the", "pair", "object", "mentioned", "LIST", "batch", "cl", "l", "part", "all", "chain", "coll", "load", "array", "cli", "detail", "i", "set", "li", "record", "result", "range", "data", "stack", "lists", "parent", "collection", "name", "later"], "url": ["resource", "string", "http", "service", "URL", "io", "open", "Url", "user", "address", "bel", "orb", "loc", "lr", "browser", "err", "l", "connection", "base", "server", "plug", "sl", "f", "socket", "file", "ssl", "bb", "reader", "data", "r", "b", "jar", "uri", "stream", "buffer", "source", "org", "fr"], "br": ["Br", "ch", "bh", "ob", "brush", "str", "ler", "ber", "io", "yr", "buf", "sr", "bro", "BR", "tr", "mr", "bridge", "gr", "er", "err", "bl", "cr", "browser", "ar", "arr", "dr", "sp", "bc", "bar", "i", "res", "handle", "result", "bb", "reader", "img", "data", "hr", "obj", "r", "b", "jar", "stream", "body", "rb", "fr"], "line": ["band", "inline", "look", "entry", "row", "pass", "status", "section", "zip", "string", "lines", "word", "LINE", "str", "character", "phase", "le", "Line", "response", "log", "sync", "letter", "header", "lr", "cl", "l", "rule", "connection", "up", "part", "lin", "cell", "shell", "license", "non", "link", "e", "code", "nl", "strip", "split", "lo", "page", "result", "error", "data", "parse", "style", "b", "lf", "job", "source", "lock", "text", "block", "name", "file", "lc"], "pos1": ["position3", "posOne", "index0", "part2", "posN", "Pos1", "pos2", "index1", "Pos2", "POSOne", "Pos3", "POS3", "position2", "Pos0", "PosN", "index2", "PosOne", " posOne", "POSN", "part1", " pos3", "positionOne", "part3", "pos0", "indexOne", "pos3", "position1", "POS1", " pos2", "position0", " posN"], "bundleSymbolicName": ["bundleSyMBolicPart", "bundleSyMBicalName", "bundleSymbicalName", "bundleSyembicKey", "bundleSymbigiousPath", "bundleSymbularName", "bundleSysembuousname", "bundleSymbuousUrl", "bundleSymbicModule", "bundleSymbicalString", "bundleSysembolicName", "bundleSymbolicname", "bundleSyMBolicPath", "bundleSymbicalInfo", "bundleSymbularPart", "bundleSymbolicPart", "bundleSymbriticalname", "bundleSymbicalKey", "bundleSymbigiousString", "bundleSymbicallyUrl", "bundleSymbillyKey", "bundleSymbriticalName", "bundleSysembuousName", "bundleSyembicName", "bundleSyMBolicName", "bundleSymbriticalUrl", "bundleSymbicallyWord", "bundleSymbillyInfo", "bundleSymbolicWord", "bundleSymbolicString", "bundleSymbicalPart", "bundleSyembolicModule", "bundleSymbularPath", "bundleSymbuousname", "bundleSymbillyModule", "bundleSysembolicWord", "bundleSyembolicKey", "bundleSymbicalPath", "bundleSymbolicKey", "bundleSymbriticalWord", "bundleSymbicName", "bundleSymbicalModule", "bundleSyMBicalPath", "bundleSyembolicName", "bundleSymbicallyname", "bundleSyembicInfo", "bundleSymbigiousName", "bundleSymbicKey", "bundleSyMBolicString", "bundleSymbillyName", "bundleSyMBicalPart", "bundleSysembolicname", "bundleSyembicModule", "bundleSymbigiousPart", "bundleSymbicInfo", "bundleSymbolicInfo", "bundleSymbularString", "bundleSymbuousWord", "bundleSysembolicUrl", "bundleSysembuousUrl", "bundleSymbicallyName", "bundleSyMBicalString", "bundleSymbuousName", "bundleSymbolicUrl", "bundleSymbolicModule", "bundleSysembuousWord", "bundleSyembolicInfo", "bundleSymbolicPath"], "bundleName": ["rbpluginname", "bridgeName", "rbundleType", "bendorName", "bblID", "bpackageDesc", "rbpluginType", "bpluginType", "baffleInfo", "rbpluginInfo", "bundleID", "bendorType", "rbundlename", "bblName", "babiname", "bpluginInfo", "bpackagename", "Bpackagename", "bendorID", "baffleType", "rbundleName", "BendorName", "bblInfo", "Bundlename", "Bendorname", "babiInfo", "boodleID", "boodlename", "BundleID", "bundleDesc", "bpackageInfo", "rbpluginName", "babiName", "boodleName", "BundleDesc", "BendorInfo", "bridgename", "BpackageDesc", "baffleName", "bendorname", "bridgeInfo", "BendorID", "bpluginname", "babiDesc", "BpackageName", "BundleName", "bendorInfo", "bafflename", "boodleInfo", "bpackageName", "BundleInfo", "bridgeDesc", "bblname", "rbundleInfo", "bundlename", "BpackageInfo", "bundleInfo", "bpluginName", "bundleType"], "info": ["entry", "of", "zip", "string", "op", "py", "fo", "comment", "api", "ignore", "key", "object", "child", "archive", "bug", "def", "alias", "handler", "part", "base", "tf", "fw", "index", "INFO", "link", "f", "i", "off", "li", "by", "image", "start", "check", "inf", "extra", "result", "gi", "next", "diff", "error", "data", "type", "parse", "obj", "filter", "b", "Info", "id", "available", "name", "file", "end"]}}
{"id1": "20247400", "id2": "1798720", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "label": 1, "substitutes": {"in": ["In", "pass", "token", "again", "n", "c", "IN", "din", "inner", "bin", "input", "con", "this", "ins", "inn", "p", "l", "part", "isin", "s", "win", "connection", "gin", "config", "f", "i", "nin", "a", "image", "socket", "h", "login", "reader", "diff", "data", "r", "b", "inc", "parent", "stream", "client", "source"], "out": ["temp", "group", "window", "line", "again", "cache", "channel", "word", "ex", "o", "call", "exp", "str", "comment", "inner", "Out", "msg", "log", "outer", "io", "list", "sys", "user", "conn", "err", "print", "up", "connection", "w", "prefix", "exec", "server", "pool", "dump", "i", "off", "image", "socket", "writer", "page", "v", "ext", "output", "error", "write", "obj", "OUT", "r", "debug", "style", "inc", "lock", "source", "client", "console", "name", "file", "flow"], "buffer": ["slave", "window", "channel", "cache", "context", "uffer", "limit", "bin", "pause", "input", "abi", "layer", "wave", "feed", "buf", "queue", "slice", "pad", "length", "header", "count", "batch", "document", "base", "server", "config", "size", "loader", "read", "Buffer", "f", "iter", "bar", "writer", "border", "transfer", "result", "reference", "output", "reader", "data", "null", "b", "fb", "buff", "flush", "offset", "binary", "source", "flow"]}}
{"id1": "2808955", "id2": "11154758", "code1": "    @Override\n    public EntrySet read(EntrySet set) throws ReadFailedException {\n        if (!SourceCache.contains(url)) {\n            SSL.certify(url);\n            try {\n                super.setParser(Parser.detectParser(url.openStream()));\n                final PipedInputStream in = new PipedInputStream();\n                final PipedOutputStream forParser = new PipedOutputStream(in);\n                new Thread(new Runnable() {\n\n                    public void run() {\n                        try {\n                            OutputStream out = SourceCache.startCaching(url);\n                            InputStream is = url.openStream();\n                            byte[] buffer = new byte[100000];\n                            while (true) {\n                                int amountRead = is.read(buffer);\n                                if (amountRead == -1) {\n                                    break;\n                                }\n                                forParser.write(buffer, 0, amountRead);\n                                out.write(buffer, 0, amountRead);\n                            }\n                            forParser.close();\n                            out.close();\n                            SourceCache.finish(url);\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }).start();\n                super.setIos(in);\n            } catch (Exception e) {\n                throw new ReadFailedException(e);\n            }\n            return super.read(set);\n        } else {\n            try {\n                return SourceCache.get(url).read(set);\n            } catch (IOException e) {\n                throw new ReadFailedException(e);\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        FileOutputStream fos = null;\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String filename = \"i.exe\";\n            fos = new FileOutputStream(filename);\n            client.retrieveFile(\"/\" + filename, fos);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fos != null) {\n                    fos.close();\n                }\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"read": ["ping", "resource", "reads", "run", "ry", "stream", "scan", "send", "readable", "current", "reading", "request", "fill", "select", "view", "http", "input", "copy", "READ", "ic", "search", "open", "feed", "add", "process", "skip", "content", "build", "play", "print", "Read", "weak", "exec", "find", "query", "get", "load", "work", "wait", "index", "iter", "start", "check", "close", "socket", "next", "reader", "parse", "write", "data", "es", "update", "block", "create"], "set": ["resource", "entry", "or", "setting", "use", "seed", "send", "cache", "site", "context", "spec", "sets", "src", "state", "sync", "object", "store", "rule", "init", "base", "setup", "server", "url", "get", "load", "config", "SET", "size", "settings", "ut", "session", "start", "reset", "ssl", "test", "type", "parse", "id", "source", "update", "et", "name", "end"], "in": ["resource", "In", "pull", "again", "ini", "cache", "IN", "inner", "bin", "input", "ic", "con", "io", "pin", "ins", "on", "min", "inn", "p", "it", "init", "win", "url", "gin", "f", "i", "image", "socket", "login", "ssl", "reader", "data", "spin", "inc", "id", "source", "client", "src", "file"], "forParser": ["ofListener", " forReader", "ofJar", "withFile", "ForFile", " forJar", "forReader", "ForListener", "withJar", "withparser", "ForJar", "forJar", "forparser", "foreReader", "foreParser", " forparser", "ofReader", "forFile", "foreparser", "forListener", "foreMaster", "Forparser", "ForMaster", "forMaster", "ForParser", "ofParser", " forFile", "withParser", " forListener", "ForReader", " forMaster"], "out": ["again", "cache", "o", "ex", "http", "inner", "bin", "Out", "copy", "outer", "log", "io", "can", "os", "outs", "co", "sync", "conn", "err", "up", "app", "init", "net", "exec", "url", "cli", "i", "image", "socket", "writer", "to", "page", "ssl", "output", "ext", "OUT", "null", "inc", "parent", "source", "client", "file"], "is": ["ib", "or", "us", "ip", "isa", "ios", "im", "bs", "ois", "isl", "ir", "was", "iris", "ci", "as", "has", "api", "ais", "os", "IS", "ui", "ins", "ri", "are", "does", "fs", "isin", "s", "Is", "vs", "iss", "url", "its", "isi", "i", "sin", "bis", "lis", "ai", "ps", "id", "ris"], "buffer": ["slave", "seed", "cache", "channel", "uffer", "limit", "padding", "bin", "delay", "layer", "feed", "sequence", "buf", "queue", "slice", "length", "repeat", "address", "count", "batch", "base", "phrase", "server", "url", "size", "Buffer", "iter", "bytes", "border", "page", "memory", "counter", "reader", "transfer", "data", "null", "buff", "offset", "source", "binary", "info", "uri", "reference"], "amountRead": ["enoughReader", "lengthRead", "poolWrite", "amountLoad", "AmountWrite", "amountReader", "weightReader", "poolLoad", "AmountStart", "weightLoad", " numberLoad", "poolRead", "numberRead", "amountBuild", "AmountReader", " amountReader", "AmountLoad", " amountStart", "AmountRead", "numberReader", "weightRead", " numberRead", " numberWrite", " amountWrite", "AmountHandle", "weightBuild", "numberLoad", " amountBuild", "AmountBuild", "enoughRead", "numberWrite", "poolReader", "lengthWrite", "enoughWrite", "lengthLoad", "lengthHandle", " amountLoad", "amountStart", "enoughStart", " numberHandle", "amountHandle", "amountWrite"]}}
{"id1": "19584877", "id2": "23532405", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFiletoString", "encodeFile2File", "encodeString2File", "encodeFiletoStream", "encodeFiletoFile", "encodeStringToString", "encodeFileToString", "encodeFileToStream", "encodeStringToFiles", "encodeStringToFile", "encodeFile2Files", "encodeString2String", "encodeFileFromFiles", "encodeFileFromString", "encodeStringToStream", "encodeFileFromStream", "encodeString2Stream", "encodeString2Files", "encodeFileToFiles", "encodeFile2String", "encodeFile2Stream", "encodeFiletoFiles", "encodeFileFromFile"], "infile": [" infp", "inputfilename", "infp", "inputFile", "outfiles", " infiles", "Infilename", "inputfp", "inputfiles", "outfilename", "Infile", "outfp", " infilename", "InFile", "inFile", "inputfile", "Infiles", "outFile", "infiles", "infilename"], "outfile": [" outname", "OutFile", "outfolder", "infp", "newFile", "Outname", "newname", "outname", " outFile", "newfolder", "outfilename", "outfp", " outfilename", " outfolder", "Outfile", "outputfp", "Outfolder", "newfile", "infolder", "outputfolder", "outFile", "outputfile", "outputfilename", " outfp", "infilename"], "in": ["In", "inas", "pass", "again", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "ic", "as", "con", "pin", "ins", "ac", "min", "conn", "inn", "into", "err", "isin", "init", "win", "s", "base", "rin", "gin", "thin", "inside", "i", "nin", "a", "image", "socket", "sin", "login", "reader", "data", "vin", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "In", "or", "exit", "again", "line", "cache", "o", "ex", "inner", "bin", "Out", "copy", "outer", "io", "outs", "co", "post", "sync", "on", "conn", "no", "err", "up", "net", "base", "exec", "work", "name", "session", "off", "home", "image", "lib", "socket", "to", "writer", "output", "error", "ou", "write", "obj", "OUT", "point", "job", "inc", "parent", "source", "client", "one", "file"], "buffer": ["seed", "cache", "uffer", "limit", "padding", "input", "layer", "wave", "feed", "buf", "slice", "queue", "length", "address", "count", "batch", "base", "server", "url", "size", "Buffer", "iter", "len", "value", "split", "bytes", "transfer", "result", "border", "bb", "reader", "data", "write", "type", "raw", "null", "b", "fb", "buff", "flush", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", "tell", " Read", "use", "ip", " skip", "send", "n", " write", "current", "reading", "fill", "limit", "select", "input", "copy", "READ", "lex", "io", "feed", "add", "slice", "sync", "length", " count", "count", "seek", "play", "Read", "ad", "exec", "find", "get", "load", "x", "wait", "size", "work", "f", "iter", "len", "i", "allow", "ind", "_", "start", "ride", "close", "connect", "check", "reader", " copy", "parse", "write", "next", "se", "raw", "inc", "id", "sleep", "end"], "success": ["rolled", "done", "pass", "status", "again", "respons", "initial", "method", "results", "failed", "comment", "winner", " Success", "continue", "response", "func", "fast", "right", "path", "open", "Success", "modified", "ceed", "primary", "first", "warning", "construct", "content", "ccess", "growth", "roll", "good", "valid", "successful", "flash", " successful", "default", "danger", "model", "fail", " succeed", "complete", " succ", "value", "rolling", "result", "better", "true", "error", "data", "follow", "xx", "null", "successfully", "message", "cess"]}}
{"id1": "3266833", "id2": "14450108", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "label": 0, "substitutes": {"is": ["ib", "or", "us", "ip", "isa", "ios", "im", "bs", "ir", "was", "fits", "iris", "has", "as", "abs", "ais", "os", "IS", "cms", "in", "ins", "init", "Is", "iso", "iss", "get", "its", "ws", "isc", "i", "image", "close", "bis", "mis", "lis", "isu", "id", "es", "iv", "info", "ris"], "name": ["Name", "names", "large", "pass", "description", "n", "string", "word", "title", "version", "named", "path", "label", "search", "key", "this", "vision", "database", "no", "min", "address", "default", "part", "base", "connection", "nice", "domain", "prefix", "url", "size", "office", "code", "value", "space", "filename", "image", "ame", "NAME", "format", "memory", "directory", "type", "data", "term", "module", "null", "id", "parent", "source", "alias", "file", "one"], "contentType": ["mediaType", "ContentTypes", " contentPoint", "messagetype", " contenttype", "contentName", "documenttype", " contentInfo", "contentPoint", "messageName", "contentInfo", "contentTypes", "outputPath", "ContentPath", "mediaPath", "mediaTypes", "documentInfo", "contenttype", "outputTypes", "messageType", "sourceInfo", "ContentType", "documentType", "sourcetype", "sourcePoint", "Contenttype", "outputType", " contentName", "sourceType", "contentPath", "ContentInfo", "documentPoint", "ContentName", "outputName", "mediaName", "messageInfo"], "index": ["timeout", "pull", "position", "height", "string", "multi", "include", "append", "pointer", "depth", "expression", "Index", "input", "shape", "search", "open", "key", "slice", "number", "list", "none", "in", "length", "content", "address", "weight", "alpha", "default", "fix", "prefix", "width", "x", "size", "i", "value", "image", "axis", "page", "level", "error", "type", "data", "write", "inc", "id", "offset", "update", "body", "end"], "extension": ["configension", "configuration", "exturation", "variensions", "extance", "variuration", "Extension", "Extensions", "variension", "configensions", "Extance", "Exturation", "extensions", "configance", "variance"], "isImage": [" isFile", "areImage", "asImage", "isimage", " isPicture", "asInstance", "isVideo", "isaImages", " isInstance", "areMedia", "isInstance", "ISFile", "areimage", " isimage", "isaFile", " isVideo", "asFile", "isaImage", "areImages", "isImages", " isImages", "areFile", "isMedia", "IsImage", "areInstance", "asimage", "ISImage", "isPicture", "IsFile", "IsPicture", " isMedia", "isaMedia", "isFile", "ISPicture", "ISVideo", "IsVideo"], "isAux": ["isWalux", " isAxt", "asAsUX", "isOAux", "isAsex", "asAUX", "isArrayux", "isUlux", "isAsUX", "isHax", " isHaux", " isArrayru", "isUux", "isOAlux", "asAExcept", "isOAUX", "isAcux", "asAsux", "asAlux", "isAru", "isAxt", "isHaux", "isHalux", "isWaux", "isAcUX", "isAnlux", " isAlux", "isAAUX", "isAUX", "isHaUX", "isUExcept", " isHalux", "asAsex", "isAAru", "isAAxt", " isArrayUX", "asAslux", "isAlux", " isAx", "asAex", "isAx", "isAslux", "isAsx", "isWax", "isOAExcept", "asAux", "isUex", "isArrayru", "isAcxt", "isArrayUX", " isAUX", "isAExcept", " isHax", " isArrayxt", "isArrayxt", "isAnUX", "isAex", "asAsExcept", " isHaUX", "isAnex", "isWaUX", " isAru", "isAsExcept", "isAcru", "isAAux", "isAnux", "isUUX", " isArrayux", "isAsux"], "out": ["temp", "again", "at", "project", "cache", "over", "o", "ex", "exp", "word", "table", "version", "inner", "Out", "input", "copy", "outer", "io", "outs", "this", "post", "sync", "in", "object", "conn", "user", "up", "part", "base", "prefix", "exec", "work", "size", "array", "pool", "off", "image", "auto", "a", " in", "plain", "socket", "page", "ext", "next", "output", "error", "data", "result", "obj", "OUT", "null", "parent", "source", "buffer", "client", "file", "extra"], "bufferedImage": ["buffendedImage", "BufferedImage", "BufferingImage", "buffendedimage", "buffledImage", "Bufferedimage", "Bufferingimage", "bufferingImage", "buffledimage", "bufferingimage", "bufferedimage"], "inputStream": ["InputSteam", "outputSteam", "outputBuffer", "inputBuffer", "inputstream", " inputSteam", "Inputstream", "InputStream", "outputstream", " inputstream", " inputBuffer", "outputStream", "inputSteam", "InputBuffer"]}}
{"id1": "9371421", "id2": "20886320", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"eventHash": ["byteHash", "messageDig", "eventDig", " eventKey", "byteDig", "eventhash", " eventhash", "eventKey", "messagehash", " eventDig", "bytehash", "byteKey", "messageKey", "messageHash"], "eventstr": ["eventdict", "Eventdict", "exstr", " eventsource", "errorStr", "EventStr", "eventstring", "errorstring", "exstring", " eventstring", "errorsource", "Eventstr", "exStr", "eventsource", " eventdict", "eventStr", "Eventstring", "exdict", "Eventsource", " eventStr", "errorstr"], "md": ["mb", "mp", "mg", "ms", "pm", "od", "mand", "cm", "mac", "map", "m", "em", "mem", "sm", " MD", "d", "sha", "hm", "di", "MD", "bd", "key", "meta", "doc", "ke", "wd", "hd", "ad", "dd", "ld", "mc", "ng", "mod", "cmd", "mn", "dh", "dr", "mag", "ma", "hash", "dm", "amd", "data", "dig", "rpm", "mm", "metadata", "vd", "id", "mt", "mu", "mo"], "theDigest": [" theDighest", "Thedigest", " theDigester", "theDigester", " theSignhest", " theSignester", "thedigEST", "theSignest", "TheDigest", "thedigester", "thedigest", "theSignester", "ThedigEST", "theHashEST", " theSignEST", "theHashester", "theSignhest", "TheDigEST", "Thedigester", " theDigEST", " theSignest", "theDighest", "thedighest", "theDigEST", "theSignEST", "theHashest", "TheDigester"]}}
{"id1": "17791385", "id2": "9413074", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    String getLocation(Class clazz) {\n        try {\n            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();\n            String location = url.toString();\n            if (location.startsWith(\"jar\")) {\n                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();\n                location = url.toString();\n            }\n            if (location.startsWith(\"file\")) {\n                java.io.File file = new java.io.File(url.getFile());\n                return file.getAbsolutePath();\n            } else {\n                return url.toString();\n            }\n        } catch (Throwable t) {\n        }\n        return Messages.getMessage(\"happyClientUnknownLocation\");\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "src": ["resource", "txt", "http", "dist", "input", "inst", "sc", "dest", "ins", "files", "ipl", "loc", "sup", "s", "rc", "ls", "upload", "url", "config", "sb", "sl", "filename", "image", "sin", "inf", "img", "st", "obj", "b", "back", "source", "stream", "uri", "sit", "rb", "sel", "file"], "dst": ["stst", "dsp", "ddest", "ddfd", "dfd", "stdest", "fdst", "ststs", " dsts", "Dlt", "pdfd", "pdst", "Dst", "fdfd", "ddft", "dsts", "Ddest", "ddsp", "ddst", " dlt", " ddest", "dft", "fdsp", "dlt", "fdft", "pdft", "Dsts", "pdsp", "stlt"], "in": ["In", "pull", "again", "n", "ini", "oin", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "as", "con", "pin", "ins", "impl", "conn", "inn", "err", "kin", "init", "win", "rin", "lin", "url", "gin", "f", "inside", "i", "nin", "h", "sin", "socket", "login", "reader", "data", "r", "inc", "id", "ln", "file"], "out": ["temp", "line", "at", "again", "n", "cache", "o", "ex", "exp", "bin", "Out", "self", "copy", "outer", "io", "outs", "post", "sync", "conn", "err", "up", "part", "net", "w", "s", "exec", "server", "x", "f", "other", "off", "i", "writer", "plain", "ext", "output", "raw", "obj", "OUT", "null", "inc", "parent", "client", "file"], "buf": ["bh", "vec", "cat", "c", "bin", "fd", "ctx", "bd", "queue", "pad", "length", "seq", "count", "loc", "batch", "br", "bl", "bag", "ff", "base", "rc", "cmd", "cur", "bc", "off", "lim", "cap", "uf", "uc", "bytes", "cb", "val", "v", "bb", "data", "fl", "raw", "b", "bf", "buff", "fb", "buffer", "wb", "rb"], "len": ["lt", "line", "n", "c", "fin", "bin", "le", "Len", "ll", "fd", "length", "no", "count", "err", "l", "part", "cl", "base", "pos", "all", "lin", "size", "sl", "f", "i", "li", "ind", "cap", "el", "split", "lim", "val", "nt", "data", "fl", "en", "lf", "rev", "ix", "ln", "name", "lc", "end"]}}
{"id1": "8430178", "id2": "873012", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "CopyPath", "copyPath", "CopyFiles", "copyfile", " copyPath", "transferFiles", "copyFiles", "transferPath", "CopyFile", "transferfile"], "source_name": ["sourceNalias", "src_size", "src_type", "source_data", "Source_data", " source_path", "sourceCname", "sourceCalias", "source_Name", "Source_file", "src_name", "sourceNtype", "src_uri", " source_names", "sourceCtype", "sourceCfile", "source_names", "sourceNname", "src_alias", " source_Name", "source_path", "sourceNfile", "source_size", " source_key", "src_file", "source_alias", "source_key", "source_uri", "Source_name", "source_type"], "dest_name": ["Dest_Name", "dest_info", "destJword", " destination_name", "dest_named", "Dest_name", "Dest_path", "destPtype", "destFilefile", "destJnames", "destappname", "destPmodel", "dest_path", " dest_names", "destPnames", "destfname", "source_Name", "destRdefinition", "destJname", " dest_label", "target_model", "destapptype", "dest_model", "destappmodel", "dest_file", "destRname", " destinationFinfo", "destfnamed", "destFinfo", "destPword", "dest_none", "destflabel", "destffile", " dest_type", "source_names", "destRName", "dest_id", " dest_path", "target_names", " destination_resource", " destinationFresource", " destination_path", "target_type", "destPName", " dest_definition", "source_path", " destination_info", "target_name", "dest_definition", " dest_Name", " dest_none", "dest_word", "destFresource", " dest_file", "dest_label", "destJName", "destFpath", "destPpath", " destinationFname", "dest_names", "destRpath", "destFilename", " dest_named", " dest_word", "destappnames", "destPname", "dest_type", "destFname", "Dest_id", "dest_resource", "destFilenamed", " destinationFpath", "destFilelabel", "dest_Name"], "source_file": ["source_url", "source__base", "source_File", "sourcefname", "sourcefurl", "ource_file", " source_class", "src_name", " source_files", " source_cache", "ource_line", "ource_files", "source_files", "src_files", "ource_name", "src_stream", " source_File", "source__class", "sourcefFile", "source__name", " source_url", "src_file", "source_class", "source__file", "source_line", "source_cache", "source_base", "sourceffile", " source_base", "source_stream"], "destination_file": ["destinate_file", "destention_name", "destinate_files", "destation_files", "destention4path", "destination2source", "destinationablebase", "destination4name", "destation_folder", "destination2file", "destation_function", "destination4file", "destention_file", "destination_source", "destination2path", "destination_name", "destinationablepage", "destinate_page", "destention4file", "destinationablefile", "destination2name", "destention_path", "destention_source", "destinationablefiles", "destination_files", "destention4source", "destination_page", "destation_file", "destention4name", "destination_base", "destation_name", "destination_function", "destination4path", "destinate_base", "destination_folder", "destination4source", "destination_path"], "source": ["resource", "ize", "slave", "local", "class", "resources", "cache", "site", "current", "Source", "view", "spec", "proxy", "inner", "service", "scope", "master", "input", "copy", "ource", "core", "search", "open", "via", "from", "slice", "dest", "client", "object", "unit", "single", "connection", "storage", "server", "get", "load", "config", "index", "ite", "image", "start", "SOURCE", "remote", "result", "reader", "diff", "output", "ources", "secure", "target", "parent", "stream", "uri", "src", "name", "file", "reference"], "destination": ["identination", "testinated", "identinated", " destina", "testinator", "foreigninate", " destinator", "identina", "targetinated", "destina", "constinator", "descinated", " destining", " destribution", "variinated", "destribution", "validinator", "destinator", "constining", "descension", "Destinator", "coordination", "variinator", "Destination", "dependinate", "destinated", "validination", "Destinated", "Destina", "destining", "destinate", "targetinator", "testination", "descinator", "variinate", "targetinate", "dependination", "Destension", "dependinated", "foreignination", "constination", "Destribution", " destinated", "testribution", "foreigninator", "Destining", "validinated", "identribution", "coordension", "variination", "coordinator", "foreigninated", "validinate", "descination", "dependinator", "coordinated", "targetination", "constribution", "destension"], "buffer": ["timeout", "temp", "window", "channel", "cache", "uffer", "limit", "bin", "input", "sequence", "buf", "queue", "header", "batch", "pool", "Buffer", "iter", "image", "writer", "transfer", "memory", "reader", "flush", "buff", "binary", "text", "block", "padding"], "bytes_read": ["Bytes_read", "Bytes_set", "bytesUnRead", "bytes_Read", "Bytes_Read", "bytesUnset", "bytesUnfound", "bytes_set", "bytesUnread", "bytes_found", "Bytes_found"], "in": ["resource", "In", "fe", "temp", "or", "token", "container", "line", "again", "serv", "ini", "n", "IN", "rec", "current", "request", "is", "inner", "din", "bin", "input", "log", "as", "con", "path", "ins", "doc", "min", "inn", "p", "l", "connection", "s", "out", "url", "get", "read", "f", "session", "nin", "a", "image", "h", "val", "login", "ssl", "reader", "data", "r", "b", "inc", "id", "stream", "lock", "re", "file"], "response": ["Response", "resource", "application", "status", "line", "description", "respond", "string", "respons", "reply", "request", "view", "version", "answer", "report", "api", "feed", "onse", "sequence", "json", "object", "header", "dict", "resp", "offer", "model", "server", "location", "su", "value", "success", "received", "image", "example", "res", "reset", "result", "next", "output", "error", "data", "true", "question", "r", "message", "uri", "text", "body", "re", "reason", "update"], "parentdir": ["parentsdir", "hostdir", "homedir", "parentlib", "hostdict", " parentdirectory", "parentsdiff", "rootfile", "partlib", "parentdict", "rootdir", "partfile", "Parentdict", " parentDir", "partdirectory", "parentdiff", "parentDir", " parentfile", "parentsfile", "Parentdir", "homeDir", "parentsDir", "rootdirectory", "homediff", " parentdiff", "rootlib", "Parentdirectory", "homefile", "partdir", "hostdirectory", "parentdirectory", " parentlib", " parentdict", "parentfile"]}}
{"id1": "22844377", "id2": "16719805", "code1": "    public int scrapeForIsbns(URL url) {\n        int matches = 0;\n        Pattern p = Pattern.compile(\"ISBN-10:</strong>\\\\s*(\\\\w{10})\");\n        Matcher m;\n        for (int i = 0; i < RETRIES; i++) {\n            try {\n                InputStream in = url.openStream();\n                BufferedReader br = new BufferedReader(new InputStreamReader(in));\n                String str;\n                while ((str = br.readLine()) != null) {\n                    m = p.matcher(str);\n                    while (m.find()) {\n                        matches++;\n                        outputIsbns.put(m.group(1));\n                        logger.debug(\"Got ISBN: \" + m.group(1));\n                    }\n                }\n                break;\n            } catch (ConnectException e) {\n                logger.warn(\"Connection attempt \" + i + \" failed, trying again. Max retries: \" + RETRIES);\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e1) {\n                }\n            } catch (IOException e) {\n                logger.error(\"Error reading URL stream\", e);\n            } catch (InterruptedException e) {\n                logger.error(\"Interrupted while calling put(Object E)\", e);\n            }\n        }\n        return matches;\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 0, "substitutes": {"scrapeForIsbns": ["scrapeForISbbn", "scrapeForIsbbcn", "scrapeForIsbbna", "scrapeForISbns", "scrapeForIsbna", "scrapeForIsbtna", "scrapeForISbna", "scrapeForIspns", "scrapeForISbcn", "scrapeForIsbbn", "scrapeForISbbcn", "scrapeForIsbtns", "scrapeForIsbbns", "scrapeForIspn", "scrapeForISbbns", "scrapeForIspcn", "scrapeForISbn", "scrapeForIspna", "scrapeForIsbtn", "scrapeForIsbn", "scrapeForIsbcn", "scrapeForIsbtcn", "scrapeForISbbna"], "url": ["resource", "zip", "string", "http", "xml", "service", "URL", "path", "ll", "ur", "io", "feed", "gl", "Url", "download", "object", "bel", "l", "connection", "base", "server", "config", "loader", "sl", "f", "el", "image", "html", "ssl", "page", "data", "r", "uri", "stream", "source", "buffer", "org", "name", "file"], "matches": [" matures", "matests", "Matchers", "Matries", "mathes", "patches", "retries", "matries", "Matches", "Matks", "Mathes", "matks", " matries", "matures", "rethes", "Matcher", "latests", " mathes", "retures", "patchers", "patests", " matcher", "latched", "retches", "matched", "matchers", " matched", "attks", "latchers", "attches", "attcher", "latches", "matcher", " matks", "patched", " matchers", " matests", "Matures", "attchers"], "p": ["n", "c", "cache", "pi", "py", "pr", "o", "op", "pb", "d", "api", "np", "pp", "tp", "proc", "l", "s", "pe", "cp", "pa", "sp", "f", "per", "comp", "e", "lp", "fp", "P", "jp", "r", "po", "b", "t", "parser", "ps", "pattern", "pro"], "m": ["mp", "pc", "ms", "pm", "u", "line", "cm", "n", "c", "mand", "pr", "pi", "wm", "sm", "um", "em", "mac", "hm", "mor", "match", "lem", "form", "g", "mr", "re", "er", "om", "M", " pm", "ym", " r", "mc", "l", "month", "man", "mn", "ma", "per", "machine", "e", "fm", "am", "rem", "gm", "dm", "h", " cm", "mut", "v", "nm", "mi", "md", "r", "mm", "b", "tm", "me", "mu", "bm", "im", "mo"], "i": ["hi", "iu", "timeout", "si", "qi", "u", "multi", "k", "ii", "ini", "c", "pi", "o", "n", "is", "inner", "ci", "di", "io", "z", "slice", "ui", "ri", "count", "ie", "it", "phi", "init", "j", "I", "fi", "x", "index", "f", "oi", "li", "ind", "ori", "start", "ni", "h", "v", "gi", "ti", "counter", "mi", "ai", "xi", "t", "id", "info", "ix", "end"], "in": ["In", "ch", "n", "ini", "IN", "ex", "exp", "is", "inner", "bin", "input", "as", "io", "ins", "inn", "err", "bl", "l", "init", "s", "out", "ar", "coll", "f", "a", "socket", "arin", "file", "reader", "data", "r", "b", "inc", "lock", "stream", "fr"], "br": ["Br", "ch", "bh", "inv", "line", "obl", "ob", "ber", "io", "abs", "yr", "buf", "bro", "BR", "tr", "gr", "er", "err", "browser", "cr", "bl", "out", "arr", "sp", "dr", "bar", "ori", "cb", "img", "reader", "data", "hr", "obj", "r", "b", "stream", "body", "src", "rb", "fr"], "str": ["fr", "pass", "stri", "line", "kr", "string", "c", "pr", "input", "char", "sr", "STR", "tr", "gr", "err", "bl", "cl", "cr", "s", "arr", "sp", "dr", "read", "sl", "f", "enc", "strip", "result", "st", "reader", "data", "strike", "hr", "obj", "raw", "r", "b", "t", "id", "Str", "text", "name", "dec"]}}
{"id1": "11962480", "id2": "9450274", "code1": "    public void read(String skeletonFilename) throws Exception {\n        ClassLoader loader = UnicodePropertiesSkeleton.class.getClassLoader();\n        URL url = loader.getResource(skeletonFilename);\n        if (null == url) {\n            throw new Exception(\"Cannot locate '\" + skeletonFilename + \"' - aborting.\");\n        }\n        String line;\n        StringBuilder section = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n        while (null != (line = reader.readLine())) {\n            if (line.startsWith(\"---\")) {\n                sections.add(section.toString());\n                section.setLength(0);\n            } else {\n                section.append(line);\n                section.append(NL);\n            }\n        }\n        if (section.length() > 0) {\n            sections.add(section.toString());\n        }\n        if (sections.size() != size) {\n            throw new Exception(\"Skeleton file '\" + skeletonFilename + \"' has \" + sections.size() + \" static sections, but \" + size + \" were expected.\");\n        }\n    }\n", "code2": "    public void seeURLConnection() throws Exception {\n        URL url = new URL(\"http://wantmeet.iptime.org\");\n        URLConnection uc = url.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n        String s = null;\n        StringBuffer sb = new StringBuffer();\n        while ((s = br.readLine()) != null) {\n            sb.append(s);\n        }\n        br.close();\n        log.debug(\"sb=[\" + sb.toString() + \"]\");\n    }\n", "label": 1, "substitutes": {"read": ["resource", "readable", "register", "transform", "copy", "report", "open", "process", "add", "download", "construct", "build", "print", "Read", "store", "init", "replace", "find", "get", "load", "split", "start", "check", "parse", "write", "create"], "skeletonFilename": ["skelFilename", " skeletonSourceFile", "southeastDownload", "southeastSourceFile", "skelSourceFile", " skelSourceFile", "skeletonfilename", "sletonFile", "sletonfilename", " skelFile", " skeletonfilename", "SkeletonDownload", "skeletonSourceFile", "southeastFile", "sletonSourceFile", "SkeletonSourceFile", "skeletonFile", "sleeFile", "skeletonDownload", "SkelSourceFile", "sletonFilename", " skeletonFile", "skelFile", "southeastFilename", "sletonDownload", "sleefilename", " skelfilename", "SkelFile", " skelFilename", "Skelfilename", "SkelDownload", "SkeletonFile", "SkeletonFilename", "SkelFilename", "skelDownload", "sleeSourceFile", "skelfilename", "Skeletonfilename", "sleeFilename"], "loader": ["resource", "class", "cache", "loaded", "loading", "http", "layer", "log", "path", "driver", "in", "rl", "impl", "er", "loc", "handler", "err", "cl", "l", "Loader", "lang", "base", "init", "server", "load", "system", "config", "r", "null", "b", "parser", "buffer", "lock", "CL", "source", "name", "builder", "file", "lc"], "url": ["resource", "cdn", "string", "host", "http", "service", "URL", "path", "api", "ur", "feed", "Url", "rl", "client", "object", "user", "address", "bel", "loc", "browser", "rel", "l", "connection", "base", "server", "location", "load", "coll", "sl", "f", "i", "image", "lib", "page", "ssl", "data", "r", "b", "source", "uri", "buffer", "name", "file"], "line": ["item", "inline", "entry", "row", "string", "lines", "word", "LINE", "str", "comment", "le", "Line", "log", "key", "number", "sync", "content", "user", "letter", "no", "header", "unit", "cl", "l", "part", "liner", "base", "L", "lin", "pe", "cell", "definition", "sl", "link", "code", "i", "nl", "strip", "split", "lo", "page", "result", "se", "data", "write", "parse", "style", "lf", "job", "source", "text", "body", "name", "file", "lc"], "section": ["body", "entry", "row", "function", "position", "description", "string", "join", "zip", "option", "union", "script", "area", "character", "ler", "service", "region", "layer", "search", " intersection", "feed", "division", "ner", "patch", "key", "length", "content", "letter", "handler", "sect", "rule", "connection", "layout", "element", "chapter", "storage", "server", "location", "contract", "definition", "config", "sec", "array", "article", "Section", "journal", "format", "writer", "editor", "draft", "sector", "page", "file", "output", "data", "se", "style", "null", "parser", "job", "parent", "sub", "source", "text", "block", "version", "builder", "sections", "lc"], "reader": ["resource", "row", "reading", "oder", "inner", "ler", "input", "layer", "io", "ner", "feed", "driver", "ri", "handler", "er", "bird", "Reader", "rer", "f", "iter", "per", "i", "worker", "editor", "writer", "rr", "r", "parser", "rar", "buffer", "stream", "rx", "builder", "file"]}}
{"id1": "9796161", "id2": "88047", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"getMD5": ["getHTMLHash", " getMDHash", " getSHAHash", "getMD512", "getSHA5", " getSHA5", " getSHA512", " getMD4", " getMD512", "getHTML5", "getmdHash", "getHTML4", "getmd5", "getMD4", "getHTML512", " getSHA4", "getmd4", "getMDHash", "getSHAHash", "getmd512", "getSHA512", "getSHA4"], "s": ["js", "si", "S", "ings", "ses", "ms", "bs", "g", "string", "n", "c", "lines", "sym", "str", "sets", "scripts", "gs", "is", "self", "input", "abs", "os", "styles", "sync", "in", "p", "ates", "l", "tests", "strings", "ls", " ads", "als", "its", "ws", "sb", "services", "f", "e", "cs", "i", "ns", "ds", "a", "bytes", "v", "ssl", "ts", "ips", "ows", "data", "parts", "b", "comments", "ps", "es", "rs", "source", "ends", " fails", "ss"], "m": ["ms", "pm", "ym", "wm", "cm", "rm", "mac", "im", "em", "c", "mand", "sm", "um", "d", "hm", "manager", "mr", "om", "M", "vm", "p", "l", "mc", "man", "f", "machine", "e", "fm", "am", "i", "arm", "gm", "h", "dm", "mut", "v", "nm", "mi", "md", "module", "mm", "t", "tm", "me", "mu", "bm"]}}
{"id1": "5399593", "id2": "3514286", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"encrypt": ["encryption", "decryption", " encress", " encryption", "decrypt", "decress", "encipher", "escrypt", "escress", "escipher", "decipher", " encipher", "escryption", "encress"], "plaintext": ["singleText", "ainform", "singletext", "forecontent", "singleTEXT", "plaincontent", " plainform", "ainTEXT", "ainText", "foreText", " plainTEXT", "plainform", "plainTEXT", "foretext", "aintext", "raincontent", " plainText", "raintext", "rainTEXT", "foreTEXT", " plaincontent", "singleform", "rainText", "plainText"], "UnsupportedEncodingException": ["UnsupportedCodingEx", "UnsupportedEncryptionError", "UnsupportedEncgorithmEx", "UnsupportedCodedEx", "UnsupportedEncodedException", "UnsupportedEncryptionEx", "UnsupportedEncryptionException", "UnsupportedEncgorithmError", "UnsupportedEncodingEx", "UnsupportedEncodedError", "UnsupportedEncodedEx", "UnsupportedCodingException", "UnsupportedCodedError", "UnsupportedCodingError", "UnsupportedCodedException", "UnsupportedEncodingError", "UnsupportedEncgorithmException"], "md": ["dc", "mb", "mp", "mg", "hed", "ms", "pm", "od", "mage", "mand", "rm", "mac", "map", "m", "Cmd", "mem", " MD", "d", "sha", "hm", "sum", "MD", "bd", "meta", "wd", "hd", "dd", "mc", "cd", "mod", "cmd", "mn", "ma", "mag", "code", "am", "dm", "material", "nm", "amd", "dig", "mm", "metadata", "po", "bf", "message", "mad", "mt", "me", "mu", "db", "mo"], "raw": ["wrap", "row", "full", "clean", "instance", "aws", "initial", "unknown", "sha", "input", "micro", "empty", "hex", "buf", "original", "ack", "shared", "missing", "alpha", "flash", "ng", "rew", "load", "array", "enc", "Raw", "serial", "blocks", "unsigned", "ghost", "null", "sign", "RAW", "message", "buffer", "block", "dec"], "hash": ["hed", "sh", "mac", "cache", "string", "Hash", "rh", "secret", "ruby", "sha", "sum", "abi", "log", "hh", "hex", "key", "auth", "ashes", "header", "kh", "build", "shared", "alpha", "flash", "ha", "base", "url", "math", "ash", "array", "code", "password", "image", "h", "html", "data", "id", "message", "text", "block", "version"]}}
{"id1": "18544890", "id2": "22879400", "code1": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "label": 0, "substitutes": {"get": ["resource", "pull", "send", "cache", "GET", "call", "select", "gets", "match", "list", "json", "download", "Get", "show", "find", "load", "query", "start", "remote", "next", "data", "debug", "info", "update", "create", "end"], "url": ["resource", "route", "string", "host", "href", "http", "str", "service", "www", "URL", "path", "ll", "layer", "ur", "feed", "key", "queue", "Url", "email", "download", "address", "loc", "rule", "connection", "l", "base", "ls", "server", "location", "sl", "f", "date", "image", "page", "ssl", "id", "uri", "source", "name", "file"], "lat": ["distance", "live", "local", "route", "late", "at", "height", "bot", "tile", "gal", "la", "length", "address", "loc", "play", "street", "l", "base", "pos", "out", "port", "location", "width", "game", "Lat", "home", "range", "data", "alt", "west", "point", "id", "las", "offset", "grid", "league"], "lon": ["online", "vel", "live", "position", "depth", "layer", "log", "fat", "number", "la", "land", "length", "on", "loc", "lang", "l", "lb", "ng", "base", "pos", "lin", "location", "left", "ino", "len", "off", "nl", "lan", "val", "lag", "range", "level", "offset", "ln", "width"], "count": ["timeout", "amount", "n", "c", "cache", "limit", "depth", "total", "more", "sum", "time", "log", "Count", "list", "number", "force", "num", "length", "age", "batch", "part", "base", "all", "load", "size", "index", "f", "pool", "scroll", "code", "len", "val", "level", "error", "type", "follow", "found", "id", "offset", "name", "file"], "req": ["fe", "ctr", "serv", "call", "http", "fin", "wx", "def", "build", "p", "proc", "rob", "reg", "q", "pub", "check", "socket", "next", "rr", "ver", "fr", "c", "cache", "respond", "request", "io", "rt", "post", "tr", "loc", "qt", "cp", "fail", "plug", "cur", "pkg", "require", "conf", "grad", "rx", "org", "pull", "ru", "exp", "Request", "ctx", "ur", "https", "fit", "cf", "orb", "query", "work", "f", "sem", "ok", "worker", "res", "ext", "hr", "jp", "r", "fb", "client", "rb", "sq", "ref", "temp", "requ", "pr", "wa", "download", "cook", "conn", "gr", "err", "resp", "cmd", "exec", "server", "bur", "cb", "test", "dq", "form", "rf"], "gl": ["rg", "il", "gg", "fe", "berg", "ml", "ger", "global", "cm", "g", "bs", "go", "view", "pl", "fx", "bg", "ll", "gal", "list", "rl", "groups", "gre", "bel", "loc", "browser", "bl", "cl", "l", "gall", "gb", "lol", "coll", "ga", "sl", "GL", "nl", "Gl", "gm", "el", "lim", "gn", "cal", "ul", "gi", "img", "ogl", "hl", "fl", "las", "sel", "ang", "gel", "console", "gold", "fr", "lc"], "br": ["Br", "ch", "ctr", "bh", "brush", "pr", "str", "ler", "ber", "io", "yr", "buf", "sr", "bro", "BR", "div", "tr", "mr", "bridge", "gr", "lr", "browser", "bl", "cr", "err", "ar", "arr", "sp", "dr", "bc", "bar", "res", "result", "img", "reader", "hr", "r", "b", "stream", "body", "rb", "fr"], "line": ["inline", "look", "entry", "row", "fr", "live", "string", "lines", "word", "LINE", "ine", "str", "comment", "le", "Line", "ge", "log", "co", "char", "key", "jo", "sync", "letter", "unit", "bl", "cl", "l", "rule", "base", "pos", "lin", "cell", "pe", "ino", "sl", "link", "e", "code", "cle", "nl", "el", "lo", "page", "ne", "data", "style", "lf", "sel", "source", "text", "block", "name", "file", "lc", "end"]}}
{"id1": "3024987", "id2": "22264586", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStreamForEncode", "testCopy_readerToOutputStream_Coding", "testCopy_readerToOutputStream_Code", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStream_Integoder", "testCopy_readerToOutputStream_Coded", "testCopy_readerToOutputStream_Integode", "testCopy_readerToOutputStreamForencoding", "testCopy_readerToOutputStream_Encode", "testCopy_readerToOutputStream_Integoding", "testCopy_readerToOutputStream_Coder", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStreamForencoded", "testCopy_readerToOutputStream_encode", "testCopy_readerToOutputStream_Integoded", "testCopy_readerToOutputStreamForencoder", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStreamForEncoded", "testCopy_readerToOutputStreamForEncoding", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStreamForencode", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStreamForEncoder"], "in": ["In", "or", "entry", "pass", "inas", "again", "ini", "n", "include", "IN", "rec", "m", "reading", "is", "inner", "din", "bin", "with", "input", "io", "slice", "ins", "min", "inn", "err", "init", "win", "rin", "url", "read", "Reader", "inside", "i", "image", "a", "file", "login", "arin", "data", "r", "inc", "id", "source", "buffer", "re"], "reader": ["or", "reading", "pointer", "oder", "inner", "ler", "input", "io", "ner", "feed", "driver", "er", "handler", "ra", "x", "loader", "read", "Reader", "iter", "rer", "per", "i", "ink", "her", "worker", "iner", "writer", "rr", "r", "b", "parser", "rar", "buffer", "stream", "rx", "source", "file"], "baout": ["vaOut", "BAOUT", "baOut", "abaOut", "wain", "daout", "aaout", "daOut", "Baout", "baOUT", "daOUT", "BAOut", "waoutput", "vaout", "baparent", "waOut", "BAparent", "BAout", "abaOUT", "aain", "BAoutput", "BaOut", "bain", "vain", "BAin", "dain", "vaparent", "Baparent", "abaout", "aaoutput", "aaOut", "Bain", "abain", "waout", "baoutput"], "out": ["inas", "line", "again", "cache", "o", "inner", "with", "Out", "io", "outs", "object", "user", "err", "up", "base", "exec", "server", "arr", "array", "pool", "image", "lib", "to", "writer", "file", "ext", "output", "write", "obj", "OUT", "null", "inc", "parent", "buffer", "client", "builder", "ref"], "bytes": ["pages", "reads", "Bytes", "classes", "codes", "bs", "zip", "string", "bps", "ies", "css", "lines", "ones", "values", "bits", "objects", "outs", "os", "files", "content", "seconds", "tes", "pieces", "cells", "strings", "ls", "size", "its", "ns", "blocks", "units", "ips", "output", "data", "parts", "items", "ipes", "null", "comments", "android", "es", "binary", "les", "text", "body", "odes", "rows"]}}
{"id1": "62362", "id2": "23517481", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["Converting", "subverting", "unverted", "Conversion", "converted", "CONverted", "unception", "CONverting", "conversion", " deconverting", "Convert", " deconvert", "conception", " deconverted", "subversion", "oconverted", "Conception", "subverted", "CONception", "oconvert", "oconversion", "subvert", "unvert", "CONversion", "CONvert", "converting", " deconversion", "unversion", "Converted", "oconverting"], "src": ["resource", "scene", "stage", "sth", "username", "cmp", "SourceFile", "string", "href", "Source", "spec", "cpp", "dist", "input", "ource", "path", "inst", "ctx", "sc", "buf", "slice", "sys", "attr", "rl", "download", "impl", "fn", "loc", "proc", "video", "gb", "s", "rc", "storage", "upload", "tmp", "url", "component", "load", "sn", "config", "sb", "code", "gz", "filename", "sin", "Dest", "fp", "cb", "ssl", "img", "reader", "st", "RC", "supp", "secure", "obj", "req", "feat", "rb", "prot", "back", "source", "stream", "uri", "sel", "name", "sit", "file", "ref"], "dest": ["dc", "txt", "temp", "class", " dst", "dat", "dist", "bin", "path", "di", "disk", "dir", "fn", "orig", "tmp", "home", "lib", "Dest", "std", "img", "test", "obj", "target", "null", " destination", "source", "cont"], "in": ["In", "inas", "pass", "ini", "n", "IN", "ex", "is", "d", "din", "bin", "input", "as", "io", "pin", "ins", "doc", "inn", "err", "up", "isin", "win", "f", "i", "a", "inf", "val", "login", "reader", "data", "r", "ps", "t", "inc", "source", "stream", "file"], "p": ["pc", "cop", "pd", "pm", "g", "c", "pr", "pi", "op", "py", "pb", "pg", "o", "m", "d", "np", "pp", "bp", "tp", "wp", "l", "part", "s", "pe", "cp", "pa", "j", "sp", "per", "f", "e", "lp", "i", "pre", "h", "fp", "v", "P", "jp", "r", "po", "ps", "t", "parser", "b"], "ds": ["dc", "hs", "words", "dl", "gs", "da", "obs", "s", "icks", "ges", "dm", "ts", "sts", "db", "df", "js", "pd", "bs", "ys", "dat", "lines", "dos", "d", "utils", "ads", "styles", " props", " sd", "amps", "ld", "ans", "Ds", "lp", "ns", "data", "posts", "parts", "docs", "ps", "DS", "ss", "dp", "scripts", "uds", "di", "os", "sync", "sys", "ins", "xs", "tests", "dds", "ls", "dt", "cs", "des", "nas", " DS", "ups", "ks", "eps", "dist", "cons", "ays", "tools", "ants", "groups", "plugins", "dd", "qs", "vs", "services", "dates", "ths", "els", "gd", "ded", "vals", "points", "ils", " ps", "ipes", "rs", "models"], "format": ["struct", "class", "function", "at", "act", "string", "host", "table", "spec", "version", "language", "atter", "path", "fd", "api", "magic", "letter", "unit", "handler", "fn", "frame", "nat", "scale", "tag", "part", "layout", "Format", "model", "prefix", "ant", "url", "config", "f", "sche", "filename", "record", "fp", "filter", "data", "type", "feat", "style", "plugin", "t", "parser", "pattern", "source", "form", "name", "file", "template"], "hasPixelData": ["showsPixeldata", "haspixeldata", "showsPixelDATA", "hasByteDATA", "hasPixeldata", "hasPixelDATA", "showsPixelStyle", " hasPixelSize", " hasPixeldata", "showsBytedata", "showsByteStyle", "haspixelSize", "showsPixelData", "hasByteData", "hasByteStyle", "hasBytedata", "haspixelData", "hasPixelStyle", "showsByteData", "hasPicturedata", "hasByteSize", "hasPictureSize", "hasPixelSize", "hasPictureData", "showsByteDATA"], "inflate": ["inFlated", "inadequating", "infloace", "insflode", "InFlate", "infolATE", "inadequode", "insvenATE", "inFlate", "insflating", "InFlace", "insflATE", "inffated", "inflation", "invenate", "inflace", "infolode", "inFlation", "infloate", "insvenate", "invenATE", "infloated", "inffation", "invenating", "InFlated", "insvenating", "insflate", "inflATE", "inflating", "Inflace", "infface", "inFlace", "infolate", "Inflated", "inffate", "Inflate", "inadequate", "insvenode", "inflated", "infolating", "infloation", "inflode", "invenode", "Inflation", "InFlation", "inadequATE"], "pxlen": ["fxdata", "pnglen", "pxlin", "mxln", "axlon", "pxcount", "fxln", "pglen", "txln", "pcln", "ppl", "pxlon", "txlin", "camlen", "fxl", "pgden", "pngsize", "axlin", "mxlen", "camln", "fxden", "xplength", "ppLen", "mxdata", "pxLen", "pxdata", "pclen", "pclin", "axln", "pxln", "axlen", "txlen", "pngcount", "campos", "mxpos", "fxLen", "xpsize", "xpcount", "pxsize", "pgl", "pxpos", "ppden", "pgLen", "fxpos", "pxlength", "fxlen", "mxlength", "mxcount", "xplen", "mxsize", "camdata", "pxden", "pclon", "pplen", "pxl", "pnglength", "txlon"], "out": ["group", "line", "again", "cache", "step", "inter", "state", "Out", "copy", "log", "io", "outs", "list", "co", "post", "sys", "pad", "user", "conn", "store", "err", "up", "server", "query", "work", "cli", "session", "dump", "lib", "v", "page", "output", "gen", "error", "obj", "OUT", "point", "parent", "lock", "re"]}}
{"id1": "6742637", "id2": "22752444", "code1": "    private static List<Properties> findExtensions() {\n        URL url = null;\n        try {\n            List<Properties> extensions = new ArrayList<Properties>();\n            Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\");\n            while (res.hasMoreElements()) {\n                url = res.nextElement();\n                Properties prop = new Properties();\n                prop.load(url.openStream());\n                extensions.add(prop);\n            }\n            return extensions;\n        } catch (IOException ioe) {\n            String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm();\n            throw new RuntimeException(msg, ioe);\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 0, "substitutes": {"findExtensions": ["findAppensions", "findAppension", "getextension", "getextensions", "findExtension", "findExtends", "getextends", "findDistends", "findextension", "getExtends", "findAppends", "findextends", "getExtensions", "getExtension", "findDistension", "findextensions", "findDistensions"], "url": ["resource", "il", "entry", "ch", "fr", "pull", "ver", "zip", "http", "service", "src", "URL", "path", "log", "ur", "api", "org", "io", "feed", "gl", "Url", "rl", "impl", "address", "bel", "bug", "loc", "lr", "err", "rel", "cl", "l", "connection", "base", "rc", "element", "ls", "server", "location", "load", "coll", "config", "sl", "f", "link", "ul", "image", "remote", "page", "result", "ssl", "html", "bb", "data", "r", "id", "web", "uri", "source", "buffer", "re", "name", "file"], "extensions": ["fends", "intends", "intension", "extencies", "fensions", "exps", "xtps", "xtensions", "exras", "exension", "exensions", "Extensions", "Extencies", "xtension", "exencies", "exends", "appencies", "extras", "fension", "extension", "intensions", "intps", "appensions", "xtends", "Extension", "Extras", "fps", "appras", "extps", "appension"], "res": ["resource", "rss", "rus", "ch", "js", "pres", "rest", "rez", "rh", "ex", "results", "http", "request", "is", "Rs", "response", "os", "details", "mr", "gr", "ret", "err", "resp", "Res", "rc", "out", "rex", "RES", "ries", "RE", "rem", "vers", "ros", "resolution", "result", "vals", "hr", "raw", "rr", "req", "r", "ps", "RS", "ras", "rev", "es", "rs", "ver", "re", "ris", "fr", "ress", "rows"], "prop": ["property", "resource", "mp", "class", "project", "pr", "op", "pb", "opt", "option", "exp", "priv", "api", "key", "pac", "attr", "properties", "lit", "def", "p", "proc", "app", "part", "base", "pos", "cp", "j", "tmp", "config", "f", "comp", "feature", "val", "fp", "ext", "result", "Prop", "data", "term", "obj", "feat", "style", "b", "fb", "point", "ps", "info", "pro", "ref"], "msg": ["mb", "mg", "status", "ug", "ms", "g", "string", "cfg", "m", "urg", "ko", "str", "title", "gs", "log", "bg", "agg", "printf", "me", "gr", "eg", "loc", "err", "db", "s", "tag", "cmd", "mn", "mag", "rag", "Msg", "gm", "format", "ext", "error", "kg", "sg", "req", "bf", "comm", "message", "info", "mt", "og", "text", "mid", "reason"]}}
{"id1": "8983517", "id2": "8328527", "code1": "    public User getUser(String userlogin) {\n        UserDAO userDAO = new UserDAO();\n        User user = null;\n        try {\n            user = userDAO.load(userlogin);\n            if (user == null) {\n                URL url = Thread.currentThread().getContextClassLoader().getResource(\"users.cfg\");\n                BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                String linea = br.readLine();\n                while (linea != null) {\n                    StringTokenizer st = new StringTokenizer(linea, \":\");\n                    if (st.countTokens() == 3) {\n                        String login = st.nextToken();\n                        String password = st.nextToken();\n                        String profile = st.nextToken();\n                        if (login.equals(userlogin)) {\n                            user = new User(login, password, profile);\n                            userDAO.save(user);\n                        }\n                    } else {\n                    }\n                    linea = br.readLine();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return user;\n    }\n", "code2": "    public void insertJobLog(String userId, String[] checkId, String checkType, String objType) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preStm = null;\n        String sql = \"insert into COFFICE_JOBLOG_CHECKAUTH (USER_ID,CHECK_ID,CHECK_TYPE,OBJ_TYPE) values (?,?,?,?)\";\n        String cleanSql = \"delete from COFFICE_JOBLOG_CHECKAUTH where \" + \"user_id = '\" + userId + \"' and check_type = '\" + checkType + \"' and obj_type = '\" + objType + \"'\";\n        try {\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            preStm = connection.prepareStatement(cleanSql);\n            int dCount = preStm.executeUpdate();\n            String sHaveIns = \",\";\n            preStm = connection.prepareStatement(sql);\n            for (int j = 0; j < checkId.length; j++) {\n                if (sHaveIns.indexOf(\",\" + checkId[j] + \",\") < 0) {\n                    preStm.setInt(1, Integer.parseInt(userId));\n                    preStm.setInt(2, Integer.parseInt(checkId[j]));\n                    preStm.setInt(3, Integer.parseInt(checkType));\n                    preStm.setInt(4, Integer.parseInt(objType));\n                    preStm.executeUpdate();\n                    sHaveIns += checkId[j] + \",\";\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            log.debug((new Date().toString()) + \" \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0228\ufffd\ufffd\u02a7\ufffd\ufffd! \");\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n                throw e;\n            }\n            throw ex;\n        } finally {\n            close(null, null, preStm, connection, dbo);\n        }\n    }\n", "label": 0, "substitutes": {"getUser": ["newuser", "getUsers", "readUsers", "newCustomer", "readUser", "getuser", "newUser", "createUsers", "createCustomer", "createuser", "newUsers", "readuser", "createUser", "readCustomer", "getCustomer"], "userlogin": [" useruser", "username", "customauth", "bugLogin", " userline", "courseuser", " userauth", "buglogin", " userLogin", "uselogin", " userpassword", "custompassword", "coursepassword", "pluginname", "bugline", "courselogin", "verusername", "useLogin", "useruser", "pluginpassword", "bugusername", "userLogin", "userauth", "pluginusername", " userusername", "userline", "useusername", "userusername", "userpassword", "customlogin", "pluginlogin", "verlogin", "vername", "verpassword", " username", "courseauth", "customuser", "useline"], "userDAO": [" userRAOB", "UserMAOO", "userDSB", "userAB", "usernameDAB", "usernameDSOB", "UserDAOs", "userDAOO", "userDSo", " userDAB", "usernameDSo", " userRAB", "usernameDAo", "UserDAOB", "userTAOO", "userDSOB", "UserMAO", "UserMAOB", "userDAo", "UserDAO", "userAo", " userRAO", "userAO", "userRAOB", "userDAB", "userTAO", "userMAOB", "userTAB", "userAOB", "userMAB", "userDKO", "userDSOO", " userDAOO", "usernameDSO", " userDAOB", "userDKB", "userRAO", "userMAOO", "UserMAOs", "userDAOB", "userDAOs", "userDKOB", "UserDAOO", "userRAOO", "usernameDAOB", "userTAOB", "userDSO", "usernameDAO", "userRAB", "userDSOs", "userDKo", "userMAOs", "usernameDSB", " userRAOO", "userMAO"], "user": ["resource", "use", "who", "full", "blog", "current", "state", "manager", "log", "match", "auth", "rule", "html", "v", "po", "parent", "ver", "db", "item", "or", "username", "usa", "cache", "str", "comment", "facebook", "io", "USER", "bug", "dict", "model", "per", "other", "record", "page", "member", "data", "oo", "one", "class", "ee", "creator", "er", "default", "sp", "usr", "home", "uc", "author", "ou", "type", "account", "lock", "name", "person", "group", "u", "um", "service", "response", "key", "object", "up", "config", "session", "e", "User", "result", "claim", "plugin", "job", "users", "info", "me"], "url": ["resource", "fr", "string", "blog", "href", "host", "channel", "http", "str", "URL", "path", "ur", "io", "feed", "gl", "org", "Url", "address", "bel", "orb", "lr", "rel", "browser", "l", "connection", "base", "server", "plug", "coll", "loader", "sl", "ssl", "fl", "r", "b", "account", "uri", "stream", "source", "src", "file"], "br": ["Br", "ch", "bh", "HR", "brush", "str", "bm", "ler", "ber", "ner", "bd", "yr", "buf", "rt", "sr", "bro", "BR", "tr", "mr", "lr", "browser", "bl", "cr", "err", "arr", "sp", "dr", "bc", "sl", "bar", "vr", "cb", "result", "bb", "reader", "img", "hr", "rr", "r", "b", "bf", "fb", "jar", "bed", "buffer", "stream", "bt", "body", "src", "rb", "db", "fr", "ref"], "linea": ["linesa", "linas", "linp", " linean", "linkva", "framea", " lineaf", "frameA", " linep", "lina", "linaf", "linan", "LINEp", "linsa", "linka", "lineA", "seea", " lineas", "linva", "linep", "LINEsa", "frameas", " lineva", "sean", " lineaa", " linesa", "lineaf", "seas", "lineas", "linean", "lineva", "sea", "frameaa", " lineea", "lineea", "linkaf", "linaa", "LINEa", "LINEas", "linA", "lineaa", " lineA", "linkA"], "st": ["fe", "lt", "sth", "stri", "sh", "est", "string", "rest", "sm", "ost", "sf", "str", "d", "ist", "ft", "ST", "be", "sc", "pt", "sa", "rt", "first", "ct", "STR", "ste", "bl", "ld", "cl", "l", "trans", "s", "sn", "sp", "ast", "sl", "sta", "nd", "sb", "td", "set", "start", "St", "std", "sts", "se", "ser", "sv", "b", "stack", "t", "rd", "mt", "fr"], "login": ["resource", "pass", "status", "token", "username", "line", "blog", "string", "site", "register", "join", "photo", "secret", "title", "service", "facebook", "log", "phone", "display", "pin", "Login", "auth", "email", "summary", "connection", "layout", "security", "gin", "config", "license", "company", "home", "filename", "stat", "joined", "mobile", "picture", "plugin", "account", "id", "inc", "lock", "alias", "name"], "password": ["resource", "pass", "token", "username", "fax", "sword", "string", "access", "sudo", "secret", "service", "sha", "money", "Password", "PASS", "screen", "phone", "auth", "database", "email", "wd", "pad", "phrase", "security", "config", "session", "picture", "style", "account", "pattern", "alias", "mask", "name", "padding"], "profile": ["property", "role", "pass", "class", "username", "photo", "option", "secret", "title", "money", "family", "platform", "phone", "key", "summary", "email", "theme", "settings", "pocket", "name", "company", "filename", "mobile", "Profile", "type", "picture", "style", "module", "prof", "account", "alias", "site", "file", "person"]}}
{"id1": "659316", "id2": "22264586", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"argv": ["paramv", "Argf", "argb", "argver", "argsc", "argumentve", " argV", "ArgV", "argumentc", "argl", "argc", " argf", "interc", "Argve", "argve", " argc", " argl", "argV", "argsf", "Argver", "Argv", " argver", " argb", "interV", "paramV", "Argb", "paramb", "argumentver", "argumentv", "Argc", "interl", "paraml", "argsl", "argf", "Argl", "argsv", "interv", " argve"], "sources": ["psides", "sides", "vesores", " sors", "statences", "sores", "tides", "vesigs", "issors", "issources", "sors", "sresources", "sences", "tource", "statores", "fource", "vesources", "issides", "sesources", "psource", "psources", "issource", "tources", "fources", "psresources", "sesigs", "sesences", "sigs", "tresources", "vesences", "fresources", "statources", "fors", " sides", "sesores", "fides", "statigs"], "targets": ["taxes", "taxets", "tanget", " tokets", "Tanglets", "Targels", " taxes", "tangets", "taxels", " toket", "targends", "targes", "Targlets", "Targens", "tampels", "tiges", "targels", "tagnet", "tanglets", "tampets", "taxens", "tanges", " taxens", "tangels", "tigens", "toket", "tokencies", "targens", " tokencies", "Tangels", " targes", "tokets", " taxets", " tokens", "tigets", "tigends", " targends", "tokens", " taxends", "tamplets", "tagnencies", "tangends", "tangencies", " targens", "tagnens", "taxlets", "targlets", "Targets", "tampens", "taxends", "Tangens", " targencies", "targencies", "tagnets", "Tangets", "tangens"], "srclen": [" srcloen", "srploen", "rsceln", "srselens", "srclens", " srploen", "rscelen", " srclength", "srClEN", "srcln", "srctength", "srcteno", "srseln", "srclEN", "rsclEN", "rscln", "rscelens", "srCLeno", "srceln", "srcloen", " srcleno", "rscelEN", "srCln", "srClens", " srplen", "srclength", "srplength", "srcleno", " srpleno", "srCLoen", "srselEN", "srClen", "srpleno", "srcelen", "srcelens", "rsclens", " srplength", "rsclen", "srcten", "srctoen", "srplen", "srselen", "srCLen", "srcelEN", "srCLength"], "source": ["resource", "use", "seed", "channel", "current", "cache", "Source", "view", "proxy", "service", "scope", "input", "copy", "ource", "self", "path", "slice", "force", "driver", "dest", "in", "client", "unit", "single", "s", "rc", "out", "event", "model", "url", "get", "component", "config", "size", "sl", "link", "image", "start", "SOURCE", "remote", "ssl", "reader", "secure", "type", "ources", "id", "parent", "stream", "uri", "src", "create"], "tgt": ["tnt", "tgz", " tgz", " targ", "ptgt", "lnt", "targ", " tnt", "hgt", "bitgt", "tgs", "tch", "lret", " tbuster", " tkt", "biticket", "tret", "ticket", "tbuster", "Ticket", "lbuster", " tch", " ticket", "Tgs", "bitgh", "hret", "hgz", "tkt", "ptbuster", "rch", "hnt", "rkt", "tgh", "Tgh", "bitarg", "rgs", "lgt", " tret", "Tch", "Tgt", "rgt", " tgs", "lgz", "larg", "Tkt", " tgh", "ptarg", "ptnt", "Targ"], "target": ["resource", "slave", "route", "external", "cross", "project", "channel", "current", "view", "service", "master", "path", "manager", "io", "open", "match", "force", "tail", "driver", "dest", "arget", "download", "conn", "object", "child", "archive", "unit", "handler", "it", "rel", "goal", "connection", "base", "out", "event", "port", "url", "component", "session", "director", "image", "Target", "to", "result", "member", "next", "output", "nt", "remote", "point", "mount", "null", "plugin", "parent", "client", "core"], "deletes": ["kesleted", "degrades", " dedates", "desletes", "deists", "delletes", "deles", "downgrades", "exdates", "disists", "deises", "kesouts", "deleted", "exgrades", "desires", "desles", "Deires", " deouts", "disles", " delete", "desists", "delises", "exletes", "delouts", "kesises", "deires", "delete", "deouts", "exlete", "Deles", "kesletes", "Deletes", " degrades", "disletes", "dedates", "Deists", " deises", "delleted", "downletes", "downlete", "disires", "downdates", " deleted"], "del": ["pull", "local", "Delete", "clean", "d", "dl", "remove", "copy", "delay", "down", "ll", "add", "skip", "download", "dir", "def", " delete", "err", "rel", "bl", "up", "base", "fail", "install", "model", "coll", "delete", "get", "syn", "nl", "ul", "el", " Del", "diff", "se", "data", "change", "fl", "null", "de", "id", "update", "sel", "neg", "lock", "name", "file", "Del", "dec"]}}
{"id1": "2017833", "id2": "13981689", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"hash": ["string", "Hash", "str", "sha", "sum", "transform", "hex", "number", "add", "build", "print", "base", "replace", "get", "ash", "dump", "set", "format", "check", "h", "html", "parse", "message", "update", "crypt", "block", "create"], "text": ["struct", "txt", "font", "class", "token", "Text", "string", "context", "word", "secret", "str", "version", "input", "EXT", "path", "key", "hex", " Text", "number", "length", "content", "object", "letter", "translation", " TEXT", "out", "contract", "url", "code", "value", "password", "image", "format", "bytes", "TEXT", "editor", "ext", "test", "output", "data", "message", "pattern", "source", "buffer", "binary", "name", "template"], "UnsupportedEncodingException": ["UnsupportedencodedException", "UnsupportedencodedWarning", "UnsupportedEncodedException", "UnsupportedEncgorithmWarning", "Unsupportedencodingception", "UnsupportedencodingWarning", "UnsupportedEncodedception", "Unsupportedencodedception", "UnsupportedencodingException", "UnsupportedEncasingception", "UnsupportedEncodingception", "UnsupportedEncgorithmception", "UnsupportedEncasingException", "UnsupportedEncodedWarning", "UnsupportedEncodingWarning", "UnsupportedEncasingWarning", "UnsupportedEncgorithmException"], "md": ["mb", "mp", "mg", "ms", "pm", "od", "mand", "rm", "mac", "m", "um", " MD", "d", "sha", "hm", "MD", "bd", "meta", "wd", "hd", "ad", "dd", "ld", "mc", "mod", "cmd", "ma", "mag", "f", "am", "ds", "gd", "ind", "dm", "nm", "amd", "dig", "mm", "metadata", "bf", "vd", "message", "mad", "mt", "bm", "mo"], "sha1hash": ["sha2h", "sha3sum", "ha1hex", "SHA1hash", "ha1hash", "sha4Hash", "shaonehex", "sha1match", "SHA2Hash", "sha1hex", "SHA1sum", "sha3match", "ha2sum", "shaonesum", "ha2hash", "sha2sum", "sha5sum", "sha5hex", "shaonehash", "ha2hex", "sha4sum", "sha4hex", "sha5hash", "sha1Hash", "sha3hash", "sha5h", "sha256sum", "shaonematch", "sha2hex", "sha1sum", "SHA1hex", "ha1match", "SHA2h", "sha256hash", "SHA1Hash", "sha5Hash", "sha2match", "sha2Hash", "sha4hash", "SHA2sum", "sha256Hash", "sha3hex", "sha2hash", "ha2match", "ha1sum", "SHA2hash", "sha256h", "SHA1h", "sha1h"]}}
{"id1": "22479286", "id2": "17158020", "code1": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"md5": ["md512", "MD4", "sha2", "md2", "m5", "m512", "m2", "MD512", "md4", "MD2", "sha512", "MD5", "sha5", "m4", "sha4"], "plainText": ["publictext", "plainString", "plainSecret", "singleText", " plainValue", " plainWidth", "extraByte", "encryptedText", "publicKey", "messageContent", "singleTEXT", " plainSecret", "flatWidth", "coreContent", "plaintext", "flatString", " plainByte", "regularCode", " plainCode", "plainValue", "regularSecret", "messageText", "coreText", "publicContent", "regularString", " plainKey", "flatText", "singleWidth", "regularText", " plainTEXT", "plainCode", "plainTEXT", "rubyContent", "regularShort", "messageSecret", "publicText", "flatTEXT", " plaintext", "encryptedContent", "messageCode", "extraContent", "plainKey", "publicTEXT", "plainShort", "encryptedtext", " plainShort", "regulartext", " plainString", "rubyValue", "flatShort", "plainWidth", "coreTEXT", "plainByte", "rubyText", " plainContent", "flattext", "rubyByte", "coreValue", "extraTEXT", "rubyTEXT", "extraText", "encryptedTEXT", "regularContent", "flatKey", "plainContent"], "md": ["df", "mb", "mp", "mg", "pd", "ms", "pm", "mand", "rm", "mac", "Cmd", "m", "sm", " MD", "d", "sha", "hm", "MD", "bd", "meta", "wd", "hd", "ad", "dd", "mc", "gb", "cd", "mod", "cmd", "mag", "f", "am", "dm", "hash", "amd", "rpm", "dig", "mm", "de", "metadata", "vd", "message", "mt", "me", "mo"], "digest": ["dedest", "dedex", "dimex", "dimEST", "dested", "mdest", "digex", "Digester", "Digested", "compit", "compest", "compEST", "digitester", "digitest", " digEST", "digested", "digester", "dest", "DigEST", "mdit", " digester", " digested", "dimested", "mdger", "Digit", "dedEST", "digEST", "digitEST", "Digger", "dimest", "digitested", "dester", "digger", "dEST", "digit", "Digest", "compger", "mdEST", "Digex", "dedested"], "hexString": ["rawArray", "tempstring", "stringSingle", "stringString", "hexSingle", "exText", " hexSingle", "hexstring", "tempBuffer", "exString", "exService", "exContent", "rawString", "exstring", "longText", " hexstring", "tempService", "hexContent", "longService", " hexBuffer", " hexText", "hexArray", "hexBuffer", " hexArray", "hexService", "stringArray", " hexService", "tempString", "longString", "exBuffer", " hexContent", "rawBuffer", "rawSingle", "longContent", "hexText", "stringBuffer"], "i": ["si", "qi", "u", "at", "multi", "n", "ii", "c", "m", "pi", "k", "o", "d", "ci", "di", "io", "z", "number", "slice", "ui", "in", "length", "ri", "bi", "count", "p", "it", "l", "part", "phi", "s", "j", "I", "x", "index", "f", "e", "oi", "li", "a", "start", "v", "gi", "ti", "type", "ai", "b", "xi", "t", "id", "info", "uri", "mu", "end"]}}
{"id1": "3994258", "id2": "6188784", "code1": "    public boolean connectServer(String server, String user, String password) {\n        boolean result = true;\n        try {\n            if (user.equals(\"\")) {\n                user = \"anonymous\";\n                password = \"anonymous\";\n            }\n            this.server = server;\n            this.user = user;\n            this.password = password;\n            ftpClient = new FTPClient();\n            ftpClient.setControlEncoding(encode);\n            ftpClient.connect(server);\n            ftpClient.setSoTimeout(1000 * 30);\n            ftpClient.setDefaultTimeout(1000 * 30);\n            ftpClient.setConnectTimeout(1000 * 30);\n            ftpClient.enterLocalPassiveMode();\n            ftpClient.login(user, password);\n            if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {\n                ftpClient.disconnect();\n                return false;\n            }\n            queFilePath = \"data\\\\\" + this.server + \".que\";\n            bufFilePath = \"data\\\\\" + this.server + \".buf\";\n            startGetList();\n        } catch (java.net.SocketTimeoutException e1) {\n            errMsg = ftpClient.getReplyString();\n            errCode = ftpClient.getReplyCode();\n            result = false;\n            setArrToFile(dirQueue, queFilePath);\n            setArrToFile(fileList, bufFilePath);\n            cn.imgdpu.util.CatException.getMethod().catException(e1, \"\u8fde\u63a5\u8d85\u65f6\");\n        } catch (Exception e) {\n            errMsg = ftpClient.getReplyString();\n            errCode = ftpClient.getReplyCode();\n            result = false;\n            setArrToFile(dirQueue, queFilePath);\n            setArrToFile(fileList, bufFilePath);\n            cn.imgdpu.util.CatException.getMethod().catException(e, \"\u672a\u77e5\u5f02\u5e38\");\n        } finally {\n            if (ftpClient.isConnected()) {\n                try {\n                    ftpClient.disconnect();\n                } catch (IOException ioe) {\n                    cn.imgdpu.util.CatException.getMethod().catException(ioe, \"IO\u5f02\u5e38\");\n                }\n            }\n        }\n        return result;\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"connectServer": ["connectGuest", "connectService", " ConnectService", " ConnectBot", " reconnectService", " reconnectServer", "connectBot", " connectGuest", " connectService", " ConnectGuest", " ConnectServer", " connectBot", " reconnectGuest", " reconnectBot"], "server": ["resource", "slave", "stage", "username", "seed", "project", "serv", "string", "host", "version", "proxy", "service", "master", "node", "layer", "manager", "outer", "engine", "queue", "driver", "enter", "database", "email", "mode", "address", "connection", "device", "domain", "reverse", "port", "url", "system", "name", "localhost", "worker", "peer", "erver", "center", "socket", "remote", "page", "ssl", "directory", "ser", "Server", "type", "serving", "parser", "loop", "uri", "ver", "client", "source", "ssh", "site"], "user": ["role", "ume", "pass", "root", "token", "username", "use", "usa", "u", "owner", "project", "clean", "string", "zero", "host", "site", "secret", "proxy", "uid", "path", "manager", "log", "search", "match", "key", "force", "ui", "auth", "email", "client", "creator", "custom", "object", "address", "USER", "profile", "up", "device", "replace", "model", "url", "query", "usr", "field", "date", "session", "User", "by", "home", "login", "author", "data", "write", "type", "student", "plugin", "human", "account", "id", "users", "job", "ver", "me", "lock", "source", "name", "file", "person"], "password": ["resource", "pass", "token", "username", "words", "sword", "who", "description", "string", "host", "word", "sudo", "secret", "Password", "wallet", "path", "manager", "params", "patch", "key", "auth", "database", "email", "wd", "pad", "custom", "address", "alias", "weight", "command", "profile", "staff", "device", "prefix", "phrase", "security", "size", "python", "home", "mobile", "login", "data", "picture", "account", "client", "mask", "column", "name", "padding"], "ftpClient": [" ftpaCase", "wdbCenter", "ftnpCase", " ftpCell", "ftpaSession", " ftpConfig", "ftfConn", "ftPServer", "aptpCase", "aptfpServer", "ftpConfig", "ftpCan", " ftpingCell", "ftbCase", "ftmClient", "ftpcCell", "aftpConfig", "ftpSession", "ftpHost", "ftcServer", " ftportClient", "ftiCase", "ftportclient", "ftpingFactory", "aftpcClient", "ftpConn", " ftpCall", "aftpcMaster", " ftpCan", "ffpCase", "fttpclient", "ftfpCenter", "ftfpConfig", "fttpCall", "ftcpServer", "ctpClient", "ftcpCan", "ftwServer", "ftpoCase", "ftpcCloud", " ftpCloud", "ftpcServer", "ftfHost", "ftpContext", "ftpCell", "wdpCenter", " ftiCase", "ftfpCloud", "aftpcConfig", " ftpFactory", " ftnConnection", "ftfpClient", "aftpSession", "aftfClient", " ftpclient", "wdpClient", "ftpingCell", "ftnpServer", "ftcpConfig", "aftpCloud", "ftspClient", "fttFactory", "ftpSystem", "aptpServer", "ffpServer", "ftfCall", "ftPCase", "ftpMaster", "ftcpFactory", "ftcclient", "ftcCase", "ftcpCase", "ftspclient", " ftpListener", "ctcpCase", "ftpcFactory", " ftPContext", "ftpcSession", "ftcFactory", "ftbSystem", "fttpCan", "aftpcCloud", "ctpServer", " ftpConn", " ftportListener", "ftiClient", "ftPclient", "ftPClient", "ftwConn", "ftpaClient", "ctpCase", "ftfClient", "ftpcConnection", " ftpingClient", "wdbCase", "ftcConfig", "ftfConfig", "ftnConn", "aftpClient", "ctcpclient", "ftpingClient", "ftpoClient", "ctcpServer", "ftcpConn", "ftnClient", "ftnConnection", " ftnClient", " ftportclient", "ftpListener", "htbaseCase", " ftPclient", "ftspListener", "ftpServer", "ftnCase", "ftmServer", "aftpMaster", "ctcpConn", "aptfpSystem", "ffPClient", " ftpaCall", " ftcClient", " ftcConfig", " ftpCase", "htbaseClient", "ftfCase", "aptpSystem", "ftiCan", " ftpaClient", "wdpCase", "ftfSession", "ftfpCan", "ftpFactory", "htpClient", "ftfpMaster", "ftbaseClient", "fttpHost", "ftfpCase", "fttCase", "ftpcConn", "htpCase", "fttpContext", " ftpingMaster", "aptfpClient", "ftpcCan", "ftfCell", "ftpingMaster", "aptfpCase", "ftpCenter", "fttpCase", "ftwClient", "ftPCan", "ftpConnection", "ftPContext", " ftpMaster", " ftPClient", " ftpaHost", "fttCan", "aftfMaster", "ftpaCall", "ftpCase", " ftcFactory", " ftnCase", " ftiClient", " ftpConnection", "ftcListener", " ftpServer", "ftnpSystem", "ftfpServer", "wdbClient", "ftpaMaster", "ftpcCase", "ftfCloud", "ftpcConfig", "ftbServer", "ftmCase", "ctcpClient", "fttCenter", " ftnConn", "ftfMaster", "ftbCenter", "wdbCan", "ctpclient", "fttpClient", "ftwCase", "ftportClient", "ftpaCase", "ctpConn", "ftbClient", "ftpcClient", "ftnpClient", "ffPCase", "ftbaseCase", "ftbCan", "ftcClient", " ftpHost", "ftpCall", " ftpingFactory", "ftpcMaster", "ftpaHost", "fttpServer", " ftPCan", "ftfpSystem", "ffPServer", "ftcpClient", " ftcCase", "fttClient", "ftbCloud", "ftfFactory", "ftfConnection", "ftpCloud", "ffpClient", " ftpContext", "ftcpContext", "ftcpclient", "aptpClient", " ftiCan", "wdpCan", "ftpclient", "aftfSession", "ftportListener", "fttConfig"], "queFilePath": ["cachefileName", "queDataCh", "QueFilePath", "poolFilePoint", "queFilepath", "queFileName", "queDatapath", "queLineName", "quefileHalf", "quePlacePoint", "queFullName", "quefilePath", "queFilespath", "queDataName", "QueLinepath", "cacheFileSource", "QueFileCh", "queTimeIs", "poolFileIs", "queFilesCh", "poolFileHalf", "queDataPath", "queFileCh", "queLineCh", "queTimePath", "QueLineCh", "queFileHalf", "cachefilePath", "quefileSource", "poolfilePoint", "quePlaceIs", "quefilepath", "queTimePoint", "queLinepath", "QueFileName", "cachefileSource", "cacheFilePath", "poolfileIs", "QueFilepath", "quePlaceHalf", "queFullPath", "queFilesPath", "poolFilePath", "poolfileHalf", "queLineSource", "queFilePoint", "quefilePoint", "cacheFilepath", "cacheFileName", "quefileName", "queFileSource", "queFullSource", "cachefilepath", "queLinePath", "quefileIs", "queFileIs", "queTimeHalf", "QueLinePath", "queFullpath", "queFilesName", "QueLineName", "poolfilePath", "quePlacePath"], "bufFilePath": ["ufDirHome", "ufFileReader", "bufLogPath", "ufFIs", "bufLineName", "bufLinePath", "bufFileSystem", "bufDirHome", "ufDirCh", "ufFileCh", "bufLogCh", "ufFileHome", "bufQueueHome", "ufDirLocation", "bufFileReader", "ufDirPath", "bufDirCh", "bufLogLocation", "bufPathSync", "ufFileSync", "bufLineSystem", "ufFileSystem", "ufFName", "bufFPath", "bufFileIs", "bufFileHome", "bufEntryReader", "ufDirReader", "bufEntryPath", "ufFPath", "bufIfSystem", "bufEntrySync", "ufFSystem", "bufPathLocation", "bufFName", "bufPathReader", "bufDirSync", "bufFileSync", "ufFilePath", "bufFSystem", "bufPathPath", "ufFileIs", "bufFIs", "bufDirReader", "bufDirLocation", "bufDirPath", "bufQueueCh", "bufIfIs", "bufLogHome", "bufQueueLocation", "bufLineIs", "bufQueuePath", "bufEntryLocation", "bufIfPath", "bufFileName", "ufDirSync", "ufFileLocation", "bufFileLocation", "ufFileName", "bufIfName", "bufFileCh"], "errMsg": [" errModule", "msgModule", " errNum", "errormsg", "errMessage", "erNum", "errorModule", " errmsg", "errorMsg", "errModule", " errMessage", "msgMsg", "errorNum", "msgMessage", "errNum", "errorMessage", "msgmsg", "ermsg", "erMessage", "errmsg", "erMsg"], "errCode": [" errNum", "rrNo", " errC", "rrCode", "errNo", "errC", "errorMsg", "errorCode", "rrC", "errorNo", "errorNum", "rrMsg", "errorC", " errNo", "errNum", "rrNum"], "result": ["resource", "df", "status", "class", "acc", "use", "Result", "append", "results", "comment", "total", "response", "ge", "sum", "open", "match", "list", "color", "json", "progress", "ret", "count", "br", "successful", "default", "order", "rc", "show", "event", "future", "url", "work", "load", "now", "complete", "date", "success", "res", "gi", "test", "error", "message", "parent", "lock", "back", "update"]}}
{"id1": "18202328", "id2": "15500892", "code1": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"register": [" reg", " Register", "activate", "Login", "auth", "user", "play", "app", "init", "setup", "chain", " regenerate", "reg", "load", " registration", "config", "password", "bind", "start", "connect", "check", "login", " unlock", "save", "Register", "update", "master", "create"], "session": ["ess", "resource", "slave", "group", "temp", "window", "section", "use", "global", "position", "cache", "host", "channel", "room", "request", "gui", "view", "version", "proxy", "script", "service", "state", "master", "input", "facebook", "manager", "sa", "sync", "driver", "database", "user", "child", "conn", "cookie", "play", "browser", "ession", "video", "mc", "connection", "device", "event", "port", "shell", "server", "security", "thread", "game", "config", "sb", "machine", "python", "Session", "caster", "password", "image", "connect", "socket", "h", "remote", "login", "ssl", "message", " Session", "lock", "parent", "client", "site", "person"], "username": ["property", "Name", "attribute", "voice", "subject", "token", "seed", "sword", "mother", " nickname", "string", "host", "word", "minecraft", "secret", "title", "character", "uid", "Password", "amer", "path", "phone", "text", "driver", "auth", "database", "email", "length", "user", "address", "verb", "profile", "steam", "hello", "prefix", "nick", "phrase", "url", " password", "localhost", "password", "filename", "ame", "NAME", "mobile", "login", "ername", "term", "duration", "account", "message", "users", "uri", "crypt", "source", "name", "monitor", "person"], "verificationKey": ["signationkey", "vermentSecret", "signationKey", "verificationKEY", "verifySecret", "validificationPoint", "validifyingSecret", "verifykey", "verationKey", "validificationKey", "verationPoint", "verationKEY", "verifyingKEY", "verifyingkey", "verifyPoint", "validificationkey", "vermentkey", "verifyingPoint", "significationkey", "verifyingSecret", "validificationSecret", "verificationPoint", "validifyingPoint", "verifyingKey", "vermentKey", "significationKEY", "vermentKEY", "signationKEY", "verationSecret", "verifyKey", "verificationkey", "verificationSecret", "signationSecret", "validifyingkey", "validifyingKey", "verationkey", "significationKey", "significationSecret"], "salt": ["SSalt", "sealt", "SALT", "sodium", "setsort", "Shash", "seALT", "setsALT", "sSalt", "sALT", "suffalt", "suffhash", " sALT", "suffALT", "Salt", "sehash", " sort", "seSalt", "suffSalt", "setsodium", "setsalt", "shash", " sodium", "sort"], "hash": ["hed", "string", "mac", "cache", "Hash", "host", "secret", "total", "sha", "input", "sum", "log", "match", "key", "hex", "number", "auth", "user", "address", "square", "header", "kh", "build", "url", "query", "ash", "name", "array", "pool", "password", "her", "h", "result", "memory", "html", "output", "message", "buffer", "crypt", "text", "version"], "digest": ["Diggest", "bigest", "signEST", "hedest", "logest", "bigested", "bigester", " digests", " digit", "Digester", "Digested", "signest", " digger", "digested", " digEST", "digester", "defe", "DigEST", " digester", "logit", " digested", "hedested", "defest", "hedester", "dige", " diggest", "Digit", "logester", "digEST", "Digger", "signests", "diggest", "signested", "defester", "Digests", "digger", "digests", "digit", "Digest", "Dige", "logger", " dige", "defEST", "biggest", "hedEST"], "nameChars": ["nameCharARS", "nameChears", " nameChats", " nameCharars", "nameChases", " nameChacters", "nameCharts", "nameGrars", "nameGrarts", "namechases", "nameChararts", "nameCheARS", "nameChARS", "nameCharars", "namechacters", "namechats", " nameCharts", " nameChararts", "nameChats", "nameCheats", "nameGrARS", "nameCharacters", " nameCharacters", "namechars", " nameCharARS", "namecharts", "nameGracters", "nameCheases", "nameChacters", " nameChARS", "namechARS", " nameChases"], "nameChar": [" NameChar", " nameCh", "addressChar", "nameCtrl", " nameDir", "resourceCharacter", " NameCharacter", " nameCtrl", "resourceChar", "NameChar", "idChar", " NameCh", "resourceDir", "addressCtrl", "NameDir", "addressCh", " NameText", "resourcechar", "NameCharacter", "idCharacter", "namechar", "NameCh", "nameCh", "idCh", " nameCharacter", "nameText", " nameText", "nameDir", "nameCharacter", "Namechar", "addressCharacter", " namechar", "idText", "NameCtrl"], "p": ["ap", "pc", "cop", "u", "at", "n", "g", "op", "py", "o", "m", "d", "api", "np", "pair", " P", "pp", "er", "br", "up", "l", "part", "s", "pe", "j", "pa", "cp", "sp", "per", "f", "e", "lp", "i", "pre", "q", "a", "h", "fp", "v", "P", "jp", "point", "r", "po", "ps", "t", "b", "client"], "player": ["slave", "gamer", "live", "class", "media", "team", "owner", "pm", "position", "g", "n", "m", "leader", "board", "script", " Player", "ler", "winner", "master", "layer", "manager", "can", "match", "driver", "person", "players", "conference", "user", "er", "play", "aster", "l", "video", "part", "connection", "steam", "pe", "server", "game", "playing", "party", "per", "pool", "e", "machine", "controller", "caster", "worker", "played", "Player", "member", "data", "parent", "client", "ace", "name", "pro", "league"], "c": ["dc", "pc", "fc", "cm", "n", "cache", "m", "k", "ca", "o", "d", "abc", "ci", "ctx", "con", "sc", "cf", "ct", "cu", "ac", "ce", "C", "cc", "cr", "cl", "l", "mc", "rc", "chain", "cp", "config", "cs", "bc", "f", "enc", "arc", "h", "cb", "v", "r", "t", "conf", "nc", "ec", "tc", "lc"]}}
{"id1": "442381", "id2": "2518655", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "label": 0, "substitutes": {"doVersionCheck": [" doReleasecheck", "doversionTest", " doVersionWork", " doBuildcheck", "doBuildCheck", "doVERSIONTest", " doBuildCheck", " doVersioncheck", " doReleaseTest", "doVERSIONWork", "doVersionWork", "doBuildTest", "doReleaseWork", "doversioncheck", "doBuildcheck", "doVERSIONcheck", "doVersioncheck", " doReleaseCheck", "doVERSIONCheck", " doBuildWork", "doVersionTest", "doReleasecheck", " doBuildTest", " doVersionTest", "doversionCheck", "doReleaseCheck", "doBuildWork", "doReleaseTest"], "view": ["row", "window", "accept", "use", "full", "View", "cache", "see", "gui", "http", "request", "comment", "input", "self", "screen", "can", "edit", "display", "box", "VIEW", "this", "ui", "client", "div", "object", "gu", "l", "app", "vis", "show", "out", "layout", "model", "port", "server", "event", "cell", "config", "block", "e", "session", "q", "el", "image", "widget", "page", "v", "change", "reader", "html", "style", "buffer", "update", "lock", "body", "form", "sel", "views"], "url": ["resource", "stream", "ob", "zip", "string", "channel", "blog", "host", "http", "service", "input", "URL", "log", "ll", "path", "open", "Url", "client", "user", "address", "bel", "build", "browser", "l", "connection", "base", "server", "loader", "sl", "f", "hub", "image", "lib", "socket", "ssl", "bb", "web", "uri", "buffer", "source", "file"], "in": ["resource", "In", "n", "ini", "IN", "cin", "is", "din", "inner", "input", "as", "con", "ins", "ac", "inn", "isin", "init", "win", "s", "lin", "out", "rin", "gin", "i", "nin", "socket", "sin", "login", "bis", "reader", "data", "b", "inc", "binary", "stream", "source", "buffer", "file"], "bin": ["inline", "run", "nb", "oin", "bot", "IN", "cin", "ruby", "fin", "din", "inner", "input", "abi", "log", "con", "pin", "bn", "inn", "bi", "browser", "kin", "part", "init", "win", "lin", "out", "gin", "loader", "lib", "socket", "sin", "record", "border", "bb", "reader", "data", "spin", "b", "binary", "buffer", "lock", "body", "ln", "file"], "line": ["inline", "look", "band", "entry", "row", "pass", "day", "ip", "string", "site", "lines", "word", "LINE", "ine", "str", "comment", "le", "Line", "ge", "layer", "log", "key", "no", "object", "letter", "unit", "valid", "cl", "l", "part", "up", "base", "rule", "lin", "cell", "pe", "model", "load", "definition", "non", "link", "e", "code", "i", "home", "nl", "el", "split", "lo", "page", "data", "parse", "style", "b", "lf", "message", "job", "source", "id", "text", "block", "name", "file", "lc", "end"], "develBuild": ["dellRelease", "deployRun", "DEVELbuild", "deployBuilder", "DEvelBuild", "devenBuilt", "deelBuild", "desvenBuilt", "deelBuilder", "develBuilder", "desvelBuild", "dellRun", "DEVELBuild", "devenbuild", "deVELBuild", "desvelbuild", "dellBuilder", "deploybuild", "devenRelease", "desvelRun", "DEVELBuilt", "devenBuilder", "dewardBuilt", "deviousBuilt", "desvelRelease", "deviousbuild", "deviousBuild", "DEvelbuild", "deVELRun", "deVELBuilder", "develbuild", "devenBuild", "desvenBuild", "DEVELBuilder", "DEvelBuilder", "dewardBuild", "develRelease", "develRun", "dewardbuild", "develBuilt", "deVELbuild", "desvenBuilder", "deployBuilt", "desvenRun", "dellBuild", "deelRelease", "deVELBuilt", "desvelBuilder", "desvelBuilt", "deelRun", "desvenbuild", "desvenRelease", "devenRun", "DEvelBuilt", "deployBuild", "dewardBuilder"], "stableBuild": ["prettyBuilder", "stableBuilder", "stablebuild", "baseVersion", " stableVersion", "compatibleBuilder", "staticbuild", "basebuild", "latestBuild", "validBuild", "stableVersion", "compatiblebuild", "latestbuild", "baseBuilder", "securebuild", "baseBuild", "prettyVersion", "prettybuild", "validBuilder", "staticBuilder", "secureBuilder", "compatibleBuild", "staticBuild", "validbuild", " stablebuild", "prettyBuild", " stableBuilder", "secureBuild", "latestBuilder"]}}
{"id1": "11562173", "id2": "16572931", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"checkInputStream": [" checkOutputstream", "checkInputstream", "checkOutputChannel", " checkInputSteam", "checkFilestream", "checkIOStream", " checkOutputSteam", "checkInputSteam", " checkOutputStream", "checkIOChannel", " checkInputChannel", "checkFileSteam", "checkOutputstream", "checkFileStream", "checkIOstream", "checkOutputSteam", "checkInputChannel", "checkFileChannel", "checkIOSteam", "checkOutputStream", " checkInputstream", " checkOutputChannel"], "in": ["In", "plus", "again", "ini", "c", "IN", "is", "din", "inner", "bin", "input", "ic", "as", "con", "io", "ins", "min", "inn", "ack", "into", "p", "up", "isin", "connection", "x", "index", "comp", "image", "login", "reader", "data", "inc", "source", "src"], "cmp": ["mp", "ctrl", "pc", "ch", "cop", "cho", "mom", "c", "cache", "op", "spec", "cpp", "pixel", "comment", "conv", "ci", "ctx", "prev", "np", "match", "co", "omp", "loc", "sup", "p", "cc", "up", "proc", "amp", "rc", "asc", "cp", "prefix", "coll", "config", "cs", "cup", "index", "comp", "code", "pre", "upp", "cb", "fp", "diff", "clip", "sort", "roc", "com", "lc"], "all": ["local", "each", "ALL", "not", "global", "full", "and", "call", "total", "ann", "sum", "partial", "match", "none", "list", "only", "process", "p", "alpha", "valid", "cl", "default", "l", "except", "asc", "coll", "array", "best", "am", "allow", "any", "auto", "a", "both", "al", "acl", "null", "All", "always", "parent", "one"], "stream": ["track", "temp", "speed", "string", "channel", "instance", "host", "context", "src", "input", "self", "response", "transform", "platform", "feed", "this", "impl", "progress", "object", "user", "ack", "roll", "iterator", "trans", "up", "steam", "document", "sw", "Stream", "model", "port", "coll", "per", "pool", "comp", "wrapper", "socket", "result", "v", "test", "output", "reader", "raw", "null", "stack", "source", "client", "cont", "form", "round", "ream"], "out": ["not", "again", "project", "full", "c", "o", "exp", "option", "comment", "bin", "Out", "response", "sum", "copy", "outer", "io", "outs", "list", "this", "sync", "user", "p", "up", "part", "prefix", "x", "array", "index", "other", "image", "v", "result", "output", "data", "obj", "OUT", "null", "point", "b", "inc", "parent", "block", "name", "extra"], "i": ["hi", "si", "qi", "u", "multi", "n", "ii", "c", "k", "pi", "ini", "d", "abi", "ci", "di", "io", "key", "slice", "ji", "ui", "ri", "bi", "p", "it", "l", "strength", "init", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "ind", "start", "h", "v", "gi", "ti", "type", "ai", "mi", "r", "b", "xi", "id", "info", "uri", "ix", "lc", "end"]}}
{"id1": "9261777", "id2": "5414088", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"source": ["resource", "token", "use", "seed", "project", "zip", "string", "Source", "request", "view", "spec", "proxy", "inner", "service", "scope", "comment", "input", "options", "ource", "copy", "path", "empty", "slice", "force", "dest", "in", "original", "address", "shared", "single", "unit", "sample", "missing", "rule", "base", "element", "prefix", "url", "query", "config", "size", "name", "index", "flat", "sl", "session", "strip", "SOURCE", "image", "start", "sin", "result", "secure", "se", "data", "parse", "style", "target", "null", "id", "parent", "uri", "text", "info", "src", "site", "file", "sort", "template"], "destination": ["dominated", "desturation", " destinating", " destipping", "destinations", "domination", " destinator", "dependension", "coordinating", "destinating", "destipping", " destension", "homeignment", "Destinations", "destinator", "Destinator", "Destinating", "coordination", "Destination", "homeinated", "databaseuration", "destinated", "Destinated", "homeination", " destignment", "Destinate", "homeinator", "destinate", "distipping", "Destignment", "coordinate", "dependination", "dependipping", "dependinated", "domuration", "databaseinated", " destinated", "dominations", "destignment", "distension", "distinated", "coordinator", " destinate", "distination", "databaseinations", "databaseination", "Desturation", "destension"], "is": ["ib", "ics", "or", "us", "ip", "isa", "ios", "serv", "zip", "bs", "ens", "isl", "ois", "osi", "ir", "ob", "act", "ii", "was", "iris", "oss", "ci", "as", "ic", "api", "abs", "ais", "IS", "io", "ui", "in", "ins", "ri", "are", "ie", "fs", "obs", "init", "s", "Is", "out", "iss", "iso", "ar", "ops", "eni", "cos", "get", "isi", "isc", "sis", "i", "ori", "sin", "close", "mis", "bis", "se", "lis", "ai", "nis", "esi", "id", "es", "info", "src", "ris"], "os": ["or", "ks", "js", "us", "ol", "ios", "so", "bs", "ens", "ob", "osi", "op", "ies", "o", "mos", "dos", "oa", "oss", "as", "oise", "io", "ais", "sys", "aos", "boot", "bos", "oes", "acs", "ose", "fs", "obs", "s", "nos", "pos", "out", "oS", "vs", "ls", "los", "ops", "cos", "ot", "Os", "i", "ds", "ori", "oses", "ros", "socket", "ou", "es", "ends", "OS", "ss", "ow"], "buffer": ["seed", "position", "string", "channel", "uffer", "limit", "padding", "copy", "layer", "wave", "sequence", "feed", "buf", "slice", "queue", "number", "pad", "address", "header", "batch", "base", "server", "url", "size", "read", "Buffer", "iter", "value", "image", "writer", "bytes", "transfer", "page", "border", "result", "reader", "bb", "data", "null", "b", "buff", "flush", "binary", "reference"], "length": ["distance", "row", "section", "line", "of", "position", "ob", "string", "full", "volume", "depth", "limit", "character", "total", "shape", "lower", "Length", "power", "partial", "division", "match", "sequence", "slice", "number", "feed", "key", "ring", "object", "address", "count", "age", "weight", "l", "part", "url", "get", "load", "left", "size", "index", "code", "len", "value", "strip", "split", "start", "quote", "last", "level", "reader", "type", "data", "range", "point", "style", "duration", "id", "offset", "lock", "block", "width", "end"]}}
{"id1": "646016", "id2": "21232043", "code1": "    public void elimina(Cliente cli) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorCliente.elimina()\");\n        int id = cli.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            sql = \"DELETE FROM persona WHERE id =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt.executeUpdate(sql);\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        }\n    }\n", "code2": "    @Override\n    public File call() throws IOException {\n        HttpURLConnection conn = null;\n        ReadableByteChannel fileDownloading = null;\n        FileChannel fileWriting = null;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            if (size == -1) {\n                size = conn.getContentLength();\n            }\n            fileDownloading = Channels.newChannel(conn.getInputStream());\n            fileWriting = new FileOutputStream(file).getChannel();\n            long left = size;\n            long chunkSize = BLOCK_SIZE;\n            for (long downloaded = 0; downloaded < size; left = size - downloaded) {\n                if (left < BLOCK_SIZE) {\n                    chunkSize = left;\n                }\n                fileWriting.transferFrom(fileDownloading, downloaded, chunkSize);\n                downloaded += chunkSize;\n                setProgress(downloaded);\n            }\n        } finally {\n            if (file != null) {\n                file.deleteOnExit();\n            }\n            if (conn != null) {\n                conn.disconnect();\n            }\n            if (fileDownloading != null) {\n                try {\n                    fileDownloading.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0441\u043a\u0430\u0447\u0438\u0432\u0430\u043d\u0438\u044f\", ioe);\n                }\n            }\n            if (fileWriting != null) {\n                try {\n                    fileWriting.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 \u0444\u0430\u0439\u043b\", ioe);\n                }\n            }\n        }\n        return file;\n    }\n", "label": 0, "substitutes": {"elimina": [" elimita", " elrimada", "elimerina", "elrimada", " elimini", "elimalita", "elimalini", "elrimina", "elrimita", " elrimini", "elimalina", " elrimina", "elrimini", "elimerada", " elrimita", "elimerini", "elimita", "elimini", "elimerita", "elimalada", " elimada", "elimada"], "cli": ["hi", "ctrl", "uci", "c", "osi", "API", "cfg", "gui", "dl", "ci", "di", "ctx", "api", "util", "cci", "colo", "ui", "cu", "oci", "conn", "l", "connection", "CL", "cmd", "server", "cgi", "sci", "li", "i", "gd", "lo", "gi", "ctl", "xi", "uri", "client", "Client", "GUI", "lu", "lc"], "id": ["resource", "entry", "status", "ip", "sid", "zip", "oid", "d", "version", "ids", "pid", "Id", "uid", "path", "aid", "key", "ID", "in", "database", "num", "client", "active", "email", "address", "p", "it", "connection", "model", "server", "url", "x", "like", "index", "f", "ident", "admin", "code", "patient", "i", "q", "value", "start", "h", "val", "login", "error", "type", "vid", "md", "style", "en", "ql", "info", "kid", "mid", "name", "db"], "sql": ["il", "status", "js", "cop", "live", "seed", "function", "zip", "string", "statement", "lua", "sf", " SQL", "eps", "script", "str", "dl", "comment", "msg", "log", "ll", "params", "util", "os", "sol", "details", "sys", "sync", "auth", "rl", "no", "generic", "err", "lang", "l", "liquid", "base", "layout", "ls", "cmd", "install", "shell", "query", "url", "sl", "sb", "su", "lv", "i", "nl", "sex", "repl", "result", "ssl", "sal", "html", "data", "type", "sg", "sv", "null", "ql", "job", "general", "SQL", "ln", "name", "db", "sq", "lc"], "stmt": ["stmd", " stsql", "stm", "shmn", " stmb", " stmm", "sthm", "estmb", "estmm", " stpt", " stdb", "stpt", "stmp", "Stmt", "putpt", "instmt", " sttr", "estnt", "estpt", "instdd", "fmt", "estmd", " stmn", "stdb", "Stmd", "Stmp", "stnt", "Stmm", "StMT", "stdr", " stnt", " stMT", "Stdb", "sthdr", "shnt", "estmn", "shmt", "estdb", "sthmt", "stdd", " stdr", "shtr", "esttr", " stmp", "stMT", "stmb", " stmd", "fm", "fMT", "Stm", "stmn", "stmm", "putsql", "instm", "putmt", "putmb", "sthdd", "estsql", "fmp", " stm", "sttr", "instdr", "stsql", " stdd", "estmt"]}}
{"id1": "7006052", "id2": "19113613", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copySourceFileInfo", " copyFilesFrom", " copyFileFrom", "copySourceFileFile", "copySourceFileFrom", " copyFilesFile", " copyFileFile", "copyfileTo", "copyfileInfo", "copyfileFrom", "copyFilesInfo", "copyFileInfo", "copyFilesFile", "copySourceFileTo", "copyFileFile", " copyFilesTo", "copyFileFrom", " copyFileInfo", "copyfileFile", "copyFilesFrom", "copyFilesTo", " copyFilesInfo"], "src": ["resource", "txt", "js", "string", "href", "old", "path", "sc", "slice", "sync", "archive", "fn", "loc", "sup", "s", "rc", "upload", "url", "config", "sl", "sb", "code", "filename", "image", "sin", "inf", "remote", "img", "data", "b", "sub", "rs", "source", "stream", "uri", "sel", "rb", "file"], "dest": ["folder", "txt", "temp", "done", "route", "project", "opt", "dist", "bin", " Dest", "desc", "die", "dir", "loc", "sup", "comb", "default", "orig", "tmp", "delete", "flat", "des", "home", "filename", "Dest", "result", "img", "output", "test", "data", "secure", "target", "b", " destination", "sub", "source", "const", "wb", "name", "later"], "destFile": ["targetFile", "destF", " destinationF", "destDir", " destinationFiles", " destinationDir", " destF", "destfile", "destFiles", " destinationFile", "Destfile", "DestF", "DestFile", "targetFiles", " destFiles", "DestDir", " destDir", "DestFiles", "targetfile", "targetDir", " destfile"], "in": ["In", "pass", "again", "n", "ini", "IN", "cin", "is", "din", "inner", "bin", "input", "con", "pin", "ins", "impl", "inn", "err", "kin", "trans", "up", "l", "init", "win", "s", "lin", "rin", "url", "gin", "thin", "f", "inside", "i", "nin", "image", "socket", "login", "reader", "diff", "data", "r", "inc", "id", "source", "stream", "ln"], "out": ["again", "n", "cache", "o", "exp", "ex", "inner", "bin", "Out", "copy", "log", "outer", "io", "post", "sync", "this", "ac", "conn", "user", "err", "up", "part", "net", "w", "exec", "work", "cos", "pool", "other", "off", "image", "writer", "plain", "ext", "output", "data", "obj", "OUT", "null", "inc", "parent", "client", "one", "file", "extra"], "buf": ["bh", "vec", "map", "cache", "c", "cas", "cv", "bin", "path", "ctx", "bd", "box", "queue", "pad", "length", "seq", "loc", "batch", "br", "bl", "bag", "ff", "orig", "rc", "tmp", "bc", "Buffer", "pool", "block", "off", "blocks", "uf", "cap", "uc", "bytes", "cb", "v", "result", "data", "raw", "b", "bf", "buff", "fb", "buffer", "rb"], "len": ["line", "n", "c", "fin", "Len", "fd", "num", "length", "no", "min", "count", "ie", "l", "part", "base", "pos", "all", "coll", "url", "size", "f", "iter", "off", "pre", "ind", "cap", "el", "split", "li", "val", "bytes", "lim", "nt", "data", "fl", "en", "id", "lf", "rev", "body", "ln", "lc", "end"]}}
{"id1": "21181542", "id2": "11484416", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "label": 0, "substitutes": {"deleteRoleType": ["deleteRoleTypes", "deleteFunctionTypes", " deleteroleTyp", "deleteRoletype", " deleteRoletype", "deleteRoleTyp", " deleteroletype", " deleteroleTypes", "deleteFunctionTyp", "deleteroleTyp", "deleteroletype", "deleteResourceType", " deleteRoleTypes", "deleteFunctionType", "deleteResourceTypes", "deleteroleTypes", " deleteroleType", "deleteResourcetype", "deleteFunctiontype", "deleteResourceTyp", "deleteroleType", " deleteRoleTyp"], "id": ["section", "ip", "sid", "string", "oid", "request", "rid", "view", "is", "version", "ids", "pid", "Id", "uid", "path", "aid", "edit", "key", "ID", "in", "length", "object", "address", "it", "part", "connection", "model", "url", "like", "ident", "index", "f", "code", "i", "start", "error", "type", "data", "vid", "info", "source", "uri", "kid", "mid", "parent", "name", "lock", "end"], "namespaceId": ["workspaceKey", "nspaceInfo", "namespaceid", "memberspaceId", "workspacesContext", "namesentityId", "aspaceId", "nsaceId", "workspaceContext", "namesspaceKey", "workspaceType", "asentityId", "NamespacedName", "asentityName", "namespacesId", "nsaceID", "namesenceType", "namesentityName", "NamespacedId", "namespacesInfo", "namespacedInfo", "namesaneId", "namesspaceInfo", "namespaceType", "namesetID", "aspaceName", "membersetType", "namespacedType", "namesetid", "namesaneName", "namespacesID", "namespacedId", "workspacePath", "memberspaceName", "NamespaceId", "worksspaceInfo", "asentityID", "nsaceid", "asentityInfo", "memberspaceType", "worksspaceKey", "membersetName", "namesspaceId", "namespacedPath", "NamespacedType", "namesplaceId", "namesetName", "namespacesContext", "workspaceid", "namespaceContext", "namesentityID", "namesaceContext", "workspacesType", "membersetid", "namespaceName", "Namespaceid", "namesplaceInfo", "membersetId", "namesplaceid", "namesaceType", "namesaneType", "NamespaceName", "namespacesid", "worksspacePath", "namesaceid", "workspacesId", "aspaceInfo", "namespaceKey", "namesenceId", "namesetId", "namesplaceID", "workspacesid", "namesenceid", "nsaceInfo", "namespaceID", "namesentityInfo", "namesenceContext", "namesaceId", "memberspaceid", "namesetInfo", "Namespacedid", "workspaceId", "namespacesType", "nspaceId", "NamespaceType", "namespacePath", "worksspaceId", "namespacesName", "aspaceID", "namespacedid", "namespacesKey", "namespacedKey", "nspaceid", "namespacedName", "namesaceID", "namesaceInfo", "namespaceInfo", "namesetType", "namesspacePath", "namespacesPath", "nspaceID", "workspaceInfo", "namesaneid"], "removeReferencesInRoleTypes": ["removeReferencesInServiceRelations", "removeReferencesFromRoleTypes", "removeReferencesInRuleType", "removeReferencesedInRoleTypes", "removeReferencesInroleTypes", "removeReferencesInRoleRelations", "removeReferencesInRuletypes", "removeReferencesInRuleRelations", "removeReferencesInRoleNames", "removeReferencesedInRoletypes", "removeReferencesFromroleTypes", "removeReferencesedInRoleNames", "removeReferencesedInRoleType", "removeReferencesInServiceType", "removeReferencesedInroleNames", "removeReferencesInroleNames", "removeReferencesedInroleTypes", "removeReferencesFromRoleRelations", "removeReferencesInServiceTypes", "removeReferencesFromroleType", "removeReferencesInRuleNames", "removeReferencesFromRoleType", "removeReferencesInServiceNames", "removeReferencesInroletypes", "removeReferencesInRoletypes", "removeReferencesInRoleType", "removeReferencesInroleRelations", "removeReferencesFromRoleNames", "removeReferencesInRuleTypes", "removeReferencesedInroleType", "removeReferencesFromroleRelations", "removeReferencesedInroletypes", "removeReferencesFromroleNames", "removeReferencesInroleType"], "permit": ["permmit", "permMIT", "Permissions", "Permit", "Perit", "permissions", "Permits", "perit", " permits", "PERmission", "PERMIT", "permits", "PerMIT", "recmit", "recit", "permmissions", "Permission", " permission", "permmission", "perMIT", "PERmit", "recmission", " perit", "PERmissions", "permission", "recmits"], "exist": ["purpose", "existing", "draw", "cmp", "support", "front", "include", "register", "present", "know", "fill", "ist", "continue", "destroy", "stick", "same", "edit", "match", "add", "list", "existence", "except", "fail", "destruct", "delete", "icate", "ident", "index", "existent", "start", "check", "apply", "diff", "write", "inc", "update", "cont", "form", "keep", "create"], "msgBuf": ["msgLuff", "msgDuff", "messageFuff", "msgLundle", "msgBUF", "msgPluf", "messageFbuf", "msgFob", " msgFuf", "msgBob", "msgAbuf", "msgCob", "messageBbuf", "msgDaf", "messageAuff", " msgFaf", "messageBbox", "messageFbox", "msgAbox", "msgAbuff", "messageAuf", "msgDBuff", "messageFuf", "msgEBuff", "msgDBbuf", " msgFbuf", "msgDBUF", "msgBraf", "msgFBuf", "msgAuff", "msgAUF", " msgBbuff", "messageAbuf", "msgFBob", "msgFbuff", "msgLob", "msgCuf", "msgFuff", " msgFraf", "msgFaf", "msgDuf", "msgAaf", "msgLUF", "msgFundle", " msgBuff", "msgBbuf", "msgEBbox", "messageFUF", "msgAuf", " msgLundle", "msgBundle", " msgBbuf", "msgDBuf", "msgDbuf", "msgFuf", " msgLuff", "msgFraf", "msgAob", " msgBraf", "msgBbox", "msgFbox", "messageFob", "messageBuf", "msgBbuff", " msgFuff", "msgPlundle", "msgFbuf", " msgBaf", "msgLuf", "msgPlaf", "msgFUF", "msgFBuff", "messageBUF", "messageBob", "msgBuff", "msgFBUF", " msgLuf", " msgBundle", "msgLaf", "msgEBuf", "messageAUF", " msgLaf", "msgPluff", "messageBuff", " msgFbuff", "msgEBbuf", "msgBaf", "msgCuff", "msgCbuf", "msgAraf"], "objects": ["names", "agents", "boxes", "ks", "classes", "pps", "bugs", "resources", "apps", "parents", "lines", "values", "results", "ids", "relations", "images", "os", "articles", "files", "ins", "notes", "groups", "members", "object", "plugins", "properties", "locks", "organisms", "oids", "obs", "roots", "cells", "pins", "actions", "ops", "projects", "keys", "kids", "children", "blocks", "frames", "archs", "types", "phones", "owners", "links", "features", "cats", "points", "archives", "parts", "obj", "items", "people", "products", "users", "jobs", "models"], "sqlRightId": ["sqlrightPoint", "sqlRID", "sqlRestRef", "SQLRightRef", " sqlrightId", " sqlRightPoint", "SQLRestID", "sqlLeftType", "sqlRRef", "sqlRightType", "sqlLeftPoint", " sqlRightType", "SQLRestid", "sqlRid", "sqlRestID", "sqlRId", "SQLRightId", "sqlLeftId", " sqlrightType", "sqlLeftid", " sqlrightid", "sqlRightid", "sqlrightId", "sqlRightID", "SQLRestRef", "sqlrightType", "SQLRestId", "sqlRestId", " sqlrightPoint", "sqlrightid", " sqlRightid", "sqlRestid", "sqlRightRef", "sqlRightPoint", "SQLRightid", "SQLRightID"], "sqlParent": [" sqlParents", "suparent", " sqlparent", "sqlRoot", "suRoot", "suParent", "qlparent", "suParents", "sqlParents", " sqlRoot", "qlParents", "qlRoot", "sqlparent", "qlParent"], "sql": [" session", "description", " SQL", "select", "dl", "msg", "log", "operation", " msg", "conn", " db", "s", "replace", "url", "delete", "where", "sl", "link", "session", " url", "repl", "error", "acl", " params", "ql", "update", "SQL", "db"], "pstmt": ["Pstmt", "pstrm", " pstct", " psttr", "pstrct", "pSttr", " pstm", "pstatmr", "Pcttr", "s", "Security", "delete", "pctmr", "pndmt", " pStmt", "pstatct", "pcttr", "pstmb", "pfmd", "pstrmt", " pstbl", "psttr", " postmt", "pndmb", "pStct", "pctbl", " postnt", "Pctmd", "postnt", "pstmd", " pstnt", "Error", "add", "Pstmd", "this", "The", "pndbl", "pmtct", "_", " pndct", "pmtmd", "pctm", "All", "pndct", "Pctct", "pstm", "pctmd", "pStmt", "pstrtr", " pstmr", "postmt", "Delete", "pftr", "pstatnt", " pndbl", "pstnt", " pStct", "postmr", " pStm", " pSttr", "Pstct", " postct", " pndmt", "pctnt", "pstmr", "pctmb", "New", "pstatmt", "pctmt", "pfct", "Pctmt", "postct", "pstbl", " pndmb", "pctct", "pfmt", "pmtmb", "pmtbl", "pmttr", "Psttr", "pstct", " pstmb", " postmr", "pmtmt", "pStm"], "typeGid": ["TypeGid", "TypeCid", "linkGid", "TypeGID", "typeCname", "linkGID", "typegid", "linkGVoid", "linkGname", "typeGUid", "typegoid", "TypeGmin", "TypeGname", "typeAccname", "typeAccid", "TypeCmin", "typeGID", "linkGoid", "typeGUname", "TypeCID", "typeGname", "linkGVid", "typegID", "typeGUoid", "typeWID", "typeGVname", "typeWmin", "linkGVID", "typeAccID", "typeWname", "typeGVID", "typeWid", "typegname", "typeGVid", "typeGmin", "typeGVoid", "typeGoid", "typeCID", "typeAccmin", "typeCid", "linkGVname", "TypeCname", "typeGUID", "typeCmin"], "defaultLevel": ["configLevel", "DefaultLevel", "configCl", " defaultMode", " defaultDepth", " defaultCl", "configMode", "defaultDepth", "defaultMode", "DefaultMode", "defaultCl", "DefaultDepth", "DefaultCl", "configDepth"], "success": ["status", "accept", "results", "failed", "continue", "response", "Success", "match", "warning", "progress", "roll", "batch", "successful", "resp", "replace", "fail", "reg", "complete", "serial", "result", "test", "error", "data", "submit", "successfully", "message", "launch"]}}
{"id1": "9738825", "id2": "9846843", "code1": "    public void load(URL url) throws IOException {\n        ResourceLocator locator = null;\n        try {\n            locator = new RelativeResourceLocator(url);\n        } catch (URISyntaxException use) {\n            throw new IllegalArgumentException(\"Bad URL: \" + use);\n        }\n        ResourceLocatorTool.addResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n        InputStream stream = null;\n        try {\n            stream = url.openStream();\n            if (stream == null) {\n                throw new IOException(\"Failed to load materials file '\" + url + \"'\");\n            }\n            logger.fine(\"Loading materials from '\" + url + \"'...\");\n            load(stream);\n        } finally {\n            if (stream != null) stream.close();\n            ResourceLocatorTool.removeResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n            locator = null;\n        }\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 0, "substitutes": {"load": ["resource", "run", "use", "full", "include", "resources", "execute", "loads", "loading", "view", "select", "input", "open", "process", "add", "from", "in", "download", "construct", "content", "build", "play", "init", "show", "replace", "install", "pload", "upload", "get", "work", "Load", "loader", "read", "config", "link", "e", "LOAD", "start", "check", "save", "parse", "raw", "oad", "pack", "en", "loop", "update", "create", "loaded"], "url": ["resource", "route", "use", "zip", "string", "host", "http", "service", "ource", "URL", "path", "ll", "layer", "ur", "log", "gl", "Url", "email", "download", "rl", "object", "user", "address", "lr", "store", "l", "connection", "base", "element", "server", "location", "coll", "config", "loader", "sl", "f", "link", "e", "ul", "filename", "image", "el", "html", "ssl", "data", "id", "info", "uri", "source", "buffer", "name", "file"], "locator": ["localater", " loccer", "localer", " locatter", "locationators", " locators", "loccer", " loculator", "locationator", "locationale", " locer", "Locale", "localator", "Locators", "locale", "Locoder", "loculator", "locationulator", "localulator", "Locer", " locoder", "Locatter", "Loculator", "Locater", "locer", "locater", "locators", " locater", "locationoder", "Loccer", "locoder", " locale", "locationer", "locatter", "locationatter", "Locator", "locationcer", "locationater"], "stream": ["track", "resource", "temp", "row", "plus", "draw", "media", "speed", "clean", "string", "channel", "host", "zip", "context", "view", "http", "response", "input", "transform", "path", "log", "can", "feed", "pair", "length", "progress", "client", "child", "ack", "content", "roll", "handler", "user", "flash", "trans", "video", "valid", "sw", "drop", "Stream", "upload", "coll", "get", "port", "server", "loader", "sl", "f", "pool", "control", "per", "wrapper", "image", "through", "socket", "draft", "result", "output", "reader", "data", "raw", "null", "stack", "sign", "iv", "source", "buffer", "cont", "form", "ream", "file"]}}
{"id1": "20275821", "id2": "11546108", "code1": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getAttribute": ["setAttributes", "createFile", " getAttributes", "Getattribute", " getFile", "getAtt", "createattribute", "createFeature", "GetFeature", " getattribute", "getFile", "setAtt", "setAttribute", "createAttribute", "getattribute", "getAttributes", " getFeature", "createAtt", "GetFile", "createAttributes", " getAtt", "GetAttribute", "getFeature", "setattribute"], "url": ["resource", "il", "route", "class", "c", "cache", "host", "string", "context", "request", "http", "version", "proxy", "URL", "path", "log", "api", "ur", "Url", "rl", "email", "conn", "object", "address", "user", "bug", "loc", "l", "connection", "base", "server", "config", "sl", "f", "link", "el", "image", "socket", "page", "ssl", "uri", "source", "client", "name", "file", "lc"], "con": ["fa", "ch", "ctrl", "pc", "run", "fc", "ob", "cm", "c", "cache", "ca", "ex", "http", "cons", "cover", "fun", "func", "conv", "log", "can", "open", "co", "cf", "ran", "conn", "on", "user", "fn", "cr", "cc", "cl", "connection", "cn", "rc", "ocon", "exec", "coll", "cur", "non", "bc", "per", "f", "CON", "Con", "connect", "uc", "close", "socket", "plain", "login", "ssl", "file", "ln", "fl", "en", "conf", "ec", "sub", "rev", "ver", "client", "com", "re", "version", "db", "un", "lc"], "response": ["Response", "resource", "status", "route", "function", "respond", "respons", "site", "reply", "request", "http", "version", "answer", "onse", "number", "json", "length", "successful", "resp", "connection", "ception", "server", "size", "index", "code", "value", "success", "received", "image", "result", "next", "output", "error", "xx", "message", "uri", "body", "reason"], "redirect": ["rdocol", "undiff", "rdirection", "rdication", "radirect", " redirection", " redred", "rediff", "radocol", "reriff", "Redirection", "redirection", "radirection", "Redocol", " rediff", "redication", "undirect", "redocol", "undred", "undirection", "rerirection", "rerirect", "rdirect", "radication", "redred", "rerred", "Redirect", "Redication"], "location": ["resource", "local", "route", "position", "description", "string", "href", "LOC", "area", "region", "language", "layer", "path", "length", "object", "content", "address", "loc", "connection", "document", "layout", "Location", "link", "localhost", "feature", "filename", "format", "remote", "reference", "directory", "direction", "data", "type", "error", "null", "message", "uri", "collection", "file", "origin"]}}
{"id1": "21063400", "id2": "5998352", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "label": 1, "substitutes": {"doImageProcess": [" doImageprocess", "doimageprocess", "doimageFile", " doimageProcess", "doThumbnailProcess", "doFileProcess", " doImageFile", "doImageprocess", " doimageprocess", "doimageProcess", "doThumbnailprocess", "doImageFile", "doThumbnailFile", "doFileFile", " doimageFile", "doFileprocess"], "request": ["resource", "application", "instance", "method", "xml", "Request", "input", "path", "report", "object", "header", "model", "server", "url", "query", "config", "image", "writer", "result", "reader", "data", "type", "req", "message", "stream", "client", "name"], "response": ["Response", "resource", "application", "status", "description", "full", "respond", "cache", "site", "host", "reply", "http", "view", "results", "version", "service", "more", "report", "api", "wave", "feed", "onse", "queue", "json", "object", "default", "resp", "document", "connection", "ception", "video", "out", "model", "server", "location", " Response", "complete", "index", "pool", "session", "success", "image", "example", "writer", "page", "result", "next", "output", "error", "message", "client", "body", "collection"], "imgSize": ["imHeight", "refSize", "imsize", "augWidth", "largeC", "augFamily", "imgFamily", "imgType", " imgWidth", " imgFamily", "bgScale", "imLength", "dimSize", "ifLen", " imgScale", "bgLength", "largesize", "dimsize", "bgSize", "largeType", " imgLength", "imagesize", "imagC", "bgLen", "ifName", "imgLength", "refLength", "ifsize", "augLen", "imgLen", "imgsize", "imgName", "imgC", "imageLen", "refsize", "imageName", "hrSize", "imagSize", "imgScale", "imgWidth", "dimHeight", "imagType", "imageSize", "bgWidth", "ifSize", " imgName", "dimLength", "refHeight", "hrsize", "imagsize", "hrC", " imgLen", "imSize", " imgsize", "largeSize", "augSize", "imgHeight", "bgFamily", "imageLength", "hrType", "imageScale"], "imageInputStream": ["fileReadstream", "imageInString", "photoReadStream", "imageUploadFile", "imageContentView", "imageFileString", "imageReadSteam", "imageReadLength", "imageStreamstream", "imageInputLength", "imageContentFile", "imageUploadSteam", " imageOutputStream", "imageOutputstream", "photoInputSteam", "photoInputFile", "imageUploadView", "photoReadstream", "imageStreamFile", "imageInputView", " imageInputView", "pictureInputstream", "fileReadString", "imageOutputFile", "fileInputString", "fileInputLength", "imageStreamSteam", "photoReadFile", "pictureInputSteam", "pictureInputStream", "imageInputSteam", "imageInputString", " imageOutputFile", "imageReadString", "imageContentStream", "imageOutputView", "imageInputFile", "imageStreamStream", "fileInputstream", "photoInputstream", " imageOutputView", "imageOutputSteam", "imageReadStream", "imageInputstream", "imageFileStream", "fileReadLength", " imageInputSteam", "imageInStream", "imageInLength", "imageFilestream", " imageOutputSteam", "photoReadSteam", "pictureUploadstream", "imageInstream", "imageUploadstream", "pictureUploadFile", "imageReadFile", "pictureUploadStream", "fileInputStream", "pictureUploadSteam", "imageContentSteam", "imageReadstream", "pictureInputFile", "imageOutputStream", "photoInputStream", "fileReadStream", "imageFileLength", "imageUploadStream", " imageInputFile"], "imageBytes": ["fileBytes", "imageData", "fileBlocks", "ImageBytes", "imageByte", "imgbytes", "imgBytes", "viewData", "imgBuffer", "pictureBlocks", "audioBytes", "pictureBytes", "imgByte", "pictureData", " imageByte", "imageUrl", "imgData", "picturebytes", "Imagebytes", "filebytes", "viewUrl", " imageUrl", "ImageBlocks", "audiobytes", "imageBlocks", " imagebytes", "audioByte", "fileData", " imageBuffer", "viewBytes", "viewbytes", "imgUrl", "ImageData", "imagebytes", "imageBuffer", "audioBuffer", " imageData"]}}
{"id1": "5148212", "id2": "14231545", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "createfile", " copyFiles", "transferFile", "createFiles", "copyfile", "createFile", "transferFiles", "copyFiles", "transferDir", " copyDir", "copyDir", "createDir", "transferfile"], "src": ["resource", "cdn", "project", "href", "view", "http", "dist", "proxy", "input", "ource", "path", "sc", "slice", "download", "impl", "archive", "loc", "ie", "l", "gb", "s", "rc", "upload", "url", "config", "loader", "name", "sl", "sb", "gz", "filename", "image", "fp", "remote", "RC", "img", "obj", "req", "r", "source", "stream", "uri", "rb", "file", "ref"], "dest": ["dc", "folder", "cdn", "temp", "done", "txt", "route", "project", "front", "zip", "rest", "dat", "opt", "exp", "dist", "d", "master", "destroy", "dep", " Dest", "desc", "di", "path", "slice", "this", "doc", "wd", "dir", "archive", "loc", "p", "comb", "trans", "orig", "tmp", "url", "delete", "du", "config", "flat", "home", "filename", "Dest", "v", "img", "output", "data", "obj", "style", "target", "b", " destination", "de", "null", "id", "parent", "source", "wb", "name", "later", "file", "origin"], "bufSize": ["buffsize", " bufCount", "buffSize", " bufLen", "bufferSize", "buffName", "bufLen", "buffLen", "bufName", "ufName", "bufferLen", "ufCount", "bufCount", "ufLen", "buffersize", "bufferCount", " bufsize", "bufsize", "buffCount", "ufsize", "ufSize", "bufferName"], "force": ["pull", "route", "cop", "keep", "use", "enable", "send", "effect", "act", "front", "cache", "want", "false", "dirty", "push", "orce", "service", "forces", "delay", "only", "die", "sync", "ignore", "child", "count", "play", "store", "err", "fix", "replace", "load", "like", "forcing", "allow", "auto", "close", "ride", "remote", "apply", "secure", "write", "require", "forced", "style", "flush", "hard", "parent", "deep", "Force", "reason", "file", "kill"], "f": ["folder", "df", "fe", "F", "fc", "u", "n", "c", "cache", "m", "g", "o", "d", "fx", "self", "path", "fd", "feed", "dir", "fn", "p", "fs", "l", "ff", "w", "s", "base", "j", "e", "fm", "i", "uf", "h", "fp", "v", "r", "b", "fb", "t", "bf", "file", "rf"], "buffer": ["resource", "seed", "position", "cache", "uffer", "limit", "bin", "input", "wave", "sequence", "feed", "buf", "queue", "slice", "number", "pad", "length", "batch", "base", "url", "size", "Buffer", "iter", "value", "bytes", "transfer", "page", "result", "bb", "reader", "border", "data", "write", "raw", "null", "b", "buff", "flush", "message", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", " Read", "use", "ip", "send", "n", "k", " write", "c", "reading", "fill", "view", "select", "sleep", "input", "copy", "READ", "lex", "io", "open", "feed", "add", "key", "text", "sync", "skip", "length", "count", "build", "play", "Read", "ad", "seek", "show", "rate", "exec", "find", "get", "load", "x", "wait", "size", "index", "max", "iter", "len", "i", "ink", "ok", "ind", "set", "start", "check", "reader", "se", "data", "write", "raw", "parse", "r", "inc", "id", "connect", "block", "end"], "in": ["In", "pull", "pass", "or", "token", "again", "ini", "c", "n", "IN", "m", "cin", "ex", "request", "inner", "din", "bin", "input", "as", "con", "pin", "ins", "ac", "on", "conn", "child", "inn", "download", "impl", "p", "err", "kin", "up", "l", "connection", "init", "s", "win", "rin", "lin", "url", "gin", "thin", "i", "nin", "a", "socket", "login", "reader", "ax", "r", "b", "inc", "id", "source", "client", "re"], "out": ["pass", "plus", "line", "again", "n", "c", "cache", "o", "exp", "ex", "inner", "bin", "Out", "sum", "log", "outer", "io", "outs", "co", "sync", "conn", "object", "user", "cookie", "err", "up", "connection", "net", "w", "init", "exec", "server", "gin", "name", "other", "off", "nin", "image", "lib", "socket", "writer", "to", "plain", "ne", "v", "ext", "output", "data", "write", "obj", "OUT", "null", "b", "error", "inc", "id", "parent", "client", "one"]}}
{"id1": "19944975", "id2": "841724", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["writeSection", "writeReport", " writeSection", "saveConfiguration", "saveReport", "saveConfig", "WriteConfiguration", "writeConfig", "WriteReport", "WriteSection", " writeConfig", "WriteConfig", "saveSection", " writeReport"], "out": ["resource", "temp", "inas", "external", "window", "line", "again", "at", "project", "string", "c", "m", "IN", "o", "ex", "exp", "xml", "inner", "scope", "Out", "report", "path", "io", "outs", "list", "key", "sync", "this", "object", "conn", "user", "err", "connection", "w", "base", "init", "prefix", "exec", "server", "config", "pool", "dump", "password", "filename", "lib", "writer", "res", "plain", "ext", "output", "reader", "write", "obj", "OUT", "flush", "parent", "client", "name", "file"], "url": ["resource", "ob", "string", "channel", "xml", "http", "service", "URL", "path", "ll", "io", "open", "feed", "api", "Url", "object", "conn", "address", "rel", "l", "connection", "base", "server", "location", "config", "sl", "f", "image", "page", "ssl", "data", "r", "b", "web", "uri", "stream", "source", "org", "file"], "in": ["resource", "In", "inas", "again", "serv", "n", "c", "ini", "IN", "cin", "xml", "is", "din", "inner", "bin", "input", "copy", "as", "pin", "cms", "ins", "ac", "conn", "min", "inn", "err", "kin", "isin", "s", "rin", "win", "lin", "gin", "f", "inside", "i", "nin", "a", "socket", "login", "ssl", "reader", "data", "r", "b", "inc", "id", "source", "stream", "file"]}}
{"id1": "1769771", "id2": "3958807", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "copyChannel", "CopyFiles", "copyfile", "transferFiles", "copyFiles", "CopyChannel", " copyChannel", "CopyFile", "transferChannel", "transferfile"], "in": ["In", "again", "c", "IN", "m", "ex", "inner", "bin", "input", "io", "pin", "ins", "min", "inn", "l", "win", "base", "lin", "url", "query", "work", "config", "index", "f", "i", "image", "login", "reader", "diff", "data", "inc", "id", "source", "lock", "name", "file"], "out": ["resource", "external", "again", "n", "c", "string", "cache", "o", "ex", "call", "Out", "io", "outs", "conn", "user", "p", "up", "default", "w", "base", "prefix", "exec", "server", "x", "off", "image", "plain", "writer", "dot", "ext", "v", "output", "write", "OUT", "point", "b", "target", "name", "file", "extra"], "inChannel": [" inchannel", "insChan", "outchannel", "inputChannel", "inputStream", "winchannel", "winChannel", "binChan", "INStream", " inStream", "InChan", "inchannel", "winStream", "insClient", "binchannel", "InClient", "inStream", "winChan", "outStream", "insStream", "binClient", "INChannel", "inChan", "binChannel", "insChannel", "inClient", "INChan", "INchannel", "outChan", " inClient", "outClient", "inputChan", "InStream", "InChannel", " inChan", "Inchannel", "inputchannel", "binStream"], "outChannel": ["outputchannel", "outputChannel", " outChan", "outchannel", "inputChannel", "OutChannel", "OutConnection", "nStream", "Outchannel", " outManager", "inCh", "outManager", "inchannel", "outputStream", "outputController", "outputChan", "inStream", "nChan", "outStream", " outConnection", "inController", " outCh", "inChan", "inputController", "outCh", "outChan", "OutChan", " outchannel", "nManager", "inConnection", "outConnection", "inputChan", "outputCh", "nChannel", " outStream", "inputchannel", "inManager", "outController"]}}
{"id1": "17817568", "id2": "20426057", "code1": "    public Reader getGETReader_bak(URL url) {\n        Reader reader = null;\n        if (Navigator.isVerbose()) System.out.println(\"Web3DService.getGETReader caching \" + url);\n        int contentLength = -1;\n        URLConnection urlc;\n        try {\n            urlc = url.openConnection();\n            urlc.setReadTimeout(Navigator.TIME_OUT);\n            if (getEncoding() != null) {\n                urlc.setRequestProperty(\"Authorization\", \"Basic \" + getEncoding());\n            }\n            urlc.connect();\n            String content_type = urlc.getContentType();\n            if (content_type == null || content_type.equalsIgnoreCase(\"x-world/x-vrml\") || content_type.equalsIgnoreCase(\"model/vrml\") || content_type.equalsIgnoreCase(\"model/vrml;charset=ISO-8859-1\")) {\n                InputStream is = urlc.getInputStream();\n                DataInputStream d = new DataInputStream(is);\n                contentLength = urlc.getContentLength();\n                byte[] content = new byte[contentLength];\n                if (d != null) {\n                    d.readFully(content, 0, contentLength);\n                }\n                is.close();\n                d.close();\n                ByteArrayInputStream bais = new ByteArrayInputStream(content);\n                reader = new InputStreamReader(bais);\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip\")) {\n                InputStream is = urlc.getInputStream();\n                BufferedInputStream bis = new BufferedInputStream(is);\n                GZIPInputStream gis = new GZIPInputStream(bis);\n                StringBuffer sb = new StringBuffer();\n                BufferedReader zipReader = new BufferedReader(new InputStreamReader(gis));\n                char chars[] = new char[10240];\n                int len = 0;\n                contentLength = 0;\n                while ((len = zipReader.read(chars, 0, chars.length)) >= 0) {\n                    sb.append(chars, 0, len);\n                    contentLength += len;\n                }\n                chars = null;\n                gis.close();\n                zipReader.close();\n                bis.close();\n                is.close();\n                reader = new StringReader(sb.toString());\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(cis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    cis.close();\n                    bufReader.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    GZIPInputStream gis = new GZIPInputStream(cis);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(gis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    bufReader.close();\n                    gis.close();\n                    cis.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"text/html;charset=utf-8\")) {\n                System.out.println(\"text/html;charset=utf-8\");\n            } else {\n                System.err.println(\"ContentNegotiator.startLoading unsupported MIME type: \" + content_type);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return reader;\n    }\n", "code2": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "label": 0, "substitutes": {"getGETReader_bak": ["getGETReader_bcaz", "getGETReader_abak", "getGETReader_cunk", "getGETReader_bunk", "getGETReader_bck", "getGETReader_bcunk", "getGETReader_ck", "getGETReader_abaz", "getGETReader_bk", "getGETReader_bcak", "getGETReader_abk", "getGETReader_abunk", "getGETReader_cak", "getGETReader_baz", "getGETReader_caz"], "url": ["resource", "pull", "stream", "string", "host", "http", "str", "service", "www", "URL", "path", "ll", "ur", "api", "feed", "gl", "Url", "rl", "client", "user", "address", "bug", "loc", "lr", "build", "l", "connection", "base", "rc", "server", "location", "coll", "config", "loader", "sl", "f", "link", "image", "html", "ssl", "page", "r", "uri", "buffer", "source", "org", "name", "file", "lc"], "reader": ["resource", "entry", "row", "library", "instance", "http", "oder", "inner", "service", "input", "io", "feed", "driver", "object", "handler", "er", "rc", "server", "dr", "loader", "read", "Reader", "rer", "iter", "per", "writer", "ser", "data", "rr", "r", "parser", "rar", "buffer", "source", "client"], "contentLength": ["ContentLen", "encSize", " contentSize", "messageSize", " contentlength", "messageLength", "contentOffset", "Contentlength", "resourceLength", "ContentLength", "contentLen", "contentlength", "ContentSize", "loadlength", " contentOffset", "resourceLen", "resourcelength", "enclength", "contentSize", "outputlength", "ContentOffset", "outputLength", "resourceType", "resourceSize", "messageType", "ContentType", "loadLength", "resourceOffset", "contentType", " contentType", "encLength", "loadSize", "messageLen", "messagelength", "loadType", " contentLen", "outputType", "outputLen"], "urlc": ["urlac", "relC", "webci", "urlf", "URLi", " urlci", "UrlC", "URLcb", "urlp", "certcase", "blogf", " urli", "Urlci", "blogd", " urln", "relc", "looklc", "Urle", "urld", "httpc", " urlac", "Urlf", " urlf", "Urlc", "urlcb", "relcase", "runC", "urllc", "httpac", "urlci", "blogac", "runcase", " urld", "URLp", "webp", "methodc", "httpd", "lln", "certc", "httpi", "llc", "lookf", "urle", "Urlac", "urln", " urlcase", "looki", "Urln", "runcs", "urcb", "Urld", "relcs", "urlcs", "methodd", "methode", " urle", "urll", "URLC", "URLci", " urll", "urlC", "urc", "URLcase", "URLe", "blogc", "urlcase", "urli", " urlp", "certe", "llf", "URLc", "Urli", "httpf", "lookc", " urllc", "runc", "httplc", "webcs", " urlcs", "lli", "certl", " urlC", "urC", "URLac", "URLl", "methodci", "webc", " urlcb", "urp", "URLcs"], "content_type": ["contentEsize", "documentaltype", "contentEversion", "Content_Type", "content_info", "Content_name", "document_key", "content_token", "document_type", "contentaltoken", "content__type", "Content_types", "content64type", "Content_block", "contentFileversion", " content_types", "content64key", "document_state", "content64token", "contentalkey", "contentEtype", "content__Type", "content_name", "content_Type", " content_size", "content_size", "contentTypeinfo", "content_block", "content__family", "contentTypetypes", "Content_platform", " content_info", "contentFilekey", "content__name", "document_token", "contentTypestyle", "contentalstate", "content_platform", " content_style", "contentEkey", "contentaltype", "content_state", "documentaltoken", "content_key", "content_style", "content64state", "content_family", "Content_type", "contentTypetype", " content_version", "Content_family", "documentalkey", "content_types", "contentFiletype", "contentFilesize", "content_version", " content_key", "documentalstate"], "is": ["ics", "dis", "si", "isa", "ios", "ois", "im", "ii", "isl", "ir", "ide", "was", "iris", "has", "as", "ais", "os", "IS", "ins", "ri", "are", "address", "ie", "it", "isin", "init", "s", "qs", "Is", "vs", "iss", "iso", "its", "idis", "iter", "isi", "isc", "sis", "i", "ori", "iri", "alis", "sin", "mis", "lis", "nis", "ps", "tis", "id", "es", "info", "iv", "ris"], "d": ["dc", "df", "done", "did", "g", "c", "m", "dat", "dos", "dist", "dl", "da", "di", "fd", "z", "bd", "ad", "p", "dd", "l", "w", "cd", "del", "s", "dh", "dr", "dt", "f", "nd", "e", "dump", "director", "i", "ds", "gd", "q", "dom", "h", "dm", "ded", "der", "v", "dad", "data", "dig", "md", "sd", "b", "de", "id", "D", "dim", "db"], "content": ["resource", "status", "media", "section", "stream", "c", "current", "cache", "xml", "script", "comment", "cover", "layer", "desc", "cont", "json", "child", "address", "header", "default", "document", "device", "model", "exec", "server", "Content", "load", "x", "config", "complete", "read", "array", "children", "enc", "code", "value", "image", "page", "result", "output", "data", "raw", "message", "source", "buffer", "text", "body", "version", "core", "dec"], "bais": ["BAiss", "dais", "xaiss", "caiss", "cai", "baiss", "baas", "haiss", "xaish", "BAis", "daiss", "BAas", "BAi", "haas", "xais", "xai", "hai", "cais", "bai", "hais", "baish", "caish", "BAish", "dai", "daas"], "bis": ["ses", "ios", "bs", "bps", "ii", "ois", "cus", "bin", "uds", "abi", "ubis", "series", "di", "abs", "ais", "slice", "dies", "ri", "boot", "bos", "bi", "fs", "isin", "gb", "pins", "vs", "onis", "iss", "cos", "alis", "sin", "mis", "lis", "nis", "nas", "esi", "tis", "bus", "rb", "lins", "las", "ris", "phis"], "gis": ["gris", " gids", "cfgis", "jios", "jist", "gids", "jis", "giss", "Giss", "jos", "gos", "ghios", "bios", "ghist", "bos", " giss", "ghos", "cfgris", "Gris", "ghis", "gist", " gris", "gios", "cfgids", "Gids", "cfgiss", "Gis", "bist"], "sb": ["ib", "mb", " eb", "usb", "erb", "sth", "nb", "bs", "B", "bps", "pb", "sm", "sf", "dB", "src", "stab", "bg", "obb", "bp", "SB", "eb", "orb", "xb", "abb", "lb", "gb", "rob", "bc", "lp", "zb", " SB", "kb", "BB", "cb", "ssl", "bb", "sg", "b", "bf", "fb", "buffer", "wb", "ab", "bm", "rb", "db", "sq"], "zipReader": ["archiveReader", " zipperRunner", "Zipreader", " zipperRead", "gzWriter", "ZipParser", " zipParser", "archiveWriter", "archiveParser", " zipWriter", "gzRead", " zipreader", " zipperWriter", "zipParser", "archivereader", "ZipWriter", "zipreader", " zipRunner", "zipRead", " zipRead", "gzReader", "zipRunner", "ZipReader", " zipperReader", "zipWriter", "gzRunner"], "chars": ["quapters", "characters", " Ch\n", "chacters", "Chars", "Chaks", "charans", "chashes", "clars", "charars", "Ch\n", "cheacters", "charts", "Chans", "quaks", "charapters", "shapes", "Charts", "chararts", "chans", "clacters", "shars", "cheashes", "clarts", " chapters", "clashes", "chears", "shacters", "quarts", "chapters", " charts", "ch\n", " ch\n", "chapes", " chans", "Chapters", "charapes", "quars", " chacters", "chaks", "sharts", " chapes", "charashes", " chaks", "chearts"], "len": ["span", "lt", "n", "fin", "dl", "ann", "ler", "le", "fun", "Len", "ll", "la", "num", "length", "min", "seq", "lit", "count", "ie", "err", "rel", "cl", "l", "part", "pos", "lin", "del", "all", "ls", "size", "sl", "f", "li", "lim", "ind", "el", "split", "led", "val", "nt", "data", "elt", "fl", "hl", "en", "lf", "rev", "lon", "id", "ln", "lc", "end"]}}
{"id1": "21821404", "id2": "9954926", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "label": 0, "substitutes": {"getWebPage": ["parsewebpage", "getwebpages", "parsewebPage", "getVirtualPage", "getVirtualpages", "getwebpage", "getWebpage", "parseWebpages", "parsewebpages", "parseWebpage", "getVirtualpage", "parseWebPage", "getwebPage", "getWebpages"], "urlObj": [" urlObject", "URLobj", "resourceObject", "urlExt", "httpobj", "blogobj", "URLObject", "UrlObj", "Urlobj", "urlobj", " urlExt", "URLObj", " urlobj", "strobj", "strObject", "blogObj", "httpOb", "resourceobj", "resourceObj", "URLExt", " urlInst", "blogInst", " urlOb", "strObj", "strInst", "resourceExt", "UrlOb", "urlInst", "urlOb", "httpObj", "urlObject", "blogObject"], "content": ["resource", "online", "section", "clean", "string", "c", "css", "lines", "comment", "response", "core", "java", "continue", "report", "cont", "feed", "empty", "json", "object", "address", "header", "document", "out", "model", "server", "Content", "url", "load", "coll", "work", "array", "code", "value", "page", "result", "html", "output", "data", "write", "raw", "comments", "message", "source", "buffer", "text", "body", "file"], "is": ["il", "or", "isp", "ires", "us", "isa", "ip", "ios", "im", "ois", "isl", "est", "you", "rest", "site", "ir", "irc", "was", "iris", "as", "be", "io", "ais", "abs", "os", "IS", "ui", "cms", "in", "ins", "ri", "does", "ie", "it", "fs", "s", "Is", "out", "iss", "iso", "ar", "ops", "x", "its", "isi", "isc", "i", "any", "mis", "bis", "lis", "ser", "ai", "al", "nis", "r", "ps", "id", "es", "info", "stream", "ris", "ise", "problem"], "reader": ["or", "row", "actor", " Reader", "reading", "oder", "inner", "ler", "io", "ner", "driver", "in", "ri", "er", "handler", "bird", "ro", "l", "rc", "server", "x", "loader", "read", "Reader", "iter", "rer", "e", "director", "i", "worker", "h", "writer", "editor", "ser", "rr", "r", "parser", "rar", "buffer", "stream", "rx"], "line": ["item", "inline", "entry", "row", "pass", "section", "string", "col", "word", "lines", "ine", "LINE", "str", "character", "comment", "Line", " inline", "response", "char", "key", "object", "user", "cr", "cl", "l", "part", "connection", "lin", "cell", "out", "server", "url", "block", "link", "f", "code", "cle", "strip", "page", "data", "lf", "message", "buffer", "source", "text", "body", "column", "name", "file", "lc"]}}
{"id1": "310182", "id2": "88047", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "subverting", "unverted", "Conversion", "converted", "CONverted", "unception", "CONverting", "conversion", " deconverting", "Convert", " deconvert", "conception", " deconverted", "subversion", "oconverted", "Conception", "subverted", "CONception", "oconvert", "oconversion", "subvert", "unvert", "CONversion", "CONvert", "converting", " deconversion", "unversion", "Converted", "oconverting"], "src": ["resource", "scene", "stage", "sth", "username", "cmp", "SourceFile", "string", "href", "Source", "spec", "cpp", "dist", "input", "ource", "path", "inst", "ctx", "sc", "buf", "slice", "sys", "attr", "rl", "download", "impl", "fn", "loc", "proc", "video", "gb", "s", "rc", "storage", "upload", "tmp", "url", "component", "load", "sn", "config", "sb", "code", "gz", "filename", "sin", "Dest", "fp", "cb", "ssl", "img", "reader", "st", "RC", "supp", "secure", "obj", "req", "feat", "rb", "prot", "back", "source", "stream", "uri", "sel", "name", "sit", "file", "ref"], "dest": ["dc", "txt", "temp", "class", " dst", "dat", "dist", "bin", "path", "di", "disk", "dir", "fn", "orig", "tmp", "home", "lib", "Dest", "std", "img", "test", "obj", "target", "null", " destination", "source", "cont"], "in": ["In", "inas", "pass", "ini", "n", "IN", "ex", "is", "d", "din", "bin", "input", "as", "io", "pin", "ins", "doc", "inn", "err", "up", "isin", "win", "f", "i", "a", "inf", "val", "login", "reader", "data", "r", "ps", "t", "inc", "source", "stream", "file"], "p": ["pc", "cop", "pd", "pm", "g", "c", "pr", "pi", "op", "py", "pb", "pg", "o", "m", "d", "np", "pp", "bp", "tp", "wp", "l", "part", "s", "pe", "cp", "pa", "j", "sp", "per", "f", "e", "lp", "i", "pre", "h", "fp", "v", "P", "jp", "r", "po", "ps", "t", "parser", "b"], "ds": ["dc", "hs", "words", "dl", "gs", "da", "obs", "s", "icks", "ges", "dm", "ts", "sts", "db", "df", "js", "pd", "bs", "ys", "dat", "lines", "dos", "d", "utils", "ads", "styles", " props", " sd", "amps", "ld", "ans", "Ds", "lp", "ns", "data", "posts", "parts", "docs", "ps", "DS", "ss", "dp", "scripts", "uds", "di", "os", "sync", "sys", "ins", "xs", "tests", "dds", "ls", "dt", "cs", "des", "nas", " DS", "ups", "ks", "eps", "dist", "cons", "ays", "tools", "ants", "groups", "plugins", "dd", "qs", "vs", "services", "dates", "ths", "els", "gd", "ded", "vals", "points", "ils", " ps", "ipes", "rs", "models"], "format": ["struct", "class", "function", "at", "act", "string", "host", "table", "spec", "version", "language", "atter", "path", "fd", "api", "magic", "letter", "unit", "handler", "fn", "frame", "nat", "scale", "tag", "part", "layout", "Format", "model", "prefix", "ant", "url", "config", "f", "sche", "filename", "record", "fp", "filter", "data", "type", "feat", "style", "plugin", "t", "parser", "pattern", "source", "form", "name", "file", "template"], "hasPixelData": ["showsPixeldata", "haspixeldata", "showsPixelDATA", "hasByteDATA", "hasPixeldata", "hasPixelDATA", "showsPixelStyle", " hasPixelSize", " hasPixeldata", "showsBytedata", "showsByteStyle", "haspixelSize", "showsPixelData", "hasByteData", "hasByteStyle", "hasBytedata", "haspixelData", "hasPixelStyle", "showsByteData", "hasPicturedata", "hasByteSize", "hasPictureSize", "hasPixelSize", "hasPictureData", "showsByteDATA"], "inflate": ["inFlated", "inadequating", "infloace", "insflode", "InFlate", "infolATE", "inadequode", "insvenATE", "inFlate", "insflating", "InFlace", "insflATE", "inffated", "inflation", "invenate", "inflace", "infolode", "inFlation", "infloate", "insvenate", "invenATE", "infloated", "inffation", "invenating", "InFlated", "insvenating", "insflate", "inflATE", "inflating", "Inflace", "infface", "inFlace", "infolate", "Inflated", "inffate", "Inflate", "inadequate", "insvenode", "inflated", "infolating", "infloation", "inflode", "invenode", "Inflation", "InFlation", "inadequATE"], "pxlen": ["fxdata", "pnglen", "pxlin", "mxln", "axlon", "pxcount", "fxln", "pglen", "txln", "pcln", "ppl", "pxlon", "txlin", "camlen", "fxl", "pgden", "pngsize", "axlin", "mxlen", "camln", "fxden", "xplength", "ppLen", "mxdata", "pxLen", "pxdata", "pclen", "pclin", "axln", "pxln", "axlen", "txlen", "pngcount", "campos", "mxpos", "fxLen", "xpsize", "xpcount", "pxsize", "pgl", "pxpos", "ppden", "pgLen", "fxpos", "pxlength", "fxlen", "mxlength", "mxcount", "xplen", "mxsize", "camdata", "pxden", "pclon", "pplen", "pxl", "pnglength", "txlon"], "out": ["group", "line", "again", "cache", "step", "inter", "state", "Out", "copy", "log", "io", "outs", "list", "co", "post", "sys", "pad", "user", "conn", "store", "err", "up", "server", "query", "work", "cli", "session", "dump", "lib", "v", "page", "output", "gen", "error", "obj", "OUT", "point", "parent", "lock", "re"]}}
{"id1": "19549489", "id2": "18358467", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public DocumentSummary parseDocument(URL url) throws IOException, DocumentHandlerException {\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n            POIOLE2TextExtractor extractor = createExtractor(inputStream);\n            SummaryInformation info = extractor.getSummaryInformation();\n            DocumentSummary docSummary = new DocumentSummary();\n            docSummary.authors = DocSummaryPOIFSReaderListener.getAuthors(info);\n            docSummary.contentReader = new StringReader(extractor.getText());\n            docSummary.creationDate = info.getCreateDateTime();\n            docSummary.keywords = new ArrayList();\n            docSummary.keywords.add(info.getKeywords());\n            docSummary.modificationDate = new Date(info.getEditTime());\n            docSummary.title = info.getTitle();\n            return docSummary;\n        } catch (IOException e) {\n            if (e.getMessage().startsWith(\"Unable to read entire header\")) {\n                throw new DocumentHandlerException(\"Couldn't process document\", e);\n            } else {\n                throw e;\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["Cop", "paste", "cop", " copies", "zip", "Copy", "io", "move", "Transfer", "sync", "download", "p", "create", " Copy", "all", " transfer", "upload", "clone", "delete", " move", "split", "transfer", "write", " copied", "source", " copying", "file"], "sourceFile": ["resourceFile", "sourceFiles", "serviceFilename", " sourcefile", "SourceFile", "sourcefile", " sourceFilename", " sourceDirectory", "resourceFiles", "SourceDirectory", "SourceFiles", "sourceFILE", "sourceFilename", "serviceFiles", "resourceDirectory", "siteFile", "searchFile", "Sourcefile", "sourceDirectory", "servicefile", "siteFILE", "searchFilename", " sourceFILE", "siteDirectory", " sourceFiles", "resourcefile", "searchfile", "searchFiles", "siteFiles", "SourceFILE", "serviceFile"], "destinationFile": ["destinationFiles", "distinationFiles", "destinatorDirectory", "destinatedfile", "DestinationDir", "DestinationFiles", "destinationDirectory", "distinationImage", "Destinatorfile", "destinationfile", "destinationImage", "destationfile", "destinatorDir", "destinatorFiles", "DestinatorFiles", "DestinatorDir", "destinatorFile", "destationImage", "destationDir", "distinatedFiles", "destinatorImage", "distinatedImage", "destinatorfile", "distinatedFile", "distinatedDirectory", "destinatedDirectory", "distinationFile", "destinatedImage", "DestinatorFile", "destationDirectory", "destationFiles", "distinationDirectory", "DestinationFile", "destinatedFiles", "destinatedDir", "destationFile", "Destinationfile", "destinationDir", "destinatedFile"], "sourceFileChannel": ["sourceFilechannel", " sourceFileContext", "sourceDirectoryChan", "sourceFilesChannel", "ourceFileStream", "sourceStreamContext", "sourceDirchannel", " sourceFilesContext", "sourceStreamConnection", "sourceDirectoryClient", "sourceStreamChan", "sourceFileContext", "sourceLibrarySocket", "sourceLibraryChan", "ourceStreamStream", "ourceFilechannel", "sourceFilesService", " sourceFileService", "sourceFileService", "sourceStreamService", "sourceLinechannel", "ourceStreamChan", " sourceFilesService", "sourceDirStream", "sourceDirectorySocket", "sourceDirectoryChannel", "sourceStreamStream", "sourceDirChannel", "sourceLineClient", "sourceFunctionService", "sourceLineChannel", "sourceLibraryClient", "ourceFileChannel", "sourceFunctionChannel", "sourceFilesContext", "targetFileClient", "targetLibraryChan", "sourceFileClient", "targetFileChan", " sourceFilesConnection", "sourceFileStream", "ourceStreamChannel", " sourceFileConnection", "ourceFileChan", "sourceLineStream", "sourceLibraryChannel", "sourceLineChan", "targetLibrarySocket", "sourceFileConnection", "sourceFileChan", "sourceFilesConnection", "sourceLineSocket", "targetFileSocket", "sourceFunctionContext", "sourceFunctionConnection", " sourceFilesChannel", "sourceDirChan", "targetFileChannel", "sourceFileSocket", "targetLibraryClient", "sourceStreamChannel", "ourceStreamchannel", "targetLibraryChannel", "sourceStreamchannel"], "destinationFileChannel": ["destinationIOClient", "destinationFileCache", "destinatorFileHandler", "destinationLineChannel", "destinationFilesService", "destinationIOCache", "destinationFilesHandler", "destinatorFileChan", "destinatorFilesService", "destinationFileChan", "destinationFilesChannel", "destinatorFileCache", "destinatorFileConnection", "destinationDirectoryConnection", "destinationIOService", "destinationDirectoryClient", "destinationDirectoryChan", "destinatorFileService", "destinatorFilesCache", "destinatorFilesChannel", "destinatorFilesClient", "destinationFilesClient", "destinationLineConnection", "destinationIOChannel", "destinationFileClient", "destinationLineHandler", "destinationDirectoryCache", "destinatorFilesConnection", "destinationFilesConnection", "destinationFileConnection", "destinationLineClient", "destinationLineService", "destinatorFilesChan", "destinationDirectoryHandler", "destinationFilesChan", "destinationFilesCache", "destinationFileHandler", "destinationLineChan", "destinationDirectoryService", "destinationDirectoryChannel", "destinatorFilesHandler", "destinatorFileChannel", "destinationFileService", "destinatorFileClient"]}}
{"id1": "17557289", "id2": "13783549", "code1": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "source": ["resource", "temp", "use", "site", "Source", "input", "copy", "ource", "core", "path", "sc", "from", "slice", "this", "object", "unit", "connection", "base", "out", "server", "clone", "size", "sl", "link", "iter", "e", "SOURCE", "image", "start", "sin", "remote", "reader", "target", "id", "parent", "stream", "src", "name", "file"], "dest": ["folder", "dc", "temp", "done", "dat", "dist", "d", "src", "master", "destroy", "desc", "south", "die", "dir", "comb", "db", "orig", "tmp", "delete", "flat", "home", "Dest", "transfer", "test", "output", "data", "obj", "target", "null", " destination", "de", "wb", "dep", "later", "file", "end"], "srcChannel": ["srcChan", " srcStream", "srcConnection", "srcchannel", "distChan", "destChannel", "sourceContext", "srcButton", "destStream", "destchannel", "rcButton", "distConnection", "destConnection", "rcContext", "sourceButton", "rcChan", "srcStream", "destChan", " srcConnection", "srcContext", " srcContext", " srcButton", " srcChan", "sourcechannel", " srcchannel", "rcChannel", "rcchannel", "sourceChannel", "distStream", "rcConnection", "sourceChan", "sourceConnection", "distChannel"], "dstChannel": ["dstsChan", "dstContext", "ddestchannel", "dstStream", "ddestContext", "DdestChan", "dDestChan", "drcChan", "drcchannel", "drdContext", " dstStream", " dndStream", "DstChan", "drdChannel", "dutStream", " dstContext", "DdestChannel", " dndContext", "DstStream", "drdchannel", "drdChan", "dutchannel", "dutChannel", "dndChannel", "ddestChan", "ddestStream", "drcChannel", "ddstChannel", " dndchannel", " dstchannel", "dndchannel", "ddestChannel", "ddstchannel", "dDestchannel", "ddrdContext", "dstsChannel", "dDestChannel", "ddstChan", "dstChan", "dstsStream", "ddrdchannel", "ddrdChannel", "dndContext", "dstchannel", "Dstchannel", "DdestStream", "ddrdChan", "Ddestchannel", "drcContext", "dstschannel", "dndStream", "dutContext", "ddstContext", "dDestStream", "DstChannel", " dndChannel"]}}
{"id1": "8778962", "id2": "20100809", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeStringToFiles", "decodeFileAsFiles", "decodeStringToFile", "decodeFileAsStream", "decodeString2Stream", "decodeFileFromStream", "decodeFileFromFiles", "decodeStringToString", "decodeFile2File", "decodeFileAsString", "decodeFileFromFile", "decodeStringToStream", "decodeFileToString", "decodeString2String", "decodeFile2String", "decodeFile2Files", "decodeFileToStream", "decodeFileToFiles", "decodeFileAsFile", "decodeString2File", "decodeString2Files", "decodeFileFromString", "decodeFile2Stream"], "infile": [" infp", " instream", "minbase", "Inbase", "inputfilename", "infp", "minstream", "outfiles", " infiles", "minFile", "inputfp", "inputfiles", "minfile", "outfilename", "Infile", "inbase", " inbase", "outfp", " infilename", "instream", "InFile", "inFile", "inputfile", " inFile", "Instream", "infiles", "infilename"], "outfile": ["outputpath", "outfolder", " outdatabase", "inputFile", "outputFile", "inputdatabase", " outFile", "outfilename", "inputpath", " outfilename", " outfolder", "outpath", " outpath", "outputdatabase", "inFile", "inputfile", "infolder", "outputfolder", "outFile", "outputfile", "outputfilename", "infilename", "outdatabase"], "in": ["In", "inas", "pass", "again", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "ic", "as", "con", "pin", "ins", "ac", "min", "conn", "inn", "into", "err", "isin", "init", "win", "s", "rin", "lin", "gin", "thin", "inside", "i", "nin", "a", "socket", "sin", "login", "reader", "data", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "In", "or", "pass", "exit", "line", "again", "cache", "channel", "o", "ex", "inner", "bin", "Out", "copy", "outer", "log", "io", "outs", "co", "post", "sync", "conn", "no", "err", "up", "net", "base", "exec", "work", "name", "session", "off", "home", "image", "lib", "socket", "to", "writer", "output", "error", "ou", "write", "obj", "OUT", "point", "job", "inc", "parent", "client", "one", "file"], "buffer": ["seed", "channel", "cache", "uffer", "limit", "padding", "bin", "input", "layer", "wave", "feed", "buf", "queue", "slice", "length", "address", "count", "batch", "base", "server", "url", "size", "Buffer", "iter", "value", "split", "bytes", "transfer", "result", "border", "bb", "reader", "data", "write", "type", "raw", "null", "b", "buff", "flush", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", "tell", " Read", "use", "ip", " skip", "send", "n", " write", "current", "reading", "fill", "limit", "select", "copy", "READ", "lex", "io", "feed", "add", "slice", "sync", "length", " count", "count", "seek", "play", "Read", "ad", "exec", "find", "get", "load", "x", "wait", "size", "work", "f", "iter", "len", "i", "allow", "ind", "_", "start", "ride", "check", "connect", "next", "reader", " copy", "parse", "write", "se", "raw", "r", "inc", "id", "sleep", "end"], "success": ["rolled", "done", "pass", "status", "again", "initial", "method", "results", "failed", "comment", "winner", " Success", "continue", "response", "func", "right", "fast", "path", "open", "Success", "primary", "ceed", "first", "warning", "construct", "content", "ccess", "positive", "growth", "roll", "good", "valid", "successful", "flash", " successful", "default", "danger", "model", "fail", " succeed", "complete", " succ", "value", "rolling", "result", "better", "true", "follow", "data", "error", "xx", "null", "successfully", "message", "cess"]}}
{"id1": "9261777", "id2": "12380475", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"source": ["resource", "token", "use", "seed", "project", "zip", "string", "Source", "request", "view", "spec", "proxy", "inner", "service", "scope", "comment", "input", "options", "ource", "copy", "path", "empty", "slice", "force", "dest", "in", "original", "address", "shared", "single", "unit", "sample", "missing", "rule", "base", "element", "prefix", "url", "query", "config", "size", "name", "index", "flat", "sl", "session", "strip", "SOURCE", "image", "start", "sin", "result", "secure", "se", "data", "parse", "style", "target", "null", "id", "parent", "uri", "text", "info", "src", "site", "file", "sort", "template"], "destination": ["dominated", "desturation", " destinating", " destipping", "destinations", "domination", " destinator", "dependension", "coordinating", "destinating", "destipping", " destension", "homeignment", "Destinations", "destinator", "Destinator", "Destinating", "coordination", "Destination", "homeinated", "databaseuration", "destinated", "Destinated", "homeination", " destignment", "Destinate", "homeinator", "destinate", "distipping", "Destignment", "coordinate", "dependination", "dependipping", "dependinated", "domuration", "databaseinated", " destinated", "dominations", "destignment", "distension", "distinated", "coordinator", " destinate", "distination", "databaseinations", "databaseination", "Desturation", "destension"], "is": ["ib", "ics", "or", "us", "ip", "isa", "ios", "serv", "zip", "bs", "ens", "isl", "ois", "osi", "ir", "ob", "act", "ii", "was", "iris", "oss", "ci", "as", "ic", "api", "abs", "ais", "IS", "io", "ui", "in", "ins", "ri", "are", "ie", "fs", "obs", "init", "s", "Is", "out", "iss", "iso", "ar", "ops", "eni", "cos", "get", "isi", "isc", "sis", "i", "ori", "sin", "close", "mis", "bis", "se", "lis", "ai", "nis", "esi", "id", "es", "info", "src", "ris"], "os": ["or", "ks", "js", "us", "ol", "ios", "so", "bs", "ens", "ob", "osi", "op", "ies", "o", "mos", "dos", "oa", "oss", "as", "oise", "io", "ais", "sys", "aos", "boot", "bos", "oes", "acs", "ose", "fs", "obs", "s", "nos", "pos", "out", "oS", "vs", "ls", "los", "ops", "cos", "ot", "Os", "i", "ds", "ori", "oses", "ros", "socket", "ou", "es", "ends", "OS", "ss", "ow"], "buffer": ["seed", "position", "string", "channel", "uffer", "limit", "padding", "copy", "layer", "wave", "sequence", "feed", "buf", "slice", "queue", "number", "pad", "address", "header", "batch", "base", "server", "url", "size", "read", "Buffer", "iter", "value", "image", "writer", "bytes", "transfer", "page", "border", "result", "reader", "bb", "data", "null", "b", "buff", "flush", "binary", "reference"], "length": ["distance", "row", "section", "line", "of", "position", "ob", "string", "full", "volume", "depth", "limit", "character", "total", "shape", "lower", "Length", "power", "partial", "division", "match", "sequence", "slice", "number", "feed", "key", "ring", "object", "address", "count", "age", "weight", "l", "part", "url", "get", "load", "left", "size", "index", "code", "len", "value", "strip", "split", "start", "quote", "last", "level", "reader", "type", "data", "range", "point", "style", "duration", "id", "offset", "lock", "block", "width", "end"]}}
{"id1": "9096314", "id2": "16215393", "code1": "    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                log.warn(\"\\'\" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" ignored - table already  has an open record \");\n            } else {\n                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());\n                long outageID = -1;\n                ResultSet seqRS = getNextOutageIdStmt.executeQuery();\n                if (seqRS.next()) {\n                    outageID = seqRS.getLong(1);\n                }\n                seqRS.close();\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement newOutageWriter = null;\n                if (log.isDebugEnabled()) log.debug(\"handleNodeLostService: creating new outage entry...\");\n                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);\n                newOutageWriter.setLong(1, outageID);\n                newOutageWriter.setLong(2, eventID);\n                newOutageWriter.setLong(3, nodeID);\n                newOutageWriter.setString(4, ipAddr);\n                newOutageWriter.setLong(5, serviceID);\n                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));\n                newOutageWriter.executeUpdate();\n                newOutageWriter.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeLostService : \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" recorded in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            }\n        } catch (SQLException sqle) {\n            log.warn(\"SQL exception while handling \\'nodeLostService\\'\", sqle);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"handleNodeLostService": ["handlenodelostFunction", "handleNodelostServer", "handleNodeLostFunction", "handleNodelostServices", "handleNodeLostServer", "handleNodeErrorServices", "handlenodelostServer", "handleNodeErrorFunction", "handleNodeUnknownServices", "handlenodeLostService", "handleNodeErrorService", "handleNodeUnknownFunction", "handlenodelostServices", "handleNodeUnknownService", "handleNodelostService", "handleNodeUnknownServer", "handlenodeLostServer", "handleNodeErrorServer", "handlenodelostService", "handlenodeLostFunction", "handlenodeLostServices", "handleNodeLostServices", "handleNodelostFunction"], "eventID": ["EventName", "documentName", "EventType", " eventName", " eventid", "resourceID", "EventId", "serviceId", "eventType", "sessionName", "resourceName", "resourceId", "documentId", "EventID", "serviceName", "nodeid", "eventId", " eventId", "eventid", "sessionId", "sessionID", "nodeName", "eventName", "documentID", "nodeId", " eventType", "nodeType", "resourceid"], "nodeID": [" nodeName", "NodeID", "Nodeid", "NodeURL", " nodeURL", "resourceID", "serviceId", "networkInfo", "resourceName", "objectName", "serviceid", "objectid", "nodeInfo", "resourceId", "serviceName", "eventURL", " nodeId", "nodeid", "eventId", "eventid", "networkID", "objectID", "nodeURL", "nodeName", " nodeInfo", "NodeId", "eventName", "eventInfo", "nodeId", "objectId", "networkId", " nodeid", "resourceid"], "ipAddr": [" ipAttr", "apiAddri", "ipaddo", " ipAddrs", "ipAddp", "ipAttr", " ipAddress", "ipaddri", " ipChr", "ipadder", " ipChri", "ipAddl", "ipAtto", "ipAddressp", "ipaddrs", "apiAttrs", "apiAttp", "ipAddresser", "ipAddressr", "ipAddo", " ipChrs", "epAddr", "ipAddressrs", " ipAdder", " ipAttrs", "apiAddrs", " ipAddrer", "ipChl", "ipChrer", "apiAttri", "ipChri", "apiAttr", " ipAtter", "ipAddressri", " ipChrer", "ipAdder", "epaddr", " ipAddo", "epaddrs", "ipAttress", "ipAddressl", "ipAddrer", "epaddl", "epAddl", "apiAddp", "ipAttrer", "ipAddri", "ipChr", "ipaddress", "ipaddrer", " ipAtto", "apiAddr", "ipAddress", "ipAddresso", "ipAttp", "epAddrer", "ipAddrs", "ipAddressrer", "ipaddl", "ipAtter", "ipChrs", "ipAttri", " ipAddri", "ipChp", "epaddrer", "ipAttrs", "epAddrs", "ipaddr"], "serviceID": ["serviceUID", " serviceUID", " serviceType", "featureId", " serviceIDs", " serviceName", "imageUID", "roleid", "roleIP", "networkName", "serviceId", "eventType", "imageId", "siteid", "networkid", "serviceid", " serviceIP", "featureUID", "ServiceName", "imageID", "serviceName", " serviceId", "eventId", "eventIDs", "serviceIDs", "eventid", "networkID", "siteIP", " serviceid", "siteID", "siteId", "ServiceType", "eventIP", "featureID", "serviceIP", "eventName", "ServiceIDs", "roleId", "ServiceId", "ServiceIP", "roleID", "networkId", "serviceType", "ServiceID"], "eventTime": ["serverInfo", "servertime", "EventName", " eventInfo", "eventName", " eventtime", "eventInfo", " eventName", "Eventtime", "EventTime", "eventtime", "serverTime", "serverName", "EventInfo"], "log": ["use", "full", "blog", "low", "call", "http", "pl", "l", "w", "cell", "port", "url", "reg", "guard", "pool", "writer", "stat", "gen", "error", "write", "db", "or", "entry", "cat", "c", "cache", "proxy", "lex", "feed", "user", "bug", "cl", "pe", "model", "Log", "plug", "thread", "where", "stop", "output", "en", "class", "host", "pg", "exp", "net", "tag", "get", "f", "lo", "level", "type", "LOG", "loop", "lock", "ger", "tool", "ge", "path", "key", "it", "base", "event", "contract", "config", "sec", "crit", "put", "debug", "job", "sign", "info", "og"], "dbConn": ["dbDr", "databaseconn", "dbConnection", "sqlCtrl", "libConn", "dbconn", "DbColl", "sqlCo", "sqlConn", "libCon", "Dbconn", " dbDr", "databaseConn", " dbNC", " dbCon", "dbCt", "sqlSession", " dbConnect", "DbConnection", "webCt", "sqlCt", "DBCs", " dbCs", "DbCtrl", "DBConnect", "DbDr", "databaseConnection", "DBConn", "sqlconn", "DbCo", "dbNC", "dbSession", " dbconn", "databaseDr", "DbCs", "libconn", "logConn", "DbCon", "libCt", "logConnect", "webCtrl", "DbCt", " dbColl", "webConn", "dbCo", "DbConn", "dbConnect", " dbCt", "dbColl", "DbSession", "dbCon", " dbCtrl", "dbCtrl", "DBCt", "logColl", " dbSession", "sqlNC", "dbCs", "DbConnect", " dbConnection", "webNC", "logCtrl", " dbCo"], "getNextOutageIdStmt": ["getNextOutageIdRmt", "getNextOutageIdRb", "getNextOutageIDSnt", "getNextOutageIdStb", "getNextOutageIDSb", "getNextOutageIDSmt", "getNextOutageIdCnt", "getNextOutageIdSMT", "getNextOutageIDStnt", "getNextOutageIdSb", "getNextOutageIdStMT", "getNextOutageIdCb", "getNextOutageIdstnt", "getNextOutageIdSnt", "getNextOutageIdStnt", "getNextOutageIDSr", "getNextOutageIDStMT", "getNextOutageIDStmt", "getNextOutageIdstr", "getNextOutageIDSMT", "getNextOutageIdstmt", "getNextOutageIdCMT", "getNextOutageIdCmt", "getNextOutageIdRr", "getNextOutageIDStr", "getNextOutageIdStr", "getNextOutageIDStb", "getNextOutageIdstMT", "getNextOutageIdRMT", "getNextOutageIdSr", "getNextOutageIdCr", "getNextOutageIdSmt"], "outageID": ["OutrageID", "outageName", "outflowId", "outageHandle", "inrageUID", "OutrageName", "outageUID", "outAGEID", "inageID", "OutrageHandle", "outAGEUID", "outissueURL", "inrageId", "OutageName", "OutageHandle", "outissueID", "outissueId", "outagementID", "outflowID", "outrageHandle", "outagingID", "OutrageSecret", "outagingName", "outrageId", "outAGEId", "outrageName", "inageURL", "inageUID", "outrageID", "OutageId", "outAGESecret", "outageId", "outagementId", "OutrageId", "inageId", "outageSecret", "OutageID", "outAGEURL", "inrageID", "outflowHandle", "outagementHandle", "outagementName", "outagingSecret", "outrageSecret", "outrageURL", "outageURL", "inrageURL", "outissueUID", "outagingId", "outrageUID", "OutageSecret", "outAGEName", "outflowName"], "seqRS": [" sequenceRT", "seqRs", "reqRS", "sequRL", " seqMR", "sqMR", "seqRL", "seqRR", " seqRC", "eqRT", "seqRT", "invRs", "colRR", "structRS", "sequenceRS", "seqrs", " sequenceMR", "eqRS", "reqTS", "eqRR", "invSR", " sequenceRC", "eqRs", "sqRT", "sequenceSR", "reqRR", "colRs", "colRS", "seqMR", " seqRL", "invrs", " sequenceRS", "reqRT", "structSR", "sqRC", "reqRL", "sequRS", "sequRC", "sequTS", " seqRT", "reqRs", "sqRS", "seqTS", "sequencers", " seqTS", "invRS", "colRT", "seqSR", "structRs", "structrs", "sequenceRs", "reqRC", "seqRC"], "newOutageWriter": ["newOutageRW", "newOutageInfo", "newoutageWriter", "newOutlineReader", "newOutpointReader", "newOutflowRW", "newOutagementRW", "newoutureWriter", "newOutrageWrite", "newExageWrite", "newInageWriter", "newOutrageWrit", "newOutureWrite", "newoutureReader", "newExlinewriter", "newouturewriter", "newOutageReader", "newOutflowReader", "newOutissueReader", "newInflowWrite", "newOutflowWriter", "newOutagementWrite", "newOutflowwriter", "newOutpointWriter", "newOutlinewriter", "newExlineReader", "newoutageWrite", "newOutpacewriter", "newOutrageRW", "newoutageReader", "newOutagewriter", "newOutartRW", "newOutartInfo", "newOutartWrite", "newOutpaceRW", "newOutpaceReader", "newOutpaceWriter", "newOutureReader", "newInageRW", "newOutflowWrit", "newOutartWriter", "newOutflowInfo", "newInflowWriter", "newOutageWrit", "newoutureWrite", "newOutissueWriter", "newOutflowWrite", "newExagewriter", "newOutpointWrite", "newInageWrit", "newOutageWrite", "newoutageRW", "newOutureInfo", "newExlineWriter", "newExlineWrite", "newoutureInfo", "newOutureWriter", "newExageWriter", "newExageReader", "newOutpointRW", "newOutlineWriter", "newoutageInfo", "newInflowWrit", "newInflowRW", "newInageWrite", "newOutrageWriter", "newOutureRW", "newOutlineWrite", "newOutagementWriter", "newoutureRW", "newOuturewriter", "newOutissuewriter", "newOutissueWrite", "newOutagementWrit", "newoutagewriter"]}}
{"id1": "17111859", "id2": "823074", "code1": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"getHash": ["GetHTML", "buildHTML", " gethash", "gethash", "buildHash", "getSalt", " getHTML", "buildhash", "GetSalt", "buildSalt", "getHTML", " getSalt", "GetHash", "Gethash"], "string": ["resource", "section", "cache", "word", "version", "input", "time", "sequence", "number", "this", "slice", "in", "database", "STR", "ring", "content", "object", "address", "p", "s", "strings", "prefix", "server", "array", "value", "password", "filename", "format", "hash", "data", "null", "duration", "message", "buffer", "uri", "text", "source", "name", "file", "reference"], "hashTime": ["HashCheck", "versionTime", " hashTimer", "hexTrack", "versiontime", "hashTimer", "hexCheck", "HashTime", " hashTrack", "hashFunction", " hashtime", "HashFunction", "versionTimer", "hexTimer", "Hashtime", "hexTime", "hashtime", "HashTimer", "HashTrack", "hashCheck", " hashFunction", "hashTrack", "versionFunction", " hashCheck"], "md5": ["md25", "digse", "mand2", "hash2", "mand5", "mdql", "hash5", "MD2", "digb", " md25", "mdol", "mad512", "MD5", "digql", " mddown", "dig25", "mad5", " md53", "madse", "MDol", "mddown", "md2", "dig6", " md6", " md3", "MDkey", "md53", "mdkey", "dig5", "mdse", " md2", " mdse", "mand25", "maddown", "shab", "md6", "sha2", "mandql", "mad3", "dig512", "mdb", "MD53", " mdql", "madkey", "mad2", " mdb", "md512", "sha6", " md512", "hashol", "MD3", "hash53", "md3", "dig2", " mdkey", "sha5", "digdown", " mdol"], "result": ["entry", "section", "function", "Result", "current", "word", "results", "character", "comment", "response", "search", "match", "hex", "number", "list", "card", "json", "length", "dict", "err", "valid", "default", "part", "prefix", "expected", "work", "array", "value", "success", "feature", "format", "res", "hash", "page", "diff", "error", "data", "test", "found", "product", "digit", "r", "message", "buffer", "uri", "source", "range"], "hexString": ["rawArray", "tempstring", "hashString", "hexstring", "exArray", "packstring", "exString", "tempBuffer", "hashBuffer", "rawString", " hexstring", "exstring", "hashstring", "rexArray", " hexBuffer", "packString", "hexArray", "hexBuffer", " hexArray", "rexStr", "packStr", "hexStr", "tempString", "rexstring", "packArray", "rawstring", "exBuffer", "hashArray", "rawBuffer", "rexString", " hexStr", "tempArray"], "i": ["si", "qi", "ip", "u", "multi", "k", "ii", "c", "m", "pi", "o", "d", "abi", "ci", "di", "io", "slice", "ui", "in", "ri", "length", "bi", "p", "l", "phi", "s", "j", "I", "fi", "x", "index", "f", "e", "code", "oi", "li", "a", "start", "h", "v", "gi", "ti", "data", "ai", "b", "xi", "zi", "id", "uri", "ix", "end"], "str": ["entry", "fr", "pass", "c", "pr", "input", "char", "key", "sr", "STR", "tr", "p", "br", "err", "s", "out", "url", "sp", "x", "sl", "f", "enc", "e", "code", "res", "val", "st", "output", "data", "obj", "r", "t", "id", "uri", "Str", "text", "buffer", "source", "name"]}}
{"id1": "15822137", "id2": "23677142", "code1": "    public TableDirectory(RandomAccessFile raf) throws IOException {\n        version = raf.readInt();\n        numTables = raf.readShort();\n        searchRange = raf.readShort();\n        entrySelector = raf.readShort();\n        rangeShift = raf.readShort();\n        entries = new DirectoryEntry[numTables];\n        for (int i = 0; i < numTables; i++) {\n            entries[i] = new DirectoryEntry(raf);\n        }\n        boolean modified = true;\n        while (modified) {\n            modified = false;\n            for (int i = 0; i < numTables - 1; i++) {\n                if (entries[i].getOffset() > entries[i + 1].getOffset()) {\n                    DirectoryEntry temp = entries[i];\n                    entries[i] = entries[i + 1];\n                    entries[i + 1] = temp;\n                    modified = true;\n                }\n            }\n        }\n    }\n", "code2": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "label": 1, "substitutes": {"raf": ["fa", "RF", "ref", " ra", "rou", "rss", "arf", "sam", "fal", "rot", "fc", "root", "raft", " priv", " ar", "hel", "asu", "fin", "dra", "transform", "fd", " fa", "io", "feed", "util", " fin", "buf", "rt", "arch", "awa", "fam", "mr", "cro", "ra", "fs", "ro", "Rot", "rc", " arc", "upload", "RR", "RB", " af", "f", "ut", "af", "bas", "rw", "ica", "arc", "fed", "uf", "fp", "rah", " rot", "reader", "rr", "r", "AF", "fb", "buff", "rar", "fif", "aft", "roc", "bf", "ab", "reed", "rb", "file", "rf"], "version": ["row", "root", "section", "ip", "seed", "step", "option", "depth", "patch", "versions", "vision", "Version", "scale", "init", "release", "prefix", "server", "index", "serial", "vers", "feature", "format", "counter", "VERSION", "id", "parent", "ver"], "numTables": ["numtrees", " numTenables", "numtables", "numtasks", "numLures", "numTasks", "numtaces", "numTenables", "numDables", "numTenures", " numTenures", "NumNaces", "NumTures", "NumTests", "NumTaces", "NumNabs", " numtodes", "Numtaces", " numTests", "numPartables", "numPartaces", "numTenaces", "numTrees", "numTries", "numDures", " numTenries", "NumTabs", "numNables", "numNaces", " numTrees", "numNrees", "NumTables", "numDabs", "numTures", "numLries", "Numtasks", "numLables", "Numtests", "numtures", " numtaces", " numTenests", "numTenasks", "numNabs", " numtrees", "numTodes", "numTests", "numtests", "numNests", " numtables", "Numtables", "NumNables", "numTabs", "numtries", "numTenries", "numNures", "NumNures", " numTures", "numPartodes", " numTries", "numLests", "numPartrees", "numtabs", "NumTasks", "numTaces", " numTodes", "numTenests", "numtodes", "numNasks", "numDaces", " numTaces", "numNodes"], "searchRange": [" searchLimit", "indexRange", "filterPart", "filterrange", "indexLimit", "searchPart", "filterRange", " searchPart", "searchLimit", "indexPart", "indexrange", "filterLimit", "searchrange", " searchrange"], "entrySelector": ["entryselective", "entrySelective", "entryselector", "sectionAcceptored", "entryAcceptored", "entryselectored", "entryAcceptor", "sectionAcceptor", "sectionSelective", "sectionSelection", "entrySelectored", "entrySelection", "entryProcession", "entryProcessive", "sectionSelectored", "sectionAcception", "sectionSelector", "entryselection", "entryAcceptive", "entryAcception", "sectionAcceptive", "entryProcessored", "entryProcessor"], "rangeShift": ["rangeCut", "queryShift", "rangeshift", "queryCut", "tableShift", "queryScale", "tableScale", " rangeCut", "tableshift", "rangeScale", "queryshift", " rangeshift", "tableCut", " rangeScale"], "entries": ["Entances", "ntrance", "errorries", "equies", "entories", "attries", "emptrys", "attrys", "entsries", "encables", "antories", "emptries", "antries", "instrance", "antrance", "errorrying", "extrations", "entables", "enties", "extances", "entry", "extries", "country", "ntants", "countries", "attrations", "countables", "intrying", "endies", "instry", "objectrations", "equries", "ntries", "endries", "encies", "Entants", "instries", "instables", "entsrys", "instances", "equry", "Entrations", "anties", "intrations", " entants", "endances", "encances", "intrics", "errorrics", "antrys", "antants", "extrys", "entsants", "equances", "intries", "Entries", "endables", "emptories", "ntrys", "instrys", "Entrys", "countrys", " entrations", "objectries", "errorrations", " entrys", "ntables", "encries", "entances", "entrations", "ntances", "emptants", "entrying", "Entry", "nties", "entrance", "objectrying", "objectrics", "entrics", "ntories", "entsrations", "entrys", "insties", "ntry", "attances", "entants", "Entables"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "ini", "ii", "c", "m", "pi", "g", "o", "y", "d", "abi", "ci", "di", "io", "api", "z", "slice", "ui", "in", "ri", "bi", "my", "ie", "p", "it", "l", "phi", "init", "j", "I", "eni", "x", "uli", "index", "f", "cli", "e", "oi", "li", "ori", "a", "anti", "h", "v", "gi", "ti", "mi", "ai", "b", "xi", "id", "info", "uri", "iv", "ix", "source", "ik", "lc"], "modified": ["created", "ended", "rolled", "status", " completed", "closed", " Modified", "dirty", "restricted", "current", "initial", "hold", "unknown", "edited", " delayed", "broken", "failed", "affected", "condition", " modify", " updated", "empty", "changed", "locked", " modifying", "active", "original", "content", " altered", "successful", "valid", "mod", "disabled", "updated", "ified", "placed", "ordered", "left", "complete", "formed", "hidden", "adjusted", " original", "success", "received", "used", " modifier", "draft", " unchanged", "stable", "found", "null", "id", "interrupted", " modification", "update", "required", "offset", " modifications", "loaded"], "temp": ["txt", "entry", "local", " adapter", " aux", " zip", " generator", "ex", " wrapper", " holder", " swap", " extra", " winner", "z", "empty", "dest", " cache", " fake", "valid", "base", "j", " intermediate", "tmp", " vendor", "ant", " cleaner", "fake", "iter", " esc", "flat", " orig", "holder", " template", "emp", "extra", "result", "v", "mini", "Temp", "stable", " candidate", " source", "porary", " destination", " dummy", "parent", "cel", "tc", "lc", "template"]}}
{"id1": "822452", "id2": "17996547", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "21181542", "id2": "20306677", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "label": 1, "substitutes": {"deleteRoleType": ["deleteRoleTypes", "deleteFunctionTypes", " deleteroleTyp", "deleteRoletype", " deleteRoletype", "deleteRoleTyp", " deleteroletype", " deleteroleTypes", "deleteFunctionTyp", "deleteroleTyp", "deleteroletype", "deleteResourceType", " deleteRoleTypes", "deleteFunctionType", "deleteResourceTypes", "deleteroleTypes", " deleteroleType", "deleteResourcetype", "deleteFunctiontype", "deleteResourceTyp", "deleteroleType", " deleteRoleTyp"], "id": ["section", "ip", "sid", "string", "oid", "request", "rid", "view", "is", "version", "ids", "pid", "Id", "uid", "path", "aid", "edit", "key", "ID", "in", "length", "object", "address", "it", "part", "connection", "model", "url", "like", "ident", "index", "f", "code", "i", "start", "error", "type", "data", "vid", "info", "source", "uri", "kid", "mid", "parent", "name", "lock", "end"], "namespaceId": ["workspaceKey", "nspaceInfo", "namespaceid", "memberspaceId", "workspacesContext", "namesentityId", "aspaceId", "nsaceId", "workspaceContext", "namesspaceKey", "workspaceType", "asentityId", "NamespacedName", "asentityName", "namespacesId", "nsaceID", "namesenceType", "namesentityName", "NamespacedId", "namespacesInfo", "namespacedInfo", "namesaneId", "namesspaceInfo", "namespaceType", "namesetID", "aspaceName", "membersetType", "namespacedType", "namesetid", "namesaneName", "namespacesID", "namespacedId", "workspacePath", "memberspaceName", "NamespaceId", "worksspaceInfo", "asentityID", "nsaceid", "asentityInfo", "memberspaceType", "worksspaceKey", "membersetName", "namesspaceId", "namespacedPath", "NamespacedType", "namesplaceId", "namesetName", "namespacesContext", "workspaceid", "namespaceContext", "namesentityID", "namesaceContext", "workspacesType", "membersetid", "namespaceName", "Namespaceid", "namesplaceInfo", "membersetId", "namesplaceid", "namesaceType", "namesaneType", "NamespaceName", "namespacesid", "worksspacePath", "namesaceid", "workspacesId", "aspaceInfo", "namespaceKey", "namesenceId", "namesetId", "namesplaceID", "workspacesid", "namesenceid", "nsaceInfo", "namespaceID", "namesentityInfo", "namesenceContext", "namesaceId", "memberspaceid", "namesetInfo", "Namespacedid", "workspaceId", "namespacesType", "nspaceId", "NamespaceType", "namespacePath", "worksspaceId", "namespacesName", "aspaceID", "namespacedid", "namespacesKey", "namespacedKey", "nspaceid", "namespacedName", "namesaceID", "namesaceInfo", "namespaceInfo", "namesetType", "namesspacePath", "namespacesPath", "nspaceID", "workspaceInfo", "namesaneid"], "removeReferencesInRoleTypes": ["removeReferencesInServiceRelations", "removeReferencesFromRoleTypes", "removeReferencesInRuleType", "removeReferencesedInRoleTypes", "removeReferencesInroleTypes", "removeReferencesInRoleRelations", "removeReferencesInRuletypes", "removeReferencesInRuleRelations", "removeReferencesInRoleNames", "removeReferencesedInRoletypes", "removeReferencesFromroleTypes", "removeReferencesedInRoleNames", "removeReferencesedInRoleType", "removeReferencesInServiceType", "removeReferencesedInroleNames", "removeReferencesInroleNames", "removeReferencesedInroleTypes", "removeReferencesFromRoleRelations", "removeReferencesInServiceTypes", "removeReferencesFromroleType", "removeReferencesInRuleNames", "removeReferencesFromRoleType", "removeReferencesInServiceNames", "removeReferencesInroletypes", "removeReferencesInRoletypes", "removeReferencesInRoleType", "removeReferencesInroleRelations", "removeReferencesFromRoleNames", "removeReferencesInRuleTypes", "removeReferencesedInroleType", "removeReferencesFromroleRelations", "removeReferencesedInroletypes", "removeReferencesFromroleNames", "removeReferencesInroleType"], "permit": ["permmit", "permMIT", "Permissions", "Permit", "Perit", "permissions", "Permits", "perit", " permits", "PERmission", "PERMIT", "permits", "PerMIT", "recmit", "recit", "permmissions", "Permission", " permission", "permmission", "perMIT", "PERmit", "recmission", " perit", "PERmissions", "permission", "recmits"], "exist": ["purpose", "existing", "draw", "cmp", "support", "front", "include", "register", "present", "know", "fill", "ist", "continue", "destroy", "stick", "same", "edit", "match", "add", "list", "existence", "except", "fail", "destruct", "delete", "icate", "ident", "index", "existent", "start", "check", "apply", "diff", "write", "inc", "update", "cont", "form", "keep", "create"], "msgBuf": ["msgLuff", "msgDuff", "messageFuff", "msgLundle", "msgBUF", "msgPluf", "messageFbuf", "msgFob", " msgFuf", "msgBob", "msgAbuf", "msgCob", "messageBbuf", "msgDaf", "messageAuff", " msgFaf", "messageBbox", "messageFbox", "msgAbox", "msgAbuff", "messageAuf", "msgDBuff", "messageFuf", "msgEBuff", "msgDBbuf", " msgFbuf", "msgDBUF", "msgBraf", "msgFBuf", "msgAuff", "msgAUF", " msgBbuff", "messageAbuf", "msgFBob", "msgFbuff", "msgLob", "msgCuf", "msgFuff", " msgFraf", "msgFaf", "msgDuf", "msgAaf", "msgLUF", "msgFundle", " msgBuff", "msgBbuf", "msgEBbox", "messageFUF", "msgAuf", " msgLundle", "msgBundle", " msgBbuf", "msgDBuf", "msgDbuf", "msgFuf", " msgLuff", "msgFraf", "msgAob", " msgBraf", "msgBbox", "msgFbox", "messageFob", "messageBuf", "msgBbuff", " msgFuff", "msgPlundle", "msgFbuf", " msgBaf", "msgLuf", "msgPlaf", "msgFUF", "msgFBuff", "messageBUF", "messageBob", "msgBuff", "msgFBUF", " msgLuf", " msgBundle", "msgLaf", "msgEBuf", "messageAUF", " msgLaf", "msgPluff", "messageBuff", " msgFbuff", "msgEBbuf", "msgBaf", "msgCuff", "msgCbuf", "msgAraf"], "objects": ["names", "agents", "boxes", "ks", "classes", "pps", "bugs", "resources", "apps", "parents", "lines", "values", "results", "ids", "relations", "images", "os", "articles", "files", "ins", "notes", "groups", "members", "object", "plugins", "properties", "locks", "organisms", "oids", "obs", "roots", "cells", "pins", "actions", "ops", "projects", "keys", "kids", "children", "blocks", "frames", "archs", "types", "phones", "owners", "links", "features", "cats", "points", "archives", "parts", "obj", "items", "people", "products", "users", "jobs", "models"], "sqlRightId": ["sqlrightPoint", "sqlRID", "sqlRestRef", "SQLRightRef", " sqlrightId", " sqlRightPoint", "SQLRestID", "sqlLeftType", "sqlRRef", "sqlRightType", "sqlLeftPoint", " sqlRightType", "SQLRestid", "sqlRid", "sqlRestID", "sqlRId", "SQLRightId", "sqlLeftId", " sqlrightType", "sqlLeftid", " sqlrightid", "sqlRightid", "sqlrightId", "sqlRightID", "SQLRestRef", "sqlrightType", "SQLRestId", "sqlRestId", " sqlrightPoint", "sqlrightid", " sqlRightid", "sqlRestid", "sqlRightRef", "sqlRightPoint", "SQLRightid", "SQLRightID"], "sqlParent": [" sqlParents", "suparent", " sqlparent", "sqlRoot", "suRoot", "suParent", "qlparent", "suParents", "sqlParents", " sqlRoot", "qlParents", "qlRoot", "sqlparent", "qlParent"], "sql": [" session", "description", " SQL", "select", "dl", "msg", "log", "operation", " msg", "conn", " db", "s", "replace", "url", "delete", "where", "sl", "link", "session", " url", "repl", "error", "acl", " params", "ql", "update", "SQL", "db"], "pstmt": ["Pstmt", "pstrm", " pstct", " psttr", "pstrct", "pSttr", " pstm", "pstatmr", "Pcttr", "s", "Security", "delete", "pctmr", "pndmt", " pStmt", "pstatct", "pcttr", "pstmb", "pfmd", "pstrmt", " pstbl", "psttr", " postmt", "pndmb", "pStct", "pctbl", " postnt", "Pctmd", "postnt", "pstmd", " pstnt", "Error", "add", "Pstmd", "this", "The", "pndbl", "pmtct", "_", " pndct", "pmtmd", "pctm", "All", "pndct", "Pctct", "pstm", "pctmd", "pStmt", "pstrtr", " pstmr", "postmt", "Delete", "pftr", "pstatnt", " pndbl", "pstnt", " pStct", "postmr", " pStm", " pSttr", "Pstct", " postct", " pndmt", "pctnt", "pstmr", "pctmb", "New", "pstatmt", "pctmt", "pfct", "Pctmt", "postct", "pstbl", " pndmb", "pctct", "pfmt", "pmtmb", "pmtbl", "pmttr", "Psttr", "pstct", " pstmb", " postmr", "pmtmt", "pStm"], "typeGid": ["TypeGid", "TypeCid", "linkGid", "TypeGID", "typeCname", "linkGID", "typegid", "linkGVoid", "linkGname", "typeGUid", "typegoid", "TypeGmin", "TypeGname", "typeAccname", "typeAccid", "TypeCmin", "typeGID", "linkGoid", "typeGUname", "TypeCID", "typeGname", "linkGVid", "typegID", "typeGUoid", "typeWID", "typeGVname", "typeWmin", "linkGVID", "typeAccID", "typeWname", "typeGVID", "typeWid", "typegname", "typeGVid", "typeGmin", "typeGVoid", "typeGoid", "typeCID", "typeAccmin", "typeCid", "linkGVname", "TypeCname", "typeGUID", "typeCmin"], "defaultLevel": ["configLevel", "DefaultLevel", "configCl", " defaultMode", " defaultDepth", " defaultCl", "configMode", "defaultDepth", "defaultMode", "DefaultMode", "defaultCl", "DefaultDepth", "DefaultCl", "configDepth"], "success": ["status", "accept", "results", "failed", "continue", "response", "Success", "match", "warning", "progress", "roll", "batch", "successful", "resp", "replace", "fail", "reg", "complete", "serial", "result", "test", "error", "data", "submit", "successfully", "message", "launch"]}}
{"id1": "11183087", "id2": "10361370", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "label": 1, "substitutes": {"doPost": ["handlePut", "doPOST", " doPOST", "handleSearch", "doingPost", " doPut", "doPut", "doingPOST", "doingSearch", " doSearch", "doingPut", "handlePost", "doSearch", "handlePOST"], "request": ["resource", "application", "pull", "route", "subject", "use", "external", "project", "join", "instance", "current", "initial", "context", "xml", "view", "Request", "http", "call", "forward", "state", "input", "right", "report", "have", "queue", "post", "enter", "the", "user", "child", "object", "er", "frame", "order", "hello", "rate", "pe", "event", "model", "server", "query", "url", "get", "config", "complete", "e", "q", "image", "remote", "result", "error", "type", "data", "req", "QUEST", "r", "press", "message", "web", "info", "parent", "client", "buffer", "create", "rf"], "response": ["Response", "resource", "application", "status", "respond", "site", "reply", "http", "results", "view", "report", "api", "onse", "object", "guide", "resp", "document", "connection", "model", "server", "pool", "writer", "res", "result", "page", "next", "output", "message", "web", "parent", "client", "body", "template"], "senha": ["senla", " senwa", "zenHa", "suitla", "sanHa", " senca", "sanlah", "senhi", "zensha", "tonHa", "senca", "senlah", "tonlah", "snla", "snhi", "zenha", "renha", "suitsha", "zenaka", "senHa", "zenhi", " senHa", "renca", "tonha", " senlah", "snsha", "tonwa", "sanha", "suitha", "renHa", "senwa", "sensha", "zenca", "suithi", "zenla", "renaka", "snha", "senaka", " senaka", "sanwa"], "email": ["mail", "username", "Email", "ip", "fax", "line", "zip", "string", "environment", "xml", "secret", "service", "language", "label", "user", "address", "letter", "hello", "business", "model", "phrase", "server", "url", "office", "e", "home", "password", "example", "mobile", "login", "data", "account", "message", "id", "alias", "name", "file"], "messageDigest": ["messageDest", "meDigest", "messageDester", " messageDigester", " messageDend", "medigEST", "messagedigest", "messageDigester", "messagedigester", " messageDEST", "messageMailest", "meDigester", " messageDest", " messagedigEST", "messageDigEST", " messageDester", "messagedigEST", "meDigher", "messagedigend", " messagedigest", " messagedigester", "meDigEST", "messageDher", "medigest", "messagedigher", "messageDend", "messageDEST", "medigester", "messageMailester", "messageDigend", " messageDigend", "messageMailEST", "medigher", "messageDigher", "messageMailend", " messageDigEST"], "usuario": ["sulurio", "suuarial", "usituarial", "ussuario", "usuariat", " usuarius", "ususario", "usuasio", "usiturio", "ussuarium", " usurio", " usuiasio", "usituario", "usguario", "usguariat", "suluarial", "usuillo", "suuario", " usuariat", "usueillo", " ususillo", " usuillo", "usuarius", " usuasio", "ususillo", "ussuasio", "suluasio", "uslurio", "ussurio", "usuitario", "usluarial", "usuitarium", "usurio", "usuiasio", " usuiario", "suluario", "usituasio", " ususario", "suurio", " ususarius", "ususarius", "usueariat", " usuirio", "usuarial", "usuiarium", "usuitasio", "usuearius", "usluasio", "usuiario", "usuitrio", "usluario", "suuasio", "usueario", " usuarium", "ususariat", "usguarius", "ussuarial", "usuarium", " usuiarium", "usguillo", " ususariat", "usuirio"], "redirect": ["redurl", "edurl", "rerict", "edirect", " redirection", "redrict", "reirect", " redRECT", "indirection", "predRECT", "Redirect", "Redirection", "induce", " reduce", "reroute", "preduce", "redirection", "indirect", "redition", "Redroute", "redRECT", "predirect", "predroute", "indrict", "Redrict", " redition", " redrict", "predrict", "predirection", "RedRECT", "Redurl", " redurl", "reduce", "edirection", "Redition", "reirection", "edition", "redroute"], "session": ["group", "use", "sid", "cache", "view", "http", "proxy", "comment", "service", "state", "input", "node", "object", "child", "user", "cookie", "browser", "flash", "ession", "app", "connection", "document", "storage", "event", "server", "query", "sp", "system", "config", "sl", "Session", "image", "page", "result", "ssl", "data", "message", "info", "client", "site", "person"]}}
{"id1": "18374598", "id2": "471804", "code1": "    private synchronized File download() throws AMSpacksException {\n        String a = addr.url.toExternalForm();\n        int p = a.lastIndexOf('/');\n        if (p < 0) {\n            p = a.lastIndexOf('\\\\');\n        }\n        if (p < 0) {\n            a = \"\" + Math.random();\n        } else {\n            a = a.substring(p + 1);\n        }\n        File td = null;\n        try {\n            td = File.createTempFile(a, \"\").getParentFile();\n        } catch (IOException ex) {\n            td = new File(\".\");\n        }\n        File f = new File(td, a);\n        td.delete();\n        long total = addr.update.getSize();\n        int progress = 0;\n        try {\n            InputStream in = new BufferedInputStream(addr.url.openStream());\n            FileOutputStream out = new FileOutputStream(f);\n            byte[] buf = new byte[500];\n            int n;\n            long percentage = 0;\n            callback.updateProgress(percentage);\n            do {\n                n = in.read(buf);\n                if (n > 0) {\n                    out.write(buf, 0, n);\n                    progress += n;\n                    long tmpPercentage = progress * 100 / total;\n                    if (percentage != tmpPercentage) {\n                        percentage = tmpPercentage;\n                        callback.updateProgress(percentage);\n                    }\n                }\n            } while (n > 0);\n            in.close();\n            out.flush();\n            out.close();\n        } catch (Exception ex) {\n            f.delete();\n            throw new DownloadFailedException(\"Error downloading update.\", ex);\n        }\n        long size = f.length();\n        String checksum = CheckSumFinder.checkSum(f);\n        if (size == addr.update.getSize() && checksum.equalsIgnoreCase(addr.update.getChecksum())) return f; else {\n            f.delete();\n            throw new CheckSumMismathchException(\"Checksum mismatch: \" + addr.update.getChecksum() + \" expected but was \" + checksum);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"download": ["pull", "external", "string", "copy", "open", "archive", "Download", "release", " Download", "install", "setup", "upload", "exec", "url", "get", "load", "loader", "dump", "filename", "transfer", "output", "diff", "data", "write", "update", "name", "file"], "a": ["an", "action", "fa", "aux", "u", "ua", "za", "c", "string", "m", "qa", "ca", "access", "asa", "oa", "area", "A", "input", "na", "da", "about", "as", "cha", "au", "api", "at", "aa", "wa", "sa", "la", "ppa", "ac", "ada", "ad", "aaa", "alpha", "audio", "l", "ha", "amp", "s", "base", "ea", "pa", "url", "addr", "ga", "aw", "ast", "ma", "array", "sta", "af", "e", "am", "i", "auto", "tta", "ae", "data", "r", "b", "t", "ba", "ata", "ab", "va", "name", "art", "file"], "p": ["ap", "ping", "dp", "ip", "u", "c", "pr", "pi", "py", "m", "y", "op", "o", "d", "pat", "after", "api", "np", "pp", "bp", "tp", "l", "part", "w", "pos", "pe", "cp", "pa", "j", "sp", "x", "e", "i", "pre", "q", "start", "h", "fp", "v", "P", "jp", "po", "b", "t"], "td": ["fa", "dc", "det", "txt", "fr", "pc", "pd", "fc", "od", "th", "pb", "dat", "table", "sf", "d", "dl", "aff", "fd", "bd", "pt", "TD", "rt", "cf", "ppa", "ht", "tr", "tn", "hd", "dd", "ld", "ff", "tf", "tif", "cd", "gb", "ud", "dh", "tmp", "dt", "sb", "nd", "af", "fm", "fp", "tl", "file", "elt", "sd", "b", "fb", "t", "lf", "tt", "rd", "buff", "bt", "db", "tc"], "f": ["fa", "df", "fe", "F", "fc", "u", "of", "function", "g", "c", "m", "full", "o", "sf", "d", "fo", "fx", "aff", "fast", "fd", "feed", "cf", "fam", "fold", "handler", "fn", "fs", "l", "ff", "tf", "fw", "base", "w", "j", "fi", "flat", "e", "fm", "i", "uf", "xf", "h", "fp", "fen", "v", "file", "fl", "r", "b", "fb", "t", "bf", "lf", "info", "buffer", "form", "fr", "rf"], "total": ["temp", "done", "local", "percent", "Total", "full", "otal", "current", "sum", "cost", "partial", "post", "doc", "active", "json", "length", "num", "count", "valid", "reported", "scale", "quant", "normal", "base", "all", "upload", "server", "max", "complete", "now", "serial", "set", "ok", "used", "start", "finished", "nt", "next", "error", "last", "info", "parent", "available", "recent"], "progress": ["rss", "resource", "Progress", "done", "status", "c", "current", "step", "rec", "dist", "path", "cost", "partial", "np", "process", "number", "skip", "active", "length", "summary", "num", "content", "conn", "roll", "count", "err", "grade", "resp", "running", "scale", "coll", "wait", "complete", "bar", "xp", "success", "next", "error", "vance", "width", "recent"], "in": ["In", "again", "c", "ini", "IN", "cin", "o", "din", "inner", "bin", "input", "as", "con", "io", "pin", "ins", "ac", "inn", "ie", "kin", "l", "isin", "init", "win", "lin", "url", "gin", "i", "nin", "socket", "v", "login", "reader", "data", "vin", "r", "b", "inc", "source", "stream"], "out": ["ch", "line", "again", "full", "c", "cache", "o", "ex", "call", "inner", "bin", "Out", "log", "io", "outs", "co", "ins", "conn", "fn", "err", "up", "w", "s", "exec", "url", "code", "off", "callback", "to", "extra", "cb", "v", "ext", "output", "error", "data", "obj", "b", "inc", "conf", "parent", "buffer", "update", "client", "file", "flow"], "buf": ["grab", "bh", "auc", "cv", "area", "bin", "box", "queue", "pad", "cf", "seq", "bp", "header", "loc", "br", "bag", "ff", "rc", "cmd", "tmp", "bc", "uno", "pkg", "uf", "cap", "callback", "uc", "bytes", "fp", "cb", "v", "border", "data", "raw", "feat", "Buff", "b", "fb", "buff", "ba", "bf", "buffer", "wb", "rb", "padding"], "n": ["nb", "nit", "not", "u", "N", "g", "m", "current", "c", "o", "d", "node", "dn", "np", "z", "none", "number", "nn", "network", "skip", "num", "length", "no", "nr", "min", "nor", "count", "fn", "br", "l", "ng", "net", "w", "pos", "cn", "j", "coll", "sn", "x", "non", "e", "len", "ns", "i", "rn", "ne", "v", "error", "r", "b", "en", "nc", "un"], "percentage": ["variity", "poundure", "latay", "Percentage", "variide", "metay", " percentages", "percentay", "Percentager", "percentile", "metages", "metage", "latide", "variage", "percentrage", "parage", "percentager", "percentity", "poundages", "latage", "Percenture", "compide", "pardages", "Percentages", "poundage", "metile", "pardure", "pardability", "metency", " percentile", "poundability", "pardage", "missay", "variile", "parages", "percentability", "voltage", "missile", "missrage", "Percentency", "compage", "metrage", "percenture", "percentages", "variay", "Percentability", "varirage", " percentency", "voltile", "percentide", "parile", "voltager", "percentency", "compity", "Percentile", "compay", "latity", "parager", "missage", "voltages"], "tmpPercentage": ["cppPercentrage", "tmppercentile", "tempPercentages", "tmpComple", "tmppercentay", "tmpPassrage", "cppPercentment", "tmpHalfency", "temppercentages", "tmpPassay", "tmpPercentile", "tmpPercentle", "tmppercentment", "cpppercentrage", "tmppercentages", "tmppercentency", "tmppercentrage", "temppercentle", "tmpPercentment", "tmpPassment", "tmpPassile", "ptypercentag", "cppPercentay", "tmppercentle", "tmpPercentency", "tmpPercentrage", "tmpPercentay", "ptypercentage", "tmpMagnment", "tmppercentag", "tmpHalfage", "temppercentency", "ptypercentency", "tmpCompages", "tmpPercentag", "tmpPassency", "ptyPercentage", "tmpCompency", "temppercentage", "tmpMagnrage", "cpppercentay", "ptyPercentency", "tempPercentency", "tmpPercentages", "ptypercentile", "tmpHalfag", "tmpPassage", "tempPercentle", "tmppercentage", "tmpMagnay", "tmpPassag", "tmpCompage", "cpppercentment", "tmpMagnage", "ptyPercentile", "tmpHalfile", "tempPercentage", "cpppercentage", "cppPercentage", "ptyPercentag"], "size": ["sized", "ize", "external", "fee", "send", "speed", "clean", "c", "capacity", "sum", "time", "empty", "length", "content", "address", "unit", "count", "loc", "SIZE", "grade", "scale", "rc", "small", "width", "sn", "max", "sec", "e", "code", "len", "i", "ne", "error", "Size", "data", "esc", "offset", "name", "core"], "checksum": ["timesig", " checksal", "checkme", " checksam", " checksig", "cksam", "cksums", "timessum", "getsumm", " checksme", "getssum", "checksums", "cksum", " Checksme", "timesum", " checkssum", "getsam", "checkum", " checksums", "cksumm", " checksumm", "checksumm", "timesums", " Checksal", "cksig", "checksig", "checksam", "checksal", "checkssum", " Checkssum", "checksme", "checkal", "ckssum", "getsum", " Checksum"]}}
{"id1": "11484416", "id2": "6470716", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "label": 1, "substitutes": {"moveFile": ["moveDirectory", "moveFiles", " movedFile", " movePath", "movePath", " moveDirectory", " movedPath", "MovePath", "MoveFile", "MoveDirectory", " movedFiles", "MoveFiles", " movedDirectory", " moveFiles"], "orig": ["folder", "temp", "ctr", "exe", "raid", "proxy", "bin", "imag", "Orig", "old", "copy", "raf", "transform", "prev", "org", "buf", "dest", "impl", "coord", "original", "archive", "loc", "build", "comb", "frame", "init", "base", "tmp", "coll", "array", "f", "iter", "bas", "real", "ori", "home", "internal", "image", "remote", "ext", "img", "obj", "id", "info", "source", "src", "rb", "file", "origin"], "target": ["resource", "temp", " Target", "external", "project", "join", "current", "copy", "path", "manager", "platform", "match", "force", "this", "dest", "arget", "compatible", "object", "original", "ret", "archive", "template", "build", "it", "base", "replace", "tmp", "f", "eth", "auto", "format", "Target", "to", "remote", "result", "nt", "next", "reference", "t", "prot", "parent", "source", "master", "origin"], "buffer": ["resource", "position", "cache", "request", "uffer", "padding", "bin", "input", "copy", "layer", "wave", "feed", "sequence", "buf", "queue", "slice", "length", "content", "repeat", "address", "header", "batch", "frame", "base", "url", "read", "Buffer", "iter", "code", "bytes", "transfer", "result", "bb", "data", "write", "raw", "null", "b", "stack", "buff", "message", "source", "binary", "block", "file", "reference"], "bread": ["fe", "robe", "fee", "raft", "brew", "zip", "zero", "bat", "piece", "wen", "broken", "str", "buck", "abi", "beat", "bare", "feed", "key", "fle", "die", "bn", "design", "num", "cook", "div", "length", "inn", "bee", "eb", "good", "batch", "grain", "fine", "hello", "choice", "rib", "ffe", "wake", "circ", "fred", "bc", "fed", "fen", "four", "meal", "bb", "rub", "ble", "food", "fall", "fif", "web", "knife", "loop", "sleep", "cake", "width", "rows"], "fis": ["afIs", "lfis", "qos", "fxisa", "afis", "fxis", "his", "lfos", "qiss", "fils", " fIs", "qis", "fIs", " fiss", "ufos", "lfIs", "ufiss", "afiss", "ufis", "hIs", "fisa", "lfiss", " fils", "qils", "hisa", "afos", "fxIs", "fiss", " fisa", "hos", "ufils", "fxos"], "fos": ["Fros", "Foses", "flens", "flos", "fose", "gos", " foses", "infos", " fose", "gis", "infois", "goss", "faos", "Fors", "flors", "fros", "floses", "flose", "fens", "flois", "infors", "Fose", "flaos", "Fis", "Fois", "infaos", "foses", "Fos", "fois", "Foss", "Faos", " fros", " foss", "fors", "foss", " fens", "gros", "Fens"]}}
{"id1": "10690321", "id2": "8665321", "code1": "    private static void readData() {\n        StringTokenizer sTok;\n        topSet = new HashSet();\n        sTok = new StringTokenizer(tops, \",\");\n        while (sTok.hasMoreTokens()) topSet.add(sTok.nextToken());\n        leftSet = new HashSet();\n        sTok = new StringTokenizer(lefts, \",\");\n        while (sTok.hasMoreTokens()) leftSet.add(sTok.nextToken());\n        rightSet = new HashSet();\n        sTok = new StringTokenizer(rights, \",\");\n        while (sTok.hasMoreTokens()) rightSet.add(sTok.nextToken());\n        farRightSet = new HashSet();\n        sTok = new StringTokenizer(farrights, \",\");\n        while (sTok.hasMoreTokens()) farRightSet.add(sTok.nextToken());\n        vowelSet = new HashSet();\n        sTok = new StringTokenizer(vowels, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            vowelSet.add(ntk = sTok.nextToken());\n            if (maxEwtsVowelLength < ntk.length()) maxEwtsVowelLength = ntk.length();\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        puncSet = new HashSet();\n        sTok = new StringTokenizer(others, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            puncSet.add(ntk = sTok.nextToken());\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet = new HashSet();\n        tibSet = new HashSet();\n        sTok = new StringTokenizer(tibetanConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            tibSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        sanskritStackSet = new HashSet();\n        sTok = new StringTokenizer(otherConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            sanskritStackSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        numberSet = new HashSet();\n        sTok = new StringTokenizer(numbers, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            numberSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet.add(\"Y\");\n        charSet.add(\"R\");\n        charSet.add(\"W\");\n        validInputSequences.put(\"Y\", anyOldObjectWillDo);\n        validInputSequences.put(\"R\", anyOldObjectWillDo);\n        validInputSequences.put(\"W\", anyOldObjectWillDo);\n        sTok = null;\n        top_vowels = new HashSet();\n        top_vowels.add(i_VOWEL);\n        top_vowels.add(e_VOWEL);\n        top_vowels.add(o_VOWEL);\n        top_vowels.add(ai_VOWEL);\n        top_vowels.add(au_VOWEL);\n        top_vowels.add(reverse_i_VOWEL);\n        try {\n            URL url = TibetanMachineWeb.class.getResource(fileName);\n            if (url == null) {\n                System.err.println(\"Cannot find \" + fileName + \"; aborting.\");\n                System.exit(1);\n            }\n            InputStreamReader isr = new InputStreamReader(url.openStream());\n            BufferedReader in = new BufferedReader(isr);\n            System.out.println(\"Reading Tibetan Machine Web code table \" + fileName);\n            String line;\n            boolean hashOn = false;\n            boolean isTibetan = false;\n            boolean isSanskrit = false;\n            boolean ignore = false;\n            while ((line = in.readLine()) != null) {\n                if (line.startsWith(\"<?\")) {\n                    if (line.equalsIgnoreCase(\"<?Consonants?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Other?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Input:Punctuation?>\") || line.equalsIgnoreCase(\"<?Input:Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Tibetan?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Sanskrit?>\")) {\n                        isSanskrit = true;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?ToWylie?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Ignore?>\")) {\n                        isSanskrit = false;\n                        ignore = true;\n                    }\n                } else if (line.startsWith(\"//\")) {\n                    ;\n                } else if (line.equals(\"\")) {\n                    ;\n                } else {\n                    StringTokenizer st = new StringTokenizer(line, DELIMITER, true);\n                    String wylie = null;\n                    DuffCode[] duffCodes;\n                    duffCodes = new DuffCode[11];\n                    int k = 0;\n                    StringBuffer escapedToken = new StringBuffer(\"\");\n                    ThdlDebug.verify(escapedToken.length() == 0);\n                    while (st.hasMoreTokens()) {\n                        String val = getEscapedToken(st, escapedToken);\n                        if (val.equals(DELIMITER) && escapedToken.length() == 0) {\n                            k++;\n                        } else if (!val.equals(\"\")) {\n                            if (escapedToken.length() != 0) {\n                                escapedToken = new StringBuffer(\"\");\n                                ThdlDebug.verify(escapedToken.length() == 0);\n                            }\n                            switch(k) {\n                                case 0:\n                                    wylie = val;\n                                    break;\n                                case 1:\n                                    duffCodes[TM] = new DuffCode(val, false);\n                                    break;\n                                case 2:\n                                    if (!ignore) {\n                                        duffCodes[REDUCED_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 3:\n                                    duffCodes[TMW] = new DuffCode(val, true);\n                                    if (null != duffCodes[TM]) {\n                                        TMtoTMW[duffCodes[TM].getFontNum() - 1][duffCodes[TM].getCharNum() - 32] = duffCodes[TMW];\n                                    }\n                                    if (null != TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32]) throw new Error(\"tibwn.ini is supposed to use the TibetanMachineWeb glyph as the unique key, but \" + val + \" appears two or more times.\");\n                                    TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = duffCodes[TM];\n                                    if (wylie.toLowerCase().startsWith(\"\\\\uf0\")) {\n                                        int x = Integer.parseInt(wylie.substring(\"\\\\u\".length()), 16);\n                                        ThdlDebug.verify((x >= 0xF000 && x <= 0xF0FF));\n                                        NonUnicodeToTMW[x - '\uf000'] = new DuffCode[] { duffCodes[TMW] };\n                                    }\n                                    break;\n                                case 4:\n                                case 5:\n                                case 6:\n                                case 7:\n                                case 8:\n                                case 9:\n                                    if (!ignore) {\n                                        try {\n                                            duffCodes[k - 1] = new DuffCode(val, true);\n                                        } catch (Exception e) {\n                                            System.err.println(\"Couldn't make a DuffCode out of \" + val + \"; line is \" + line + \"; k is \" + k);\n                                        }\n                                    }\n                                    break;\n                                case 10:\n                                    if (!val.equals(\"none\")) {\n                                        StringBuffer unicodeBuffer = new StringBuffer();\n                                        StringTokenizer uTok = new StringTokenizer(val, \",\");\n                                        while (uTok.hasMoreTokens()) {\n                                            String subval = uTok.nextToken();\n                                            ThdlDebug.verify(subval.length() == 4 || subval.length() == 3);\n                                            try {\n                                                int x = Integer.parseInt(subval, 16);\n                                                ThdlDebug.verify((x >= 0x0F00 && x <= 0x0FFF) || x == 0x5350 || x == 0x534D || x == 0x0020 || x == 0x00A0 || x == 0x2003);\n                                                unicodeBuffer.append((char) x);\n                                            } catch (NumberFormatException e) {\n                                                ThdlDebug.verify(false);\n                                            }\n                                        }\n                                        TMWtoUnicode[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = unicodeBuffer.toString();\n                                        char ch;\n                                        if (unicodeBuffer.length() == 1 && UnicodeUtils.isInTibetanRange(ch = unicodeBuffer.charAt(0))) {\n                                            if (null != UnicodeToTMW[ch - '\u0f00'][0] && '\u0f00' != ch && '\u0f02' != ch && '\u0f03' != ch && '\u0f0b' != ch && '\u0f0e' != ch && '\u0f40' != ch && '\u0f42' != ch && '\u0f49' != ch && '\u0f4f' != ch && '\u0f51' != ch && '\u0f53' != ch && '\u0f5e' != ch && '\u0f62' != ch && '\u0f64' != ch && '\u0f67' != ch && '\u0f6a' != ch && '\u0f71' != ch && '\u0f72' != ch && '\u0f73' != ch && '\u0f74' != ch && '\u0f75' != ch && '\u0f76' != ch && '\u0f77' != ch && '\u0f78' != ch && '\u0f79' != ch && '\u0f7a' != ch && '\u0f7c' != ch && '\u0f7e' != ch && '\u0f81' != ch) {\n                                                throw new Error(\"tibwn.ini has more than one TMW fellow listed that has the Unicode \" + val + \", but it's not on the list of specially handled glyphs\");\n                                            }\n                                            UnicodeToTMW[ch - '\u0f00'][0] = duffCodes[TMW];\n                                        }\n                                    }\n                                    break;\n                                case 11:\n                                    if (!ignore) {\n                                        duffCodes[HALF_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 12:\n                                    if (!ignore) {\n                                        DuffCode binduCode = new DuffCode(val, true);\n                                        binduMap.put(duffCodes[TMW], binduCode);\n                                    }\n                                    break;\n                                case 13:\n                                    throw new Error(\"tibwn.ini has only 13 columns, you tried to use a 14th column.\");\n                            }\n                        } else {\n                            if (k == 10) {\n                                throw new Error(\"needed none or some unicode; line is \" + line);\n                            }\n                        }\n                    }\n                    if (k < 10) {\n                        throw new Error(\"needed none or some unicode; line is \" + line);\n                    }\n                    if (!ignore) {\n                        if (null == wylie) throw new Error(fileName + \" has a line ^\" + DELIMITER + \" which means that no Wylie is assigned.  That isn't supported.\");\n                        if (hashOn) {\n                            tibHash.put(Manipulate.unescape(wylie), duffCodes);\n                        }\n                        if (isTibetan) {\n                            StringBuffer wylieWithoutDashes = new StringBuffer(wylie);\n                            for (int wl = 0; wl < wylieWithoutDashes.length(); wl++) {\n                                if (wylieWithoutDashes.charAt(wl) == '-') {\n                                    wylieWithoutDashes.deleteCharAt(wl);\n                                    --wl;\n                                }\n                            }\n                            tibSet.add(wylieWithoutDashes.toString());\n                        }\n                        if (isSanskrit) {\n                            sanskritStackSet.add(wylie);\n                        }\n                        if (null == duffCodes[TMW]) throw new Error(fileName + \" has a line with wylie \" + wylie + \" but no TMW; that's not allowed\");\n                        int font = duffCodes[TMW].getFontNum();\n                        int code = duffCodes[TMW].getCharNum() - 32;\n                        toHashKey[font][code] = Manipulate.unescape(wylie);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"file Disappeared\");\n            ThdlDebug.noteIffyCode();\n        }\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"readData": ["parsedata", "processdata", "processData", "parseText", "initText", "initDATA", "processText", "parseDATA", "processDATA", "initData", "parseData", "readText", "initdata", "readdata", "readDATA"], "sTok": [" sToken", "submitTok", "dsTok", "singleTok", " sBuff", "fsTok", "sSel", "siteTok", "syncIter", " sVal", "SIter", "sesUk", "awsEnc", "sisVal", "submitBu", "hsVo", "nBu", "yourTok", "newKe", " sLoc", " sEh", "sOp", "testsKo", "pIter", "awsRec", "seToken", "yourLoc", "sOtt", "sesAk", "sTag", "nUt", " sDoc", "lsTok", "dsOtt", " sTu", "awsDoc", "SBuff", " sPos", "fsDec", "sDoc", "gsTok", "suTok", "STok", "gsSk", "awsTok", "dsAk", "sPop", "sportsPop", "sBu", "awsLoc", " sChat", "dTok", "synOtt", "singleSk", "sOrg", "hsTok", "sBuild", " sIter", "singleCorp", "nMsg", " sBot", "sEnc", "nOp", " sSk", "dsIter", "obsBuild", "obsTok", "dsVo", "sEh", "dToken", " sOtt", " sSel", "sDec", "dsLoc", "tIter", "sesTok", "fsLex", "submitLex", "sportsTok", "sSk", "sLoc", "suVo", "sslTu", "gsLex", "sportsEh", "sToken", "sisTu", "nIter", "hsSk", "nTok", "sAk", " sTag", "syncTu", "pTok", " sBu", "opensEh", "seTok", "syncTok", "sMsg", "synVal", "sVal", "newTok", " sPop", "sKe", " sKo", "seSel", "siteLoc", "opensPos", "sOk", "opensPop", "SToken", "servicesIv", "sChat", "lsBuild", "sportsBuild", "sisBuff", "servicesLex", "testsTu", "testsTok", " sVo", "tTok", "pToken", "dsTu", "synIter", "SSel", "sslIter", "sesIter", "sPos", "servicesKo", "dsVal", "tLoc", "sisOtt", " sCorp", "dLoc", "sisIter", " sMsg", "newBot", "sChan", "submitMsg", "sBuff", "fsSk", "opensTok", "sisChan", "singleMsg", "syncVo", "nChat", "sUt", "sTu", " sOk", "sVo", " sIv", "yourChat", "sisTok", " sRec", "sRec", " sKe", "sportsKe", "sCorp", " sDec", "synTok", "newUt", "sslTok", "obsKe", "siteOtt", "sLex", "hsIter", "sUk", " sOp", "lsKe", "siteIter", "sIter", "testsIter", "nLoc", "dIter", " sChan", "siteTag", "nLex", "dsUk", "sBot", " sUt", "sportsPos", " sLex", "seBuff", "sIv", "sslVo", " sEnc", "tDoc", " sAk", "sKo", "servicesTu", "SOk", "awsIter", "gsDec", "pLoc", "yourMsg", "servicesIter", "servicesTok", " sUk", "SOrg", "suSk", "suIter", " sOrg"], "topSet": ["pperMap", "TOPSet", "TOPUnit", "pperHat", "topAdd", "topHat", "TopChan", "TopMap", "TOPAdd", "TopAdd", "topChan", "TopUnit", "TopSet", "topMap", "topUnit", " topMap", "pperSet", " topChan", " topUnit", "TOPChan", "TopHat", " topHat", " topAdd", "pperChan"], "leftSet": [" leftHat", "lawCollect", " leftUnit", "leftUnit", "rightKit", "lawSet", "controlHat", "leftKit", "lawBlock", "controlCollect", "leftBlock", " leftCollect", "smallUnit", "leftHat", "rightUnit", "leftCollect", "smallSet", "lawHat", "controlBlock", " leftKit", "smallKit", "controlSet", " leftBlock"], "rightSet": ["rightList", "rightsSet", " rightSource", "RightSet", "RightChain", "RightList", "rightsChain", "rightChain", "RightUnit", "rightsMap", "rightSource", "rightUnit", "RightSource", "RightMap", "RightGet", "rightsSource", " rightMap", " rightUnit", " rightList", "rightsUnit", " rightChain", "rightsGet", " rightGet", "rightMap", "rightGet", "rightsList"], "farRightSet": [" farRightUnit", "farCorrectChan", "farLeftList", "farRightset", " farLeftUnit", "farrightUnit", "farRightChan", "farLeftset", "farrightList", " farRightList", "farLeftChan", "farLeftUnit", "farLeftSet", " farRightChan", "farRightUnit", "farCorrectList", "farrightSet", "farCorrectSet", " farLeftSet", "farRightList", " farRightset", " farLeftList", "farCorrectset"], "vowelSet": ["vowelsList", "vowlSize", "voxelsList", "vowelsMap", "voxelList", "voulList", "voweleSet", "voxelsSet", "vowellSize", "vowelsSize", "vowlSet", "voxelsMap", "vowelList", "vouelSet", "voulSize", "vowelsSet", "vouelList", "voxelMap", "vowellList", "vouelSize", "voweleMap", "vowlList", "vowellMap", "vowelSize", "voxelSet", "voweleList", "vowelMap", "vowellSet", "voulSet"], "ntk": ["ontp", "ontik", "etwork", "antk", "otku", "LTuk", "octg", "octsk", "ntkg", "ontk", "ptks", "gtok", "rtK", "ptik", "settk", "netc", "ontks", "untch", "netok", "ntsk", "antik", "NTuk", "antkg", "antp", "ontr", "ontg", "etk", "ntg", "ntp", "ottwork", "antku", "LTk", "montk", "ntK", "ottk", "ntks", "ontwork", "antok", "ontku", "NTc", "untwork", "ontak", "netK", "ctsk", "netk", "ntok", "LTek", "rtok", "gtK", "antc", "ntke", "antK", "montsk", "gtk", "ontok", "ntuk", "etK", "notk", "ontc", "NTak", "untk", "settsk", "gtke", "LTok", "NTch", "ptK", "ontsk", "notsk", "octke", "ntr", "untok", "rtk", "ottok", "ptr", "ontkg", "ctke", "antwork", "notks", "montke", "ntik", "ntwork", "otp", "gtsk", "ontch", "ontK", "ntch", "notK", "NTwork", "ctk", "ntku", "montK", "otkg", "ptsk", "otk", "settke", "etok", "NTk", "NTok", "ptp", "ntc", "ntek", "gtc", "ntak", "ontke", "octk", "NTek", "settg", "ctK", "antr", "ptk", "NTK", "rtwork", "ottak"], "maxEwtsVowelLength": ["maxEwtsVowselLength", "maxEwtsVowetText", "maxEwtsVowelId", "maxEwtsVoyelLength", "maxEwtsVowelsId", "maxEwtsVowelingText", "maxEwtsVoyellId", "maxEwtsVowelingLen", "maxEwtsVowelingLength", "maxEwtsVowsetLen", "maxEwtsVoyellLength", "maxEwtsVowsetLength", "maxEwtsVowelsLength", "maxEwtsVoyelLen", "maxEwtsVowselNumber", "maxEwtsVowetNumber", "maxEwtsVowelLen", "maxEwtsVowsetNumber", "maxEwtsVowilLength", "maxEwtsVoyellLen", "maxEwtsVoyelType", "maxEwtsVowellLen", "maxEwtsVowselText", "maxEwtsVowelsLen", "maxEwtsVowellId", "maxEwtsVoyellType", "maxEwtsVowellText", "maxEwtsVowelText", "maxEwtsVowsetText", "maxEwtsVoyelId", "maxEwtsVowilLen", "maxEwtsVowetLength", "maxEwtsVowellLength", "maxEwtsVowetLen", "maxEwtsVowellNumber", "maxEwtsVowelsType", "maxEwtsVowelingNumber", "maxEwtsVowselLen", "maxEwtsVowellType", "maxEwtsVowilType", "maxEwtsVowelNumber", "maxEwtsVowelType", "maxEwtsVowilId"], "puncSet": ["pucGet", " puncset", "pummGet", "PuncSet", "PucNum", "puncGet", "puccSet", "puncNum", "pucNum", "pummset", "pucSet", "puncset", "PucSet", " puccset", " puccGet", "pascalList", "pascalNum", "PuncNum", "puccGet", " puccSet", "PucList", "pocSet", "pocList", "PuncList", "pascalSet", "pocNum", "pummSet", "puncList", "pucList", " puncGet", "puccset", "pucset"], "charSet": ["inchMap", "charList", "inchSet", "characterMap", "CharSet", "CharBlock", "charBlock", "inchLet", "charLet", "characterSet", " charBlock", "characterList", "charMap", "CharList", "characterLet", " charMap", " charList", " charLet", "characterBlock"], "tibSet": ["tobEn", "TobSet", "TibiSet", "tikSet", "tibiSet", "Tibiet", "tikset", "tilibet", "tobSet", "TibArray", "tobet", "tibArray", "tilibSet", "tikArray", "Tibset", "tibiet", "TibEn", "tibiset", "Tibiset", "Tobet", "Tibet", "tilibEn", "tivEn", "TibSet", "tibEn", "tiket", "TobEn", "tbiset", "tivSet", "tivet", "tibet", "TibiArray", "tbiSet", "tbiArray", "tbiet", "tibset", "tibiArray"], "sanskritStackSet": ["sanskriticalRootset", "sanskritRootSet", "sanskriticalStackset", "sanskritContextMap", "sanskritContextSet", "sanskritStackset", "sanskritHashset", "sanskritHashMap", "sanskritHashSet", "sanskriticalStackSet", "sanskritStackMap", "sanskriticalStackMap", "sanskritRootset", "sanskriticalRootMap", "sanskriticalRootSet", "sanskritRootMap", "sanskritContextset"]}}
{"id1": "18370075", "id2": "17111859", "code1": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 1, "substitutes": {"createPasswordDigest": ["createPassworddigester", "createPasswordSignest", "createpasswordDigester", "createPassworddigifier", "createpasswordDigenge", "createPasswordSignester", "createpassworddigenge", "createPasswordModifier", "createPassworddigest", "createPasswordModester", "createPasswordSignenge", "createpasswordDigifier", "createpasswordDigest", "createpassworddigester", "createPasswordModest", "createPasswordDigester", "createPasswordDigenge", "createPassworddigenge", "createpassworddigifier", "createPasswordDigifier", "createpassworddigest", "createPasswordModenge", "createPasswordSignifier"], "password": ["pass", "token", "username", "words", "seed", "sword", "string", "word", "secret", "Password", "PASS", "wallet", "path", "key", "auth", "pad", "email", "wd", "database", "user", "address", "command", "p", "phrase", "security", "config", "filename", "hash", "login", "data", "account", "message", "Pass", "pattern", "crypt", "text", "source", "name", "padding"], "salt": [" ssecret", "SALT", "pass", "ssecret", "psecret", "sesalt", "palt", "sessecret", "ssALT", "sesass", "sALT", " sass", "ssalt", "pALT", "Sass", "Ssecret", " sALT", "Salt", "sesALT", "sssecret", "ssass", "sass"], "md": ["mb", "mail", "pd", "ms", "pm", "od", "mand", "clean", "mac", "zip", "m", " MD", "d", "sha", "di", "MD", "bd", "meta", "ad", "dd", "ph", "mc", "ld", "cd", "mod", "cmd", "mn", "ma", "mag", "nd", "code", "ind", "gd", "dm", "nm", "amd", "kg", "mm", "metadata", "bf", "po", "message", "mad", "mt", "me", "mo"], "digest": ["decests", "hashcode", "hashest", "dested", " digests", "Digester", "Digested", "signest", " digEST", "digested", "digester", "dest", "decest", "DigEST", " digester", " digested", "digress", "generest", "signester", "hashester", "signcode", "generester", "digEST", " digcode", "generress", "digcode", "signested", "dester", "digests", "dEST", "hashested", "Digest", "decress", "decester", " digress", "generests"]}}
{"id1": "18374598", "id2": "732800", "code1": "    private synchronized File download() throws AMSpacksException {\n        String a = addr.url.toExternalForm();\n        int p = a.lastIndexOf('/');\n        if (p < 0) {\n            p = a.lastIndexOf('\\\\');\n        }\n        if (p < 0) {\n            a = \"\" + Math.random();\n        } else {\n            a = a.substring(p + 1);\n        }\n        File td = null;\n        try {\n            td = File.createTempFile(a, \"\").getParentFile();\n        } catch (IOException ex) {\n            td = new File(\".\");\n        }\n        File f = new File(td, a);\n        td.delete();\n        long total = addr.update.getSize();\n        int progress = 0;\n        try {\n            InputStream in = new BufferedInputStream(addr.url.openStream());\n            FileOutputStream out = new FileOutputStream(f);\n            byte[] buf = new byte[500];\n            int n;\n            long percentage = 0;\n            callback.updateProgress(percentage);\n            do {\n                n = in.read(buf);\n                if (n > 0) {\n                    out.write(buf, 0, n);\n                    progress += n;\n                    long tmpPercentage = progress * 100 / total;\n                    if (percentage != tmpPercentage) {\n                        percentage = tmpPercentage;\n                        callback.updateProgress(percentage);\n                    }\n                }\n            } while (n > 0);\n            in.close();\n            out.flush();\n            out.close();\n        } catch (Exception ex) {\n            f.delete();\n            throw new DownloadFailedException(\"Error downloading update.\", ex);\n        }\n        long size = f.length();\n        String checksum = CheckSumFinder.checkSum(f);\n        if (size == addr.update.getSize() && checksum.equalsIgnoreCase(addr.update.getChecksum())) return f; else {\n            f.delete();\n            throw new CheckSumMismathchException(\"Checksum mismatch: \" + addr.update.getChecksum() + \" expected but was \" + checksum);\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 0, "substitutes": {"download": ["pull", "external", "string", "copy", "open", "archive", "Download", "release", " Download", "install", "setup", "upload", "exec", "url", "get", "load", "loader", "dump", "filename", "transfer", "output", "diff", "data", "write", "update", "name", "file"], "a": ["an", "action", "fa", "aux", "u", "ua", "za", "c", "string", "m", "qa", "ca", "access", "asa", "oa", "area", "A", "input", "na", "da", "about", "as", "cha", "au", "api", "at", "aa", "wa", "sa", "la", "ppa", "ac", "ada", "ad", "aaa", "alpha", "audio", "l", "ha", "amp", "s", "base", "ea", "pa", "url", "addr", "ga", "aw", "ast", "ma", "array", "sta", "af", "e", "am", "i", "auto", "tta", "ae", "data", "r", "b", "t", "ba", "ata", "ab", "va", "name", "art", "file"], "p": ["ap", "ping", "dp", "ip", "u", "c", "pr", "pi", "py", "m", "y", "op", "o", "d", "pat", "after", "api", "np", "pp", "bp", "tp", "l", "part", "w", "pos", "pe", "cp", "pa", "j", "sp", "x", "e", "i", "pre", "q", "start", "h", "fp", "v", "P", "jp", "po", "b", "t"], "td": ["fa", "dc", "det", "txt", "fr", "pc", "pd", "fc", "od", "th", "pb", "dat", "table", "sf", "d", "dl", "aff", "fd", "bd", "pt", "TD", "rt", "cf", "ppa", "ht", "tr", "tn", "hd", "dd", "ld", "ff", "tf", "tif", "cd", "gb", "ud", "dh", "tmp", "dt", "sb", "nd", "af", "fm", "fp", "tl", "file", "elt", "sd", "b", "fb", "t", "lf", "tt", "rd", "buff", "bt", "db", "tc"], "f": ["fa", "df", "fe", "F", "fc", "u", "of", "function", "g", "c", "m", "full", "o", "sf", "d", "fo", "fx", "aff", "fast", "fd", "feed", "cf", "fam", "fold", "handler", "fn", "fs", "l", "ff", "tf", "fw", "base", "w", "j", "fi", "flat", "e", "fm", "i", "uf", "xf", "h", "fp", "fen", "v", "file", "fl", "r", "b", "fb", "t", "bf", "lf", "info", "buffer", "form", "fr", "rf"], "total": ["temp", "done", "local", "percent", "Total", "full", "otal", "current", "sum", "cost", "partial", "post", "doc", "active", "json", "length", "num", "count", "valid", "reported", "scale", "quant", "normal", "base", "all", "upload", "server", "max", "complete", "now", "serial", "set", "ok", "used", "start", "finished", "nt", "next", "error", "last", "info", "parent", "available", "recent"], "progress": ["rss", "resource", "Progress", "done", "status", "c", "current", "step", "rec", "dist", "path", "cost", "partial", "np", "process", "number", "skip", "active", "length", "summary", "num", "content", "conn", "roll", "count", "err", "grade", "resp", "running", "scale", "coll", "wait", "complete", "bar", "xp", "success", "next", "error", "vance", "width", "recent"], "in": ["In", "again", "c", "ini", "IN", "cin", "o", "din", "inner", "bin", "input", "as", "con", "io", "pin", "ins", "ac", "inn", "ie", "kin", "l", "isin", "init", "win", "lin", "url", "gin", "i", "nin", "socket", "v", "login", "reader", "data", "vin", "r", "b", "inc", "source", "stream"], "out": ["ch", "line", "again", "full", "c", "cache", "o", "ex", "call", "inner", "bin", "Out", "log", "io", "outs", "co", "ins", "conn", "fn", "err", "up", "w", "s", "exec", "url", "code", "off", "callback", "to", "extra", "cb", "v", "ext", "output", "error", "data", "obj", "b", "inc", "conf", "parent", "buffer", "update", "client", "file", "flow"], "buf": ["grab", "bh", "auc", "cv", "area", "bin", "box", "queue", "pad", "cf", "seq", "bp", "header", "loc", "br", "bag", "ff", "rc", "cmd", "tmp", "bc", "uno", "pkg", "uf", "cap", "callback", "uc", "bytes", "fp", "cb", "v", "border", "data", "raw", "feat", "Buff", "b", "fb", "buff", "ba", "bf", "buffer", "wb", "rb", "padding"], "n": ["nb", "nit", "not", "u", "N", "g", "m", "current", "c", "o", "d", "node", "dn", "np", "z", "none", "number", "nn", "network", "skip", "num", "length", "no", "nr", "min", "nor", "count", "fn", "br", "l", "ng", "net", "w", "pos", "cn", "j", "coll", "sn", "x", "non", "e", "len", "ns", "i", "rn", "ne", "v", "error", "r", "b", "en", "nc", "un"], "percentage": ["variity", "poundure", "latay", "Percentage", "variide", "metay", " percentages", "percentay", "Percentager", "percentile", "metages", "metage", "latide", "variage", "percentrage", "parage", "percentager", "percentity", "poundages", "latage", "Percenture", "compide", "pardages", "Percentages", "poundage", "metile", "pardure", "pardability", "metency", " percentile", "poundability", "pardage", "missay", "variile", "parages", "percentability", "voltage", "missile", "missrage", "Percentency", "compage", "metrage", "percenture", "percentages", "variay", "Percentability", "varirage", " percentency", "voltile", "percentide", "parile", "voltager", "percentency", "compity", "Percentile", "compay", "latity", "parager", "missage", "voltages"], "tmpPercentage": ["cppPercentrage", "tmppercentile", "tempPercentages", "tmpComple", "tmppercentay", "tmpPassrage", "cppPercentment", "tmpHalfency", "temppercentages", "tmpPassay", "tmpPercentile", "tmpPercentle", "tmppercentment", "cpppercentrage", "tmppercentages", "tmppercentency", "tmppercentrage", "temppercentle", "tmpPercentment", "tmpPassment", "tmpPassile", "ptypercentag", "cppPercentay", "tmppercentle", "tmpPercentency", "tmpPercentrage", "tmpPercentay", "ptypercentage", "tmpMagnment", "tmppercentag", "tmpHalfage", "temppercentency", "ptypercentency", "tmpCompages", "tmpPercentag", "tmpPassency", "ptyPercentage", "tmpCompency", "temppercentage", "tmpMagnrage", "cpppercentay", "ptyPercentency", "tempPercentency", "tmpPercentages", "ptypercentile", "tmpHalfag", "tmpPassage", "tempPercentle", "tmppercentage", "tmpMagnay", "tmpPassag", "tmpCompage", "cpppercentment", "tmpMagnage", "ptyPercentile", "tmpHalfile", "tempPercentage", "cpppercentage", "cppPercentage", "ptyPercentag"], "size": ["sized", "ize", "external", "fee", "send", "speed", "clean", "c", "capacity", "sum", "time", "empty", "length", "content", "address", "unit", "count", "loc", "SIZE", "grade", "scale", "rc", "small", "width", "sn", "max", "sec", "e", "code", "len", "i", "ne", "error", "Size", "data", "esc", "offset", "name", "core"], "checksum": ["timesig", " checksal", "checkme", " checksam", " checksig", "cksam", "cksums", "timessum", "getsumm", " checksme", "getssum", "checksums", "cksum", " Checksme", "timesum", " checkssum", "getsam", "checkum", " checksums", "cksumm", " checksumm", "checksumm", "timesums", " Checksal", "cksig", "checksig", "checksam", "checksal", "checkssum", " Checkssum", "checksme", "checkal", "ckssum", "getsum", " Checksum"]}}
{"id1": "22977189", "id2": "5414088", "code1": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"in": ["In", "pass", "plus", "again", "n", "g", "c", "IN", "ini", "cin", "is", "din", "inner", "bin", "input", "as", "con", "this", "ins", "min", "inn", "re", "er", "err", "up", "isin", "init", "win", "lin", "url", "gin", "read", "f", "inside", "i", "nin", "image", "socket", "login", "reader", "data", "r", "b", "inc", "id", "source", "ln"], "out": ["again", "ex", "call", "log", "w", "s", "prefix", "pool", "writer", "plain", "error", "write", "flush", "parent", "file", "flow", "cache", "o", "comment", "bin", "outer", "io", "this", "user", "connection", "init", "off", "password", "strip", "editor", "page", "output", "data", "OUT", "block", "at", "n", "word", "copy", "outs", "sync", "default", "part", "query", "f", "ext", "raw", "obj", "r", "client", "name", "temp", "window", "inner", "Out", "self", "as", "list", "key", "conn", "object", "err", "up", "app", "exec", "server", "a", "point", "b", "inc"], "line": ["inline", "entry", "row", "pass", "string", "c", "lines", "word", "LINE", "str", "character", "comment", "Line", "log", "feed", "char", "key", "content", "letter", "header", "unit", "cl", "l", "rule", "lin", "cell", "pe", "url", "sl", "f", "link", "code", "i", "value", "page", "next", "data", "write", "style", "id", "message", "lf", "source", "lock", "text", "block", "column", "name", "file", "lc", "end"]}}
{"id1": "15018553", "id2": "4716110", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"encrypt": ["encryption", "Encryption", "decryption", "secipher", "Encrypt", "deccrypt", "Encipher", "decrypt", "enccrypt", "secryption", "encipher", "Enccrypt", "decipher", "seccrypt", "secrypt"], "text": ["struct", "txt", "font", "class", "token", "seed", "Text", "string", "word", "method", "secret", "str", "input", "path", "sequence", "key", "hex", " Text", "number", "length", "content", "object", "address", "letter", "connection", "contract", "config", "code", "password", "image", "bytes", "TEXT", "transfer", "ext", "test", "output", "data", "message", "pattern", "binary", "buffer", "source", "name", "template"], "md": ["df", "mb", "mp", "mg", "pd", "ms", "cmp", "od", "pm", "mand", "cm", "mac", "Cmd", "m", "pg", "em", "sm", " MD", "rm", "d", "sha", "hm", "MD", "mk", "bd", "meta", "wd", "hd", "ad", "dd", "ld", "mc", "gb", "mod", "cmd", "mn", "dr", "mag", "ma", "pkg", "am", "dm", "hash", "amd", "data", "mi", "dig", "mm", "metadata", "message", "mt", "me", "db", "mo"], "md5hash": ["MD5hex", "md25sum", "md2sum", "MD5hash", " md5log", "md7block", " md4log", "md4block", " md4block", "md25log", "md2Hash", " md5block", "MD5key", "MD512hex", "md512key", "md256key", "md6log", " md5sum", " md4sum", " md4Hash", "md6hash", " md4hash", "md6sum", "md5Hash", "md4log", "md256hash", "md7sum", "md4sum", "md5sum", " md5Hash", "md5log", "md5block", "md7hash", "md512hash", "md25hash", "md7Hash", "md5key", "md4hash", "md25Hash", "md4Hash", "MD512hash", "md256hex", "md6key", "md512hex", "md6Hash", "md5hex", "MD512key", "md2block", "md6hex", "md2hash"]}}
{"id1": "3375718", "id2": "1235538", "code1": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 0, "substitutes": {"importarHistoricoDeCotacoesDoDolar": [" importarHistoricoDeCotacosDODi", " importarHistoricoDeCotacoesDomD", " importarHistoricoDeCotacosDoDo", " importarHistoricoDeCotacosDoD", " importarHistoricoDeCotacoesdod", " importarHistoricoDeCotacoesDOD", " importarHistoricoDeCotacoesDoDi", " importarHistoricoDeCotacosDODo", " importarHistoricoDeCotacoesDoDo", " importarHistoricoDeCotacoesDomDo", " importarHistoricoDeCotacosDOD", " importarHistoricoDeCotacoesdoDo", " importarHistoricoDeCotacoesdoD", " importarHistoricoDeCotacoesDOd", " importarHistoricoDeCotacoesdoDi", " importarHistoricoDeCotacoesDODi", " importarHistoricoDeCotacosDOd", " importarHistoricoDeCotacosDod", " importarHistoricoDeCotacosDoDi", " importarHistoricoDeCotacoesDomDi", " importarHistoricoDeCotacoesDoD", " importarHistoricoDeCotacoesDODo", " importarHistoricoDeCotacoesDod", " importarHistoricoDeCotacoesDomd"], "pAndamento": ["pAndamentano", "pAndagementO", "pNotimento", "pAndimenti", "pNotimenti", "pButmento", "pAndimento", " pAndamente", "pAndiationor", " pANDamentO", "pAndiationO", "pAndagemente", "pNotimentO", " pANDitecte", "pNotamento", "pButementi", " pAnditectado", "pAndiationi", "pButamente", "pButementano", "pAndeyi", " pAnditectO", "pAndmenti", " pAndmentado", "pButamentano", " pAndamentado", "pAndagementor", "pAndementi", "pButmente", "pAndemente", "pAndamentor", "pAndmente", "pAndmento", " pAnditecte", "pButmenti", " pAndmente", " pANDamentado", "pAndementano", "pNotimentor", " pANDamento", "pNotamentO", " pAnditecto", "pAndeyo", "pAndmentor", "pAndamente", "pButamento", " pAndmento", "pButemente", "pNotamentor", " pAndimentado", "pAndamenti", " pANDamente", "pAndimentO", " pANDitectO", "pAndemento", "pButamentor", "pAndimentano", "pNotamenti", " pAndimentO", " pANDitecto", "pButmentor", "pAndiationo", "pAndimentor", " pAndmentO", "pAndamentO", " pAndamentO", "pAndagementi", " pAndimente", "pAndeye", " pAndimento", "pAndagemento", "pAndimente", " pANDitectado", "pAndeyano", "pButamenti", "pButemento"], "cotacoesPendentesDoDolar": ["cotacoesPendentesDoDSolar", "cotacoesPendentesDODolic", "cotacoesPendentesDoDiSolar", "cotacoesPendentesDoVSolar", "cotacoesPendentesDODiolo", "cotacoesPendentesDoDoolar", "cotacoesPendentesDoVolar", "cotacoesPendentesDoDiolic", "cotacoesPendentesDoDoollar", "cotacoesPendentesDoDoSolar", "cotacoesPendentesDoPolic", "cotacoesPendentesDoFollar", "cotacoesPendentesdodolar", "cotacoesPendentesdodSolar", "cotacoesPendentesDODolo", "cotacoesPendentesDoDiocal", "cotacoesPendentesdoDSolar", "cotacoesPendentesDODiolic", "cotacoesPendentesDoTSolar", "cotacoesPendentesdoDollar", "cotacoesPendentesDOdolar", "cotacoesPendentesDoDolic", "cotacoesPendentesdoDiSolar", "cotacoesPendentesDoFolar", "cotacoesPendentesDOdollar", "cotacoesPendentesDoTolar", "cotacoesPendentesDodolo", "cotacoesPendentesDOdolo", "cotacoesPendentesdoSolar", "cotacoesPendentesDoTolo", "cotacoesPendentesDoSSolar", "cotacoesPendentesdodolate", "cotacoesPendentesdodollar", "cotacoesPendentesdoSollar", "cotacoesPendentesDoDiolar", "cotacoesPendentesDODollar", "cotacoesPendentesdoDiocal", "cotacoesPendentesDoPolo", "cotacoesPendentesDoDoolo", "cotacoesPendentesDoSolo", "cotacoesPendentesDoDiolo", "cotacoesPendentesDodolate", "cotacoesPendentesDODiolar", "cotacoesPendentesDoSollar", "cotacoesPendentesDoPolar", "cotacoesPendentesdoDiolar", "cotacoesPendentesDoSolar", "cotacoesPendentesDoDolate", "cotacoesPendentesDoDiolate", "cotacoesPendentesDOdSolar", "cotacoesPendentesDODSolar", "cotacoesPendentesDODolar", "cotacoesPendentesDoDollar", "cotacoesPendentesDoFSolar", "cotacoesPendentesdoSSolar", "cotacoesPendentesDoFocal", "cotacoesPendentesdoDiollar", "cotacoesPendentesDoDolo", "cotacoesPendentesDoTollar", "cotacoesPendentesDoPollar", "cotacoesPendentesDoDiollar", "cotacoesPendentesDodSolar", "cotacoesPendentesDodolar", "cotacoesPendentesDoDoolic", "cotacoesPendentesdoDolar", "cotacoesPendentesDoVolate", "cotacoesPendentesDodocal", "cotacoesPendentesDoDocal", "cotacoesPendentesdoDocal", "cotacoesPendentesdoDolate", "cotacoesPendentesdoDolo", "cotacoesPendentesDoVollar", "cotacoesPendentesDodollar", "cotacoesPendentesDODiollar", "cotacoesPendentesdoSolo"], "sql": ["il", "fr", "local", "seed", "zip", "string", "pr", "pg", "statement", "aws", "values", " SQL", "select", "str", "comment", "dl", "http", "expression", "utils", "spec", "orm", "log", "params", "api", "util", "sol", "details", "json", "rl", "database", "object", "spr", "insert", "dd", "lang", "l", "s", "csv", "base", "storage", "ls", "model", "shell", "query", "QL", "math", "where", "sl", "serial", "su", "nl", "el", "types", "fp", "expr", "repl", "ssl", "html", "data", "sg", "b", "ql", "parser", "es", "general", "mt", "lock", "SQL", "software", "db", "sq", "models"], "stmtDestino": ["stmbDestini", "stmtRestino", "stmDestro", "stmtDestorno", "stmtStini", "storDestinos", "stmtStino", "stmtStin", "stmtCombino", "stmtDestination", "stmbRestino", "stptDestro", "stmtDestin", "stmtStorno", "stmtStination", "stmtDestini", "stmdestino", "stmtDestinos", "stmDestINO", "stmtDistaco", "stmbRestini", "stmtDocining", "stmtOrdino", "storDestaco", "stordestino", "stmbDestorno", "storDestini", "stptdestinos", "stptDestinos", "stmtDistINO", "stptdestro", "stctDestining", "stctOrdination", "stmbDestINO", "stptdestINO", "stmtdestino", "stmbDestino", "stmDestino", "stmtdestro", "stmtOrdin", "stmtDestaco", "stmtStINO", "stmtCombinos", "stordestini", "stctOrdining", "stmtdestINO", "stctDestin", "stmbRestINO", "stmtDistinos", "stmtCombaco", "stmtOrdining", "stptDestINO", "stctDestination", "stmbRestorno", "stmdestinos", "stmtOrdination", "storDestino", "stmtdestaco", "stmtDocination", "stmtdestorno", "stmtRestorno", "stptDestino", "stmtDestINO", "stmdestro", "stmdestINO", "stctOrdino", "stctOrdin", "stmtRestini", "stmtDestro", "stmtRestro", "stptdestino", "stmtdestinos", "stmtCombini", "stmtDestining", "stctDestino", "stmtDistini", "stmtdestini", "stordestinos", "stmtDocin", "stmtDocino", "stmDestinos", "stmtDistro", "stmtRestinos", "stmtStining", "stordestaco", "stmtDistino", "stmtRestINO"], "quantidadeDeRegistrosASeremImportados": ["quantidadeDeRegistrosSeremsPortadas", "quantidadeDeRegistrosSeremsPortados", "quantidadeDeRegistrosSeremimportada", "quantidadeDeRegistrosSeremsImportadas", "quantidadeDeRegistrosSeremortada", "quantidadeDeRegistrosSeremPortada", "quantidadeDeRegistrosSeremsPortado", "quantidadeDeRegistrosSeremImportados", "quantidadeDeRegistrosSeremPortadas", "quantidadeDeRegistrosSeremImportado", "quantidadeDeRegistrosSeremPortados", "quantidadeDeRegistrosSeremImportada", "quantidadeDeRegistrosSeremsPortada", "quantidadeDeRegistrosSeremsImportados", "quantidadeDeRegistrosSeremortados", "quantidadeDeRegistrosSeremImportadas", "quantidadeDeRegistrosSeremimportadas", "quantidadeDeRegistrosSeremsImportada", "quantidadeDeRegistrosSeremsImportado", "quantidadeDeRegistrosSeremortado", "quantidadeDeRegistrosSeremimportados", "quantidadeDeRegistrosSeremortadas", "quantidadeDeRegistrosSeremimportado", "quantidadeDeRegistrosSeremPortado"], "quantidadeDeRegistrosImportados": ["quantidadeDeRegistronsOperants", "quantidadeDeRegistronsImportos", "quantidadeDeRegistrosInstants", "quantidadeDeRegistronsImportados", "quantidadeDeRegistrosOperadas", "quantidadeDeRegistrosImados", "quantidadeDeRegistronsOperados", "quantidadeDeRegistrosImadas", "quantidadeDeRegistronsOperos", "quantidadeDeRegistrosOperants", "quantidadeDeRegistrosImportants", "quantidadeDeRegistronsImportadas", "quantidadeDeRegistronsOperadas", "quantidadeDeRegistrosInstados", "quantidadeDeRegistrosImos", "quantidadeDeRegistronsImportants", "quantidadeDeRegistrosImants", "quantidadeDeRegistrosInstos", "quantidadeDeRegistrosInstadas", "quantidadeDeRegistrosImportadas", "quantidadeDeRegistrosImportos", "quantidadeDeRegistrosOperados", "quantidadeDeRegistrosOperos"], "numeroDoRegistro": ["numeroDoRegastros", "numeroDoRegastr", "numeroDoRegestro", "numeroDoRegistsros", "numeroDoRegistsrar", "numeroDoregastron", "numeroDoRegostr", "numeroDoRegostron", "numeroDoregastro", "numeroDoregastros", "numeroDoRegostro", "numeroDoTagistros", "numeroDoRegistsro", "numeroDoRegestrar", "numeroDoRegistrar", "numeroDoRegisterrob", "numeroDoRegestros", "numeroDoRegistsrob", "numeroDoRegistron", "numeroDoRegistrob", "numeroDoregastr", "numeroDoRegestrob", "numeroDoRegisterrar", "numeroDoTagistro", "numeroDoregistros", "numeroDoregistron", "numeroDoRegistr", "numeroDoRegistros", "numeroDoRegisterros", "numeroDoRegestr", "numeroDoRegastron", "numeroDoRegastro", "numeroDoTagistsro", "numeroDoTagistsros", "numeroDoRegostros", "numeroDoregistro", "numeroDoTagistrar", "numeroDoRegestron", "numeroDoTagistsrar", "numeroDoRegisterro", "numeroDoTagistsrob", "numeroDoregistr", "numeroDoTagistrob"], "cotacaoPendenteDoDolar": ["cotacaoPendenteDoTolic", "cotacaoPendenteDOSSolar", "cotacaoPendenteDoSIR", "cotacaoPendentePiDollar", "cotacaoPendenteDoSSolar", "cotacaoPendentePidolic", "cotacaoPendentePidolar", "cotacaoPendenteDoLiscal", "cotacaoPendenteDodolic", "cotacaoPendenteDoTolar", "cotacaoPendenteDoDollar", "cotacaoPendenteDoDSolar", "cotacaoPendenteDoMollar", "cotacaoPendenteDoDublic", "cotacaoPendentePiDolar", "cotacaoPendenteDoPolic", "cotacaoPendenteDoPollar", "cotacaoPendentePidollar", "cotacaoPendenteDoPolo", "cotacaoPendenteDoMolar", "cotacaoPendenteDODSolar", "cotacaoPendenteDoDolic", "cotacaoPendenteMoDolo", "cotacaoPendenteDOSolar", "cotacaoPendenteDodolan", "cotacaoPendenteDoIolar", "cotacaoPendenteDoMolic", "cotacaoPendenteDoIolo", "cotacaoPendenteDOSublic", "cotacaoPendenteDoISolar", "cotacaoPendenteDoSolic", "cotacaoPendenteDoIublic", "cotacaoPendenteDodiscal", "cotacaoPendenteDoSiscal", "cotacaoPendenteMoSollar", "cotacaoPendenteDodolo", "cotacaoPendenteDoPolar", "cotacaoPendenteDoTolan", "cotacaoPendenteDoCollar", "cotacaoPendenteDODublic", "cotacaoPendenteDoDolo", "cotacaoPendentePidolan", "cotacaoPendenteMoDolic", "cotacaoPendenteDoLollar", "cotacaoPendentePiDolic", "cotacaoPendenteMoDollar", "cotacaoPendenteDODolo", "cotacaoPendenteDoLolar", "cotacaoPendenteDoSolar", "cotacaoPendenteMoSIR", "cotacaoPendenteDOSolo", "cotacaoPendenteMoDIR", "cotacaoPendenteDoTollar", "cotacaoPendenteDoCIR", "cotacaoPendenteDoSolo", "cotacaoPendenteDoLolo", "cotacaoPendenteMoSiscal", "cotacaoPendenteDoTSolar", "cotacaoPendenteMoDSolar", "cotacaoPendenteMoSolic", "cotacaoPendenteMoSolo", "cotacaoPendentePiDolan", "cotacaoPendenteMoDiscal", "cotacaoPendenteDoSublic", "cotacaoPendenteDoColar", "cotacaoPendenteDodollar", "cotacaoPendenteDoDIR", "cotacaoPendenteMoSolar", "cotacaoPendenteDoPSolar", "cotacaoPendenteMoDolar", "cotacaoPendenteDoPublic", "cotacaoPendenteDoDiscal", "cotacaoPendenteDodolar", "cotacaoPendenteDoSollar", "cotacaoPendenteDoTIR", "cotacaoPendenteMoSSolar", "cotacaoPendenteDODolar", "cotacaoPendenteDoCSolar", "cotacaoPendenteDoMolan", "cotacaoPendenteDoDolan"], "ano": ["ane", "oshi", "aro", "ilo", "ao", "aldo", "ko", "alia", "obo", "oa", "aho", "ato", "ago", "osa", "ono", "ardo", "asio", "iso", "illo", "office", "uno", "zo", "oda", "amo", "anto", "auto", "iana", "anos", "umo", "ara", "lo", "uto", "rio", "ana", "mi", "oni", "rano", "erno", "amia", "ania", "antis", "lio", "ado"], "mes": ["ms", "Ms", "ses", "mins", "ME", "ens", "mx", "mos", "ims", "mus", "mers", "ails", "mor", "ems", "mol", "la", "ums", "mer", "mr", "lia", "mc", "nos", "pins", "ls", "los", "mot", "ma", "sem", "des", "MS", "mie", "mis", "ae", "lis", "mi", "mails", "nis", "nas", "nes", "las", "es", "les", "me", "phis"], "dia": [" dica", "dIA", "dsIA", "dria", "Dias", "Dia", "DIA", "nd\u00eda", "dsica", " d\u00eda", "ndica", "D\u00eda", "dsria", "ndias", "dsia", " dria", "ndia", "Dria", "dias", " dias", " dIA", "Dica", "dica", "d\u00eda"], "calendario": ["palendierra", "calendiry", "Calendasio", "palendar", "calENDarius", "calENDario", "calendedillo", " recalentario", "calendaro", "calENDaro", "caladario", "calmentado", "calendingillo", "calentiry", "Caladarius", "calenar", "palenario", "Calendedaro", "calENDasio", "calendingado", "calendingarius", "calenario", "calandar", "Calendedillo", " recalentri", "calendarius", "calentri", "calendasio", "Calendario", "calendingaro", "caladiry", "calpendario", "calendierra", "Calendedario", " recalendazon", "Calendillo", "calandario", "caladasio", "calentado", "calandasio", "calenasio", "calendedario", "calmentri", "Calendedarius", "calENDillo", "calmentario", " recalendado", "palendasio", "calpendiry", "calENDierra", "calandierra", "calendar", " recalentazon", "calendingario", "calendedaro", " recalentado", "Calendiry", "Caladasio", " recalendri", "calentasio", "calentazon", "calpendasio", "calpendarius", "palenasio", "calendado", "calendillo", "calendingri", "palendario", "calendri", "calmentazon", "Calendaro", "palenierra", "calendedarius", "Caladario", "calendazon", " recalendario", "Caladiry", "caladarius", "palenar", "calenierra", "calentario", "Calendarius", "calendingazon", "calENDar", "calentarius"], "vDATA": ["VATA", "hDATA", "Vdata", "VData", "vdata", " vData", " vdata", " vATA", "VDATA", "vData", "hdata", "hATA", "jDEF", "hData", "vDEF", "jData", "jDATA", "vATA", "VDEF", "jATA", " vDEF"], "vPRECO": ["fPreCON", "vPREDO", "vPDO", "vPRECo", "fPRECON", "fPRECo", "vPACO", "fPreCo", "fPRECO", "vPreDO", "fPREDO", "vPreCO", "vPADO", "fPreDO", "vPCo", "vPreCON", "vPCO", "vPACo", "fPreCO", "vPRECON", "vPACON", "vPCON", "vPreCo"]}}
{"id1": "7425022", "id2": "11334468", "code1": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"transferWSDL": ["transferWDDL", "transferWSDl", "transferWsdl", "transferWsdL", "transferWsdLS", "transferSWsdDL", "transferWSDLS", "transferWNDLS", "transferWDDLS", "transferWDDl", "transferWDDDL", "transferWSDDL", "transferSWsdL", "transferWNDDL", "transferSWSDLS", "transferWNDL", "transferSWsdLS", "transferWNDl", "transferSWsdl", "transferWsdDL", "transferSWSDL", "transferSWSDDL", "transferSWSDl"], "wsdlURL": ["wllPath", "wsdlPath", "wsdnPath", "wsdnFILE", "wsllPath", "wssdUrl", "wssdFILE", "wdlPath", "wslURL", "wsdlURI", "wdlUrl", "wsdlFILE", "wslUrl", "wsdnURL", "wslPath", "wsllURL", "wsdalURI", "wdlFILE", "wsdlUrl", "wsslURI", "wdlURL", "wsslUrl", "wsllUrl", "wslURI", "wllURL", "wsllFILE", "wssdPath", "wsllURI", "wllFILE", "wsdnUrl", "wsslURL", "wssdURL", "wsdalUrl", "wdlURI", "wllUrl", "wsslPath", "wsdalURL", "wsdalPath"], "userPassword": ["userPass", " userAuth", " userData", "userName", " userPass", "usePassword", "UserPass", "usepassword", " userpassword", "UserData", "userAuth", "usePass", "userData", "UserName", "userpassword", "UserAuth", "userWord", "useData", " userWord", "USERPassword", "Userpassword", "UserPassword", "USERWord", "USERpassword", "UserWord", "useAuth", " userName", "USERName"], "filePath": ["filepath", "transferStr", "fileLocation", "FileStr", "Filepath", " fileStr", "FilePath", "transferPath", "transferpath", " fileLocation", "fileStr", "FileLocation", " filepath", "transferLocation"], "endpoint": ["Endpoints", "adpoint", "Endwall", "adpoints", "endwall", "EndPoint", " endwall", "adwall", " endpoints", "Endpoint", "endpoints", " endPoint", "endPoint", "adPoint"], "conn": ["dc", "ch", "pc", "cm", "n", "c", "Connection", "g", "pg", "ca", "act", "col", "ob", "oa", "inner", "Conn", "ann", "oss", "conv", "ci", "dn", "ctx", "con", "open", "co", "sync", "Connect", "cf", "ct", "auth", "client", "ac", "impl", "sql", "fn", "loc", "p", "adj", "connection", "w", "init", "part", "cn", "rc", "cp", "dh", "exec", "coll", "url", "reg", "ws", "enc", "cli", "ns", "Con", "pub", "h", "close", "cb", "socket", "ssl", "nt", "mc", "comm", "en", "conf", "nc", "ec", "connect", "org"], "is": ["ib", "hi", "serv", "im", "ois", "isl", "est", "rest", "irc", "has", " IS", "sc", "IS", "sr", "ism", "p", "fs", "s", "out", "iss", "iet", "isi", "lis", "ai", "es", "or", "js", "ios", "was", "io", "ais", "ar", "x", "isc", "ps", "iv", "stream", "rx", "ris", "ss", "il", "us", "act", "ir", "os", "ins", "ie", "Is", "ops", "its", "ws", "index", "any", "h", "res", "r", "src", "mes", "rss", "isp", "si", "ip", "as", "in", "ri", "oc", "it", "ipp", "iso", "sec", "i", "bis", "mis", "info", "rs"], "isr": ["isp", "ISr", "isl", "ssp", " isp", " isl", "isrb", "iscp", "ISp", "isw", "iscrb", "issrb", "ISw", "ssrb", "iscrs", "issl", "isrs", "issrs", "ssrs", "iscr", "issr", "issp", " isw", "ISl", "issw", "ssr"], "sw": ["rss", "wrap", "hi", "wh", "wt", "war", "sh", "so", "im", "nw", "wo", "pg", "sm", "sf", "xml", "iw", "tw", "wx", "was", "response", "sc", "wa", "Sw", "ew", "ww", "wp", "cr", "w", "rew", "aw", "x", "wra", "ws", "sl", "SW", "eng", "hw", "rw", "su", "sem", "sb", "wr", "sv", "r", "rx", "wl", "hop", "stream", "wb", "ow"], "buf": ["brace", "bh", "vec", "cas", "shift", "str", "cv", "bin", "func", "bd", "feed", "text", "box", "char", "la", "pad", "seq", "batch", "br", "cr", "bag", "ff", "ha", "err", "base", "rc", "cur", "bc", "Buffer", "pool", "block", "len", "uf", "uc", "bytes", "cb", "bb", "data", "raw", "b", "fb", "buff", "prop", "rx", "buffer", "wb", "rb"], "read": ["reads", "pass", "run", "use", "send", "n", "k", " write", "g", "reading", "select", "sleep", "old", "input", "READ", "copy", "log", "open", "feed", "add", "sync", "need", "skip", "in", "num", "length", "boot", "child", "count", "play", "Read", "default", "w", "find", "get", "load", "work", "wait", "size", "max", "f", "index", "iter", "i", "ok", "check", "start", "ride", "connect", "se", "reader", "parse", "write", "raw", "data", "r", "en", "buffer", "stream", "text", "block", "end"], "outputDir": ["outFolder", "outDirectory", "inputFile", "inputDirectory", "outputFile", "outDir", "OutputFile", " outputFolder", "OutputFolder", "outputPath", "OutputDir", " outputDirectory", "outputFolder", "OutputDirectory", "inputFolder", "outputDirectory", " outputPath", "inputDir", " outputFile", "OutputPath", "tmpDir", "tmpDirectory", "outFile", "tmpPath", "tmpFolder"], "file": ["File", "resource", "folder", "local", "line", "function", "full", "zip", "le", "log", "path", "feed", "files", "object", "content", "dir", "letter", "handler", "build", "unit", "store", "up", "base", "out", "future", "url", "work", "f", "FILE", "filename", "writer", "fp", "output", "directory", "data", "b", "message", "info", "buffer", "stream", "ile", "lock", "parent", "name", "db"], "fos": ["FOs", " fOS", "infos", "faos", "infOs", "f\n", "t\n", " f\n", "fOS", "infOS", "infaos", "F\n", "Fos", " faos", "FOS", "Faos", "fOs", " fOs"]}}
{"id1": "20929570", "id2": "23517481", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"toMd5": ["toBd512", "toMcd7", "toMm7", "toBd5", "toMmd15", "toBd7", "toMm15", "toMm5", "toMmd7", "toMmd5", "toMcd5", "toBmd15", "toMd512", "toMcd512", "toMd7", "toBmd7", "toMd15", "toMm512", "toBmd5", "toMmd512", "toBd15", "toMcd15", "toBmd512"], "str": ["txt", "temp", "fr", "pass", "stri", "kr", "string", "exp", "input", "msg", "char", "sr", "in", "STR", "tr", "conn", "err", "br", "s", "out", "arr", "url", "sp", "dr", "sec", "enc", "f", "e", "bytes", "result", "st", "data", "obj", "r", "b", "buffer", "Str", "text", "source", "name"], "messageDigest": ["messageDest", "messageDester", "messageDefest", "messageDigse", "messagedigest", " messageDEST", "messageHashester", "moredigester", "messageDigEST", "moreDigeter", "messageDefested", "MessageDigher", "Messagedigester", "moreDigester", "messageMixested", "MessagedigEST", "messageDEST", "MessageDigested", "messageUploadested", "Messagedigested", "messageDetter", "moreDigested", "Messagedigest", "MessageMarketter", " messageDigEST", "messageDefester", "messageHasheter", "messageDuster", "messagediguster", "MessageDigEST", "messageGEST", " messageDuster", "MessageMarkester", "messageMixester", "messageDigested", "messageHashest", "messageDiguster", "messagedigher", "messageDigetter", "messageGest", "MessageDigetter", "messagedigetter", "messageGester", "MessageMarkest", "messageDigher", "MessageDigse", "messagedigeter", " messageDiguster", "messageDeter", "messagedigested", "MessageDigester", "messagedigester", "messageDigeter", "messageMixest", " messageDest", "moredigested", "messageDested", " messageDester", "messageMarkest", "messageDefse", "messageMixse", "MessageDefse", "messageHashested", "moredigest", "MessageMarkher", "moredigeter", "messageGuster", "moreDigest", "messageMarkester", "MessageDefest", " messageDigester", "messageDigester", "MessageDefested", "messagedigEST", "messageUploadEST", "messageDher", "messageMarkher", "messageMarketter", "MessageDigest", "messageDse", "messageUploadest", "messageUploadester", "MessageDefester"], "byteArray": [" byteOrder", "ByteArray", "charAddress", "bitObject", "bitLength", " byteLength", " byteAddress", "resourceLength", "pixelBuffer", "doubleBuffer", "byteOrder", " bytearray", "wordArray", "byteAddress", "ByteLength", "pixelObject", "charNumber", " byteIndex", "charBuffer", "resourceIndex", "ByteNumber", "doubleArray", "bitarray", "byteNumber", " byteBuffer", "wordString", "bytearray", "pixelLength", "bitIndex", "resourceArray", "wordBuffer", "wordarray", "doubleString", "byteAmount", " byteString", "bitBuffer", "pixelArray", "byteBuffer", "charObject", "charLength", " byteNumber", " byteAmount", "resourcearray", "ByteAmount", "doublearray", "charArray", "ByteOrder", "byteString", "bitArray", "charAmount", "byteLength", "charOrder", "byteObject", "ByteBuffer", "byteIndex", "ByteAddress"], "md5StrBuff": ["md2StringRest", "md5strApp", "md2StrRest", "md2StringBuff", "md2StrBuff", "md6Strbuff", "md5TrBuffer", "md6strBuff", "md5TrText", "md2StringBuffer", "md5Stringbuff", "md2StringComp", "md6StrBuff", "md5Strbuff", "md5StringComp", "md5StrApp", "md6strbuff", "md2StringApp", "md2StrText", "md5StringBuffer", "md5StrDb", "md5TrDb", "md6StrBuffer", "md5StrComp", "md2StrComp", "md5Trbuff", "md6StrText", "md5StDb", "md6strText", "md5StringRest", "md5StringApp", "md2StrRef", "md5StringRef", "md5strText", "md5StringText", "md5StApp", "md5StBuffer", "md5strBuff", "md5StrRest", "md5TrRef", "md5strbuff", "md5StringBuff", "md5StText", "md6strBuffer", "md5StringDb", "md5TrBuff", "md5STRComp", "md5StRef", "md5StrRef", "md5StBuff", "md5STRBuffer", "md2StrBuffer", "md2StrApp", "md2StringText", "md5StComp", "md2StrDb", "md2StringRef", "md5strBuffer", "md5StrText", "md5STRRest", "md5StRest", "md2StringDb", "md5STRBuff", "md5StrBuffer"], "i": ["iu", "si", "qi", "ip", "u", "multi", "k", "ii", "c", "n", "pi", "o", "y", "d", "inner", "abi", "ci", "di", "io", "slice", "ji", "ui", "in", "ri", "length", "bi", "ie", "p", "it", "l", "part", "phi", "j", "I", "fi", "x", "index", "f", "field", "e", "oi", "li", "h", "v", "gi", "ti", "ai", "b", "xi", "id", "info", "uri", "ix", "mu", "name", "lc"]}}
{"id1": "8328527", "id2": "13657103", "code1": "    public void insertJobLog(String userId, String[] checkId, String checkType, String objType) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preStm = null;\n        String sql = \"insert into COFFICE_JOBLOG_CHECKAUTH (USER_ID,CHECK_ID,CHECK_TYPE,OBJ_TYPE) values (?,?,?,?)\";\n        String cleanSql = \"delete from COFFICE_JOBLOG_CHECKAUTH where \" + \"user_id = '\" + userId + \"' and check_type = '\" + checkType + \"' and obj_type = '\" + objType + \"'\";\n        try {\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            preStm = connection.prepareStatement(cleanSql);\n            int dCount = preStm.executeUpdate();\n            String sHaveIns = \",\";\n            preStm = connection.prepareStatement(sql);\n            for (int j = 0; j < checkId.length; j++) {\n                if (sHaveIns.indexOf(\",\" + checkId[j] + \",\") < 0) {\n                    preStm.setInt(1, Integer.parseInt(userId));\n                    preStm.setInt(2, Integer.parseInt(checkId[j]));\n                    preStm.setInt(3, Integer.parseInt(checkType));\n                    preStm.setInt(4, Integer.parseInt(objType));\n                    preStm.executeUpdate();\n                    sHaveIns += checkId[j] + \",\";\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            log.debug((new Date().toString()) + \" \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0228\ufffd\ufffd\u02a7\ufffd\ufffd! \");\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n                throw e;\n            }\n            throw ex;\n        } finally {\n            close(null, null, preStm, connection, dbo);\n        }\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 0, "substitutes": {"insertJobLog": ["insertJobHistory", "createjobEntry", "insertWorkEntry", "insertjoblog", "createJobLog", "insertJoblog", "createjobHistory", "insertjobEntry", "insertJLog", "insertWorkLog", "insertWorkHistory", "createJobEntry", "insertJHistory", "createjoblog", "createjobLog", "createJoblog", "insertjobHistory", "insertWorklog", "createJobHistory", "insertJobEntry", "insertjobLog", "insertJEntry", "insertJlog"], "userId": ["useName", " userData", "USERID", "userName", "customID", " userID", " userDb", "UserData", "userType", "customId", "useId", "USERId", "customData", "UserID", "UserId", "userData", "UserName", "customDb", "useType", "userID", "UserDb", "useID", " userType", "UserType", "userDb", "USERName"], "checkId": ["jobPath", "checkID", " checkPoint", "CheckInt", "pullID", "workerID", "CheckType", "pullType", "updatePoint", "workPoint", " checkPath", "userPoint", "jobID", "jobId", "workerInt", "jobPoint", "updateID", "pullPoint", "workType", " checkInt", "userID", "checkPath", "checkInt", "checkPoint", "workId", "updateId", "updateInt", "pullInt", "userInt", "workerId", "workID", "CheckPoint", "CheckPath", " checkID", "CheckId", "CheckID", "pullId"], "checkType": ["taskID", "CheckTypes", "checkID", "workInfo", " checkLength", "taskInfo", "CHECKType", "CHECKID", "checkTyp", " checkTyp", "blockId", "CheckType", "CHECKRole", "checkInfo", "blockTypes", " checkInfo", "blockLength", "CheckRole", "CheckLength", "taskId", " checkTypes", "checkLength", "checkRole", "CheckTyp", "workType", "CHECKTyp", "workId", "checkTypes", "blockType", "workID", " checkID", "CheckId", "CheckID", "taskType", " checkRole"], "objType": ["objectType", "opName", "ObjType", "objTyp", "checkTyp", "objectName", "ObjTypes", "ObjId", "objectTypes", " objName", "objectTyp", "opId", "checkName", "objName", "objectTy", "objTypes", "ObjTyp", "ObjTy", "objTy", "ObjName", "opType", " objId", " objTy", "objectId", "objId", "opTypes"], "dbo": ["dbu", "jBo", "Dbl", "jbu", "drBO", "DBO", "dbm", " dBo", "Dbu", "jbo", "mBo", "DBo", "Dbo", "Dbf", " dbl", "dbf", "dBo", " dBO", "dbl", "adbo", "adBo", "drbl", "drko", "mbu", "drBo", "jbf", "dko", "mbf", "mbo", " dko", "drbo", "Dko", "adBO", "drbm", "Dbm", " dbm", "dBO", "adbm"], "connection": ["resource", "application", "subject", "section", " Connection", "function", "position", "c", "Connection", "current", "statement", "context", "channel", "union", "management", "cache", "service", "condition", "response", "log", "ci", "con", "ctx", "ion", "BC", "manager", "io", "engine", "driver", "database", "relation", "conn", "unit", "loc", "mc", "document", "communication", "server", "query", "config", "bc", "index", "pool", "session", "graph", "connect", "socket", "directory", "b", "connected", "message", "lock", "client", "collection", "db"], "preStm": ["PREEstm", "preStreamM", "preStf", "preScv", "synStd", "PRERestmn", "prestfm", "synStM", "preStv", "preRmn", "PRERestfm", "PREEstms", "preDismr", " preRmd", "preEstms", "preSTmd", "preStmt", " preStvm", "prDismr", "preShmr", "cleanClmn", "cleanStm", "preStrm", "preConstm", " preShms", "preDisf", "preStreamvm", "preStam", "preStmr", "preStmn", "preClv", " preShf", "preTrmn", "prestmr", " preStmn", "preStM", "preStpm", "preSlm", "prestf", "preRestM", " preStmt", "PREStms", "preShv", "PRERestmt", "prStm", "preColmn", "PREStm", "preRestm", " preTrm", "prStmr", "PREStfm", "preScm", "PREStmn", "preSlmt", " preStma", "preSlam", "preInstvm", "prStf", " preStM", "preRm", "preRrm", "preShf", " preShv", " preShvm", "preRestd", "preConstmn", "preEstM", " preStfm", "prestm", "preStfm", " preRms", "synStm", "preDispm", "preShM", "preSlma", "preEdfm", "preStvm", "preStrms", "synEstd", "preInstm", "preRestfm", " preStam", "PREStM", " preTram", "cleanClm", "preStma", "preEstm", "preEstd", "preRestmt", " preTrmn", "preShma", "preClm", "synEstm", "preEdms", "preStmd", "cleanClv", "cleanStmn", " preScfm", "preClmn", "preShmt", " preScms", "prDism", "PRERestm", "prStpm", "prestvm", "preStd", "preSlmn", " preStrm", " preScvm", "preShpm", " preRrm", "preRv", "preStreamm", " preStf", "preRms", "synEstms", "preStrM", "preSlfm", "preColv", "preShms", "preEstmt", "preInstms", "preShm", " preTrmt", "cleanStM", "preEstvm", "preEdmn", "preStreamms", "PREEstmt", "preRestms", "preColm", "preTram", " preStv", "preSlv", "preTrmt", "preEdm", "preScf", "prDisf", "preSTm", "synStms", "synEstM", "preSTrm", "preStrd", "preClM", " preShM", " preStmd", " preScm", "preSlf", " preShm", "preStms", "preRM", "preSTms", " preShma", "prestpm", "preConstmt", "preEdrm", "PREEstM", "preRmd", "preEdmd", "cleanClM", " preStms", "cleanStv", "preScvm", " preRm", "PREStmt", "preTrm", "preDism", "prDispm", "preColM", "preScfm", "preScma", "preRestmn", "preInstfm", "preShvm", "preConstam", "preScms", "prestms", "preEdmt"], "sql": ["body", "seed", "function", "zip", "string", "join", "statement", "pg", "select", "str", "eps", "dl", "limit", "msg", "log", "params", "sol", "sync", "database", "printf", "conn", "fn", "l", "ls", "shell", "query", "sn", "url", "where", "sl", "nl", "q", "plan", "expr", "html", "ssl", "ql", "job", "SQL", "db", "sq"], "cleanSql": ["cleanAsql", "cleanSQL", " cleanAsq", "cleanSprintf", " cleanCwl", "cleanSsql", "cleanPsprintf", "cleanAssql", "cleanPssql", "cleanSq", "cleanAsprintf", " cleanAsprintf", "cleanCql", " cleanSwl", "cleanEsql", "cleanAswl", "cleanCsql", "cleanAsq", "cleanStwl", "cleanPsql", "cleanPsq", "cleanStsql", "cleanSwl", " cleanSQL", " cleanSprintf", " cleanSsql", " cleanCsql", "cleanAsQL", "cleanEsq", "cleanStQL", "cleanEsprintf", " cleanAsql", "cleanCwl", " cleanCql", "cleanStql", " cleanAssql", " cleanSq", " cleanCQL", "cleanEssql", "cleanCQL"], "dCount": ["dNumber", "dcount", "DCount", " dcount", " dNumber", "dCounter", "dhNumber", "dhCounter", "DCounter", "dhCount", "dhcount", "DNumber", " dCounter", "Dcount"], "sHaveIns": ["sWithNoINS", "sHavingINS", "sHadins", " shaveIn", " shaveins", "sWithNoins", "pHaveins", "sHaveWs", "phaveIns", " sHaveIn", "sHavingWs", "sHasContents", "shaveIn", "sHadIn", "sHaveins", "phaveINS", " sWithNoIns", "sWithNoContents", " sWithNoINS", "shaveWs", "sHaveINS", "pHaveIns", "sHaveIn", "sHasINS", "sAreContents", "sHavingins", "sHadIns", "sAreINS", "pHaveINS", "shaveins", " sHaveINS", "sHavingIns", "sWithNoIns", "pHaveWs", "sHasIns", "sWithNoIn", "sAreins", " sHaveins", " sWithNoContents", " sHaveContents", " shaveIns", "sHaveContents", "sAreWs", "phaveins", "shaveINS", "phaveWs", "sAreIns", "shaveIns"], "j": ["jet", "ch", "fr", "js", "oj", "section", "u", "k", "n", "g", "pr", "kj", "jl", "y", "dj", "vol", "J", "z", "jo", "key", "ji", "jj", "num", "jit", "ie", "p", "br", "uj", "adj", "l", "part", "x", "syn", "f", "i", "li", "ind", "el", "ja", "journal", "h", "off", "v", "jp", "bj", "obj", "b", "job", "jc", "lock", "aj", "ij"]}}
{"id1": "1698200", "id2": "13981689", "code1": "    public static void loginBitShare() throws Exception {\n        HttpParams params = new BasicHttpParams();\n        params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\");\n        DefaultHttpClient httpclient = new DefaultHttpClient(params);\n        System.out.println(\"Trying to log in to bitshare.com\");\n        HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\");\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\"));\n        formparams.add(new BasicNameValuePair(\"password\", \"\"));\n        formparams.add(new BasicNameValuePair(\"submit\", \"Login\"));\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\");\n        httppost.setEntity(entity);\n        HttpResponse httpresponse = httpclient.execute(httppost);\n        Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator();\n        Cookie escookie = null;\n        while (it.hasNext()) {\n            escookie = it.next();\n            System.out.println(escookie.getName() + \" = \" + escookie.getValue());\n        }\n        System.out.println(EntityUtils.toString(httpresponse.getEntity()));\n    }\n", "code2": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"loginBitShare": [" loginBitRay", "loginBandshare", "loginBitRay", "loginbitRay", "loginBitShares", "loginBandRay", " loginBitshare", "loginbitshare", "loginBandShare", "loginbitShares", " loginBitShares", "loginBandShares", "loginbitShare", "loginBitshare"], "params": ["reports", "words", "cmp", "pm", "ip", "cache", "pi", "results", "http", "eps", "utils", "options", "manager", "ctx", "api", "param", "details", "json", "properties", "eters", "p", "base", "ams", "Parameters", "ls", "vs", "phrase", "server", "ops", "license", "settings", "config", "php", "services", "lp", "ns", "ds", "Par", "rules", "bis", "ssl", "page", "parts", "parse", "posts", "mm", "ps", "parser", "fps", "radius", "par", "photos", "pro"], "httpclient": [" httpserver", "httpsresponse", "httpapi", " httpapi", "httphttp", "htmlclient", "httpserver", "webserver", "webClient", "phpClient", "ttpclient", "phpapi", "htmlconnection", "webclient", "ttpserver", "httpsClient", "httpsconnection", "htmlClient", "httpsapi", " httpconnection", "phpclient", "htmlresponse", "httpconnection", "httpsclient", " httphttp", " httpClient", "ttpClient", "httpClient", "ttphttp", "webhttp", "phpconnection"], "httppost": ["httpperost", " httplost", " httploster", "httpost", "httpposter", "httcppost", " httppood", " httpppost", " httppeoster", "httploster", " httplpost", " httppeoint", "httcppoint", " httpoint", "httppeoint", "httppeood", " httposter", "httppood", " httppoint", "httppsost", "httppsrost", "httplost", "httppeost", "httphost", " httpprost", "httprost", "httplpost", "httpoint", " httplort", "httcppood", "httppsoster", "httppeoster", " httppeost", "httcpposter", "httpport", "httport", "httphoster", "httpood", " httprost", " httpport", " httpost", "httpppost", "httposter", " httpposter", "httplort", "httpprost", " httppeood", "httppsoint", "httphort", "httppoint", "httphpost"], "formparams": [" formnames", "feedparam", " formparam", "FORMparams", " formams", "handParameters", "headnames", " formargs", "formparam", "FORMams", "formedparams", "Formargs", "handams", "formsettings", "Formsettings", "Formnames", "formedparam", "Formparam", "formauthors", "Formparams", "formParameters", "fams", "formams", "formedauthors", " formblock", "FORMparam", "headparams", "Formams", "headparam", " formauthors", "FORMblock", "handparams", "feedams", " formParameters", "formedams", "formedblock", "fauthors", " formsettings", "feedparams", "formargs", "handargs", "formnames", "FormParameters", "feedsettings", "headams", "fparam", "fparams", "formblock"], "entity": ["resource", "body", "entry", " Entity", "environment", "xml", "service", "response", "api", "et", "email", "json", "content", "object", "translation", "connection", "document", "collection", "event", "model", "server", "url", "query", " entities", "article", "e", "el", "result", "html", "page", "output", "data", "ities", "type", "ent", "ec", "Entity", "form", "db", "file", "person"], "httpresponse": [" httpresp", " httpserver", "htmlclient", "hyperresponse", "htmlserver", "Httpresp", "Httpserver", "httpserver", "hyperclient", "phpresp", "phpserver", "httpresp", "htmlresponse", "hyperserver", "Httpresponse", "phpresponse"], "it": ["entry", "or", "si", " It", "ip", "not", "pit", "and", "you", "op", "ait", "iz", "IT", "ist", "rit", "itted", "ic", "iti", "edit", "slice", "the", "in", "ins", "ort", "ct", "lit", "mit", "l", "init", "I", "its", "ati", "quit", "index", "ite", "i", "set", "ind", "ul", "start", "st", "It", "iv", "cont", "which", "sort", "end"], "escookie": ["scake", "ascinel", "Escookie", "estenter", "estookie", "descaddy", "Escaddy", "descake", "ascale", "ascerve", "Escenter", "caddy", "ecoding", "cinel", "ascake", "escoding", "escerve", " enaddy", " encookie", "scookie", "escenter", "Escerve", "desccel", "descookie", "cerve", "escale", "ecaddy", "cookie", "esccel", "estaddy", "scale", "ecookie", "escaddy", "eccookie", " escaddy", "ascookie", "esccookie", "descenter", "descale", " enoding", "escake", " enookie", " esccookie", "sccel", "escinel", "asccel", "Esccel", "Escinel", " escoding", "estcel", "ascaddy"]}}
{"id1": "12146394", "id2": "4056444", "code1": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "code2": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "label": 1, "substitutes": {"md5Crypt": ["MD5Key", "MD5Hash", "md4Crypt", "md2Hash", "md2Crypt", "md6Key", "MD2Crypt", "MD2Key", "md5Key", "md5Hash", "MD5Crypt", "md2crypt", "MD2Hash", "MD2crypt", "md4crypt", "MD5crypt", "md5crypt", "md2Key", "md6Crypt", "md4Hash", "md6Hash", "md4Key", "md6crypt"], "key": ["ch", "ask", "use", "full", "m", "call", "scope", "state", "time", "cer", "power", "magic", "none", "pair", "ke", "ce", "my", "kh", "carry", "rule", "order", "date", "image", "hash", "material", "transfer", "ssl", "cy", "parent", "text", "ace", "version", "seed", "cache", "shift", "y", "money", "empty", "this", "length", "user", "wire", "connection", "element", "x", "other", "air", "code", "value", "password", "data", "req", "message", "row", "root", "Key", "word", "go", "ee", "copy", "char", "sync", "no", "phrase", "size", "cert", "any", "type", "id", "lock", "kid", "name", "temp", "token", "kw", "fee", "ip", "k", "string", "zip", "secret", "blow", "service", "input", "self", "year", "proof", "KEY", "list", "number", "trust", "cookie", "base", "server", "here", "point", "sign", "source", "core"], "salt": [" ssecret", "sesift", "SALT", "sodium", "ssecret", " skey", "southalt", "sul", "ssol", "sesalt", "asALT", "seskey", " sift", "sesart", "southodium", "sessecret", "sesort", "ssALT", "sesal", "sol", " sol", "svort", "sesass", "sALT", "Sodium", "sift", " sart", " sass", "ssalt", "southift", " sALT", "Ssecret", "southsecret", "Sal", "sart", "sesul", "Salt", "sesol", "asalt", "asal", "sesALT", "sal", "osALT", "skey", "southALT", "sval", "osul", "sort", "osalt", "assecret", "ssass", "svalt", "osift", "sass", " sodium", "southart", "svALT"], "_md": ["copycmd", "localcmd", " _MD", "_nm", "\u00a0mand", "copydm", " _nm", " _amd", "_mand", "\u00a0cmd", "\u00a0mode", "_mg", "_m", "Newamd", "localmb", "\u00a0dm", "__cmd", "Newmd", "_dm", "copykey", "\u00a0md", " _key", " _m", "\u00a0m", " _cmd", "_mb", "_MD", "_key", "__amd", "__dm", "Newcmd", " _dm", "_mode", "localmd", "_db", "_cmd", " _db", "copymd", "localmg", "__md", "Newdm", "\u00a0nm", "_amd"], "md2": ["amd62", "hdTwo", "MD2", "cmd1", "MD1", "amd32", "MD5", " mdTwo", "md02", "md32", "amdTwo", "cmd2", "cmd3", " md5", "md5", "hd32", "mdTwo", "md4", " md4", " md62", "MD62", "amd4", "md1", " md32", "hd62", "cmd62", "md62", "cmd4", " md02", "MD4", "hd2", " md1", "amd2", "amd02", "MD3", "cmd02", "cmd5"], "abyFinal": ["sayInitial", "abeFinish", "abiesSuccess", "BabyLast", "aberfinal", "abeFull", "butInitial", "amyInitial", "andyLast", "BabyFinish", "babyResult", "andyInitial", "abiesFinish", "amyFinal", "rayInitial", "abeLast", "babyfinal", "amyResult", "abiesFinal", "amySuccess", "abiesFull", "abeFinal", "BabyFinal", "babyTotal", "babySpecial", "abyFinish", "abyfinal", "aberFinal", "aberTotal", "abyResult", "rayLast", "babySuccess", "saySpecial", "abySpecial", "babyLast", "abyInitial", "andyTotal", "babyFinal", "abiesResult", "andyfinal", "aberInitial", "butLast", "butFinal", "abiesLast", "abyTotal", "andyFinal", "sayFinal", "babyInitial", "BabyFull", "abySuccess", "amySpecial", "rayFinal", "Babyfinal", "abyLast", "abyFull"], "n": ["span", "nb", "pn", "not", "yn", "nw", "N", "c", "g", "m", "k", "y", "o", "d", "byn", "na", "node", "dn", "ner", "z", "np", "none", "network", "nn", "number", "num", "on", "conn", "nor", "min", "ny", "inn", "fn", "no", "p", "br", "adj", "l", "ng", "net", "cn", "all", "mn", "sn", "x", "non", "syn", "f", "len", "ns", "don", "a", "ni", "gn", "v", "ne", "nt", "r", "b", "en", "t", "nc", "nu", "nan", "name", "un"], "j": ["fr", "js", "si", "qi", "section", "u", "k", "ii", "c", "dj", "jl", "y", "o", "d", "ci", "di", "io", "J", "z", "ji", "jj", "num", "ie", "p", "adj", "l", "uj", "I", "x", "index", "q", "ind", "li", "ja", "ni", "v", "ne", "yi", "jp", "bj", "b", "xi", "jc", "aj", "ij"], "i": ["iu", "si", "qi", "chi", "multi", "ini", "ii", "c", "pi", "y", "o", "ani", "ci", "di", "io", "ji", "ui", "ri", "bi", "ie", "p", "gu", "phi", "ki", "I", "eni", "fi", "ali", "index", "e", "oi", "li", "ni", "gi", "mini", "ti", "mi", "ai", "yi", "zi", "xi", "mu"], "sbPasswd": ["sbCrword", "sbCrwords", "sbPassw", "bbParword", "bbPassrc", "sbSecretwords", "rbCrword", "sbFailwd", "sbCrw", "sbFailword", "sfPassw", "sfPasswd", "sbParw", "sbParWD", "sfSecretword", "sbParrc", "rbCrw", "rbPassword", "sbFailw", "cbParw", "sbParword", "rbCrwd", "sfSecretw", "sbSecretw", "sfSecretwords", "sbCrwd", "cbParphrase", "sfSecretwd", "cbPassword", "sbParphrase", "rbPassWD", "bbParwd", "sbSecretwd", "bbPasswd", "sbPassphrase", "sbParwd", "bbParrc", "sbCrWD", "sbParwords", "bbPassword", "sfPassword", "sbSecretword", "rbPasswd", "cbPassphrase", "rbCrWD", "cbParword", "bbPassw", "sbCrrc", "cbPassw", "bbParw", "sfPasswords", "sbFailphrase", "cbParwd", "sbPassWD", "cbPasswd", "rbPassw", "sbPassrc", "sbPasswords", "sbPassword"], "md3": ["mand15", "md23", "mand23", "msthree", "amd15", "amdthird", "amd512", "MD2", "MD1", "cmd53", "ms3", " md53", " mdthree", "mag3", "cmd2", "cmd3", "md53", "md15", "amd3", "amd23", "amdthree", " md03", "mag23", "mdthird", "mag512", " mdthird", "MD53", "md1", "md512", "cmd23", "mand3", " md23", "MD23", "ms03", "msthird", " md1", "mdthree", "md03", "mand512", "cmd1", "mag15", "MD3", "amd03"]}}
{"id1": "7276377", "id2": "15905041", "code1": "    public static String checksum(URL url, String algorithm) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(algorithm);\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Could not create an instance of MessageDigest\", ex);\n        }\n        byte[] bytes = new byte[4 * 1024];\n        try {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                int nBytesRead = 0;\n                while ((nBytesRead = in.read(bytes)) > 0) {\n                    messageDigest.update(bytes, 0, nBytesRead);\n                }\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not read message digest for: \" + url.toExternalForm() + \" using algorithm: \" + algorithm);\n        }\n        byte[] checksumValue = messageDigest.digest();\n        return digestAsString(checksumValue);\n    }\n", "code2": "    public void createPartControl(Composite parent) {\n        viewer = new ScrollingGraphicalViewer();\n        viewer.setRootEditPart(new ScalableRootEditPart());\n        viewer.setEditPartFactory(new BlockEditPartFactory());\n        viewer.setEditDomain(new EditDomain());\n        viewer.createControl(parent);\n        viewer.setKeyHandler(new GraphicalViewerKeyHandler(viewer));\n        ActionRegistry actionRegistry = new ActionRegistry();\n        createActions(actionRegistry);\n        ContextMenuProvider cmProvider = new BlockContextMenuProvider(viewer, actionRegistry);\n        viewer.setContextMenu(cmProvider);\n        Block b = new Block();\n        b.addChild(new ChartItem());\n        viewer.setContents(b);\n        System.err.println(\"!!! \" + viewer.getContents().getChildren().get(0));\n        viewer.select((EditPart) viewer.getContents().getChildren().get(0));\n        PaletteRoot root = new PaletteRoot();\n        PaletteGroup toolGroup = new PaletteGroup(\"Chart Tools\");\n        List toolList = new ArrayList();\n        ToolEntry tool = new SelectionToolEntry();\n        toolList.add(tool);\n        root.setDefaultEntry(tool);\n        tool = new MarqueeToolEntry();\n        toolList.add(tool);\n        toolGroup.addAll(toolList);\n        PaletteGroup templateGroup = new PaletteGroup(\"Templates\");\n        List templateList = new ArrayList();\n        CombinedTemplateCreationEntry entry = new CombinedTemplateCreationEntry(\"Rect\", \"Rect\", new ChartItem(), new SimpleFactory(ChartItem.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        CombinedTemplateCreationEntry entry1 = new CombinedTemplateCreationEntry(\"Line\", \"Line\", new ChartLine(), new SimpleFactory(ChartLine.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        templateList.add(entry);\n        templateList.add(entry1);\n        templateGroup.addAll(templateList);\n        List rootList = new ArrayList();\n        rootList.add(toolGroup);\n        rootList.add(templateGroup);\n        root.addAll(rootList);\n        final PaletteViewer v = new PaletteViewer();\n        v.setPaletteRoot(root);\n        v.createControl(parent);\n        v.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(\"selectionChanged \" + v.getActiveTool());\n            }\n        });\n        deleteAction.setSelectionProvider(viewer);\n        viewer.getEditDomain().setPaletteViewer(v);\n        viewer.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(event.getSelection());\n                deleteAction.update();\n            }\n        });\n        viewer.getEditDomain().getCommandStack().addCommandStackEventListener(new CommandStackEventListener() {\n\n            public void stackChanged(CommandStackEvent event) {\n                undoAction.setEnabled(viewer.getEditDomain().getCommandStack().canUndo());\n                redoAction.setEnabled(viewer.getEditDomain().getCommandStack().canRedo());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"checksum": ["checksums", "cksum", "cksumb", "checkssum", "decumb", " checksums", "decums", "ckssum", "decum", "cksums", " checkssum", " checksumb", "checksumb", "decsum"], "url": ["resource", "or", "fr", "username", "stream", "string", "host", "href", "http", "str", "proxy", "service", "URL", "manager", "path", "ll", "ur", "feed", "gl", "Url", "email", "download", "user", "address", "loc", "rule", "connection", "l", "base", "server", "location", "config", "loader", "sl", "f", "cert", "filename", "image", "ssl", "id", "uri", "source", "text", "src", "name", "file"], "algorithm": ["exgorithm", "malignment", "allgorithm", " alignment", "ALgebra", " algebra", "ALgo", "Algorithm", "algorith", "Algorith", "allgo", "exgo", "ALgorithm", "malgorith", "malgorithm", "Algebra", " algo", "exgebra", "allgorith", "malgo", "ALgorith", "alignment", "algebra", " algorith", "Alignment", "allgebra", "exgorith", "malgebra", "algo", "Algo"], "messageDigest": ["messageDest", "messageSignse", "messageDester", "MessageDigator", "messagediger", "messageDigse", "messageDigator", "messageDiger", "MessageDigester", "MessageSignse", "MessageDigess", "messagedigest", "messageDigester", "messageDigpe", "messagedigse", "messagedigester", "MessageDester", "messageMixest", "MessageDesignest", "messageDesignester", "MessageSignge", "MessageSignest", "messageRegest", "messageDesignator", "messageDigge", "messageDpe", "MessageMixer", "messageDigess", "MessageDesignester", "MessageDigge", "messageSignge", "messageRegator", "messageSignester", "messageRegess", "MessageDesigness", "messageMixester", "messageMixpe", "messageDer", "messagedigade", "messageDesigness", "MessageDse", "MessageSignester", "messagedigess", "MessageDesignator", "messageDesignest", "MessageMixester", "MessageDade", "MessageMixest", "MessageDest", "messagedigpe", "MessageDigade", "messageDigade", "MessageDigest", "messageMixer", "messageSignest", "messageRegester", "messageDse", "MessageMixpe", "messagedigge", "messagedigator", "MessageDigpe", "MessageDiger", "messageDade", "MessageDigse", "messageDge"], "bytes": ["pages", "reads", "Bytes", "classes", "words", "bps", "bs", "zip", "resources", "lines", "ones", "values", "loads", "errors", "eps", "gets", "bits", "outs", "bles", "objects", "os", "files", "boot", "seconds", "tes", "steps", "pieces", "limits", "cells", "resses", "ls", "vs", "size", "blocks", "frames", "units", "ips", "vals", "parts", "items", "ipes", "es", "buffer", "rows"], "in": ["In", "fe", "fr", "token", "again", "serv", "n", "c", "ini", "IN", "m", "ex", "is", "din", "inner", "bin", "input", "as", "con", "ins", "ac", "impl", "conn", "min", "inn", "err", "kin", "l", "isin", "init", "s", "win", "rin", "out", "gin", "f", "i", "nin", "a", "socket", "login", "ssl", "reader", "gen", "data", "r", "b", "inc", "id", "source", "stream", "client", "version", "file"], "nBytesRead": ["nByteWritten", " nBytesLength", "nFramesRead", "nByteLoad", "nFramesFound", " nByteFound", "nByteLength", "nByteRead", " nByteLength", " nBytesWritten", "nPartsLoad", "nBytesLength", "nByteCount", "nCharactersCount", "nWordsRead", "nCharactersRead", " nBytesCount", "nWordsLength", " nByteCount", "nPagesRead", " nByteLoad", "nCharactersLength", "nByteFound", "nFramesLength", "nWordsWritten", "nPagesLength", "nBytesWritten", " nBytesFound", "nBytesLoad", "nPagesFound", " nByteWritten", "nPartsWritten", "nPagesWritten", " nBytesLoad", "nFramesWritten", "nCharactersWritten", "nBytesFound", "nWordsCount", "nPartsRead", " nByteRead", "nBytesCount"], "checksumValue": [" checkssumVal", "checksumberValue", "checksramVal", "checksramArray", "checkssumVal", "checksumberText", "checksumString", "checksumberData", "checksumArray", "checksupData", " checksumString", "checksummPath", " checkssumString", "checkssumPath", "checksupString", "checksummValue", "checksupText", " checkssumData", "checksumText", "checksumPath", " checksumData", "checkssumString", " checkssumText", " checksumVal", " checksumPath", " checkssumArray", "checksupValue", "checksramPath", "checksummArray", "checksramValue", "checksummVal", "checksumData", " checksumArray", "checksumberString", "checkssumText", " checkssumValue", "checkssumData", "checkssumValue", "checksumVal", "checkssumArray", " checkssumPath", " checksumText"]}}
{"id1": "14794404", "id2": "18097962", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["encryptSecret", "EncipherPassword", "EncryptPassword", "encryptString", "encryptedpassword", "EncipherSecret", "Encryptpassword", "encipherSecret", "EncipherString", "encressString", "encryptpassword", "encressPassword", "encipherPassword", "Encipherpassword", "encressSecret", "encipherString", "encresspassword", "EncryptSecret", "EncryptString", "encipherpassword", "encryptedSecret", "encryptedString"], "password": ["resource", "pass", "attribute", "token", "username", "words", "sword", "description", "string", "cache", "channel", "word", "secret", "input", "Password", "PASS", "path", "params", " passwords", "database", "email", "wd", "content", "object", "address", "p", "connection", "device", "prefix", "phrase", "definition", "array", "enc", "data", "message", "pattern", "buffer", "crypt", "text", "name", "padding"], "encryptedPassword": [" encryptedpassword", "ryptedpassword", "lockedPassword", "encryptedpassword", "protectedpassword", "protectedPass", "encryptedCode", "ryptedPass", " encryptedCode", "protectedCode", "ryptedPassword", "ryptedString", " encryptedPass", "lockedPass", "encryptedPass", "lockedpassword", " encryptedString", "ryptedCode", "protectedString", "encryptedString", "protectedPassword", "lockedString"], "md5": ["MD2", "MD5", "MD6", " MD3", " mddown", " md6", "mddown", "md2", " md3", "MDdown", "dig45", "dig4", " md4", "md4", "dig5", " md2", " MD5", "dig3", "md6", "amd6", "amd4", "MD45", "md512", "MD4", " MD2", " md512", "MD512", "amd2", "md45", "md3", "dig2", " MD512", "MD3", "amd5", "digdown", " md45"], "digest": ["mdment", "mdash", "encment", "Digace", "mdest", " digher", " digests", "Digester", "mdested", "Digested", "signest", "digested", "digester", "digace", "digenge", " digester", "Digenge", "Digher", "signester", "digment", "mdests", "mdace", " digash", "signests", " digenge", "signested", " digace", "Digests", "mdenge", "mdester", "digests", "mdher", "Digest", "encester", "digash", " digment", "digher", "encash", "encest"], "i": ["hi", "si", "qi", "ip", "u", "multi", "k", "ii", "c", "pi", "o", "d", "ci", "di", "io", "ui", "length", "ri", "bi", "ie", "p", "it", "l", "phi", "s", "j", "I", "x", "index", "f", "e", "oi", "li", "h", "v", "gi", "ti", "ai", "r", "b", "zi", "t", "id", "xi", "uri", "ix"], "hex": ["temp", "ctr", "ip", "nexus", "zip", "string", "utf", "rh", "ex", "exp", "ix", "shift", "str", "pixel", "bin", "stick", "di", "bits", "char", "none", "bit", "slice", "num", "length", "coord", "letter", "lit", "alpha", "oct", "prefix", "pex", "mix", "enc", "comp", "serial", "rex", "sex", "hash", "check", "closure", "ext", "data", "digit", "null", "pack", "buff", "id", "pattern", "sign", "binary", "text"]}}
{"id1": "12586404", "id2": "8801182", "code1": "    @Override\n    public List<ProvaSolution[]> run(ProvaService prova, String agent, String key, String src) throws IOException {\n        File file = new File(src);\n        BufferedReader in;\n        InputStream is = null;\n        try {\n            if (!file.exists() || !file.canRead()) {\n                try {\n                    is = Thread.currentThread().getContextClassLoader().getResourceAsStream(src);\n                    in = new BufferedReader(new InputStreamReader(is));\n                } catch (Exception ex1) {\n                    try {\n                        is = RuleReaderImpl.class.getResourceAsStream(src);\n                        in = new BufferedReader(new InputStreamReader(is));\n                    } catch (Exception ex2) {\n                        try {\n                            URL url = new URL(src);\n                            in = new BufferedReader(new InputStreamReader(url.openStream()));\n                        } catch (Exception ex3) {\n                            throw new IOException(\"Cannot read from \" + src);\n                        }\n                    }\n                }\n            } else {\n                FileReader fr = new FileReader(file);\n                in = new BufferedReader(fr);\n            }\n            List<ProvaSolution[]> results = prova.consult(agent, in, key);\n            return results;\n        } finally {\n            if (is != null) is.close();\n        }\n    }\n", "code2": "    private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception {\n        Properties list = new Properties();\n        list.load(new FileInputStream(fileWithListOfImages));\n        long current = 0;\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir);\n        System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\");\n        System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\");\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\");\n        }\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            URL url = new URL(uriPrefix + urlString);\n            File file = new File(outputDir + \"/\" + imageNameToFileName(urlString));\n            current++;\n            if (!file.exists()) {\n                try {\n                    BufferedInputStream in = new BufferedInputStream(url.openStream(), 64000);\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file), 64000);\n                    int c;\n                    while ((c = in.read()) != -1) {\n                        out.write(c);\n                    }\n                    out.close();\n                    in.close();\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                    System.out.println(\"saved\");\n                } catch (Exception e) {\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", FAILED, error: \" + e.getMessage());\n                }\n            } else {\n                System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                System.out.println(\"already exists\");\n            }\n            if (current / 100 == current / 100.0) {\n                long delta = (System.currentTimeMillis() - startTime);\n                System.out.println(\"Total time \" + delta + \" ms, \" + (delta / current) + \" ms/file\");\n            }\n        }\n        long delta = (System.currentTimeMillis() - startTime);\n        System.out.println(\"Total time \" + delta + \" ms, \" + (delta / list.size()) + \" ms/file\");\n    }\n", "label": 0, "substitutes": {"run": ["use", "Run", "execute", "call", "master", "report", "process", "add", "unit", "build", "trial", "running", "setup", "exec", "work", "config", "start", "un", "close", "apply", "runner", "test", "submit", "runs", "connect", "create"], "prova": ["proga", "Proda", "peva", "Profa", "perba", "PROVA", "perfa", "ProVA", "peVA", "proda", " proda", " proba", "pefa", "Proga", "pega", "perda", "Prova", "proVA", "profa", " profa", "PROfa", "Proba", "proba", "PROga", "PROva", "perva"], "agent": ["resource", "agents", "entry", "actor", "acc", "fax", "act", "ator", "agency", "service", "state", "input", "report", "manager", "Agent", "attr", "conn", "address", "man", "domain", "model", "server", "reg", "contract", "ant", "gent", "config", "session", "director", "graph", "writer", "r", "account", "client", "ace", "monitor"], "key": ["resource", "role", "or", "entry", "row", "Key", "ip", "k", "string", "host", "step", "secret", "str", "service", "state", "path", "KEY", "param", "ak", "json", "ring", "user", "address", "rule", "base", "server", "contract", "work", "config", "keys", "link", "air", "cert", "type", "id", "sign", "source", "client", "name"], "src": ["rou", "resource", "rss", "route", "username", "seed", "string", "SourceFile", "href", "resources", "rest", "Source", "method", "host", "sch", "ruby", "dist", "proxy", "input", "ource", "path", "inst", "sc", "text", "sr", "sync", "dest", "rl", "address", "loc", "s", "rc", "rin", "server", "config", "loader", "sec", "sl", "sb", "code", "filename", "sin", "RC", "img", "ssl", "st", "ser", "ources", "secure", "null", "prot", "sit", "source", "stream", "uri", "sel", "rb"], "file": ["File", "resource", "folder", "fe", "il", "local", "class", "use", "full", "zip", "cache", "http", "proxy", "service", "input", "log", "path", "io", "feed", "this", "files", "object", "loc", "play", "it", "l", "rule", "connection", "base", "pe", "model", "work", "loader", "f", "FILE", "per", "link", "el", "image", "filename", "socket", "fp", "reader", "b", "id", "info", "source", "stream", "ile", "uri", "binary", "lock"], "in": ["In", "or", "again", "ini", "and", "include", "IN", "rec", "cin", "inner", "din", "bin", "with", "str", "input", "ic", "ci", "io", "pin", "ins", "ac", "on", "min", "conn", "inn", "ri", "ie", "p", "err", "it", "kin", "l", "part", "init", "s", "isin", "rc", "out", "rin", "lin", "exec", "ar", "get", "dr", "x", "config", "gin", "read", "index", "f", "i", "nin", "el", "image", "login", "reader", "ai", "req", "r", "inc", "id", "info"], "is": ["im", "ini", "isl", "http", "ire", "has", "ci", "IS", "impl", "are", "isin", "s", "iss", "eni", "isi", "image", "sin", "lis", "ai", "nis", "es", "uri", "ise", "or", "ios", "was", "ic", "abs", "ais", "does", "ar", "x", "iter", "isc", "ori", "ris", "il", "us", "isa", "ir", "os", "ins", "min", "er", "ie", "Is", "get", "sp", "its", "r", "id", "sit", "si", "ip", "internet", "inner", "iris", "as", "be", "api", "ui", "cms", "ri", "err", "it", "iso", "i", "bis", "info", "sel"], "url": ["resource", "pull", "ob", "string", "http", "str", "www", "URL", "path", "ll", "layer", "ur", "feed", "Url", "rl", "impl", "address", "bel", "loc", "l", "connection", "base", "server", "sl", "f", "link", "image", "ssl", "r", "b", "id", "web", "info", "uri", "stream", "source", "ref"], "fr": ["il", "fe", "fc", "compl", "kr", "pr", "ir", "sf", "fin", "frac", "raf", "ur", "yr", "sr", "rt", "rl", "tr", "fer", "lr", "rel", "br", "err", "rin", "arr", "dr", "fi", "f", "fm", "el", "fp", "range", "adr", "fl", "rr", "fb", "Fr", "form", "ris", "rf"], "results": ["reports", "maps", "resources", "errors", "values", "ids", "terms", "response", "relations", "params", "objects", "versions", "details", "files", "groups", "Results", "changes", "plugins", "properties", "forms", "RESULTS", "tests", "roots", "devices", "res", "grades", "result", "features", "ips", "rules", "vals", "items", "rows", "lists", "runs", "models"]}}
{"id1": "442381", "id2": "4501356", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "label": 0, "substitutes": {"doVersionCheck": [" doReleasecheck", "doversionTest", " doVersionWork", " doBuildcheck", "doBuildCheck", "doVERSIONTest", " doBuildCheck", " doVersioncheck", " doReleaseTest", "doVERSIONWork", "doVersionWork", "doBuildTest", "doReleaseWork", "doversioncheck", "doBuildcheck", "doVERSIONcheck", "doVersioncheck", " doReleaseCheck", "doVERSIONCheck", " doBuildWork", "doVersionTest", "doReleasecheck", " doBuildTest", " doVersionTest", "doversionCheck", "doReleaseCheck", "doBuildWork", "doReleaseTest"], "view": ["row", "window", "accept", "use", "full", "View", "cache", "see", "gui", "http", "request", "comment", "input", "self", "screen", "can", "edit", "display", "box", "VIEW", "this", "ui", "client", "div", "object", "gu", "l", "app", "vis", "show", "out", "layout", "model", "port", "server", "event", "cell", "config", "block", "e", "session", "q", "el", "image", "widget", "page", "v", "change", "reader", "html", "style", "buffer", "update", "lock", "body", "form", "sel", "views"], "url": ["resource", "stream", "ob", "zip", "string", "channel", "blog", "host", "http", "service", "input", "URL", "log", "ll", "path", "open", "Url", "client", "user", "address", "bel", "build", "browser", "l", "connection", "base", "server", "loader", "sl", "f", "hub", "image", "lib", "socket", "ssl", "bb", "web", "uri", "buffer", "source", "file"], "in": ["resource", "In", "n", "ini", "IN", "cin", "is", "din", "inner", "input", "as", "con", "ins", "ac", "inn", "isin", "init", "win", "s", "lin", "out", "rin", "gin", "i", "nin", "socket", "sin", "login", "bis", "reader", "data", "b", "inc", "binary", "stream", "source", "buffer", "file"], "bin": ["inline", "run", "nb", "oin", "bot", "IN", "cin", "ruby", "fin", "din", "inner", "input", "abi", "log", "con", "pin", "bn", "inn", "bi", "browser", "kin", "part", "init", "win", "lin", "out", "gin", "loader", "lib", "socket", "sin", "record", "border", "bb", "reader", "data", "spin", "b", "binary", "buffer", "lock", "body", "ln", "file"], "line": ["inline", "look", "band", "entry", "row", "pass", "day", "ip", "string", "site", "lines", "word", "LINE", "ine", "str", "comment", "le", "Line", "ge", "layer", "log", "key", "no", "object", "letter", "unit", "valid", "cl", "l", "part", "up", "base", "rule", "lin", "cell", "pe", "model", "load", "definition", "non", "link", "e", "code", "i", "home", "nl", "el", "split", "lo", "page", "data", "parse", "style", "b", "lf", "message", "job", "source", "id", "text", "block", "name", "file", "lc", "end"], "develBuild": ["dellRelease", "deployRun", "DEVELbuild", "deployBuilder", "DEvelBuild", "devenBuilt", "deelBuild", "desvenBuilt", "deelBuilder", "develBuilder", "desvelBuild", "dellRun", "DEVELBuild", "devenbuild", "deVELBuild", "desvelbuild", "dellBuilder", "deploybuild", "devenRelease", "desvelRun", "DEVELBuilt", "devenBuilder", "dewardBuilt", "deviousBuilt", "desvelRelease", "deviousbuild", "deviousBuild", "DEvelbuild", "deVELRun", "deVELBuilder", "develbuild", "devenBuild", "desvenBuild", "DEVELBuilder", "DEvelBuilder", "dewardBuild", "develRelease", "develRun", "dewardbuild", "develBuilt", "deVELbuild", "desvenBuilder", "deployBuilt", "desvenRun", "dellBuild", "deelRelease", "deVELBuilt", "desvelBuilder", "desvelBuilt", "deelRun", "desvenbuild", "desvenRelease", "devenRun", "DEvelBuilt", "deployBuild", "dewardBuilder"], "stableBuild": ["prettyBuilder", "stableBuilder", "stablebuild", "baseVersion", " stableVersion", "compatibleBuilder", "staticbuild", "basebuild", "latestBuild", "validBuild", "stableVersion", "compatiblebuild", "latestbuild", "baseBuilder", "securebuild", "baseBuild", "prettyVersion", "prettybuild", "validBuilder", "staticBuilder", "secureBuilder", "compatibleBuild", "staticBuild", "validbuild", " stablebuild", "prettyBuild", " stableBuilder", "secureBuild", "latestBuilder"]}}
{"id1": "1097146", "id2": "7372311", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 1, "substitutes": {"getMessageDigest": ["getMessagedigester", "getContentdigester", "getMessageDigifier", "getContentDigifier", "getMessagedigests", "getMessagedigifier", "getMessageEncester", "getMessageEncests", "getContentDigest", "getContentdigifier", "getMessageSignest", "getContentDigester", "getMessageEncifier", "getMessageEncest", "getMessageSignester", "getMessageDigests", "getMessagedigest", "getMessageSignests", "getMessageDigester", "getMessageSignifier", "getContentDigests", "getContentdigests", "getContentdigest"], "input": ["temp", "plus", "accept", "stream", "container", "string", "instance", "context", "request", "xml", "str", "inner", "state", "self", "empty", "list", "this", "in", "content", "object", "address", "audio", "amp", "document", "out", "element", "model", "definition", "config", "now", "array", "Input", "i", "password", "image", "inf", "output", "argument", "data", "type", "raw", "submit", "parse", "null", "reader", "target", "message", "parent", "source", "buffer", "text", "binary", "form"], "md": ["dc", "df", "mb", "mg", "mp", "ms", "pm", "od", "mand", "cm", "mac", "rm", "m", "sm", " MD", "um", "d", "sha", "di", "MD", "bd", "meta", "wd", "M", "dd", "mc", "mod", "cmd", "mn", "dr", "ma", "mag", "am", "gd", "dm", "nm", "amd", "rpm", "mm", "metadata", "vd", "bf", "mad", "mt", "me", "bm", "mo"], "bytes": ["pages", "Bytes", "classes", "words", "codes", "bs", "bps", "string", "ies", "lines", "values", "bits", "outs", "bles", "files", "groups", "seconds", "address", "tes", "pieces", "gb", "base", "s", "strings", "keys", "its", "blocks", "units", "vals", "data", "parts", "ipes", "b", "null", "es", "binary", "les", "body", "odes", "rows"]}}
{"id1": "2461169", "id2": "7545002", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static String POST(String url, String[][] props) throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        for (int i = 0; i < props.length; ++i) {\n            conn.addRequestProperty(props[i][0], props[i][1]);\n        }\n        conn.connect();\n        try {\n            return new String((byte[]) conn.getContent());\n        } finally {\n            conn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeStringToFiles", "decodeFileAsFiles", "decodeStringToFile", "decodeFileAsStream", "decodeString2Stream", "decodeFileFromStream", "decodeFileFromFiles", "decodeStringToString", "decodeFile2File", "decodeFileAsString", "decodeFileFromFile", "decodeStringToStream", "decodeFileToString", "decodeString2String", "decodeFile2String", "decodeFile2Files", "decodeFileToStream", "decodeFileToFiles", "decodeFileAsFile", "decodeString2File", "decodeString2Files", "decodeFileFromString", "decodeFile2Stream"], "infile": [" infp", " instream", "minbase", "Inbase", "inputfilename", "infp", "minstream", "outfiles", " infiles", "minFile", "inputfp", "inputfiles", "minfile", "outfilename", "Infile", "inbase", " inbase", "outfp", " infilename", "instream", "InFile", "inFile", "inputfile", " inFile", "Instream", "infiles", "infilename"], "outfile": ["outputpath", "outfolder", " outdatabase", "inputFile", "outputFile", "inputdatabase", " outFile", "outfilename", "inputpath", " outfilename", " outfolder", "outpath", " outpath", "outputdatabase", "inFile", "inputfile", "infolder", "outputfolder", "outFile", "outputfile", "outputfilename", "infilename", "outdatabase"], "in": ["In", "inas", "pass", "again", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "ic", "as", "con", "pin", "ins", "ac", "min", "conn", "inn", "into", "err", "isin", "init", "win", "s", "rin", "lin", "gin", "thin", "inside", "i", "nin", "a", "socket", "sin", "login", "reader", "data", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "In", "or", "pass", "exit", "line", "again", "cache", "channel", "o", "ex", "inner", "bin", "Out", "copy", "outer", "log", "io", "outs", "co", "post", "sync", "conn", "no", "err", "up", "net", "base", "exec", "work", "name", "session", "off", "home", "image", "lib", "socket", "to", "writer", "output", "error", "ou", "write", "obj", "OUT", "point", "job", "inc", "parent", "client", "one", "file"], "buffer": ["seed", "channel", "cache", "uffer", "limit", "padding", "bin", "input", "layer", "wave", "feed", "buf", "queue", "slice", "length", "address", "count", "batch", "base", "server", "url", "size", "Buffer", "iter", "value", "split", "bytes", "transfer", "result", "border", "bb", "reader", "data", "write", "type", "raw", "null", "b", "buff", "flush", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", "tell", " Read", "use", "ip", " skip", "send", "n", " write", "current", "reading", "fill", "limit", "select", "copy", "READ", "lex", "io", "feed", "add", "slice", "sync", "length", " count", "count", "seek", "play", "Read", "ad", "exec", "find", "get", "load", "x", "wait", "size", "work", "f", "iter", "len", "i", "allow", "ind", "_", "start", "ride", "check", "connect", "next", "reader", " copy", "parse", "write", "se", "raw", "r", "inc", "id", "sleep", "end"], "success": ["rolled", "done", "pass", "status", "again", "initial", "method", "results", "failed", "comment", "winner", " Success", "continue", "response", "func", "right", "fast", "path", "open", "Success", "primary", "ceed", "first", "warning", "construct", "content", "ccess", "positive", "growth", "roll", "good", "valid", "successful", "flash", " successful", "default", "danger", "model", "fail", " succeed", "complete", " succ", "value", "rolling", "result", "better", "true", "follow", "data", "error", "xx", "null", "successfully", "message", "cess"]}}
{"id1": "13981689", "id2": "20619879", "code1": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 0, "substitutes": {"md5Hash": [" MD5Hash", "md5String", "md5hash", "md4String", " MD5String", "md6hash", "md512String", " MD5Sum", "md6Sum", " MD6hash", "md512Hash", " MD6Hash", " MD5hash", "md4Sum", "md512Sum", " MD6Sum", "md4hash", "md4Hash", " MD6String", "md6Hash", "md5Sum", "md512hash", "md6String"], "src": ["Bytes", "string", "SourceFile", "href", "Source", "ruby", "str", "input", "URL", "msg", "inst", "sc", "buf", "dest", "Url", "length", "SB", "sup", "gb", "s", "rc", "ptr", "buster", "tmp", "RGB", "sb", "sl", "SOURCE", "lib", "bytes", "inf", "RC", "ssl", "img", "data", "obj", " source", "b", "info", "source", "Str", "text", "uri", "rb", "file"], "md": ["mb", "mp", "pd", "ms", "pm", "od", "mand", "rm", "mac", "m", " MD", "km", "d", "di", "MD", "bd", "wd", "hd", "ad", "dd", "mc", "cd", "mod", "cmd", "ma", "mag", "f", "code", "gd", "ind", "dm", "hash", "material", "editor", "rod", "amd", "ss", "kg", "dig", "mm", "metadata", "vd", "mad", "db", "mo"]}}
{"id1": "14303294", "id2": "21395184", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    @Test\n    public void test30_passwordAging() throws Exception {\n        Db db = DbConnection.defaultCieDbRW();\n        try {\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"5\", 1);\n            PreparedStatement pst = db.prepareStatement(\"UPDATE e_people SET last_passwd_change = '2006-07-01' WHERE user_name = ?\");\n            pst.setString(1, \"esis\");\n            db.executeUpdate(pst);\n            db.commit();\n            p_logout();\n            t30login1();\n            assertTrue(isPasswordExpired());\n            PeopleInfoLine me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().before(DateHelper.now()));\n            t30chgpasswd();\n            assertFalse(isPasswordExpired());\n            me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().after(DateHelper.now()));\n            p_logout();\n            t30login2();\n            assertFalse(isPasswordExpired());\n            t30chgpasswd2();\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"0\", 1);\n            db.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            db.rollback();\n        } finally {\n            db.safeClose();\n        }\n    }\n", "label": 0, "substitutes": {"getServerHash": ["getSessionHash", "getServerAddress", " getServerAddress", "getSecureSalt", "getServerSalt", "getserverAddress", " getSecureAddress", "getserverHash", "getSessionAddress", "getserverSHA", "getSecureSHA", "getSecureHash", "getSecureAddress", "getserverSalt", "getSessionSalt", "getSessionSHA", " getServerSHA", " getSecureSalt", " getSecureHash", "getServerSHA", " getServerSalt", " getSecureSHA"], "passwordHash": ["passwordhash", " PasswordHash", " passwordCode", "PasswordHash", "passwordPass", "PasswordPassword", " passwordhash", "PasswordPass", " passwordPass", "privatePassword", " PasswordPass", " PasswordCode", "privatehash", "passwordCode", "privateHash", " passwordSalt", "passwordSalt", "privateSalt", " passwordPassword", "Passwordhash", "PasswordCode", "passwordPassword"], "PasswordSalt": [" PasswordHash", "password256", " passwordSecret", "PasswordHash", "PasswordPassword", "passwordSecret", "PasswordSecret", "PASSSalt", "PASSPassword", "PASSHash", " Password256", " passwordSalt", "passwordSalt", "Password256", "PASS256", " passwordPassword", " PasswordPassword", " PasswordSecret", "passwordPassword"], "hash": ["row", "sh", "string", "cache", "mac", "Hash", "sha", "response", "sum", "copy", "log", "search", "hex", "number", "key", "auth", "content", "user", "address", "kh", "build", "crypt", "ha", "base", "url", "work", "ash", "size", "array", "pool", "code", "value", "password", "her", "image", "h", "check", "result", "change", "html", "error", "data", "dig", "message", "update", "buffer", "block"], "digest": ["hashener", "digener", " digall", "generall", "hashest", " diger", "digusher", "mdest", "Digener", " digher", "Digester", " digusher", "integested", "mdested", "signest", "Digested", "integest", " digger", "digested", "digester", "signer", "Digusher", " digester", " digested", "Digher", "generest", "mdusher", "signester", "hasher", "hashester", "signher", "generester", "Diger", "diger", "Digger", "integester", "generested", " digener", "integall", "digger", "mdester", "Digest", "digher", "digall", "signger"]}}
{"id1": "20588811", "id2": "15904772", "code1": "    public void run() {\n        long time = System.currentTimeMillis();\n        logger.info(\"Version: \" + version);\n        String hostname = properties.getProperty(\"mercuriushost\");\n        String protocol = properties.getProperty(\"mercuriusprotocol\");\n        String port = properties.getProperty(\"mercuriusport\");\n        String path = properties.getProperty(\"mercuriuspath\");\n        String action = properties.getProperty(\"mercuriusaction\");\n        logger.info(\"Getting Timex Data --- \" + getTimeDifferent(time));\n        String xml = timexfrmk.getUnsynchedSessionsXMLFormat();\n        logger.info(\"Done getting Timex Data --- \" + getTimeDifferent(time));\n        if (timexfrmk.getSessionCount() > 0) {\n            try {\n                logger.info(\"Sending Timex Data to Mercurius --- \" + getTimeDifferent(time));\n                String data = URLEncoder.encode(\"action\", \"UTF-8\") + \"=\" + URLEncoder.encode(action, \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"data\", \"UTF-8\") + \"=\" + URLEncoder.encode(xml, \"UTF-8\");\n                if (isAdminFeedKeySet()) {\n                    data += \"&\" + URLEncoder.encode(\"adminfeedkey\", \"UTF-8\") + \"=\" + URLEncoder.encode(adminfeedkey, \"UTF-8\");\n                    logger.debug(\"Using adminfeedkey to authenticate\");\n                } else {\n                    Authenticator.setDefault(new CustomAuthenticator(user, password));\n                    logger.debug(\"Using user/pwd to authenticate\");\n                }\n                String u = protocol + \"://\" + hostname + \":\" + port + path;\n                logger.debug(\"Posting xml data to: \" + u);\n                URL url = new URL(u);\n                URLConnection conn = url.openConnection();\n                conn.setRequestProperty(\"User-Agent\", \"TimexMercurius/\" + version);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                StringBuffer s = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    s.append(line);\n                }\n                if (s.length() > 0) {\n                    logger.debug(s.toString());\n                    if (s.toString().indexOf(\"Result:\") != -1) {\n                        logger.info(s.toString().substring(s.toString().indexOf(\"Result:\")));\n                        if (s.toString().indexOf(\"Result: Successful\") != -1) {\n                            timexfrmk.updateSessionsStatus();\n                        }\n                    } else {\n                        logger.error(s.toString());\n                    }\n                } else {\n                    logger.info(\"No data returned\");\n                }\n                wr.close();\n                rd.close();\n            } catch (MalformedURLException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (IOException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (Exception e) {\n                logger.error(e);\n                logger.trace(e, e);\n            }\n        } else {\n            logger.info(\"There is nothing to send.  Everything has already been synchronized\");\n        }\n        timexfrmk.close();\n        logger.info(\"Done!!! Total Time: \" + getTimeDifferent(time));\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 0, "substitutes": {"run": ["Run", "execute", "process", "client", " Run", " test", "unit", "build", "up", "app", "running", "release", "install", "exec", "server", "work", "system", "worker", "start", " running", "runner", "test", "loop", "update", "sleep", "create"], "time": ["timeout", "temp", "stage", "etime", "ip", "times", "im", "cache", "current", "hour", "request", "volume", "depth", "version", "service", "money", "right", "year", "micro", "length", "content", "mode", "count", "age", "up", "rate", "server", "work", "clock", "size", "now", "name", "date", "TIME", "value", "home", "space", "image", "start", "tim", "counter", "ime", "type", "timer", "info", "loop", "message", "sleep", "Time", "later", "file"], "hostname": [" hostNAME", "hostcode", "addresscode", "portNAME", "addressn", " hostn", "hostn", " hostline", "addressname", " hostcode", "Hostpath", "hostpath", "hostline", "portline", "Hostname", "localhostNAME", "Hostn", "addresspath", "localhostline", "localhostname", "Hostcode", "portname", " hostpath", "hostNAME"], "protocol": ["extocol", "Prototype", "propolution", "propocol", "resourceocol", "Protport", "scheport", "resourceotype", "protport", "extport", "scheocol", "propport", "propotype", "scheotype", "tocol", "resourcename", "extotype", "tport", "protolution", "extname", "scheolution", "resourceport", "tname", "Protolution", "Protocol", "prototype", "protname", "totype"], "port": ["username", "ip", "host", "method", "table", "secret", "limit", "service", "phone", "key", "length", "user", "address", "Port", "profile", "server", "name", "ports", "pool", "value", "password", "type", "PORT", "point", "target", "plugin", "uri", "version", "file"], "path": ["resource", "route", "string", "host", "Path", "method", "secret", "version", "api", "key", "user", "dir", "location", "config", "session", "code", "ath", "password", "home", "image", "format", "filter", "type", "id", "pattern", "uri", "text", "name", "file"], "action": ["resource", "stage", "token", "function", "act", "step", "method", "call", "view", "script", "service", "input", "auth", "active", "user", "ack", "agent", "event", "actions", "query", "Action", "session", "image", "format", "filter", "error", "type", "style", "plugin", "account", "info", "activity", "file", "sort"], "xml": ["txt", "mail", "application", "ml", "description", "zip", "string", "mx", "context", "http", "www", "response", "log", "feed", "files", "ww", "json", "email", "doc", "events", "content", "plex", "ez", "document", "event", "model", "X", "work", "x", "config", " XML", "office", "php", "ws", "code", "value", "image", "example", "tx", "html", "output", "ql", "message", "info", "update", "stream", "text", "body", "form", "name", "file"], "data": ["resource", "entry", "token", "media", "function", "send", "description", "string", "dat", "results", "method", "request", "str", "http", "response", "input", "api", "open", "feed", "empty", "key", "post", "auth", "json", "database", "download", "content", "object", "batch", "connection", "document", "actions", "DATA", "complete", "array", "session", "dump", "i", "image", "format", "to", "record", "result", "change", "next", "output", "message", "info", "update", "stream", "text", "body", "one", "file"], "u": ["bu", "us", "uu", "n", "c", "ru", "o", "universal", "uid", "U", "ur", "ue", "ui", "uv", "cu", "user", "p", "up", "l", "ut", "f", "uno", "e", "su", "i", "ul", "a", "uc", "h", "hu", "v", "ou", "tu", "b", "nu", "uri", "uni", "lu", "un"], "url": ["resource", "n", "channel", "host", "http", "service", "www", "response", "URL", "ll", "api", "open", "Url", "download", "user", "p", "browser", "l", "connection", "base", "server", "config", "sl", "f", "page", "ssl", "fl", "r", "b", "web", "uri", "client", "file"], "conn": ["ch", "serv", "ob", "n", "c", "Connection", "channel", "act", "http", "oa", "Conn", "ann", "conv", "ctx", "con", "api", "open", "util", "p", "l", "connection", "net", "cn", "rc", "cp", "exec", "server", "f", "enc", "cli", "connect", "h", "socket", "cb", "ssl", "ai", "obj", "b", "en", "comm", "nc", "info", "ec", "client"]}}
{"id1": "11546108", "id2": "16215393", "code1": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "code2": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"run": ["action", "println", "Run", "execute", "request", "call", "input", "process", "download", "build", "print", "running", "exec", "load", "read", "evaluate", "start", "apply", "test", "runner", "output", "write", "submit", "loop", "update"], "in": ["In", "token", "again", "serv", "ini", "c", "IN", "fin", "din", "is", "bin", "inner", "input", "con", "io", "cms", "ins", "min", "inn", "l", "isin", "init", "s", "rin", "lin", "out", "server", "loader", "f", "pool", "e", "nin", "h", "socket", "login", "ssl", "reader", "data", "r", "b", "t", "inc", "buffer", "stream", "client", "source", "fr"], "ligneEnCours": ["ligneEncours", "ligneOpenAcour", "ligneENcrosse", "ligneEnTours", "ligneEnCrosse", "ligneOpenCours", "ligneENCour", "ligneEnScours", "ligneenCourses", "ligneEncrosse", "ligneENAcourses", "ligneEnFCours", "ligneEnSurs", "ligneEnAcore", "ligneEnLCour", "ligneEncore", "ligneEnLCrosse", "ligneEnFCour", "ligneENcOUR", "ligneEnSours", "ligneEnScrosse", "ligneEnAcour", "ligneENCurs", "ligneEnScOUR", "ligneENcurs", "ligneEnFCOUR", "ligneOpenCurs", "ligneEnAcourses", "ligneenCours", "ligneEnTour", "ligneenAcour", "ligneEncour", "ligneEnScour", "ligneEncourses", "ligneENcour", "ligneEnTore", "ligneOpenAcOUR", "ligneEnLCours", "ligneEnAcOUR", "ligneEnCourses", "ligneENAcour", "ligneENCrosse", "ligneEnAcurs", "ligneEnSOUR", "ligneEnTOUR", "ligneEnSour", "ligneEnAcours", "ligneenAcore", "ligneenCore", "ligneEnScore", "ligneEnCOUR", "ligneENCore", "ligneENAcours", "ligneEnCurs", "ligneEncurs", "ligneEnCore", "ligneEnTourses", "ligneOpenCour", "ligneenAcours", "ligneENAcore", "ligneEnCour", "ligneEnLCOUR", "ligneEnTurs", "ligneENCOUR", "ligneOpenAcurs", "ligneenCour", "ligneENCours", "ligneEnFCurs", "ligneOpenCOUR", "ligneENcours", "ligneENCourses", "ligneEncOUR", "ligneOpenAcours", "ligneenAcourses", "ligneEnScourses"], "i": ["iu", "si", "qi", "ip", "u", "k", "ii", "n", "m", "pi", "c", "o", "col", "ini", "ci", "di", "io", "ui", "bi", "count", "p", "l", "phi", "j", "I", "eni", "x", "ski", "index", "f", "e", "oi", "li", "start", "gi", "v", "ti", "counter", "type", "ai", "yi", "b", "xi", "t", "id", "esi", "info", "uri", "zi"], "informations": ["inparations", "informings", "inspectations", "instrumentations", "incstrumentings", "incformats", "inspectators", "inceptionings", "informsals", "inpectations", "instrumentings", "incformation", "insformals", "informats", "inceptionats", "inparators", "invocats", "instrumentation", "incstrumentation", "invocations", "incformations", "informsations", "informators", "inpectals", "inspectats", "informsators", "invocation", "insformations", "informsats", "insformators", "incformings", "inparals", "informals", "information", "inpectators", "inspectals", "inceptionation", "incstrumentations", "insformats", "inparats", "incstrumentats", "instrumentats", "inceptionations", "inpectats", "invocings"], "version": ["resource", "ip", "description", "position", "channel", "comment", "language", "versions", "number", "download", "Version", "unit", "release", "install", "model", "prefix", "server", "index", "feature", "v", "page", "VERSION", "parent", "source", "ver", "uri"], "url": ["resource", "status", "position", "channel", "href", "http", "xml", "comment", "language", "URL", "path", "number", "json", "download", "address", "base", "prefix", "server", "location", "config", "image", "page", "ssl", "output", "source", "uri", "text"], "texteErreur": ["texteCurrecurred", "texteErrorrenour", "texteErbreour", "texteErreeau", "texteErrenure", "texteErroUR", "texteArrenur", "texteErruur", "texteErritau", "texteErrecurs", "texteErreeour", "texteArreurs", "texteArreur", "texteErrenau", "texteErrorreur", "texteErraser", "texteErbreaser", "texteErpreUR", "texteErreeur", "texteErrourred", "texteErreau", "texteIrreaser", "texteErrur", "texteErruries", "texteErrituries", "texteCurrecUR", "texteIrreour", "texteErreaser", "texteIrreuries", "texteErritur", "texteArreure", "texteErpreaur", "texteErrorrenur", "texteErpreurred", "texteErbreuries", "texteErrecaur", "texteErpreur", "texteErregurs", "texteCurreaur", "texteErritour", "texteErrorrenuries", "texteErrecur", "texteIrrur", "texteIrruries", "texteErreour", "texteErreaur", "texteErrorreau", "texteErrenuries", "texteErrour", "texteCurrecur", "texteErregure", "texteErrenur", "texteErreUR", "texteCurreUR", "texteErruuries", "texteErrorreour", "texteErregur", "texteErruour", "texteIrrour", "texteErruaser", "texteCurreurred", "texteCurrecaur", "texteErbreur", "texteErrecurred", "texteErrecure", "texteErrenour", "texteArrenour", "texteErreuries", "texteArrenure", "texteErregour", "texteArreour", "texteErreure", "texteIrreur", "texteArrenurs", "texteErrorreuries", "texteIrraser", "texteErreurred", "texteErrecour", "texteErreurs", "texteErrecUR", "texteErreeuries", "texteErroaur", "texteErrenurs", "texteCurreur", "texteErrorrenau"], "numErreur": ["numEreure", "numErreceur", "numErreeur", "numEREurs", "numErrenUR", "numEreurs", "numErrecurs", "numErreUR", "numErrecUR", "numSerreur", "numErrenur", "numEREur", "numSerreUR", "numEreur", "numEreeur", "numErroUR", "numErrecure", "numSerreure", "numSerrenurs", "numErrenure", "numErREurs", "numErrecur", "numErREur", "numErreurs", "numSerrenur", "numErreure", "numErroure", "numErrour", "numErREure", "numEREure", "numErrours", "numErroeur", "numSerrenUR", "numEREeur", "numErrenurs", "numSerreurs", "numErREeur", "numSerrenure"], "al": ["il", "tal", " rel", "ral", " Al", "AL", "unal", " fal", " signal", "mal", "Al", " nil", "ale", "list", "aler", " ale", " all", "l", " cal", "all", "bal", "ar", "stal", " ab", "ali", "als", " hal", "f", " bell", "af", "pal", "ul", " ul", "el", "alis", "val", " AL", "cal", "sal", "dal", "alf", "ala", "alist", "hal", "back", "oper", "alled"]}}
{"id1": "12428013", "id2": "23310397", "code1": "    public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) {\n        if (monitor != null && monitor.isCanceled()) {\n            return;\n        }\n        try {\n            ftpClient = new FTPClient();\n            ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST)));\n            ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT));\n            ftpClient.connect();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD)));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (from != null) {\n                FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false);\n                synchedSet.add(ftpHolder);\n            }\n            JobHandler.aquireFTPLock();\n            for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) {\n                if (monitor != null && monitor.isCanceled()) {\n                    JobHandler.releaseFTPLock();\n                    ftpClient.quit();\n                    return;\n                }\n                Thread.yield();\n                FTPHolder element = (FTPHolder) iter.next();\n                ftpClient.setType(FTPTransferType.ASCII);\n                ftpClient.put(element.from, element.to);\n                if (element.renameTo != null) {\n                    try {\n                        ftpClient.delete(element.renameTo);\n                    } catch (Exception e) {\n                    }\n                    ftpClient.rename(element.to, element.renameTo);\n                    log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo);\n                }\n            }\n            JobHandler.releaseFTPLock();\n            ftpClient.quit();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (FTPException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        synchedSet.clear();\n    }\n", "code2": "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        mButton1 = (Button) findViewById(R.id.myButton1);\n        mButton2 = (Button) findViewById(R.id.myButton2);\n        mTextView1 = (TextView) findViewById(R.id.myTextView1);\n        mButton1.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpPost httpRequest = new HttpPost(uriAPI);\n                List<NameValuePair> params = new ArrayList<NameValuePair>();\n                params.add(new BasicNameValuePair(\"str\", \"post string\"));\n                try {\n                    httpRequest.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n        mButton2.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpGet httpRequest = new HttpGet(uriAPI);\n                try {\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        strResult = eregi_replace(\"(\\r\\n|\\r|\\n|\\n\\r)\", \"\", strResult);\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n", "label": 0, "substitutes": {"polishOff": [" polishingOn", " synchroniceDown", " polishDown", " synchronishOn", " synchronishingOn", " synchronipeDown", " synchroniceOffline", " synchronishOffline", " polishOn", " polishOffline", " synchronishingOffline", " synchronishOff", " synchronishingOff", " polishingOff", " synchronipeOff", " synchroniceOn", " polishingOffline", " synchronipeOffline", " synchroniceOff", " polishingDown", " synchronishDown", " synchronishingDown", " synchronipeOn"], "monitor": ["timeout", "or", "reason", "watch", "status", "username", "container", "pm", "function", "cm", "m", "sm", "method", "state", "condition", "log", "report", "manager", "mor", "match", "number", "driver", "umi", "progress", "conn", "object", "client", "handler", "cher", "unit", "mc", "consumer", "program", "port", "component", "thread", "clock", "config", "loader", "processor", "control", "Monitor", "controller", "period", "don", "callback", "image", "dm", "widget", "stat", "counter", "member", "runner", "directory", "mon", "meter", "module", "annot", "duration", "timer", "message", "update", "oper", "master", "body", "core"], "from": ["resource", "action", "or", "actor", "attribute", "route", "username", "owner", "who", "at", "front", "string", "channel", "host", "false", "with", "From", "about", "path", "vol", "contact", "add", "form", "email", "ce", "user", "address", "loc", "connection", "part", "base", "since", "prefix", "server", "small", "url", "component", "left", "size", "code", "by", "start", "remote", "range", "type", "ou", "id", "back", "source", "uri", "org", "name", "origin"], "to": ["resource", "token", "so", "full", "site", "o", "go", "reply", "table", "version", "with", "about", "io", "key", "dest", "database", "user", "address", "into", "connection", "base", "pos", "TO", "out", "prefix", "two", "server", "url", "location", "To", "left", "size", "eto", "su", "value", "by", "top", "remote", "repl", "until", "range", "type", "target", "po", "info", "uri", "source", "toc", "name", "file", "ref"], "renameTo": ["renAMEto", "renAMEToken", "renameFrom", " RenAMETarget", "renenameto", " renAMETarget", "renenameFrom", "renamelOf", "renributeFor", "relenameto", "renributeTarget", "renseTo", "reameTo", "renAMEWill", "renalFrom", "renenameUrl", "renewTo", " RenseTo", " RenameTO", "relenameFrom", "renamelTO", "renokeTo", "renokeTO", "renalTarget", " RenAMEFor", "renoketo", "reageToken", "renameFor", "renamTo", "relenameTo", "relalto", "renalToken", " RenseFor", " RenameOf", "renokeOf", "relalTarget", " renAMEFrom", "renameto", "relameUrl", "renameWill", "renseOf", "renameOf", "renameToken", "renamWill", "reameTO", " RenameTarget", "relalTo", " RenseTO", " RenAMETo", "relameto", "renAMEUrl", "renAMETO", " renameFrom", "renributeWill", "renokeFrom", "reageTO", "relalFrom", "renamFor", "relameFrom", "renamelFor", "renalTO", "renageTO", "rennameTo", "reameto", "renameTO", "renalTo", " RenseOf", "renameTarget", "renageTo", "reageto", "renenameTo", "renributeTo", "rennameFrom", "renAMEFor", " renAMETo", "renageto", " RenameTo", "renAMEFrom", "renamTarget", "renageToken", "renAMETo", "renewFrom", "relameTarget", "rennameto", "renseFor", "renseTO", "renalto", "renenameTarget", " RenameFor", "renokeFor", "renewTarget", "reameToken", "renAMETarget", "renamelTo", "rennameTarget", "renameUrl", " RenAMEWill", "renokeUrl", "relenameUrl", "reageTo", " renameTarget", "relameTo", " RenameWill"], "ftpClient": [" ftpoCenter", " ftpiHost", " ftoHost", "afttStream", " fttpControl", "ftapiCloud", "ftlCommunity", "fticlient", " ftoClient", " ftnHost", "ftpcHelper", "ftcpHost", "ftpsContainer", "ftpCan", "ftmClient", "ftpoCenter", "ftapiClient", "ftpsControl", "ftpHost", "ftcpResource", "ftcServer", "ftfpResource", " ftlClient", "ftapiServer", "ftpClass", " ftpCan", "ftfpCenter", "ftcpGuest", " ftlCenter", "ftcpServer", "ftpCommunity", " ftpChannel", "ctpClient", "ftlClient", " ftpoCloud", "ftpcCloud", " ftpCloud", "ftpcServer", "ftfpCloud", " ftoCan", "ftfpClient", " ftpclient", " ftlConnection", "ftpHelper", " ftoServer", "ftbHost", "ftcclient", "ftnServer", " ftpGuest", "ctcpChannel", "ftoClient", "ftfCenter", " ftiServer", "ftnHost", "ftpiServer", "fttpStream", " ftapiHelper", "afttClient", "ftoCan", "ctpChannel", "ftlConnection", "fttpCan", "ctpServer", " ftiGuest", "ftiClient", "fttpControl", "ftoHost", "ftbrClient", " ftpControl", "ftfClient", "ftpcConnection", "ftpControl", "ftpiClient", "aftpClient", "ftmResource", "ftpcCommunity", "fttpContainer", "ctcpServer", "fttpClass", "ftpoClient", "ftnClient", " ftnClient", " ftpContainer", " ftlCommunity", "ftpServer", "ftmServer", "ftcpHelper", "ftpResource", "ftcGuest", " fttpClass", "ftpiChannel", " ftpiChannel", "ftpoCloud", "fttpHost", " fttpClient", "ftcpCloud", "ftpContainer", "ftpiHost", "ftpCenter", " fttpContainer", "ftpcContainer", "ftbrStream", "ftpConnection", " ftnServer", "ftoServer", "ftpsClass", "ftpStream", " ftiClient", " ftpConnection", " ftpServer", "ftfpChannel", " ftpiServer", "ftfpServer", "ftfCloud", " ftpiClient", "ctcpClient", "ftbServer", " ftapiClient", "ftlCenter", " ftpHelper", "fttpClient", "ftbClient", "ftpcClient", "fttpChannel", "ftcpChannel", "fttStream", " fticlient", "ftiGuest", "ftbCan", " ftpoClient", "ftpGuest", "ftcClient", " ftpHost", "ftpcClass", "fttpServer", "ftpChannel", " ftpCommunity", " ftapiCloud", "ctcpResource", " ftpCenter", "ftpcCenter", "ftcpClient", " ftapiServer", "ftmChannel", "ftpsClient", "fttClient", "ftpCloud", "ftapiHelper", " ftpClass", "ftcpclient", "ftcpCenter", "ftpclient", "ftcpConnection", "ftcpCommunity", "aftpStream", "ftpcControl", "ctpResource", "ftiServer"], "ftpHolder": ["ftpWorkolder", "ftpcWolder", "fttpChard", "ftphander", "fttpChander", "ftpShard", "ftpShook", "ftpWold", "fttpHook", "ftpcHolder", "ftpHholder", "ftpCholder", "ftphook", "ftpcWather", "ftpWholder", "ftpHook", "ftpcHold", "ftphholder", "ftpHard", "ftphard", "ftpSholder", "ftpWorkather", "ftpHather", "ftpWorkold", "ftpWolder", "ftpChander", "ftpcHholder", "ftpWorkholder", "ftpholder", "fttpCholder", "ftpWather", "ftphold", "ftpcWholder", "ftphather", "ftpChook", "ftpHander", "ftpcHather", "ftpHold", "fttpHander", "fttpHard", "ftpcWold", "fttpHolder", "fttpChook", "ftpChard", "ftpShander"], "iter": ["entry", "or", "ip", "ter", "over", "ir", "inter", "http", "ator", "former", "inner", "limit", "walker", "outer", "ner", "collect", "list", "enter", "in", "skip", "Iterator", "er", "iterator", "cher", "it", "loc", "err", "izer", "ener", "init", "chain", "coll", "ipper", "its", "oper", "index", "f", "ite", "e", "itter", "size", "i", "set", "result", "next", "finder", "ser", "reader", "Iter", "gener", "id", "info", "inc", "ver", "iv", "keep", "file", "end"], "element": ["resource", "container", "environment", "match", "email", "letter", "cell", "definition", "next", "parent", "text", "item", "entry", "or", "expression", "comment", "empty", "this", "atom", "header", "connection", "variable", "per", "air", "value", "editor", "page", "member", "output", "data", "module", "optional", "folder", "attribute", "section", "owner", "entity", "instance", "ee", "node", "content", "er", "part", "document", "coll", "component", "ele", "Element", "reader", "type", "activity", "action", "token", "line", "option", "inner", "service", "input", "layer", "key", "number", "object", "child", "event", "server", "article", "e", "el", "result", "style", "plugin", "et"]}}
{"id1": "20310134", "id2": "16557837", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "copyChannel", "CopyFiles", "copyfile", "transferFiles", "copyFiles", "CopyChannel", " copyChannel", "CopyFile", "transferChannel", "transferfile"], "in": ["In", "again", "c", "IN", "m", "ex", "inner", "bin", "input", "ic", "as", "io", "ins", "min", "inn", "l", "base", "lin", "url", "query", "work", "config", "index", "i", "image", "login", "reader", "diff", "data", "inc", "id", "source", "lock", "buffer", "name", "file"], "out": ["resource", "external", "again", "n", "c", "string", "cache", "o", "ex", "call", "Out", "io", "outs", "conn", "user", "p", "default", "connection", "w", "base", "prefix", "exec", "server", "x", "off", "image", "plain", "writer", "dot", "ext", "v", "img", "output", "page", "write", "OUT", "point", "b", "name", "file"], "inChannel": [" inchannel", "insChan", "outQueue", "outchannel", "inputChannel", "loginChannel", "insConnection", "inputStream", "InGate", "iniChannel", "binChan", "INStream", "loginchannel", "InChan", "inchannel", "binchannel", "InQueue", "INConnection", "inStream", "outStream", "loginChan", "insStream", "INChannel", "inChan", "binChannel", "loginStream", "insChannel", "INChan", "INchannel", "inQueue", "outChan", " inQueue", "binGate", "inConnection", "inputChan", "inGate", "InStream", "iniGate", "InChannel", "Inchannel", "iniChan", " inChan", "inputConnection", "iniStream", "binStream"], "outChannel": ["outputchannel", "outputChannel", " outChan", "netStream", "outchannel", "outGate", "OutChannel", "outChar", "OutConnection", "Outchannel", "ouchannel", "ouChannel", "inchannel", "outputStream", "ouGate", "outputChan", "outputGate", "inStream", "outStream", " outChar", " outConnection", "inChan", "outChan", "netGate", "OutChan", " outchannel", "inConnection", "outConnection", " outGate", "inChar", "ouChan", "inGate", "netChan", " outStream", "netChannel", "outputChar"]}}
{"id1": "18570190", "id2": "11562165", "code1": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 0, "substitutes": {"getProcess": ["showProcess", "createProcess", "getprocess", "updateJob", "updateResource", "updateProcess", "getResource", "getJob", "updateprocess", "showJob", "createResource", "showResource", "createJob", "showprocess", "createprocess"], "processId": ["taskID", "processorId", "processorid", "taskName", "ProcessID", "ProcessId", "taskId", "ProcessName", " processName", "processorID", " processID", "processid", "Processid", "processName", " processid", "processID"], "req": ["resource", "requ", "fr", "rep", "serv", "pr", "op", "request", "http", "Request", "response", "desc", "ctx", "rt", "json", "qq", "conn", "gr", "err", "proc", "app", "exec", "url", "query", "get", "f", "quest", "q", "ok", "Resp", "res", "fp", "cb", "imp", "require", "rr", "r", "obj", "sub", "info", "rx", "sq", "ref"], "resp": ["Response", "rss", "entry", "soc", "status", "rep", "inv", "fc", "serv", "respond", "rec", "rh", "request", "reply", "http", "response", "report", "ctx", "api", "feed", "json", "client", "pp", "conn", "eb", "err", "esp", "rel", "proc", "exec", "server", "coll", "exc", "sp", "f", "enc", "e", "Resp", "res", "result", "page", "html", "bb", "imp", "error", "obj", "rr", "jp", "ev", "esi", "rev", "lf", "par", "body", "re", "fr", "ref"], "xmlable": [" xmlabe", "xmlabe", "wireable", "phpabe", " xmlble", " textsafe", "playachable", "wireability", "textachable", "wireble", " adaptble", " xmlsafe", " xmlparable", " xmlability", "wireparable", "xmlsafe", " adaptabe", "phpparable", "playable", " adaptsafe", "phpble", "xmlble", "playables", "textabe", "phpachable", "xmlachable", "phpable", "xmlables", " adaptable", " textable", " textble", "phpability", "xmlparable", " textabe", "playabe", "xmlability", "textable", "phpables", "textables"], "p": ["ap", "ping", "pc", "n", "c", "g", "pi", "pb", "o", "pointer", "pid", " ap", "api", " pi", "pp", "object", "bp", "tp", "er", "ing", "l", "part", "cp", " subp", "pa", "j", "port", "f", "pkg", "e", "lp", "i", "a", "fp", "v", "P", "jp", "ps", "t", " disp", "parser", "parent", "vp"]}}
{"id1": "16851955", "id2": "23452437", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"testTrainingBackprop": ["testTrainingFrontprop", "testTrainBackdrop", "testTrainingFrontdrop", "testTrainingBACKpointer", "testTrainingBACKdrop", "testTrainingBackpointer", "testTrainingBACKpressure", "testTrainBACKpressure", "testTrainBackprop", "testTrainingFrontpointer", "testTrainBackpressure", "testTrainingBackpressure", "testTrainBACKprop", "testTrainBackpointer", "testTrainingBACKprop", "testTrainBACKdrop", "testTrainingBackdrop", "testTrainBACKpointer", "testTrainingFrontpressure"], "temp": ["folder", "txt", "wrap", "pipe", "local", "pdf", "container", "full", "zip", "clean", "cache", "current", "dat", "ex", "http", "input", "copy", "path", "io", "empty", "this", "dest", "form", "archive", "base", "out", "storage", "model", "tmp", "tem", "config", "fake", "f", "flat", "session", "emp", "writer", "v", "test", "output", "Temp", "data", "directory", "save", "stable", "porary", "mount", "parent", "buffer", "lock", "font", "cel", "file", "template"], "layers": ["lobs", " lients", "lowers", "slowers", "dlayers", "nlayers", "slays", "licikes", "placks", "Layers", "lasks", "backs", " languages", "lacks", "liayers", "slacks", "fllements", "planguages", "languages", "blayers", " lowers", "bowers", "players", "flasses", "lients", "lagers", "liacks", "liores", "gients", "lasses", " lays", "dlasks", "flanguages", "flayers", "liibraries", "likes", "licayers", "dlacks", "gayers", "Lobs", " likes", " lasks", "licagers", "bllements", " lobs", "Lients", "lores", "blanguages", "nlibraries", " lagers", "llements", "nlagers", "slayers", " libraries", "dlores", "licibraries", " lasses", "gobs", "lays", "nlikes", "plasks", "bays", "bayers", "libraries", "dlibraries", " lores", "dlanguages", " llements", " lacks", "blasses"], "fann": ["larn", "sfannon", "fain", "xfanny", "elfnn", "gana", "garn", "elfann", "fanny", "lnn", "fana", "fnn", "lann", "Fannon", "xfann", "xfannon", "lana", "xfain", "elfana", "sfann", "Fanny", "gann", "farn", "elfarn", "Fann", "gnn", "sfanny", "sfain", "Fain", "fannon"], "trainer": ["strainer", "tacker", "striner", "tracer", "rain", "Triner", "retacer", "traacer", "Tracker", "tracker", "triner", "stracker", "racker", "racer", "Trainer", "retiner", "traacker", "traainer", " tracker", "strayer", "rainer", "trayer", "stracer", " train", "tacer", "train", "retainer", "retayer", "trarain", " tracer", "trrain", "strain", "Tracer", "Trrain", "Trayer", "tainer"], "desiredError": ["desirableSize", "deservedOrder", "desciredError", "despectedProblem", "DesireException", "desidedFailure", "desizedException", "desiringError", "DesireSize", "reservedOrder", "desivedError", "desiredEvent", "descirederror", "desirableOrder", "desivedSize", "descidedFailure", "deservedError", "despectederror", "DesiredException", "reservedEvent", "resiredOrder", "desiredException", "despectedError", "descidederror", "resiredError", "desiringFailure", "designedError", "desiredFailure", "desciredFailure", "desizedSize", "descidedError", "desidedProblem", "DesiredSize", "designedOrder", "desivedException", "desirableEvent", "desirederror", "desireError", "resiredEvent", "desiredProblem", "descidedProblem", "desidedError", "desciredProblem", "despectedFailure", "desizedError", "DesiredError", "desirableError", "desiredOrder", "deservedEvent", "reservedSize", "desiredSize", "desireSize", "desireException", "DesireError", "desidederror", "desiringerror", "desiringProblem", "resiredSize", "deservedSize", "designedSize", "designedEvent", "reservedError"], "mse": ["fmce", "gmse", "fmte", "mce", " mSE", " mce", "gmge", "mte", "fmze", "Mte", "MSE", "Mze", "fSE", "fce", " mge", "fse", " mte", "mge", "gmSE", "Mse", "Mce", "fmse", "mze", " mze", "gmce", "fge", "Mge", "mSE"]}}
{"id1": "15797402", "id2": "823074", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"parse": [" transform", "wrap", "processing", "pc", "scan", " rewrite", "request", "view", "xml", "http", "cover", "service", "transform", "report", "patch", "process", " split", "print", " parsing", "rate", "replace", " parser", "fork", "Parser", " serve", "load", "read", "php", " analyse", "arse", "set", "worker", "split", " dispatch", "handle", "apply", "se", " convert", "save", "raw", " process", "pack", "parser"], "stream": ["resource", "temp", "draw", "channel", "view", "http", "inner", "src", "input", "response", "down", "feed", "in", "download", "content", "iterator", "sample", "video", "document", "Stream", "upload", "server", "url", "load", "loader", "read", "image", "through", "writer", "handle", "remote", "reader", "data", "raw", "stack", "message", "source", "client", "form", "file"], "handler": ["application", "function", "channel", "host", "pointer", "phase", "service", "response", "layer", "manager", "ctx", "di", "driver", "hand", "Handler", "default", "connection", "base", "event", "server", "loader", "processor", "controller", "wrapper", "writer", "format", "handle", "h", "reader", "data", "handled", "parser", "info", "parent", "client", "collection", "monitor"], "metadata": ["property", "resource", "attribute", "subject", "map", "management", "mx", "m", "xml", "state", "manager", "ctx", "params", "di", "meta", "database", "json", "properties", "content", "header", "runtime", "document", "metry", "connection", "storage", "component", "config", "processor", "adata", "material", "directory", "managed", "data", "mi", "mon", "md", "module", "plugin", "parser", "message", "info", "mt", "uri", "source", "collection", "met", "monitor", "template"], "context": ["resource", "txt", "entry", " Context", "subject", "cmp", "instance", "Context", "environment", "method", "request", "xml", "proxy", "scope", "concept", "manager", "ctx", "content", " contexts", "object", "translation", "command", "document", "mc", "connection", "element", "event", "component", "system", "config", "processor", "tx", "reader", "data", "kernel", "message", "parent", "text", "collection"], "name": ["Name", "names", "resource", "action", "large", "route", "class", "full", "n", "string", "m", "word", "call", "version", "comment", "named", "old", "time", "path", "label", "search", "api", "key", "none", "sync", "in", "active", "on", "no", "object", "address", "child", "missing", "default", "part", "base", "connection", "prefix", "model", "url", "work", "size", "code", "filename", "image", "ame", "NAME", "type", "data", "null", "id", "message", "job", "source", "alias", "file", "common"], "out": ["resource", "temp", "window", "line", "again", "instance", "channel", "o", "ex", "ray", "exp", "bin", "Out", "copy", "path", "manager", "io", "outs", "sync", "in", "object", "conn", "child", "user", "err", "connection", "server", "url", "cos", "pool", "image", "lib", "socket", "writer", "plain", "result", "page", "ext", "output", "data", "obj", "OUT", "null", "flush", "source", "client", "builder", "file", "extra"]}}
{"id1": "12066447", "id2": "13563706", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "label": 1, "substitutes": {"truncate": ["trrenational", "autuncator", "trunator", "tratenator", "autuncate", "autatenate", "tratenation", "trrenate", "autatenational", "trrenation", "truncational", "trunational", "truncator", "tratenate", "autatenation", "trrenator", "autatenator", "trunation", "trunate", "autuncational", "truncation", "tratenational", "autuncation"], "file": ["File", "resource", " File", "folder", "or", "body", "local", "class", "plus", "line", "function", "full", "zip", "string", "cache", "current", "http", "time", "log", "path", "io", "queue", "this", "files", "object", "ile", "address", "archive", "handler", "single", "it", "l", "connection", "base", "document", "out", "model", "future", "url", "get", "f", "FILE", "e", "per", "filename", "image", "format", "fp", "page", "directory", "type", "data", "info", "stream", "source", "binary", "uri", "name", "db", "parent", "one"], "backupRoot": ["BackbackDir", "backupPath", "backdownroot", "backdownRoot", "backureDir", "BackupDirectory", "backbaseroot", "backupDir", "BackureDirectory", "backflowFile", "Backuproot", "BackdownDirectory", "backflowRoot", "BackureDir", "backuproot", "backUpFolder", "BackupFile", "backupsroot", "frontupDir", "BackdownPath", "BackbackFile", "frontupRoot", "frontdownroot", "backdownPath", "backbackRoot", "backflowDir", "backdownDirectory", "backbackDirectory", "BackupDir", "backbackDir", "backureHome", "frontdownDir", "backbaseDirectory", "Backdownroot", "backdownFolder", "backureDirectory", "frontuproot", "backbackFile", "backupHome", "backUproot", "frontdownFolder", "BackupPath", "backbackHome", "backupsRoot", "frontupFolder", "backdownDir", "backupFolder", "backureRoot", "BackdownRoot", "backUpRoot", "backdownHome", "BackbackRoot", "backbasePath", "frontdownRoot", "backbaseRoot", "backupsDirectory", "BackupRoot", "backflowroot", "backupsDir", "backUpDir", "BackupHome", "BackureHome", "backbackroot", "BackureRoot", "backupsPath", "backdownFile", "backupsFolder", "backupDirectory", "backupFile", "Backbackroot"], "df": ["dc", "fe", "deb", "dp", "pd", "fc", "pdf", "sf", "d", "dl", "raf", "func", "da", "dn", "fd", "di", "io", " def", "cf", "fn", "def", "dict", "fs", "dd", "DF", "tf", "dt", "f", "af", "CF", "ds", "xf", "format", "dm", "fp", "data", "dq", "md", "fb", "bf", "de", "db", "fr", "flow"], "date": ["created", "stage", "day", "use", "dose", "fee", "string", "m", "dat", "ate", "d", "str", "version", "input", "ge", "time", "log", "year", "open", "modified", "ale", "sync", "days", "min", "custom", "atom", "re", "bug", "age", "valid", "rule", "tag", "out", "pe", "updated", "j", "url", "work", "x", "dt", "complete", "dates", "code", "value", "Date", "pre", "format", "output", "diff", "data", "type", "style", "module", " Date", "D", "back", "update", "message", "form", "name", "db", "create"], "zipFile": ["zipModel", "zFiles", "zipEntry", " zipFiles", "Zipfile", " zipfile", "sqlModel", "zipFiles", "ressModel", "zFile", "ZipFiles", "sqlFile", "sqlfile", "zSection", "zipSection", " zipEntry", "sqlSection", "ZipEntry", "ressfile", "ressSection", "ressFile", "zModel", "ZipFile", "zfile", "zEntry", "zipfile"], "zos": ["nz", "robe", "js", "zes", "budget", "ozo", "exit", "ses", "zen", "zip", "osi", "css", "zona", "zero", "rez", "dos", "fits", "proxy", "zn", "inos", "bitcoin", "eros", " sands", "z", "os", "outs", "iffs", "uz", "obb", "bos", "tz", "zag", "address", "nox", "liquid", "zan", "ZA", "asio", "chini", "ls", "los", "bes", "zx", "dylib", "ops", "jas", "cos", "zar", "zy", "settings", "webkit", "hess", "zo", "han", "gz", "zb", "her", "ros", "zh", "closure", "ssl", "cash", "zer", "kos", "ils", "zi", "zon", "lins", "forge", "las", "zl", "zik", "zzy"], "fis": ["rafias", "fisl", "biss", " fits", "Fias", "Fiss", " fias", "fisp", "lias", "fits", "bisl", " fisp", "lids", "Fisp", "flris", "liss", "flids", "fiz", "fils", "viz", "infils", " fiss", "infiss", "bos", "fris", "fids", "rafris", " fiz", "infis", "infiz", "vis", "vils", "Fisl", "flias", " fris", "rafiss", "flis", "Fis", "infits", "fliss", " fils", "Fos", "fos", "fias", "bis", "lis", " fisl", "Fris", " fos", "infids", "infias", "rafis", "fiss", "flisp", "vits"], "entry": ["or", "row", "ry", "si", "so", "zip", "and", "exp", "Entry", "comment", "ge", "ion", "z", "feed", "add", "key", "card", "ui", "the", "address", "letter", "archive", "ie", "it", " Entry", "cell", "element", "event", "server", "index", "per", "zo", "array", "e", "ries", "her", "image", "auto", "record", "next", "reader", "data", "se", "term", "obj", "style", "r", "de", "info", "uri", "offset", "ace", "cel", "lc", "extra"], "buffer": ["row", "seed", "position", "cache", "channel", "vector", "uffer", "padding", "comment", "layer", "shape", "wave", "sequence", "feed", "buf", "queue", "slice", "number", "pad", "FFER", "length", "address", "header", "batch", "device", "server", "Buffer", "iter", "writer", "bytes", "transfer", "page", "memory", "result", "reader", "border", "data", "bb", "null", "b", "beta", "buff", "flush", "binary", "available", "reference"], "readed": ["texted", " ReadED", "readized", "readable", "readED", "bootable", "intED", "inted", "inputned", " readned", " readized", "inputed", "intized", " Readled", " Readed", " readended", "textended", "readered", "bootED", "readled", " Readned", " Readered", " readled", "booted", "inputED", " readED", "bootered", "readned", "textED", " Readable", "intended", " readered", "textized", "readended", " readable", "inputled"]}}
{"id1": "20247400", "id2": "19849797", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"in": ["In", "pass", "token", "again", "n", "c", "IN", "din", "inner", "bin", "input", "con", "this", "ins", "inn", "p", "l", "part", "isin", "s", "win", "connection", "gin", "config", "f", "i", "nin", "a", "image", "socket", "h", "login", "reader", "diff", "data", "r", "b", "inc", "parent", "stream", "client", "source"], "out": ["temp", "group", "window", "line", "again", "cache", "channel", "word", "ex", "o", "call", "exp", "str", "comment", "inner", "Out", "msg", "log", "outer", "io", "list", "sys", "user", "conn", "err", "print", "up", "connection", "w", "prefix", "exec", "server", "pool", "dump", "i", "off", "image", "socket", "writer", "page", "v", "ext", "output", "error", "write", "obj", "OUT", "r", "debug", "style", "inc", "lock", "source", "client", "console", "name", "file", "flow"], "buffer": ["slave", "window", "channel", "cache", "context", "uffer", "limit", "bin", "pause", "input", "abi", "layer", "wave", "feed", "buf", "queue", "slice", "pad", "length", "header", "count", "batch", "document", "base", "server", "config", "size", "loader", "read", "Buffer", "f", "iter", "bar", "writer", "border", "transfer", "result", "reference", "output", "reader", "data", "null", "b", "fb", "buff", "flush", "offset", "binary", "source", "flow"]}}
{"id1": "10728243", "id2": "16549995", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"scramble411": ["scramble5", "screamprint41", "screamble411", "screamble41", "scramcy41", "scrambe5", "scrambe411", "scramble41", "screamble5", "scramcy411", "scramble123", "scramprint5", "screamprint5", "screamprint411", "scramprint411", "scramprint41", "screamprint123", "scramcy5", "scrambe123", "scramprint123", "scramcy123", "screamble123", "scrambe41"], "password": ["pass", "attribute", "token", "username", "words", "sword", "project", "string", "mac", "channel", "word", "sudo", "secret", "input", "Password", "sum", "wallet", "PASS", "path", "key", "number", "auth", "pad", "email", "wd", "user", "address", "dh", "phrase", "prefix", "security", "config", "filename", "hash", "account", "crypt", "name", "padding"], "seed": ["pass", "token", "username", "shadow", "eed", "zip", "string", "sudo", "volume", "secret", "state", "prime", "sum", "key", "slice", "driver", "pad", "finger", "pair", "length", "random", "address", "mode", "template", "alias", "device", "prefix", "phrase", "size", "machine", "Salt", "hash", "id", "pattern", "offset", "source", "crypt", "text", "name", "padding"], "md": ["dc", "df", "mb", "mg", "mp", "pd", "ms", "pm", "od", "mand", "rm", "mac", "Cmd", "m", "cm", "mem", "sm", " MD", "km", "d", "sha", "hm", "di", "MD", "bd", "meta", "doc", "wd", "ht", "mode", "hd", "ad", "om", "dd", "ld", "mc", "part", "cd", "cmd", "dh", "mn", "addr", "mag", "ma", "nd", "pkg", "am", "ds", "ind", "gd", "dm", " Md", "amd", "mi", "nm", "kg", "dig", "diff", "mm", "metadata", "vd", "po", "mad", "mt", "grad", "mid", "bm", "mo"], "passwordHashStage1": ["passwordHashstage0", "passwordHashStep2", "passwordHashstage4", "passwordHashPhase0", "passwordSumPhase0", "passwordHashstage2", "passwordHashStage3", "passwordHashstage3", "passwordSumPhase3", "passwordHashStage0", "passwordSumStageOne", "passwordHashStep1", "passwordSumPhase2", "passwordHashPhase4", "passwordHashStage4", "passwordHashPhase1", "passwordHashStageOne", "passwordSumStage3", "passwordSumStage2", "passwordSumPhaseOne", "passwordSumStage0", "passwordHashPhase3", "passwordSumStage4", "passwordHashPhase2", "passwordHashStep3", "passwordSumPhase1", "passwordSumPhase4", "passwordSumStage1", "passwordHashstage1", "passwordHashstageOne", "passwordHashPhaseOne"], "passwordHashStage2": ["passwordHashStep8", "passwordHashPhase8", "passwordHashStep2", "passwordHashstage4", "passwordBlockStage4", "passwordHashstage2", "passwordHashStep1", "passwordSumPhase2", "passwordHashPhase4", "passwordBlockstage4", "passwordHashStage4", "passwordSumStageTwo", "passwordHashPhaseTwo", "passwordBlockStage2", "passwordHashPhase1", "passwordSumPhase02", "passwordHashPhase02", "passwordBlockStage1", "passwordSumStage2", "passwordBlockstage8", "passwordHashstage8", "passwordHashStage8", "passwordBlockStage8", "passwordHashPhase2", "passwordSumPhase1", "passwordHashStageTwo", "passwordHashstageTwo", "passwordBlockstage1", "passwordSumPhaseTwo", "passwordSumStage1", "passwordBlockstage2", "passwordHashstage1", "passwordHashStage02", "passwordHashstage02", "passwordSumStage02", "passwordHashStep4"], "toBeXord": ["toBeYors", "tobeXords", "tobeXor", "toBeCrossord", "toBeZors", "tobeYor", "tobeCrossor", "toBeWorkor", "toBeXords", "tobeYorder", "toBEXord", "tobeCrossords", "toBeCrossor", "toBEXor", "toBeWorkorder", "toBEYORD", "toBEYords", "toBeXORD", "tobeXord", "toBeCrossors", "toBeZORD", "toBEXORD", "tobeCrossord", "toBEYord", "toBeYor", "toBeYORD", "tobeXorder", "toBeWorkord", "tobeCrossors", "toBeWorkords", "toBeYords", "tobeYord", "tobeYors", "toBeZorder", "toBeWorkORD", "toBeZord", "toBeYord", "toBEXords", "toBeZords", "toBeWorkors", "toBeCrossORD", "toBeXorder", "toBEYor", "toBeYorder", "toBeZor", "toBeCrossords", "tobeXors", "toBeXor", "toBeXors"], "numToXor": ["numToxor", "numtoXorer", "num2AbsOr", "numToxOR", "numtoXor", "numToCrossOR", "numToAbsOr", "numToAbsorer", "num2XOR", "numToxorer", "numToWorkorer", "numToWorkors", "num2Absorer", "numtoxorer", "numToXOr", "numtoxOR", "numToWorkor", "num2AbsOR", "numToWorkOR", "numToAbsOR", "num2XOr", "num2Xor", "numToAnyor", "numToAnyorer", "numToCrossor", "numToCrossorer", "numtoXors", "num2Absor", "num2Xorer", "numToXors", "numToCrossOr", "numToXorer", "numtoXOR", "numToAnyOR", "numToXOR", "numToCrossors", "numToAbsor", "numtoxor", "numToAnyOr", "numtoxors", "numToxors"], "i": ["hi", "si", "qi", "chi", "ip", "u", "multi", "k", "ii", "c", "m", "pi", "n", "o", "y", "d", "abi", "ci", "di", "io", "z", "key", "slice", "ui", "in", "ri", "bi", "p", "it", "l", "part", "j", "I", "x", "index", "f", "e", "oi", "li", "off", "a", "h", "v", "gi", "ti", "ai", "r", "b", "xi", "t", "id", "info", "uri", "ix"]}}
{"id1": "14473711", "id2": "23161545", "code1": "    public static String str2md5(String str) {\n        try {\n            MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE);\n            alga.update(str.getBytes());\n            byte[] digesta = alga.digest();\n            return byte2hex(digesta);\n        } catch (NoSuchAlgorithmException ex) {\n            return str;\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"str2md5": ["str2dig512", "str_MD5", "str2MDse", "str_md3", "str2md512", "str2MD3", "str_MDse", "str_md5", "str_MD3", "str2mdse", "str2MD512", "str2digse", "str2dig5", "str_md512", "str_MD512", "str2h3", "str2hse", "str2MD5", "str2h512", "str_mdse", "str2h5", "str2md3", "str2dig3"], "str": ["txt", "pass", "kr", "string", "exp", "spec", "inner", "input", "msg", "empty", "char", "hex", "sr", "in", "STR", "tr", "er", "p", "err", "br", "dict", "cr", "s", "strings", "arr", "url", "sp", "dr", "enc", "f", "code", "i", "format", "bytes", "result", "test", "st", "data", "obj", "r", "t", "buffer", "Str", "text", "source", "name", "fr"], "alga": ["alsqa", "ALca", "alqa", " alda", "elda", "ALa", " ala", "Algas", "ALda", "ela", "ALja", "alja", "alsa", "elga", "Alja", " algas", "ALqa", " alca", "alsda", "algas", "ALsa", "alsga", "alda", "ALgas", "ALga", "Alga", " alsa", "alsca", " alqa", "elgas", "ala", " alja", "Alsa", "alca"], "digesta": ["badza", "codza", "badesta", "igera", "digosta", "igosta", "digsta", "igesta", "badosta", "diffsta", "igza", "codesta", "codera", "finsta", "fineste", "badera", "codosta", "finosta", "diffeste", "finesta", "digeste", "diffosta", "codsta", "codeste", "diffesta", "digera", "digza"]}}
{"id1": "7891509", "id2": "17901739", "code1": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "code2": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "label": 1, "substitutes": {"pageAddress": ["urlAddress", "PageAddress", "pageUrl", "PageName", " pageLocation", "urlLocation", "Pageaddress", "siteAddress", "urladdress", "siteUrl", "resourceaddress", "resourceAddress", "resourceUrl", "pageaddress", "pageLocation", " pageUrl", " pageName", "urlUrl", "siteName", "pageName", "PageUrl", "siteLocation", "PageLocation", "resourceLocation"], "url": ["resource", "string", "channel", "host", "http", "service", "URL", "feed", "open", "this", "Url", "client", "object", "user", "address", "browser", "l", "connection", "base", "out", "ls", "element", "server", "loader", "sl", "f", "i", "image", "socket", "page", "ssl", "bb", "reader", "data", "r", "b", "plugin", "web", "uri", "stream", "source", "file"], "in": ["resource", "In", "token", "line", "again", "ini", "c", "IN", "rec", "din", "inner", "bin", "input", "as", "ins", "client", "impl", "min", "conn", "inn", "into", "err", "kin", "l", "isin", "init", "s", "win", "out", "gin", "read", "f", "inside", "i", "nin", "socket", "login", "ssl", "reader", "data", "r", "b", "inc", "id", "buffer", "stream", "source", "file"], "inputLine": ["InputLine", "selectFile", "rawLine", "imageCell", "pageline", "pageUrl", "InputCell", "pageString", "inputFile", "inputContent", " inputL", " inputPage", " inputline", " inputContent", " inputFile", "pageLine", "inputString", "selectPage", "rawFile", " inputString", "inputUrl", "inputL", " inputUrl", "rawString", "selectLine", "imageFile", "imageLine", "imageL", "inputline", "InputFile", " inputCell", "inputPage", "rawPage", "rawUrl", "rawContent", "rawline", "InputL", "selectContent", "inputCell"]}}
{"id1": "494226", "id2": "13063241", "code1": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"linesep": ["timeseps", "linpace", "linedew", "linesearch", "linesupp", "linesew", "linep", "linspec", "linerspec", "timesep", "geseps", "lineupp", "linersew", "codeseps", "lineps", "linepace", " linesupp", "codesep", "lineseper", "linsew", "nsep", "nseps", " lineseng", " linesearch", "linedip", "linerseter", "linedep", "linersip", "linersearch", "linesip", "inesep", "timesyp", "ringsep", "linerseps", "codesip", "lineeps", "lineearch", "linseng", "linpe", "linesaper", " lineseper", " linesew", " lineseter", "linespe", "linespec", "linerseng", "linyp", "gesyp", "gespe", "linepec", "codesew", "linesyp", "linspace", "gesep", "linsep", "timespe", "linseps", "linespace", "inesaper", "linersep", "ringsupp", " linespace", "ineseps", " lineseps", "linseter", "nsaper", " linesaper", "lineseps", "ineseper", "lineep", " linespec", "lineseter", "nseper", "ringspace", "linpec", "ringspec", "linedeps", "lineseng"], "fos": ["eo", "Foses", "FOs", "zol", "forats", " fOS", "infotes", "fios", "fullis", "goss", "fops", "infops", " fios", "infoses", "pols", "fulloes", "focks", "Foss", "infol", " fOs", "loadOs", "fingoss", "foros", " fats", "infoes", "eos", "Fes", "fats", "fo", " fops", "fingos", "fulloser", " fes", "infis", "Focks", "poos", "foes", "fotes", "foses", "fes", "cols", "Fos", "zotes", "Fios", "eotes", "foss", "Foser", "fol", "go", "coos", "fols", " foS", "fingocks", "Fops", "cos", "infols", " foser", "loadops", "Fis", "loados", "coes", "Fats", " fis", "forOS", "Fo", "foroses", " foes", "foser", "infios", "eol", "fingo", "gos", " foses", "infos", "foos", "poes", " fo", "foS", "pos", "gocks", "FoS", "fOS", "fullos", "zo", "infoos", "fis", "FOS", "zos", "fOs", "infes", "Foes", "info", "loadoS"], "files": ["pages", "boxes", "names", "classes", "books", "bs", "bugs", "resources", "lines", "apps", "results", "http", "ids", "headers", "images", "tools", "objects", "events", "ins", "groups", "members", "plugins", "locks", "fs", "facts", "tests", "l", "obs", "strings", "ls", "projects", "balls", "scenes", "ports", "f", "services", "keys", "thumbnails", "blocks", "features", "archives", "rules", "states", "data", "items", "docs", "Files", "iles", "rows", "workers", "users", "jobs", "lets", "file", "models"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "ini", "ii", "c", "m", "pi", "current", "col", "y", "d", "inner", "ci", "di", "io", "z", "slice", "ji", "ui", "ri", "count", "ie", "it", "p", "phi", "j", "I", "fi", "eni", "index", "f", "e", "oi", "li", "start", "v", "gi", "ti", "type", "ai", "yi", "b", "xi", "t", "id", "info", "uri", "ix"], "metaprops": ["metaporeps", "metopproperties", "metepropps", "metaparpps", "metepprops", "metappropp", "metoppropps", "metaproperties", "metepropes", "metaprobps", "metaparp", "metaprospes", "metapropp", "metaprope", "metoprop", "meteprope", "meteppropes", "metapPropps", "meteppropps", "metapPrope", "metoprops", "metaporepe", "metapropps", "metapproperties", "metaporepps", "metapprops", "metopropes", "metaprobperties", "metaprpe", "metaprosps", "metaprobpp", "metappropes", "metaprop", "metopprops", "metaprobpps", "metaprobpe", "metappropps", "metaprobp", "metoppropes", "metaparpp", "metapprop", "meteprops", "metaprobpes", "metaprospps", "metapProps", "metapropes", "metoproperties", "metoppropp", "metaparps", "metepprope", "metapPropes", "metoprope", "metaporepes", "metopropps", "metopprope", "metopropp", "metaprosperties", "metopprop", "metaprpes", "metaprpps", "metaprps", "metapprope"], "itsect": ["itssect", "litect", " itsection", " itna", "itconnect", "litna", "itersect", "itna", "itrupt", " itect", "itssector", "Itect", " itconnect", "iterconnect", "Itsection", "itssection", "iterrupt", "itsection", "litsect", "Itrupt", " itrupt", "Itna", "Itsector", "itect", "Itsect", " itsector", "itsector", "Itconnect", "litrupt", "iterect"], "section": ["entry", "route", "line", "function", "description", "string", "step", "environment", "version", "script", "area", "service", "ion", "ect", "search", "year", "division", "key", "vision", "second", "child", "mission", "header", "loc", "ie", "sect", "part", "rc", "element", "j", "config", " Section", "array", "sec", "Section", "set", "protection", "sector", " sections", "page", "closure", " subsection", "esc", "job", "sub", "account", "edition", "text", "ection", "name", "sections"]}}
{"id1": "11840277", "id2": "18358467", "code1": "    protected static void clearTables() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"delete from Objects\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (1, 'Money value')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (2, 'Date')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (3, 'Unix path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (4, 'Dos path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (5, 'Time')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (6, 'IP address')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (7, 'Internet hostname')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (8, 'Number')\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public DocumentSummary parseDocument(URL url) throws IOException, DocumentHandlerException {\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n            POIOLE2TextExtractor extractor = createExtractor(inputStream);\n            SummaryInformation info = extractor.getSummaryInformation();\n            DocumentSummary docSummary = new DocumentSummary();\n            docSummary.authors = DocSummaryPOIFSReaderListener.getAuthors(info);\n            docSummary.contentReader = new StringReader(extractor.getText());\n            docSummary.creationDate = info.getCreateDateTime();\n            docSummary.keywords = new ArrayList();\n            docSummary.keywords.add(info.getKeywords());\n            docSummary.modificationDate = new Date(info.getEditTime());\n            docSummary.title = info.getTitle();\n            return docSummary;\n        } catch (IOException e) {\n            if (e.getMessage().startsWith(\"Unable to read entire header\")) {\n                throw new DocumentHandlerException(\"Couldn't process document\", e);\n            } else {\n                throw e;\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"clearTables": ["cacheTableows", "clearTings", "clearBables", "cacheTows", "cacheTableings", "cacheTations", "createTaces", "clearTaches", "clearTableations", "clearContables", "createStaces", "createStables", "clearBings", "clearBaces", "clearTableables", "createTows", "clearTations", "clearTaces", "createTables", "cacheTings", "clearTableings", "clearTableows", "clearContows", "createStaches", "clearBations", "cacheTableations", "cacheTables", "cacheTableables", "createStows", "clearContaches", "clearStaches", "clearTemables", "clearStables", "clearTemings", "clearContaces", "clearTemations", "clearTows", "createTaches", "clearStows", "clearBaches", "clearStaces", "clearTemows", "clearBows"], "conn": ["dc", "ch", "sth", "cmp", "cat", "cm", "n", "c", "Connection", "cache", "act", "ca", "pg", "col", "ob", "Conn", "ann", "state", "oss", "ci", "path", "log", "con", "dn", "ctx", "di", "co", "open", "Connect", "ct", "cf", "oci", "ac", "client", "wd", "sql", "loc", "p", "cc", "connection", "mc", "cn", "cond", "cp", "rc", "exec", "coll", "server", "config", "enc", "session", "ns", "pub", "h", "close", "cb", "ssl", "nt", "bb", "error", "ou", "ai", "obj", "conf", "nc", "jc", "lock", "connect", "mt", "org", "db", "lc"], "stmt": ["stmd", "ctr", "stbm", "stm", "playmt", "strmt", "actmi", "putma", " stmi", "stgr", "stql", "est", "sswt", "istmt", "STwd", "STlt", "stsmt", "stml", "ssbm", "stap", " stct", "ldmt", "Stnt", "putMT", "stwt", "STMT", "istmn", "Stmi", "puttor", "dm", "STgr", "stmi", "ctmt", "ftlt", "STbm", "STmn", " stql", "strlt", "dql", " stml", "stma", "estmm", "stager", "stst", " stager", "STprint", "str", "putlt", "Stmd", "ssmt", "ldmn", "stsprint", " stnt", "Stmn", "ldma", " stma", "STmd", "stswd", "Stap", "actmn", "putbm", "ctgr", " stlt", "ctmd", "Stwt", "putmt", "putager", "ctql", "ftmn", "tm", "STmt", "ftmt", "putml", "putm", "stprint", " stgr", " stmc", "Sttor", "playtor", "putmm", "sttor", " stmn", "stnt", "Stmm", "StMT", "strMT", "dmt", "istMT", "stmc", "eprint", "stMT", "STst", "ldager", "actmt", "stmm", "playtx", "puttx", " stap", "stlt", "putwt", "estmt", " str", "tnt", "Stml", "ctm", "Stmc", " stwt", "stwd", "actnt", "STmc", "Stmt", "emt", "estm", "stct", " stbm", "tmt", "Stct", "ssmn", "ftbm", "putap", "sttx", "dr", "Stgr", " stmd", "Stm", "putmn", "stmn", "istgr", "estwt", "Stlt", "playwt", "stsst", "strml", "Sttx", " stm", "ewd", "tct"]}}
{"id1": "11082670", "id2": "6517139", "code1": "    @SuppressWarnings(\"unchecked\")\n    public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException {\n        StringBuilder json = new StringBuilder();\n        String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n        try {\n            URL url = new URL(requestUrl.toString());\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                json.append(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            throw new GtugsException(e);\n        }\n        List<Event> events = new ArrayList<Event>();\n        JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString());\n        JSONArray results = (JSONArray) jsonObj.get(\"results\");\n        for (int i = 0; i < results.size(); i++) {\n            JSONObject result = (JSONObject) results.get(i);\n            Event e = new Event();\n            e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\")));\n            e.setCity((String) result.get(\"venue_city\"));\n            e.setDescription((String) result.get(\"description\"));\n            e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\")));\n            e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\")));\n            e.setName((String) result.get(\"name\"));\n            Date myDate = null;\n            String time = (String) result.get(\"time\");\n            try {\n                myDate = meetupDateFormat.parse(time);\n                e.setStartTime(timeDateFormat.format(myDate));\n                e.setEndTime(timeDateFormat.format(myDate));\n                e.setStartDate(myDate);\n                e.setEndDate(myDate);\n                String tz = tzDateFormat.format(myDate);\n                if (tz != null && tz.startsWith(\"+\")) {\n                    tz = tz.substring(1);\n                }\n                e.setTimeZone(Integer.toString(Integer.parseInt(tz) / 100));\n            } catch (ParseException ex) {\n                ex.printStackTrace();\n                continue;\n            }\n            e.setState((String) result.get(\"venue_state\"));\n            StringBuilder addressBuilder = new StringBuilder();\n            if (result.get(\"venue_address1\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address1\") + \" \");\n            }\n            if (result.get(\"venue_address2\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address2\") + \" \");\n            }\n            if (result.get(\"venue_address3\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address3\") + \" \");\n            }\n            if (result.get(\"venue_address4\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address4\"));\n            }\n            e.setStreetAddress(addressBuilder.toString().trim());\n            e.setZipCode((String) result.get(\"venue_zip\"));\n            e.setUrl((String) result.get(\"event_url\"));\n            events.add(e);\n        }\n        return events;\n    }\n", "code2": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "label": 0, "substitutes": {"lookupFutureEvents": ["lookUpupItems", "lookupFutureEvent", "lookupFutureItems", "lookUpFutureEvents", "lookupRequestEvents", "lookupAllEvent", "lookupupEvent", "lookupupItems", "lookupRequestItems", "lookUpupEvents", "lookupRequestEvent", "lookUpFutureItems", "lookUpFutureEvent", "lookUpupEvent", "lookupAllEvents", "lookupAllItems", "lookupupEvents"], "groupIdentifier": ["groupSequifer", " groupIdentizer", "groupIdizer", "groupSequifier", "groupIdifer", "groupidentifiers", "groupidentifier", "groupidentizer", "groupSequification", "groupIdentifer", " groupIdentification", " groupIdentifiers", "groupSequifiers", "groupIdentification", "groupidentification", " groupIdentifer", "groupIdentifiers", "groupIdentizer", "groupIdifier", "groupidentifer", "groupIdifiers"], "json": ["struct", "rss", "txt", "status", "js", "token", "JSON", " JSON", "description", "zip", "string", "jack", "request", "photo", "http", "xml", "response", "input", "api", "io", "key", "list", "son", "sql", "build", "j", "server", "query", "twitter", "array", "value", "journal", "html", "ssl", "output", "data", "obj", "id", "message", "info", "text", "body"], "requestUrl": ["responseUrl", "responseName", " requestName", "requestAddress", "downloadUrl", "requestURL", "responseStr", " requestAddress", "downloadURL", " requestURL", "RequestURL", "downloadAddress", " requestUr", "responseURL", "requestName", "RequestUrl", "requestUr", "downloadUr", "RequestName", " requestStr", "RequestAddress", "RequestUr", "RequestStr", "requestStr"], "url": ["resource", "string", "channel", "http", "service", "input", "URL", "path", "api", "open", "io", "gl", "Url", "client", "rl", "user", "address", "l", "connection", "rule", "base", "event", "server", "sl", "f", "hub", "image", "socket", "ssl", "data", "web", "uri", "stream", "buffer", "source", "org", "file"], "in": ["In", "line", "again", "serv", "ini", "c", "IN", "is", "din", "inner", "bin", "input", "io", "ins", "impl", "min", "inn", "er", "into", "err", "l", "init", "s", "lin", "out", "gin", "read", "f", "image", "login", "ssl", "reader", "data", "r", "b", "inc", "id", "buffer", "stream", "source", "re", "fr"], "inputLine": ["InputLine", "controlLine", "audioLine", "eventText", " inputline", "inputText", "eventStream", " inputL", " inputStream", "inputStream", "outputline", "requestLine", "inputUrl", "inputL", " inputUrl", "eventline", "outputStream", "inputBlock", "eventLine", "controlStream", "audioUrl", "inputline", "requestBlock", "outputBlock", "outputText", "audioL", " inputText", "controlL", "InputUrl", "InputL", "requestStream", "requestL", "outputLine", "controlBlock", "outputL"], "events": ["reports", "pages", "views", "times", "lines", "errors", "ents", "files", "groups", "members", "plugins", "forms", "tests", "effects", "actions", "Events", "services", "dates", "fires", "features", "archives", "items", "comments", "es", "lists", "issues", "rows"], "jsonObj": ["JSONObject", "JSONExt", "sonObj", "xmlObject", "jsonobj", "xmlAct", "jsonExt", "jsonArray", "responseAct", "responseObject", "responseobj", "jsonObject", "JSONObj", "JSONAct", "JSONobj", "sonArray", "responseObj", "jsonAct", "xmlObj", "xmlExt", "xmlobj", "xmlArray", "sonobj", "JSONArray", "sonExt"], "results": ["reports", "pages", "words", "ings", "Result", "stats", "times", " Results", "resources", "values", "errors", "roads", "terms", "response", "objects", "details", "shows", "Results", "groups", "changes", "RESULTS", "successful", "tests", "ventures", "qs", "Events", "its", "dates", "vers", "ries", "ions", "res", "features", "vals", "output", "rules", "data", "items", "r", "es", "products", "runs", "rows"], "i": ["iu", "hi", "si", "chi", "qi", "ip", "u", "multi", "n", "ii", "c", "ini", "pi", "inner", "ci", "di", "io", "slice", "vi", "ui", "ji", "ri", "bi", "ie", "p", "phi", "j", "I", "fi", "x", "eni", "index", "f", "oi", "li", "ori", "h", "v", "gi", "ti", "ai", "yi", "b", "xi", "id", "info", "uri", "ix", "mu", "uni"], "result": ["resource", "entry", "row", "role", "plus", "status", "section", "function", "Result", "particip", "rh", "request", "venture", "view", "comment", "response", "report", "manager", "search", "ner", "match", "details", "sr", "user", "err", "goal", "profile", "successful", "rule", "default", "part", "order", "element", "event", "query", "game", "complete", "date", "session", "success", "feature", "record", "res", "page", "output", "error", "data", "product", "term", "found", "r", "style", "job", "message", "info", "back", "ver"], "e": ["eu", "fe", "g", "m", "none", "enter", "ce", "p", "l", "s", "E", "ne", "v", "error", "de", "t", "ec", "es", "or", "entry", "c", "oe", "o", "y", "d", "die", "ea", "pe", "element", "exc", "ga", "office", "ep", "ae", "eve", "esi", "en", "one", "end", "je", "entity", "n", "see", "te", "ee", "ed", "er", "ie", "ception", "j", "complete", "f", "ele", "ze", "ev", "r", "line", "u", "le", "ge", "be", "eb", "err", "it", "ente", "event", "ffe", "ite", "ye", "el", "se", "b", "me"], "myDate": ["homeDate", "myYear", "MYDat", "MYDay", "homedate", " myTime", "MYTime", "myDat", "anyDate", "myTime", "anyTime", "yourDate", "yourTime", "myDay", "homeTime", "MyDate", "yourDat", "anyDat", "MYDate", "homeDat", "MyDay", " myDat", "MyDat", "MyTime", " myYear", "yourdate", " myDay", "yourDay", "mydate", "yourYear", "anyYear", "anydate"], "time": ["timeout", "live", "etime", "times", "string", "host", "hour", "depth", "money", "week", "year", "length", "Time", "loc", "rate", "location", "work", "clock", "size", "price", "date", "TIME", "code", "am", "value", "home", "rice", "image", "start", "tim", "ime", "data", "type", "duration", "id", "message", "timer", "text", "name"], "tz": [" offset", " zones", " loc", "etime", "Clock", "hour", "UTC", "hh", "z", " hour", "zone", " zone", "Offset", " clock", " schedule", "loc", " timestamp", "Zone", "clock", " interval", " GMT", "Timeout", "Delta", " locale", "GMT", "zz", "offset", "Z", "tc"]}}
{"id1": "10383721", "id2": "9846843", "code1": "    @SuppressWarnings(\"unchecked\")\n    private ReaderFeed processEntrys(String urlStr, String currentFlag) throws UnsupportedEncodingException, IOException, JDOMException {\n        String key = \"processEntrys@\" + urlStr + \"_\" + currentFlag;\n        if (cache.containsKey(key)) {\n            return (ReaderFeed) cache.get(key);\n        }\n        List<Post> postList = new ArrayList<Post>();\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Cookie\", \"SID=\" + sid);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n        SAXBuilder builder = new SAXBuilder(false);\n        Document doc = builder.build(reader);\n        Element root = doc.getRootElement();\n        Namespace grNamespace = root.getNamespace(\"gr\");\n        Namespace namespace = root.getNamespace();\n        String newflag = root.getChildText(\"continuation\", grNamespace);\n        String title = root.getChildText(\"title\", namespace);\n        String subTitle = root.getChildText(\"subtitle\", namespace);\n        List<Element> entryList = root.getChildren(\"entry\", namespace);\n        DateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n        for (Element e : entryList) {\n            Post post = new Post();\n            post.setTitle(e.getChildText(\"title\", namespace));\n            try {\n                post.setDate(sdf.parse(e.getChildText(\"published\", namespace)));\n            } catch (ParseException e1) {\n            }\n            post.setUrl(e.getChild(\"link\", namespace).getAttributeValue(\"href\"));\n            post.setSauthor(e.getChild(\"author\", namespace).getChildText(\"name\", namespace));\n            String content = e.getChildText(\"content\", namespace);\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"description\", namespace);\n            }\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"summary\", namespace);\n            }\n            post.setContent(content);\n            postList.add(post);\n        }\n        ReaderFeed readerFeed = new ReaderFeed();\n        readerFeed.setTitle(title);\n        readerFeed.setSubTitle(subTitle);\n        readerFeed.setFlag(newflag);\n        readerFeed.setPostList(postList);\n        cache.put(key, readerFeed);\n        return readerFeed;\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 0, "substitutes": {"processEntrys": ["processEllrys", "processEllrings", "processDistris", "processENTrys", "runENTrings", "processEllriers", "runEntriers", "processENTrings", "runEntrings", "runENTris", "runENTriers", "processENTriers", "processEllris", "processENTris", "processEntris", "runEntris", "runEntrys", "processEntriers", "processDistrys", "processDistrings", "runENTrys", "processEntrings", "processDistriers"], "urlStr": ["httpStr", "uriSTR", "URLSTR", "uriString", "urlstr", "URLSt", " urlString", "httpstr", "filestr", "urlSTR", "resourcestr", "Urlstr", "URLStr", "URLString", "uriSt", "urlSt", "resourceSTR", " urlSTR", "UrlStr", "httpString", "uriStr", " urlSt", "resourceStr", "httpSTR", "urlString", " urlstr", "fileSTR", "fileStr", "UrlSTR", "resourceString"], "currentFlag": ["nextFlag", "currentText", "reportedField", "activeflag", "nextflag", "CurrentText", "currentField", "currentTag", "nextTag", "currentFLAG", "activeFlag", "CurrentField", "currentBit", " currentBit", "reportedBit", "reportedFlag", " currentText", " currentField", "reportedText", "CurrentTag", "activeTag", "Currentflag", "CurrentBit", "CurrentFlag", "currentflag", "CurrentFLAG", "nextFLAG", "activeFLAG"], "key": ["entry", "or", "ry", "section", "Key", "function", "seed", "fee", "k", "string", "cache", "mac", "step", "kid", "full", "method", "exp", "secret", "ey", "str", "scope", "service", "msg", "path", "search", "match", "KEY", "list", "empty", "ie", "rule", "part", "fix", "base", "prefix", "query", "keys", "field", "value", "roy", "check", "hash", "lease", "here", "type", "data", "point", "id", "message", "parent", "lock", "sign", "text", "ace", "name"], "postList": ["postCollection", "Postlist", " postlist", "POSTGroup", " postCollection", "POSTlist", "postlist", " postGroup", "PostGroup", "PostCollection", "postGroup", "POSTCollection", "POSTList", "PostList"], "url": ["resource", "entry", "string", "cache", "host", "channel", "http", "proxy", "service", "www", "URL", "path", "log", "ur", "feed", "text", "Url", "conn", "address", "build", "loc", "l", "base", "server", "location", "sl", "link", "director", "image", "socket", "page", "ssl", "data", "web", "uri", "client", "org", "file"], "connection": ["resource", "application", "section", " Connection", "function", "position", "c", "Connection", "channel", "http", "proxy", "character", "condition", "response", "URL", "con", "io", "open", "number", "database", "relation", "conn", "object", "creator", "handler", "l", "document", "out", "communication", "server", "config", "machine", "wrapper", "director", "password", "connect", "socket", "to", "writer", "remote", "directory", "b", "connected", "uri", "client", "body", "collection", "version"], "reader": ["resource", "entry", "row", "channel", "reading", "oder", "xml", "ler", "input", "io", "feed", "driver", "er", "handler", "document", "server", "loader", "read", "Reader", "per", "iter", "f", "editor", "writer", "data", "r", "parser", "buffer", "stream", "client", "body", "file"], "builder": ["entry", "row", "or", "xml", "http", "manager", "builders", "driver", "database", "bridge", "creator", "keeper", "bug", "build", "er", "default", "document", "base", "config", "loader", "building", "bean", "wrapper", "Builder", "image", "editor", "writer", "result", "runner", "r", "b", "parser", "info", "buffer", "client", "db"], "doc": ["dc", "resource", "df", "ger", "project", "Doc", "context", "xml", "d", "str", "node", "open", "tree", "div", "dir", "bug", "build", "doctor", "app", "document", "base", "coll", "dr", "f", "graph", "lib", "writer", "html", "gen", "data", "docs", "md", "r", "parser", "info", "git", "text", "body", "db", "file"], "root": ["container", "zero", "http", "scope", "right", "manager", "valid", "rup", "rew", "writer", "html", "error", "parent", "ver", "body", "db", "entry", "bot", "rec", "comment", "outer", "empty", "tree", "rt", "user", "roots", "element", "nav", "record", "page", "data", "null", "parser", "master", "leaf", "section", "owner", "project", "front", "n", "xml", "node", "sys", "first", "div", "creator", "archive", "default", "document", "query", "component", "ree", "home", "top", "author", "r", "name", "rss", "string", "inner", "cover", "path", "box", "Root", "child", "server", "loader", "article", "director", "head", "remote", "result", "back"], "grNamespace": ["grNamescape", "grMemberspaces", "grnamescape", "Grnamespe", "Grnamescape", "grMemberspace", "grMemberspaced", "grNamespe", "GrNamesche", "grMembersche", "GrNamespaced", "grnamespe", "GrNamespe", "Grnamespaces", "grnamespace", "grnamespaces", "grNamesche", "grnamespaced", "GrNamescape", "GrNamespaces", "grnamesche", "Grnamespace", "GrNamespace", "grNamespaced", "grNamespaces"], "namespace": ["namespect", "Namespaced", "kespaced", "http", "namespaced", "workspaces", "memberscore", "memberspace", " namespec", "membersace", "s", "Namesception", "membersternal", "Namesace", "Namespaces", "namesase", "inaspace", "worksception", "Namespect", "technspace", " namescore", " Namespaced", "Namesase", "namesspace", "feed", "add", "this", "namespaces", "technpace", "inasternal", "Namesspace", "namecape", "namesace", "namescape", "Namesternal", "_", " Namespec", "namepaces", "Namespace", "xml", "inasspace", "Namescape", " namescape", " Namespaces", "namespec", " namesspace", " Namespace", "nameception", "workspace", "membersspace", " namespaces", "namepace", "namescore", "New", "kesase", "namesternal", "namesception", " namesace", "memberspaces", "inasace", "workspect", "memberscape", "Namescore", " namesception", "nameternal", " namesternal", "Namespec", " namespaced", " namesase", "kespace", " namespect"], "newflag": [" newstyle", " newStatus", " newFlag", "newstyle", "lnFlag", "nextFlag", "lnflag", "nextflag", "lnStatus", "nextStatus", "lnstyle", "newStatus", "nextstyle", "newFlag"], "title": ["resource", "Title", "subject", "itle", "description", "published", "version", "label", "details", "summary", "header", "template", "Content", "license", "filename", "format", "html", "author", "type", "term", "message", "text", "body", "name", "itles"], "subTitle": ["SubDescription", "subDescription", "ubName", "ubDescription", "subName", " subtitle", "SubTitle", "Subtitle", "ubTitle", "subtitle", " subName", "SubName", " subDescription", "ubtitle"], "entryList": ["elementList", "elementlist", "entryL", "postlist", "ziplist", "trylist", " entrylist", "zipLIST", "tryQueue", "postL", "elementChain", "entryLIST", " entryChain", "zipList", "elementQueue", "entrylist", "entryQueue", " entryQueue", " entryLIST", "tryList", "tryChain", "zipL", "entryChain", " entryL", "postLIST"], "sdf": ["rsfd", " scf", "ssde", "Sdf", "asde", "rsdd", "asdd", "asdf", "pscf", " sde", "rsdf", "Sfd", "ascf", "rsde", "ssdd", "ssdf", "psde", "psdf", "scf", "ssfd", "sdd", " sdd", "Sde", "psdd", "sfd", "sde", "Sdd"], "e": ["eu", "entry", "je", "entity", " me", "line", "n", "c", "oe", "m", " event", "o", "y", "te", "pse", " entity", "d", "ee", "le", "node", "ge", "be", "ve", " ie", "enter", " E", "ce", "ed", "er", "eb", "ie", "p", "l", "ea", "ente", "element", "j", "event", "f", "E", " pe", "ele", "i", "ze", "el", "ne", "Element", "se", "ae", " element", "r", "esi", "en", "t", "de", "ec", "me", "one", "edge", "end"], "post": ["entry", "row", "pass", "draw", "cross", "project", "push", "op", "POST", "ost", "comment", "node", "copy", "feed", "patch", "list", "add", "edit", "the", "maybe", "user", "child", "object", "archive", "wp", "p", "valid", "default", "part", "mod", "tax", "install", "upload", "server", "get", "load", "system", "Post", "read", "index", "article", "link", "posted", "set", "head", "pre", "home", "check", "record", "page", "result", "next", "author", "posts", "pod", "style", "text", "form", "one", "create"], "content": ["resource", "status", "media", "description", "script", "language", "path", "summary", "archive", "header", "Content", "size", "name", "code", "value", "image", "draft", "page", "output", "data", "comments", "message", "source", "text", "body", "version", "file", "template"]}}
{"id1": "19810820", "id2": "19322910", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    @Test\n    public void test_blueprintTypeByTypeID() throws Exception {\n        URL url = new URL(baseUrl + \"/blueprintTypeByTypeID/20188\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"{\\\"blueprintTypeID\\\":20188,\\\"blueprintTypeName\\\":\\\"Obelisk Blueprint\\\",\\\"productTypeID\\\":20187,\\\"productTypeName\\\":\\\"Obelisk\\\",\\\"productCategoryID\\\":6,\\\"techLevel\\\":1,\\\"productionTime\\\":1280000,\\\"researchProductivityTime\\\":7680000,\\\"researchMaterialTime\\\":5120000,\\\"researchCopyTime\\\":2560000,\\\"researchTechTime\\\":500000,\\\"productivityModifier\\\":256000,\\\"wasteFactor\\\":10,\\\"maxProductionLimit\\\":1,\\\"productVolume\\\":\\\"17550000\\\",\\\"productPortionSize\\\":1,\\\"dumpVersion\\\":\\\"cru16\\\"}\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n        connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/xml\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?><invBlueprintTypeDto><blueprintTypeID>20188</blueprintTypeID><blueprintTypeName>Obelisk Blueprint</blueprintTypeName><dumpVersion>cru16</dumpVersion><maxProductionLimit>1</maxProductionLimit><productCategoryID>6</productCategoryID><productPortionSize>1</productPortionSize><productTypeID>20187</productTypeID><productTypeName>Obelisk</productTypeName><productVolume>17550000</productVolume><productionTime>1280000</productionTime><productivityModifier>256000</productivityModifier><researchCopyTime>2560000</researchCopyTime><researchMaterialTime>5120000</researchMaterialTime><researchProductivityTime>7680000</researchProductivityTime><researchTechTime>500000</researchTechTime><techLevel>1</techLevel><wasteFactor>10</wasteFactor></invBlueprintTypeDto>\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/xml; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"copyFileChannel": ["transferfilechannel", "copyStreamchannel", "copyStreamChannel", "transferfileStream", "transferFileStream", "transferfileChan", "copyFileStream", "copyDirectoryChan", "copyFilechannel", "copyDirectorychannel", "transferfileChannel", "copyDirectoryStream", "copyFileChan", "transferFileChannel", "copyDirectoryChannel", "copyfilechannel", "copyfileStream", "copyStreamStream", "transferFilechannel", "copyStreamChan", "copyfileChannel", "transferFileChan", "copyfileChan"], "src": ["scene", "sth", "ses", "rest", "Source", "ruby", "dist", "input", "func", "path", "ctx", "inst", "lower", "sc", "slice", "sys", "dest", "sync", "download", "client", "conn", "loc", "sup", "s", "rc", "ls", "upload", "server", "url", "cur", "tmp", "config", "sl", "sb", "filename", "SOURCE", "start", "sin", "ssl", "img", "RC", "st", "b", "sub", "sit", "source", "stream", "rs", "sel", "rb", "sq"], "dst": ["stst", "blt", "fdrc", "ddest", "ldST", "adst", "adrc", "tlt", "fdst", "brc", "drc", "tST", "adput", "bart", "dST", "Dst", "bST", " dST", " dost", "dost", "fdST", "Ddest", "lddest", "adST", "start", "Dost", "dart", "tst", "tart", "ldost", "bst", " ddest", "dlt", "ldst", "fdput", "dput", "bput", "stST", "stlt", "DST"], "preserveModificationTime": ["preserveModifyingFile", "preserveModationtime", "preserveModificationFile", "preserveMinificationTime", "preserveMinifiedtime", "preserveMinifiedTime", "preserveModifyingtime", "preserveModifyingTime", "preserveMinificationFile", "preserveModifiedFile", "preserveModifiedTime", "preserveModifytime", "preserveMinificationtime", "preserveModationFile", "preserveModationTime", "preserveModificationtime", "preserveModifiedtime", "preserveModifyTime", "preserveMinifiedFile"], "inputChannel": ["fileConnection", "outputchannel", "fileChannel", "InputQueue", "outputCode", "inputConsole", "outputCache", "InputChannel", " inputCache", " inputStream", "binaryChannel", "requestCode", "outputSocket", "inputStream", "errorChan", "inputGate", "inputSocket", "inputCode", "imageGate", "outputConsole", " inputConnection", " inputSocket", "requestChannel", "errorStream", "errorChannel", " inputChan", "errorCache", "outputStream", " inputQueue", "requestChan", "outputBuffer", "outputChan", "inputBuffer", "Inputchannel", "outputConnection", "outputGate", "imagechannel", "InputSocket", "binaryGate", "fileConsole", " inputBuffer", " inputConsole", "InputChan", "InputBuffer", " inputchannel", " inputCode", "outputQueue", "inputChan", "binaryChan", "binarychannel", "fileChan", "requestStream", "imageChannel", "imageChan", "inputConnection", "inputQueue", "inputchannel", "inputCache"], "outputChannel": ["outputchannel", "OutputStream", "outchannel", "writeChan", "outChannel", "outButton", "outputManager", " outputQueue", " outputChan", "inputStream", "outputButton", "writeChannel", "OutputChan", "inputButton", "outputStream", " outputchannel", "outputChan", "OutputQueue", "outStream", " outputButton", "writeQueue", "outChan", " outputStream", "outputQueue", "writeStream", "inputChan", "inputManager", "OutputChannel", " outputManager", "Outputchannel", "writeManager"], "length": ["slave", "pull", "section", "position", "full", "join", "current", "volume", "limit", "with", "sum", "delay", "Length", "partial", "sequence", "text", "number", "child", "count", "build", "l", "part", "base", "max", "load", "size", "php", "block", "complete", "session", "len", "value", "head", "start", "result", "last", "next", "type", "style", "duration", "id", "end", "offset", "lock", "buffer", "available", "form", "width"], "total": ["done", "Total", "full", "otal", "multi", "current", "limit", "failed", "available", "sum", "partial", "key", "no", "translation", "count", "valid", "less", "part", "scale", "base", "all", "cur", "max", "size", "complete", "len", "i", "set", "used", "start", "result", "last", "error", "type", "found", "duration", "id", "always", "offset", "info", "toc"]}}
{"id1": "1769771", "id2": "4618237", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "copyChannel", "CopyFiles", "copyfile", "transferFiles", "copyFiles", "CopyChannel", " copyChannel", "CopyFile", "transferChannel", "transferfile"], "in": ["In", "again", "c", "IN", "m", "ex", "inner", "bin", "input", "io", "pin", "ins", "min", "inn", "l", "win", "base", "lin", "url", "query", "work", "config", "index", "f", "i", "image", "login", "reader", "diff", "data", "inc", "id", "source", "lock", "name", "file"], "out": ["resource", "external", "again", "n", "c", "string", "cache", "o", "ex", "call", "Out", "io", "outs", "conn", "user", "p", "up", "default", "w", "base", "prefix", "exec", "server", "x", "off", "image", "plain", "writer", "dot", "ext", "v", "output", "write", "OUT", "point", "b", "target", "name", "file", "extra"], "inChannel": [" inchannel", "insChan", "outchannel", "inputChannel", "inputStream", "winchannel", "winChannel", "binChan", "INStream", " inStream", "InChan", "inchannel", "winStream", "insClient", "binchannel", "InClient", "inStream", "winChan", "outStream", "insStream", "binClient", "INChannel", "inChan", "binChannel", "insChannel", "inClient", "INChan", "INchannel", "outChan", " inClient", "outClient", "inputChan", "InStream", "InChannel", " inChan", "Inchannel", "inputchannel", "binStream"], "outChannel": ["outputchannel", "outputChannel", " outChan", "outchannel", "inputChannel", "OutChannel", "OutConnection", "nStream", "Outchannel", " outManager", "inCh", "outManager", "inchannel", "outputStream", "outputController", "outputChan", "inStream", "nChan", "outStream", " outConnection", "inController", " outCh", "inChan", "inputController", "outCh", "outChan", "OutChan", " outchannel", "nManager", "inConnection", "outConnection", "inputChan", "outputCh", "nChannel", " outStream", "inputchannel", "inManager", "outController"]}}
{"id1": "3024987", "id2": "19096138", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStreamForEncode", "testCopy_readerToOutputStream_Coding", "testCopy_readerToOutputStream_Code", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStream_Integoder", "testCopy_readerToOutputStream_Coded", "testCopy_readerToOutputStream_Integode", "testCopy_readerToOutputStreamForencoding", "testCopy_readerToOutputStream_Encode", "testCopy_readerToOutputStream_Integoding", "testCopy_readerToOutputStream_Coder", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStreamForencoded", "testCopy_readerToOutputStream_encode", "testCopy_readerToOutputStream_Integoded", "testCopy_readerToOutputStreamForencoder", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStreamForEncoded", "testCopy_readerToOutputStreamForEncoding", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStreamForencode", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStreamForEncoder"], "in": ["In", "or", "entry", "pass", "inas", "again", "ini", "n", "include", "IN", "rec", "m", "reading", "is", "inner", "din", "bin", "with", "input", "io", "slice", "ins", "min", "inn", "err", "init", "win", "rin", "url", "read", "Reader", "inside", "i", "image", "a", "file", "login", "arin", "data", "r", "inc", "id", "source", "buffer", "re"], "reader": ["or", "reading", "pointer", "oder", "inner", "ler", "input", "io", "ner", "feed", "driver", "er", "handler", "ra", "x", "loader", "read", "Reader", "iter", "rer", "per", "i", "ink", "her", "worker", "iner", "writer", "rr", "r", "b", "parser", "rar", "buffer", "stream", "rx", "source", "file"], "baout": ["vaOut", "BAOUT", "baOut", "abaOut", "wain", "daout", "aaout", "daOut", "Baout", "baOUT", "daOUT", "BAOut", "waoutput", "vaout", "baparent", "waOut", "BAparent", "BAout", "abaOUT", "aain", "BAoutput", "BaOut", "bain", "vain", "BAin", "dain", "vaparent", "Baparent", "abaout", "aaoutput", "aaOut", "Bain", "abain", "waout", "baoutput"], "out": ["inas", "line", "again", "cache", "o", "inner", "with", "Out", "io", "outs", "object", "user", "err", "up", "base", "exec", "server", "arr", "array", "pool", "image", "lib", "to", "writer", "file", "ext", "output", "write", "obj", "OUT", "null", "inc", "parent", "buffer", "client", "builder", "ref"], "bytes": ["pages", "reads", "Bytes", "classes", "codes", "bs", "zip", "string", "bps", "ies", "css", "lines", "ones", "values", "bits", "objects", "outs", "os", "files", "content", "seconds", "tes", "pieces", "cells", "strings", "ls", "size", "its", "ns", "blocks", "units", "ips", "output", "data", "parts", "items", "ipes", "null", "comments", "android", "es", "binary", "les", "text", "body", "odes", "rows"]}}
{"id1": "4599372", "id2": "9236363", "code1": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"readFixString": ["readfixString", "createFixedstring", "createFixedArray", "createFixContent", "readAdjustString", "readFixedArray", "readAdjustArray", "readAdjustContent", "createFixedContent", "createFixedString", "readFixContent", "readAdjuststring", "readFixedContent", "createFixstring", "createFixArray", "readFixedstring", "readfixContent", "readfixArray", "readFixstring", "createFixString", "readFixArray", "readFixedString", "readfixstring"], "len": ["lt", "line", "n", "string", "limit", "str", "le", "Len", "ll", "list", "length", "lit", "count", "fn", "loc", "l", "part", "base", "pos", "lin", "size", "sl", "f", "enc", "e", "code", "i", "li", "lp", "el", "split", "val", "file", "data", "en", "lf", "body", "ln", "lc"], "sw": ["wh", "wt", "sh", "so", "nw", "serv", "zip", " SW", "sf", "iw", "tw", "wx", "io", "sc", "wa", "sa", "Sw", "ew", "ww", "sr", "wp", "w", "fw", "WS", "sn", "sp", "aw", "ws", "sb", "sl", "SW", "hw", "wra", "rw", "lv", "writer", "wr", "bb", "fl", "sv", "null", "es", "stream", "wb", "ss", "ow"]}}
{"id1": "9802073", "id2": "13946197", "code1": "    public void testAutoCommit() throws Exception {\n        Connection con = getConnectionOverrideProperties(new Properties());\n        try {\n            Statement stmt = con.createStatement();\n            assertEquals(0, stmt.executeUpdate(\"create table #testAutoCommit (i int)\"));\n            con.setAutoCommit(false);\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (0)\"));\n            con.setAutoCommit(false);\n            con.rollback();\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (1)\"));\n            con.setAutoCommit(true);\n            con.setAutoCommit(false);\n            con.rollback();\n            con.setAutoCommit(true);\n            ResultSet rs = stmt.executeQuery(\"select i from #testAutoCommit\");\n            assertTrue(rs.next());\n            assertEquals(1, rs.getInt(1));\n            assertFalse(rs.next());\n            rs.close();\n            stmt.close();\n        } finally {\n            con.close();\n        }\n    }\n", "code2": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "label": 0, "substitutes": {"testAutoCommit": ["testAutoDebits", "testAutoommite", "testSyncCommIT", "testSyncDebIT", "testAutoComits", "testAutoComIT", "testAutoDebit", "testSyncDebits", "testAutoDebIT", "testAutoommIT", "testSyncCommite", "testAutoommit", "testAutoDebite", "testAutoComit", "testSyncCommit", "testAutoCommite", "testSyncCommits", "testSyncDebite", "testSyncDebit", "testAutoommits", "testAutoCommits", "testAutoCommIT", "testAutoComite"], "con": ["ctrl", "pc", "Connection", "m", "ca", "log", "can", "ct", "cond", "fac", "pool", "pub", "gen", " conn", "ver", "db", "an", "c", "cache", "Conn", " CON", "cc", "cl", "connection", "mc", "win", "cn", "ocon", "cur", "pre", "en", "conf", "connect", "class", "cm", "n", "act", "col", "union", "conv", "ctx", "co", "util", "sync", "cf", "ac", "sql", "min", "fn", "cr", "rc", "coll", "Con", "uc", "lock", "client", "com", "fc", "cas", "pr", "context", "platform", "ran", "conn", "config", "syn", "bc", "non", "crit", "session", "CON", "un", "tc", "close", "pen", "core", "common"], "stmt": ["stmd", "STpt", "STmt", "ctmb", "stm", " stmb", "rmt", "estmb", "STmb", "storp", "Stmb", " stpt", "stpt", "Stb", "stmp", "Stbl", "Stmt", "stor", "stbl", " stb", "STbl", "STm", "Storp", "Stur", " stmn", "Stmd", "Stmp", "stnt", "rmd", "Stmn", "Stnt", " stnt", " stMT", " stbl", "ctmp", "ctor", "estMT", "slmt", "Stor", " storp", " stor", "STMT", "stsp", " stmp", " stur", "stMT", "Stpt", "stmb", " stmd", "stur", "Stm", "stmn", " stsp", "slmn", "stb", "STnt", "ctmt", "estsp", "slmp", "rorp", "STsp", "STmp", " stm", "slur", "rb", "estmt"], "rs": ["rss", "hs", "row", "ry", "ms", " Rs", " rc", "pr", "results", "errors", "Rs", " rows", "relations", "sc", "sr", "rt", "rys", "ins", "rl", "mr", "xs", "ra", "ubs", "cr", " results", " r", "rc", " RS", "ls", "acks", "ars", "cs", "vers", "ges", "ros", "eers", " res", "res", "repl", "RC", "reader", "runs", "hr", "rr", "RS", "r", "ps", "ras", "rd", " sr", "rx", "src", "ris", "ows", "rows"]}}
{"id1": "1371265", "id2": "23291583", "code1": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "code2": "    private ByteArrayInputStream fetchUrl(String urlString, Exception[] outException) {\n        URL url;\n        try {\n            url = new URL(urlString);\n            InputStream is = null;\n            int inc = 65536;\n            int curr = 0;\n            byte[] result = new byte[inc];\n            try {\n                is = url.openStream();\n                int n;\n                while ((n = is.read(result, curr, result.length - curr)) != -1) {\n                    curr += n;\n                    if (curr == result.length) {\n                        byte[] temp = new byte[curr + inc];\n                        System.arraycopy(result, 0, temp, 0, curr);\n                        result = temp;\n                    }\n                }\n                return new ByteArrayInputStream(result, 0, curr);\n            } finally {\n                if (is != null) {\n                    try {\n                        is.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            if (outException != null) {\n                outException[0] = e;\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"update": ["resource", "run", "append", "request", "table", "select", "report", "edit", "add", "post", "json", "insert", "UPDATE", "replace", "updated", "delete", "query", "index", "set", "Update", "apply", "save", "data", "write", "info", "create"], "channelPath": ["resourcepath", " channelMap", "filepath", "resourceMap", "fileMap", " channelObject", " channelpath", "downloadpath", "filePath", "resourcePath", "downloadObject", "fileObject", "resourceObject", "downloadPath", "downloadMap"], "dataField": ["datafield", " dataTable", " dataFIELD", "dataTerm", "responseField", "resourcefield", "alphaField", "DataArea", "dataFIELD", "resourceFIELD", " dataArea", "alphaTerm", "responsefield", "alphaTable", "dataTable", "resourceField", "DataTable", "alphaArea", " datafield", "dataArea", "responseFIELD", " dataTerm", "resourceTerm", "DataField", "responseTerm", "DataTerm"], "fatherDocId": ["motherDocInfo", "fatherdocPath", "motherDocumentID", "fatherPoName", "fatherWriterName", "fatherDocumentInfo", "fatherDocumentID", "fatherWriterID", "fatherFileId", "motherDocid", "motherDocumentName", "fatherDocID", "fatherdocId", "fatherDocPath", "motherDocumentInfo", "motherDocName", "fatherDocName", "motherDocumentid", "fatherWriterid", "motherDocID", "fatherDocInfo", "fatherWriterInfo", "fatherdocName", "fatherWriterId", "fatherDocumentPath", "motherDocPath", "motherDocumentId", "fatherDocumentId", "fatherDocid", "fatherFileInfo", "fatherPoId", "fatherFileName", "fatherDocumentid", "fatherFilePath", "fatherFileID", "fatherDocumentName", "fatherPoid", "fatherPoID", "fatherFileid", "motherDocumentPath", "fatherdocInfo", "motherDocId"], "sqlInitial": ["SQLFinal", "qlInitialized", "qlFinal", "sqlFinal", "SQLInitial", "sqlInitialized", "queryInitial", "SQLinitial", " sqlInit", "SQLInit", "SQLInitialized", "qlInitial", "queryFinal", "sqlInit", "queryinitial", " sqlinitial", "qlinitial", "qlInit", " sqlInitialized", "sqlinitial", "queryInit"], "sqlsortURL": ["sqlsORTUrl", "sqLSORTurl", "sqLSortUrl", "sqllortSSL", "sqllortURI", "sqlsortUrl", "sqlsortSSL", "sqlsaltSSL", "sqlssortURL", "sqlsORTURL", "sqLSORTURI", "sqllaltSSL", "sqlsourceURL", "sqLSortURI", "sqlsaltURL", "sqlsaltUrl", "sqlsaltURI", "sqllaltURI", "sqlsendURI", "sqlsourceUrl", "sqLSorturl", "sqlsortURI", "sqlsorturl", "sqlsendUrl", "sqllaltUrl", "sqllortUrl", "sqlsourceURI", "sqlssortURI", "sqlssortUrl", "sqlsourceurl", "sqlsORTurl", "sqllaltURL", "sqLSortURL", "sqlsourceSSL", "sqlsORTURI", "sqLSORTUrl", "sqLSORTURL", "sqlssorturl", "sqlsendSSL", "sqlsendURL", "sqllortURL"], "conn": ["dc", "ch", " con", "pc", "cat", "n", "c", "Connection", "pr", "pg", "ca", "ens", "act", "col", "Conn", "ann", "apt", "oss", "ci", "dn", "ctx", "con", "pt", "co", "rt", "sync", "Connect", "ct", "oci", "client", "sql", "ht", "p", "cr", "cc", "connection", "mc", "net", "cn", "rc", "cp", "coll", "reg", "cs", "syn", "enc", "session", "ds", "pub", "res", "nt", "en", "conf", "nc", "lock", "connect", "orp", "db", "core"], "rs": ["rg", "rss", "hs", "ks", "rep", "ms", "bs", "maps", "ats", "ys", "pr", "ocr", "lines", "results", "Rs", "sc", "sr", "rt", "arch", "rys", "ins", "rl", "xs", "mr", "pers", "ra", "cr", "rors", "obs", "s", "qs", "rc", "ans", "vs", "acks", "ars", "cs", "icks", "its", "vers", "ns", "ds", "ues", "ges", "ros", "res", "repl", "ts", "asts", "hr", "rr", "RS", "r", "PS", "ras", "rb", "DS", "rd", "runs", "rx", "sels", "src", "ris", "ows", "rows"], "ps": ["ups", "ks", "pass", "pc", "pps", "ms", "pres", "pm", "bs", "ens", "ys", "pr", "pg", "LS", "pse", "eps", "ples", "Rs", "pl", "gs", "con", "pt", "Ps", "co", "os", "ins", "pp", "amps", "pers", "p", "fs", "s", "ans", "ons", "pe", "vs", "pa", "pos", "ars", "sp", "pex", "cs", "ws", "aps", "ports", "syn", "ns", "ds", "pre", "ros", "res", "ips", "ts", "posts", "jp", "RS", "PS", "po", "ras", "DS", "ss"], "dbo": ["ldbc", "bBo", "bbi", "dbi", "dba", " dpo", "dpo", " dBo", "mdBo", "mdba", "DBo", "Dbo", "Dpo", "Dbi", " dbc", "dBo", "mdbo", "mdbc", "dbc", " dbi", "ldba", "bpo", "ldbo", "ldBo", "bbo", " dba"], "url": ["resource", "fr", "route", "username", "string", "blog", "href", "host", "request", "view", "http", "str", "language", "www", "response", "URL", "path", "ll", "layer", "ur", "feed", "force", "Url", "rl", "download", "email", "address", "loc", "rel", "l", "rule", "server", "location", "sl", "f", "date", "nl", "q", "filename", "image", "page", "ssl", "html", "data", "hl", "fl", "r", "id", "uri", "source", "text", "src", "name", "file"], "st": ["sth", "stri", "sh", "est", "string", "rest", "pr", "ust", "th", "ost", "str", "ist", "ft", "ST", "inst", "sc", "pt", "rt", "la", "const", "ste", "p", "bl", "cr", "ld", "l", "cl", "sw", "s", "pe", "stress", "sn", "sp", "x", "ast", "sl", "sb", "nd", "sta", "ut", "stop", "start", "St", "std", "sts", "ss", "r", "stack", "t", "rd", "Str", "src", "fr"], "sortDocId": ["sortWriterID", " sortDocInfo", " sortDocid", "sortdocId", "sortPageName", "sortDepName", "sortDocumentInfo", "sortDocInfo", "sortDocid", " sortFilePath", "sortdocid", "sortDepid", " sortDocPath", "sortDepInfo", "sortDocumentName", "sortDOCId", " sortDocumentId", "sortFileId", "sortFilePath", "sortDOCName", " sortFileInfo", "sortPageId", "updateDocumentInfo", " sortDocumentName", " sortDocID", "sortWriterid", "sortDocumentId", "sortFileID", "sortDocumentID", "updateDocumentId", " sortFileId", "updateDocId", "sortdocPath", " sortDocumentID", "sortDocName", "updateDocid", "updateDocumentid", "updateDocID", "sortDocumentPath", "sortPageID", "sortdocInfo", "sortDocumentid", "sortDocID", "sortdocName", "sortWriterId", "sortDOCID", "sortDepId", "sortDepID", "sortDocPath", "sortdocID", "sortFileid", "updateDocumentID", "updateDocInfo", " sortDocName", " sortFileID", "sortWriterName", "sortPageid", "sortDOCid", "sortFileInfo", " sortDocumentid"], "flag": ["inline", "status", "use", "cat", "kind", "string", "blog", " Flag", "str", "fun", "func", "FLAG", "match", "only", "force", "char", "sync", "bit", "agg", "key", "child", "ret", "count", "bug", "store", "ag", "part", "tag", "wait", "standard", "field", "ind", "format", "start", "lag", "star", "ext", "Flag", "flags", "data", "arg", "fl", "debug", "prop", "id", "offset", "binary", "leaf", "file", "bool"], "sqlsort": ["sqlsorted", "sqllorted", " sqlesORT", "sqlsorter", "sqsorts", "sqlesort", "sqllorter", "sqsort", " sqlesort", " sqLSorts", "sqLSORT", "sqlesorts", " sqlsORT", "sqllort", "sqlesORT", " sqLSort", "sqLSsort", "sqLSorter", "sqLSort", "sqssort", "sqLSorts", "sqlsORT", " sqlssort", "sqlessort", "sqllORT", "sqlssort", " sqlsorts", "sqLSorted", " sqlsorter", " sqlesorted", " sqlsorted", " sqLSsort", " sqLSORT", "sqlsorts", "sqlesorted", " sqlesorter", "sqlesorter", "sqsORT"], "sortURL": [" sortURI", "editurl", " sortUR", "altURL", "Sorturl", "editUrl", "sortUrl", "SortUR", "ortID", "ortURI", " sortUrl", " sortID", "searchID", "updateURL", "sortUR", "altUR", "editURL", "altUrl", "updateUR", "sortURI", "searchUrl", "ortSSL", "searchURL", "updateSSL", "editUR", "searchUR", "searchURI", "ortURL", "sortID", " sorturl", "sortSSL", "SortUrl", "SortURL", "ortUrl", "updateURI", "altSSL", "sorturl", " sortSSL", "ortUR"], "sortflag": ["SortFlag", " sortFLAG", "considerfeed", "orttype", "sortFLAG", "addressflags", " sorttype", "addressfeed", "addressflag", "ortfeed", "filterFLAG", "considerflag", "ortFlag", "addresslike", "considerflags", "sortflags", " sortFlag", "sorttype", "SortFLAG", "filterflag", "ortflag", "sortFlag", "ortflags", "filtertype", "considerlike", "ortFLAG", "Sortflag", "sortlike", "ortlike", "sortfeed"]}}
{"id1": "5035872", "id2": "536614", "code1": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "src": ["resource", "root", "http", "dist", "input", "copy", "path", "inst", "sc", "slice", "this", "dest", "in", "files", "download", "conn", "loc", "s", "rc", "storage", "ls", "upload", "url", "config", "sl", "sb", "filename", "image", "sin", "img", "st", "data", "obj", "b", "sit", "source", "stream", "uri", "iv", "rb", "sel", "file"], "dst": ["dbst", "ddest", "Dcr", "dbput", "dcr", " dcr", "adst", "dbds", "fdst", "fdot", " dsts", "adsts", "Dst", "dds", "dsts", "tdst", "Ddest", "dput", "dot", "addest", "dbot", " ddest", "tdds", "tdput", "fdds", "fdput", "Dsts", "adcr", "tdot"], "inChannel": [" inchannel", "inputMessage", "loginCamera", "innerStream", "outchannel", " inConnection", "inputChannel", "loginChannel", "inCamera", "incStream", " inContext", "inputStream", "binConnection", "InContext", " inMessage", "binChan", "againStream", "INStream", " inStream", "InChan", "inchannel", "innerChannel", "binchannel", "INConnection", "outMessage", "inStream", "incChan", "outStream", "loginChan", "INChannel", "inChan", "againChannel", "binChannel", "incCamera", "loginStream", "INChan", "INchannel", "inMessage", "outChan", "againChan", "againCamera", "innerConnection", "inConnection", "outConnection", "inputChan", "inContext", "InStream", "incChannel", "InChannel", "inputConnection", " inChan", "Inchannel", "outContext", "inputchannel", "innerChan", "binStream"], "outChannel": ["outputchannel", "outWriter", "outputChannel", "outQueue", " outChan", "OutStream", "outchannel", "inputChannel", "outGate", " outQueue", "OutChannel", "offWriter", "inputStream", "Outchannel", "againStream", " outContext", "inchannel", "outputStream", "offContext", " outWriter", "outputChan", "inStream", "outStream", "offChannel", " outConnection", "againQueue", "inChan", "againChannel", "inQueue", "againConnection", "againChan", "outChan", "inWriter", " outchannel", "OutChan", "againchannel", "inConnection", "outConnection", "offChan", "inputChan", "inContext", " outGate", "inGate", " outStream", "inputchannel", "outContext", "againGate"], "result": ["folder", "or", "done", "pass", "status", "use", "compl", "function", "Result", "cache", "current", "false", "results", "comment", "response", "continue", "func", "match", "card", "length", "ret", "err", "ault", "default", "successful", "valid", "future", "event", "math", "work", "complete", "cup", "array", "f", "success", "res", "true", "cash", "test", "error", "ure", "found", "data", "r", "diff"]}}
{"id1": "22264586", "id2": "9347451", "code1": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"copyFiles": ["clonePages", "cloneFile", "transferFile", "CopyChildren", "Copyfiles", "clonefiles", "copyFile", "CopyFiles", " copyfiles", "copyPages", "transferChildren", "transferPages", "transferFiles", " copyPages", "copyChildren", " copyChildren", "cloneFiles", "transferfiles", " copyFile", "CopyFile", "copyfiles"], "strPath": ["stFile", " strpath", "strName", "striFile", "stPath", " strName", "strFile", "striLog", "STRpath", "StrLog", "STRLog", "stName", "stripath", "striPath", "strpath", "StrFile", "stpath", "strLog", "Strpath", "STRFile", "StrName", "StrPath", "STRPath", " strFile"], "dstPath": ["dstsFile", "dblpath", "dstFile", "ddestDir", "drcpath", "dndPath", "fstsDir", "sdndPath", "dblFile", "sdstName", "drcDir", "sdndName", "ddestFile", "dstName", "drcName", "sdndpath", "fstPath", "sdndDir", "sdstPath", "dstDir", "dblPath", "dndDir", "dndpath", "ddestName", "sdstDir", "fstspath", "dstspath", "drcPath", "dblDir", "dstpath", "dndName", "sdstpath", "fstsPath", "fstFile", "fstsFile", "fstDir", "ddestPath", "dstsPath", "ddestpath", "dstsDir", "fstpath"], "src": ["txt", "cmp", "project", "obl", "front", "host", "Source", "ruby", "dist", "scripts", "self", "input", "ource", "path", "inst", "ctx", "sc", "slice", "this", "sys", "in", "sync", "client", "download", "loc", "sup", "s", "rc", "rob", "ls", "reverse", "upload", "tmp", "cur", "url", "config", "sb", "sl", "back", "SOURCE", "split", "sin", "cb", "RC", "img", "st", "ssl", "secure", "ources", "sub", "rs", "source", "stream", "sel", "sit", "rb", "iv", "sq", "sort"], "dest": ["dc", "folder", "cdn", "txt", "done", "slave", "temp", "wh", "cat", "project", "front", "zip", "rest", "later", "dat", "dist", "d", "destroy", " Dest", "desc", "di", "wd", "div", "sup", "dd", "comb", "trans", "default", "out", "tmp", "delete", "du", "thin", "flat", "des", "ds", "home", "gd", "Dest", "result", "img", "secure", "test", "style", "target", "prop", "de", "source", "wb", "dep", "db"], "list": ["status", "full", "map", "dl", "ll", "none", "files", "pair", "members", "dir", "p", "l", "s", "delete", "url", "like", "val", "stat", "filter", "write", "lists", "parent", "version", "lc", "names", "entry", "lines", "str", "la", "LIST", "bl", "cl", "strings", "keys", "code", "data", "null", "stream", "sort", "www", "listed", "queue", "part", "all", "ls", "coll", "arr", "load", "size", "array", "set", "diff", "type", "stack", "id", "cont", "name", "group", "run", "string", "parents", "is", "remove", "path", "key", "json", "batch", "base", "chain", "config", "read", "split", "test", "info", "source"], "i": ["hi", "si", "qi", "ip", "u", "multi", "n", "ii", "c", "m", "pi", "o", "y", "abi", "ci", "di", "io", "key", "slice", "ji", "ui", "ri", "length", "me", "bi", "ie", "p", "part", "phi", "j", "I", "x", "index", "f", "e", "oi", "li", "a", "start", "gi", "v", "ti", "type", "ai", "data", "r", "b", "xi", "id", "info", "uri", "ix", "mu"], "dest1": ["srcOne", "sourceone", "Dest0", "Dest2", "dest0", "source2", "destOne", "DestOne", "homeone", "source0", "src2", "source1", "src0", "dest2", " destone", "sourceOne", "destone", "home1", "Dest1"], "src1": ["srcOne", "sourceone", "rc1", "source2", " src2", "rcOne", "src2", "rcone", "source1", " srcone", " srcOne", "sourceOne", "rc2", "srcone"], "sourceChannel": ["srcChan", "SourceStream", "ourceChan", "Sourcechannel", "sourceContext", "SourceContext", "targetChan", "ourceStream", " sourcechannel", "SourceChan", "srcStream", "srcContext", " sourceChan", "sourcechannel", "SourceChannel", "ourceChannel", "targetContext", "targetchannel", "sourceStream", "srcChannel", " sourceStream", "sourceChan", "targetStream", " sourceContext", "ourceContext"], "targetChannel": ["TargetChannel", "destContext", "TargetContext", "TargetManager", " targetConnection", "sourceContext", "targetChan", "destChannel", " targetManager", "destConnection", "argetManager", " targetContext", "targetManager", "destChan", " targetChan", "argetChan", " targetchannel", "sourcechannel", "targetConnection", "Targetchannel", "argetChannel", "targetContext", "targetchannel", "argetchannel", "TargetConnection", "sourceChan", "TargetChan"]}}
{"id1": "22410173", "id2": "4481712", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "source": ["resource", "route", "use", "site", "Source", "inner", "input", "copy", "ource", "path", "down", "from", "slice", "ins", "unit", "ie", "up", "connection", "base", "url", "size", "iter", "SOURCE", "start", "internal", "sin", "image", "reader", "ources", "target", "id", "parent", "stream", "src", "name", "file"], "dest": ["folder", "temp", "done", "exit", "project", "dist", "bin", "destroy", "desc", "down", "path", "die", "this", "comb", "connection", "orig", "tmp", "delete", "thin", "flat", "home", "Dest", "transfer", "img", "output", "test", "true", "target", " destination", "de", "wb", "src", "name", "later", "file"], "in": ["resource", "In", "pull", "again", "n", "c", "ini", "IN", "m", "cin", "inner", "din", "bin", "src", "input", "as", "con", "this", "pin", "ins", "min", "conn", "inn", "ie", "err", "up", "init", "win", "s", "url", "work", "gin", "f", "inside", "i", "by", "nin", "a", "image", "socket", "start", "file", "login", "reader", "data", "r", "b", "plugin", "inc", "id", "info", "lock", "client", "re", "name"], "out": ["timeout", "temp", "not", "at", "again", "cat", "n", "c", "channel", "o", "option", "call", "ex", "exp", "inner", "bin", "with", "Out", "self", "log", "outer", "io", "outs", "this", "sync", "conn", "no", "our", "err", "up", "connection", "init", "net", "w", "exec", "url", "index", "pool", "off", "password", "i", "lib", "socket", "plain", "writer", "to", "ext", "img", "output", "ou", "write", "data", "obj", "OUT", "vert", "inc", "id", "parent", "client", "name", "file", "extra"]}}
{"id1": "22752444", "id2": "1235538", "code1": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["encryption", "decryption", " encress", " encryption", "decrypt", "decress", "encipher", "escrypt", "escress", "escipher", "decipher", " encipher", "escryption", "encress"], "plainText": ["plainString", "singleText", "singleString", "singletext", " plainForm", "plainForm", "plaintext", "flatString", "plainData", " plainCode", "singleForm", " plainBody", "binaryCode", "lineData", "flatForm", "lineText", "flatText", "binarytext", " plainData", "linetext", "lineContent", "plainCode", "singleBody", " plaintext", "binaryText", " plainString", "singleData", "singleCode", " plainContent", "flattext", "plainBody", "binaryBody", "singleContent", "plainContent"], "hash": ["row", "mac", "string", "cache", "Hash", "rh", "secret", "sha", "sum", "copy", "msg", "log", "match", "key", "hex", "auth", "json", "header", "kh", "build", "tag", "base", "cmd", "url", "ash", "array", "block", "code", "password", "image", "h", "material", "format", "html", "error", "data", "dig", "id", "message", "text", "body", "db"], "md": ["df", "mb", "mg", "mp", "pd", "ms", "pm", "od", "cm", "mand", "mac", "Cmd", "m", "rm", "mem", "sm", " MD", "um", "d", "sha", "hm", "da", "di", "MD", "bd", "meta", "wd", "hd", "ad", "dd", "mc", "cd", "mod", "cmd", "mn", "dh", "dr", "ma", "mag", "am", "dm", "material", "amd", "data", "dig", "mm", "metadata", "vd", "mad", "mt", "mu", "mo"], "raw": ["wrap", "row", "draw", "full", "clean", "instance", "initial", "unknown", "inner", "input", "sc", " hex", "hex", "buf", "feed", "json", " RAW", "pure", "ack", "original", "shared", "ode", "flash", "ng", "orig", "out", "rew", "load", "array", "enc", "Raw", "block", "serial", "image", "unsigned", "data", " Raw", "null", "pack", "RAW", "buffer", "stream", "text", "message", "dec"]}}
{"id1": "1141361", "id2": "4593012", "code1": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"makeRead": [" makeREAD", "doREAD", "doRead", " executePut", " executeAdd", "executeAdd", "doPut", "executeREAD", "doAdd", "executePut", " executeRead", " executeREAD", " makeAdd", "executeRead", " makePut"], "user": ["item", "row", "token", "username", "use", "owner", "project", "blog", "string", "host", "word", "comment", "uid", "log", "post", "meta", "mode", "creator", "custom", "bug", "USER", "install", "server", "url", "usr", "date", "field", "admin", "password", "User", "author", "write", "pod", "human", "job", "users", "alias", "name", "db"], "databaseID": [" databaseid", "tableID", "DatabaseUID", " databaseName", "dbName", "DatabaseName", "databaseUID", "databaseid", "tableid", " databaseKey", "connectionid", " databaseUID", "connectionID", "DatabaseID", "databaseName", "databaseKey", "dbId", "DatabaseId", " databaseId", "tableKey", "dbID", "dbUID", "databaseId", "connectionKey"], "time": ["timeout", "times", "string", "instance", "host", "hour", "table", "depth", "str", "comment", "money", "path", "year", "post", "length", "Time", "mode", "tz", "month", "rate", "port", "clock", "size", "read", "date", "TIME", "value", "set", "home", "tim", "ime", "type", "id", "timer", "message", "source", "text", "name", "end"], "query": ["timeout", "function", "string", "join", "execute", "table", "request", "Query", "select", "script", "comment", "call", "report", "qu", "search", "sequence", "post", "database", "sql", "command", "connection", "work", "commit", "code", "q", "filter", "error", "question", "module", "ql", "eries", "message", "id", "update", "name", "db", "sq"], "statement": ["slave", "status", "study", "si", "use", "media", "section", "function", "string", "instance", "note", "execute", "join", "volume", "table", "expression", "str", "comment", "language", "state", "response", "di", "jo", "post", "this", "database", "sql", "opened", "unit", "command", "batch", "rule", "connection", "document", "s", "init", "agent", "storage", "server", "commit", "ma", "machine", "session", "usage", "ment", "i", "password", "journal", "stat", "result", "memory", "joined", "st", "Statement", "style", "parser", "message", "general", "mt", "alias", "builder"], "count": ["cache", "table", "depth", "limit", "total", "state", "more", "sum", "log", "Count", "number", "force", "list", "process", "length", "content", "child", "err", "batch", "cc", "part", "connection", "base", "cond", "expected", "size", "index", "code", "start", "check", "handle", "counter", "diff", "error", "type", "found", "id", "inc", "offset"]}}
{"id1": "22035737", "id2": "19096138", "code1": "    private static void loadMappings(Configuration cfg) {\n        try {\n            Enumeration en = LoadingUtils.getResources(MAPPINGS_FILE);\n            while (en.hasMoreElements()) {\n                URL url = (URL) en.nextElement();\n                logger.info(\"Found mapping module \" + url.toExternalForm());\n                InputStream inputStream = null;\n                try {\n                    inputStream = url.openStream();\n                    HibConfiguration hm = loadModuleMappings(inputStream);\n                    configureModuleMappings(cfg, hm.getSessionFactory());\n                } catch (IOException e) {\n                    logger.warn(\"Could not load mappings file \\\"\" + url.toExternalForm() + \"\\\"\", e);\n                } catch (JAXBException e) {\n                    logger.warn(\"Unable to instantiate JAXBContext \", e);\n                } finally {\n                    try {\n                        if (inputStream != null) inputStream.close();\n                    } catch (IOException e) {\n                        logger.debug(e);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            logger.warn(\"Could not find any mappings file hibernate.mappings.xml\", e);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"loadMappings": ["getMations", "loadEmappings", "loadEmapping", "loadmations", "loadmappers", "loadMetations", "loadMappers", "loadMations", "getMappings", "loadEmappers", "getmappings", "getmappers", "getMappers", "getmations", "loadMetappers", "getMapping", "loadmapping", "loadMetapping", "loadmappings", "loadEmations", "getmapping", "loadMapping", "loadMetappings"], "cfg": ["Conf", "g", "c", "cm", "Configuration", "gui", "xml", "gs", "utils", "core", "msg", "ci", "ctx", "Config", "cms", "cf", "conn", "fs", "mc", "gb", "fg", "cn", "cmd", "config", "loader", "settings", "bc", "f", "cli", "pkg", "gd", "cb", "fp", "gi", "obj", "module", "gate", "conf", "info", "org", "db", "file"], "en": ["an", "que", "online", "ane", "zen", "n", " EN", "ens", "m", "em", "ani", "ner", "open", "reen", "En", "jen", "ven", "env", "een", "ern", "er", "hen", "ener", "ben", "ea", "EN", "pe", "ren", "enn", "eni", "isen", "f", "enc", "eng", "e", "ende", "len", "set", "el", "fen", "ne", "ense", "ae", "ou", "ent", "r", "ena", "de", "esi", "es", "et", "un", "end"], "url": ["resource", "fr", "route", "string", "href", "host", "xml", "http", "www", "URL", "path", "layer", "ll", "ur", "feed", "gl", "in", "Url", "rl", "download", "json", "address", "bel", "loc", "lr", "l", "connection", "base", "rc", "element", "coll", "server", "location", "config", "loader", "sl", "f", "e", "i", "filename", "image", "el", "page", "ssl", "bb", "hl", "fl", "r", "b", "web", "uri", "source", "org", "name", "file"], "inputStream": ["outputForm", "InputView", "inputContext", "outputSteam", "InputForm", "outputChannel", " inputSteam", "inputChannel", " inputReader", "InputChannel", " inputForm", "outputContext", "inputstream", "inputForm", "InputContext", "outputView", " inputstream", "inSteam", "outputStream", "InputSteam", "inReader", "instream", "inStream", " inputContext", "Inputstream", "inputReader", "inputView", "inView", "outputReader", "InputStream", "outputstream", " inputChannel", "inputSteam"], "hm": ["hs", "bh", "helm", "hom", "phy", "kr", "cm", "rm", "uh", "rh", "uph", "km", "utm", "hh", "cht", "him", "ih", "qq", "ht", "mr", "hd", "hp", "vm", "HM", "dh", "hw", "gm", "MH", "dm", "hu", "h", "hn", "drm", "chid", "hl", "hr", "tm", "htm", "wm", "bm"]}}
{"id1": "22235113", "id2": "947406", "code1": "    protected Object unmarshallXml(final Unmarshaller unmarshaller, final String accessUrl, final String nameSpace, final String replace, final String with) throws Exception {\n        final URL url = new URL(accessUrl);\n        final BufferedReader inputStream = new BufferedReader(new InputStreamReader(url.openStream()));\n        String xmlContent = readWithStringBuffer(inputStream);\n        if (replace != null) {\n            xmlContent = xmlContent.replace(replace, with);\n        }\n        LOGGER.info(\"Calls \" + accessUrl);\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"\\nXml:\" + accessUrl + \"\\n\" + xmlContent);\n        }\n        if (LOGGER.isDebugEnabled()) {\n            final BufferedWriter out = new BufferedWriter(new FileWriter(\"target/XmlAgentLog\" + xmlRequestNumber++ + \".txt\"));\n            out.write(xmlContent);\n            out.close();\n        }\n        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xmlContent.getBytes());\n        Source source;\n        if (nameSpace != null) {\n            source = setNameSpaceOnXmlStream(byteArrayInputStream, nameSpace);\n        } else {\n            source = new StreamSource(byteArrayInputStream);\n        }\n        return unmarshaller.unmarshal(source);\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"unmarshallXml": ["unmarshallExml", "unmarshallXil", "unmarshallYML", "unmarshalXML", "unmarshalXml", "unmarshallExson", "unmarshallExil", "unmarshalExson", "unmarshallxml", "unmarshalExML", "unmarshallxson", "unmarshallExML", "unmarshallYson", "unmarshallXson", "unmarshalXson", "unmarshallYil", "unmarshallYml", "unmarshalExil", "unmarshallxil", "unmarshallxML", "unmarshalXil", "unmarshallXML", "unmarshalExml"], "unmarshaller": ["unmashalledable", "unmarshalling", "unmarshalor", "unmashaller", "unmockallinging", "unmarshillers", "unmarshillable", "unmashallor", "unmarshallinging", "unmarshallinger", "unmarshalinging", "unmashallable", "unmarshillor", "unmarshalledor", "unmarshalable", "unmockallingers", "unmashalleder", "unmockalling", "unmockallinger", "unmarshalleders", "unmashalledor", "unmockallers", "unmashallers", "unmarshallingers", "unmarshallers", "unmarshalleder", "unmarshaler", "unmarshallable", "unmarshiller", "unmarshalingers", "unmarshalledable", "unmarshallor", "unmarshalinger", "unmarshaling", "unmarshalers", "unmashalleders", "unmockaller"], "accessUrl": ["AccessUrl", "accessStream", "accessUr", " accessPath", "execFile", "requestLog", "AccessLog", "requestLink", "requestLine", "AccessLine", "serviceUr", "AccessURL", " accessURL", "inputUrl", " accessFile", "accessLink", "AccessPath", " accessUr", "inputLink", "serviceLink", "accessFile", "requestFile", "AccessStream", "requestUrl", "accessPath", "requestURL", "inputURL", "execUrl", " accessLog", "serviceURL", "accessLine", "requestUr", "execURL", "requestPath", " accessLine", "accessURL", "inputUr", "accessLog", "requestStream", " accessStream", "execUr", "serviceUrl"], "nameSpace": ["namespace", "nameSp", "namesSpace", "nameName", "NameSpace", "NameString", "namesspace", "resourceSp", "namesSp", " nameString", "NameName", "resourcespace", "NameSp", "nameFrame", "namesName", " namePath", "resourcePath", "namePath", " nameFrame", "Namespace", " nameSp", "resourceFrame", " namespace", "NamePath", "NameFrame", "nameString", "resourceSpace", "resourceString", " nameName"], "replace": ["group", "escape", "align", "use", "section", "string", "join", "over", "append", "see", "fill", "reply", "comment", "cover", "remove", "be", "same", "search", "protect", "match", "patch", "add", "force", "operation", "place", "pair", "repeat", "address", "store", "insert", "br", "flash", "tag", "fix", "prefix", "find", "placed", "get", "where", "settings", "complete", "like", "space", "strip", "format", "repl", "apply", "change", "quote", "save", "places", "parse", "write", "r", "sub", "update", "alias", "re", "name"], "with": ["resource", "at", "and", "include", "join", "host", "context", "xml", "spec", "partial", "search", "then", "params", "none", "from", "add", "place", " With", "properties", "flash", "document", "tag", "layout", "prefix", "get", "work", "x", "settings", "other", "before", "without", "by", "some", "format", "apply", "claim", " without", "plugin", "style", "id", "around", "message", "With", "name"], "url": ["resource", "window", "stream", "zip", "string", "channel", "host", "blog", "xml", "http", "service", "URL", "log", "ll", "path", "api", "feed", "Url", "rl", "client", "user", "conn", "address", "browser", "l", "connection", "base", "server", "sl", "image", "socket", "page", "ssl", "fl", "uri", "buffer", "file"], "inputStream": ["InputReader", " inputSteam", "inputContent", " inputReader", " inputContent", "xmlSteam", "inputstream", " inputstream", "outputStream", "InputSteam", "outputBuffer", "inputBuffer", "xmlStream", "Inputstream", " inputBuffer", "xmlReader", "InputBuffer", "inputReader", "outputReader", "InputStream", "outputstream", "inputSteam", "InputContent"], "xmlContent": ["xmlString", "xmlAddress", "phpContent", "phpString", "broadMessage", "jsonContent", "xmlMessage", " xmlHeader", "eventContents", "txtContent", " xmlMessage", "xmlContents", "mlString", " xmlContents", "txtContents", " xmlFile", "jsonReader", "eventContent", "xmlFile", "mlFile", "fileString", "mlMessage", "mlDocument", "broadText", "txtAddress", "mlData", "txtFile", " xmlText", " xmlReader", "jsonHeader", "mlHeader", "eventAddress", " xmlData", " xmlDocument", "mlText", "mlReader", "fileContent", "phpData", "mlContent", " xmlString", "xmlReader", "xmlData", "xmlText", "broadContent", "phpFile", "xmlDocument", "jsonMessage", "xmlHeader", "fileDocument", "fileMessage", "eventFile", " xmlAddress", "broadDocument"], "out": ["temp", "group", "window", "again", "project", "full", "cache", "word", "exp", "ex", "Out", "response", "copy", "log", "report", "path", "io", "outer", "outs", "key", "sync", "in", "doc", "object", "user", "err", "up", "w", "prefix", "array", "f", "password", "writer", "plain", "page", "result", "ext", "output", "gen", "data", "write", "OUT", "b", "flush", "stream", "name", "builder", "file", "extra"], "xmlRequestNumber": ["xmlVersionNum", "xmlFilenumber", "xmlRequestnumber", "xmlVersionCounter", "xmlRequestNum", "httpResponseNum", "xmlFileNumber", "xmlFileCounter", "httpResponsenumber", "httpRequestCounter", "httpRequestnumber", "xmlResponseNumber", "httpRequestNum", "xmlFileNum", "httpResponseNumber", "xmlResponseCounter", "xmlVersionnumber", "xmlResponseNum", "httpResponseCounter", "httpRequestNumber", "xmlVersionNumber", "xmlResponsenumber", "xmlRequestCounter"], "byteArrayInputStream": ["byteArrayOutputStyle", "byteStringOutputstream", "byteStreamInputstream", "byteArrayInputFile", "byteArrayBytestream", "byteStringInputStream", "byteStreamInputArray", "byteStringOutputSteam", "byteArrayInputstream", "byteArrayByteStyle", "byteArrayReadFile", "byteArrayOutputSteam", "byteStreamInputStream", "byteArrayReadSteam", "byteArrayReadstream", "byteArrayByteSteam", "byteStreamInputSteam", "byteArrayOutputArray", "byteStreamOutputSteam", "byteStreamInputFile", "byteArrayTextArray", "byteArrayByteStream", "byteArrayInputStyle", "byteStreamOutputStyle", "byteArrayInputSteam", "byteStreamOutputFile", "byteStringInputSteam", "byteArrayReadArray", "byteStreamOutputStream", "byteStreamOutputArray", "byteStringOutputStream", "byteArrayTextStream", "byteArrayReadStream", "byteStringInputstream", "byteArrayTextstream", "byteStreamOutputstream", "byteArrayOutputStream", "byteStreamInputStyle", "byteArrayOutputstream", "byteArrayOutputFile", "byteArrayInputArray", "byteArrayTextFile"], "source": ["resource", "slave", "scene", "plus", "class", "use", "stream", "position", "g", "string", "speed", "zip", "Source", "view", "spec", "str", "proxy", "inner", "scope", "service", "input", "copy", "ource", "node", "ge", "slice", "ce", "content", "object", "unit", "kin", "rule", "connection", "rate", "model", "event", "component", "sp", "config", "size", "get", "sl", "iter", "session", "wrapper", "SOURCE", "result", "secure", "reader", "data", "type", "style", "target", "null", "id", "info", "uri", "text", "src", "core"]}}
{"id1": "11968328", "id2": "16623181", "code1": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getMD5": ["getSHA32", " getCD53", " getMD32", "getMD512", " getMC32", "getSHA5", " getSHA5", " getMC53", " getSHA512", " getCD5", " getMD512", " getMC5", " getSHA53", " getMC512", " getMD53", "getMD32", " getCD32", " getCD512", "getMD53", "getSHA53", " getSHA32", "getSHA512"], "_pwd": ["_dpass", "_dWD", "_dwd", "_npass", "_Pwn", "_Ppass", "_swd", "_sWD", "_Pword", "_nwd", "_PWD", "_Pwd", "_spass", "_pwn", "_pWD", "_nwn", "_pword", "_ppass", "_sword", "_dword", "_nWD"], "md": ["df", "mb", "mg", "mp", "pd", "pm", "od", "mand", "rm", "mac", "m", "pg", "sm", " MD", "um", "d", "sha", "MD", "bd", "meta", "wd", "hd", "ad", "dd", "mc", "gb", "cd", "cmd", "dh", "ma", "mag", "pkg", "ind", "dm", "editor", "nm", "amd", "kg", "dig", "mm", "metadata", "po", "bf", "vd", "mad", "mt", "mu", "db", "mo"]}}
{"id1": "6966398", "id2": "20924119", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"reader": ["resource", "df", "or", "row", "reads", "ry", "k", "instance", "context", "o", "reading", "rake", "oder", "ler", "raf", "input", "cer", "manager", "io", "ner", "feed", "driver", "cms", "ri", "client", "pp", "keeper", "er", "handler", "book", "p", "connection", "rc", "pe", "server", "load", "dr", "config", "loader", "read", "Reader", "iter", "per", "rw", "her", "writer", "se", "rr", "r", "parser", "rar", "source", "stream", "buffer", "builder", "file"], "ks": ["ics", "acts", "akes", "reads", "kes", "hs", "KS", "ms", "books", "bs", "k", "opens", "ko", "checks", "gets", "orks", "ctx", "co", "ke", "powers", "acs", "fs", "qs", "ki", "ans", "ls", "inks", "acks", "cks", "vs", "ops", "ches", "keys", "icks", "cs", "ns", "ds", "ku", "CS", "kb", "ges", "ips", "sk", "se", "ps", "DS", "es", "rs", "works", "ck", "kies", "ss", "rows"], "key": ["Key", "seed", "k", "c", "cache", "pg", "ca", "secret", "ee", "service", "state", "io", "co", "char", "pair", "ke", "ce", "ring", "trust", "user", "p", "base", "ki", "court", "pe", "server", "keys", "read", "code", "value", "transfer", "ssl", "type", "point", "sign", "lock", "client", "file"], "chain": ["wrap", "root", "container", "c", "cache", "chains", "table", "wheel", "secret", "circle", "family", "path", "sequence", "box", "network", "list", "none", "slice", "pair", "object", "store", "cr", "rule", "mc", "scale", "base", "coll", "Chain", "config", "enc", "code", "set", "image", "range", "stack", "lock", "crypt", "block", "collection", "file"], "os": ["rss", "ms", "ol", "ios", "ob", "osi", "oid", "op", "o", "opens", "is", " o", "oss", "options", "io", "outs", "aos", "object", "bos", " bos", "p", "fs", "s", "pos", "los", "iso", "ops", "cos", "ot", "Os", "ds", "oses", "ros", "res", "ou", "ps", "es", "rs", "OS"], "stamper": ["starmple", "spampe", "function", " nostameple", "g", "spamper", " nostamler", "streampe", "stammper", "stAMper", "spammer", "path", "spAMpe", "stAMmer", "stampper", "stammple", "this", " nostamepper", "starmper", "stammpe", "starmpper", " nostamper", " nostameper", "stammmer", "s", "stAMpe", "stampe", "streammer", "stameple", "streamper", "spamler", "stamler", "spAMler", "stameler", "_", "stample", "starmler", "stammler", "stammer", "stammpper", "stamepper", "stAMler", "stameper", "data", " nostample", "streamler", " nostameler", " nostampper", "spAMper", "spAMmer"], "appearance": ["ppearance", "attfacing", "installear", "appasion", " appears", "ppearing", "suppearing", "byearance", "feedearance", "feedointment", "formismo", "atteared", "formearing", "appfacing", "askence", "appence", " appfacing", "appearing", "suppearance", "appismo", "ppaser", "signearing", "appointment", "attence", "feedfacing", "suppfacing", "byismo", "askeared", "feedear", " appeared", "Appearance", "signfacing", "ppear", "signear", "byearing", "suppasion", "signearance", "askearance", "installearing", "Appears", "formaser", " applier", "appears", "signointment", "askfacing", "formear", "byear", "installearance", "appear", "ppasion", "signears", "signlier", "attearance", "suppointment", "applier", "Appearing", " appence", "appaser", " appear", " appearing", " appaser", "formearance", " appismo", "installasion", "Applier", "suppear", "appeared"]}}
{"id1": "5148212", "id2": "23088292", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "code2": "    private void Submit2URL(URL url) throws Exception {\n        HttpURLConnection urlc = null;\n        try {\n            urlc = (HttpURLConnection) url.openConnection();\n            urlc.setRequestMethod(\"GET\");\n            urlc.setDoOutput(true);\n            urlc.setDoInput(true);\n            urlc.setUseCaches(false);\n            urlc.setAllowUserInteraction(false);\n            if (urlc.getResponseCode() != 200) {\n                InputStream in = null;\n                Reader reader = null;\n                try {\n                    in = urlc.getInputStream();\n                    reader = new InputStreamReader(in, \"UTF-8\");\n                    int read = 0;\n                    char[] buf = new char[1024];\n                    String error = null;\n                    while ((read = reader.read(buf)) >= 0) {\n                        if (error == null) error = new String(buf, 0, read); else error += new String(buf, 0, read);\n                    }\n                    throw new NpsException(error, ErrorHelper.SYS_UNKOWN);\n                } finally {\n                    if (reader != null) try {\n                        reader.close();\n                    } catch (Exception e1) {\n                    }\n                    if (in != null) try {\n                        in.close();\n                    } catch (Exception e1) {\n                    }\n                }\n            }\n        } finally {\n            if (urlc != null) try {\n                urlc.disconnect();\n            } catch (Exception e1) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyfile", "createfile", " copyFiles", "transferFile", "createFiles", "copyfile", "createFile", "transferFiles", "copyFiles", "transferDir", " copyDir", "copyDir", "createDir", "transferfile"], "src": ["resource", "cdn", "project", "href", "view", "http", "dist", "proxy", "input", "ource", "path", "sc", "slice", "download", "impl", "archive", "loc", "ie", "l", "gb", "s", "rc", "upload", "url", "config", "loader", "name", "sl", "sb", "gz", "filename", "image", "fp", "remote", "RC", "img", "obj", "req", "r", "source", "stream", "uri", "rb", "file", "ref"], "dest": ["dc", "folder", "cdn", "temp", "done", "txt", "route", "project", "front", "zip", "rest", "dat", "opt", "exp", "dist", "d", "master", "destroy", "dep", " Dest", "desc", "di", "path", "slice", "this", "doc", "wd", "dir", "archive", "loc", "p", "comb", "trans", "orig", "tmp", "url", "delete", "du", "config", "flat", "home", "filename", "Dest", "v", "img", "output", "data", "obj", "style", "target", "b", " destination", "de", "null", "id", "parent", "source", "wb", "name", "later", "file", "origin"], "bufSize": ["buffsize", " bufCount", "buffSize", " bufLen", "bufferSize", "buffName", "bufLen", "buffLen", "bufName", "ufName", "bufferLen", "ufCount", "bufCount", "ufLen", "buffersize", "bufferCount", " bufsize", "bufsize", "buffCount", "ufsize", "ufSize", "bufferName"], "force": ["pull", "route", "cop", "keep", "use", "enable", "send", "effect", "act", "front", "cache", "want", "false", "dirty", "push", "orce", "service", "forces", "delay", "only", "die", "sync", "ignore", "child", "count", "play", "store", "err", "fix", "replace", "load", "like", "forcing", "allow", "auto", "close", "ride", "remote", "apply", "secure", "write", "require", "forced", "style", "flush", "hard", "parent", "deep", "Force", "reason", "file", "kill"], "f": ["folder", "df", "fe", "F", "fc", "u", "n", "c", "cache", "m", "g", "o", "d", "fx", "self", "path", "fd", "feed", "dir", "fn", "p", "fs", "l", "ff", "w", "s", "base", "j", "e", "fm", "i", "uf", "h", "fp", "v", "r", "b", "fb", "t", "bf", "file", "rf"], "buffer": ["resource", "seed", "position", "cache", "uffer", "limit", "bin", "input", "wave", "sequence", "feed", "buf", "queue", "slice", "number", "pad", "length", "batch", "base", "url", "size", "Buffer", "iter", "value", "bytes", "transfer", "page", "result", "bb", "reader", "border", "data", "write", "raw", "null", "b", "buff", "flush", "message", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", " Read", "use", "ip", "send", "n", "k", " write", "c", "reading", "fill", "view", "select", "sleep", "input", "copy", "READ", "lex", "io", "open", "feed", "add", "key", "text", "sync", "skip", "length", "count", "build", "play", "Read", "ad", "seek", "show", "rate", "exec", "find", "get", "load", "x", "wait", "size", "index", "max", "iter", "len", "i", "ink", "ok", "ind", "set", "start", "check", "reader", "se", "data", "write", "raw", "parse", "r", "inc", "id", "connect", "block", "end"], "in": ["In", "pull", "pass", "or", "token", "again", "ini", "c", "n", "IN", "m", "cin", "ex", "request", "inner", "din", "bin", "input", "as", "con", "pin", "ins", "ac", "on", "conn", "child", "inn", "download", "impl", "p", "err", "kin", "up", "l", "connection", "init", "s", "win", "rin", "lin", "url", "gin", "thin", "i", "nin", "a", "socket", "login", "reader", "ax", "r", "b", "inc", "id", "source", "client", "re"], "out": ["pass", "plus", "line", "again", "n", "c", "cache", "o", "exp", "ex", "inner", "bin", "Out", "sum", "log", "outer", "io", "outs", "co", "sync", "conn", "object", "user", "cookie", "err", "up", "connection", "net", "w", "init", "exec", "server", "gin", "name", "other", "off", "nin", "image", "lib", "socket", "writer", "to", "plain", "ne", "v", "ext", "output", "data", "write", "obj", "OUT", "null", "b", "error", "inc", "id", "parent", "client", "one"]}}
{"id1": "335223", "id2": "22801734", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "9257487", "id2": "3184073", "code1": "    public static boolean downloadFile(String from, String to, ProgressMonitor pm) {\n        try {\n            FileOutputStream out = new FileOutputStream(to);\n            URL url = new URL(from);\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int read = 0;\n            while ((read = in.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n                if (pm != null) pm.addToProgress(read);\n            }\n            out.close();\n            in.close();\n        } catch (Exception e) {\n            Installer.getInstance().getLogger().log(StringUtils.getStackTrace(e));\n            return false;\n        }\n        return true;\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 0, "substitutes": {"downloadFile": [" downloadfile", "copyFile", " downloadFiles", "Downloadfile", "downloadfile", "DownloadResource", " downloadResource", "copyfile", "DownloadFiles", "downloadResource", "DownloadFile", "copyFiles", "downloadFiles", "copyResource"], "from": ["folder", "resource", "or", "route", "at", "project", "host", "src", "with", "From", "about", "as", "path", "user", "address", "part", "connection", "base", "prefix", "f", "link", "code", "by", "a", "remote", "html", "range", "data", "module", "source", "uri", "form", "name", "file"], "to": ["resource", "temp", "or", "route", "token", "so", "o", "with", "about", "path", "as", "io", "os", "flo", "download", "address", "base", "TO", "prefix", "storage", "location", "To", "addr", "office", "eto", "socket", "remote", "repl", "until", "range", "output", "too", "target", "po", "prot", "uri", "source", "name", "file"], "pm": ["mp", "pc", "cm", "rm", "im", "m", "em", "pr", "PM", "gp", "sm", "pb", "pi", "um", "prem", "pl", "pt", "px", "pp", "mr", "wp", "p", "vm", "cp", "pa", "sp", "pool", "lp", "sem", "fm", "gm", "dm", "dem", "rpm", "mi", "prom", "meter", "jp", "po", "mm", "tm", "wm", "bm", "monitor", "pro"], "out": ["timeout", "temp", "In", "line", "again", "string", "o", "inner", "bin", "Out", "self", "copy", "input", "as", "log", "outer", "io", "outs", "sync", "err", "up", "connection", "net", "w", "cmd", "exec", "cli", "i", "socket", "writer", "file", "login", "ext", "output", "reader", "write", "obj", "OUT", "inc", "parent", "source", "client"], "url": ["resource", "fr", "zip", "c", "channel", "http", "www", "URL", "log", "ll", "con", "ur", "open", "Url", "download", "impl", "bel", "er", "loc", "l", "connection", "base", "server", "sl", "f", "i", "el", "image", "lib", "socket", "ssl", "fl", "b", "fb", "web", "uri", "source", "client", "org", "file"], "conn": ["dc", "ch", "cm", "n", "c", "Connection", "g", "act", "http", "Conn", "apt", "ann", "conv", "ci", "ctx", "con", "open", "cms", "sync", "client", "p", "l", "connection", "mc", "cn", "cp", "exec", "coll", "cur", "f", "enc", "pub", "socket", "close", "cb", "ssl", "b", "en", "nc", "lock", "connect", "lc"], "in": ["In", "again", "ini", "n", "c", "IN", "cin", "is", "inner", "din", "bin", "input", "con", "io", "ins", "impl", "inn", "err", "connection", "init", "win", "s", "lin", "isin", "exec", "f", "inside", "i", "nin", "socket", "login", "ssl", "reader", "data", "r", "b", "inc", "source", "stream", "client", "lock", "file"], "buffer": ["row", "seed", "position", "cache", "uffer", "limit", "bin", "input", "layer", "shape", "wave", "feed", "buf", "slice", "queue", "length", "address", "batch", "base", "size", "Buffer", "iter", "bytes", "result", "memory", "bb", "reference", "reader", "data", "write", "raw", "null", "b", "buff", "flush", "message", "offset", "binary", "source", "padding"], "read": ["reads", "pass", "run", "ask", "use", "send", "k", " write", "readable", "current", "reading", "fill", "select", "input", "old", "READ", "lex", "io", "open", "feed", "add", "slice", "text", "sync", "skip", "number", "length", "download", "count", "seek", "play", "Read", "rate", "exec", "find", "get", "load", "x", "wait", "size", "work", "f", "iter", "index", "allow", "ok", "ind", "check", "start", "connect", "ride", "transfer", "close", "reader", "se", "parse", "write", "raw", "b", "loop", "sleep", "block", "create", "end"]}}
{"id1": "7468827", "id2": "18631594", "code1": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "code2": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "label": 0, "substitutes": {"run": ["resource", "Run", "execute", "call", "open", "process", "download", "build", "running", "exec", "server", "url", "get", "work", "stop", "start", "check", "close", "login", "test", "runner", "submit", "web", "loop", "update", "create"], "con": ["fa", "fe", "ctrl", "pc", "fc", "ob", "clean", "c", "ca", "ex", "http", "cons", "Conn", "fun", "conv", "can", "open", "co", "cf", "ran", "conn", "on", "cl", "connection", "init", "rc", "cn", "cp", "out", "ocon", "exec", "url", "cur", "bc", "CON", "Con", "don", "connect", "socket", "plain", "close", "uc", "file", "login", "en", "conf", "web", "com", "sub", "ver", "client", "re", "un"], "encodedPassword": ["enccodedPassword", "enccodedPass", "encodedpassword", "encoderData", "enccodedpassword", "Encryptedpassword", "encodedData", "enoderPassword", "encryptedpassword", "enccodedSecret", "encodedPass", "encoderSecret", "EncryptedSecret", "enodedPass", "enodedPassword", "enoderData", "EncryptedPassword", "encapedpassword", "EncodedPassword", "encryptedPassword", "enoderpassword", "encoderpassword", "enoderPass", "encapedData", "enodedData", "encoderPass", "encoderPassword", "encryptedPass", "encryptedSecret", "encapedPass", "Encodedpassword", "enodedpassword", "encapedPassword", "encodedSecret", "EncryptedPass", "encryptedData", "EncodedSecret", "EncodedPass"], "encoder": ["decoder", " encode", "enoded", "Encode", "enode", " encoded", "encoded", "Encoded", " encoding", "encode", "enoder", "encoding", "Encoding", "decoding", "decoded", "decode", "enoding", "Encoder"], "in": ["In", "pass", "again", "ini", "c", "IN", "cin", "is", "inner", "din", "bin", "input", "as", "io", "pin", "ins", "conn", "inn", "kin", "isin", "init", "win", "rin", "lin", "out", "url", "gin", "cgi", "f", "i", "nin", "socket", "login", "reader", "vin", "b", "inc", "source", "file"], "fos": ["lfis", "Foses", "dos", " fOS", "fose", "Foos", " foses", " foos", "lfos", "infos", "foos", "bOS", " fose", "bos", "faos", "infoses", "doses", "foes", "doss", "fOS", "Fose", "infOS", "infoss", "infoos", "lfoes", "foses", " fis", "Fos", "lfOS", " faos", "FOS", "fis", "Foss", "daos", "Faos", "infose", "bis", " foss", "foss", " foes", "boes"], "bout": ["Bin", "bouter", "bbio", "bio", "fio", "Bio", " bio", "fin", "bb4", " bin", "bin", " bcache", "bbouter", " b4", "BOut", "bcache", "Bcache", "bbouts", "f4", "b4", "bouts", "bOut", "bbcache", " bOut", "bbOut", "fouter", "fouts", "bbout", "Bout", "fout", " bouts", "bbin", " bouter"], "data": ["media", "zip", "string", "zero", "cache", "dat", "d", "input", "response", "partial", "feed", "key", "number", "pad", "length", "div", "content", "address", "sample", "batch", "alpha", "xxx", "video", "part", "xxxx", "DATA", "size", "read", "block", "value", "i", "image", "start", "bytes", "result", "memory", "next", "reader", "raw", "message", "info", "buffer", "body", "one"], "x": ["u", "n", "c", "m", "y", "ex", "d", "wx", "fx", "xc", "lex", "z", "wa", "number", "ww", "num", "xy", "no", "xs", "my", "p", "xxx", "w", "pos", "pe", "X", "max", "width", "size", "index", "f", "dx", "code", "xp", "i", "tx", "val", "v", "xx", "b", "en", "t", "id", "xi", "rx", "ix"], "lastIteraction": ["lastIterate", "lastExecAction", "lastExecate", "lastGeneration", "lastGenerATION", "lastGenerAction", "prevIterAction", "lastIterATION", "lastIterAction", "prevIteration", "lastIteration", "prevIterATION", "lastGenerate", "prevIterate", "lastExecATION", "lastExecation", "prevGenerAction", "prevGenerate", "prevGeneration", "prevGenerATION"], "e": ["or", "fe", "u", "n", "c", "g", "oe", "o", "d", "ee", "ge", "be", "this", "ke", "no", "er", "ie", "p", "it", "ception", "s", "pe", "element", "event", "exc", "f", "E", "ite", "i", "ze", "a", "ne", "ae", "error", "type", "se", "ure", "r", "b", "esi", "t", "es", "me", "re", "one", "ise", "edge"]}}
{"id1": "8216539", "id2": "7149578", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFilecontentInStream", "getFileContentAsText", "getFileContentInStream", "getFilecontentAsStream", "getFileContentasStream", "getFileContentFromText", "getFilecontentInString", "getFileContentAsStr", "getFileContentasText", "getFileContentInText", "getFilecontentAsStr", "getFileContentasString", "getFileContentFromString", "getFileContentasStr", "getFilecontentAsString", "getFileContentInStr", "getFileContentFromStream", "getFilecontentInText", "getFileContentAsStream", "getFileContentInString", "getFilecontentInStr", "getFileContentFromStr", "getFilecontentAsText"], "filePath": ["fileName", "baseUrl", "singlepath", "basepath", "FileUrl", "resourceName", "filepath", "FileStr", "basePath", "Filepath", "singleLocation", " fileUrl", "baseName", "singleUrl", " fileStr", "resourcePath", "baseStr", "FileName", "FileLocation", "resourcepath", "fileUrl", "fileLocation", "baseLocation", "FilePath", "singlePath", "fileStr", " filepath", "resourceLocation"], "encoding": ["encryption", "enclocking", "equlocking", "encpling", "encging", "languagepling", "Encging", "Encryption", "Encasing", "decasing", "languageging", "encoded", "equoding", "Encpling", "Encoded", "coded", "cryption", "Encoding", "languageoding", "coding", "decoding", "decoded", "casing", "languagelocking", "encasing", "decryption", "Enclocking", "equging", "equpling"], "testURL": ["testingURI", "testingTL", "testTL", "TestUrl", "testingURL", " testUrl", "appurl", "fileURL", " testURI", "Testurl", " testRL", "appUrl", "TestUR", "testingUR", "testRL", "testingUrl", "testURI", " testurl", "testUrl", "shortTL", "shortURL", "appURL", "testUR", "testingRL", "fileUrl", "testingurl", "shortUrl", "shorturl", "testurl", "fileRL", "fileURI", "TestURL", "appUR", " testTL"], "input": ["dc", "resource", "temp", "pull", "entry", "act", "current", "instance", "qa", "op", "xml", "http", "inner", "bin", "path", "api", "feed", "this", "in", "active", "client", "ac", "conn", "ack", "audio", "connection", "init", "rc", "out", "element", "exec", "upload", "url", "get", "config", "enc", "Input", "but", "wrapper", "inside", "i", "ink", "image", "through", "socket", "inf", "result", "ssl", "img", "output", "reader", "data", "type", "raw", "error", "ou", "null", "acl", "inc", "parent", "source", "stream", "text", "binary", "form", "file", "flow"], "sw": ["ib", "wrap", "we", "wt", "sh", "nw", " SW", "sm", "sf", "iw", "tw", "wx", "io", "sc", "sa", "Sw", "ew", "ww", "wp", "cr", "w", "WS", "rc", "sn", "work", "rew", "aw", "now", "ws", "sl", "sb", "SW", "hw", "rw", "wrapper", "writer", "fp", "wr", "sk", "sv", "rx", "en", "web", "stream", "wb", "ow"]}}
{"id1": "5237257", "id2": "12242903", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "label": 0, "substitutes": {"download": ["paste", "run", "zip", "register", "select", "log", "report", "open", "process", "archive", "Download", "release", "upload", "exec", "url", "delete", "load", "complete", "dump", "start", " downloading", "transfer", "output", "submit", "pack", "update", "file"], "fileName": ["fileType", " fileCode", "FileUrl", "fileDirectory", "resourceCode", "FileCode", " fileUrl", "FileType", "FileFolder", "resourceType", "fileFolder", " fileType", " fileFolder", "resourceDirectory", "resourceUrl", "resourcePath", "resourceFolder", "FileName", "fileCode", "fileUrl", " fileDirectory", "FilePath", "FileDirectory", "resourceName"], "filePath": ["filePart", "resourceFile", "filepath", " fileFile", "resourcePart", "Filepath", "FilePart", "resourcePath", "FileName", "FileLocation", "resourcepath", "fileLocation", " filePart", "FileFile", "fileFile", "FilePath", " fileLocation", "resourceName", " filepath", "resourceLocation"], "in": ["resource", "In", "issue", "again", "n", "ini", "IN", "m", "cin", "is", "inner", "din", "bin", "input", "copy", "as", "con", "io", "this", "pin", "sync", "ins", "ac", "on", "inn", "err", "up", "l", "isin", "init", "win", "rin", "lin", "url", "work", "gin", "x", "cgi", "f", "inside", "i", "nin", "a", "image", "socket", "login", "reader", "data", "ax", "r", "b", "spin", "id", "inc", "source", "re", "name", "file"], "out": ["In", "or", "line", "at", "again", "n", "string", "cache", "IN", "o", "ex", "view", "option", "call", "exp", "inner", "bin", "with", "Out", "copy", "path", "outer", "log", "io", "outs", "this", "sync", "on", "conn", "user", "err", "up", "net", "base", "cmd", "exec", "server", "url", "prefix", "x", "office", "off", "password", "nin", "by", "image", "lib", "socket", "to", "writer", "ext", "output", "error", "write", "obj", "OUT", "point", "null", "id", "one", "source", "client", "name", "file", "extra"]}}
{"id1": "21491791", "id2": "19687456", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 1, "substitutes": {"run": ["Run", "execute", "call", "invoke", "func", "log", "process", "unit", "build", "command", "app", "running", "all", "exec", "fork", "work", "code", "worker", "start", "apply", "runner", "test", "spawn", "job", "loop", "create"], "input": ["resource", "entry", "readable", "instance", "initial", "context", "request", "reading", "view", "inner", "state", "io", "feed", "text", "driver", "in", "active", "client", "user", "conn", "address", "iterator", "audio", "up", "connection", "out", "storage", "work", "config", "loader", "read", "index", "control", "Input", "worker", "internal", "image", "data", "raw", "parser", "stream", "source", "form", "file", "flow"], "output": ["resource", "temp", "application", "exit", "writers", "cache", "environment", "response", "log", "path", "outer", "Writer", "queue", "operation", "network", "user", "letter", "object", "unit", "connection", "document", "out", "config", "office", "index", "control", "filename", "image", "page", "data", "write", "written", "writing", "put", "target", "job", "web", "parent", "source", "generated", "text", "console", "later", "file", "Output", "end"], "reader": ["resource", "entry", "riter", "row", "slave", "owner", "context", "reading", "request", "oder", "view", "inner", "manager", "io", "ner", "driver", "in", "ri", "handler", "er", "book", "audio", "server", "system", "loader", "read", "Reader", "rer", "wrapper", "worker", "peer", "image", "author", "r", "parser", "rator", "stream", "client", "source", "builder"], "writer": ["or", "riter", "entry", "writ", "war", "nw", "writers", "player", "ter", "word", "request", "wer", "inner", "outer", "manager", "Writer", "ner", "engine", "wa", "driver", "ew", "creator", "maker", "er", "wire", "w", "connection", "out", "wan", "work", "ws", "office", "rw", "wrapper", "worker", "her", "editor", "wr", "author", "writing", "write", "written", "data", "r", "wb", "builder"], "pump": ["cumping", "mumps", "ppumps", "pprint", "cumper", "prump", "pumps", " pumps", "prumper", " pumping", "pram", "Pdump", "Pam", "humps", "cump", "dmp", "hump", "pumper", "Pump", "pmp", "mumper", "dumper", "pumping", "ppump", "pdump", "prdump", "mump", " pamp", "humper", "pamp", "dumps", " pam", "Pamp", "ppumping", "dump", " pmp", "mprint", "pam", "ppumper", " pumper", "Pprint", "hprint", "Pumper", "camp", "Pumping", "Pumps", " pdump", "Pmp"], "counter": ["entry", "row", "ver", "ger", "seed", "instance", "ter", "current", "step", "zero", "inter", "pointer", "version", "currency", "comment", "inner", "continue", "walker", "trace", "layer", "outer", "ner", "sequence", "number", "enter", "num", "second", "repeat", "keeper", "Counter", "progress", "const", "count", "er", "cookie", "ener", "lr", "starter", "ception", "order", "hello", "collection", "consumer", "server", "url", "rew", "builder", "clock", "loader", "now", "index", "processor", "code", "worker", "center", "page", "result", "author", "runner", "meter", "r", "timer", "loop", "master", "race", "parent", "offset", "keep"], "buffer": ["resource", "entry", "position", "channel", "uffer", "limit", "layer", "buf", "queue", "length", "address", "header", "batch", "document", "base", "port", "server", "url", "loader", "Buffer", "iter", "uf", "page", "data", "buff", "message", "source", "text", "binary", "file", "reference"], "off": ["of", "low", "opt", "o", "unknown", "oa", "area", "inner", "down", "open", "ui", "on", "Offset", "flow", "ff", "less", "offer", "pos", "eno", "out", "fail", "addr", "left", "now", "ord", "head", "set", "offs", "start", "auto", "own", "OFF", "Off", "offset", "info", "art", "ref", "end"], "len": ["lt", "line", "n", "limit", "fin", "bin", "ler", "den", "log", "Len", "layer", "ll", "fd", "in", "length", "on", "lit", "count", "loc", "ld", "l", "pos", "lin", "all", "url", "size", "li", "lim", "el", "lan", "lib", "val", "gen", "lc", "elt", "fl", "en", "lf", "lon", "lock", "body", "ln", "name", "width", "ref", "end"], "rd": ["rss", "rm", "ru", "rh", "rid", "raid", "d", "rand", "dra", "fd", "rt", "rl", "rf", "RD", "nr", "ra", "lr", "dd", "cr", " r", "ld", "db", "rc", "rob", "ud", "RR", "dr", "red", "nd", "ord", "rw", "ds", "ind", "val", "rn", "rod", "adr", "hr", "rr", "r", "rs", "rx", "rb", " prod", "fr", "xd"]}}
{"id1": "17791385", "id2": "7911686", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "src": ["resource", "txt", "http", "dist", "input", "inst", "sc", "dest", "ins", "files", "ipl", "loc", "sup", "s", "rc", "ls", "upload", "url", "config", "sb", "sl", "filename", "image", "sin", "inf", "img", "st", "obj", "b", "back", "source", "stream", "uri", "sit", "rb", "sel", "file"], "dst": ["stst", "dsp", "ddest", "ddfd", "dfd", "stdest", "fdst", "ststs", " dsts", "Dlt", "pdfd", "pdst", "Dst", "fdfd", "ddft", "dsts", "Ddest", "ddsp", "ddst", " dlt", " ddest", "dft", "fdsp", "dlt", "fdft", "pdft", "Dsts", "pdsp", "stlt"], "in": ["In", "pull", "again", "n", "ini", "oin", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "as", "con", "pin", "ins", "impl", "conn", "inn", "err", "kin", "init", "win", "rin", "lin", "url", "gin", "f", "inside", "i", "nin", "h", "sin", "socket", "login", "reader", "data", "r", "inc", "id", "ln", "file"], "out": ["temp", "line", "at", "again", "n", "cache", "o", "ex", "exp", "bin", "Out", "self", "copy", "outer", "io", "outs", "post", "sync", "conn", "err", "up", "part", "net", "w", "s", "exec", "server", "x", "f", "other", "off", "i", "writer", "plain", "ext", "output", "raw", "obj", "OUT", "null", "inc", "parent", "client", "file"], "buf": ["bh", "vec", "cat", "c", "bin", "fd", "ctx", "bd", "queue", "pad", "length", "seq", "count", "loc", "batch", "br", "bl", "bag", "ff", "base", "rc", "cmd", "cur", "bc", "off", "lim", "cap", "uf", "uc", "bytes", "cb", "val", "v", "bb", "data", "fl", "raw", "b", "bf", "buff", "fb", "buffer", "wb", "rb"], "len": ["lt", "line", "n", "c", "fin", "bin", "le", "Len", "ll", "fd", "length", "no", "count", "err", "l", "part", "cl", "base", "pos", "all", "lin", "size", "sl", "f", "i", "li", "ind", "cap", "el", "split", "lim", "val", "nt", "data", "fl", "en", "lf", "rev", "ix", "ln", "name", "lc", "end"]}}
{"id1": "21125261", "id2": "8667872", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 0, "substitutes": {"test": [" tests", "run", " example", "execute", " evaluate", " solve", " sample", "Train", " verify", " testing", " run", " eval", "tests", "Main", " validate", " train", "evaluate", " analyse", "Test", "train", " simulate", " deploy", " process", " check"], "is": ["ics", "si", "isa", "ses", "ios", "serv", "ir", "opens", "iris", "has", "as", "gets", "ais", "os", "IS", "in", "ins", "does", "fs", "s", "Is", "out", "ls", "iss", "iso", "its", "ws", "isi", "i", "res", "mis", "bis", "lis", "ai", "ps", "ists", "es", "info", "id", "stream", "src", "ris"], "byteArrayOutputStream": ["byteStringOutputContext", "byteArrayFileSteam", "byteArrayInputPath", "byteArrayOutputString", "byteArrayInputFile", "byteArrayFileFile", "byteArrayoutputSteam", "byteStringInputStream", "byteStringInputFile", "byteArrayInputString", "byteStringOutputSteam", "byteArrayIOStream", "byteArrayInputStream", "byteArrayByteString", "byteArrayFileStream", "byteArrayIOFile", "byteArrayOutputSteam", "byteStringOutputFile", "byteArrayByteSteam", "byteArrayIOSteam", "byteArrayIOString", "byteArrayoutputStream", "byteArrayByteFile", "byteArrayByteStream", "byteArrayInputSteam", "byteStringInputSteam", "byteArrayoutputPath", "byteStringOutputStream", "byteStringInputString", "byteStringOutputString", "byteStringInputContext", "byteArrayFileString", "byteArrayOutputPath", "byteArrayInputContext", "byteStringInputPath", "byteStringOutputPath", "byteArrayFileContext", "byteArrayoutputContext", "byteArrayOutputContext", "byteArrayOutputFile", "byteArrayFilePath"], "def": ["df", "entry", "class", "DE", "defined", "spec", "d", "dist", "da", "report", "di", "pro", "desc", "this", "dev", "dir", "frame", "default", "init", "base", "DEF", "Def", "decl", "define", "definition", "config", "f", "e", "des", "der", "data", "dem", "obj", "md", "parse", "de", "bus", "conf", "id", "info", "re", "file", "ref"], "se": ["fe", "entry", "si", "ane", "sh", "ses", "so", "zip", "est", "ase", "see", "te", "ine", "pse", "service", "le", "ge", "be", "sle", "lex", "ve", "sc", "ke", "ce", "ste", "ie", "spe", "inse", "s", "pe", "ade", "sea", "sp", "sec", "sl", "per", "e", "su", "sem", "sche", "cle", "ze", "sed", "ne", "ser", "parse", "sk", "de", "es", "sel", "me", "site", "ss", "SE"], "linkId": ["linkLength", "Linkid", " linkInfo", "lineById", "feedInfo", "lockInfo", "LinkId", "LinkLength", " linkid", " linkById", "feedId", "lineId", "linkById", "linkid", "lockId", "feedid", " linkLength", "LinkInfo", "linkInfo", "feedLength", "lockById", "lineInfo"], "segmentId": ["sementID", " segmentType", "sementNumber", "sementInfo", "selementID", "negementCount", "selementId", "segementCount", " segmentsType", "segmentsType", "segmentID", " segmentID", "negmentNumber", " segmentCount", "segmentNumber", "negementInfo", "sementCount", "selementType", "segmentInfo", "negmentInfo", "segmentsID", " segmentsID", "negmentCount", "negmentId", "sementId", "segmentsNumber", "segmentsInfo", "selementCount", "segmentType", "segmentsId", "segmentsCount", "segmentCount", "segementInfo", " segmentsCount", "segementNumber", "negementNumber", "negementId", "sementType", " segmentsId", "segementId"], "linkSegments": ["linkEnggments", "linkConnectgments", "lineFragines", "linkEngments", "lineFraggments", " linkEngments", "linkFragures", "lineFragment", "linkFragments", "linkIncrements", "linkSegment", "linkIncreles", "linkIncreines", "lineSegments", "linkSegures", "linkFragles", " linkSegment", " linkEngures", "linkConnectures", "linkIncregments", " linkSegures", "lineSegment", "linkConnectments", "linkFraggments", "lineFragles", "linkSeggments", "linkSegines", "linkConnectment", " linkSeggments", "linkEngment", "lineSegines", "lineSegles", "lineFragments", "linkFragines", "linkIncrement", "lineSeggments", "linkEngures", "linkEngles", " linkEnggments", "linkFragment", "linkSegles", " linkEngment", "linkEngines"], "segments": ["segements", "segs", "sements", "gegs", "begment", "pegments", "schegments", "Seggements", "begments", "Seggments", "pegment", "segment", "pegements", "gements", "scheplings", "Seggment", "bements", "Segments", "geplings", "peplings", "gegments", "pements", "pegs", "schements", "begs", "seplings", "schegment", "gegment", "gegements"], "frameProperties": [" frameproeters", "frameproblems", " frameProproperties", " frameproproperties", "framePromperties", "frameProblems", "framePropps", " frameproblems", "frameProps", " frameprops", "frameproproperties", "framePropproperties", "frameproperties", "frameprops", " frameProeters", "framePropeters", "framePrometers", "framePromps", "framePropblems", "frameProproperties", "frameProeters", " frameProps", "framePromproperties", " frameProblems", " frameproperties", "frameproeters", "framePropperties"], "time": ["timeout", "vel", "live", "etime", "speed", "times", "c", "step", "depth", "money", "delay", "activity", "cost", "length", "count", "age", "weight", "play", "video", "rate", "event", "port", "work", "x", "clock", "size", "name", "now", "f", "date", "TIME", "e", "value", "image", "start", "h", "tim", "v", "change", "ice", "ime", "data", "type", "t", "id", "timer", "duration", "end", "loop", "sleep", "Time", "file", "once"], "vehicle": [" vehology", " vehicles", "driocity", "vehicles", "driical", "verticles", " vehline", "Vehline", "Vehicle", "driicle", "venometry", "bridocity", " mobicle", "vehology", "Vehicular", "vehometry", "venocity", "vertology", "bridometry", " mobicles", "bridicle", "bridical", " vehicular", "Vehicles", "verticular", "driometry", "Vehish", "Vehology", "venicle", " vehish", "venical", "vehline", "vehical", " mobish", "vehicular", " mobline", "vehish", "vehocity", "verticle"]}}
{"id1": "21821404", "id2": "20024612", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    private void parse() throws Exception {\n        BufferedReader br = null;\n        InputStream httpStream = null;\n        URL fileURL = new URL(url);\n        URLConnection urlConnection = fileURL.openConnection();\n        httpStream = urlConnection.getInputStream();\n        br = new BufferedReader(new InputStreamReader(httpStream, \"UTF-8\"));\n        String ligne;\n        String post;\n        String date;\n        String titre;\n        String resume;\n        String url2DL;\n        while ((ligne = br.readLine()) != null) {\n            if (ligne.indexOf(\"div class=\\\"post\\\" id=\\\"post\") != -1) {\n                post = null;\n                date = null;\n                titre = null;\n                try {\n                    post = ligne.substring(ligne.indexOf(\"post-\") + 5, ligne.indexOf(\"\\\"\", ligne.indexOf(\"post-\")));\n                    ligne = br.readLine();\n                    date = ligne.substring(ligne.indexOf(\"<div class=\\\"date\\\"><span>\") + 24);\n                    date = date.replaceAll(\"</span>\", \"\").replaceAll(\"</div>\", \"\").trim();\n                    log.info(\"Post   : \" + post + \" du \" + date);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    titre = ligne.substring(ligne.indexOf(\">\", ligne.indexOf(\"title\")) + 1, ligne.indexOf(\"</a>\"));\n                    titre = titre.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    url2DL = ligne.substring(ligne.indexOf(\"<a href=\\\"\") + 9, ligne.indexOf(\"/\\\"\")).trim();\n                    url2DL = url2DL.replace(\"mega-films.net\", \"mega-protect.com\") + \".php\";\n                    log.info(\"Titre  : \" + titre);\n                    log.info(\"To DL  : \" + url2DL);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    resume = ligne.substring(ligne.indexOf(\"<em>\") + 4, ligne.indexOf(\"</em>\"));\n                    resume = resume.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    log.info(\"Resume : \" + resume);\n                } catch (Exception e) {\n                    log.error(\"ERREUR : Le film n'a pas pu etre parse...\");\n                }\n                log.info(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\");\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getWebPage": ["parsewebpage", "getwebpages", "parsewebPage", "getVirtualPage", "getVirtualpages", "getwebpage", "getWebpage", "parseWebpages", "parsewebpages", "parseWebpage", "getVirtualpage", "parseWebPage", "getwebPage", "getWebpages"], "urlObj": [" urlObject", "URLobj", "resourceObject", "urlExt", "httpobj", "blogobj", "URLObject", "UrlObj", "Urlobj", "urlobj", " urlExt", "URLObj", " urlobj", "strobj", "strObject", "blogObj", "httpOb", "resourceobj", "resourceObj", "URLExt", " urlInst", "blogInst", " urlOb", "strObj", "strInst", "resourceExt", "UrlOb", "urlInst", "urlOb", "httpObj", "urlObject", "blogObject"], "content": ["resource", "online", "section", "clean", "string", "c", "css", "lines", "comment", "response", "core", "java", "continue", "report", "cont", "feed", "empty", "json", "object", "address", "header", "document", "out", "model", "server", "Content", "url", "load", "coll", "work", "array", "code", "value", "page", "result", "html", "output", "data", "write", "raw", "comments", "message", "source", "buffer", "text", "body", "file"], "is": ["il", "or", "isp", "ires", "us", "isa", "ip", "ios", "im", "ois", "isl", "est", "you", "rest", "site", "ir", "irc", "was", "iris", "as", "be", "io", "ais", "abs", "os", "IS", "ui", "cms", "in", "ins", "ri", "does", "ie", "it", "fs", "s", "Is", "out", "iss", "iso", "ar", "ops", "x", "its", "isi", "isc", "i", "any", "mis", "bis", "lis", "ser", "ai", "al", "nis", "r", "ps", "id", "es", "info", "stream", "ris", "ise", "problem"], "reader": ["or", "row", "actor", " Reader", "reading", "oder", "inner", "ler", "io", "ner", "driver", "in", "ri", "er", "handler", "bird", "ro", "l", "rc", "server", "x", "loader", "read", "Reader", "iter", "rer", "e", "director", "i", "worker", "h", "writer", "editor", "ser", "rr", "r", "parser", "rar", "buffer", "stream", "rx"], "line": ["item", "inline", "entry", "row", "pass", "section", "string", "col", "word", "lines", "ine", "LINE", "str", "character", "comment", "Line", " inline", "response", "char", "key", "object", "user", "cr", "cl", "l", "part", "connection", "lin", "cell", "out", "server", "url", "block", "link", "f", "code", "cle", "strip", "page", "data", "lf", "message", "buffer", "source", "text", "body", "column", "name", "file", "lc"]}}
{"id1": "21531069", "id2": "10158738", "code1": "    public int updateuser(User u) {\n        int i = 0;\n        Connection conn = null;\n        PreparedStatement pm = null;\n        try {\n            conn = Pool.getConnection();\n            conn.setAutoCommit(false);\n            pm = conn.prepareStatement(\"update user set username=?,passwd=?,existstate=?,management=? where userid=?\");\n            pm.setString(1, u.getUsername());\n            pm.setString(2, u.getPasswd());\n            pm.setInt(3, u.getExiststate());\n            pm.setInt(4, u.getManagement());\n            pm.setString(5, u.getUserid());\n            i = pm.executeUpdate();\n            conn.commit();\n            Pool.close(pm);\n            Pool.close(conn);\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            Pool.close(pm);\n            Pool.close(conn);\n        } finally {\n            Pool.close(pm);\n            Pool.close(conn);\n        }\n        return i;\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 1, "substitutes": {"updateuser": [" updateusers", "updateusers", "editUser", "UPDATEuser", " updateperson", "updateUser", "UPDATEperson", " updateUser", "editperson", "updateperson", "editusers", "edituser", "UPDATEusers", "UPDATEUser"], "u": ["eu", "iu", "us", "uu", "username", "n", "c", "m", "ru", "o", "uid", "U", "ur", "ue", "util", "ui", "cu", "user", " su", "p", "gu", "up", "l", "w", "du", "ut", "f", "cli", "fu", "e", "su", "ul", "h", "hu", "v", "ou", "tu", "b", "t", "users", "nu", "uri", "client", "mu", "lu", "un"], "i": ["iu", "hi", "si", "qi", "ip", "n", "ii", "c", "m", "pi", "ini", "o", "limit", "d", "ci", "di", "api", "ui", "ri", "bi", "count", "p", "it", "l", "phi", "j", "I", "fi", "f", "cli", "e", "oi", "li", "ori", "ni", "gi", "ti", "mi", "ai", "b", "xi", "t", "id", "info"], "conn": ["dc", "ch", "pc", "pn", "cat", "serv", "cm", "n", "c", "Connection", "pr", "pg", "ca", "act", "col", "Conn", "ann", "ci", "ctx", "con", "api", "pt", "co", "rt", "sync", "Connect", "ct", "oci", "ht", "client", "sql", "loc", "p", "cc", "cl", "connection", "mc", "cn", "rc", "cp", "Exec", "exec", "coll", "server", "cmd", "config", "Sync", "pool", "enc", "cli", "session", "Pool", "Con", "h", "close", "fp", "nt", "jp", "po", "mm", "nc", "lock", "connect", "db", "core", "lc", "MC"], "pm": ["mp", "pc", "LM", "ml", "pd", "vim", "cm", "rm", "m", "em", "pi", "PM", "pb", "pr", "py", "pg", "gp", " PM", "prem", "pl", "hm", "con", "mor", "pt", "px", "param", "pp", "mr", "om", "p", "vm", "wp", "mc", "cn", "pa", "mn", "pool", "cli", "lp", "fm", "am", "sem", "arm", "gm", "dm", "fp", "nm", "mi", "rpm", "mon", "jp", "prom", "module", "mm", "po", "wm", "bm", "db", "lc"]}}
{"id1": "530882", "id2": "18974466", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "21642215", "id2": "1133123", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "label": 0, "substitutes": {"addIDs": ["loadID", "loadLinks", "addIDS", "findIDs", "findLinks", "loadIDS", "addLinks", "loadIDs", "findIDS", "addID", " addIDS", " addID", "findID", " addLinks"], "row": ["item", "entry", "group", "ry", "scan", "col", "table", "view", "copy", "report", "feed", "list", "key", "post", "tr", "user", "bug", "batch", "up", "ro", "cell", "server", "query", "index", "per", "array", "tab", "head", "record", "result", "reader", "raw", "r", "job", "info", "column", "builder", "Row", "ow", "rows"], "name": ["Name", "resource", "username", "description", "n", "string", "word", "title", "str", "named", "time", "path", "search", "key", "number", "connection", "prefix", "query", "size", "filename", "image", "start", "ame", "NAME", "filter", "type", "info", "source", "alias", "file"], "in": ["resource", "string", "In", "token", "container", "again", "serv", "at", "n", "c", "ini", "IN", "rec", "m", "cin", "ex", "cache", "xml", "http", "is", "inner", "din", "bin", "with", "input", "ic", "as", "path", "con", "pin", "ins", "doc", "conn", "min", "inn", "user", "err", "it", "l", "init", "s", "win", "out", "query", "gin", "f", "iter", "session", "i", "nin", "a", "image", "record", "socket", "login", "ssl", "file", "reader", "gen", "diff", "r", "b", "inc", "buffer", "stream", "source", "lock", "re", "update"], "urlName": ["filePart", "fileName", "urlPart", "UrlName", "toolPath", "lname", "URLName", "urlStr", "UrlPart", "lName", "toolName", " urlname", "urlPath", " urlPath", "URLPath", " urlType", "Urlname", "lPath", "urlname", "filePath", "UrlStr", " urlStr", "lStr", "toolname", "filename", " urlPart", "URLname", "lType", "UrlType", "urlType", "UrlPath"], "url": ["resource", "channel", "http", "service", "input", "URL", "path", "io", "open", "feed", "gl", "Url", "client", "user", "bel", "l", "connection", "base", "out", "server", "loader", "sl", "f", "link", " URL", "hub", "image", "socket", "ssl", "reader", "fl", "r", "b", "web", "uri", "stream", "source", "buffer", "org", "file"], "inputLine": ["InputLo", "typeline", "readSync", "rawL", " inputline", "readLook", "inputString", "againLINE", "inputStream", "dataLINE", "readline", "InputBlock", "requestUrl", "inputBlock", "searchLine", "formLINE", "formLin", "indexEntry", "inputline", "dataLink", "formline", "inputLo", " inputSync", "htmlString", "dataRoute", "InputStream", "issueline", "uploadline", "formLine", "Inputline", " inputEntry", "responseFile", "requestEmail", "dataLook", "inputFile", "inputLook", "uploadLin", "dataUrl", " inputFile", "dataSync", "typeLink", "indexLine", "rawFile", " inputString", "htmlline", "typeLine", "inputL", " inputLINE", "inputLink", "InputLink", " inputLo", "updateLine", "input\n", "againLine", "inputWrite", "dataLo", "uploadSel", "dataLine", "indexLINE", "againUrl", "output\n", "execEmail", "readL", " inputLin", "accessLINE", "execLine", "readLin", "baseline", "dataFile", " inputL", "Input\n", "requestLINE", " inputStream", "requestLine", "dataline", " inputUrl", "accessSync", "InputRoute", "requestline", "readFile", " inputWrite", "htmlLine", "InputFile", "inputLINE", "baseLine", "responseLink", "accessLine", "rawline", "inputLin", "dataSource", "updateLin", " inputLook", "htmlLINE", "InputLine", "searchStream", "rawLine", "baseLINE", "againWrite", "typeLINE", "inputSource", "readLine", "responseLine", "inputSync", " inputLink", "uploadLine", "inputUrl", "updateline", "indexSync", "accessEntry", " inputSel", "InputSource", "responseLINE", " inputEmail", "execUrl", "dataLin", "searchFile", "baseFile", " inputRoute", "dataBlock", "inputEntry", "requestString", "issueLine", "updateLINE", " inputBlock", " inputSource", "dataWrite", "inputSel", "inputRoute", " input\n", "InputLINE", "InputSync", "issueLin", "InputL", "execline", "inputEmail", "searchL", "issueSel"], "score": ["scoring", "live", "ranking", "status", " Score", "seed", "fee", "speed", "Score", "player", "winner", "time", "cost", "sc", "match", "ner", "key", "fit", "length", "count", "weight", "grade", "rate", "confidence", "width", "rank", "price", "size", "game", "index", "code", "gain", "value", "rice", "feature", "result", "loss", "test", "level", "error", "message", "core"], "metaboliteID": ["metovaliteName", "metabolitionID", "metabololeName", "metabolheticId", "metmboliqueType", "metabolheticIndex", "metabolitionId", "metabolitableID", "metabolitationId", "metmboliteIDs", "metabolriteIN", "metovaliteAddress", "metabolicizeID", "metovalriteIN", "metabolizeName", "metabolriteScore", "metabolidateScore", "metabolriteAddress", "metabolizeScore", "metabolriteId", "metovalriteIndex", "metabolverseIN", "metabolitableName", "metabolheticID", "metovaliteIndex", "metaboliciteName", "metovalriteId", "metaboliteIDs", "metaboliciteInfo", "metmboliqueIDs", "metovalriteAddress", "metabolitableType", "metaboliqueIDs", "metabolriteIndex", "metabololeSize", "metaboliqueID", "metabolidateInfo", "metmboliqueID", "metabolitationName", "metabolizeID", "metabolitableSize", "metmboliteID", "metaboliciteScore", "metabolicizeName", "metovaliteId", "metabolheticAddress", "metmboliteIndex", "metaboliqueId", "metmbolitableIndex", "metaboliteType", "metovaliteIN", "metovalriteID", "metaboliqueType", "metabolriteInfo", "metaboliteAddress", "metabolriteSize", "metabolriteName", "metabololeIndex", "metabolriteType", "metabolitionAddress", "metovalriteName", "metabolizeInfo", "metaboliteScore", "metabolitionIndex", "metabolverseName", "metaboliteName", "metaboliteId", "metabolverseId", "metaboliciteID", "metabolitationIN", "metabolriteIDs", "metabolitableId", "metaboliteIndex", "metmboliteId", "metmbolitableSize", "metabolitationID", "metabolitableIndex", "metaboliteSize", "metabolicizeScore", "metabolidateName", "metabolidateID", "metabolitableIDs", "metabololeID", "metabolverseID", "metmboliqueId", "metmbolitableID", "metmboliteName", "metmboliteType", "metaboliteInfo", "metabolicizeInfo", "metmbolitableName", "metabolriteID", "metaboliteIN", "metmboliteSize", "metovaliteID"], "dataScore": [" dataMatch", "laScore", " dataLevel", " dataRank", "DataScore", "DataMatch", "inputMatch", "laPath", "numberType", "dataID", "videoType", "DataSize", "doubleWeight", "inputSource", "DataRank", "dataRank", "laSum", "styleWeight", "DataSum", "dataWeight", "numberGrade", " dataSum", "inputScore", "DataPath", "dataPath", "videoScore", "numberWeight", "styleSize", "dataMatch", "dataSize", "indexScore", "DataLevel", "indexPath", "doubleScore", "numberScore", "inputPath", "dataType", "numberLevel", " dataPath", "styleScore", "dataSum", "indexSource", " dataGrade", "doubleRank", "indexID", "styleType", "dataGrade", " dataSize", " dataSource", " dataWeight", "numberRank", "DataGrade", "inputID", " dataType", "videoSize", "laLevel", "dataSource", "inputSize", " dataID", "videoWeight", "doubleType", "dataLevel"], "data": ["resource", "done", "media", "zip", "string", "map", "dat", "results", "area", "response", "input", "empty", "key", "number", "ui", "pad", "json", "div", "content", "weight", "sample", "batch", "missing", "alpha", "DATA", "size", "array", "code", "value", "image", "split", "result", "change", "error", "picture", "style", "ata", "info", "source", "message", "text", "body", "buffer", "extra"], "molecularWeight": ["molecularWidth", "mosellularWidth", "moleularWidth", "mosellularFlow", "mosecularWidth", "moleuralWeight", "molellularFlow", "moleciumWidth", "molecularSize", "molescularWeight", "molellularWeight", "moleculeSize", "mosecularFlow", "molescularWidth", "moleuralWidth", "moleciumWeight", "mosellularWeight", "moleculeWeight", "mosecularWeight", "molecularFlow", "molesularWeight", "moleularSize", "moleuralSize", "moleculeWidth", "molesularWidth", "molesularSize", "moleularWeight", "moleciumFlow", "molescularSize", "moleculeFlow", "molellularWidth"]}}
{"id1": "13565787", "id2": "14733078", "code1": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["encryptString", "encryptedpassword", "decryptPass", "encipherPass", "enccryptpassword", "decipherPassword", "decryptPassword", "encryptPass", "decryptString", "encryptpassword", "enccryptString", "enccryptPassword", "encryptedPassword", "encipherPassword", "enccryptPass", "encipherString", "decipherpassword", "decryptpassword", "decipherString", "decipherPass", "encryptedPass", "encipherpassword", "encryptedString"], "plainPassword": ["plainString", "messagepassword", "encryptedpassword", "protectedpassword", "protectedPass", " plainCode", "messageText", "flatText", "flatpassword", "plainCode", "flatPassword", " plainpassword", "encryptedPassword", " plainText", " plainPass", "plainPass", "messageCode", " plainString", "encryptedPass", "messagePassword", "flatCode", "plainpassword", "protectedString", "encryptedString", "protectedPassword", "plainText"], "sb": ["mb", "usb", "bh", "nb", "erb", "si", "sth", "bs", "bps", "pb", "sf", "bm", "gs", "bg", "bd", "BG", "buf", "sa", "obb", "bsp", "bp", "SB", "eb", "orb", "xb", "lb", "gb", "ls", "url", "sp", "wb", "bc", "zb", "BB", "kb", "split", "cb", "fp", "ssl", "bb", "sg", "obj", "sv", "bj", "b", "bf", "buff", "fb", "buffer", "binary", "bt", "ab", "src", "rb", "db"], "messageDigest": ["messageDest", " messageDigenge", "messagedigenge", "messageDester", " messageDigester", "messageDger", "messagedigested", "messagediger", "messageDiger", "MessageDigester", "messagedigest", "messageDigester", "messageMarkested", "messageRobest", "messagedigester", "messageMarkusher", "messageDigusher", " messageDested", "MessageDesignest", "messageDesignester", "messagedigger", " messageDest", "MessageDesigner", " messageDigusher", "messageAddesting", "messageDested", "MessageDesignester", " messageDester", " messageDusher", " messageDger", "messageMarkest", "messageAddester", "MessageDigesting", "messageDigenge", " messageDenge", "messageDigested", "messageDenge", "MessageDesignesting", "messageDesignest", "messageDesigner", "messageDusher", "messageRobenge", " messageDigested", "messageDesignesting", "messageRobester", "MessageDigest", "messageAdder", "messagedigusher", " messageDigger", "messageDigger", "MessageDiger", "messagedigesting", "messageAddest", "messageDigesting", "messageMarkester", "messageRobger"], "digestBytes": ["digestedByte", "digestbytes", "Digestbytes", "DigestPart", "DigestedByte", "DigestString", "digestString", " digestedbytes", "digestedbytes", "digestByte", "DigesterByte", "DigesterPart", "digesterBytes", "digESTByte", "Digesterbytes", "digestedBytes", "digESTbytes", "dighestbytes", "digestedPart", "digesterbytes", "DigestBytes", "DigestedString", "Digestedbytes", "digseString", "digsebytes", "digesterByte", "digESTParts", "digesterPart", " digestedParts", "DigestByte", " digestParts", " digestbytes", "dighestByte", "digestedString", " digestByte", "digestedParts", " digestedByte", " digestedBytes", "dighestPart", "digesterParts", "digestParts", "dighestBytes", "digseBytes", "digestPart", "digseByte", "DigesterBytes", "digesterString", "DigestedBytes", "digESTBytes"], "hex": ["hs", "ctr", "wh", "cmp", "ip", "zip", "string", "cache", "utf", "rh", "ex", "exp", "str", "bin", "sha", "path", "shape", "bits", "char", "key", "json", "num", "length", "coord", "letter", "address", "header", "lit", "kh", "cookie", "ph", "oct", "alph", "url", "x", "pex", "index", "serial", " Hex", "iter", "su", "rex", "sex", "tx", "xf", "hash", "format", "h", "check", "ext", "dig", "digit", "null", "pack", "buff", "id", "pattern", "binary", "text", "form"], "i": ["hi", "si", "qi", "ip", "u", "multi", "n", "c", "ii", "m", "pi", "k", "o", "d", "ci", "di", "io", "slice", "ui", "length", "ri", "bi", "p", "l", "s", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "v", "gi", "ti", "ai", "r", "b", "zi", "t", "id", "xi", "uri", "ix", "end"]}}
{"id1": "21152728", "id2": "15409512", "code1": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 0, "substitutes": {"authenticate": ["authentication", "authication", " authentication", "authicate", "authenticating", "authicating", "Authenticating", " authenticating", " authenticated", "Authenticated", "authicated", "Authenticate", "authenticated", "Authentication"], "module": ["resource", "entry", "role", "class", "pm", "project", "cm", "instance", "m", "site", "py", "method", "table", "script", "str", "service", "scope", "input", "msg", "manager", "ctx", "io", "pin", "object", "mode", "conn", "address", "unit", "mission", " modules", "header", "vm", "rule", "connection", "base", "mod", "device", "chain", "domain", " Module", "server", "model", "component", "element", "prefix", "config", "query", "member", "data", "mi", "require", "Module", "plugin", "message", "course", "lock", "name", "file", "modules"], "rand": ["rot", "token", "chance", "seed", "bot", "push", "NG", "raid", "winner", "right", "sum", "gram", "rage", "pad", "in", "auth", "conn", "random", "min", "alpha", "dd", "ro", "ng", "init", "bird", "rc", "out", "reg", "max", "Rand", "han", "nd", "gd", " random", "range", "gen", "r", "rar", "pattern", "round", "crypt", "grad", "re"], "challenge": ["buckonge", "chenge", "chalge", "challenges", "chalenges", "chge", "passge", "scheise", "schege", "challge", "challaine", "scheaine", "buckchall", " challge", "Challise", "Challaine", " challonge", "chalise", "Challenge", "scheenges", "scheenge", "buckge", "Challge", "passenge", " challchall", "challonge", "buckenge", "challchall", "passise", "challise", "chalenge", "Challonge", "Challchall", "passenges", "chise", "chaine"], "b64": ["bbl", "xb48", "base62", "b62", "mb16", "B64", "B58", "base48", "b58", "basebl", " b16", "xb62", "base36", "bb64", " b4", "base64", "B4", "base16", "b4", " b36", " b58", "b16", " b48", "bb36", "xbbl", "b36", "bb58", "mb4", " bbl", "mb64", "B16", "base58", " b62", "xb64", "mb58", "b48", "bb16"], "reply": ["Response", "entry", "voice", "route", "respond", "string", "related", "py", "request", "secret", "http", "comment", "reset", "service", "answer", "report", "queue", "sync", "address", "frame", "resp", "connection", "part", " replies", "base", "ridge", "out", "replace", "prefix", "server", "query", "link", "notice", "Reply", "received", "remote", "result", "repl", "range", "next", "error", "data", "write", "parse", "rr", "id", "message", "info", "buffer", "uri", "text", "body", "back", "reason", "template"], "user": ["resource", "role", "entry", "pass", "route", "token", "use", "username", "project", "full", "string", "host", "word", "request", "secret", "comment", "cover", "service", "proxy", "character", "uid", "manager", "open", "match", "key", "force", "pin", "client", "creator", "me", "object", "address", "bug", "USER", "valid", "profile", "rule", "device", "replace", "out", "consumer", "server", "url", "query", "per", "field", "date", "session", "allow", "password", "User", "by", "used", "result", "login", "author", "error", "type", "data", "write", "plugin", "id", "account", "users", "source", "ver", "text", "parent", "using", "name", "lock", "person"], "response": ["resource", "Response", "status", "token", "description", "respond", "string", "respons", "host", "request", "secret", "service", "answer", "api", "json", "object", "address", "header", "profile", "resp", "connection", "model", "server", "url", "session", "password", "format", "result", "output", "error", "data", "account", "message", "uri", "body", "version"], "secrets": ["Secrets", "secret", "SECards", "SECret", "securityurs", "Secredits", "securityrets", "secures", "securityret", "secredits", "subrets", " secret", "Secards", "regrets", "subret", " secredits", "secards", "regret", "securityures", "SECurs", "securs", "regurs", "subredits", "SECures", "regards", "Securs", "SECrets", "Secures", "Secret"], "md4": [" md44", "madfour", "shafour", "mcfour", "sha04", "MD2", " md04", "mc4", " MD6", "sha4", "MD6", " md256", "mc6", " md6", "MD04", "md2", " md5", "sha44", "md5", "mad4", " md2", "MD44", "md6", " mdfour", "sha2", "mdfour", " MD4", " MDfour", "mad2", "sha6", "MD4", "mc5", " MD2", "MDfour", "mad04", "md256", "md44", "MD256", "md04", "sha5", "mad256"], "line": ["inline", "look", "entry", "row", "pass", "status", "string", "lines", "LINE", "str", "comment", "le", "Line", "log", "sync", "object", "letter", "header", "profile", "frame", "rule", "l", "part", "cl", "lin", "cell", "model", "out", "server", "url", "pe", "shell", "definition", "block", "link", "code", "value", "strip", "record", "lo", "page", "range", "error", "data", "parse", "style", "lf", "message", "lock", "text", "body", "name", "file", "lc", "end"], "passwd": ["assw", " passpass", "Passpassword", "PassWD", "passpass", "passwordpass", "pw", "Passpass", "Passw", "passw", "Password", "passwordwd", "asspass", "passwordword", "Passwd", "passpassword", " password", "password", "passwordpassword", "ppass", "asswd", "assWD", " passpassword", "pWD", "passWD", "pwd"], "hash": ["body", "hed", "shadow", "sh", "cache", "Hash", "rh", "secret", "cover", "sha", "sum", "match", "hex", "key", "object", "header", "kh", "build", "flash", "ha", "tag", "base", "server", "url", "ash", "array", "value", "her", "image", "check", "h", "html", "style", "sign", "id", "block", "version"]}}
{"id1": "7372311", "id2": "1097147", "code1": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"generateDeviceUUID": ["generateDeviceUID", "generateDeviceSUuid", "generatedeviceUUID", "generateDeviceSUMD", "generateDeviceCID", "generateDeviceSUID", "generateDeviceCuid", "generateDeviceUMD", "generatedeviceUuid", "generateDeviceUuid", "generateDeviceCMD", "generateDeviceCUID", "generateDeviceSUUID", "generatedeviceUMD", "generatedeviceUID"], "md5": ["mand2", "MD75", "mand5", "MD2", "MD5", " md75", " MD3", "md2", "md75", "md95", " md4", "md4", " md2", " MD5", "MD95", " MD75", "mem4", "mem3", "mand4", "MD55", "md55", " md95", "md512", "MD4", "mand3", " MD2", " md512", "mem5", "MD512", " md55", "md3", "mand95", "mem55", " MD512", "MD3", " md3"], "hexString": [" hexList", "pexArray", "dumpArray", " hexFile", "hashString", "stringString", "dumpBuffer", "hashList", "hexstring", "dumpString", "pexstring", "hexFile", "formstring", "octString", "hashFile", " hexstring", "stringList", "formBuffer", " hexBuffer", "hexArray", " hexArray", "hexBuffer", "stringArray", "octArray", "hexStr", "formString", "pexString", "hexList", "octBuffer", "octStr", "formArray", "pexBuffer", "stringFile", "hashArray", " hexStr", "dumpStr"], "digest": ["sumests", "digse", "signse", "Digense", "mdest", "indexests", " digests", "feedester", "Digester", "sumse", "feedense", "mdested", "signest", "Digested", " digense", "feedested", " digEST", "digested", "digester", "codEST", "indexester", "DigEST", " digester", "codester", "mdse", " digested", "digense", "codests", "mdests", "digEST", "sumested", "sumest", "signests", "indexEST", "signested", "Digests", "digests", "Digest", "feedest", "indexest", "codest"], "i": ["si", "qi", "u", "at", "multi", "k", "c", "ii", "m", "pi", "o", "shift", "d", "ci", "di", "io", "slice", "ui", "length", "ri", "bi", "count", "p", "l", "phi", "s", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "h", "v", "gi", "ti", "ai", "r", "b", "xi", "t", "id", "zi", "uri", "mu", "end"], "uuid": ["suID", "suids", "uid", "euid", "euID", "euuid", "uID", "uids", "euids", "uuuid", "uuids", "suuid", "uuID", "suid"], "runTimeEx": ["runTimesExcept", "RunTimeEx", "runetimeExcept", "runContextObj", "RunTimesEx", "runTimeException", " runTimeException", " runtimeEx", "runTimeExcept", "RunTimeExcept", "runtimeExcept", "runTypeEx", "runTimeOut", "runTypeException", "runTimesObj", "runTimesException", "runtimeOut", "RunTimesExcept", "runTimeObj", "RunTimeOut", "runContextEx", "runTimesExc", "runtimeException", " runtimeException", "RunTimesObj", "runSizeException", "runSizeObj", "runTimesEx", "runSizeEx", "runetimeEx", "runtimeEx", "RunTimeExc", "RunTimesExc", "RunTimesException", "runTimesOut", "runTypeOut", "RunTimeObj", "runContextException", " runtimeExcept", "runTimeExc", "runtimeExc", "runTypeExc", "runetimeException", "runSizeExcept", "runContextExcept", "RunTimesOut", "RunTimeException", " runTimeExcept"]}}
{"id1": "14053882", "id2": "1156851", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public void runWeb(String beginURL, String contextRoot, String pageURI) {\n        if (bDebug) System.out.println(\"WEB Path\");\n        List<String> vtURLs = new ArrayList<String>();\n        List<String> vtRobots = getRobots(beginURL, contextRoot);\n        vtURLs.add(\"/\" + contextRoot + \"/\" + pageURI);\n        Indexer indexer = null;\n        IndexDocument indexDoc = null;\n        try {\n            indexer = new Indexer(\"/tmp/tmp/index\");\n            for (String sxURL : vtURLs) {\n                if (bDebug) System.out.println(\"\\n\\n*** INDEXING \" + sxURL);\n                if (bDebug) System.out.println(\"Have - \" + sxURL);\n                boolean bIndexPage = true;\n                if (vtRobots != null) {\n                    for (String sxRobotURL : vtRobots) {\n                        if (bDebug) System.out.println(\"Comparing to - \" + sxRobotURL);\n                        if (sxURL.startsWith(sxRobotURL)) {\n                            if (bDebug) System.out.println(\"Found URL - \" + sxRobotURL + \" - \" + sxURL);\n                            bIndexPage = false;\n                            break;\n                        }\n                    }\n                } else {\n                    bIndexPage = true;\n                }\n                sxURL = beginURL + sxURL;\n                ParserDelegator pd = new ParserDelegator();\n                CallbackHandler cb = new CallbackHandler(vtURLs, bIndexPage, contextRoot);\n                try {\n                    URLConnection urlConn = new URL(sxURL).openConnection();\n                    urlConn.setUseCaches(false);\n                    Date modDate = new Date(urlConn.getLastModified());\n                    if (bDebug) System.out.println(\"\\nMatch - \" + sxURL + \" - Modified Date - \" + modDate);\n                    BufferedReader bfReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n                    pd.parse(bfReader, cb, true);\n                    if (bIndexPage) {\n                        if (bDebug) System.out.println(\"Adding Index - \" + sxURL + \"\\nContent:\" + cb.getText() + \"\\nSummary:\" + cb.getSummary() + \"\\nTitle:\" + cb.getTitle());\n                        indexDoc = new IndexDocument();\n                        indexDoc.setUID(sxURL + modDate.toString());\n                        indexDoc.setPageURL(sxURL);\n                        indexDoc.setModifiedDate(modDate.toString());\n                        indexDoc.setContents(cb.getText());\n                        indexDoc.setTitle(cb.getTitle());\n                        indexDoc.setSummary(cb.getSummary());\n                        indexer.addDocument(indexDoc);\n                    }\n                } catch (Exception ee) {\n                    PetstoreUtil.getLogger().log(Level.SEVERE, \"Inner Exception\" + ee);\n                }\n            }\n        } catch (Exception e) {\n            PetstoreUtil.getLogger().log(Level.SEVERE, \"Outer Exception\" + e);\n        } finally {\n            try {\n                if (indexer != null) {\n                    indexer.close();\n                }\n            } catch (Exception ee) {\n                ee.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["encryption", " enrypt", " enryption", " enipher", "decryption", "decrypt", " encryptcode", " encode", " encryptryption", " encryptrypt", "encipher", "deccode", "enccode", "decipher", " encryptipher"], "plaintext": ["protectedstruct", "encryptedText", "givenfont", "plainstruct", "plaincontent", "battext", "giventext", "batsource", "batstring", "encryptedcontent", "protectedcontent", " plainText", " plainstruct", " plainstring", " plainfont", "plainsource", " plainsource", "givenstring", "encryptedtext", "givensource", "protectedText", "batfont", " plaincontent", "protectedtext", "encryptedstruct", "plainstring", "plainfont", "plainText"], "md": ["dc", "df", "mb", "mg", "mp", "pd", "ms", "pm", "od", "mage", "mand", "cm", "mac", "Cmd", "m", "pg", "sm", " MD", "d", "sha", "hm", "da", "MD", "bd", "meta", "wd", "alg", "hd", "ad", "dd", "ph", "mc", "cd", "mod", "cmd", "dh", "dr", "ma", "mag", "pkg", "code", "am", "dm", "material", "cb", "nm", "amd", "data", "dig", "kg", "mm", "metadata", "po", "mad", "mt", "mu", "mo"], "raw": ["row", "full", "clean", "string", "instance", "initial", "unknown", "sha", "input", "response", "partial", "wave", "feed", "hex", "text", "buf", "empty", "auth", "json", " RAW", "pure", "ack", "original", "shared", "rc", "rew", "load", "array", "enc", "Raw", "serial", "wrapper", "image", "unsigned", "data", "null", "pack", "RAW", "binary", "stream", "buffer", "block", "dec"], "hash": ["sh", "mac", "cache", "href", "Hash", "rh", "secret", "sha", "response", "sum", "log", "hex", "key", "auth", "ashes", "length", "header", "kh", "ha", "base", "url", "ash", "array", "index", "password", "her", "image", "h", "html", "data", "id", "message", "buffer", "block", "version"]}}
{"id1": "3801655", "id2": "10795866", "code1": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"helper": ["shp", "scheper", "helpler", "helppherd", "Helper", "sher", "heller", "Heler", "harler", "harpherd", "Help", "helpHelper", "shmer", "workper", "scheler", "schepherd", "helpherd", "shper", "helpper", "workp", "heler", "help", "worker", "scheHelper", "helmer", "helHelper", "Helmer", "harHelper", "harper", "workmer"], "dataset": [" DatASet", "datAset", "DatASET", "datasert", "datASheet", "DatasET", "datapset", "metaset", "datASets", "datastET", "metasET", "datAsets", "datassET", "metassert", "datassets", "datraset", " DatasET", "datrasET", "datASET", " Dataset", "datassheet", "datasET", " DatASheet", "DatASets", "metassET", " Datasets", "datastets", "Dataseter", "DatASeter", "datapsert", "datacet", "datapsheet", " DatASets", "metassheet", "datacET", "datacert", "datacheet", "metasert", " Datasheet", "Datasets", "datassert", "datapsET", "datASet", " DatASET", "datAsheet", "datrasets", "metasheet", "datasteter", "datASeter", "dataseter", "datAsET", "datasset", "Dataset", "datasheet", "metasset", "DatASet", "datraseter", "datastet", "datasets"], "zip": ["folder", "pipe", "wrap", "window", "pdf", "ip", "py", "xml", "service", "copy", "java", "io", "z", "slice", "tar", "zone", "Zip", "dir", "archive", "handler", "bug", "p", "bag", "out", "sea", "system", "sl", "f", "flat", "pkg", "code", "gz", "split", "ssl", "se", "secure", "data", "parse", "directory", "plugin", "pack", "jar", "git", "lock", "binary", "loop", "source", "file"], "entries": ["delements", "ENTrees", "ntents", "entlines", "entslections", "itrys", " entlines", "entrants", "itries", "iterries", " entlements", "intlements", "ENTries", "intities", "deents", "inflines", "deries", "entsries", "contrys", "contries", "ntries", "infities", "infrees", "entrees", "intries", "ENTlections", " entities", "entsrants", "itents", "contents", "entrys", "entryents", "itry", "entities", "ntrys", "ntry", "iterlements", "entents", "inflements", "iterents", "intlines", "inflections", "contry", "ENTrants", "entsrees", "infries", "entryries", "entlements", "entrylements", "entlections", "infrants"], "performance": [" writers", "slave", "each", "stats", "union", " ratio", "U", " unit", "Unit", "util", " units", "ui", " split", "unit", "book", "it", " Units", "exec", "work", "rank", "its", "ul", "units", " Unit", " u", " result", "runner", " group", " output", " suite"], "index": ["position", "depth", "limit", "Index", "path", "key", "number", "num", "length", "count", "unit", "order", "pos", "x", "iter", "i", "value", "head", "page", "level", "type", "write", "id", "offset", "name"], "entry": ["folder", "row", "or", "route", "ry", "section", "si", "xml", "Entry", "inner", "service", "input", "export", "feed", "key", "add", "post", "in", "child", "archive", "ie", "it", "connection", "part", "cell", "element", "pe", "install", "server", "office", "e", "her", "record", "result", "nt", "se", "data", "write", "obj", "parse", "r", "style", "pattern", "info", "uri", "stream", "cel", "file", "lc"], "temp": ["folder", "wrap", "txt", "pipe", "local", "full", "clean", "cache", "context", "table", "http", " temporary", "input", "copy", "path", "partial", "io", "ctx", "empty", "dest", "original", "archive", "single", "p", "store", "valid", "part", "w", "base", "out", "storage", "layout", "tmp", "thread", "tem", "config", "office", "fake", "f", "flat", "iter", "session", "emp", "tc", "test", "output", "Temp", "data", "directory", "stable", "porary", "parent", "lock", "binary", "cel", "file", "template"], "writer": ["riter", "or", "war", "writers", "player", "wer", "inner", "ler", "layer", "log", "outer", "manager", "Writer", "io", "engine", "wave", "key", "feed", "driver", "handler", "er", "wire", "w", "sw", "out", "element", "server", "loader", "ws", "per", "iter", "holder", "rw", "wrapper", "worker", "editor", "wr", "output", "writing", "write", "written", "author", "r", "stream", "builder", "file"], "reader": ["or", "ry", "ter", "reading", "upper", "oder", "http", "inner", "ler", "input", "io", "ner", "feed", "driver", "ri", "handler", "er", "iterator", "element", "server", "loader", "Reader", "iter", "rer", "per", "f", "wrapper", "i", "worker", "editor", "ser", "write", "rr", "r", "rar", "stream", "builder", "file"], "buffer": ["resource", "row", "seed", "position", "channel", "initial", "capacity", "table", "uffer", "limit", "character", "input", "layer", "wave", "sequence", "feed", "buf", "queue", "slice", "length", "address", "header", "batch", "document", "device", "server", "size", "Buffer", "iter", "bytes", "transfer", "result", "memory", "data", "write", "null", "buff", "flush", "message", "offset", "source", "binary", "reference"], "read": ["reads", "pass", "run", "use", "send", "g", "k", "readable", "current", "reading", "view", "fill", "select", "sleep", "available", "input", "copy", "READ", "old", "report", "open", "feed", "process", "eval", "add", "text", "skip", "sync", "download", "length", "child", "count", "book", "build", "print", "Read", "play", "ad", "seek", "default", "exec", "find", "get", "load", "work", "config", "size", "max", "x", "wait", "iter", "allow", "ind", "check", "start", "close", "ride", "next", "save", "parse", "write", "data", "type", "se", "raw", "id", "connect", "create", "end"], "outfile": ["inline", "Outline", " outline", "logdata", "logfile", "Outf", " outFile", "againfile", "outline", "outdir", " outf", "infile", "outdata", "outfilename", " outdata", "instream", " outfilename", "Outfile", "againdir", "outf", "logFile", "inFile", "indata", "logfilename", "inf", "outFile", "againline", "Outdir", "infilename", "Outstream", " outstream", "indir", "outstream", "againstream"], "line": ["item", "inline", "look", "band", "pass", "status", "row", "section", "ip", "string", "lines", "word", "LINE", "ine", "str", "comment", "le", "Line", "side", "log", "sync", "on", "object", "letter", "header", "frame", "l", "lin", "cell", "url", "link", "code", "cle", "strip", "el", "split", "val", "page", "filter", "range", "error", "data", "parse", "type", "style", "lf", "job", "sel", "text", "block", "column", "name", "file", "end"], "parser": ["class", "function", "string", "oder", "xml", "ler", "manager", "params", "umper", "angler", "driver", "er", "handler", "book", "p", "cher", "server", "Parser", "system", "loader", "processor", "pool", "per", "lp", "wrapper", "worker", "plan", "arser", "test", "parse", "data", "type", "plugin", "r", "pattern", "par", "builder"], "list": ["group", "and", "map", "join", "table", "right", "can", "match", "listed", "er", "p", "LIST", "l", "part", "base", "all", "out", "chain", "get", "left", "array", "pool", "other", "lp", "best", "li", "set", "plan", "val", "v", "result", "test", "filter", "data", "type", "member", "r", "lists", "info", "parent", "collection"], "rule": ["item", "row", "group", "class", "function", "ule", "table", "str", "ee", "service", "layer", "match", "tree", "Rule", "rl", "ri", "header", "er", "lr", "dict", "base", "rate", "pe", "model", "event", "per", "field", "li", "ul", "record", "val", "rules", "range", "data", "rol", "parse", "style", "r", "plugin"], "measure": ["Measured", "speasure", "measured", "speasures", "Measure", "feasuring", "measuring", "speasured", "feasured", "feasure", "feasures", "Measuring", "Measures", "speasuring", "measures"]}}
{"id1": "3252116", "id2": "11865906", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"getMD5": [" getSHA3", "getMP3", "getMAC4", "getMD512", "getMAC512", "getMP512", "getSHA5", " getSHA5", "getSHA3", " getSHA512", " getMD4", " getMD512", "getMAC3", "getMAC5", "getMD4", " getSHA4", "getMP5", "getMP4", " getMD3", "getSHA512", "getMD3", "getSHA4"], "source": ["resource", "body", "stream", "string", "Source", "secret", "service", "input", "ource", "from", "slice", "this", "dest", "content", "object", "connection", "document", "base", "security", "url", "sp", "config", "sl", "f", "e", "code", "password", "SOURCE", "fp", "result", "output", "data", "target", "parent", "buffer", "text", "uri", "src", "file"], "s": ["js", "si", "S", "ings", "ses", "n", "string", "g", "m", "results", "sym", "d", "sets", "is", "gs", "series", "os", "ins", "p", "fs", "strings", "ls", "als", "ops", "its", "ws", "sl", "f", "sb", "services", "e", "ns", "ds", "h", "bytes", "ssl", "ts", "bis", "sg", "r", "b", "ps", "t", "es", "rs", "ends", "ss", "rows"], "hexDigits": ["hashDigats", "hexSignists", "tempSignits", "tempDigists", "hashDigists", "hexDigals", "hexFormists", "hexDigitives", "hexEdits", "hexFormits", "hexdigats", "hexSignites", "hexDigites", "hexdigings", " hexDigases", "hashFormits", "hexdigals", "hexdigites", "hashFormats", "hexSignit", "hashDigits", "tempSignites", "hexdigases", "hexSignings", "hexDigats", "hexSignitives", "hexEdists", "hexFormats", "hexDigings", "hashFormists", "hexSignits", "tempDigals", "hexEdals", "hexDigists", "tempSignists", "hexdigists", "hexDigases", "hexdigitives", "hexSignases", "hexdigit", "hexSignats", "hexSignals", "hexdigits", " hexDigings", " hexDigit", "tempSignals", "hexFormitives", "hexEdites", "hashDigitives", "hashFormitives", "tempDigits", "tempDigites", "hexDigit"], "md": ["dc", "df", "mb", "mg", "mp", "mail", "pd", "pm", "mand", "cm", "mac", "rm", "m", "em", "sm", " MD", "um", "sha", "di", "MD", "bd", "meta", "wd", "hd", "dd", "mc", "cd", "cmd", "ma", "mag", "f", "am", "dm", "nm", "amd", "mi", "rpm", "dig", "mm", "bf", "metadata", "vd", "mad", "mt", "mu"], "tmp": ["txt", "temp", "mp", "cmp", "seed", "append", "stuff", "pointer", "cpp", "area", " temp", "params", "api", "np", "buf", "dest", "meta", "pad", "pp", "ppo", "bp", "sup", "p", "wp", "app", "proc", "base", "storage", "sp", "config", "now", "array", "pre", "cb", "v", "img", "test", "data", "obj", "fb", "buff", "buffer", "bt", "rb", "extra"], "str": ["txt", "temp", "ctr", "fr", "stri", "string", "pr", "exp", "spec", "inner", "char", "hex", "sr", " substr", " sp", "doc", "STR", "div", "tr", "unit", "err", "br", "dict", "cr", "part", "pos", "j", "exec", "arr", "cur", "sp", "dr", "cs", "sec", "sl", "enc", "iter", "code", "v", "st", "ss", "data", "hr", "obj", "style", "r", "Str", "text", "dec"], "k": ["ks", "ch", "kw", "u", "n", "c", "g", "y", "o", "ko", "d", "kat", "mk", "key", "ak", "dk", "p", "w", "ki", "j", "work", "x", "f", "e", "kick", "q", "ok", "ku", "v", "sk", "b", "K", "id", "unk", "kk", "ek", "kid", "ck"], "i": ["iu", "hi", "si", "chi", "qi", "ip", "u", "multi", "ii", "c", "n", "m", "pi", "y", "ini", "shift", "d", "abi", "ci", "di", "io", "z", "ji", "ui", "in", "ri", "bi", "p", "it", "l", "phi", "j", "I", "x", "index", "f", "e", "oi", "li", "a", "v", "ti", "gi", "ai", "b", "xi", "t", "info", "uri", "mu"], "byte0": [" byte5", "word1", " byte00", "byte1", "byte6", "bytek", "pixel0", "pixel2", "pixel5", " byte6", "letter2", "byte5", "word2", "number5", "number2", "pixel6", "byte00", "letter00", "letterk", "pixel00", "number6", "letter0", "word0", " byte2", "number1", "byte2", " byte1", "numberk", "number0", "number00", "pixelk", "word5"]}}
{"id1": "12428013", "id2": "21308543", "code1": "    public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) {\n        if (monitor != null && monitor.isCanceled()) {\n            return;\n        }\n        try {\n            ftpClient = new FTPClient();\n            ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST)));\n            ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT));\n            ftpClient.connect();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD)));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (from != null) {\n                FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false);\n                synchedSet.add(ftpHolder);\n            }\n            JobHandler.aquireFTPLock();\n            for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) {\n                if (monitor != null && monitor.isCanceled()) {\n                    JobHandler.releaseFTPLock();\n                    ftpClient.quit();\n                    return;\n                }\n                Thread.yield();\n                FTPHolder element = (FTPHolder) iter.next();\n                ftpClient.setType(FTPTransferType.ASCII);\n                ftpClient.put(element.from, element.to);\n                if (element.renameTo != null) {\n                    try {\n                        ftpClient.delete(element.renameTo);\n                    } catch (Exception e) {\n                    }\n                    ftpClient.rename(element.to, element.renameTo);\n                    log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo);\n                }\n            }\n            JobHandler.releaseFTPLock();\n            ftpClient.quit();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (FTPException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        synchedSet.clear();\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 0, "substitutes": {"polishOff": [" polishingOn", " synchroniceDown", " polishDown", " synchronishOn", " synchronishingOn", " synchronipeDown", " synchroniceOffline", " synchronishOffline", " polishOn", " polishOffline", " synchronishingOffline", " synchronishOff", " synchronishingOff", " polishingOff", " synchronipeOff", " synchroniceOn", " polishingOffline", " synchronipeOffline", " synchroniceOff", " polishingDown", " synchronishDown", " synchronishingDown", " synchronipeOn"], "monitor": ["timeout", "or", "reason", "watch", "status", "username", "container", "pm", "function", "cm", "m", "sm", "method", "state", "condition", "log", "report", "manager", "mor", "match", "number", "driver", "umi", "progress", "conn", "object", "client", "handler", "cher", "unit", "mc", "consumer", "program", "port", "component", "thread", "clock", "config", "loader", "processor", "control", "Monitor", "controller", "period", "don", "callback", "image", "dm", "widget", "stat", "counter", "member", "runner", "directory", "mon", "meter", "module", "annot", "duration", "timer", "message", "update", "oper", "master", "body", "core"], "from": ["resource", "action", "or", "actor", "attribute", "route", "username", "owner", "who", "at", "front", "string", "channel", "host", "false", "with", "From", "about", "path", "vol", "contact", "add", "form", "email", "ce", "user", "address", "loc", "connection", "part", "base", "since", "prefix", "server", "small", "url", "component", "left", "size", "code", "by", "start", "remote", "range", "type", "ou", "id", "back", "source", "uri", "org", "name", "origin"], "to": ["resource", "token", "so", "full", "site", "o", "go", "reply", "table", "version", "with", "about", "io", "key", "dest", "database", "user", "address", "into", "connection", "base", "pos", "TO", "out", "prefix", "two", "server", "url", "location", "To", "left", "size", "eto", "su", "value", "by", "top", "remote", "repl", "until", "range", "type", "target", "po", "info", "uri", "source", "toc", "name", "file", "ref"], "renameTo": ["renAMEto", "renAMEToken", "renameFrom", " RenAMETarget", "renenameto", " renAMETarget", "renenameFrom", "renamelOf", "renributeFor", "relenameto", "renributeTarget", "renseTo", "reameTo", "renAMEWill", "renalFrom", "renenameUrl", "renewTo", " RenseTo", " RenameTO", "relenameFrom", "renamelTO", "renokeTo", "renokeTO", "renalTarget", " RenAMEFor", "renoketo", "reageToken", "renameFor", "renamTo", "relenameTo", "relalto", "renalToken", " RenseFor", " RenameOf", "renokeOf", "relalTarget", " renAMEFrom", "renameto", "relameUrl", "renameWill", "renseOf", "renameOf", "renameToken", "renamWill", "reameTO", " RenameTarget", "relalTo", " RenseTO", " RenAMETo", "relameto", "renAMEUrl", "renAMETO", " renameFrom", "renributeWill", "renokeFrom", "reageTO", "relalFrom", "renamFor", "relameFrom", "renamelFor", "renalTO", "renageTO", "rennameTo", "reameto", "renameTO", "renalTo", " RenseOf", "renameTarget", "renageTo", "reageto", "renenameTo", "renributeTo", "rennameFrom", "renAMEFor", " renAMETo", "renageto", " RenameTo", "renAMEFrom", "renamTarget", "renageToken", "renAMETo", "renewFrom", "relameTarget", "rennameto", "renseFor", "renseTO", "renalto", "renenameTarget", " RenameFor", "renokeFor", "renewTarget", "reameToken", "renAMETarget", "renamelTo", "rennameTarget", "renameUrl", " RenAMEWill", "renokeUrl", "relenameUrl", "reageTo", " renameTarget", "relameTo", " RenameWill"], "ftpClient": [" ftpoCenter", " ftpiHost", " ftoHost", "afttStream", " fttpControl", "ftapiCloud", "ftlCommunity", "fticlient", " ftoClient", " ftnHost", "ftpcHelper", "ftcpHost", "ftpsContainer", "ftpCan", "ftmClient", "ftpoCenter", "ftapiClient", "ftpsControl", "ftpHost", "ftcpResource", "ftcServer", "ftfpResource", " ftlClient", "ftapiServer", "ftpClass", " ftpCan", "ftfpCenter", "ftcpGuest", " ftlCenter", "ftcpServer", "ftpCommunity", " ftpChannel", "ctpClient", "ftlClient", " ftpoCloud", "ftpcCloud", " ftpCloud", "ftpcServer", "ftfpCloud", " ftoCan", "ftfpClient", " ftpclient", " ftlConnection", "ftpHelper", " ftoServer", "ftbHost", "ftcclient", "ftnServer", " ftpGuest", "ctcpChannel", "ftoClient", "ftfCenter", " ftiServer", "ftnHost", "ftpiServer", "fttpStream", " ftapiHelper", "afttClient", "ftoCan", "ctpChannel", "ftlConnection", "fttpCan", "ctpServer", " ftiGuest", "ftiClient", "fttpControl", "ftoHost", "ftbrClient", " ftpControl", "ftfClient", "ftpcConnection", "ftpControl", "ftpiClient", "aftpClient", "ftmResource", "ftpcCommunity", "fttpContainer", "ctcpServer", "fttpClass", "ftpoClient", "ftnClient", " ftnClient", " ftpContainer", " ftlCommunity", "ftpServer", "ftmServer", "ftcpHelper", "ftpResource", "ftcGuest", " fttpClass", "ftpiChannel", " ftpiChannel", "ftpoCloud", "fttpHost", " fttpClient", "ftcpCloud", "ftpContainer", "ftpiHost", "ftpCenter", " fttpContainer", "ftpcContainer", "ftbrStream", "ftpConnection", " ftnServer", "ftoServer", "ftpsClass", "ftpStream", " ftiClient", " ftpConnection", " ftpServer", "ftfpChannel", " ftpiServer", "ftfpServer", "ftfCloud", " ftpiClient", "ctcpClient", "ftbServer", " ftapiClient", "ftlCenter", " ftpHelper", "fttpClient", "ftbClient", "ftpcClient", "fttpChannel", "ftcpChannel", "fttStream", " fticlient", "ftiGuest", "ftbCan", " ftpoClient", "ftpGuest", "ftcClient", " ftpHost", "ftpcClass", "fttpServer", "ftpChannel", " ftpCommunity", " ftapiCloud", "ctcpResource", " ftpCenter", "ftpcCenter", "ftcpClient", " ftapiServer", "ftmChannel", "ftpsClient", "fttClient", "ftpCloud", "ftapiHelper", " ftpClass", "ftcpclient", "ftcpCenter", "ftpclient", "ftcpConnection", "ftcpCommunity", "aftpStream", "ftpcControl", "ctpResource", "ftiServer"], "ftpHolder": ["ftpWorkolder", "ftpcWolder", "fttpChard", "ftphander", "fttpChander", "ftpShard", "ftpShook", "ftpWold", "fttpHook", "ftpcHolder", "ftpHholder", "ftpCholder", "ftphook", "ftpcWather", "ftpWholder", "ftpHook", "ftpcHold", "ftphholder", "ftpHard", "ftphard", "ftpSholder", "ftpWorkather", "ftpHather", "ftpWorkold", "ftpWolder", "ftpChander", "ftpcHholder", "ftpWorkholder", "ftpholder", "fttpCholder", "ftpWather", "ftphold", "ftpcWholder", "ftphather", "ftpChook", "ftpHander", "ftpcHather", "ftpHold", "fttpHander", "fttpHard", "ftpcWold", "fttpHolder", "fttpChook", "ftpChard", "ftpShander"], "iter": ["entry", "or", "ip", "ter", "over", "ir", "inter", "http", "ator", "former", "inner", "limit", "walker", "outer", "ner", "collect", "list", "enter", "in", "skip", "Iterator", "er", "iterator", "cher", "it", "loc", "err", "izer", "ener", "init", "chain", "coll", "ipper", "its", "oper", "index", "f", "ite", "e", "itter", "size", "i", "set", "result", "next", "finder", "ser", "reader", "Iter", "gener", "id", "info", "inc", "ver", "iv", "keep", "file", "end"], "element": ["resource", "container", "environment", "match", "email", "letter", "cell", "definition", "next", "parent", "text", "item", "entry", "or", "expression", "comment", "empty", "this", "atom", "header", "connection", "variable", "per", "air", "value", "editor", "page", "member", "output", "data", "module", "optional", "folder", "attribute", "section", "owner", "entity", "instance", "ee", "node", "content", "er", "part", "document", "coll", "component", "ele", "Element", "reader", "type", "activity", "action", "token", "line", "option", "inner", "service", "input", "layer", "key", "number", "object", "child", "event", "server", "article", "e", "el", "result", "style", "plugin", "et"]}}
{"id1": "18613870", "id2": "19096138", "code1": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "src": ["http", "dist", "input", "conv", "inst", "ctx", "sc", "slice", "this", "dest", "ins", "files", "download", "conn", "loc", "l", "gb", "s", "rc", "ls", "upload", "server", "url", "config", "sb", "gd", "filename", "image", "sin", "inf", "img", "ources", "b", "sit", "source", "stream", "sel", "rb", "sq"], "dst": ["dbst", "rdest", "ddest", "dbdest", "adst", "adrc", "sdrc", "dbST", "rddest", "dbsts", " dsts", "drc", "rdst", "dest", "sdest", "sdst", "sddest", "rdrc", "dST", "Dst", " dST", "dsts", "Ddest", "adest", "addest", " ddest", "Dsts", "DST"], "in": ["In", "pull", "pc", "again", "n", "ini", "IN", "cin", "is", "din", "inner", "bin", "input", "as", "con", "io", "pin", "sync", "ins", "min", "conn", "inn", "kin", "up", "connection", "init", "win", "rin", "part", "url", "gin", "f", "inside", "i", "nin", "image", "start", "socket", "login", "file", "reader", "r", "null", "inc", "id", "source"], "out": ["temp", "not", "again", "outside", "at", "n", "c", "channel", "o", "exp", "ex", "call", "bin", "Out", "copy", "outer", "io", "outs", "this", "bit", "sync", "conn", "user", "err", "up", "connection", "net", "init", "exec", "server", "x", "gin", "other", "off", "i", "image", "writer", "plain", "img", "output", "write", "obj", "OUT", "null", "b", "inc", "parent", "client", "file", "extra"]}}
{"id1": "10131427", "id2": "16590954", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "copyChannel", "CopyFiles", "copyfile", "transferFiles", "copyFiles", "CopyChannel", " copyChannel", "CopyFile", "transferChannel", "transferfile"], "in": ["resource", "In", "or", "again", "at", "ini", "c", "IN", "m", "ex", "inner", "bin", "input", "copy", "io", "ins", "ac", "min", "inn", "base", "url", "work", "config", "index", "i", "image", "a", "login", "reader", "diff", "data", "b", "inc", "id", "source", "buffer", "name", "file"], "out": ["temp", "external", "at", "n", "c", "string", "cache", "o", "ex", "Out", "copy", "io", "outs", "dest", "conn", "object", "p", "part", "w", "base", "connection", "prefix", "exec", "x", "off", "image", "writer", "v", "output", "data", "OUT", "point", "target", "source", "buffer", "client", "name", "file"], "sourceChannel": [" sourceSocket", "srcChan", "SourceStream", "srcConnection", "Sourcechannel", "ourceChan", "targetChan", "srcSocket", "SourceManager", " sourcechannel", "ourceStream", "ourcechannel", "srcQueue", " sourceQueue", "sourceConnection", " sourceConnection", "SourceChan", "srcStream", "srcManager", " sourceChan", "sourcechannel", "SourceChannel", "SourceConnection", "sourceSocket", "SourceSocket", "sourceQueue", "sourceManager", "ourceChannel", "targetchannel", "SourceQueue", "sourceStream", "targetChannel", "srcChannel", " sourceStream", " sourceManager", "sourceChan", "targetStream"], "destinationChannel": ["destinatedChan", "DestinatorConnection", "destationChan", "DestinatorCh", "destinatorchannel", "destinationsStream", "destinatorStream", "Destinatorchannel", "DestinationConnection", "DestinationChannel", "destinationchannel", "DestinationCh", "destinationCh", "destinateChannel", "DestinationStream", "destinationsConnection", "destinatedCh", "destinationStream", "destinateConnection", "DestinationChan", "destinationChan", "destinatorChan", "Destinationchannel", "destinationsChannel", "destinatorChannel", "DestinatorChannel", "destationCh", "destationchannel", "destinatedConnection", "destinateStream", "destationConnection", "DestinatorStream", "destinationschannel", "destinatorCh", "destinatedChannel", "destationChannel", "destinatorConnection", "destinatechannel", "destinationConnection", "DestinatorChan"]}}
{"id1": "12106167", "id2": "18164929", "code1": "    public static void init(Locale lng) {\n        try {\n            Locale toLoad = lng != null ? lng : DEFAULT_LOCALE;\n            URL url = ClassLoader.getSystemResource(\"locales/\" + toLoad.getISO3Language() + \".properties\");\n            if (url == null) {\n                url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n            }\n            PROPS.clear();\n            PROPS.load(url.openStream());\n        } catch (IOException ioe) {\n            try {\n                URL url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n                PROPS.clear();\n                PROPS.load(url.openStream());\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.exit(99);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(99);\n        }\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"init": ["ize", "Init", "register", "initial", "loading", "process", "construct", "boot", "strap", "build", "it", "create", "up", "setup", "install", "get", "load", "config", "loader", "start", "check", "reset", "parse", "pack", "info", "launch", "file"], "lng": ["slgn", "sleng", "Lnd", "slang", "leng", " lnd", "lcang", "slong", "lang", "lcong", " lgn", "Lng", "lnd", "Leng", " leng", "lcng", "Lang", "lgn", "lcnd", " lang", "Lgn", "slng"], "toLoad": ["toload", "poAdd", "ToLoader", " toAdd", "poLoader", " toSave", "TOLoader", "ToLoad", "TOLoad", "TOload", "toLoader", "TOSave", "Toload", "toAdd", " toload", "toSave", "TOAdd", "poSave", "poLoad", " toLoader", "ToAdd"], "url": ["resource", "or", "pull", "entry", "class", "stream", "ob", "zip", "string", "blog", "host", "http", "xml", "service", "www", "ource", "URL", "log", "path", "ll", "ur", "layer", "feed", "gl", "Url", "rl", "impl", "object", "user", "address", "orb", "bel", "loc", "lr", "err", "browser", "l", "base", "element", "event", "server", "location", "coll", "loader", "sl", "f", "ul", "el", "image", "page", "ssl", "bb", "fl", "obj", "null", "job", "id", "web", "uri", "source", "buffer", "parent", "org", "name", "file", "ref"]}}
{"id1": "10451698", "id2": "15768167", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["run", "cop", "paste", "share", "cat", "zip", "rm", "py", "Copy", "move", "process", "ignore", "list", "sync", "download", "archive", "part", "replace", "drop", "cp", "clone", "delete", "get", "load", " cp", "dump", "split", "transfer", "file", "remote", "change", "clip", "write", "type", "parent", "update", "lock", "ssh", "create"], "source": ["folder", "resource", "slave", "root", "plus", "class", "use", "section", "seed", "project", "string", "current", "site", "cache", "Source", "sf", "view", "proxy", "service", "scope", "ource", "path", "from", "slice", "client", "ce", "object", "archive", "unit", "ie", "connection", "document", "storage", "model", "server", "url", "config", "flat", "iter", "filename", "SOURCE", "start", "image", "remote", "result", "directory", "reader", "data", "secure", "target", "null", "parent", "stream", "info", "src", "name", "file"], "destinationDirectory": ["destinationsFolder", "destructionFolder", "destinatorDirectory", "destributionFile", "DestinationDir", "destributionDirectory", "destinatorPath", "destinationHome", "destinationPoint", " destinationDir", "destippingDir", "destinatorPoint", " destinationsDir", "destributionHome", "destructionDir", "destificationDirectory", "destributionFolder", "destributionDir", " destinationsFile", "DestinationDirectory", "destarationPoint", "destinationsDirectory", "DestinationFolder", "destinationPath", " destinationsFolder", "DestributionHome", "destributionPath", "destinationFile", "destarationPath", "destinationsDir", "destarationDirectory", "destructionDirectory", "destributionPoint", "destinationsFile", "destificationDir", "DestinationPath", "DestinationHome", " destinationsDirectory", "DestributionPoint", "destippingFolder", "DestinationPoint", " destinationFolder", "DestributionPath", "destificationFolder", "DestributionDirectory", "destippingDirectory", "destificationHome", "destippingHome", "destinationFolder", "destinationDir", " destinationFile", "DestributionFolder", "destructionFile", "DestributionDir"], "newDir": ["NewFolder", " newFolder", "NewFile", "Newdir", "nextDirectory", "nextFile", "newdir", "newFolder", "NewDirectory", "nextFolder", " newdir", "newDirectory", "nextDir", "nextdir", "NewDir", " newDirectory"], "children": ["names", "pages", "packages", "each", "words", "father", "current", "parents", "opens", "values", "list", "ools", "files", " Children", "ins", "events", "ums", "members", "content", "child", "begin", "loc", "tests", "roots", "when", "url", "ren", "projects", "scenes", "balls", "kids", "other", "blocks", "ul", "iblings", "filename", "uc", "Children", "rules", "data", "items", "mount", "sub", "parent", "web", "iv", "pes", "collection", "which", "sort", "rows"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "n", "ii", "k", "m", "pi", "ini", "o", "y", "d", "inner", "ci", "di", "io", "key", "slice", "ji", "ui", "in", "ri", "ie", "p", "it", "part", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "ori", "q", "start", "h", "gi", "v", "ti", "type", "ai", "mi", "b", "xi", "id", "info", "uri", "iv", "ix", "mu", "lc", "end"], "newFile": ["Newfile", "oldDir", "createFile", "nextSource", "newSource", "oldFiles", "NewFile", " newSourceFile", "nextfile", "newFiles", "createSource", " newfile", "NewFiles", "nextFile", "nextSourceFile", "nextFiles", "NewDirectory", "NewSourceFile", "newDirectory", "newfile", "nextDir", "oldFile", "createDir", "newSourceFile", "NewSource", "NewDir", "createfile", "oldDirectory", " newFiles", " newDirectory"], "output": ["resource", "temp", "application", "external", "again", "current", "ilo", "o", "option", "service", "response", "core", "outer", "after", "display", "operation", "object", "address", "unit", "generation", "connection", "out", "config", "complete", "oper", "other", "control", "image", "socket", "writer", "result", "page", "four", "error", "ou", "write", "kernel", "change", "target", "put", "web", "parent", "generated", "binary", "update", "console", "file", "Output", "flow"], "input": ["resource", "temp", "pull", "plus", "operator", "instance", "current", "context", "request", "http", "inner", "self", "feed", "text", "this", "in", "child", "ack", "print", "audio", "connection", "out", "storage", "exec", "work", "config", "index", "Input", "before", "ink", "image", "socket", "inf", "reader", "data", "error", "raw", "inc", "parent", "stream", "client", "buffer", "form", "keep", "flow"], "buff": ["bound", "txt", "fe", "ob", "cast", "comment", "bin", "uff", "shape", "feed", "char", "buf", "slice", "cod", "pad", "cf", "length", "boot", "count", "bug", "batch", "comb", "ph", "ff", "oct", "gb", "hello", "cp", "cmd", "cur", "load", "f", "gz", "uf", "bind", "cb", "bb", "data", "Buff", "b", "fb", "flush", "pack", "info", "buffer", "back", "text", "rb"], "read": ["reads", "ask", "run", "pass", "use", "ip", "send", "n", "and", " write", "readable", "k", "reading", "fill", "select", "READ", "lex", "io", "open", "feed", "add", "slice", "sync", "skip", "length", " count", "count", "seek", "play", "Read", " load", "rate", "exec", "find", "get", "load", "x", "config", "wait", "size", "f", "iter", "index", "len", "allow", "ink", "ind", "ok", "check", "start", "close", "transfer", "next", "reader", "se", "type", "write", "parse", "b", "en", "id", "loop", "buffer", "text", "end"]}}
{"id1": "2668853", "id2": "17792212", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeStringToFiles", "decodeFileAsFiles", "decodeFileAsfile", "decodeFiletoFiles", "decodeStringToFile", "decodeFileAsStream", "decodeString2Stream", "decodeFile2file", "decodeString2file", "decodeFile2File", "decodeFileTofile", "decodeStringToStream", "decodeStringTofile", "decodeFiletoFile", "decodeFile2Files", "decodeFileToStream", "decodeFileToFiles", "decodeFileAsFile", "decodeString2File", "decodeFiletofile", "decodeFiletoStream", "decodeString2Files", "decodeFile2Stream"], "infile": ["inputfilename", "infp", "inputFile", "outfiles", "minfp", " infiles", "inputfp", "minFile", "inputfiles", "minfile", "outfilename", "minfilename", "outfp", " infilename", "inFile", "inputfile", " inFile", "outFile", "infiles", "infilename"], "outfile": ["OutFile", "outfolder", "infp", "outputfull", "outputFile", " outFile", "outfilename", "outfp", " outfilename", " outfolder", "Outfile", "outputfp", "Outfull", "Outfolder", "infolder", "outputfolder", " outfull", "outFile", "outfull", "outputfile", "outputfilename", " outfp", "infilename"], "in": ["In", "inas", "again", "ini", "IN", "m", "cin", "ex", "is", "din", "inner", "bin", "input", "ic", "as", "con", "this", "pin", "ins", "ac", "min", "conn", "inn", "err", "up", "init", "win", "s", "rin", "lin", "gin", "f", "e", "inside", "i", "nin", "a", "image", "socket", "login", "reader", "data", "r", "b", "inc", "source", "re"], "out": ["In", "pass", "exit", "line", "again", "cache", "op", "o", "ex", "exp", "inner", "bin", "Out", "copy", "as", "outer", "io", "outs", "co", "post", "sync", "on", "conn", "no", "err", "up", "net", "base", "s", "exec", "work", "other", "session", "off", "home", "image", "lib", "socket", "to", "writer", "ext", "output", "error", "write", "obj", "OUT", "target", "b", "point", "inc", "lock", "client", "name", "file"], "buffer": ["resource", "row", "seed", "uffer", "limit", "bin", "pause", "input", "layer", "shape", "wave", "feed", "buf", "queue", "slice", "pad", "length", "address", "batch", "base", "server", "url", "size", "Buffer", "iter", "value", "split", "bytes", "transfer", "border", "memory", "bb", "reader", "reference", "data", "result", "null", "b", "buff", "flush", "offset", "binary", "source", "padding"], "read": [" reach", " Read", "use", "current", " sleep", "count", " r", "start", "check", "next", " send", "write", "sleep", " request", "select", "lex", "feed", "add", "length", " receive", " use", " parse", "play", " load", "find", "x", "wait", "iter", "allow", " check", "connect", "end", "reads", "tell", "send", " find", "copy", "open", "sync", "skip", "seek", "ad", "get", "load", "work", "size", "index", "reader", " copy", "parse", "r", "id", "pass", "run", "line", " reader", "k", " write", "reading", "fill", "limit", "input", "READ", "Read", "exec", " get", " ride", " connect", "ind", "ride", "se", "inc"], "success": ["rolled", "correct", "done", "pass", "status", "accept", "again", "full", "zero", "initial", "results", "failed", "winner", "safe", " Success", "continue", "response", "func", "fast", "Success", "ceed", "first", "warning", "ccess", "content", "construct", "roll", "good", "valid", "successful", "default", " successful", "fail", "danger", "selected", " succeed", "complete", " succ", "value", "ok", "rolling", "result", "better", "true", "error", "data", "follow", "found", "null", "yes", "successfully", "job", "cess"]}}
{"id1": "10385815", "id2": "21232043", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    public File call() throws IOException {\n        HttpURLConnection conn = null;\n        ReadableByteChannel fileDownloading = null;\n        FileChannel fileWriting = null;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            if (size == -1) {\n                size = conn.getContentLength();\n            }\n            fileDownloading = Channels.newChannel(conn.getInputStream());\n            fileWriting = new FileOutputStream(file).getChannel();\n            long left = size;\n            long chunkSize = BLOCK_SIZE;\n            for (long downloaded = 0; downloaded < size; left = size - downloaded) {\n                if (left < BLOCK_SIZE) {\n                    chunkSize = left;\n                }\n                fileWriting.transferFrom(fileDownloading, downloaded, chunkSize);\n                downloaded += chunkSize;\n                setProgress(downloaded);\n            }\n        } finally {\n            if (file != null) {\n                file.deleteOnExit();\n            }\n            if (conn != null) {\n                conn.disconnect();\n            }\n            if (fileDownloading != null) {\n                try {\n                    fileDownloading.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0441\u043a\u0430\u0447\u0438\u0432\u0430\u043d\u0438\u044f\", ioe);\n                }\n            }\n            if (fileWriting != null) {\n                try {\n                    fileWriting.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 \u0444\u0430\u0439\u043b\", ioe);\n                }\n            }\n        }\n        return file;\n    }\n", "label": 0, "substitutes": {"copy": ["Cop", "paste", "cmp", "send", "zip", "Copy", "move", "open", "Transfer", "process", "sync", "download", " Copy", "replace", "upload", "exec", "clone", "delete", "get", "split", "transfer", "file", "change", "write", "put", "update", "create"], "fileFrom": [" fileStart", "FileSource", "FileStart", "fileStart", "mailIn", "ioSource", "FileTo", "FileIn", "ioStart", "mailTo", " fileSource", "mailFrom", " fileAs", "FileFrom", "ioFrom", "fileSource", "FileAs", "mailAs", "fileAs", "ioTo", " fileIn", "fileIn"], "fileTo": ["fpto", "resourceFile", "resourceTarget", "fileTO", " fileFile", "FileTo", " fileto", "resourceFrom", "resourceTo", "fpFrom", " fileTO", "fpTO", "fileto", "fileTarget", " fileTarget", "Fileto", "FileFrom", "fpTo", "FileTarget", "fileFile", "FileFile", "FileTO"], "inputStream": ["inputContext", "outputSteam", " inputSteam", "inputFile", "InputChannel", " inputFile", "outputFile", "inputSync", "outputContext", "inputstream", "InputContext", " inputstream", "InputSteam", "InputFile", " inputContext", "Inputstream", "outputSync", " inputSync", "InputSync", "InputStream", "outputstream", "inputSteam"], "outputStream": ["referenceStream", "outputSteam", "OutputStream", "fourStream", "fourChannel", " outputChan", "outputStreamer", "referenceSocket", "outputSocket", " outputSteam", "fourStreamer", "inputSocket", "writeSocket", "fourSteam", "writeChannel", "OutputChan", "referenceSteam", "OutputStreamer", "outputPath", "OutputSteam", "outputChan", "inputPath", " outputStreamer", " outputPath", "OutputPath", "writeSteam", "inputChan", "writeStream", "OutputChannel", "referenceChannel", "inputSteam"], "inputChannel": ["inputContext", "audioClient", "butContext", "parentPassword", "InputChannel", " inputClient", "outputSocket", "butCommand", "outputContext", " inputPassword", "inputSocket", "inputCam", "butChan", " inputCam", "InputContext", "parentStream", "outputPassword", "audioChannel", " inputSocket", " inputChan", "outputChan", " inputCommand", "inputClient", " inputContext", "outputCam", "inputCommand", "parentChannel", "InputSocket", "butChannel", "InputChan", "inputPassword", "inputChan", "outputCommand", "outputClient", "audioStream", "audioCam", "parentChan", "InputStream"], "outputChannel": ["inputContext", "outputchannel", "OutputStream", "outChannel", "OutputContext", " outputQueue", " outputChan", "outputContext", " outputContext", "OutputChan", " outputchannel", "outputChan", "OutputQueue", "outStream", "outChan", "outputQueue", "inputChan", "OutputChannel", "inputQueue", "inputchannel", "outContext", "Outputchannel"]}}
{"id1": "23273706", "id2": "5148212", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectDocumentMeta", "getProjectTreeInfo", "getProjecttreeData", "getprojecttreeInfo", "getprojecttreeDATA", "getProjectPageData", "getprojectTreeData", "getProjecttreeDATA", "getProjectTreeDATA", "getProjecttreeInfo", "getProjecttreeMeta", "getprojectTreeDATA", "getProjectPageInfo", "getprojectTreeMeta", "getprojecttreeData", "getprojecttreeMeta", "getProjectTreeMeta", "getProjectDocumentData", "getprojectTreeInfo", "getProjectPageMeta", "getProjectDocumentInfo", "getProjectPageDATA", "getProjectDocumentDATA"], "treeData": ["treeDec", "reeArray", "bodyDat", "TreeInfo", " treeText", "treeString", "reeString", "storyData", "monkeyArray", "bodyList", "storyDec", "reeData", "contentDat", "treeText", "TreeArray", " treeDec", "treeList", "contentInfo", "storyArray", "TreeData", " treeArray", "bodyData", " treeString", "reeText", "bodyString", "treeInfo", " treeList", "reeInfo", " treeInfo", "reeDat", "contentText", " treeDat", "monkeyDat", "TreeString", "treeDat", "storyDat", "monkeyDec", "monkeyData", "treeArray", "TreeList", "reeList", "contentData"], "filename": ["folder", "txt", "username", "SourceFile", "string", "jpg", "kj", "xml", "title", "Filename", "path", "kn", "fd", "fil", "sheet", "whatever", "files", "database", "ppa", "framework", "fn", "prefix", "tmp", "upload", "url", "location", "dylib", "FILE", "dll", "password", "journal", "figure", "fp", "ername", "directory", "nil", "data", "wav", "metadata", "kl", "uri", "name", "file"], "urlString": ["URLstring", "addressStr", "URLUrl", "locationUrl", "locationString", "urlStr", "addressURL", "addressString", " urlURL", "locationStr", "URLStr", "addressstring", "URLString", " urlstring", "URLURL", "urlUrl", " urlStr", "locationstring", " urlUrl", "urlstring", "urlURL"], "urldata": ["urlddata", "URldata", "URlfdata", " urLDATA", "URldATA", "urLDdata", "urlfdata", "urlledta", "urlledata", "urldATA", "urledata", "urlfat", "urLDta", "urleddata", "urLDat", "urlleddata", "urlfATA", "urlldata", "urledATA", "urlfata", " urLDta", " urlddata", "URlfat", "urLDATA", "URldat", "urLData", " urldta", "urldat", "URlddata", " urldATA", "urllATA", " urLData", "urlledATA", "URlfata", " urLDdata", "urllat", "URlfATA", "urldta", "urledta", "urllata"], "factory": [" flier", "ufictionary", "confFactory", "cFactory", "fault", "cfFactory", "fFactory", " filler", "cfiller", "liller", "lactory", "ufiller", "confiller", "filler", "cflier", "luild", "pault", " fault", "cactory", "flier", "pFactory", "fictionary", "ufactory", "lictionary", " fuild", "cfactory", " fictionary", " fFactory", "ufuild", "cault", "ciller", "pactory", "conflier", "fuild", "confactory", "piller"], "parser": ["root", "ger", "pdf", "library", "string", "instance", "jack", "xml", "http", "utils", "raf", "manager", "api", "util", "monkey", "driver", "json", "er", "handler", "p", "up", "l", "ph", "s", "Parser", "loader", "fruit", "lp", "auto", "arser", "writer", "reader", "se", "parse", "r", "b", "plugin", "t", "parent", "uri", "builder"], "u": ["iu", "eu", " ur", "us", "uu", "c", "ru", "o", "http", "universal", "d", "U", "ur", "io", "util", "yu", "ui", "uv", "cu", "p", "l", "s", "plug", "url", "su", "uf", "ul", "hu", "ou", "tu", "b", "uri", "nu", "uni", "lu"], "is": ["ib", "or", "us", "isa", "ip", "ios", "serv", "ob", "isl", "pi", "ir", "http", "iris", "has", "as", "gets", "io", "api", "ais", "IS", "abs", "ui", "in", "ri", "are", "ie", "p", "fs", "it", "obs", "init", "s", "Is", "iso", "iss", "ar", "ops", "its", "ori", "mis", "bis", "lis", "isu", "ai", "es", "info", "uri", "ris"], "os": ["or", "us", "ms", "ol", "ios", "so", "bs", "ens", "ob", "osi", "o", "dos", "opens", "http", "oa", "fits", "oss", "as", "gets", "io", "sys", "aos", "bos", "oes", "oos", "fs", "ose", "obs", "s", "pos", "los", "iso", "ops", "cos", "Os", "oses", "ros", "bis", "ils", "ps", "es", "OS"], "iBufSize": ["iBytebufSize", "iLlfSt", "iLlfsize", "iBytebufsize", "iBytebufLength", "iBlfLen", "iBlfLength", "iByteufSize", "iBufferLength", "iBytebufLen", "iBufferSt", "iLlfLength", "iBufLen", "iByteufLen", "iLufSize", "iByteufLength", "iBufsize", "iBbufSize", "iBlfSt", "iLlfSize", "iBbufLen", "iBuffLength", "iBlfSize", "iBuffSt", "iBuffsize", "iBufSt", "iBufferSize", "iBuffersize", "iBbufLength", "iByteufsize", "iBlfsize", "iBufLength", "iLufsize", "iLufSt", "iBbufsize", "iLufLength", "iBuffLen", "iBuffSize"], "inBuf": ["outBuffbuf", "inBbuf", "inCuff", "outBuffub", "outBub", "outBuffuf", "inBlump", "inFbuf", "inBuffump", "inBunk", "inFaf", "inDbuf", "inBuff", "inCbuf", "inbuf", "inCunk", "inPlunk", " inBump", "inCump", "inDuf", "inBump", " inCbuf", "inFuff", " inBunk", " inFaf", "inPlbuf", "inBluf", " inFuff", "outBump", " inBaf", " inBbuf", "inBlbuf", "inBuffuf", "inbub", "inPluf", "inCuf", "inFuf", "inDuff", "inBub", "inBuffbuf", "inPlump", " inCunk", "inbump", "inBlub", "outBuffump", "inDaf", " inCuf", " inBuff", "outBuf", "inCaf", "inBlunk", " inFbuf", "inBuffub", "outBbuf", "inBaf", "inbbuf", " inCump", " inFuf"], "iNumRead": ["iValBuild", "iChanBuild", "pNumWritten", "iChanRead", "pNumread", "qiNumBuild", "qiValBuild", "iFatWritten", "iNumberBuild", "qiNumRead", "inumWritten", "inumRead", "qiNumREAD", "pNumberRead", "pNumberWritten", "iNumberREAD", " iFatWrite", "pNumWrite", "iNumberWrite", "iLenWritten", "iNumread", "qiValread", "inumread", "iLenRead", "iChanread", "iNumberWritten", "iFatRead", " iFatWritten", "inumWrite", "iNumWritten", "pNumberread", "iNumberRead", "iValread", " iNumWrite", "iChanREAD", "qiNumread", "iNumBuild", "pNumRead", "iLenWrite", "iNumWrite", "qiValREAD", "pNumberWrite", " iFatRead", "iValRead", "iNumREAD", "qiValRead", " iNumWritten", "iFatWrite", "iValREAD", "iNumberread"], "f": ["fa", "df", "fe", "fr", "F", "fc", "full", "g", "c", "n", "m", "o", "sf", "d", "fd", "io", "feed", "fn", "handler", "p", "fs", "l", "ff", "s", "j", "fi", "e", "uf", "h", "fp", "v", "r", "b", "t", "file", "rf"], "inputstream": ["outputchannel", "inputsystem", "inputsw", " inputStream", "inputStream", "contentsw", "outputStream", "Inputsystem", "Inputchannel", "contentstream", "Inputstream", " inputchannel", "contentStream", " inputsw", "InputStream", "contentsystem", "outputstream", " inputsystem", "Inputsw", "inputchannel"], "document": ["window", "media", "container", "project", "n", "m", "context", "xml", "d", "language", "node", "response", "list", "tree", "doc", "Document", "content", " documents", "object", "p", "l", "Documents", " documentation", "office", "e", "director", "dom", "record", "page", "html", "output", "DOM", "data", "directory", "docs", "ocument", "null", "t", "info", "source", "parent", "collection", "file"], "nodelist": ["Nodemark", "NODestyle", "nonedette", " nodeselist", "nodeestate", "Nodestyle", "nonedename", " nodesename", "nozelist", "snodselist", "anodedelist", "anodedestate", "anodedeme", "nODeline", "nozels", "anodata", "nozemark", "nodesh", "nODestyle", "nodeeme", "nodeata", " nodename", "anodeme", "nODesh", "nodedestyle", "nodename", "nodeelist", "nondeme", "nodesels", "snodeline", "anodedata", "nodeline", "nondelist", "Nodesh", "nodeme", "nondestate", "nodedata", "Nodelist", "nodata", " nodesels", "nonedels", "nodedlist", "snodelist", " nodels", "nodedeline", "NODelist", "nodlist", "nodsette", "nonedelist", "nozestyle", "nozename", "nodestate", "nODemark", "nozette", "nodselist", "nODette", "nODlist", "nodeselist", "anodestate", "snodette", "nODelist", "NODemark", "nodedeme", " nodette", "nodels", "nodestyle", "snodsette", "snodlist", "anodelist", "nodette", "nodseline", "nondata", "nozesh", "nodedelist", "nodesename", " nodesette", "snodslist", "snodseline", "nodedesh", "nodedette", "nodedemark", "nodedestate", "NODesh", "nodemark", "nodslist", "nodesette"], "num": ["span", "temp", "nb", "multi", "n", "zero", "m", "col", "um", "total", "mult", "node", "sum", "con", "np", "norm", "number", "NUM", "div", "umi", "nr", "mu", "count", "unit", "Num", "loc", "om", "comb", "part", "net", "init", "pos", "max", "index", "len", "ul", "nom", "lim", "dom", "tri", "mon", "en", "nam", "inc", "nu", "uri", "dim", "uni"], "i": ["iu", "hi", "si", "qi", "chi", "ip", "multi", "g", "ii", "ini", "c", "pi", "col", "o", "y", "m", "d", "ci", "di", "io", "slice", "ji", "ui", "in", "ri", "bi", "ie", "p", "it", "l", "part", "phi", "j", "I", "eni", "fi", "x", "index", "cli", "isi", "oi", "li", "ori", "a", "start", "v", "gi", "ti", "mi", "ai", "yi", "b", "xi", "id", "info", "uri", "iv", "ix", "mu", "ik"]}}
{"id1": "4056444", "id2": "11005804", "code1": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"hashPassword": ["updatePassword", "printWord", " hashSecret", "printSecret", " hashpassword", "updateWord", "printPassword", "printpassword", "hashWord", "hashpassword", " hashWord", "hashSecret", "updatepassword", "updateSecret"], "password": ["pass", "attribute", "SHA", "words", "username", "token", "sword", "string", "cache", "word", "secret", "sha", "input", "Password", "PASS", "path", "param", " passwords", "auth", "database", "email", "wd", "user", "random", "address", "p", " Password", "out", "prefix", "phrase", "security", "confirmed", "pool", "code", "login", "data", "null", "account", "message", "crypt", "text", "name", "create", "padding"], "md": ["mb", "mg", "mp", "pd", "pm", "od", "mand", "rm", "mac", "m", "sm", " MD", "d", "sha", "hm", "sum", "di", "MD", "bd", "wd", "hd", "ad", "dd", "mc", "mod", "cmd", "dh", "mag", "ma", "f", "nd", "am", "dm", "rod", "amd", "dig", "mm", "metadata", "bf", "mad", "mt", "grad", "mo"], "hash": ["pass", "SHA", "hed", "username", "shadow", "sh", "full", "mac", "cache", "string", "Hash", "rh", "secret", "sha", "sum", "log", "search", "match", "hex", "key", "number", "length", "user", "address", "header", "kh", "build", "ha", "ho", " hashing", "url", "ash", "array", "block", "dump", "code", "value", "her", "image", "h", "check", "dot", "html", "format", "data", "dig", "style", "id", "body", "version", "db", "file"]}}
{"id1": "937612", "id2": "5682569", "code1": "    public String new2Password(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            String clearPassword = passwd;\n            md.update(clearPassword.getBytes());\n            byte[] digestedPassword = md.digest();\n            return new String(digestedPassword);\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"MD5 doesn't exist\");\n            System.out.println(e.toString());\n            return null;\n        }\n    }\n", "code2": "    public void metodo1() {\n        int temp;\n        boolean flagDesordenado = true;\n        while (flagDesordenado) {\n            flagDesordenado = false;\n            for (int i = 0; i < this.tamanoTabla - 1; i++) {\n                if (tabla[i] > tabla[i + 1]) {\n                    flagDesordenado = true;\n                    temp = tabla[i];\n                    tabla[i] = tabla[i + 1];\n                    tabla[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"new2Password": ["hashBaseWD", "hash3Word", "hash3WD", "hash4WD", " gen2Password", "hash3Secret", "hashBasePassword", " gen2WD", "hash2WD", " gen2Word", " gen3Word", "hashBaseSecret", "hash4Secret", "hash2Word", "hash3Password", "hash2Password", " gen2Secret", " gen3Password", " gen3WD", " gen3Secret", "hash2Secret", "hash4Password", "hash4Word", "hashBaseWord"], "passwd": ["assword", " passpass", "Passpassword", "PassWD", "passpass", "Passpass", "asspassword", "Password", "asspass", "Passwd", " passWD", "passpassword", " password", "password", "asswd", "assWD", " passpassword", "passWD"], "md": ["df", "mb", "mg", "mp", "pd", "ms", "pm", "od", "mand", "mac", "m", "sm", " MD", "d", "sha", "di", "MD", "bd", "meta", "wd", "hd", "ad", "dd", "ld", "mc", "cmd", "dh", "ma", "mag", "f", "am", "password", "ind", "hash", "dm", "editor", "nm", "amd", "dig", "mm", "metadata", "vd", "po", "mt", "grad", "mo"], "clearPassword": ["plainString", "clearpassword", " clearPass", "hashWord", "clearword", "clearString", "hashPassword", "passWord", "passPassword", "clearPass", " clearword", "passMessage", " clearMessage", " clearString", "passpassword", "passPass", "plainPass", "plainPassword", "passString", "password", " clearWord", "clearMessage", "plainpassword", "clearWord", " clearpassword", "hashMessage", "hashword"], "digestedPassword": ["Digestedpassword", " digestPass", "Digestpassword", "digestedPad", "digestPad", " digestedPass", "DigestedPad", "digustedPat", "digestingPass", "digustedPass", " digestPassword", "DigestPass", "digustedPassword", "DigestedPass", "digestedPass", "digestingPad", " digestPat", "digashedPassword", "digestedPat", "digestedpassword", "digestpassword", "diguredpassword", "digestPass", "diguredPass", "digestPassword", "DigestPad", "digestPat", "DigestedPassword", "digestingpassword", "diguredPassword", "digestingPassword", "diguredPad", "DigestPassword", "digashedPat", " digestedPat", "digashedPass"]}}
{"id1": "16673769", "id2": "18696387", "code1": "    @Override\n    public void Start() {\n        try {\n            Enumeration<URL> resources = Configurator.class.getClassLoader().getResources(IOCContainer.GetApplicationName() + \".config\");\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                if (Logger.logger.isDebugEnabled()) {\n                    Logger.logger.debug(\"Loading '\" + url + \"'\");\n                }\n                JSONValue configFileContents = JSONValue.Decode(url.openStream(), url.toString());\n                if (configFileContents instanceof JSONObjectValue) {\n                    for (Configurable configurable : IOCContainer.LookupAll(Configurable.class)) {\n                        JSONValue jsonData = ((JSONObjectValue) configFileContents).GetProperty(configurable.GetConfigSectionName());\n                        if (jsonData != null) {\n                            if (Logger.logger.isDebugEnabled()) {\n                                Logger.logger.debug(\"Configurging \" + configurable.getClass() + \" with '\" + jsonData.Encode());\n                            }\n                            try {\n                                configurable.Configure(jsonData);\n                            } catch (Throwable th1) {\n                                Logger.logger.error(\"Caught throwable while configuring \" + configurable.getClass() + \":\" + th1.getMessage() + \". IGNORED.\", th1);\n                                Logger.logger.error(\"[Continued]. Config Data was:\" + jsonData.Encode());\n                            }\n                        }\n                    }\n                } else {\n                    Logger.logger.error(\"'\" + url + \"' does not contain a json object. Skipping and looking for other applciation.config files in classpath ...\");\n                }\n            }\n        } catch (Throwable th) {\n            throw new RuntimeException(\"Exception while attempting to load application.config:'\" + th.getMessage() + \"'\", th);\n        }\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 0, "substitutes": {"Start": ["ize", "run", "Init", "Run", "register", " Startup", "process", " Run", "Exception", "Main", "init", "Stop", "get", "Do", "Load", " start", " stop", "Starting", "Test", "stop", "Begin", "start", "Service", "Boot", "End", "Process", "create", "end"], "resources": ["reports", "pages", "resource", "packages", "classes", "maps", "lines", "parents", "Resources", "errors", "results", "http", "opens", "ids", "stores", "relations", "objects", "uploads", "styles", "files", "events", "groups", "plugins", "roots", "projects", "settings", "services", "includes", "vers", "stars", "thumbnails", "ions", "fires", "types", "bytes", "features", "rules", "archives", "states", "models", "ources", "users", "issues", "works", "rows"], "url": ["resource", "route", "string", "href", "channel", "host", "http", "xml", "str", "service", "response", "URL", "path", "layer", "ll", "api", "io", "feed", "gl", "text", "key", "Url", "email", "rl", "download", "json", "address", "loc", "lr", "l", "connection", "base", "element", "ls", "server", "location", "coll", "config", "sl", "f", " URL", "ul", "filename", "image", "socket", "html", "ssl", "page", "data", "r", "mount", "uri", "stream", "source", "buffer", "name", "file"], "configFileContents": ["configContentValues", "configfileTextures", "logfileParameters", "configfileValues", "configResourceValues", "configResourceContents", "configResourceIncludes", "jsonFileTextures", "logfileLocation", "configfileIncludes", "jsonfileContent", "configUrlContent", "jsonfileIncludes", "configContentIncludes", "configUrlParameters", "configFILETextures", "logFileParameters", "jsonfileValues", "configfileContents", "configFILEContents", "jsonFileIncludes", "configFileLocation", "configFileContent", "logfileContents", "jsonfileContents", "jsonfileStream", "configFILEStream", "logfileContent", "logFileContent", "configFileTextures", "configfileLocation", "configContentContent", "configUrlContents", "jsonFileContent", "configDirectoryContent", "configContentParameters", "configDirectoryContents", "configDirectoryTextures", "configDirectoryStream", "configfileParameters", "configFileStream", "logFileLocation", "configfileContent", "jsonFileValues", "jsonFileStream", "configUrlLocation", "configContentContents", "jsonFileContents", "configResourceContent", "configFileValues", "configfileStream", "configContentLocation", "configFileIncludes", "configFileParameters", "configFILEContent", "logFileContents", "jsonfileTextures"], "configurable": ["confur", "structurable", "configurer", "figur", "confurable", "Configuration", " configure", "figurer", "Configur", "configuration", "figural", "configur", " configuration", "confuration", "structurer", "Configuring", "confurer", "configural", "Configurable", "figurable", "configure", "structur", "structuring", "structural", " configural", "structuration", "structure", "confure", "configuring", "Configure", " configur", "confural", "confuring", "Configural", "Configurer", " configurer"], "jsonData": ["jsData", "xmlString", "rssParser", " jsonParser", "JSONString", "sonCode", "ajData", "journalDiv", "jsonParser", "JSONReader", "jsonReader", "jsonVar", "JSONValue", " jsonReader", "jsonArray", "ajDat", "sonVar", "jsArray", "sslValue", "sslDat", " jsonCode", "jsonInfo", "JSONData", "JSONDATA", "JSONInfo", "jsonCode", "rssDATA", "JSONDat", "sonData", "xmlCode", "sonDiv", "ajValue", " jsonDiv", "rssData", "jsonString", "ajInfo", "xmlInfo", "JSONCode", " jsonVar", "jsonDat", "sslData", "sonDATA", "jsonDiv", "xmlReader", "xmlData", "sslInfo", " jsonInfo", "jsonDATA", "xmlDATA", "xmlArray", " jsonDATA", "jsString", "jsonValue", "jsDATA", "JSONArray", "sonParser", "journalData", "journalCode", "rssVar"]}}
{"id1": "1122585", "id2": "812803", "code1": "    private String copyImageFile(String urlString, String filePath) {\n        FileOutputStream destination = null;\n        File destination_file = null;\n        String inLine;\n        String dest_name = \"\";\n        byte[] buffer;\n        int bytes_read;\n        int last_offset = 0;\n        int offset = 0;\n        InputStream imageFile = null;\n        try {\n            URL url = new URL(urlString);\n            imageFile = url.openStream();\n            dest_name = url.getFile();\n            offset = 0;\n            last_offset = 0;\n            offset = dest_name.indexOf('/', offset + 1);\n            while (offset > -1) {\n                last_offset = offset + 1;\n                offset = dest_name.indexOf('/', offset + 1);\n            }\n            dest_name = filePath + File.separator + dest_name.substring(last_offset);\n            destination_file = new File(dest_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    if (!destination_file.canWrite()) {\n                        System.out.println(\"FileCopy: destination \" + \"file is unwriteable: \" + dest_name);\n                    }\n                    System.out.println(\"File \" + dest_name + \" already exists. File will be overwritten.\");\n                } else {\n                    System.out.println(\"FileCopy: destination \" + \"is not a file: \" + dest_name);\n                }\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory doesn't exist: \" + dest_name);\n                }\n                if (!parentdir.canWrite()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory is unwriteable: \" + dest_name);\n                }\n            }\n            destination = new FileOutputStream(dest_name);\n            buffer = new byte[1024];\n            while (true) {\n                bytes_read = imageFile.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(\"Bad URL \" + urlString);\n        } catch (IOException ex) {\n            System.out.println(\" IO error: \" + ex.getMessage());\n        } finally {\n            if (imageFile != null) {\n                try {\n                    imageFile.close();\n                } catch (IOException e) {\n                }\n            }\n            if (destination != null) {\n                try {\n                    destination.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return (dest_name);\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"copyImageFile": ["copyPictureFile", "CopyimageStream", "copyPictureFolder", "CopyImageFile", "copyimageFile", "copyPictureStream", "copyimageFiles", "CopyImageFolder", "copyImagesStream", "copyImageStream", "copyImageFiles", "CopyimageFolder", "copyimageStream", "copyPictureFiles", "CopyimageFile", "copyImagesFiles", "copyImagesFile", "copyImageFolder", "CopyImageFiles", "CopyImageStream", "copyimageFolder", "copyImagesFolder", "CopyimageFiles"], "urlString": ["filestring", "URLText", "uriStream", "uriString", "urlStr", "urlText", "urlPath", "URLBytes", "urlBytes", "fileString", " urlPath", "URLString", " urlstring", " urlStream", "resourcePath", " urlBytes", "uriText", " urlStr", "urlStream", "resourceStr", "uriBytes", "urlstring", "resourcestring", "URLStream", "fileStr", " urlText", "resourceString"], "filePath": ["urlName", "fileName", " fileName", "filepath", "urlPath", "fileDir", "imageDir", "resourceDir", " fileUrl", "imageUrl", " filePos", "imagePos", "urlPos", "filePos", "imageName", "imagepath", "resourcePath", "urlUrl", "resourcepath", "fileUrl", " fileDir", "resourceName", "imagePath", " filepath"], "destination": ["externalication", "estinated", " destacement", "scheination", "endribution", "teminator", "destigroup", "Destruction", "destacement", " destinator", "distacement", "temacement", "endinator", "destication", "teminate", " destigroup", "externalinator", " destribution", "destribution", " destension", "signruction", "destinator", "signination", "estination", "originated", " destication", "Destinator", "coordination", "originator", "Destination", "homeinated", "destinated", "scheribution", "Destinated", "homeination", "endinated", "Destigroup", "homeinator", "destinate", "distinate", "Destension", "destruction", "coordribution", "signribution", "scheinated", "externalination", "Destribution", "externalinated", " destinated", " destruction", "scheinator", "signinator", "endination", "distinated", "distribution", "coordinator", "estinator", " destinate", "estension", "distination", "distinator", "origication", "homeigroup", "origination", "coordinated", "temination", "destension"], "destination_file": ["destination_cache", "destinated_auto", "destination__file", "destinate_file", "destination_File", "destinate_files", "destining__cache", "destaration24folder", "destaration_folder", "destinationJstring", "destining__auto", "destining__file", "destining_files", "destinationsfolder", "destaration_force", "destination_string", "destinated_filename", "destination__auto", "destaration_name", "destination2file", "destination_queue", "destination2force", "destination_filename", "destaration_file", "destinated24full", "destaration24force", "destination_name", "destination24folder", "destinationJqueue", "destination24full", "destinated_file", "destination2name", "destinated_full", "destinationsforce", "destining_name", "destination24file", "destination_full", "destination_files", "destinationJfile", "destining_file", "destinationsname", "destination__File", "destinate_function", "destinate_filename", "destination24name", "destining__File", "destinated_string", "destination_force", "destinated24name", "destination2folder", "destination24force", "destination__cache", "destinated24auto", "destination_function", "destining_auto", "destinated24file", "destination_resource", "destination_auto", "destinated_name", "destinated_queue", "destining_cache", "destination24auto", "destaration24name", "destining_resource", "destining_File", "destination_folder", "destaration24file", "destinationsfile", "destinationJfilename"], "inLine": [" uploadedRow", " paramChar", " uploadedObj", " paramRow", "inList", " paramList", "inChar", "sourceList", "inRow", " paramObj", " uploadedChar", "inObj", "sourceObj", "sourceRow", "sourceChar", " uploadedList"], "dest_name": ["destJstring", "destDmain", "dest_main", "destDpath", "destDdescription", "destJmemory", "destPfilename", " dest__filename", "dest_size", " dest_memory", "dest9NAME", " dest_time", "destJfile", "dest_named", "destFilefile", "dest8description", "dest_call", "dest_path", "dest_no", "dest_missing", "destJname", "destJmain", " dest_default", "dest_string", "destLmissing", "destPsource", " dest_missing", "dest_file", " destPname", "dest__name", "destKname", "destLcall", "destKfile", "dest__filename", " dest_description", " dest_string", " dest_path", "destDname", "destLNAME", "dest8name", "dest_NAME", "destPName", "destLName", "dest8Name", "dest_source", "dest_filename", " dest_call", " dest_NAME", "destKNAME", "dest9name", " dest_Name", " dest__Name", "destPfile", " destPfile", " dest_file", " dest_no", "dest__Name", "destJName", " dest__name", "dest_time", "dest__path", "destKpath", "destLname", "destFileName", "destPpath", "dest_default", "dest_description", " dest__path", "destFilename", "dest9call", " dest_named", " dest_size", "dest9Name", "destFilepath", " dest_main", "destPname", "destLdefault", " dest_source", "dest_memory", " destPpath", " dest_filename", "dest8path", "destKsource", " destPsource", "dest_Name"], "buffer": ["resource", "seed", "position", "string", "cache", "table", "request", "uffer", "limit", "padding", "comment", "input", "layer", "texture", "wave", "sequence", "feed", "buf", "slice", "queue", "FFER", "pad", "length", "header", "count", "batch", "document", "variable", "size", "read", "Buffer", "iter", "bar", "len", "value", "split", "writer", "bytes", "border", "transfer", "memory", "result", "reader", "bb", "data", "stack", "buff", "flush", "message", "source", "binary", "block", "info", "reference"], "bytes_read": [" bytes_check", "bytes_available", " bytes_write", "bytes_load", " bytes_available", " bytes_find", " bytes_load", "bytes_find", " bytes_left", "bytes_left", "bytesRleft", " bytes_len", "bytesRload", "bytesRread", "bytes_write", "bytes_len", "bytesRavailable", " bytes_count", " bytes_written", "bytes_written", "bytes_count", "bytes_check"], "last_offset": ["lastlexerror", "next_position", "lastlexindex", "next_length", "prev_left", "next_offset", "lastlexobject", "last___name", "next_off", "lastlexleft", "lastlexname", "last_length", " last_index", "prev_error", "lastacerror", "last_off", "lastacobject", "lastacoffset", "last_url", "last_notation", "next_name", "prev_object", "last_error", "next_index", "last_name", "last_index", "lastlexposition", "last___index", "lastlexoffset", "last_left", "last_position", " last_notation", "last_object", "last___offset", " last_url", "last___position", "prev_offset", "lastacleft"], "offset": ["route", "align", "current", "append", "pointer", "notation", "partial", "absolute", "address", "enabled", "location", "slot", "auto", "start", "error", "alias", "timeout", "entry", "shift", "o", "oa", "phase", "slice", "length", "progress", "loc", "alpha", "connection", "element", "usage", "off", "page", "output", "optional", "starting", "interrupted", "sort", "end", "attribute", "section", "operation", "no", "part", "left", "size", "index", "type", "always", "width", "origin", "action", "position", "initial", "option", "limit", "area", "layer", "api", "number", "Offset", "object", "iterator", "pos", "addr", "article", "info", "et", "padding"], "imageFile": [" imageDir", "picturefile", " imageFiles", "ImageStream", " imageStream", "ImageFiles", "imageDirectory", "pictureDir", "ImageDirectory", "ImageDir", "photoStream", "pictureFiles", "imagefile", "imageDir", "imageUrl", " imageLine", "imageStream", "photoFile", "exampleDirectory", "ImageLine", "imageLine", "exampleUrl", "pictureFile", "Imagefile", "imageFiles", " imageUrl", "exampleFile", " imageDirectory", "photofile", "photoDir", "exampleLine", "ImageFile", " imagefile", "ImageUrl"], "url": ["resource", "pull", "fr", "ob", "string", "channel", "blog", "host", "http", "URL", "path", "api", "open", "feed", "gl", "text", "key", "Url", "download", "client", "user", "address", "loc", "browser", "rel", "l", "connection", "base", "server", "location", "sl", "f", "hub", "ul", "image", "page", "ssl", "bb", "data", "fl", "ball", "web", "uri", "stream", "source", "update", "name", "file"], "parentdir": ["homedir", "parentfolder", " parentparent", " parentdirectory", "parentdict", "rootfile", "rootdir", "masterparent", "partfile", "partdirectory", "masterdir", "homeparent", "parentparent", " parentfile", "homedict", "partfolder", "Parentdir", "rootdirectory", "rootfolder", "homedef", "Parentdirectory", " parentfolder", "Parentfile", "partdir", "Parentfolder", " parentdef", "parentdirectory", "parentdef", "masterdef", " parentdict", "masterdict", "parentfile"]}}
{"id1": "8770016", "id2": "3945236", "code1": "    public InputStream loadResource(String location) throws GenericConfigException {\n        URL url = getURL(location);\n        try {\n            return url.openStream();\n        } catch (java.io.IOException e) {\n            throw new GenericConfigException(\"Error opening URL resource at location [\" + url.toExternalForm() + \"]\", e);\n        }\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"loadResource": ["newURL", "readFile", "newResource", "createURL", "newFile", "loadUrl", "newUrl", "createFile", "createResource", "readUrl", "loadURL", "readResource", "readURL", "loadFile", "createUrl"], "location": ["property", "resource", "timeout", "local", "route", "description", "position", "string", "href", "pointer", "area", "region", "language", "response", "URL", "path", "layer", "operation", "length", "content", "address", "loc", "l", "base", "layout", "Location", "ocation", "config", "loader", "link", "localhost", "filename", "remote", "directory", "level", "type", "point", "target", "uri", "source", "uration", "collection", "name", "file", "reference"], "url": ["resource", "route", "external", "ob", "string", "site", "http", "xml", "URL", "log", "path", "layer", "this", "Url", "rl", "object", "address", "loc", "build", "rel", "l", "connection", "base", "element", "event", "server", "plug", "config", "loader", "sl", "f", "link", "e", "i", "image", "remote", "page", "ssl", "null", "jar", "job", "web", "source", "buffer", "uri", "org", "name", "file", "ref"]}}
{"id1": "841724", "id2": "19096138", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "11183087", "id2": "614099", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"doPost": ["handlePut", "doPOST", " doPOST", "handleSearch", "doingPost", " doPut", "doPut", "doingPOST", "doingSearch", " doSearch", "doingPut", "handlePost", "doSearch", "handlePOST"], "request": ["resource", "application", "pull", "route", "subject", "use", "external", "project", "join", "instance", "current", "initial", "context", "xml", "view", "Request", "http", "call", "forward", "state", "input", "right", "report", "have", "queue", "post", "enter", "the", "user", "child", "object", "er", "frame", "order", "hello", "rate", "pe", "event", "model", "server", "query", "url", "get", "config", "complete", "e", "q", "image", "remote", "result", "error", "type", "data", "req", "QUEST", "r", "press", "message", "web", "info", "parent", "client", "buffer", "create", "rf"], "response": ["Response", "resource", "application", "status", "respond", "site", "reply", "http", "results", "view", "report", "api", "onse", "object", "guide", "resp", "document", "connection", "model", "server", "pool", "writer", "res", "result", "page", "next", "output", "message", "web", "parent", "client", "body", "template"], "senha": ["senla", " senwa", "zenHa", "suitla", "sanHa", " senca", "sanlah", "senhi", "zensha", "tonHa", "senca", "senlah", "tonlah", "snla", "snhi", "zenha", "renha", "suitsha", "zenaka", "senHa", "zenhi", " senHa", "renca", "tonha", " senlah", "snsha", "tonwa", "sanha", "suitha", "renHa", "senwa", "sensha", "zenca", "suithi", "zenla", "renaka", "snha", "senaka", " senaka", "sanwa"], "email": ["mail", "username", "Email", "ip", "fax", "line", "zip", "string", "environment", "xml", "secret", "service", "language", "label", "user", "address", "letter", "hello", "business", "model", "phrase", "server", "url", "office", "e", "home", "password", "example", "mobile", "login", "data", "account", "message", "id", "alias", "name", "file"], "messageDigest": ["messageDest", "meDigest", "messageDester", " messageDigester", " messageDend", "medigEST", "messagedigest", "messageDigester", "messagedigester", " messageDEST", "messageMailest", "meDigester", " messageDest", " messagedigEST", "messageDigEST", " messageDester", "messagedigEST", "meDigher", "messagedigend", " messagedigest", " messagedigester", "meDigEST", "messageDher", "medigest", "messagedigher", "messageDend", "messageDEST", "medigester", "messageMailester", "messageDigend", " messageDigend", "messageMailEST", "medigher", "messageDigher", "messageMailend", " messageDigEST"], "usuario": ["sulurio", "suuarial", "usituarial", "ussuario", "usuariat", " usuarius", "ususario", "usuasio", "usiturio", "ussuarium", " usurio", " usuiasio", "usituario", "usguario", "usguariat", "suluarial", "usuillo", "suuario", " usuariat", "usueillo", " ususillo", " usuillo", "usuarius", " usuasio", "ususillo", "ussuasio", "suluasio", "uslurio", "ussurio", "usuitario", "usluarial", "usuitarium", "usurio", "usuiasio", " usuiario", "suluario", "usituasio", " ususario", "suurio", " ususarius", "ususarius", "usueariat", " usuirio", "usuarial", "usuiarium", "usuitasio", "usuearius", "usluasio", "usuiario", "usuitrio", "usluario", "suuasio", "usueario", " usuarium", "ususariat", "usguarius", "ussuarial", "usuarium", " usuiarium", "usguillo", " ususariat", "usuirio"], "redirect": ["redurl", "edurl", "rerict", "edirect", " redirection", "redrict", "reirect", " redRECT", "indirection", "predRECT", "Redirect", "Redirection", "induce", " reduce", "reroute", "preduce", "redirection", "indirect", "redition", "Redroute", "redRECT", "predirect", "predroute", "indrict", "Redrict", " redition", " redrict", "predrict", "predirection", "RedRECT", "Redurl", " redurl", "reduce", "edirection", "Redition", "reirection", "edition", "redroute"], "session": ["group", "use", "sid", "cache", "view", "http", "proxy", "comment", "service", "state", "input", "node", "object", "child", "user", "cookie", "browser", "flash", "ession", "app", "connection", "document", "storage", "event", "server", "query", "sp", "system", "config", "sl", "Session", "image", "page", "result", "ssl", "data", "message", "info", "client", "site", "person"]}}
{"id1": "11477906", "id2": "16092702", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"loadDefaultSettings": ["getDefaultParameters", "loadGlobalsettings", "loadGlobalParameters", "loaddefaultConfiguration", "loaddefaultParameters", "loadApplicationSettings", "getdefaultConfiguration", "getdefaultParameters", "getdefaultsettings", "loadDefaultConfiguration", "loadDefaultsettings", "loadApplicationParameters", "loaddefaultsettings", "loaddefaultSettings", "loadDefaultParameters", "getDefaultSettings", "loadApplicationsettings", "getdefaultSettings", "getDefaultsettings", "loadGlobalSettings", "loadGlobalConfiguration", "loadApplicationConfiguration", "getDefaultConfiguration"], "configFileName": ["configPlaceLocation", "configFILELocation", "configFileType", "configFilenameLocation", "configFullLocation", "fileFILEType", "fileFILETime", "configFILETime", "configFileUrl", "configFilesName", "fileFILELocation", "ConfigModuleUrl", "ConfigFileString", "fileFileType", "configFileLocation", "configModuleUrl", "configFilesType", "ConfigModuleLocation", "configModuleString", "fileFileName", "configModuleName", "fileFileTime", "configFullUrl", "configFilenameName", "ConfigFileLocation", "configFullName", "configPlaceName", "configFileTime", "fileFileLocation", "configPlaceString", "ConfigFileName", "configFilesTime", "configFilesLocation", "configPlaceUrl", "configFileString", "configModuleLocation", "configFullString", "ConfigModuleString", "configFilenameType", "ConfigModuleName", "configFILEType", "ConfigFileUrl", "fileFILEName", "configFILEName", "configFilenameTime"], "in": ["resource", "In", "pull", "pass", "pc", "plus", "again", "n", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "as", "log", "con", "this", "pin", "ins", "conn", "inn", "err", "it", "up", "init", "base", "url", "work", "config", "read", "f", "inside", "i", "nin", "a", "socket", "login", "ssl", "reader", "diff", "data", "r", "inc", "id", "source", "stream"], "out": ["timeout", "able", "again", "and", "string", "instance", "c", "o", "ex", "exp", "view", "d", "version", "bin", "Out", "copy", "log", "io", "outs", "this", "sync", "conn", "object", "user", "err", "it", "up", "default", "connection", "net", "s", "all", "prefix", "exec", "server", " back", "config", "f", "off", "set", " file", "password", "image", "lib", "socket", "writer", "to", "ext", "file", "output", "data", "ou", "write", "obj", "OUT", "point", "null", " output", "t", "inc", "error", "parent", "back", "client", "name", "one"]}}
{"id1": "6371580", "id2": "21308543", "code1": "    public void insertDomain(final List<String> domains) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"domain.add\"));\n                    Iterator<String> iter = domains.iterator();\n                    String domain;\n                    while (iter.hasNext()) {\n                        domain = iter.next();\n                        psImpl.setString(1, domain);\n                        psImpl.setString(2, domain.toLowerCase(locale));\n                        psImpl.executeUpdate();\n                    }\n                }\n            });\n            connection.commit();\n            cmDB.updateDomains(null, null);\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                    log.error(ex);\n                }\n            }\n        }\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 0, "substitutes": {"insertDomain": ["addDom", "updatedomain", " insertdomain", " insertDom", "insertDom", "updateHost", "insertdomain", "addDomain", "addHost", "updateDom", "adddomain", " insertHost", "insertHost", "updateDomain"], "domains": ["commands", "commances", "Domains", "domages", "demains", "messains", "demages", "demands", "Domands", "commains", "messain", "demales", "dimages", "messands", "Domages", "demain", "dimales", "domances", "dimands", "domales", "messances", "domands", "dimains", "Domales", "commain", "demances"], "psImpl": ["PSEl", "osEl", " psInstance", "psEl", "psFactory", "qsImpl", "paramsInstance", " psimpl", "osFactory", "PSFactory", "PSimpl", "upsImpl", "PSUl", "osimpl", "ipsImpl", "psUl", "qsUl", "ipsOrg", "paramsInterface", "osImpl", "psimpl", " psManager", " psInterface", "paramsManager", "ipsInterface", "psOrg", "PSOrg", "qsimpl", "PSImpl", " psFactory", "upsimpl", " psOrg", "psManager", "psInterface", " psEl", "ipsimpl", "upsUl", "psInstance", "ipsManager", "ipsEl", "ipsInstance", "paramsImpl"], "iter": ["entry", "ip", "ter", "over", "ir", "inter", "upper", "former", "ator", "is", "inner", "walker", "cer", "ner", "feed", "apper", "enter", "in", "Iterator", "er", "iterator", "cher", "it", "err", "izer", "inse", "order", "chain", "coll", "index", "ite", "e", "itter", "i", "set", "el", "page", "ider", "finder", "next", "reader", "parse", "Iter", "gener", "inc", "loop", "oper", "sort", "end"], "domain": ["folder", "role", "root", "route", "country", "Domain", "description", "string", "host", "site", "str", "version", "region", "node", "division", "key", "zone", "address", "unit", "command", "rule", "base", "agent", "model", "prefix", "query", "url", "index", "company", "value", "feature", "dom", "format", "example", "remote", "result", "range", "page", "data", "type", "product", "module", "id", "message", "pattern", "brand", "name", "file", "origin"]}}
{"id1": "20024612", "id2": "17947246", "code1": "    private void parse() throws Exception {\n        BufferedReader br = null;\n        InputStream httpStream = null;\n        URL fileURL = new URL(url);\n        URLConnection urlConnection = fileURL.openConnection();\n        httpStream = urlConnection.getInputStream();\n        br = new BufferedReader(new InputStreamReader(httpStream, \"UTF-8\"));\n        String ligne;\n        String post;\n        String date;\n        String titre;\n        String resume;\n        String url2DL;\n        while ((ligne = br.readLine()) != null) {\n            if (ligne.indexOf(\"div class=\\\"post\\\" id=\\\"post\") != -1) {\n                post = null;\n                date = null;\n                titre = null;\n                try {\n                    post = ligne.substring(ligne.indexOf(\"post-\") + 5, ligne.indexOf(\"\\\"\", ligne.indexOf(\"post-\")));\n                    ligne = br.readLine();\n                    date = ligne.substring(ligne.indexOf(\"<div class=\\\"date\\\"><span>\") + 24);\n                    date = date.replaceAll(\"</span>\", \"\").replaceAll(\"</div>\", \"\").trim();\n                    log.info(\"Post   : \" + post + \" du \" + date);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    titre = ligne.substring(ligne.indexOf(\">\", ligne.indexOf(\"title\")) + 1, ligne.indexOf(\"</a>\"));\n                    titre = titre.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    url2DL = ligne.substring(ligne.indexOf(\"<a href=\\\"\") + 9, ligne.indexOf(\"/\\\"\")).trim();\n                    url2DL = url2DL.replace(\"mega-films.net\", \"mega-protect.com\") + \".php\";\n                    log.info(\"Titre  : \" + titre);\n                    log.info(\"To DL  : \" + url2DL);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    resume = ligne.substring(ligne.indexOf(\"<em>\") + 4, ligne.indexOf(\"</em>\"));\n                    resume = resume.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    log.info(\"Resume : \" + resume);\n                } catch (Exception e) {\n                    log.error(\"ERREUR : Le film n'a pas pu etre parse...\");\n                }\n                log.info(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\");\n            }\n        }\n    }\n", "code2": "    public String readURL(String urlLocation, ArrayList headers, RenderEngine c) throws Exception {\n        URL url = null;\n        HttpURLConnection conn = null;\n        InputStream istream = null;\n        try {\n            url = new URL(urlLocation);\n            conn = (HttpURLConnection) url.openConnection();\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to retrieve URL for '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        loadCookies(urlLocation, conn, c);\n        if (headers != null) {\n            for (int i = 0; i < headers.size(); i++) {\n                String header = (String) headers.get(i);\n                String key = header.substring(0, header.indexOf(\":\"));\n                String value = header.substring(header.indexOf(\":\") + 2);\n                Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                conn.setRequestProperty(key, value);\n            }\n        }\n        Debug.debug(\"Set to use GET, URL=\" + urlLocation);\n        try {\n            istream = conn.getInputStream();\n        } catch (Exception e) {\n            Debug.debug(\"Unable to capture input stream: \" + e.getMessage());\n            throw new Exception(\"Unable to capture input stream from URL '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        Debug.debug(\"'GET' - Got input stream.\");\n        if (conn.getContentLength() == -1) {\n            Debug.debug(\"Content length = unknown\");\n        } else {\n            Debug.debug(\"Content length = \" + conn.getContentLength());\n        }\n        byte data[] = null;\n        int curPos = 0, contentLength = conn.getContentLength();\n        if (conn.getContentLength() == -1) {\n            String byteSize = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.tunable']/property[@type='engine.unknowncontentsize']/@value\");\n            if (byteSize == null) {\n                contentLength = 4096;\n            } else {\n                contentLength = Integer.parseInt(byteSize);\n            }\n            Debug.debug(\"Content length unknown.  Allowing fuzz of \" + contentLength + \" bytes.\");\n        }\n        data = new byte[contentLength];\n        try {\n            int dataRead = 0;\n            while ((dataRead = istream.read(data, curPos, contentLength - curPos)) != -1) {\n                if (dataRead == 0) {\n                    break;\n                }\n                curPos += dataRead;\n            }\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to read data from HTTP connection: \" + e.getMessage());\n        }\n        try {\n            istream.close();\n            conn.disconnect();\n        } catch (MalformedURLException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' is invalid: \" + e.getMessage());\n        } catch (IOException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' failed to connect.\");\n        }\n        String dataOut = new String(data);\n        int counter = 0;\n        data = null;\n        istream = null;\n        conn = null;\n        url = null;\n        return dataOut.trim();\n    }\n", "label": 0, "substitutes": {"parse": ["request", "xml", "report", "process", "build", "print", "init", " parsing", "setup", " parser", "Parser", " serve", "load", "get", "url", "read", "arse", "split", "format", "check", "handle", "se", "raw", "pack", "parser", "update", "file"], "br": ["Br", "ch", "bh", "ger", "HR", "obl", "bre", "blog", "pr", "ocr", "http", "str", "ler", "report", "ber", "be", "ur", "ner", "yr", "buf", "sr", "bro", "BR", "div", "tr", "mr", "gr", "bridge", "orb", "bel", "cro", "lr", "err", "bl", "cr", "browser", "bolt", "arr", "url", "dr", "sp", "bc", "bar", "pre", "vr", "res", "cb", "result", "wr", "bb", "img", "next", "hr", "r", "b", "bf", "jar", "bt", "rb", "fr"], "httpStream": ["fileConnection", "httpsReader", "resourceSteam", " httpstream", "urlSteam", "httpsStream", "httpCh", "resourceReader", " httpSteam", "httpConnection", "fileStream", "ttpConnection", " httpSync", "ttpCh", " httpConnection", "httpSteam", "httpsSteam", "ttpStream", "databaseConnection", "databaseSteam", " httpInput", "databaseStream", "fileSync", "resourceStream", "httpReader", "httpstream", " httpCh", "resourcestream", "httpSync", "httpsstream", "urlInput", "urlStream", "fileCh", " httpReader", "ttpSync", "databaseInput", "httpInput"], "fileURL": ["urlSR", "baseSR", "baseLink", "baseURL", "baseUrl", "urlLocation", "fileSR", "FileUrl", "urlURL", " fileSR", "FileURL", " fileUrl", " fileLink", "fileLink", "urlUrl", "FileLocation", "fileUrl", "FileLink", "fileLocation", "baseLocation", " fileLocation"], "urlConnection": ["fileConnection", "urlConn", "httpConn", "fileBuffer", "resourceConnect", "urlBuffer", "resourceConnection", "httpBuffer", "httpConnection", "httpConnect", "resourceConn", "inputBuffer", "urlconnection", "fileconnection", "inputConnect", "httpconnection", "fileConnect", "resourceconnection", "fileConn", "urlConnect", "inputConn", "inputConnection"], "ligne": ["tivia", "olonge", "sligne", "elitte", " lauga", "sliner", "yline", " lgent", "torde", "ylige", "ylinea", "yligne", "liigne", "livia", "ilffe", "tine", "lidable", " livia", "tauga", " lounge", "elinea", " line", " linois", " lourse", "liuble", "tille", "elonge", "lilette", "olounge", "tinea", " liner", "zigne", "slagi", "tinois", "eligne", "liorde", "zuble", " litte", "slitte", " lidable", "litte", "tignment", " lagi", "lourse", "iline", "ylorde", " lille", "ilitte", " loyer", "slourse", "toyer", "klauga", "olinea", "slinea", "ilinea", "lagi", "linois", "ilgent", "zlette", "elidable", "ilonge", " lige", "elffe", "llette", "iloyer", "liiner", "liauga", "ylivia", "tgent", "lige", " llette", "ylitte", "oline", "ylinois", "sloodle", "ylounge", "elourse", "plounge", "sluble", "sloyer", "longe", "tonge", "lauga", "elounge", "lgent", " linea", "liignment", "zauga", "ilagi", "iluble", "sline", "liner", "tigne", "lignment", "eliner", "pline", "luble", "slonge", "ilauga", "kligne", "lionge", "linea", "slounge", "slauga", "ilourse", "klille", "lounge", "oligne", "iloodle", "slffe", "loodle", "line", " lorde", "iligne", "liivia", "slidable", "olourse", "olitte", "slignment", " loodle", "olidable", "kline", "plonge", " longe", "ilige", "lorde", "lille", "yloyer", " lffe", "loyer", "ylourse", "lffe", " luble", "tuble", "tiner", "pligne"], "post": ["pass", "class", "draw", "media", "ip", "project", "od", "zip", "string", "topic", "word", "POST", "title", "comment", "time", "log", "ticket", "patch", "add", "the", "meta", "cod", "user", "object", "address", "bug", "build", "p", "dd", "valid", "month", "tag", "tax", "mod", "pe", "thread", "Post", "pre", "password", "head", "image", "record", "data", "posts", "pod", "type", "style", "po", "id", "message", "update", "text", "body", "name"], "date": ["resource", "stage", "mate", "status", "day", "draw", "pose", "zip", "string", "dat", "d", "gender", "time", "year", "open", "match", "patch", "key", "number", "doc", "div", "user", "bug", "grade", "create", "month", "tag", "trade", "rate", "pe", "event", "url", "dr", "complete", "index", "dates", "mark", "value", "Date", "pre", "image", "format", "button", "page", "change", "save", "data", "type", "md", "module", "debug", "style", "duration", "id", "message", "sign", "update", "body", "name", "reason", "file"], "titre": ["tipre", "taitril", "ttigrex", "ttitril", "titaret", "ntitr", "ntittingrell", "titaril", "tizbre", "atipren", "ttitrex", "ntitritic", "titreen", "taitre", "ttitsril", "titsere", "atipre", "ptitsrone", "ptitsres", "atipbre", "tractren", "titpen", "ptitsre", "ttigre", "ntitsbre", "titsret", "titritic", "tittere", "titril", "tibrex", "tractrer", "ticere", "tuitre", "tigreen", "titsrone", "titsres", "tractritic", "tittrone", "ntitre", "taitret", "ttitsro", "ntittingrex", "tractre", "tizren", "ptitre", "tuitpen", "ptitres", "ttitreen", "atitbre", "titbre", "titsritic", "tithre", "ticre", "titrone", "tipbre", "taitro", "tuitritic", "titaro", "tithr", "titret", "titr", "tiprer", "ttitret", "tittingr", "tithrex", "titsreen", "tigrex", "titrex", "ntittingre", "titsbre", "titsro", "atitre", "ntitrex", "titspen", "tipren", "titsril", "ticrone", "titres", "ttitro", "ntitbre", "tittingrex", "ticres", "ttitsre", "tithrell", "ntitpen", "titrell", "tibrell", "tittre", "atitren", "tittingrell", "tithreen", "ptitere", "ttigritic", "tittingre", "ntitsre", "titro", "titsre", "tigre", "ntitsritic", "tittres", "atitrer", "tibr", "tibre", "ttitritic", "tithritic", "ptitsere", "titare", "tractbre", "ttigreen", "ntitspen", "ntittingr", "titsrex", "ttitre", "atiprer", "ttitsret", "tizre", "tractpen", "titere", "tigritic", "tizrer", "ntitrell", "titrer", "ptitrone", "titren", "tuitbre"], "resume": ["revend", " reserve", " resumption", "presumption", "presend", " resend", "resumption", "preserve", "reverve", "revumption", "revume", "presume", "resend", "reserve"], "url2DL": ["url4SL", "url4LL", "url2TL", "url4LM", " url2SL", "urlGETLP", "file2LC", " url6dl", "url2LC", "url6LP", " url2UL", "url62LR", "url2SL", "file2LL", " url6LL", "urlToDL", "urlTwoLC", "url6DL", "fileTwoLR", "urlBDL", "url2NL", "url2LM", "urlToTL", "url4DL", "file2LR", " url2LM", "fileTwoLC", "urlBLC", "url62DL", "urlTwoUL", "urlGETDL", "url2LR", "url2LP", "url2dl", "url6LL", "file2DL", "url4UL", "url4TL", "urlGETLL", " url2dl", "urlToLM", "urlTwoLL", " url2NL", "urlTwoSL", "fileTwoLL", "url4NL", "fileTwoDL", "urlTwoLP", "url2LL", "urlToNL", "urlTwoDL", " url6LP", "urlBLR", " url2LL", " url6DL", "url6dl", "urlTwoLR", "urlGETdl", "url2UL", "url62LL", " url2TL", " url2LP", "url62LC", "urlBLL", "urlTwodl"]}}
{"id1": "13757855", "id2": "8625346", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"process": ["resource", "processing", "run", "project", "request", "call", "view", "transform", "path", "construct", "build", "proc", "exec", "load", "processor", "code", "evaluate", "handle", "output", "parse", "submit", "Process", "update", "cess", "create"], "tpl": ["Tplate", "pPL", "itpl", "stPL", "qtfc", "tyl", "templ", "tPL", "qtple", "psl", "stplate", "tplate", "Tpp", " tplug", "qtcp", "Tpl", "pcl", "tcp", "Tplates", "atml", "lplate", "Tml", " tple", "latpl", "latyl", "fplug", "templates", "stpl", "tcl", " ttemplate", "tmyl", "tper", " tplates", " tcl", "tipl", "itplate", "qtbl", "fplate", "lpl", "lcl", " tfc", "lPL", "tfc", "tmpl", "qtpl", "latple", "tpp", "latcp", " tbl", "lple", " tsl", "atplug", "TPL", "Ttemplate", "Tcl", "temtemplate", "tplug", "atpl", "Tbl", " tper", "fml", "pipl", "atplate", "tsl", "itPL", " tPL", "lper", "qtyl", "tbl", "Tipl", "tmple", "itplates", "tmcp", "Tper", "tml", "ttemplate", "ppl", " tplate", " tpp", "tplates", "stpp", " tipl", "tple", "temPL", "Tple", "Tsl", " tml", "Tfc", "lml", "fpl"], "model": ["media", "project", "m", "xml", "language", "node", "copy", "log", "params", "param", "json", "doc", "command", "document", "location", "config", "where", "graph", "result", "data", "models", "module", "Model", "conf", "message", "body"], "packageName": ["contextNames", "groupKey", " packageNames", "modulename", "PackageNames", "moduleName", "packageKey", "projectUrl", " packageInfo", " packagename", "projectName", "PackageInfo", "packagename", "groupname", "contextName", "projectname", "packageUrl", "PackageName", "packageInfo", "contextInfo", "Packagename", "moduleUrl", "groupName", "projectKey", "contextname", "packageNames", "moduleKey", "groupUrl"], "outFileName": ["outfileTime", "OutDirLine", "outfileMode", "outStreamType", " outDirPath", "outFileCopy", "outFilesPath", "outStreamInfo", "diffFileName", "outLinename", "outFilename", "OutFilename", "OUTFileMode", "outFileNames", "outLineInfo", "outFileType", "outStreamName", "outLineName", " outFilePath", "OutDirName", "OutFileName", "OUTBufferNames", " outDirTime", "outDirEnd", "diffFileInfo", "difffileOnce", "OutDirname", "outfileInfo", "outDirInfo", "outfileName", "outDirTime", "diffFileTime", "outFileInfo", "inFileCopy", "outFullName", "outFilenameNames", "outLineNames", "outLineTime", "inDirEnd", "difffileInfo", "outFileEnd", "outFullPath", "outFilenameHalf", "OutDirNames", "outBufferName", "outFilesName", "outFileHalf", "outFullNames", "outFullLine", "outFileLine", "outfileNames", "outBufferMode", "outBufferHalf", "outFullInfo", "outfileHalf", "inFileEnd", " outDirName", "inFilePath", "outFullType", "OUTBufferName", "outDirOnce", "difffileTime", "inDirCopy", "OUTBufferHalf", "outDirCopy", "outfileEnd", "OutFileLine", "outFilenameName", "OUTFileNames", "inFileName", " outFileType", "outFilesTime", "diffFileOnce", "outfileOnce", "OUTBufferMode", " outFileLine", " outFullInfo", " outFileInfo", "outDirName", "outRuleName", "outLineOnce", "outDirLine", "outFilenameMode", "outFilenamePath", "outLineLine", "outDirPath", " outFullType", "outFileOnce", "outFilenameEnd", " outDirLine", "outFilesLine", "outFilenameCopy", "outFullTime", "outDirname", "inDirPath", "outFileTime", "outfilePath", "OUTFileHalf", "outDirNames", " outFileTime", "outfileCopy", "inDirName", "outFileMode", "outRuleType", "outFilePath", " outFullName", "outRuleInfo", "outFullname", "OutFileNames", "outBufferNames", "difffileName", "OUTFileName"], "xsltParam": ["xslicVal", "xsltVal", "xsltMode", "xsltparam", "xsldparam", "xldVal", "xslpMode", "xltparam", "xltParam", "xslpParam", "xslpVal", "xsldParam", "xldparam", "xldMode", "xltMode", "xltVal", "xslicMode", "xsldVal", "xsldMode", "xslicparam", "xslpparam", "xslicParam", "xldParam"], "artifact": ["Arturation", "Artfact", "artfact", "ARTfact", "Artifest", "Artifacts", "ARTifact", "advertribution", "artribution", "advertifact", "ARTifest", "aratfact", "aratifact", "Artribution", "arturation", " arturation", "artifest", "aratifest", "advertifacts", " artifacts", "adverturation", "Artifact", "aratifacts", "ARTifacts", "artifacts", " artribution"], "destinationPath": ["tempinationpath", "destationpath", "restinatorHalf", "destributionpath", "destensionText", "destinatorPoint", "distinatorName", "destinatingLocation", "distributionpath", "destiningPath", "destinatorFile", "destplingUrl", "destiningDir", "tempinatedPath", "constinatorWidth", "destinateName", "datinationLocation", "destinateHalf", "destinationCase", "tempinatedpath", "destributionCry", "destinatepath", "desturationpath", "desticationFile", "destinationName", "distinationCry", "DestinationPart", "destationPath", "datinateLocation", "restificationpath", "restificationLocation", "destificationDir", "distinationDir", "restificationPoint", "restinatorPath", "desturationHandler", "destinatedKey", "destinatePoint", "destinatorUrl", "DestinatingPoint", "DestinatingPath", "destinationHandler", "datinateTime", "distinationPath", "destinationsPoint", "destinatedHalf", "distributionCase", "tempinationDir", "destinatorCry", "destinatePart", "restinationPoint", "constinationsName", "destinatorLocation", "destiationDir", "destinatingName", "combinationHandler", "destinationpath", "destinationContext", "DestinatingName", "destinationsPath", "destinationPoint", "constinationsPath", " destinationDir", "constinationspath", "restinationLocation", "destiationLog", "constinationsPoint", "destinatingText", "destributionDir", "destinatingPath", "destificationPart", "constinationName", "restinatorString", "destplingAuth", "DestificationPath", " destificationPath", "desticationPath", "destcreationPath", "destificationAuth", "destinatingPoint", "DestificationName", "distinatorCry", "destinatePath", "destinateTime", "desturationName", "destinerContext", "distributionDir", "constinationPath", "datinationpath", "DestinationName", "destificationName", "distinationStep", "distinationFile", "distinationKey", "tempinatedDir", "destplingLog", "destinateDir", "destiningContext", "destinatedPath", "destplingDir", "restinationString", "destinateLocation", "restinationHalf", "destinatedpath", "destributionName", "destensionName", " destinationLog", "constinationDir", "desturationPath", "restificationPath", "desticationPart", "destinatedString", "destinatedFile", "destinationsName", "destplingWidth", "destificationPoint", "destinationLog", "constinationContext", "distinationCase", "restinationpath", "destinatorHalf", "distinatorKey", "constinationWidth", "DestinationText", "destificationLocation", "destcreationWidth", "destinationText", "destinatorString", "destinationLocation", "destinatorTime", "destiationPath", "destinationPart", "tempinationHalf", "desticationKey", "tempinationPath", "combinatorpath", "constinatorContext", " destificationAuth", "destinateHandler", "constinatorPath", "constinatorDir", "combinationpath", "destinatingpath", " destificationDir", "destinerPath", "destensionPath", "destinatorCase", "destinatorKey", "combinatorName", "destinationWidth", "destinatorpath", "destiningName", "destensionPoint", "distinationpath", "combinatorHandler", "destinationString", "constinatorpath", "destiationAuth", "constinatorUrl", "destinatorContext", "destinationUrl", "destinationDir", "destinatorHandler", "destationLocation", "distributionPath", "constinationpath", "destificationLog", "distinatorFile", "combinatorPath", "datinationPath", "destinationKey", "destificationpath", "destinatorStep", "destinatedStep", "destationTime", "destcreationUrl", "destinatorPath", "destinationStep", "combinationName", "restinationPath", "DestinatingText", "tempinatedHalf", "distinationName", "datinatepath", "destignmentCase", "datinationTime", "destinatorDir", "destinatorName", "destinationAuth", "destinateText", "destinationHalf", "desticationStep", "destificationPath", "destignmentCry", "destinatedPoint", "destiningpath", "destinateString", "combinationPath", "datinatePath", "destinatedCase", "destignmentPath", " destinationAuth", "desticationName", "distinatorStep", "distinatorCase", "destributionPath", "destinationFile", "destinerpath", "destplingPath", "destributionCase", "destinerDir", "destignmentName", "DestinationPath", "destinationTime", "restinatorPoint", "destinatorWidth", "constinationPoint", "destiningPoint", "DestificationPart", "DestinationPoint", "destinatedDir", "destinationspath", " destificationLog", "distinatorPath", "constinationUrl", "destinationCry"], "in": ["In", "n", "c", "cache", "IN", "ex", "d", "din", "bin", "input", "con", "ins", "doc", "min", "connection", "x", "config", "i", "image", "reader", "data", "r", "t", "inc", "source", "name"], "out": ["temp", "group", "line", "again", "full", "string", "cache", "o", "ex", "str", "comment", "version", "bin", "state", "Out", "with", "copy", "msg", "outer", "manager", "log", "io", "path", "outs", "key", "list", "sys", "post", "doc", "user", "conn", "err", "store", "up", "connection", "w", "part", "all", "prefix", "exec", "server", "index", "pool", "cli", "session", "dump", "lib", "writer", "free", "page", "result", "ne", "output", "gen", "error", "write", "obj", "OUT", "point", "parent", "lock", "source", "client", "name", "file", "Output"], "root": ["cat", "history", " roots", "instance", "resources", "cache", "include", "results", "values", "xml", "node", "transform", "options", "path", "params", "Root", "tree", "meta", "json", "roots", "query", "url", "loader", "index", "graph", "_", "format", " result", "module", "r", "id", "pattern", "parent", "collection", "modules"]}}
{"id1": "8942491", "id2": "12744653", "code1": "    public static URLConnection openProxiedConnection(URL url) throws IOException {\n        if (proxyHost != null) {\n            System.getProperties().put(\"proxySet\", \"true\");\n            System.getProperties().put(\"proxyHost\", proxyHost);\n            System.getProperties().put(\"proxyPort\", proxyPort);\n        }\n        URLConnection cnx = url.openConnection();\n        if (proxyUsername != null) {\n            cnx.setRequestProperty(\"Proxy-Authorization\", proxyEncodedPassword);\n        }\n        return cnx;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"openProxiedConnection": ["openProxifiedconnection", "openProxiesConnection", "openProXifiedconnection", "openProxiedApplication", "openProxedconnection", "openProXifiedApplication", "openProxifiedConn", "openProxedConnection", "openProxifiedApplication", "openProxiesConn", "openProxedApplication", "openProXiedConn", "openProXifiedConnection", "openProXiedconnection", "openProxedConn", "openProXiedApplication", "openProxifiedConnection", "openProxiesApplication", "openProxiesconnection", "openProxiedConn", "openProxiedconnection", "openProXiedConnection", "openProXifiedConn"], "url": ["resource", "class", "u", "string", "host", "http", "str", "proxy", "service", "www", "URL", "api", "io", "gl", "this", "Url", "object", "user", "address", "lr", "browser", "l", "connection", "base", "server", "system", "config", "loader", "sl", "f", "i", "socket", "page", "ssl", "obj", "b", "web", "uri", "source", "client", "file"], "cnx": ["cnX", "nb", "lcf", "CNNx", "nw", "cnw", "CNNw", "connx", "connxes", "CNx", "lcX", "gnf", "cnxes", "cnf", "nx", "CNn", "CNNb", "lcxes", "nn", "cnex", "lcn", "cnb", "CNNn", "cnc", "gnx", "cdnn", "lcx", "gnex", "cnn", "connX", "cdnx", "CNw", "connex", "lcex", "gnn", "gnc", "cdnf", "gnX", "CNb", "lcc", "cdnc", "gnxes"]}}
{"id1": "16232202", "id2": "21489105", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "code2": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"doPost": [" doSend", "didSend", "doingSend", "doPOST", "didPut", " doPOST", " doPut", "didPOST", "doSend", "doPut", "doingPOST", "didPost", "doingPost", "doingPut"], "request": ["resource", "application", "row", "route", "subject", "use", "external", "project", "join", "instance", "current", "initial", "context", "register", "method", "view", "Request", "xml", "you", "select", "condition", "state", "input", "self", "report", "list", "queue", "post", "enter", "user", "child", "object", "er", "store", "order", "hello", "rate", "event", "upload", "server", "query", "url", "load", "get", "complete", "session", "e", "q", "image", "remote", "result", "page", "next", "reader", "save", "data", "type", "submit", "parse", "req", "QUEST", "press", "error", "message", "web", "info", "parent", "client", "re", "create", "rf"], "response": ["Response", "resource", "application", "status", "we", "subject", "exit", "serv", "respond", "site", "environment", "reply", "http", "view", "forward", "service", "report", "api", "feed", "onse", "wa", "tree", "object", "resp", "document", "ception", "model", "server", "shell", "query", " Response", "complete", "index", "pool", "session", "su", "e", "image", "writer", "res", "result", "page", "next", "output", "ae", "error", "esi", "en", "de", "message", "parent", "web", "uri", "body", "re", "fire"], "cu": ["VC", "eu", "uu", "usa", "uci", "u", "c", "cul", "ru", "ca", "cin", "Cu", "asu", "cus", "agu", "cca", "ci", "xc", "U", "ue", "cci", "co", "ui", "cf", "aca", "ce", "ac", "cum", "ucc", "CI", "loc", "gu", "cc", "mc", "vc", "rc", "UC", "coll", "cur", "chu", "du", "cli", "su", "CU", "ul", "ku", "uc", "hu", "ou", "tu", "cy", "nu", "uni", "CA", "lu", "tc", "lc"], "ud": ["eu", "df", "us", "uu", "usa", "pd", "u", "ug", "od", "stri", "ub", "ru", "UD", "asu", "um", "cus", "uds", "utils", "uid", "da", "ci", "wik", "uda", "au", "ur", "ue", "util", "ui", "uv", "auth", "user", "ada", "bug", "ad", "gu", "dd", "gb", "usc", "rc", "storage", "upload", "chu", "uli", "du", "usr", "ut", "cli", "su", "li", "uf", "ku", "pub", "uc", "udi", "ou", "tu", "vd", "uri", "ck", "lu", "db"], "returnTo": ["replyto", "outputFrom", "accessFrom", "replyTo", "exitFrom", "accessTo", "returnto", "backto", "exitTo", "returnFrom", "accessTO", "Returnto", "ReturnTo", "backTo", "backTO", "replyTO", "accessto", "exitto", "ReturnFrom", "returnTO", "outputto", "replyFrom", "outputTO", "backFrom", "outputTo", "ReturnTO", "exitTO"], "password": ["token", "username", "sword", "mac", "string", "pg", "word", "secret", "sha", "sum", "Password", "wallet", "PASS", "params", "patch", "key", "auth", "pad", "email", "wd", "user", "address", "ass", "pa", "phrase", "confirmed", "code", "login", "diff", "data", "null", "account", "message", "crypt", "mask", "name", "encrypted", "padding"], "md": ["dc", "df", "mb", "mg", "mp", "ms", "od", "mand", "rm", "mac", "m", "pg", "sm", " MD", "d", "sha", "MD", "bd", "meta", "wd", "hd", "dd", "mc", "cd", "cmd", "mn", "ma", "mag", "f", "am", "dm", " Md", "amd", "diff", "dig", "managed", "rpm", "mm", "vd", "mad", "mt", "db", "mo"], "hash": ["row", "hed", "sh", "mac", "cache", "Hash", "rh", "secret", "total", "sha", "sum", "hex", "key", "number", "char", "auth", "user", "no", "kh", "ass", "base", "tag", "url", "ash", "array", "confirmed", "code", "her", "h", "dot", "diff", "dig", "raw", "block", "version", "db", "ref"], "pass": [" auth", "row", "ask", " passed", "act", "string", "mac", "push", " Pass", "secret", "sum", "PASS", " login", "key", " def", "auth", " mac", "mess", "wd", "user", " secret", "conn", "def", "ass", "pos", "fail", "pa", "phrase", " mess", "sl", "strip", "login", "gen", "diff", "r", "az", "id", "sign", "Pass", "conf", "text", "db", "ss", "ref"], "vis": ["dc", "travel", "status", "class", "keep", "acc", "cross", "ip", "nic", "act", "VIS", "c", "host", "qa", "virt", "access", "ex", "exp", "secret", "view", "see", "state", "visible", "na", "shape", "wa", "skip", "design", "lit", "mit", "gu", "lab", "nat", "rib", "spot", "coll", "miss", "nav", "circ", "fac", "su", "Vis", "vest", "ravis", "stat", "tri", "mis", "att", "type", "vid", "style", "vert", "press", "feat", "id", "sign", "name", "san", "ref"]}}
{"id1": "812803", "id2": "12744653", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["Converting", "subverting", "unverted", "Conversion", "converted", "CONverted", "unception", "CONverting", "conversion", " deconverting", "Convert", " deconvert", "conception", " deconverted", "subversion", "oconverted", "Conception", "subverted", "CONception", "oconvert", "oconversion", "subvert", "unvert", "CONversion", "CONvert", "converting", " deconversion", "unversion", "Converted", "oconverting"], "src": ["resource", "scene", "stage", "sth", "username", "cmp", "SourceFile", "string", "href", "Source", "spec", "cpp", "dist", "input", "ource", "path", "inst", "ctx", "sc", "buf", "slice", "sys", "attr", "rl", "download", "impl", "fn", "loc", "proc", "video", "gb", "s", "rc", "storage", "upload", "tmp", "url", "component", "load", "sn", "config", "sb", "code", "gz", "filename", "sin", "Dest", "fp", "cb", "ssl", "img", "reader", "st", "RC", "supp", "secure", "obj", "req", "feat", "rb", "prot", "back", "source", "stream", "uri", "sel", "name", "sit", "file", "ref"], "dest": ["dc", "txt", "temp", "class", " dst", "dat", "dist", "bin", "path", "di", "disk", "dir", "fn", "orig", "tmp", "home", "lib", "Dest", "std", "img", "test", "obj", "target", "null", " destination", "source", "cont"], "in": ["In", "inas", "pass", "ini", "n", "IN", "ex", "is", "d", "din", "bin", "input", "as", "io", "pin", "ins", "doc", "inn", "err", "up", "isin", "win", "f", "i", "a", "inf", "val", "login", "reader", "data", "r", "ps", "t", "inc", "source", "stream", "file"], "p": ["pc", "cop", "pd", "pm", "g", "c", "pr", "pi", "op", "py", "pb", "pg", "o", "m", "d", "np", "pp", "bp", "tp", "wp", "l", "part", "s", "pe", "cp", "pa", "j", "sp", "per", "f", "e", "lp", "i", "pre", "h", "fp", "v", "P", "jp", "r", "po", "ps", "t", "parser", "b"], "ds": ["dc", "hs", "words", "dl", "gs", "da", "obs", "s", "icks", "ges", "dm", "ts", "sts", "db", "df", "js", "pd", "bs", "ys", "dat", "lines", "dos", "d", "utils", "ads", "styles", " props", " sd", "amps", "ld", "ans", "Ds", "lp", "ns", "data", "posts", "parts", "docs", "ps", "DS", "ss", "dp", "scripts", "uds", "di", "os", "sync", "sys", "ins", "xs", "tests", "dds", "ls", "dt", "cs", "des", "nas", " DS", "ups", "ks", "eps", "dist", "cons", "ays", "tools", "ants", "groups", "plugins", "dd", "qs", "vs", "services", "dates", "ths", "els", "gd", "ded", "vals", "points", "ils", " ps", "ipes", "rs", "models"], "format": ["struct", "class", "function", "at", "act", "string", "host", "table", "spec", "version", "language", "atter", "path", "fd", "api", "magic", "letter", "unit", "handler", "fn", "frame", "nat", "scale", "tag", "part", "layout", "Format", "model", "prefix", "ant", "url", "config", "f", "sche", "filename", "record", "fp", "filter", "data", "type", "feat", "style", "plugin", "t", "parser", "pattern", "source", "form", "name", "file", "template"], "hasPixelData": ["showsPixeldata", "haspixeldata", "showsPixelDATA", "hasByteDATA", "hasPixeldata", "hasPixelDATA", "showsPixelStyle", " hasPixelSize", " hasPixeldata", "showsBytedata", "showsByteStyle", "haspixelSize", "showsPixelData", "hasByteData", "hasByteStyle", "hasBytedata", "haspixelData", "hasPixelStyle", "showsByteData", "hasPicturedata", "hasByteSize", "hasPictureSize", "hasPixelSize", "hasPictureData", "showsByteDATA"], "inflate": ["inFlated", "inadequating", "infloace", "insflode", "InFlate", "infolATE", "inadequode", "insvenATE", "inFlate", "insflating", "InFlace", "insflATE", "inffated", "inflation", "invenate", "inflace", "infolode", "inFlation", "infloate", "insvenate", "invenATE", "infloated", "inffation", "invenating", "InFlated", "insvenating", "insflate", "inflATE", "inflating", "Inflace", "infface", "inFlace", "infolate", "Inflated", "inffate", "Inflate", "inadequate", "insvenode", "inflated", "infolating", "infloation", "inflode", "invenode", "Inflation", "InFlation", "inadequATE"], "pxlen": ["fxdata", "pnglen", "pxlin", "mxln", "axlon", "pxcount", "fxln", "pglen", "txln", "pcln", "ppl", "pxlon", "txlin", "camlen", "fxl", "pgden", "pngsize", "axlin", "mxlen", "camln", "fxden", "xplength", "ppLen", "mxdata", "pxLen", "pxdata", "pclen", "pclin", "axln", "pxln", "axlen", "txlen", "pngcount", "campos", "mxpos", "fxLen", "xpsize", "xpcount", "pxsize", "pgl", "pxpos", "ppden", "pgLen", "fxpos", "pxlength", "fxlen", "mxlength", "mxcount", "xplen", "mxsize", "camdata", "pxden", "pclon", "pplen", "pxl", "pnglength", "txlon"], "out": ["group", "line", "again", "cache", "step", "inter", "state", "Out", "copy", "log", "io", "outs", "list", "co", "post", "sys", "pad", "user", "conn", "store", "err", "up", "server", "query", "work", "cli", "session", "dump", "lib", "v", "page", "output", "gen", "error", "obj", "OUT", "point", "parent", "lock", "re"]}}
{"id1": "8778962", "id2": "12172485", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeStringToFiles", "decodeFileAsFiles", "decodeStringToFile", "decodeFileAsStream", "decodeString2Stream", "decodeFileFromStream", "decodeFileFromFiles", "decodeStringToString", "decodeFile2File", "decodeFileAsString", "decodeFileFromFile", "decodeStringToStream", "decodeFileToString", "decodeString2String", "decodeFile2String", "decodeFile2Files", "decodeFileToStream", "decodeFileToFiles", "decodeFileAsFile", "decodeString2File", "decodeString2Files", "decodeFileFromString", "decodeFile2Stream"], "infile": [" infp", " instream", "minbase", "Inbase", "inputfilename", "infp", "minstream", "outfiles", " infiles", "minFile", "inputfp", "inputfiles", "minfile", "outfilename", "Infile", "inbase", " inbase", "outfp", " infilename", "instream", "InFile", "inFile", "inputfile", " inFile", "Instream", "infiles", "infilename"], "outfile": ["outputpath", "outfolder", " outdatabase", "inputFile", "outputFile", "inputdatabase", " outFile", "outfilename", "inputpath", " outfilename", " outfolder", "outpath", " outpath", "outputdatabase", "inFile", "inputfile", "infolder", "outputfolder", "outFile", "outputfile", "outputfilename", "infilename", "outdatabase"], "in": ["In", "inas", "pass", "again", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "ic", "as", "con", "pin", "ins", "ac", "min", "conn", "inn", "into", "err", "isin", "init", "win", "s", "rin", "lin", "gin", "thin", "inside", "i", "nin", "a", "socket", "sin", "login", "reader", "data", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "In", "or", "pass", "exit", "line", "again", "cache", "channel", "o", "ex", "inner", "bin", "Out", "copy", "outer", "log", "io", "outs", "co", "post", "sync", "conn", "no", "err", "up", "net", "base", "exec", "work", "name", "session", "off", "home", "image", "lib", "socket", "to", "writer", "output", "error", "ou", "write", "obj", "OUT", "point", "job", "inc", "parent", "client", "one", "file"], "buffer": ["seed", "channel", "cache", "uffer", "limit", "padding", "bin", "input", "layer", "wave", "feed", "buf", "queue", "slice", "length", "address", "count", "batch", "base", "server", "url", "size", "Buffer", "iter", "value", "split", "bytes", "transfer", "result", "border", "bb", "reader", "data", "write", "type", "raw", "null", "b", "buff", "flush", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", "tell", " Read", "use", "ip", " skip", "send", "n", " write", "current", "reading", "fill", "limit", "select", "copy", "READ", "lex", "io", "feed", "add", "slice", "sync", "length", " count", "count", "seek", "play", "Read", "ad", "exec", "find", "get", "load", "x", "wait", "size", "work", "f", "iter", "len", "i", "allow", "ind", "_", "start", "ride", "check", "connect", "next", "reader", " copy", "parse", "write", "se", "raw", "r", "inc", "id", "sleep", "end"], "success": ["rolled", "done", "pass", "status", "again", "initial", "method", "results", "failed", "comment", "winner", " Success", "continue", "response", "func", "right", "fast", "path", "open", "Success", "primary", "ceed", "first", "warning", "construct", "content", "ccess", "positive", "growth", "roll", "good", "valid", "successful", "flash", " successful", "default", "danger", "model", "fail", " succeed", "complete", " succ", "value", "rolling", "result", "better", "true", "follow", "data", "error", "xx", "null", "successfully", "message", "cess"]}}
{"id1": "16760971", "id2": "16572931", "code1": "    public static String generateHash(String key) {\n        key += \"use_your_key_here\";\n        MessageDigest md;\n        try {\n            md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            StringBuffer buff = new StringBuffer();\n            for (int l = 0; l < bytes.length; l++) {\n                String hx = Integer.toHexString(0xFF & bytes[l]);\n                if (hx.length() == 1) buff.append(\"0\");\n                buff.append(hx);\n            }\n            return buff.toString().trim();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 0, "substitutes": {"generateHash": ["generatesMac", "generatedSalt", "generoseKey", "generatesKey", "generateKey", "generateSalt", "generoseSalt", "generatesSalt", " GeneratedHash", "generateMac", " GenerateKey", "generoseMac", " GenerateSalt", " GeneratedMac", "generatedKey", "generatesHash", " GenerateHash", "generoseHash", " GenerateMac", " GeneratedSalt", " GeneratedKey", "generatedMac", "generatedHash"], "key": ["body", "token", "Key", "seed", "fee", "full", "k", "string", "mac", "word", "secret", "str", "self", "msg", "path", "proof", "KEY", "hex", "char", "pair", "trust", "ce", "user", "address", "rule", "connection", "base", "pe", "prefix", "url", "work", "keys", "block", "date", "code", "cert", "password", "hash", "data", "type", "point", "id", "message", "cy", "sign", "crypt", "text", "ace", "name", "file"], "md": ["dc", "df", "mb", "mg", "mp", "mail", "pd", "ms", "mage", "pm", "od", "mand", "cm", "mac", "Cmd", "m", "rm", "clean", "mem", "sm", " MD", "d", "hm", "di", "MD", "bd", "wd", "hd", "ad", "dd", "ld", "mc", "cd", "mod", "cmd", "dh", "dr", "ma", "mag", "nd", "am", "ds", "dm", "hash", "editor", " Md", "nm", "amd", "dig", "rpm", "mm", "metadata", "po", "message", "mad", "mt", "me", "bm", "mo"], "bytes": ["pages", "Bytes", "words", "codes", "bps", "zip", "bs", "lines", "ones", "values", "errors", "bits", "objects", "bles", "outs", "letters", "os", "files", "boot", "seconds", "pieces", "gb", "cells", "s", "pins", "strings", "ls", "vs", " bits", "ops", "keys", "blocks", "ips", "vals", "bis", "parts", "data", "items", "b", "fb", "es", "binary", "les", "rows"], "buff": ["mb", "txt", "nb", "ob", "append", "py", "pb", "cpp", "cast", "fx", "uff", "ctx", "bd", "buf", "agg", "obb", "pp", "bug", "eb", "batch", "abb", "ph", "ff", "app", "gb", "amp", "fw", "tf", "bag", "cp", "tmp", "sb", "Buffer", "f", "flat", "uf", "kb", "bo", "cb", "html", "bis", "bb", "diff", "Buff", "b", "fb", "bf", "tt", "hack", "buffer", "bm"], "l": ["il", "ol", "u", "n", "c", "col", "o", "d", "dl", "pl", "le", "ll", "z", "la", "ly", "ell", "rl", "length", "p", "bl", "cl", "lb", "L", "ls", "j", "x", "sl", "f", "e", "lp", "lv", "i", "li", "nl", "el", "ul", "h", "v", "al", "fl", "b", "t", "kl", " L", "ln", "lu", "jl", "lc"], "hx": ["Hy", "Hxa", "hsx", "hmy", "hswx", "hc", "hy", "Hc", "dhc", "Hxc", " hxc", "hwx", "Hrx", "hmxa", "hxa", " hex", "hex", "dhex", "hmxs", " hrx", " hxs", "hmx", "hsrx", "dhx", "hxc", "hrx", " hwx", "hsxc", "Hwx", "Hxs", " hc", " hy", "Hex", "hxs", "Hx", "dhxc", " hxa"]}}
{"id1": "18217985", "id2": "22268798", "code1": "    public static String fromHtml(URL url, String defaultEncoding, boolean overrideEncoding) throws IOException, BadDocumentException {\n        URLConnection conn = url.openConnection();\n        String contentType = conn.getContentType();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) {\n            int i = contentType.indexOf(\"charset\");\n            if (i >= 0) {\n                String s = contentType.substring(i);\n                i = s.indexOf('=');\n                if (i >= 0) {\n                    s = contentType.substring(i + 1).trim();\n                    encoding = s.replace(\"\\'\", \"\").replace(\"\\\"\", \"\").trim();\n                    if (encoding.equals(\"\")) {\n                        encoding = defaultEncoding;\n                    }\n                }\n            } else {\n                encoding = defaultEncoding;\n            }\n        }\n        String expected = \"text/html\";\n        if (contentType == null) {\n            DefaultXMLNoteErrorHandler.warning(null, 90190, \"Returned content type for url.openConnection() is null\");\n            contentType = expected;\n        }\n        int index = contentType.indexOf(';');\n        if (index >= 0) {\n            contentType = contentType.substring(0, index).trim();\n        }\n        if (!contentType.equals(expected)) {\n            String msg = translator.translate(\"The content type of url '%s' is not '%s', it is '%s'\");\n            throw new BadDocumentException(String.format(msg, url.toString(), expected, contentType));\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        return fromHtml(in, encoding);\n    }\n", "code2": "    @Override\n    public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException {\n        String uniqueName = path.getBaseName();\n        URL url = buildURL(uniqueName);\n        URLContent content = new URLContent(url, this.getName(), uniqueName);\n        content.setUniqueName(uniqueName);\n        content.setReadable(true);\n        content.setWritable(writable);\n        content.setExists(true);\n        try {\n            URLConnection connection = url.openConnection();\n            String mimeType = connection.getContentType();\n            content.setMimeType(mimeType);\n            content.setWritable(true);\n        } catch (IOException ex) {\n            throw new ContentException(\"unable to obtain mime type of \" + url, ex);\n        }\n        return content;\n    }\n", "label": 0, "substitutes": {"fromHtml": [" fromHml", " fromChhtml", " fromPhtml", " fromPhttp", "fromChhtml", "fromShhtml", " fromHText", "fromPhHTML", "fromHttpHTML", "fromShtml", "fromHHTML", "fromChUrl", "fromHUrl", "fromHttpText", " fromHhtml", "fromChtml", "fromShUrl", " fromChUrl", "fromPhttp", "fromBushHTML", "fromHttp", " fromHHTML", "fromPhml", " fromHUrl", " fromHttp", "fromHText", "fromHml", "fromBushml", " fromChtml", "fromPhtml", "fromHttpml", "fromShText", "fromHttpUrl", "fromBushttp", " fromChText", "fromHttptml", " fromPhHTML", "fromHhtml", " fromPhml", "fromHttphtml", "fromHttpttp", "fromChText", "fromBushtml"], "url": ["resource", "il", "or", "ch", "string", "blog", "host", "xml", "http", "str", "service", "www", "input", "response", "URL", "path", "ur", "open", "api", "text", "Url", "email", "download", "object", "address", "loc", "lr", "browser", "l", "connection", "base", "domain", "server", "location", "config", "loader", "sl", "article", "cli", "link", "f", "image", "remote", "html", "ssl", "page", "obj", "r", "id", "web", "uri", "source", "client", "org", "name", "builder", "file", "ref"], "defaultEncoding": ["defaultChoding", "currentEnoded", "currentEnoding", "defaultencoded", "defaultEncoded", " defaultEncasing", "defaultEngoded", "defaultEnoded", "defaultCasing", "defaultEnode", "defaultEncasing", "defaultEngoder", "currentEncoding", "defaultEncode", " defaultCoder", "defaultChode", " defaultCoding", "defaultencoder", " defaultCoded", "defaultCoding", "defaultCoded", " defaultencoding", "defaultCoder", "currentEncasing", "defaultencoding", " defaultEncoded", "defaultEngoding", "defaultEnasing", " defaultCasing", " defaultencoded", "defaultChoded", "defaultEngasing", "defaultChasing", "currentEnode", " defaultencasing", " defaultEncoder", "defaultencode", "defaultEnoding", " defaultencoder", "defaultEnoder", "currentEncode", "defaultEncoder", "currentEncoded", "defaultencasing", "currentEnasing"], "overrideEncoding": ["overwriteEnasing", "overrideEnoded", "overwriteEncoded", "overwriteEnoded", "overrideencoded", "overrideEncoded", "overrideEnoder", "overrideCoded", "overrideencoding", "overrideEncoder", "overrideEnasing", "overwriteEncasing", "overrideCoding", "overwriteEncoder", "overrideEnoding", "overrideencoder", "overrideCasing", "overrideCoder", "overwriteEnoding", "overrideEncasing", "overrideencasing", "overwriteEncoding", "overwriteEnoder"], "conn": ["dc", "ch", "serv", "n", "c", "Connection", "act", "http", "Conn", "ann", "conv", "dn", "ctx", "con", "api", "open", "co", "sync", "ct", "client", "sql", "loc", "ad", "err", "l", "connection", "cn", "out", "cp", "cmd", "exec", "coll", "server", "reg", "config", "enc", "f", "cli", "session", "socket", "close", "cb", "ssl", "nt", "conf", "nc", "connect", "db"], "contentType": ["documentName", "ContentLength", "contentLength", "wordtype", "ontentName", "ContentPath", "documentInfo", "workToken", "contentLine", "contentFormat", "languageInfo", " contentName", "encLength", "worktype", "contentPath", " contentClass", "ontentPath", "resourceName", "documentText", "ContentUnit", "encToken", "resourcetype", "ontentFormat", "ContentFile", "workLength", "contentName", "ContentClass", " contentFile", "resourceUnit", "ontentType", "encType", "contentFile", "documentType", "filetype", "enctype", "inputUnit", "languagetype", "resourceInfo", "contentUnit", "codeType", "fileType", "wordType", " contenttype", "contentToken", "inputtype", " contentPath", "languageType", "contentInfo", "contentClass", "resourceType", " contentStyle", " contentToken", "workType", "ContentText", "ContentType", "filePath", "ContentFormat", "contentStyle", "Contenttype", "inputPath", "codetype", "ontentClass", "languageStyle", "fileFile", "inputType", "codeStyle", " contentText", "codeInfo", "resourceLength", "codeUnit", "codeFile", "codeName", "inputLine", " contentInfo", " contentLine", "contenttype", " contentFormat", "ontentLength", "contentText", " contentUnit", "ContentLine", "ContentInfo", "ContentName", "wordName", " contentLength"], "encoding": ["caching", "encaching", "encryption", "engosing", "enhasing", "colloded", "enoded", "collasing", " encode", " encapping", "encoder", "ecasing", "enosing", "ecoding", "execoder", "Encode", "Encryption", " encoder", "enhode", "Encasing", "ecoded", " encryption", "equoded", "engoded", "engoding", "coder", "colloder", "enhryption", "encoded", "execasing", "equoding", "colloding", "Encoded", "engoder", "equoder", "encode", "enoder", "equosing", "Encoding", "coding", "coded", "enhoding", "engapping", " encasing", "enaching", "casing", "engasing", "enoding", "equapping", "encapping", "Encaching", "Encoder", "encasing", "execoded", "encosing", "ecoder", "execoding", "enasing", " encosing"], "i": ["hi", "iu", "si", "qi", "ip", "u", "multi", "ini", "ii", "c", "pi", "o", "is", "area", "abi", "ci", "di", "io", "api", "slice", "ji", "ui", "ei", "ri", "bi", "ie", "p", "l", "phi", "init", "j", "I", "fi", "x", "eni", "f", "cli", "e", "oi", "li", "ori", "ni", "h", "gi", "v", "ti", "mi", "ai", "yi", "zi", "xi", "t", "id", "info", "uri", "ix", "mu", "adi", "lc"], "s": ["js", "si", "S", "ses", "u", "g", "string", "n", "m", "c", "o", "sym", "str", "d", "service", "gs", "as", "abs", "os", "details", "sync", "ins", "p", "fs", "l", "strings", "ls", "settings", "ws", "sl", "enc", "f", "sb", "e", "su", "session", "ns", "ds", "a", "h", "v", "ssl", "ts", "sg", "sv", "r", "ps", "en", "t", "es", "b", "source", "site", "ss"], "expected": ["allowed", "entry", "wrong", "pretty", " email", "current", "host", " accepted", " event", " expectation", " received", "failed", "seen", "response", "actual", "yet", " unexpected", " e", " ie", "force", "supported", "pected", "email", "opened", "ed", "provided", "latest", "ie", "default", "reported", "ception", "element", "event", "pecting", "updated", "now", "nexpected", "fake", "e", "acceptable", "illegal", "received", " Expect", " expecting", "example", "format", "next", "error", "type", "found", "forced", "style", " expects", "target", "handled", "needed", "required", "info", "pect", "specified", " expect", "encrypted"], "index": ["pull", "position", "ini", "current", "option", "condition", "Index", "input", "shape", "search", "open", "match", "edit", "key", "number", "slice", "list", "none", "num", "length", "active", "object", "address", "unit", "loc", "weight", "alpha", "pos", "all", "element", "prefix", "find", "width", "x", "where", "size", "array", "date", "value", "ind", "connect", "page", "level", "diff", "type", "output", "point", "inc", "id", "offset", "info", "update", "ix", "column", "version", "sort", "end"], "msg": ["ug", "ms", "g", "title", "str", "gs", " message", "desc", "log", "details", "mess", "doc", "printf", "agg", "mr", "mit", "err", "ag", "lang", "fg", "cmd", "reg", "dr", "ma", "Message", "Msg", "MS", "gm", "format", "gen", "error", "sg", "rr", "sim", "comm", "message", "info", "mt", "og", "text", "mid", "name", "reason"], "in": ["In", "inas", "fr", "ini", "c", "IN", "xml", "inner", "din", "bin", "input", "as", "con", "io", "ins", "impl", "inn", "p", "err", "connection", "win", "rin", "out", "dr", "gin", "read", "login", "reader", "data", "ax", "r", "b", "rx", "inc", "id", "buffer", "stream", "tin"]}}
{"id1": "11477906", "id2": "20375440", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["getDefaultParameters", "loadGlobalsettings", "loadGlobalParameters", "loaddefaultConfiguration", "loaddefaultParameters", "loadApplicationSettings", "getdefaultConfiguration", "getdefaultParameters", "getdefaultsettings", "loadDefaultConfiguration", "loadDefaultsettings", "loadApplicationParameters", "loaddefaultsettings", "loaddefaultSettings", "loadDefaultParameters", "getDefaultSettings", "loadApplicationsettings", "getdefaultSettings", "getDefaultsettings", "loadGlobalSettings", "loadGlobalConfiguration", "loadApplicationConfiguration", "getDefaultConfiguration"], "configFileName": ["configPlaceLocation", "configFILELocation", "configFileType", "configFilenameLocation", "configFullLocation", "fileFILEType", "fileFILETime", "configFILETime", "configFileUrl", "configFilesName", "fileFILELocation", "ConfigModuleUrl", "ConfigFileString", "fileFileType", "configFileLocation", "configModuleUrl", "configFilesType", "ConfigModuleLocation", "configModuleString", "fileFileName", "configModuleName", "fileFileTime", "configFullUrl", "configFilenameName", "ConfigFileLocation", "configFullName", "configPlaceName", "configFileTime", "fileFileLocation", "configPlaceString", "ConfigFileName", "configFilesTime", "configFilesLocation", "configPlaceUrl", "configFileString", "configModuleLocation", "configFullString", "ConfigModuleString", "configFilenameType", "ConfigModuleName", "configFILEType", "ConfigFileUrl", "fileFILEName", "configFILEName", "configFilenameTime"], "in": ["resource", "In", "pull", "pass", "pc", "plus", "again", "n", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "as", "log", "con", "this", "pin", "ins", "conn", "inn", "err", "it", "up", "init", "base", "url", "work", "config", "read", "f", "inside", "i", "nin", "a", "socket", "login", "ssl", "reader", "diff", "data", "r", "inc", "id", "source", "stream"], "out": ["timeout", "able", "again", "and", "string", "instance", "c", "o", "ex", "exp", "view", "d", "version", "bin", "Out", "copy", "log", "io", "outs", "this", "sync", "conn", "object", "user", "err", "it", "up", "default", "connection", "net", "s", "all", "prefix", "exec", "server", " back", "config", "f", "off", "set", " file", "password", "image", "lib", "socket", "writer", "to", "ext", "file", "output", "data", "ou", "write", "obj", "OUT", "point", "null", " output", "t", "inc", "error", "parent", "back", "client", "name", "one"]}}
{"id1": "397240", "id2": "1188100", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "15445861", "id2": "21999120", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "CopyFiles", "copyfile", " copyDirectory", "CopyDirectory", "copyFiles", "transferFiles", "transferDirectory", "copyDirectory", "CopyFile", "transferfile"], "srcFile": ["rcPlace", "rcFiles", "rcPath", " srcStream", "sourceFiles", "rcStream", "srcDir", "destDir", "rcFile", "supFile", "sourcefile", "rcDir", "rcDirectory", "supPath", "srcFiles", " srcDir", "ourcePlace", "rcfile", "srcfile", "ourceFile", " srcPlace", "srcDirectory", " srcfile", "srcTime", "destTime", "destDirectory", "srcStream", "srcPlace", "supStream", "sourceFile", "sourcePath", " srcPath", " srcTime", "sourceDirectory", " srcDirectory", "srcPath", "ourceTime", "ourcePath", "sourceDir", "rcTime", "supfile", " srcFiles"], "destFile": ["targetFile", "destPath", "tempFiles", "endTime", "sourcefile", " destDirectory", "vertFile", "destFilename", "endFilename", "targetPath", "inationFiles", "destfile", "destFiles", "stdFile", " destTime", "DestPath", " destFilename", "Destfile", "tempPath", "DestFile", "inationFile", "targetTime", "destTime", "destDirectory", "targetFilename", "vertFilename", "sourceFile", "inationFilename", " destFiles", "vertFiles", "tempFile", "sourceDirectory", "stdTime", "stdDirectory", "tempfile", "DestFilename", "inationPath", "endPath", "vertPath", "stdfile", "sourceTime", "endFile", "DestFiles", " destPath", " destfile"], "in": ["In", "or", "pull", "again", "serv", "ini", "IN", "m", "cin", "ex", "is", "din", "inner", "bin", "input", "as", "con", "io", "pin", "ins", "ac", "min", "inn", "kin", "up", "isin", "init", "win", "base", "rin", "url", "get", "gin", "read", "f", "inside", "i", "nin", "a", "image", "socket", "h", "login", "reader", "r", "b", "inc", "id", "source"], "out": ["pass", "line", "again", "n", "cache", "o", "exp", "ex", "inner", "bin", "Out", "io", "outs", "sync", "conn", "user", "err", "up", "net", "w", "base", "exec", "work", "gin", "other", "off", "by", "socket", "writer", "to", "ext", "output", "obj", "OUT", "inc", "parent", "client", "one", "file"], "buffer": ["position", "channel", "uffer", "limit", "pause", "input", "layer", "wave", "feed", "slice", "buf", "queue", "length", "address", "header", "batch", "document", "base", "phrase", "server", "url", "variable", "size", "read", "Buffer", "iter", "bytes", "border", "result", "memory", "transfer", "reader", "reference", "data", "null", "b", "buff", "flush", "offset", "binary", "source", "block", "padding"], "no": [" lo", "so", "zero", " NO", "o", "go", "No", "ko", "was", "na", " none", "io", "co", "from", "number", "none", "only", "os", "wa", "num", "maybe", " mo", "nor", "nr", "nos", "eno", "pos", "nothing", "x", " number", "ino", "index", "NO", "size", "i", "off", "auto", "to", "lo", "nt", "error", "data", "type", "po", "yes", "id", "info", "which", "mo"]}}
{"id1": "13946197", "id2": "14691829", "code1": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 1, "substitutes": {"transformByMD5": [" transformWithM3", " transformByMD4", " transformWithM5", " transformWithMD3", " transformByM4", " transformWithMD4", " transformByMSecret", " transformByMC3", " transformByMC4", " transformByMD3", " transformWithMDSecret", " transformByM5", " transformBymd4", " transformBymdSecret", " transformWithMD5", " transformWithMSecret", " transformByMC5", " transformByM3", " transformWithM4", " transformByMCSecret", " transformBymd3", " transformByMDSecret", " transformBymd5"], "password": ["resource", "attribute", "token", "username", "sword", "string", "channel", "word", "secret", "Password", "PASS", "wallet", "path", "params", " passwords", "auth", "database", "email", "wd", "user", "object", "address", "p", " Password", "connection", "device", "prefix", "phrase", "config", "filename", "hash", "login", "data", "account", "message", "pattern", "source", "crypt", "text", "name", "padding"], "md5": ["mand2", "mdql", "mand5", "MD2", "amd512", "MD5", "material5", " MD3", "MDql", "MDfive", "mand55", " mddown", "mdok", "MDok", "mddown", "md2", " MD45", "mandse", "materialfive", "MDdown", " mdok", "material2", "md4", " md4", "mdse", " md2", " MD5", " mdse", "amd3", " mdfive", "mand45", " MDdown", " MD4", "mand4", " mdql", "md55", " MDok", " MD55", "md512", "mand3", " md512", "MDse", "MD512", "MD3", "amd2", " md55", "md3", "md45", "mdfive", "materialql", "amd5", " md3", " md45"], "output": ["property", "resource", "exit", "full", "string", "word", "o", "secret", "character", "response", "input", "outer", "display", "sequence", "queue", "letter", "address", "unit", "generation", "document", "out", "prefix", "config", "complete", "array", "foo", "hidden", "image", "format", "dot", "page", "result", "data", "write", "written", "style", "beta", "target", "message", "offset", "buffer", "generated", "text", "console", "reason", "width", "Output", "reference"], "bufferPass": ["bufferLink", "bufLink", "bufferScan", "bufComp", "bufferComp", " bufferCopy", "bufPack", " bufferFeed", "bufferPack", " bufferLink", "bufferpass", "BufferFeed", "BufferLink", "bufLine", "bufPass", "bufferCopy", "BufferPass", " bufferLine", "bufPush", "ufferCopy", "bufferPush", "ufferFeed", "bufScan", " bufferPack", "bufFeed", "BufferComp", "bufpass", " bufferpass", "ufferPass", "ufferPush", "Bufferpass", "ufferPack", " bufferComp", " bufferScan", "ufferLine", "bufferFeed", "bufCopy", "bufferLine", "ufferScan", " bufferPush"], "b": [" eb", "line", "u", "B", "k", "c", "n", "ob", "bs", "y", "d", "be", " a", "ab", "orb", "eb", "bi", "p", "br", "abb", "lb", "l", "bl", "w", "base", "s", "url", "x", "sb", "f", "e", "i", "a", "h", "cb", "bytes", "v", "bb", "obj", "r", "fb", "t", "ba", "null", "bf", "binary", "buffer", "wb", "body", "rb", "db"]}}
{"id1": "10361370", "id2": "16820041", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "label": 1, "substitutes": {"hash": ["render", "shadow", "cache", "Hash", "fill", "comment", "sha", "sum", "match", "hex", "key", "header", "build", "dh", "ash", "index", "dump", "password", "ashing", "check", "h", "html", "sign", "update", "crypt", "block", "version"], "saltBefore": ["saultHead", "singALTBefore", "sultBefore", "sultStart", "isaultFrom", "sultHead", "singALTAfter", "sintBefore", "seedAbove", "sertBefore", "saltStart", "sertStart", "sintFrom", "saultStart", "singaltAfter", "sALTStart", "isaltStart", "isaultHead", "saultFrom", "isaultStart", "sALTBefore", "sALTAfter", "sertAbove", "seedAfter", "isaltHead", "seedStart", "sintStart", "saltHead", "singaltAbove", "sertAfter", "saltAbove", "isaultBefore", "singALTAbove", "singaltStart", "saltFrom", "saultBefore", "sALTAbove", "singaltBefore", "isaltFrom", "sultFrom", "isaltBefore", "sintHead", "singALTStart", "seedBefore"], "content": ["resource", "temp", "media", "section", "entity", "string", "cache", "word", "method", "xml", "expression", "str", "character", "script", "comment", "input", "cont", "sequence", "json", "length", "music", "address", "object", "header", "creator", "document", "model", "Content", "url", "size", "code", "value", "password", "filename", "image", "format", "output", "data", "raw", "message", "pattern", "source", "stream", "text", "body", "buffer", "version", "parent"], "saltAfter": ["singALTBefore", "singaltAround", "sALTExtra", "singALTAfter", "sALTafter", " saltExtra", " sALTBefore", "sintBefore", "saltafter", "sertBefore", "singaltEnd", "singaltAfter", " sALTAfter", "sertAround", "saultafter", "sintafter", "sALTBefore", "sALTAfter", " sALTExtra", "sintAfter", "sintExtra", "singALTEnd", " sALTafter", "saltAround", "saltedAfter", "sertEnd", "sertAfter", "singALTAround", "saultBefore", "singaltBefore", "saltExtra", "saltedBefore", "saultExtra", "saltedAround", "saultAfter", "sALTEnd", "sALTAround", "saltEnd", " saltafter", "saltedEnd"], "repeatedHashingCount": ["repeatedHashedcount", "repeatedChashesNumber", "repeatedHashedNumber", "repeatedShashLength", "repeatedHashingcount", "repeatedChashescount", "repeatedHatingCounter", "repeatedShashingCode", "repeatedHashingCounter", "repeatedHumpingCount", "repeatedShashingLength", "repeatedHashingCode", "repeatedHumpingcount", "repeatedHumpingNumber", "repeatedHashesType", "repeatedChashingcount", "repeatedChashesType", "repeatedHashesCount", "repeatedHumpingType", "repeatedShashingCount", "repeatedHashesCounter", "repeatedChashingNumber", "repeatedChashesCount", "repeatedHashedType", "repeatedHashedCount", "repeatedShashCount", "repeatedHatingCount", "repeatedShashCode", "repeatedHashesNumber", "repeatedShashCounter", "repeatedChashingCount", "repeatedHashesCode", "repeatedHashCounter", "repeatedHashCount", "repeatedHashingLength", "repeatedHatingLength", "repeatedHashingNumber", "repeatedHashesLength", "repeatedChashingType", "repeatedHashLength", "repeatedHashingType", "repeatedHashescount", "repeatedShashingCounter", "repeatedHashCode", "repeatedHatingCode"], "digest": ["Diggest", "ngest", " Diger", "signEST", "hexString", "ngested", "mixested", "hashString", "digator", "finester", "logest", "Digator", " Digester", "hashest", " diger", "digusher", "nger", " digator", " digests", "Digester", " digusher", "Digested", "signest", " digger", "digested", " digEST", "digester", " Digator", "mixester", "Digusher", "finests", "DigEST", " digester", "DigString", " digested", "validest", "hexests", "generest", "signester", "mixusher", "finested", " diggest", "valider", "hashests", "mixest", "logester", "digEST", "generester", "finest", "Diger", "diger", " Digest", "Digger", "validested", "generested", "diggest", "signested", "ngester", "Digests", "digger", "hexest", "digests", "hexested", "loger", "Digest", "hashested", "loggest", "validester", "digString", "generests", "signger"], "digestLength": ["digestinglength", "Digestlength", "digestingLen", "digestsType", "digestLen", "DigesterLen", " digesterLen", "digestedLength", "DigestLen", " digestlength", "digestlength", " digesterlength", "DigestLength", "digesterLen", " digestType", "digesterlength", "digestedlength", "digestingLength", "DigesterLength", "Digesterlength", "digestsLength", "digesterType", "digestsLen", "digestingType", "digesterLength", " digesterLength", "digestslength", "digestType", " digesterType", " digestLen", "digestedLen"], "i": ["iu", "si", "qi", "chi", "u", "multi", "n", "ii", "c", "k", "pi", "ini", "o", "d", "ci", "di", "io", "api", "slice", "ui", "ri", "length", "bi", "count", "p", "ami", "l", "phi", "s", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "anti", "start", "h", "v", "gi", "ti", "wei", "ai", "b", "xi", "t", "id", "zi", "info", "uri", "mu", "lc"]}}
{"id1": "19113613", "id2": "20019847", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copy": ["Cop", "share", "cop", "paste", "cat", "zip", "rm", "Copy", "move", "process", "sync", "download", "opy", "archive", "p", "replace", "cp", "upload", "clone", "delete", "get", "load", " cp", "split", "transfer", "change", "save", "type", "write", "clip", "put", "update", "ssh", "create"], "in": ["In", "token", "again", "project", "n", "c", "ini", "IN", "cin", "inner", "din", "bin", "input", "old", "ic", "as", "this", "pin", "ins", "on", "min", "inn", "kin", "part", "init", "base", "win", "lin", "connection", "url", "get", "work", "config", "thin", "f", "index", "inside", "i", "image", "a", "sin", "login", "reader", "diff", "data", "plugin", "inc", "id", "update", "client", "name"], "out": ["resource", "group", "root", "external", "line", "again", "project", "at", "n", "c", "cache", "outside", "o", "ex", "call", "option", "version", "bin", "with", "Out", "self", "input", "outer", "path", "io", "outs", "this", "conn", "object", "no", "user", "p", "err", "goal", "up", "app", "connection", "net", "base", "part", "init", "exec", "work", "x", "other", "off", "image", "dot", "remote", "ext", "page", "v", "output", "obj", "OUT", "b", "vert", "null", "inc", "point", "parent", "client", "block", "name", "one"], "source": ["resource", "attribute", "route", "class", "subject", "use", "username", "status", "project", "position", "site", "Source", "view", "secret", "proxy", "service", "scope", "ource", "family", "from", "force", "dest", "ce", "unit", "missing", "base", "pe", "prefix", "url", "component", "size", "iter", "feature", "internal", "SOURCE", "format", "sin", "reference", "secure", "direction", "type", "alt", "id", "parent", "uri", "src", "name", "origin"], "target": ["resource", "wrong", "root", "route", "token", "project", "cat", "current", "host", "site", "service", "about", "path", "tail", "force", "dest", "arget", "origin", "address", "alias", "goal", "base", "prefix", "url", "component", "config", "detail", "value", "home", "top", "format", "Target", "reference", "output", "direction", "next", "alt", "null", "point", "pattern", "parent", "master", "src", "name", "template"], "files": ["pages", "names", "classes", "resources", "lines", "apps", "results", "images", "tools", "sections", "objects", "ins", "groups", "plugins", "fs", "obs", "s", "cells", "ls", "keys", "ports", "f", "children", "ions", "blocks", "filename", "links", "features", "flows", "data", "items", "docs", "Files", "iles", "users", "jobs", "assets", "models"], "file": ["File", "resource", " File", "entry", "item", "folder", "live", "fe", "local", "line", "entity", "function", "string", "current", "le", "layer", "path", "feed", "object", "child", "dir", "letter", "single", "unit", "it", "l", "part", "base", "future", "url", "load", "f", "FILE", "per", "e", "filename", "el", "lib", "fp", "page", "directory", "data", "b", "id", "parent", "uri", "ile", "binary", "name"], "inCh": ["outch", "inch", "outChannel", " inch", " inChannel", "InChan", "Inch", " inCH", "inCH", "INChannel", "inChan", "INChan", "outChan", "inChannel", "outCH", "INCH", "InCh", "InChannel", " inChan", "InCH", "INCh"], "outCh": ["outch", "inch", "OutCh", "outChannel", " outCH", "OutChannel", "OutCH", "outputch", " outChannel", "outputChan", "Outch", "inCH", "inChan", "outputCH", "outChan", "OutChan", "inChannel", "outCH", "outputCh", " outch"]}}
{"id1": "15797402", "id2": "6501291", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"parse": [" transform", "wrap", "processing", "pc", "scan", " rewrite", "request", "view", "xml", "http", "cover", "service", "transform", "report", "patch", "process", " split", "print", " parsing", "rate", "replace", " parser", "fork", "Parser", " serve", "load", "read", "php", " analyse", "arse", "set", "worker", "split", " dispatch", "handle", "apply", "se", " convert", "save", "raw", " process", "pack", "parser"], "stream": ["resource", "temp", "draw", "channel", "view", "http", "inner", "src", "input", "response", "down", "feed", "in", "download", "content", "iterator", "sample", "video", "document", "Stream", "upload", "server", "url", "load", "loader", "read", "image", "through", "writer", "handle", "remote", "reader", "data", "raw", "stack", "message", "source", "client", "form", "file"], "handler": ["application", "function", "channel", "host", "pointer", "phase", "service", "response", "layer", "manager", "ctx", "di", "driver", "hand", "Handler", "default", "connection", "base", "event", "server", "loader", "processor", "controller", "wrapper", "writer", "format", "handle", "h", "reader", "data", "handled", "parser", "info", "parent", "client", "collection", "monitor"], "metadata": ["property", "resource", "attribute", "subject", "map", "management", "mx", "m", "xml", "state", "manager", "ctx", "params", "di", "meta", "database", "json", "properties", "content", "header", "runtime", "document", "metry", "connection", "storage", "component", "config", "processor", "adata", "material", "directory", "managed", "data", "mi", "mon", "md", "module", "plugin", "parser", "message", "info", "mt", "uri", "source", "collection", "met", "monitor", "template"], "context": ["resource", "txt", "entry", " Context", "subject", "cmp", "instance", "Context", "environment", "method", "request", "xml", "proxy", "scope", "concept", "manager", "ctx", "content", " contexts", "object", "translation", "command", "document", "mc", "connection", "element", "event", "component", "system", "config", "processor", "tx", "reader", "data", "kernel", "message", "parent", "text", "collection"], "name": ["Name", "names", "resource", "action", "large", "route", "class", "full", "n", "string", "m", "word", "call", "version", "comment", "named", "old", "time", "path", "label", "search", "api", "key", "none", "sync", "in", "active", "on", "no", "object", "address", "child", "missing", "default", "part", "base", "connection", "prefix", "model", "url", "work", "size", "code", "filename", "image", "ame", "NAME", "type", "data", "null", "id", "message", "job", "source", "alias", "file", "common"], "out": ["resource", "temp", "window", "line", "again", "instance", "channel", "o", "ex", "ray", "exp", "bin", "Out", "copy", "path", "manager", "io", "outs", "sync", "in", "object", "conn", "child", "user", "err", "connection", "server", "url", "cos", "pool", "image", "lib", "socket", "writer", "plain", "result", "page", "ext", "output", "data", "obj", "OUT", "null", "flush", "source", "client", "builder", "file", "extra"]}}
{"id1": "13596891", "id2": "1598693", "code1": "    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n        String szUrl = request.getParameter(\"url\");\n        System.out.println(szUrl);\n        URL url;\n        InputStream is = null;\n        ServletOutputStream sout = null;\n        try {\n            url = new URL(szUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            Enumeration hNames = request.getHeaderNames();\n            while (hNames.hasMoreElements()) {\n                String txt = hNames.nextElement().toString();\n                con.setRequestProperty(txt, request.getHeader(txt));\n            }\n            con.setRequestProperty(\"host\", url.getHost());\n            con.setRequestProperty(\"refer\", szUrl);\n            con.setRequestMethod(method);\n            con.setDoOutput(true);\n            con.setDoInput(true);\n            InputStreamReader inBody = new InputStreamReader(request.getInputStream());\n            char bufCh[] = new char[1024];\n            int r;\n            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());\n            while ((r = inBody.read(bufCh)) != -1) {\n                System.out.println(bufCh);\n                outReq.write(bufCh, 0, r);\n            }\n            outReq.flush();\n            outReq.close();\n            inBody.close();\n            System.out.println(con.getResponseCode());\n            System.out.println(con.getResponseMessage());\n            if (con.getResponseCode() == con.HTTP_OK) {\n                response.setContentType(con.getContentType());\n                response.addHeader(\"Content-Encoding\", con.getContentEncoding());\n                sout = response.getOutputStream();\n                is = con.getInputStream();\n                byte buff[] = new byte[1024];\n                while ((r = is.read(buff)) != -1) {\n                    sout.write(buff, 0, r);\n                    System.out.print(buff);\n                }\n                sout.flush();\n                is.close();\n                sout.close();\n            } else {\n                response.sendError(con.getResponseCode(), con.getResponseMessage());\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String retrieveData(URL url) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setRequestProperty(\"User-agent\", \"MZmine 2\");\n        InputStream is = connection.getInputStream();\n        if (is == null) {\n            throw new IOException(\"Could not establish a connection to \" + url);\n        }\n        StringBuffer buffer = new StringBuffer();\n        try {\n            InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n            char[] cb = new char[1024];\n            int amtRead = reader.read(cb);\n            while (amtRead > 0) {\n                buffer.append(cb, 0, amtRead);\n                amtRead = reader.read(cb);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        is.close();\n        return buffer.toString();\n    }\n", "label": 0, "substitutes": {"doTransfer": ["handleImport", " doSend", "makeRequest", "doImport", "makeImport", " doRequest", "doRequest", "doSend", "handleSend", "makeTransfer", " doImport", "handleTransfer", "handleRequest", "makeSend"], "request": ["resource", "application", "requ", "subject", "position", "instance", "current", "context", "http", "Request", "xml", "condition", "input", "time", "report", "queue", "this", "post", "enter", "in", "form", "object", "user", "command", "connection", "model", "event", "server", "query", "config", "complete", "session", "q", "received", "record", "remote", "result", "reader", "data", "type", "req", "QUEST", "message", "com", "stream", "client", "re", "version", "create", "rf"], "response": ["Response", "resource", "application", "status", "serv", "full", "respond", "cache", "site", "reply", "http", "results", "view", "version", "cover", "service", "call", "report", "onse", "json", "warning", "content", "object", "header", "default", "resp", "connection", "document", "out", "event", "model", "server", " Response", "index", "session", "success", "image", "writer", "res", "remote", "result", "page", "next", "output", "error", "en", "message", "client", "body", "re"], "method": ["property", "resource", "pull", "status", "route", "class", "subject", "use", "send", "description", "position", "string", "call", "hod", "time", "path", "process", "json", "content", "mode", "verb", "command", "cmd", "prefix", "date", "session", "head", "callback", "format", "METHOD", "direction", "type", "term", "sign", "message", "text", "version", "reason", "sort", "Method"], "servletContext": ["servLETContext", "ServletConfig", "ServletController", "servleConfig", "ServletsConfig", "servlexConfig", "servlexcontext", " servletCurrent", "servLETCurrent", "servApplicationcontext", " servantCurrent", "servletConfig", "servantConfig", "Servletcontext", "Servletscontext", "ServletsController", "servApplicationConfig", "servantCurrent", " servletProvider", " servantConfig", "servletCurrent", "servletsContext", "servantProvider", " servletConfig", "servletProvider", "servLETConfig", "servantContext", " servantProvider", "ServletsContext", "servApplicationController", "servApplicationContext", "servletcontext", "servletsController", "ServletContext", "servletController", "servlexController", "servLETProvider", "servlexContext", "servleCurrent", "servleContext", " servantContext", "servleProvider", "servletscontext", "servletsConfig"], "wac": ["wsae", "wae", " wae", " Wacs", " WAC", "wsAC", " Wac", " wacs", "wacs", "wAC", "wsacs", " wAC", "wsac", " Wae"], "szUrl": ["asizUrl", "szenFolder", "sizFolder", "asizurl", "szUr", "szURL", "sizurl", "sizFrame", "asizUr", "szenurl", "sziurl", "szaURL", "szeurl", " sizURL", "szerURL", "sizPath", "sziUr", " szURL", "szerUr", "sznURL", "asizFrame", "asizURL", "aszURL", "szFrame", "sznUrl", "szaPath", "szerUrl", "szeFolder", "sziURL", "szeUrl", " szFolder", "szenURL", "sznPath", "szenUrl", "sziUrl", " szurl", "szPath", "sznUr", " sizUrl", "szaUrl", "aszUrl", "szerFrame", "szeUr", "szeFrame", " sizurl", "aszurl", "sizURL", "szeURL", " sizFolder", "sizUr", "asizPath", "szaUr", "sizUrl", "sznurl", "szFolder", "aszFrame", "szurl", "aszUr", "aszPath"], "url": ["resource", "il", "cloud", "stream", "string", "host", "context", "xml", "http", "service", "www", "URL", "log", "ll", "ur", "org", "gl", "key", "Url", "rl", "impl", "conn", "user", "loc", "rel", "lb", "l", "connection", "base", "event", "server", "location", "get", "config", "sl", "f", " URL", "li", "ul", "el", "socket", "page", "ssl", "fl", "obj", "web", "uri", "source", "client", "buffer", "re", "name", "file"], "is": ["ib", "il", "us", "ip", "isa", "serv", "im", "ios", "ii", "isl", "bs", "ir", "was", "oss", "isf", "ci", "as", "has", " isn", "io", "ais", "os", "IS", "cms", "ri", " are", "it", "Is", "rc", "iss", "iso", "x", "isi", "isc", "i", "bis", "lis", "ai", "isu", "ils", "web", "info", " bis", "uri", "rx", "src", "ris"], "sout": ["Sout", " sOUT", "souts", " sin", "Sdata", "Sin", "sdata", " sOut", " sdata", "Souts", "sOut", "SOut", " souts", "sin", "sOUT", "SOUT"], "con": ["fe", "ctrl", "pc", "status", "subject", "Connection", "m", "ca", "view", "http", "can", "ct", "l", "ren", "don", "ssl", "gen", "ec", "general", "ver", "const", "version", "lc", "fa", "c", "cache", "fun", "xc", "pin", "user", "Common", "single", "cc", "cl", "connection", "win", "cn", "cp", "ocon", "cur", "pre", "login", "en", "conf", "nc", "connect", "re", "conv", "ctx", "open", "co", "util", "cf", "min", "net", "rc", "coll", "query", "wan", "get", "cos", "Con", "uc", "author", "type", "web", "client", "com", "run", "fc", "cons", "Internal", "func", "java", "wa", "ran", "conn", "on", "C", "event", "exec", "server", "syn", "bc", "non", "crit", "CON", "internal", "un", "close", "remote", "inc", "pen", "san", "core", "common"], "hNames": ["HBlocks", "ihName", "hFiles", "hostNames", "hVs", "HVs", "hostTypes", "hrKeys", " hKeys", "HNames", " hFiles", " hNs", " hBlocks", "hrName", " hVs", "hKeys", "hrNs", "ihBlocks", "HTypes", "hrNames", "HName", "ihNames", "hNs", "hTypes", " hTypes", " hName", "ihVs", "HFiles", "hostKeys", "hrTypes", "hBlocks", "hrFiles", "hostNs", "hName"], "txt": ["struct", "xt", "lt", "wt", "section", "zip", "Text", "py", "str", "wx", "fx", "ctx", "inet", "key", "text", "in", "ct", "ht", "header", "xxx", "XT", "csv", "qt", "phrase", "dt", "gt", "lv", "value", "q", "gz", "tx", "cb", "fp", "v", "kt", "nt", "nm", "gi", "TEXT", "elt", "obj", "rr", "jp", "rx", " text", "t", "sv", "prot", "git", "htm", "tin", "bt", "utt", "et", "name", "binary", "vt"], "inBody": ["INReader", "inbody", "insReader", " inbody", "INFile", "INBody", "InReader", "outBody", "outbody", "Inbody", "INStream", "InBody", " inStream", "inReader", "inStream", "outStream", "insFile", "insStream", "InFile", "inFile", " inFile", "outFile", " inReader", "INbody", "InStream", "insBody"], "bufCh": ["queueCol", "bufferCh", "queuech", "bufferch", "bufferCH", "ufch", " bufCol", " bufChar", "queueCH", "bufC", "buffCh", "ufCol", "ufChar", "ufCH", "bufch", "bufChar", "buffch", "bufCH", " bufC", "ufC", " bufch", "ufCh", "buffC", "bufCol", " bufCH", "queueCh", "buffCH", "bufferChar"], "r": ["rg", "u", "k", "c", "R", "pr", "ru", "m", "rh", "g", "n", "d", "str", "ner", "sr", "rt", "rl", "ri", "nr", "er", "lr", "p", "br", "cr", "err", "w", "rc", "ar", " rg", "reg", "x", "f", "ror", "e", "rw", "i", "q", "res", "result", "v", "range", "reader", "hr", "rr", "b", "rs", "rd", "re", "rb", "fr", "rf"], "outReq": ["outSeck", " outReck", "outDeq", "outRece", " outRce", "outREque", " outSeque", " outReh", " outRq", "outRecce", " outRsque", "outSequest", " outEq", "outRck", " outRereq", "outEck", "outReck", "outRq", "outReh", "outSece", " outEreq", " outEque", " outSeck", "outRsq", "outREh", "outConh", "outConce", "outRecreq", "outEq", " outRequest", "outRsque", " outRsce", "outDeque", "outRreq", " outEck", " outSece", "outRquest", "outRereq", "outEque", " outRquest", " outRece", "outREce", "outRque", " outRque", "outRecck", "outRsce", "outConq", "outDequest", "outRecq", "outReque", "outRequest", " outRsh", "outSeq", " outReque", "outRce", "outREck", "outConque", "outEreq", "outRecque", "outRsh", " outRsq", " outSeq", "outSeque", "outREq", "outDece"], "buff": ["Ptr", "ch", " Buffer", "map", "lines", " chunk", "Pad", "buf", "num", "p", " buffers", "array", "Buffer", "f", " Buff", "Msg", "uf", "bb", "data", "Buff", "b", "Info", "info", "buffer", "file"]}}
{"id1": "14794404", "id2": "19206412", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["encryptSecret", "EncipherPassword", "EncryptPassword", "encryptString", "encryptedpassword", "EncipherSecret", "Encryptpassword", "encipherSecret", "EncipherString", "encressString", "encryptpassword", "encressPassword", "encipherPassword", "Encipherpassword", "encressSecret", "encipherString", "encresspassword", "EncryptSecret", "EncryptString", "encipherpassword", "encryptedSecret", "encryptedString"], "password": ["resource", "pass", "attribute", "token", "username", "words", "sword", "description", "string", "cache", "channel", "word", "secret", "input", "Password", "PASS", "path", "params", " passwords", "database", "email", "wd", "content", "object", "address", "p", "connection", "device", "prefix", "phrase", "definition", "array", "enc", "data", "message", "pattern", "buffer", "crypt", "text", "name", "padding"], "encryptedPassword": [" encryptedpassword", "ryptedpassword", "lockedPassword", "encryptedpassword", "protectedpassword", "protectedPass", "encryptedCode", "ryptedPass", " encryptedCode", "protectedCode", "ryptedPassword", "ryptedString", " encryptedPass", "lockedPass", "encryptedPass", "lockedpassword", " encryptedString", "ryptedCode", "protectedString", "encryptedString", "protectedPassword", "lockedString"], "md5": ["MD2", "MD5", "MD6", " MD3", " mddown", " md6", "mddown", "md2", " md3", "MDdown", "dig45", "dig4", " md4", "md4", "dig5", " md2", " MD5", "dig3", "md6", "amd6", "amd4", "MD45", "md512", "MD4", " MD2", " md512", "MD512", "amd2", "md45", "md3", "dig2", " MD512", "MD3", "amd5", "digdown", " md45"], "digest": ["mdment", "mdash", "encment", "Digace", "mdest", " digher", " digests", "Digester", "mdested", "Digested", "signest", "digested", "digester", "digace", "digenge", " digester", "Digenge", "Digher", "signester", "digment", "mdests", "mdace", " digash", "signests", " digenge", "signested", " digace", "Digests", "mdenge", "mdester", "digests", "mdher", "Digest", "encester", "digash", " digment", "digher", "encash", "encest"], "i": ["hi", "si", "qi", "ip", "u", "multi", "k", "ii", "c", "pi", "o", "d", "ci", "di", "io", "ui", "length", "ri", "bi", "ie", "p", "it", "l", "phi", "s", "j", "I", "x", "index", "f", "e", "oi", "li", "h", "v", "gi", "ti", "ai", "r", "b", "zi", "t", "id", "xi", "uri", "ix"], "hex": ["temp", "ctr", "ip", "nexus", "zip", "string", "utf", "rh", "ex", "exp", "ix", "shift", "str", "pixel", "bin", "stick", "di", "bits", "char", "none", "bit", "slice", "num", "length", "coord", "letter", "lit", "alpha", "oct", "prefix", "pex", "mix", "enc", "comp", "serial", "rex", "sex", "hash", "check", "closure", "ext", "data", "digit", "null", "pack", "buff", "id", "pattern", "sign", "binary", "text"]}}
{"id1": "13012591", "id2": "14865947", "code1": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "code2": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"getPasswordHash": ["getPasswordhash", "getHashSum", " getPasswordSum", " getPasswordSecret", "getHashHash", "getPasswordSecret", "getStringhash", "getPasswordSum", "getpasswordHash", " getPasswordhash", " getpasswordHash", "getStringSum", "getStringHash", "getpasswordhash", "getHashSecret", " getpasswordhash", "getpasswordSum", "getpasswordSecret", "getStringSecret", "getHashhash", " getpasswordSum", " getpasswordSecret"], "password": ["pass", "attribute", "token", "username", "words", "sword", "string", "cache", "word", "secret", "input", "Password", "PASS", "path", "key", "number", " passwords", "auth", "database", "email", "wd", "user", "content", "address", "p", "prefix", "phrase", "security", "config", "array", "confirmed", "code", "data", "account", "message", "pattern", "buffer", "crypt", "text", "source", "name", "padding"], "md": ["dc", "mb", "mg", "mp", "pd", "mage", "pm", "ms", "od", "mand", "cm", "mac", "map", "m", "mem", "sm", " MD", "d", "sha", "hm", "MD", "bd", "meta", "alg", "hd", "ad", "dd", "ld", "mc", "amp", "gb", "mod", "cmd", "dh", "dr", "ma", "mag", "pkg", "arm", "gd", "gm", "dm", "material", "nm", "amd", "dig", "mm", "metadata", "vd", "mt", "mu", "bm", "db", "mo"], "hash": ["body", "row", "mask", "bh", "hed", "sh", "mac", "cache", "map", "Hash", "host", "secret", "total", "cover", "sha", "sum", "search", "match", "hex", "key", "number", "ashes", "length", "address", "square", "header", "kh", "build", "count", "batch", "carry", "ha", "url", "query", "ash", "array", "index", "code", "image", "h", "check", "dot", "html", "filter", "handle", "diff", "error", "data", "dig", "message", "block"], "buf": ["bh", "nb", "aux", " buffer", "cas", "pb", "cv", "bin", "src", "conv", "abi", "ctx", "abs", "box", "pad", "cf", "bp", "ab", "book", "br", "bag", "ff", "tmp", "bc", "sb", "Buffer", "f", "array", "af", "pkg", "home", "uf", "cap", "h", "cb", "fp", "v", "bb", "img", "data", "Buff", "b", "fb", "buff", "bf", "buffer", "va", "rb", "db", "ref"], "i": ["hi", "si", "chi", "qi", "ip", "u", "multi", "k", "c", "ii", "m", "pi", "o", "d", "abi", "ci", "di", "io", "vi", "ui", "ji", "ri", "length", "bi", "p", "it", "l", "phi", "s", "j", "I", "eni", "x", "uli", "fi", "index", "f", "field", "e", "oi", "li", "h", "v", "gi", "ti", "data", "ai", "r", "b", "xi", "t", "id", "uri", "mu", "end"]}}
{"id1": "14773782", "id2": "1598693", "code1": "    public void testJPEGRaster() throws MalformedURLException, IOException {\n        System.out.println(\"JPEGCodec RasterImage:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            JPEGImageDecoder dec = JPEGCodec.createJPEGDecoder(istream);\n            Raster raster = dec.decodeAsRaster();\n            int width = raster.getWidth();\n            int height = raster.getHeight();\n            istream.close();\n            System.out.println(\"w: \" + width + \" - h: \" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    public static String retrieveData(URL url) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setRequestProperty(\"User-agent\", \"MZmine 2\");\n        InputStream is = connection.getInputStream();\n        if (is == null) {\n            throw new IOException(\"Could not establish a connection to \" + url);\n        }\n        StringBuffer buffer = new StringBuffer();\n        try {\n            InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n            char[] cb = new char[1024];\n            int amtRead = reader.read(cb);\n            while (amtRead > 0) {\n                buffer.append(cb, 0, amtRead);\n                amtRead = reader.read(cb);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        is.close();\n        return buffer.toString();\n    }\n", "label": 0, "substitutes": {"testJPEGRaster": [" testJPPGrast", " testJPEGraster", " testJPEGRotatter", " testJPPGratter", " testJPEGWast", " testJPEGWasters", " testJPEGWatter", " testJPEGRatter", " testJPPGRasters", " testJPPGraster", " testJPEGWaster", " testJPPGrasters", " testJPPGRast", " testJPEGratter", " testJPEGrast", " testJPEGRotasters", " testJPEGRotast", " testJPEGRasters", " testJPPGRatter", " testJPEGRast", " testJPPGRaster", " testJPEGrasters", " testJPEGRotaster"], "IOException": ["IPException", " IOError", "OSError", " IOception", "IOError", "OSception", "IPError", "IOception", "OSException", "IPception"], "start": ["ish", "stage", "started", "use", "speed", "Start", "step", "shift", "sum", "time", "delay", "from", "first", "in", "length", "min", "scale", "order", "pos", "init", "base", "get", "load", "left", "size", "f", "date", "set", "pre", "diff", "data", "style", "starting", "id", "offset", "source", "info", "art", "end"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "ini", "ii", "c", "m", "pi", "inner", "abi", "ci", "di", "io", "key", "slice", "ui", "ri", "bi", "ie", "p", "l", "phi", "j", "I", "fi", "eni", "x", "index", "f", "e", "oi", "li", "image", "ni", "v", "gi", "ti", "mi", "ai", "yi", "zi", "b", "xi", "id", "info", "ix", "uni"], "url": ["resource", "route", "string", "channel", "href", "http", "www", "URL", "path", "ur", "feed", "org", "in", "Url", "download", "address", "l", "connection", "base", "ls", "location", "config", "sl", "f", "hub", "filename", "image", "file", "page", "img", "data", "fb", "id", "web", "uri", "source", "src", "name", "album", "ref"], "istream": ["istsstream", "isteep", "step", "instep", "ishore", "isream", "isead", "ISTrib", "ishream", "ISTream", "stagram", "ISTstream", "isep", "irstream", "irstREAM", "ISTep", "irstore", "istsrib", "istsound", "istestream", "instream", "istREAM", "iststream", "instagram", "instead", "irstound", "istagram", "istore", "istrib", "istsREAM", "istsep", "ishound", "istead", "isagram", "istound", "istsore", "istep", "ishREAM", "isterib", "isteream", "stream", "stead", "istsream"], "dec": ["dc", "DEC", "draw", "vec", " decode", "c", "rec", "exp", "oder", "deg", "func", "da", "desc", "doc", " DEC", "div", "dir", "ra", "valid", "s", "decl", "out", "sec", "enc", "code", "director", "des", "cam", "der", " Dec", "img", "Dec", "data", "dig", "next", "r", "de", "inc", "ec", "rev", "neg", "ode", "fr"], "raster": [" ratter", "eratter", "Rasters", "araster", "rasters", "eroder", "erasters", " rap", "Ratter", " rasters", "ratter", "Roder", "rap", " rascal", "Rap", "hatter", "rascal", "Raster", "arascal", "hasters", "aroder", "eraster", "arasters", "hap", "haster", " roder", "roder", "Rascal"], "width": ["ize", "window", "full", "n", "d", "area", "gender", "shape", "z", "wa", "Width", "wn", "length", "wd", "min", "density", "weight", "age", "p", "frame", "w", "scale", "fw", "layout", "work", "x", "left", "size", "wb", "f", "value", "image", "h", "widget", "page", "img", "write", "west", "style", "en", "duration", "lon", "dim", "wm", "flow"], "height": ["window", "th", "k", "y", "rh", "dy", "volume", "depth", "padding", "d", "right", "angle", "shape", "crop", "stroke", "pad", "length", "density", "hd", "Height", "build", "w", "ady", "max", "work", "x", "han", "size", "thin", "head", "h", "v", "img", "inches", "deep", "dim", "rows"], "stop": ["snap", "exit", "speed", "zero", "rest", "step", "fill", "limit", "comment", "pause", "remove", "cut", "delay", "shape", "pop", "number", "skip", "summary", "address", "roll", "drop", "spot", "Stop", "ops", "wait", "trip", "set", "hide", "check", "page", "change", "output", "clip", "save", "b", "sign", "hop", "sleep", "block", "keep", "sort", "end"]}}
{"id1": "6009527", "id2": "4468255", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadAssments", "doFinishLoadInstortion", "doFinishLoadInstachment", "doFinishloadAttments", "doFinishLoadAttment", "doFinishLoadInstment", "doFinishloadAttment", "doFinishLoadAssment", "doFinishloadAttachment", "doFinishLoadAttachments", "doFinishLoadAttachortion", "doFinishloadAttachachment", "doFinishLoadAttments", "doFinishLoadInstments", "doFinishloadAttachments", "doFinishLoadAttortion", "doFinishloadAttortion", "doFinishLoadAttachachment", "doFinishloadAttachortion", "doFinishLoadAssachment", "doFinishLoadAssortion"], "attachmentId": ["attentionInfo", "attimageID", "attimageInfo", "attachmentID", "adachmentId", "adociationPath", "attachmentid", "attachmentPath", "adociationInfo", "attentionid", "attplementationId", "attplementationID", "AttachmentId", "attimagePath", "ttociationid", "ttociationId", "Attachmentid", "ttachmentID", "attlementID", "attociationid", "AttachmentID", "attociationId", "adachmentInfo", "attociationInfo", "attentionID", "attlementId", "attentionPath", "AttachmentType", "attentionId", "attociationID", "ttociationID", "ttachmentId", "adachmentPath", "attlementType", "attlementid", "attimageId", "attachmentInfo", "ttachmentid", "adachmentID", "attachmentType", "attociationPath", "adociationID", "adociationId", "attentionType", "attplementationid"], "attachment": ["attment", "attachruction", "adment", "appachment", "appment", "attruction", "attention", "attachached", " attention", "attachachment", "assention", "instment", "attached", "assached", " adaptociation", " attment", "association", "attociation", " adaptachment", "appruction", "adached", "attachention", "assachment", "instachment", "assment", "adention", " attociation", " adaptention", "instention", " adaptment", "appention", "adachment", "instruction"], "attachmentUri": ["attmentIri", "attachmentUris", "attachmentCuURI", "attachedAti", "attachmentEri", "attachmentSuris", "attachmentIuri", "attachedURI", "attachmentSuri", "attachmentSuti", "attachmentSuuri", "attachmentIURI", "attachedUti", "attachmentSuRI", "attachedAuri", "attachmentAri", "attachmentEuri", "attachmentUti", "attachedUri", "attachmentIris", "attmentUURI", "attachmentSuURI", "attmentUri", "attachmentERI", "attachedARI", "attachmentUuri", "attachedUuri", "attachmentCuuri", "attachedAri", "attachmentAuri", "attachmentEti", "attachmentAti", "attachmentCuri", "attachmentIri", "attachmentUURI", "attmentIURI", "attachmentCuris", "attmentIuri", "attmentUuri", "attmentIris", "attachmentURI", "attachmentARI", "attmentUris"], "contentUri": ["contentUsris", "contentIi", "contentURuri", "contentUuri", " contentSudi", " contentSuRI", " contentURI", "contentSuRI", "resourceIri", "contentSuri", "resourceURI", "contentIri", "resourceUris", "contentCRI", "contentFileris", "contentURi", "resourceUri", "contentURI", "contentURris", "resourceIuri", "resourceIRI", "contentUsdi", "contentUdi", "contentCuri", "contentUsRI", "resourceUi", " contentUris", "contentUi", "contentCi", "resourceIi", " contentUdi", " contentSuri", "contentUsuri", "contentCris", "resourceUuri", "contentCdi", "resourceIris", "contentCri", "contentFileri", "contentSudi", "contentFileRI", "contentUsri", "contentFileuri", "contentIuri", "contentIRI", "contentUris", "contentSuris", "contentIris", " contentSuris", "contentURri"], "file": ["File", "folder", "resource", "able", "local", "ger", "use", "stream", "line", "entity", "zip", "cache", "view", "le", "input", "copy", "path", "log", "io", "via", "this", "files", "object", "child", "letter", "content", "unit", "book", "single", "handler", "up", "create", "connection", "base", "pe", "model", "upload", "url", "get", "work", "load", "f", "FILE", "filename", "image", "auto", "socket", "to", "fp", "output", "reader", "data", "picture", "b", "source", "uri", "binary", "buffer", "name"], "in": ["In", "pull", "or", "again", "ini", "c", "IN", "m", "o", "din", "inner", "bin", "input", "copy", "as", "con", "io", "this", "pin", "sync", "ins", "ac", "conn", "inn", "err", "up", "connection", "init", "s", "win", "url", "gin", "f", "cli", "e", "i", "nin", "a", "image", "socket", "login", "reader", "data", "r", "b", "inc", "id", "source", "binary"], "out": ["resource", "In", "line", "again", "cache", "IN", "o", "ex", "view", "inner", "bin", "Out", "copy", "log", "outer", "io", "outs", "this", "sync", "on", "conn", "err", "up", "connection", "net", "s", "base", "init", "exec", "cli", "i", "by", "nin", "image", "socket", "to", "writer", "page", "ext", "output", "data", "OUT", "null", "b", "inc", "source", "lock", "client", "one"], "intent": ["action", "entry", "advert", "vent", "acc", "entity", "effect", "act", "context", "request", "xml", "language", "ents", "concept", "response", "ani", "ctx", "inst", "contact", "this", "activate", " Intent", "content", "object", "it", "intention", "animate", "document", "init", "agent", "element", "spirit", "event", "ant", "anc", "enc", "impact", "category", "eng", "anim", "ink", "feature", "Activity", "term", "feat", "ent", "activation", "text", "activity", "focus", "android"]}}
{"id1": "8667872", "id2": "10436471", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "code2": "    @Override\n    public Cal3dModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        Cal3dModel model = new Cal3dModel(getFlags());\n        loadCal3dModel(getBaseURL(), url.toExternalForm(), new InputStreamReader(url.openStream()), model);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "label": 0, "substitutes": {"hash": ["SHA", " sum", "string", "Hash", "str", "sum", "copy", "add", "hex", " fingerprint", "build", " hashes", "print", " hashing", "component", "dump", "code", "h", " decipher", "gen", "write", "update", "text", " Hash"], "data": ["media", "string", "cache", "dat", "str", "input", "response", "hex", "key", "this", "json", "database", "length", "content", "address", "alpha", "connection", "base", "storage", "DATA", "size", "dump", "value", "a", "image", "format", "bytes", "result", "memory", "output", "reader", "picture", "message", "info", "buffer", "source", "text", "body", "name", "padding"], "digest": ["bigest", "digse", "signEST", "signse", "hedest", "bigse", " diger", "decEST", "bigester", " digse", "bigger", "Digester", " digit", "hedge", "signest", "digge", " digger", " digEST", "Digge", "digester", "signit", "signer", "decest", "DigEST", " digester", "hedester", "signester", "digEST", "Diger", "diger", "Digger", " digge", "decit", "digger", "digit", "Digest", "Digse", "hedger", "decester"]}}
{"id1": "14303294", "id2": "15202804", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"getServerHash": ["getSessionHash", "getServerAddress", " getServerAddress", "getSecureSalt", "getServerSalt", "getserverAddress", " getSecureAddress", "getserverHash", "getSessionAddress", "getserverSHA", "getSecureSHA", "getSecureHash", "getSecureAddress", "getserverSalt", "getSessionSalt", "getSessionSHA", " getServerSHA", " getSecureSalt", " getSecureHash", "getServerSHA", " getServerSalt", " getSecureSHA"], "passwordHash": ["passwordhash", " PasswordHash", " passwordCode", "PasswordHash", "passwordPass", "PasswordPassword", " passwordhash", "PasswordPass", " passwordPass", "privatePassword", " PasswordPass", " PasswordCode", "privatehash", "passwordCode", "privateHash", " passwordSalt", "passwordSalt", "privateSalt", " passwordPassword", "Passwordhash", "PasswordCode", "passwordPassword"], "PasswordSalt": [" PasswordHash", "password256", " passwordSecret", "PasswordHash", "PasswordPassword", "passwordSecret", "PasswordSecret", "PASSSalt", "PASSPassword", "PASSHash", " Password256", " passwordSalt", "passwordSalt", "Password256", "PASS256", " passwordPassword", " PasswordPassword", " PasswordSecret", "passwordPassword"], "hash": ["row", "sh", "string", "cache", "mac", "Hash", "sha", "response", "sum", "copy", "log", "search", "hex", "number", "key", "auth", "content", "user", "address", "kh", "build", "crypt", "ha", "base", "url", "work", "ash", "size", "array", "pool", "code", "value", "password", "her", "image", "h", "check", "result", "change", "html", "error", "data", "dig", "message", "update", "buffer", "block"], "digest": ["hashener", "digener", " digall", "generall", "hashest", " diger", "digusher", "mdest", "Digener", " digher", "Digester", " digusher", "integested", "mdested", "signest", "Digested", "integest", " digger", "digested", "digester", "signer", "Digusher", " digester", " digested", "Digher", "generest", "mdusher", "signester", "hasher", "hashester", "signher", "generester", "Diger", "diger", "Digger", "integester", "generested", " digener", "integall", "digger", "mdester", "Digest", "digher", "digall", "signger"]}}
{"id1": "9371421", "id2": "13024538", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static String getHash(String uri) throws NoSuchAlgorithmException {\n        MessageDigest mDigest = MessageDigest.getInstance(\"MD5\");\n        mDigest.update(uri.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "label": 1, "substitutes": {"eventHash": ["byteHash", "messageDig", "eventDig", " eventKey", "byteDig", "eventhash", " eventhash", "eventKey", "messagehash", " eventDig", "bytehash", "byteKey", "messageKey", "messageHash"], "eventstr": ["eventdict", "Eventdict", "exstr", " eventsource", "errorStr", "EventStr", "eventstring", "errorstring", "exstring", " eventstring", "errorsource", "Eventstr", "exStr", "eventsource", " eventdict", "eventStr", "Eventstring", "exdict", "Eventsource", " eventStr", "errorstr"], "md": ["mb", "mp", "mg", "ms", "pm", "od", "mand", "cm", "mac", "map", "m", "em", "mem", "sm", " MD", "d", "sha", "hm", "di", "MD", "bd", "key", "meta", "doc", "ke", "wd", "hd", "ad", "dd", "ld", "mc", "ng", "mod", "cmd", "mn", "dh", "dr", "mag", "ma", "hash", "dm", "amd", "data", "dig", "rpm", "mm", "metadata", "vd", "id", "mt", "mu", "mo"], "theDigest": [" theDighest", "Thedigest", " theDigester", "theDigester", " theSignhest", " theSignester", "thedigEST", "theSignest", "TheDigest", "thedigester", "thedigest", "theSignester", "ThedigEST", "theHashEST", " theSignEST", "theHashester", "theSignhest", "TheDigEST", "Thedigester", " theDigEST", " theSignest", "theDighest", "thedighest", "theDigEST", "theSignEST", "theHashest", "TheDigester"]}}
{"id1": "19086952", "id2": "21979462", "code1": "    public static HttpResponse createUrlResponse(final URL url, final TcpConnection connection) throws IOException, NullPointerException {\n        String fullPath = url.toString();\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        final long length = conn.getContentLength();\n        if (connection.isDebugEnabled()) connection.logDebug(\"Sending \" + fullPath + \" to \" + connection.getRemoteAddress() + \" (length: \" + length + \").\");\n        return createInputStreamResponse(in, conn.getContentType(), length, connection);\n    }\n", "code2": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "label": 0, "substitutes": {"createUrlResponse": ["createHttpRequest", "createHttpresponse", "createWebResponse", "createURLResponse", "createHttpResponse", "createWebResp", "getUrlResponse", "getUrlresponse", "getUrlResp", "createUrlResp", "getURLRequest", "getURLResp", "getUrlRequest", "createUrlresponse", "createURLResp", "createHttpResp", "getURLresponse", "createURLresponse", "createUrlRequest", "createWebresponse", "getURLResponse", "createWebRequest", "createURLRequest"], "url": ["resource", "entry", "string", "channel", "host", "http", "proxy", "service", "response", "URL", "log", "path", "con", "io", "open", "Url", "client", "object", "address", "bug", "loc", "l", "base", "server", "location", "config", "sl", "f", "link", " URL", "image", "connect", "socket", "remote", "page", "ssl", "uri", "buffer", "text", "source", "org", "name", "file"], "connection": ["timeout", "resource", "ch", "application", "subject", "section", " Connection", "container", "function", "description", "c", "Connection", "channel", "cache", "context", "current", "http", "character", "service", "response", "ci", "ctx", "con", "io", "sync", "database", "relation", "object", "handler", "loc", "cc", "event", "communication", "server", "config", "bc", "pool", "cli", "link", "session", "wrapper", "password", "graph", "connect", "socket", "writer", "directory", "conf", "connected", "general", "uri", "source", "client", "nc", "collection", "db", "tc", "lc"], "fullPath": ["Fullpath", "halfUrl", "FullURL", "fullURL", "FullUrl", " fullUrl", "tempPath", "fullpath", "tempURL", "halfPath", "fullUrl", "temppath", "FullPath", " fullURL", "tempUrl", " fullpath", "halfpath"], "conn": ["ch", "serv", "n", "c", "Connection", "act", "ca", "col", "Conn", "ann", "conv", "ci", "ion", "ctx", "con", "api", "open", "co", "rt", "sync", "ct", "cf", "client", "loc", "l", "init", "part", "cn", "cp", "exec", "coll", "cur", "server", "reg", "config", "sec", "f", "enc", "cli", "Con", "close", "cb", "stat", "nt", "en", "conf", "nc", "connected", "ec", "connect", "db", "lc"], "in": ["In", "inas", "again", "ini", "c", "n", "m", "IN", "cin", "is", "inner", "din", "bin", "input", "as", "con", "ins", "ac", "min", "inn", "kin", "s", "rin", "out", "gin", "index", "f", "i", "nin", "socket", "login", "ssl", "reader", "data", "inc", "id", "stream", "client"], "length": ["pull", "class", "section", "library", "position", "height", "string", "zip", "th", "limit", "depth", "total", "angle", "shape", "path", "Length", "number", "slice", "child", "count", "build", "l", "port", "load", "size", "len", "value", "level", "type", "ength", "style", "duration", "id", "offset", "lock", "available", "width", "padding"]}}
{"id1": "17111859", "id2": "4056444", "code1": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "code2": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "label": 1, "substitutes": {"getHash": ["GetHTML", "buildHTML", " gethash", "gethash", "buildHash", "getSalt", " getHTML", "buildhash", "GetSalt", "buildSalt", "getHTML", " getSalt", "GetHash", "Gethash"], "string": ["resource", "section", "cache", "word", "version", "input", "time", "sequence", "number", "this", "slice", "in", "database", "STR", "ring", "content", "object", "address", "p", "s", "strings", "prefix", "server", "array", "value", "password", "filename", "format", "hash", "data", "null", "duration", "message", "buffer", "uri", "text", "source", "name", "file", "reference"], "hashTime": ["HashCheck", "versionTime", " hashTimer", "hexTrack", "versiontime", "hashTimer", "hexCheck", "HashTime", " hashTrack", "hashFunction", " hashtime", "HashFunction", "versionTimer", "hexTimer", "Hashtime", "hexTime", "hashtime", "HashTimer", "HashTrack", "hashCheck", " hashFunction", "hashTrack", "versionFunction", " hashCheck"], "md5": ["md25", "digse", "mand2", "hash2", "mand5", "mdql", "hash5", "MD2", "digb", " md25", "mdol", "mad512", "MD5", "digql", " mddown", "dig25", "mad5", " md53", "madse", "MDol", "mddown", "md2", "dig6", " md6", " md3", "MDkey", "md53", "mdkey", "dig5", "mdse", " md2", " mdse", "mand25", "maddown", "shab", "md6", "sha2", "mandql", "mad3", "dig512", "mdb", "MD53", " mdql", "madkey", "mad2", " mdb", "md512", "sha6", " md512", "hashol", "MD3", "hash53", "md3", "dig2", " mdkey", "sha5", "digdown", " mdol"], "result": ["entry", "section", "function", "Result", "current", "word", "results", "character", "comment", "response", "search", "match", "hex", "number", "list", "card", "json", "length", "dict", "err", "valid", "default", "part", "prefix", "expected", "work", "array", "value", "success", "feature", "format", "res", "hash", "page", "diff", "error", "data", "test", "found", "product", "digit", "r", "message", "buffer", "uri", "source", "range"], "hexString": ["rawArray", "tempstring", "hashString", "hexstring", "exArray", "packstring", "exString", "tempBuffer", "hashBuffer", "rawString", " hexstring", "exstring", "hashstring", "rexArray", " hexBuffer", "packString", "hexArray", "hexBuffer", " hexArray", "rexStr", "packStr", "hexStr", "tempString", "rexstring", "packArray", "rawstring", "exBuffer", "hashArray", "rawBuffer", "rexString", " hexStr", "tempArray"], "i": ["si", "qi", "ip", "u", "multi", "k", "ii", "c", "m", "pi", "o", "d", "abi", "ci", "di", "io", "slice", "ui", "in", "ri", "length", "bi", "p", "l", "phi", "s", "j", "I", "fi", "x", "index", "f", "e", "code", "oi", "li", "a", "start", "h", "v", "gi", "ti", "data", "ai", "b", "xi", "zi", "id", "uri", "ix", "end"], "str": ["entry", "fr", "pass", "c", "pr", "input", "char", "key", "sr", "STR", "tr", "p", "br", "err", "s", "out", "url", "sp", "x", "sl", "f", "enc", "e", "code", "res", "val", "st", "output", "data", "obj", "r", "t", "id", "uri", "Str", "text", "buffer", "source", "name"]}}
{"id1": "11032546", "id2": "11673907", "code1": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testCopyUnknownSize": ["testcopyUnknownsize", "testCopyKnownSize", "testCopyunknownsize", "testcopyunknownSize", "testcopyUnknownSize", "testCopyunknownSize", "testCopyKnownsize", "testCopyUnknownsize", "testcopyunknownsize"], "in": ["In", "at", "n", "c", "IN", "m", "is", "din", "inner", "bin", "input", "as", "io", "this", "ins", "min", "conn", "inn", "err", "up", "connection", "exec", "url", "inside", "i", "nin", "a", "image", "reader", "data", "r", "b", "inc", "id", "info", "source", "src"], "out": ["temp", "plus", "again", "at", "cache", "append", "o", "ex", "bin", "with", "Out", "input", "copy", "path", "io", "outs", "post", "sync", "conn", "user", "up", "base", "prefix", "exec", "work", "size", "name", "array", "pool", "off", "image", "auto", "to", "ext", "next", "output", "error", "data", "obj", "OUT", "target", "inc", "parent", "buffer", "client", "one", "file", "extra"], "cpySize": ["cciSize", "cpyMode", "cPyCount", "czipSize", "cpyArray", " cpeLength", "CpyLength", "cpeMode", "cpiLength", "cpyCount", "czipLength", "cpeSize", "czipMode", "czipArray", "cpeCount", "cpiArray", "cpiMode", " cpeArray", "cPySize", " cpyMode", "cciCount", "cpeArray", "cpiSize", " cpeMode", " cpeSize", "cPyLength", "cciLength", "cpyLength", "cpeLength", "CpeLength", "CpeCount", "CpySize", "CpyCount", " cpyArray", " cpyLength", "CpeSize"], "outArray": [" outMemory", "viewSize", "inBuffer", " outAmount", "outList", " outSize", "targetBuffer", "targetList", "targetArray", " outList", "inAmount", "targetMemory", "inSize", "outAmount", "viewAmount", "outputArray", "outputMemory", "outMemory", "viewBuffer", "outputBuffer", "outputList", "inArray", "outBuffer", "outSize", "viewArray", " outBuffer"]}}
{"id1": "3266833", "id2": "23510383", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 1, "substitutes": {"is": ["ib", "or", "us", "ip", "isa", "ios", "im", "bs", "ir", "was", "fits", "iris", "has", "as", "abs", "ais", "os", "IS", "cms", "in", "ins", "init", "Is", "iso", "iss", "get", "its", "ws", "isc", "i", "image", "close", "bis", "mis", "lis", "isu", "id", "es", "iv", "info", "ris"], "name": ["Name", "names", "large", "pass", "description", "n", "string", "word", "title", "version", "named", "path", "label", "search", "key", "this", "vision", "database", "no", "min", "address", "default", "part", "base", "connection", "nice", "domain", "prefix", "url", "size", "office", "code", "value", "space", "filename", "image", "ame", "NAME", "format", "memory", "directory", "type", "data", "term", "module", "null", "id", "parent", "source", "alias", "file", "one"], "contentType": ["mediaType", "ContentTypes", " contentPoint", "messagetype", " contenttype", "contentName", "documenttype", " contentInfo", "contentPoint", "messageName", "contentInfo", "contentTypes", "outputPath", "ContentPath", "mediaPath", "mediaTypes", "documentInfo", "contenttype", "outputTypes", "messageType", "sourceInfo", "ContentType", "documentType", "sourcetype", "sourcePoint", "Contenttype", "outputType", " contentName", "sourceType", "contentPath", "ContentInfo", "documentPoint", "ContentName", "outputName", "mediaName", "messageInfo"], "index": ["timeout", "pull", "position", "height", "string", "multi", "include", "append", "pointer", "depth", "expression", "Index", "input", "shape", "search", "open", "key", "slice", "number", "list", "none", "in", "length", "content", "address", "weight", "alpha", "default", "fix", "prefix", "width", "x", "size", "i", "value", "image", "axis", "page", "level", "error", "type", "data", "write", "inc", "id", "offset", "update", "body", "end"], "extension": ["configension", "configuration", "exturation", "variensions", "extance", "variuration", "Extension", "Extensions", "variension", "configensions", "Extance", "Exturation", "extensions", "configance", "variance"], "isImage": [" isFile", "areImage", "asImage", "isimage", " isPicture", "asInstance", "isVideo", "isaImages", " isInstance", "areMedia", "isInstance", "ISFile", "areimage", " isimage", "isaFile", " isVideo", "asFile", "isaImage", "areImages", "isImages", " isImages", "areFile", "isMedia", "IsImage", "areInstance", "asimage", "ISImage", "isPicture", "IsFile", "IsPicture", " isMedia", "isaMedia", "isFile", "ISPicture", "ISVideo", "IsVideo"], "isAux": ["isWalux", " isAxt", "asAsUX", "isOAux", "isAsex", "asAUX", "isArrayux", "isUlux", "isAsUX", "isHax", " isHaux", " isArrayru", "isUux", "isOAlux", "asAExcept", "isOAUX", "isAcux", "asAsux", "asAlux", "isAru", "isAxt", "isHaux", "isHalux", "isWaux", "isAcUX", "isAnlux", " isAlux", "isAAUX", "isAUX", "isHaUX", "isUExcept", " isHalux", "asAsex", "isAAru", "isAAxt", " isArrayUX", "asAslux", "isAlux", " isAx", "asAex", "isAx", "isAslux", "isAsx", "isWax", "isOAExcept", "asAux", "isUex", "isArrayru", "isAcxt", "isArrayUX", " isAUX", "isAExcept", " isHax", " isArrayxt", "isArrayxt", "isAnUX", "isAex", "asAsExcept", " isHaUX", "isAnex", "isWaUX", " isAru", "isAsExcept", "isAcru", "isAAux", "isAnux", "isUUX", " isArrayux", "isAsux"], "out": ["temp", "again", "at", "project", "cache", "over", "o", "ex", "exp", "word", "table", "version", "inner", "Out", "input", "copy", "outer", "io", "outs", "this", "post", "sync", "in", "object", "conn", "user", "up", "part", "base", "prefix", "exec", "work", "size", "array", "pool", "off", "image", "auto", "a", " in", "plain", "socket", "page", "ext", "next", "output", "error", "data", "result", "obj", "OUT", "null", "parent", "source", "buffer", "client", "file", "extra"], "bufferedImage": ["buffendedImage", "BufferedImage", "BufferingImage", "buffendedimage", "buffledImage", "Bufferedimage", "Bufferingimage", "bufferingImage", "buffledimage", "bufferingimage", "bufferedimage"], "inputStream": ["InputSteam", "outputSteam", "outputBuffer", "inputBuffer", "inputstream", " inputSteam", "Inputstream", "InputStream", "outputstream", " inputstream", " inputBuffer", "outputStream", "inputSteam", "InputBuffer"]}}
{"id1": "12197169", "id2": "5607440", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    public void updateShoppingBean(String userId) {\n        Connection connection = null;\n        PreparedStatement preparedStatement1 = null;\n        PreparedStatement preparedStatement2 = null;\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            connection = DriverManager.getConnection(this.jdbcURL);\n            connection.setAutoCommit(false);\n            String preparedQuery = \"INSERT INTO dbComputerShopping.order(name,product_id,quantity,date,status)VALUES(?,?,?,?,?)\";\n            preparedStatement1 = connection.prepareStatement(preparedQuery);\n            Date date = new Date();\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            String orderDate = format.format(date);\n            Iterator iterator = this.cart.iterator();\n            Object[] shoppingInfo = null;\n            while (iterator.hasNext()) {\n                shoppingInfo = (Object[]) iterator.next();\n                ProductBean product = (ProductBean) shoppingInfo[0];\n                int quantity = (Integer) shoppingInfo[1];\n                preparedStatement1.setString(1, userId);\n                preparedStatement1.setInt(2, product.getId());\n                preparedStatement1.setInt(3, quantity);\n                preparedStatement1.setString(4, orderDate);\n                preparedStatement1.setString(5, \"confirmed\");\n                preparedStatement1.executeUpdate();\n            }\n            Object[] cartInfo = null;\n            preparedQuery = \"UPDATE components SET quantity=quantity-? WHERE comp_id=?\";\n            preparedStatement2 = connection.prepareStatement(preparedQuery);\n            for (Iterator i = this.cart.iterator(); i.hasNext(); ) {\n                cartInfo = (Object[]) i.next();\n                ProductBean product = (ProductBean) cartInfo[0];\n                int quantity = (Integer) cartInfo[1];\n                ProductListBean productList = new ProductListBean(jdbcURL);\n                ArrayList components = productList.getComponents(product.getId());\n                for (Iterator j = components.iterator(); j.hasNext(); ) {\n                    ComponentBean component = (ComponentBean) j.next();\n                    preparedStatement2.setInt(1, quantity);\n                    preparedStatement2.setInt(2, component.getId());\n                    preparedStatement2.executeUpdate();\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n            }\n        } finally {\n            try {\n                connection.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement1.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement2.close();\n            } catch (SQLException ex) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"read": ["ready", "run", "println", "readable", "reading", "request", "continue", "report", "open", "process", "download", "print", "Read", "init", "replace", "get", "load", "work", "check", "start", "reader", "parse", "write", "loop", "stream", "create", "end"], "in": ["In", "fr", "token", "again", "at", "of", "ini", "c", "n", "IN", "scan", "o", "ex", "is", "din", "inner", "bin", "input", "path", "log", "con", "io", "from", "cms", "ins", "doc", "on", "min", "conn", "inn", "er", "ing", "err", "it", "l", "isin", "connection", "s", "out", "server", "url", "index", "f", "e", "by", "nin", "a", "image", "login", "ssl", "reader", "error", "data", "r", "b", "inc", "id", "info", "buffer", "stream", "source", "file"], "line": ["inline", "entry", "row", "status", "string", "lines", "col", "LINE", "ine", "str", "comment", "le", "Line", "ge", "log", "key", "object", "unit", "frame", "l", "L", "lin", "cell", "url", "sl", "f", "link", "e", "code", "value", "el", "record", "val", "page", "ne", "reader", "se", "data", "parse", "b", "id", "message", "lf", "source", "buffer", "text", "block", "name", "file", "lc", "end"], "i": ["si", "qi", "u", "ip", "n", "ii", "ini", "pi", "o", "is", "abi", "ci", "di", "io", "slice", "ui", "ri", "bi", "ie", "p", "l", "phi", "j", "I", "eni", "x", "fi", "ski", "index", "f", "e", "oi", "li", "ori", "ni", "gi", "ti", "ai", "b", "zi", "xi", "info", "ix", "uni"], "logDatum": ["logDatatum", "exDDam", "logDatata", "logDum", "logDData", "exDDatum", "logDDam", "logdata", "logDsict", "LogData", "logDam", "logDatam", "logDictionary", "LogDatum", "logdict", "logDsatum", "logDatict", "logFam", "logDsum", "logdum", "Logdum", "exDam", "LogDum", "logDatictionary", "LogDict", "exData", "logFatum", "logDict", "logFata", "Logdatum", "exDDictionary", "logData", "logdatum", "logDDatum", "logDDictionary", "logFictionary", "Logdict", "exDictionary", "exDatum", "logDsata", "exDData", "Logdata"]}}
{"id1": "1156851", "id2": "8182932", "code1": "    public void runWeb(String beginURL, String contextRoot, String pageURI) {\n        if (bDebug) System.out.println(\"WEB Path\");\n        List<String> vtURLs = new ArrayList<String>();\n        List<String> vtRobots = getRobots(beginURL, contextRoot);\n        vtURLs.add(\"/\" + contextRoot + \"/\" + pageURI);\n        Indexer indexer = null;\n        IndexDocument indexDoc = null;\n        try {\n            indexer = new Indexer(\"/tmp/tmp/index\");\n            for (String sxURL : vtURLs) {\n                if (bDebug) System.out.println(\"\\n\\n*** INDEXING \" + sxURL);\n                if (bDebug) System.out.println(\"Have - \" + sxURL);\n                boolean bIndexPage = true;\n                if (vtRobots != null) {\n                    for (String sxRobotURL : vtRobots) {\n                        if (bDebug) System.out.println(\"Comparing to - \" + sxRobotURL);\n                        if (sxURL.startsWith(sxRobotURL)) {\n                            if (bDebug) System.out.println(\"Found URL - \" + sxRobotURL + \" - \" + sxURL);\n                            bIndexPage = false;\n                            break;\n                        }\n                    }\n                } else {\n                    bIndexPage = true;\n                }\n                sxURL = beginURL + sxURL;\n                ParserDelegator pd = new ParserDelegator();\n                CallbackHandler cb = new CallbackHandler(vtURLs, bIndexPage, contextRoot);\n                try {\n                    URLConnection urlConn = new URL(sxURL).openConnection();\n                    urlConn.setUseCaches(false);\n                    Date modDate = new Date(urlConn.getLastModified());\n                    if (bDebug) System.out.println(\"\\nMatch - \" + sxURL + \" - Modified Date - \" + modDate);\n                    BufferedReader bfReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n                    pd.parse(bfReader, cb, true);\n                    if (bIndexPage) {\n                        if (bDebug) System.out.println(\"Adding Index - \" + sxURL + \"\\nContent:\" + cb.getText() + \"\\nSummary:\" + cb.getSummary() + \"\\nTitle:\" + cb.getTitle());\n                        indexDoc = new IndexDocument();\n                        indexDoc.setUID(sxURL + modDate.toString());\n                        indexDoc.setPageURL(sxURL);\n                        indexDoc.setModifiedDate(modDate.toString());\n                        indexDoc.setContents(cb.getText());\n                        indexDoc.setTitle(cb.getTitle());\n                        indexDoc.setSummary(cb.getSummary());\n                        indexer.addDocument(indexDoc);\n                    }\n                } catch (Exception ee) {\n                    PetstoreUtil.getLogger().log(Level.SEVERE, \"Inner Exception\" + ee);\n                }\n            }\n        } catch (Exception e) {\n            PetstoreUtil.getLogger().log(Level.SEVERE, \"Outer Exception\" + e);\n        } finally {\n            try {\n                if (indexer != null) {\n                    indexer.close();\n                }\n            } catch (Exception ee) {\n                ee.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 0, "substitutes": {"runWeb": ["processWeb", " runweb", "processWs", "runningweb", "runningSite", "processweb", "processSite", "runningWs", " runSite", "runSite", " runWs", "runWs", "runningWeb", "runweb"], "beginURL": ["beginUrl", "untilurl", "BeginUrl", " beginELF", "useUR", "beginURI", "beginurl", "BeginURI", "BeginURL", "startSSL", " beginSSL", "BeginELF", "endURI", "useUrl", "beginUR", "Beginurl", "beginSSL", "BeginUR", " beginUrl", "useURL", "untilURI", "untilUrl", "endurl", "startUrl", "endUR", "useURI", "startURL", "beginELF", "endURL", "startELF", "untilURL", "endUrl", "BeginSSL"], "contextRoot": [" contextRO", "contextroot", "ContextPath", "conceptBase", "contextRO", "serviceRO", "ContextBase", "ContextRO", " contextroot", " contextHome", "resourceroot", "contextHome", "contextBase", "conceptRoot", " contextGround", "contextGround", "Contextroot", "ContextHome", "serviceRoot", "serviceGround", "contextPath", "resourcePath", " contextPath", "resourceRoot", "ContextGround", " contextBase", "conceptHome", "ContextRoot", "eventRoot", "conceptroot", "serviceroot", "eventroot"], "pageURI": [" pageURL", "pageURL", " pageUR", "PageURI", "enduri", "PageID", "endURI", "pageUR", "siteID", "siteURI", "PageURL", "pageuri", "siteURL", "PageUR", "pageID", " pageID", "endUR", " pageuri", "endURL", "Pageuri", "siteUR"], "vtURLs": ["vtUrllines", "vturllines", "vtGETs", "vtURls", "vtURLi", "vtStreamParts", "vtURS", "rtURLs", "htURLs", "vtIPS", "vtRLS", "vtRLs", "vtURi", "tvURLS", "htURls", "vtStreamobs", "htURParts", "htURobs", "rtURLls", "tvDownloads", "vtURLobs", "vtStreams", "rtURLS", "vtGETS", "htURLobs", "VTURLs", "VTURLlines", "vtURLls", "rtURs", "vtURLes", "vtURs", "VTURls", "vtGETls", "vtIPs", "vtIPes", "vtURLParts", "htURs", "tvURLs", "tvDownloadS", "vturls", "rtURls", "vtURLlines", "vtURlines", "VTURi", "VTURLls", "vtRLes", "vturlls", "tvURLes", "VTURlines", "vtURParts", "vtUrlS", "vtUrlobs", "VTURLi", "vtDownloadS", "vtURLS", "htURLParts", "vtURobs", "vtDownloades", "vtUrlParts", "VTURs", "rtURS", "tvDownloades", "vtStreamls", "vtUrli", "htURLls", "vtUrls", "vturli", "vtUrlls", "vtDownloads"], "vtRobots": ["vtBops", "vtPlugs", "vtProOTS", "vtLogops", "vtBlops", "vtGroots", "vtLegibraries", "htrobOTS", "VTGrougs", "vtRobops", "VTRobrots", "vtPlibraries", "VTGroibraries", "vtGrougs", "vtBlOTS", "vtrobot", "vtLegots", "vtRobibraries", "VTPros", "vtGrorots", "vtPros", "vtLogOTS", "vtBOTS", "VTProots", "vtLogs", "VTRobOTS", "vtRobot", "htRobops", "htrobots", "vtPlrots", "VTProOTS", "vtLegrots", "vtBs", "htRobots", "VTProops", "VTRobops", "vtLogots", "VTRobibraries", "vtProops", "VTGroots", "vtrobops", "vtBlot", "vtRobs", "VTRobots", "vtProots", "VTRobs", "vtPlots", "vtGroibraries", "VTRobugs", "VTGrorots", "vtBots", "vtrobots", "htrobot", "vtRobrots", "vtBot", "htRobot", "vtLegugs", "htRobOTS", "vtBlots", "vtrobOTS", "vtRobugs", "vtRobOTS", "htrobops"], "indexer": ["indexeer", "checkER", "checkers", "fixe", " indexe", "checker", "Indexer", "indexe", "finde", "indexER", "indexed", " indexER", "finded", " indexers", "fixed", "indexReader", "fixReader", "indexers", " indexeer", "findReader", " indexReader", "Indexers", "IndexER", "checkeer", "finder", " indexed", "fixer", "Indexeer"], "indexDoc": ["IndexDom", "officePage", "Indexdoc", "indexDom", "documentdoc", "officeDoc", "officedoc", "indexdoc", "officeDom", "documentDoc", "indexPage", "documentDom", "IndexPage", "IndexDoc", "documentPage"], "sxURL": ["dsxUR", "sxaTL", "swwLink", "SxUR", "lXDOM", "SexUrl", " sXDB", " sxLink", " sxcUrl", "sxturl", "dsxTL", "sxtUrl", "sXUR", "sxxUrl", "pxcUrl", " sexurl", "pxURI", " sXurl", "sxeUrl", "sxeTL", "swwUR", "sxiDOM", "sxURI", "sxxURL", "sxeSSL", "sXDOM", " sexURL", "sxaUR", "sXELF", "lXUR", "sxtUR", " sxDB", "sxcUrl", "sXurl", " sxcURI", "sxurl", "sexUR", "sxcURI", "sxDOM", "lXSSL", "sexELF", " sexUrl", "sXURL", "SxUrl", "lxUR", "sxcLink", "SxELF", "sxeUR", "lXURL", "sxtURL", "sxELF", "sxeURL", "sexUrl", "lxDOM", " sxurl", "sxxURI", "pxcURL", "sxtURI", "sxcUR", "sxxUR", "pxUrl", "sexDOM", "sxSSL", "swwUrl", " sxURI", "sexurl", "sxxDB", "sxcSSL", "sfxSSL", "dsxeurl", "sxxurl", "SexUR", "sxiSSL", "dsxeTL", "dsxeUR", "snexUR", "sexURL", "sxcELF", "sfxURI", " sxUrl", " sxcSSL", "sxaURL", "sexSSL", "sxLink", "dsxurl", "sxtDB", "sXDB", " sXUR", "sfxUR", "sxUR", "sxTL", "sxcurl", "lxURL", "sxburl", "lxSSL", "sxbUrl", "sfxUrl", " sxUR", "SexELF", " sxcurl", "snexTL", "dsxURL", "sxiUR", "pxURL", "sfxURL", "snexurl", " sxcUR", "sXSSL", "sxiURL", "sxeurl", "sxUrl", "SxURL", " sxcURL", "swwURL", "sxbUR", "sxDB", " sXURL", "snexURL", "sxbURL", "pxcURI", " sxSSL", "dsxeURL", "sXUrl", "sxcURL", " sexUR", "sxaurl", "SexURL"], "sxRobotURL": ["sxRuboUR", "sxRooyUR", "sxRuboURL", "sxRobortTL", "sxRooyURL", "sxRubotUrl", "sxLootTL", "sxRootURL", "sxRobobURI", "sxRobogURL", "sxRobotationURL", "sxRobootTL", "sxRobobSSL", "sxRubotPath", "sxRoboturl", "sxRobobTL", "sxLootURL", "sxRubotUR", "sxRobotUrl", "sxRobOTTL", "sxRobogTL", "sxRobogurl", "sxRobootURL", "sxRobotationCL", "sxRobogSSL", "sxRobotPath", "sxRoboUrl", "sxRobOTURL", "sxRobotationURI", "sxRobOTUR", "sxLooburl", "sxRobortUR", "sxRootUR", "sxRobootSSL", "sxRooyTL", "sxRoboburl", "sxRobobUR", "sxRobotSSL", "sxRoboUR", "sxRobOTUrl", "sxRoboPath", "sxRootTL", "sxRobotURI", "sxRobobCL", "sxLootSSL", "sxRubotURL", "sxRobotationUR", "sxLooturl", "sxLoobURL", "sxLoobSSL", "sxRoboyURL", "sxRobotTL", "sxRobOTCL", "sxRobortURL", "sxRobOTPath", "sxRoboyUR", "sxRoboURL", "sxRoboyPath", "sxRoboyUrl", "sxLoobTL", "sxRobotUR", "sxRobotCL", "sxRobOTURI", "sxRuboUrl", "sxRobooturl", "sxRuboPath", "sxRobobURL", "sxRoboyTL"], "pd": [" md", " td", "pc", " pp", "pm", "pi", "pb", "pg", "py", "cpp", "d", "dl", " pdf", " cd", "bd", "ppa", "ht", " sd", "APD", " db", "pp", " df", "hd", "wp", "p", "dd", " pm", "cd", "PF", "PB", "Parser", " dd", " PD", "PD", " cp", "lp", "CB", "ds", "td", "gd", "BT", "bb", " dc", "md", "bf", "vd", "parser", "xd", " DD"], "cb": ["dc", "fc", "cmp", "ob", "cm", "c", " rc", "ca", "pb", "cpp", "cv", "func", " cd", "ctx", "fd", "bd", "cod", "cf", "obb", " db", "bp", "handler", "fn", "eb", "ff", "gb", "cd", "cp", "cmd", " CB", "BBC", " bc", "bc", " dd", "Callback", "sb", "CB", "kb", "callback", "bb", "fb", "bf", "b", "buff", "rb", "db"], "bIndexPage": ["bSearchPages", "bShortPage", " bQueryFile", "nbLinkpage", " bIndexpage", " bSearchPage", "bbIndexPage", "nbLinkLine", "bindexPage", "nbIndexFile", " bIndexFile", "nbIndexpage", "nbLinkFile", "bSearchpage", "bbSearchLine", "nbIndexLine", "bSearchFile", "bShortLine", "bbSearchpage", "bQueryPage", "bIndexPages", "nbLinkPage", " bSearchPages", " bIndexPages", "bindexPages", "bbIndexpage", "bIndexLine", "bindexpage", " bindexPage", " bindexPages", " bindexpage", " bSearchpage", "bbIndexLine", " bQueryTable", "bLinkFile", "bIndexFile", " bIndexLine", "bLinkpage", "bindexLine", "bIndexTable", "bQueryTable", "bindexFile", "nbIndexPage", "bIndexpage", "bLinkLine", "bQueryLine", "bbSearchPage", "bindexTable", "bLinkPages", "bSearchPage", " bQueryLine", " bQueryPage", " bIndexTable", "bLinkPage", "bQueryFile", "bSearchLine", " bindexLine", "bSearchTable", "bShortpage"], "urlConn": ["fileConnection", "serverConn", "URLCo", "httpConn", "httpCo", "urlConnection", " urlConnection", "serverConnect", " urlCon", "URLconn", "UrlBuff", "URLBuff", "urlCon", "serverCon", "serverConnection", "httpConnection", " urlConfig", "URLConf", " urlBuff", "urlconn", "urlCo", "httpConnect", "URLConfig", " urlConf", "UrlConf", "UrlConfig", "urlConf", " urlConnect", "UrlConn", " urlCo", "fileconn", "httpconn", "URLConnect", "fileConnect", "fileConn", "urlConnect", "urlConfig", "URLConn", "URLConnection", "httpCon", "urlBuff"], "modDate": ["ModDay", " modDay", "MODDat", " modDat", "modTime", "MODDate", " modTime", "MODTime", "modDay", "modDat", "ModTime", "ModDat", "ModDate", "MODDay"], "bfReader": ["btRead", "bbBuffer", "btFile", "bbFile", "btBuffer", "bdreader", "BFReader", "bfBuffer", "bdReader", "btreader", "bdWriter", "bbReader", "BFFile", "bfFile", "BFWriter", "btWriter", "bfRead", "bbWriter", "bfreader", "bbreader", "bbRead", "bdBuffer", "bfWriter", "BFRead", "btReader"]}}
{"id1": "15580610", "id2": "21308543", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 1, "substitutes": {"trainClassifier": [" trainclassLoader", "trainModelLoader", "trainTestify", "trainclassification", "trainclassifier", "trainModelification", " trainclassification", " trainClassification", "trainTestification", "trainTestifier", "trainTestLoader", " trainClassLoader", " trainclassifier", " trainClassify", "trainclassify", " trainclassify", "trainClassification", "trainModelifier", "trainModelify", "trainclassLoader", "trainClassify", "trainClassLoader"], "dir": ["folder", "group", "root", "class", "window", "project", "d", "dist", "path", "report", "di", "fd", "files", "database", "env", "wd", "div", "object", "doc", "DIR", "build", "loc", "base", "cd", "out", "domain", "model", "url", "config", "du", "home", "Dir", "filename", " directory", "lib", "directory", "output", "data", "direction", "md", "target", "module", "uri", "name", "db", "file"], "command": ["action", "slave", "reason", "root", "attribute", "media", "project", "function", "shell", "and", "string", "history", "word", "request", "volume", "sudo", "script", "comment", "service", "language", "input", "path", "power", "move", "sequence", "operation", "force", "this", "database", "child", "clear", "archive", "document", "connection", "domain", "cmd", "program", "exec", "model", "event", "query", "system", "config", "help", "component", "array", "delete", "category", "cli", "control", "usage", "machine", "password", "image", "Command", "three", "directory", "argument", "error", "menu", "module", "pattern", "message", "info", "name", "which", "file", "one"], "length": ["distance", "or", "span", "class", "section", "position", "full", "join", "th", "zip", "capacity", "word", "limit", "depth", "character", "padding", "inner", "prime", "sum", "angle", "time", "shape", "power", "Length", "how", "sequence", "match", "number", "slice", "creator", "letter", "square", "count", "loc", "ph", "strength", "part", "l", "max", "left", "size", "now", "before", "len", "value", "head", "both", "last", "range", "level", "type", "ength", "style", "duration", "id", "dim", "body", "form", "width", "end"], "process": ["application", "group", "processing", "status", "class", "run", "share", "use", "plus", "project", "function", "host", "method", "call", "script", "service", "pid", "path", "display", "this", "sync", "post", "user", "child", "p", "task", "proc", "app", "connection", "document", "out", "cmd", "exec", "program", "component", "thread", "system", "processor", "machine", "python", "session", "worker", "handle", "result", "output", "parse", "parent", "Process", "master", "cess", "console", "file"]}}
{"id1": "18504192", "id2": "21425787", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "in": ["In", "or", "again", "at", "ini", "c", "IN", "m", "d", "inner", "bin", "input", "old", "copy", "io", "ins", "ac", "min", "inn", "part", "base", "url", "index", "i", "image", "login", "reader", "diff", "data", "b", "inc", "id", "info", "parent", "buffer", "src", "name", "file"], "out": ["temp", "external", "line", "again", "n", "c", "cache", "string", "o", "ex", "call", "Out", "copy", "io", "outs", "dest", "conn", "object", "p", "err", "part", "w", "base", "connection", "prefix", "exec", "password", "writer", "output", "data", "obj", "OUT", "target", "b", "point", "inc", "client", "name", "file"], "source": ["slave", "use", "project", "channel", "Source", "view", "proxy", "service", "scope", "input", "self", "ource", "copy", "from", "slice", "sync", "dest", "unit", "ie", "connection", "storage", "clone", "server", "component", "get", "size", "settings", "sl", "iter", "i", "SOURCE", "start", "sin", "writer", "ssl", "se", "reader", "secure", "ources", "target", "null", "parent", "stream", "client", "src", "core", "origin"], "destination": ["testinated", "declification", "destinations", "testinator", "declination", " destinator", " destining", "declinator", "Destinations", "destinator", "contining", "Destinator", "dependification", "Destination", "destinated", "destification", "Destinated", "destining", "testination", "dependination", "dependinated", "contination", " destinated", "Destification", "continated", "testinations", "Destining", "continator", "dependinator", " destinations", "declinated"]}}
{"id1": "338852", "id2": "12883117", "code1": "    public static void sort(float norm_abst[]) {\n        float temp;\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 7; j++) {\n                if (norm_abst[j] > norm_abst[j + 1]) {\n                    temp = norm_abst[j];\n                    norm_abst[j] = norm_abst[j + 1];\n                    norm_abst[j + 1] = temp;\n                }\n            }\n        }\n        printFixed(norm_abst[0]);\n        print(\" \");\n        printFixed(norm_abst[1]);\n        print(\" \");\n        printFixed(norm_abst[2]);\n        print(\" \");\n        printFixed(norm_abst[3]);\n        print(\" \");\n        printFixed(norm_abst[4]);\n        print(\" \");\n        printFixed(norm_abst[5]);\n        print(\" \");\n        printFixed(norm_abst[6]);\n        print(\" \");\n        printFixed(norm_abst[7]);\n        print(\"\\n\");\n    }\n", "code2": "    public PhoneSetImpl(URL url) throws IOException {\n        BufferedReader reader;\n        String line;\n        phonesetMap = new HashMap();\n        reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        line = reader.readLine();\n        lineCount++;\n        while (line != null) {\n            if (!line.startsWith(\"***\")) {\n                parseAndAdd(line);\n            }\n            line = reader.readLine();\n        }\n        reader.close();\n    }\n", "label": 0, "substitutes": {"sort": ["cmp", "g", "func", "transform", "desc", "search", "norm", "ort", "num", "print", "scale", "order", "asc", "replace", "rank", "array", "index", "iter", "comp", "f", "by", "split", "format", "parse", "type", "Sort", "info", "round"], "norm_abst": ["norm_absc", "norm_acst", "norm_Absc", "norm_appste", "norm_abbST", "norm_abssp", "norm_abnt", "norm_AbST", "norm_avST", "norm_acsc", "norm_abbsc", "norm_obST", "norm_absp", "norm_abST", "norm_avsc", "norm_avste", "norm_obst", "norm_ubest", "norm_avst", "norm_appst", "norm_abssc", "norm_absstd", "norm_absst", "norm_ubste", "norm_absest", "norm_abssts", "norm_acste", "norm_avsp", "norm_absstr", "norm_appsc", "norm_obste", "norm_bsts", "norm_Absp", "norm_absST", "norm_obsp", "norm_ubst", "norm_bst", "norm_obost", "norm_ubST", "norm_bST", "norm_obsts", "norm_ubsc", "norm_absnt", "norm_bste", "norm_abstr", "norm_abstd", "norm_abste", "norm_acnt", "norm_afsc", "norm_afST", "norm_absste", "norm_Absts", "norm_acST", "norm_afsp", "norm_avsts", "norm_Abost", "norm_abbnt", "norm_ubstr", "norm_obstd", "norm_obsc", "norm_obest", "norm_Abstr", "norm_avost", "norm_abost", "norm_ubstd", "norm_absts", "norm_obstr", "norm_abbst", "norm_Abst", "norm_acsp", "norm_appsts", "norm_afst", "norm_afstr", "norm_abest"], "temp": ["n", "c", "current", "cache", "clean", "k", "str", "frac", "partial", "z", "modified", "num", "length", "count", "weight", "p", "alpha", "adj", "default", "w", "base", "tmp", "x", "tem", "now", "mag", "fake", "f", "iter", "flat", "value", "pre", "emp", "var", "tc", "v", "result", "test", "output", "Temp", "data", "diff", "stable", "style", "null", "beta", "alt", "t", "const"], "i": ["iu", "si", "qi", "ip", "u", "ini", "ii", "c", "m", "pi", "g", "y", "ci", "di", "api", "z", "ji", "ui", "ri", "bi", "p", "l", "I", "fi", "x", "index", "f", "oi", "li", "ind", "ni", "v", "gi", "mi", "ai", "b", "xi", "id", "ix", "ik", "ij"], "j": ["jet", "fr", "oj", "js", "qi", "section", "u", "k", "ii", "n", "pr", "dj", "py", "y", "o", "g", "c", "d", "ij", "J", "z", "jo", "ji", "ui", "jj", "jit", "p", "br", "uj", "l", "x", "f", "li", "q", "ind", "ja", "v", "next", "jp", "bj", "obj", "b", "xi", "job", "jc", "aj", "jl"]}}
{"id1": "14194234", "id2": "11377441", "code1": "    private String File2String(String directory, String filename) {\n        String line;\n        InputStream in = null;\n        try {\n            File f = new File(filename);\n            System.out.println(\"File On:>>>>>>>>>> \" + f.getCanonicalPath());\n            in = new FileInputStream(f);\n        } catch (FileNotFoundException ex) {\n            in = null;\n        } catch (IOException ex) {\n            in = null;\n        }\n        try {\n            if (in == null) {\n                filename = directory + \"/\" + filename;\n                java.net.URL urlFile = ClassLoader.getSystemResource(filename);\n                if (urlFile == null) {\n                    System.out.println(\"Integrated Chips list file not found: \" + filename);\n                    System.exit(-1);\n                }\n                in = urlFile.openStream();\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            StringBuffer xmlText = new StringBuffer();\n            while ((line = reader.readLine()) != null) {\n                xmlText.append(line);\n            }\n            reader.close();\n            return xmlText.toString();\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"Integrated Chips list file not found\");\n            System.exit(-1);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n        return null;\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"File2String": ["FileToStr", "File2string", "file4String", "File2Line", "Filetostring", "FiletoLine", "File4Line", "file4Line", "File4Str", "file4string", "FileToString", "file2String", "FileTostring", "file4Str", "File4String", "file2Str", "FiletoStr", "file2Line", "File2Str", "FiletoString", "FileToLine", "file2string", "File4string"], "directory": ["folder", "resource", "txt", "application", "root", "section", "library", "project", "description", "environment", "d", "path", "manager", "division", "database", "Directory", "mode", "dir", "archive", "document", "connection", "storage", "prefix", "location", "system", "office", "category", "python", "direct", "password", "direction", "module", "uri", "source", "collection", "file"], "filename": ["folder", "File", "txt", "il", "inline", "resource", "route", "token", "username", "description", "SourceFile", "string", "utf", "href", "sf", "xml", "title", "Filename", "language", "layer", "path", "fil", "sequence", "jo", "files", "database", "summary", "download", "rl", "ppa", "fn", "l", "document", "connection", "prefix", "ename", "phrase", "url", "location", "loader", "FILE", "dll", "figure", "journal", "password", "fp", "nil", "ssl", "metadata", "kl", "uri", "source", "binary", "collection", "name", "which", "file"], "line": ["entry", "row", "ml", "ip", "string", "word", "LINE", "ine", "xml", "str", "comment", "character", "le", "Line", "log", "feed", "char", "key", "letter", "unit", "cl", "l", "liner", "part", "base", "frame", "lin", "pe", "cell", "rule", "url", "link", "iter", "e", "code", "len", "li", "nl", "page", "next", "se", "type", "write", "data", "parse", "en", "id", "source", "buffer", "text", "ace", "name", "file", "lc", "end"], "in": ["fa", "resource", "In", "or", "inas", "token", "again", "ini", "n", "c", "IN", "include", "cin", "o", "ex", "reading", "is", "din", "inner", "bin", "fin", "input", "as", "io", "pin", "ins", "conn", "min", "inn", "into", "err", "kin", "it", "l", "part", "init", "win", "rin", "lin", "out", "connection", "isin", "url", "get", "x", "gin", "index", "thin", "i", "nin", "a", "socket", "login", "arin", "vin", "r", "b", "en", "inc", "id", "source", "stream", "src", "file"], "f": ["fa", "df", "File", "fe", "folder", "fr", "F", "fc", "n", "c", "sf", "d", "fin", "fo", "fx", "func", "fd", "feed", "this", "fn", "p", "fs", "l", "tf", "w", "out", "x", "e", "fm", "i", "h", "fp", "inf", "v", "fen", "fl", "b", "fb", "t", "lf", "bf", "info", "file"], "urlFile": ["resourceFile", "systemPath", " urlContent", "resourceContent", "URLInfo", "viewFile", "urlInfo", "urlPath", "urlLine", " urlPath", "URLLine", " urlLine", "URLFolder", "systemLine", "UrlFile", "UrlFolder", "UrlLine", " urlInfo", "resourceUrl", " urlFolder", "resourcePath", "resourceLine", "viewUrl", "systemUrl", "urlUrl", "viewfile", "URLFile", "resourcefile", "viewContent", " urlfile", " urlUrl", "systemFile", "urlfile", "UrlInfo", "urlContent", "urlFolder"], "reader": ["row", "ger", "ry", "over", "reading", "oder", "inner", "ler", "input", "layer", "io", "ner", "feed", "driver", "ri", "er", "handler", "cher", "bird", "l", "rc", "out", "server", "loader", "read", "Reader", "rer", "per", "iter", "i", "editor", "writer", "result", "rr", "r", "rar", "parser", "buffer", "stream", "rx", "uri", "builder", "file"], "xmlText": ["phpText", "xmlString", "xmlBuffer", "mlString", "xmlTEXT", "urlText", " xmltext", "urlTEXT", "phpTEXT", " xmlBuffer", "phptext", "jsonText", "mlData", "jsonData", " xmlData", "mlText", "jsonBuffer", "phpData", " xmlString", "jsonTEXT", "xmlData", "urlData", " xmlTEXT", "urlString", "mltext", "xmltext", "mlBuffer", "mlTEXT"]}}
{"id1": "88047", "id2": "12766394", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "6906419", "id2": "4118412", "code1": "    public static String encryptPassword(String password) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA1\");\n            digest.update(password.getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                int halfbyte = (hash[i] >>> 4) & 0x0F;\n                int two_halfs = 0;\n                do {\n                    if ((0 <= halfbyte) && (halfbyte <= 9)) {\n                        buf.append((char) ('0' + halfbyte));\n                    } else {\n                        buf.append((char) ('a' + (halfbyte - 10)));\n                    }\n                    halfbyte = hash[i] & 0x0F;\n                } while (two_halfs++ < 1);\n            }\n            return buf.toString();\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["encratepassword", "encrateString", "encryptHash", "decryptHash", "encryptString", "encipherHash", "enccryptpassword", "decipherPassword", "decryptPassword", "encrateHash", "decryptString", "encryptpassword", "enccryptString", "encratePassword", "enccryptPassword", "encipherPassword", "enccryptHash", "decipherHash", "encipherString", "decipherString", "decryptpassword", "decipherpassword", "encipherpassword"], "password": ["pass", "token", "words", "username", "sword", "seed", "project", "string", "word", "secret", "input", "Password", "PASS", "path", "key", " passwords", "auth", "database", "wd", "user", "content", "address", "p", "prefix", "phrase", "confirmed", "array", "data", "message", "pattern", "buffer", "crypt", "text", "name", "padding"], "digest": ["signEST", "diffester", "hashest", "initest", "Digeter", " diger", "digText", " digText", " digests", "diffest", "Digester", "signest", "Digested", "digeter", " digEST", "digester", "digested", "signer", "DigEST", " digester", " digested", "signester", "hasher", "diffested", "hashester", "initests", "initEST", " digeter", "digEST", "Diger", "diger", "Digests", "initText", "diffEST", "digests", "hasheter", "Digest", "DigText"], "hash": ["body", "bh", "hed", "sh", "map", "cache", "history", "Hash", "secret", "cover", "bin", "sha", "sum", "log", "search", "wave", "match", "hex", "key", "char", "number", "ashes", "auth", "address", "header", "bug", "build", "count", "batch", "kh", "ha", "url", "query", "ash", "array", "f", "block", "index", "code", "value", "image", "h", "check", "handle", "filter", "memory", "html", "diff", "error", "id", "message", "buffer", "mask", "version"], "buf": ["bh", "bu", "nb", "aux", "vec", "cmp", "ob", "cas", "append", "pb", "cv", "abc", "src", "bin", "func", "conv", "ctx", "box", "queue", "la", "uv", "pad", "ab", "abb", "bag", "fw", "out", "tmp", "builder", "coll", "url", "cur", "port", "config", "bc", "sb", "Buffer", "f", "af", "pkg", "home", "uf", "cap", "vr", "uc", "fp", "cb", "v", "bb", "runner", "img", "data", "Buff", "b", "fb", "buff", "ba", "bf", "uber", "buffer", "wb", "va", "rb", "db"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "n", "ii", "c", "ini", "pi", "o", "d", "abi", "ci", "di", "io", "key", "slice", "ji", "ui", "length", "ri", "count", "ie", "p", "it", "l", "phi", "init", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "a", "h", "v", "gi", "ti", "mini", "type", "ai", "b", "xi", "id", "info", "uri", "ix", "mu", "uni"], "halfbyte": ["littlebyte", "Halfbit", "thirdsecond", "halfchar", " halfurl", "halfreference", "thirdbyte", "quarterbytes", "HalfByte", "quartersecond", "littlebit", "superbyte", " halfchar", "wardbytes", "halfabyte", "halfnumber", "quarterbyte", "sidebyte", "Halfchar", "littleByte", "postbyte", " halfbytes", "sidereference", " halfsecond", "superbit", "postbit", "halfsecond", "Halfbyte", "halfByte", "halfbytes", " halfreference", "halfurl", "quarternumber", "sideByte", "wardbyte", " halfByte", " halfabyte", "quarterByte", "sidebit", "thirdnumber", "halfbit", " halfbit", "littlereference", "superchar", "postabyte", "quarterurl", "wardurl", "quarterbit", " halfnumber", "quarterabyte"], "two_halfs": ["two_Halfbytes", "two_commonows", "two_Halfs", "two_Halfrows", "two_hations", "two_thirdrows", "two_commonrows", "two_hatrows", "two_halfions", "two_thirdis", "two_hats", "two_thirds", "two_quarterows", "two_thirdbytes", "two_halfbytes", "two_partrows", "two_Halfis", "two_quarterrows", "two_quarters", "two_partis", "two_commons", "two_commonions", "two_halfrows", "two_quarterions", "two_parts", "two_partbytes", "two_halfows", "two_halfis", "two_hatows"]}}
{"id1": "11484416", "id2": "4686922", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"moveFile": ["moveDirectory", "moveFiles", " movedFile", " movePath", "movePath", " moveDirectory", " movedPath", "MovePath", "MoveFile", "MoveDirectory", " movedFiles", "MoveFiles", " movedDirectory", " moveFiles"], "orig": ["folder", "temp", "ctr", "exe", "raid", "proxy", "bin", "imag", "Orig", "old", "copy", "raf", "transform", "prev", "org", "buf", "dest", "impl", "coord", "original", "archive", "loc", "build", "comb", "frame", "init", "base", "tmp", "coll", "array", "f", "iter", "bas", "real", "ori", "home", "internal", "image", "remote", "ext", "img", "obj", "id", "info", "source", "src", "rb", "file", "origin"], "target": ["resource", "temp", " Target", "external", "project", "join", "current", "copy", "path", "manager", "platform", "match", "force", "this", "dest", "arget", "compatible", "object", "original", "ret", "archive", "template", "build", "it", "base", "replace", "tmp", "f", "eth", "auto", "format", "Target", "to", "remote", "result", "nt", "next", "reference", "t", "prot", "parent", "source", "master", "origin"], "buffer": ["resource", "position", "cache", "request", "uffer", "padding", "bin", "input", "copy", "layer", "wave", "feed", "sequence", "buf", "queue", "slice", "length", "content", "repeat", "address", "header", "batch", "frame", "base", "url", "read", "Buffer", "iter", "code", "bytes", "transfer", "result", "bb", "data", "write", "raw", "null", "b", "stack", "buff", "message", "source", "binary", "block", "file", "reference"], "bread": ["fe", "robe", "fee", "raft", "brew", "zip", "zero", "bat", "piece", "wen", "broken", "str", "buck", "abi", "beat", "bare", "feed", "key", "fle", "die", "bn", "design", "num", "cook", "div", "length", "inn", "bee", "eb", "good", "batch", "grain", "fine", "hello", "choice", "rib", "ffe", "wake", "circ", "fred", "bc", "fed", "fen", "four", "meal", "bb", "rub", "ble", "food", "fall", "fif", "web", "knife", "loop", "sleep", "cake", "width", "rows"], "fis": ["afIs", "lfis", "qos", "fxisa", "afis", "fxis", "his", "lfos", "qiss", "fils", " fIs", "qis", "fIs", " fiss", "ufos", "lfIs", "ufiss", "afiss", "ufis", "hIs", "fisa", "lfiss", " fils", "qils", "hisa", "afos", "fxIs", "fiss", " fisa", "hos", "ufils", "fxos"], "fos": ["Fros", "Foses", "flens", "flos", "fose", "gos", " foses", "infos", " fose", "gis", "infois", "goss", "faos", "Fors", "flors", "fros", "floses", "flose", "fens", "flois", "infors", "Fose", "flaos", "Fis", "Fois", "infaos", "foses", "Fos", "fois", "Foss", "Faos", " fros", " foss", "fors", "foss", " fens", "gros", "Fens"]}}
{"id1": "9796161", "id2": "16556717", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"getMD5": ["getHTMLHash", " getMDHash", " getSHAHash", "getMD512", "getSHA5", " getSHA5", " getSHA512", " getMD4", " getMD512", "getHTML5", "getmdHash", "getHTML4", "getmd5", "getMD4", "getHTML512", " getSHA4", "getmd4", "getMDHash", "getSHAHash", "getmd512", "getSHA512", "getSHA4"], "s": ["js", "si", "S", "ings", "ses", "ms", "bs", "g", "string", "n", "c", "lines", "sym", "str", "sets", "scripts", "gs", "is", "self", "input", "abs", "os", "styles", "sync", "in", "p", "ates", "l", "tests", "strings", "ls", " ads", "als", "its", "ws", "sb", "services", "f", "e", "cs", "i", "ns", "ds", "a", "bytes", "v", "ssl", "ts", "ips", "ows", "data", "parts", "b", "comments", "ps", "es", "rs", "source", "ends", " fails", "ss"], "m": ["ms", "pm", "ym", "wm", "cm", "rm", "mac", "im", "em", "c", "mand", "sm", "um", "d", "hm", "manager", "mr", "om", "M", "vm", "p", "l", "mc", "man", "f", "machine", "e", "fm", "am", "i", "arm", "gm", "h", "dm", "mut", "v", "nm", "mi", "md", "module", "mm", "t", "tm", "me", "mu", "bm"]}}
{"id1": "14168494", "id2": "16825994", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyClass", " copyfile", " copyFiles", "transferFile", " copiedfile", " copiedFile", "copyfile", " copyClass", "transferFiles", "copyFiles", " copiedClass", "transferClass", " copiedFiles", "transferfile"], "dest": ["resource", "txt", "temp", "done", "class", "dist", "d", "destroy", " Dest", "desc", "path", "this", "dir", "loc", "sup", "comb", "orig", "out", "tmp", "Dest", "transfer", "st", "output", "data", "true", "obj", "target", "null", " destination", "source", "wb", "name", "later", "file"], "src": ["dist", "bin", "master", "copy", "inst", "sc", "slice", "sync", "download", "loc", "sup", "sq", "gb", "s", "rc", "storage", "rob", "tmp", "upload", "url", "config", "sb", "sl", "ds", "filename", "split", "sin", "Dest", "cb", "ssl", "img", "st", "target", "sub", "sit", "source", "stream", "sel", "rb", "file"], "srcChannel": [" srcCh", "inputSection", "srcChan", " srcStream", "rcStream", "srcConnection", "srcchannel", "distCh", "inputChannel", "distChan", "destChannel", "srcButton", "destchannel", "rcButton", "destConnection", "sourceButton", "rcChan", "srcStream", "destChan", " srcConnection", " srcButton", " srcChan", "srcSection", "sourcechannel", " srcchannel", "rcCh", "rcChannel", "rcchannel", " srcSection", "sourceChannel", "distStream", "rcSection", "rcConnection", "srcCh", "inputConnection", "inputchannel", "sourceChan", "distChannel"], "dstChannel": ["dstConnection", "dstContext", " dstsChannel", "ddestchannel", "dstStream", "ddestConnection", "ddestContext", " dstschannel", "drcChan", "drcchannel", "drdContext", " drdChan", " dstStream", "dstsConnection", "drdChannel", " dstContext", "DdestChannel", "dDestConnection", "dsrcchannel", " drdContext", "drcVideo", "drdchannel", "ddestVideo", "drdChan", "dsrcChannel", "dstVideo", "DdestVideo", "ddestStream", "DstVideo", "drcChannel", "ddestChan", " dstchannel", "ddestChannel", "dDestchannel", " drdchannel", "dstsChannel", "dDestChannel", "dstChan", "dstsStream", " dstsStream", "dsrcVideo", " dstConnection", "dstchannel", " dstsConnection", "Dstchannel", "Ddestchannel", "drcContext", " drdChannel", "dstschannel", "dDestStream", "DstChannel", " dstChan"]}}
{"id1": "7169984", "id2": "14609912", "code1": "    public static String connRemote(JSONObject jsonObject, String OPCode) {\n        String retSrc = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(AZConstants.validateURL);\n            HttpParams httpParams = new BasicHttpParams();\n            List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>();\n            nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode));\n            nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString()));\n            httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair));\n            httpPost.setParams(httpParams);\n            HttpResponse response = httpClient.execute(httpPost);\n            retSrc = EntityUtils.toString(response.getEntity());\n        } catch (Exception e) {\n            Log.e(TAG, e.toString());\n        }\n        return retSrc;\n    }\n", "code2": "    private static String lastModified(URL url) {\n        try {\n            URLConnection conn = url.openConnection();\n            return long2date(conn.getLastModified());\n        } catch (Exception e) {\n            SWGAide.printDebug(\"cach\", 1, \"SWGCraftCache:lastModified: \" + e.getMessage());\n        }\n        return \"0\";\n    }\n", "label": 0, "substitutes": {"connRemote": ["invokeIP", "invokeRemote", " executeIP", "invokeLocal", "execURL", " execRemote", " executeURL", "execLocal", " execURL", " executeLocal", " execIP", "invokeURL", "execIP", " execLocal", " executeRemote", "execRemote"], "jsonObject": ["JSONObject", "customOperation", "JSONOperation", "javaBody", "JSONString", "javaOb", "jsonObj", "jsonOb", "jsonOperation", "httpArray", " jsonString", "jsonArray", "JSONBody", "JSONOb", "JSONObj", " jsonBody", "javaString", "customObj", "jsonBody", "jsonString", "javaObject", "customArray", "httpObject", " jsonOb", "httpOperation", "customObject", "JSONArray", "httpObj"], "OPCode": ["OPAction", "OPERName", "opName", "OPcode", "OpAction", " OPAction", "OPERCode", "opAction", "OPName", "opCode", "OpCode", "OpName", "opcode", " OPcode", " OPName", "Opcode", "OPERcode"], "retSrc": ["retDuc", "retDrt", "retSvc", "retNRC", "retInuc", "retInRC", " retDsrc", "RetAsuc", "retSrt", "RetSrc", " retSvc", "retOsrc", " retDRC", "retInck", "retPRC", "retNvc", "retAsrc", "retOsrt", "retSck", "retAsRC", "retDrc", "retSsrc", "retNsrc", "retOssrc", "retDRC", "RetAsck", " retDrc", "retAsuc", "retPvc", "retSuc", "retSRC", "retPsrc", "retOsRC", "RetAsrc", "RetAsRC", "retNrt", "retAsck", "retDsrc", " retSsrc", "RetSRC", " retSrt", "retNrc", " retSRC", " retDrt", "retInrc", "RetSuc", "retPrc", "retDck", "RetSck"], "httpClient": ["httpsPost", "httpsCall", "xmlProxy", "phpPost", "HttpClient", "httpProxy", "httpCase", "httpConnection", " httpConnection", "phpClient", "apiClient", "xmlCase", "httpclient", "httpCall", "HttpCase", "apiCall", "httpsClient", "xmlClient", "HttpProxy", "HttpConnection", "phpclient", "apiclient", "xmlConnection", "httpsclient", "phpCall", " httpCase", " httpProxy", "apiPost"], "httpPost": ["workpost", "httpsPost", "HttpRequest", "workPre", "htmlCopy", "httpCopy", "phpPost", "httppost", "httpPOST", "autoPOST", "httpDo", "webpost", "webDo", " httpCopy", "htmlDo", "webPost", "HttpPOST", "httpPre", " httpDo", " httppost", "httpsCopy", "autoPre", "phpPOST", "HttpPre", " httpRequest", " httpPOST", "webPre", "httpRequest", "httpsPOST", "HttpPost", " httpPre", "autoCopy", "workDo", "HttpCopy", "autoPost", "htmlPost", "HttpDo", "httpsPre", "htmlPOST", "phpDo", "workPost", "phpRequest"], "httpParams": ["httpVariam", " httpPams", "httpVariams", "httpVariars", "httpPms", " httpParam", "httpParars", "httpVariums", "hrPams", "httpParam", "hrParams", "httpPerars", "httpPam", "hrParars", "httpArgam", "hrParam", "httpPars", "httpCatam", "httpPams", " httpParars", "httpPums", "hrPam", "httpPeram", "httpArgams", "httpArgars", "httpPerums", "httpCatars", "hrParms", "httpParms", " httpPums", " httpParums", "httpCatams", "hrPars", " httpPam", "httpParums", "httpPerams", "httpCatms", " httpPars", "httpArgms", "hrPms"], "nameValuePair": ["nameValueProtore", "nameValueParair", "nameValuepatch", "nameValueCpair", "nameValuePerair", "nameValueSore", "nameValuePore", "nameValueLair", "nameValuePhair", "nameVPpair", "nameValueCair", "nameValueLolder", "nameValuePointpair", "nameValuePpair", "nameValueSpair", "nameNameProtpair", "nameValueFortion", "nameNamePatch", "nameNameProtair", "nameNamePiece", "nameValuePhiece", "nameNamePolder", "nameVCait", "nameValueSair", "nameVPait", "nameNameProtore", "nameValueportion", "nameValuePhortion", "nameValueppair", "nameValueParpair", "nameValuePointair", "nameValuepair", "nameValuePatch", "nameValueLatch", "nameValuePait", "nameValuePortion", "nameVCpair", "nameValuepolder", "nameNameportion", "nameValueCait", "nameNamePortion", "nameNameLolder", "nameNamePore", "nameValueProtpair", "nameValuePolder", "nameValuePerolder", "nameValuepait", "nameValuePenter", "nameValuePointenter", "nameNameLair", "nameVCair", "nameValueProtair", "nameNamepair", "nameValuepiece", "nameValueFiece", "nameNamepiece", "nameNamePenter", "nameValuePeratch", "nameValueFair", "nameNameLatch", "nameValuePiece", "nameNamePair", "nameValueProtenter", "nameValueSenter", "nameVPair", "nameValuePointore", "nameNamePpair", "nameValueParait", "nameNameProtenter"], "response": ["Response", "resource", "jet", "application", "status", "entity", "full", "respond", "site", "environment", "channel", "reply", "request", "http", "method", "view", "api", "wave", "feed", "tree", "json", "object", "resp", "connection", "server", "throw", " Response", "f", "block", "e", "session", "i", "success", "res", "result", "page", "v", "output", "data", "message", "body"]}}
{"id1": "3683344", "id2": "14820302", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"genRandomGUID": [" genRandGIP", " genRandomGUIP", " genRandUID", " genRandUUID", " genRandomGID", " genRandGUID", " genRandomGuid", " genRandomUuid", " genRandomIGID", " genRandomUUID", " genRandGID", " genRandomGUuid", " genRandomUIP", " genRandomGIP", " genRandUuid", " genRandomGUUID", " genRandomUID", " genRandomIGUID", " genRandomIGIP", " genRandomIGuid", " genRandUIP", " genRandGuid"], "secure": ["timeout", "seed", "zip", "exclusive", "host", "secret", "depth", "str", "proxy", " Secure", "safe", "fast", "Secure", "protect", "https", "force", "sensitive", "sys", "active", " insecure", "random", "weak", "server", "security", "config", "sec", "session", "allow", "password", "q", "close", "remote", "ssl", "stable", "require", "forced", "debug", "deep", "client", "ssh", "encrypted", "smart"], "valueBeforeMD5": ["valueBeforeMR85", "valueBeforeMP2", "valueBeforeMC8", "valueBeforeM3", "valueBeforeAMD3", "valueBeforeMC5", "valueBeforeMR5", "valueAfterMD85", "valueBeforeMT3", "valueBeforeMT55", "valueBeforeMD55", "valueBeforeSHA5", "valueBeforeMD3", "valueAfterMD3", "valueBeforeMS5", "valueBeforeMT2", "valueAfterMC5", "valueBeforeMT05", "valueBeforeAMD05", "valueBeforeMR8", "valueAfterMD05", "valueBeforeMS1", "valueAfterMC8", "valueBeforeMT5", "valueBeforeMD85", "valueBeforemd5", "valueBeforeSHA3", "valueAfterMS5", "valueBeforeMD2", "valueBeforeMC85", "valueAfterMS2", "valueAfterMD55", "valueAfterMC3", "valueBeforeMD1", "valueAfterMD2", "valueBeforeM1", "valueBeforeMP5", "valueBeforeMD8", "valueAfterMS3", "valueAfterMC85", "valueBeforeSHA2", "valueBeforeMR3", "valueBeforeAMD5", "valueBeforemd85", "valueBeforemd3", "valueBeforeAMD20", "valueBeforeMS2", "valueBeforeM5", "valueAfterMS1", "valueBeforeMD20", "valueBeforeMP3", "valueAfterMD8", "valueBeforeM2", "valueBeforeMC3", "valueBeforeMT20", "valueBeforemd8", "valueBeforeMD05", "valueBeforeMS3", "valueBeforeSHA1", "valueAfterMD1", "valueAfterMD20", "valueBeforeMP55"], "valueAfterMD5": ["valueAfterMFTE", "valueAfterASTody", "valueAfterDM5", "valueAfterMT3", "valueAfterAST5", "valueBeforeMD3", "valueAfterMD3", "valueAfterHTMLody", "valueAfterDM3", "valueAfterMT5", "valueAfterGM3", "valueAfterAST005", "valueBeforeVM3", "valueAfterMC1", "valueAfterMF5", "valueAfterM1", "valueBeforeMP3", "valueAfterDF005", "valueAfterAST512", "valueBeforeMD005", "valueAfterVM005", "valueAfterVM3", "valueBeforeMC5", "valueAfterMC2", "valueAfterDMody", "valueBeforeAST3", "valueAfterAMD5", "valueAfterAST2", "valueAfterHTML512", "valueAfterDM512", "valueBeforeMDTE", "valueBeforeMDody", "valueBeforeMDql", "valueAfterMD2", "valueAfterAMD005", "valueAfterAMD3", "valueAfterMPTE", "valueAfterMDTE", "valueBeforeVM5", "valueAfterMP2", "valueAfterM3", "valueBeforeMPTE", "valueBeforeMC3", "valueAfterDF5", "valueBeforeMP1", "valueAfterHTML5", "valueBeforeVM005", "valueAfterVM5", "valueBeforeMD05", "valueAfterM2", "valueBeforeASTody", "valueAfterGM005", "valueBeforeAST005", "valueAfterMD512", "valueAfterMDody", "valueBeforeMD512", "valueAfterAST3", "valueAfterMF3", "valueAfterMD05", "valueBeforeMD2", "valueBeforeAST2", "valueBeforeAST5", "valueAfterMD005", "valueAfterHTMLTE", "valueAfterM5", "valueAfterHTML3", "valueAfterMF05", "valueAfterMD1", "valueBeforeMP2", "valueAfterMP5", "valueAfterMP005", "valueAfterGM2", "valueAfterMCql", "valueAfterMC5", "valueBeforeMCql", "valueAfterDF3", "valueAfterMP3", "valueAfterMC3", "valueBeforeMD1", "valueAfterGM5", "valueBeforeAST512", "valueAfterMDql", "valueBeforeMP5", "valueAfterMP1", "valueAfterHTML05", "valueAfterMTql", "valueAfterMP05", "valueBeforeMP05"], "md5": ["MD25", "cmd05", "mand2", "mand5", "MD2", "amd512", " md25", "cmd65", "mandkey", " md65", "MD5", " MD3", "amd25", "cmd53", " md53", "md2", "cmd2", "cmd3", " md05", "md53", "mdkey", "md05", " MD53", " md2", " MD5", " MD05", "md1", "mand65", "md65", "md512", "cmd512", "mand3", " md512", "mand1", "cmdkey", " md1", "MD512", "amd2", "md3", " mdkey", "mand512", "cmd1", "amd5", " md3", "md25", "cmd5"], "sbValueBeforeMD5": ["sbValueBeforeAMD25", "sbValueBeforeND85", "sbValueBeforeMP85", "sbValueBetweenMD305", "sbValueInsideAMD5", "sbValueAfterMD005", "sbValuebeforeND2", "sbValueBehindND25", "sbValueBeforeMP512", "sbValueBeforeMT5", "sbValueBeforeMM5", "sbValueBeforeMD005", "sbValueBeforeMP1", "sbValueAfterMP005", "sbValueBeforeMG5", "sbValueInsideMD25", "sbValueBeforeND3", "sbValueAfterMP55", "sbValueBeforeMR3", "sbValueAfterMD5", "sbValueBeforeAMD3", "sbValuebeforeMD85", "sbValueBeforeND5", "sbValueBeforeMP55", "sbValueBeforeMT55", "sbValueBeforeMP3", "sbValueBetweenmd2", "sbValueBeforeMD2", "sbValueBetweenMD3", "sbValueBeforeMD512", "sbValueWithoutMF5", "sbValueBeforemd3", "sbValueBeforeMF25", "sbValueBetweenMD2", "sbValueBeforeMP5", "sbValueBeforeMC25", "sbValueBeforeMF35", "sbValueBetweenmd305", "sbValueBeforeMR25", "sbValueWithoutMF35", "sbValuebeforeND85", "sbValueBeforeND25", "sbValueBeforeMP25", "sbValueBeforeMC5", "sbValueInsideMD3", "sbValueBeforeMM3", "sbValueBeforemd305", "sbValueBehindND3", "sbValueBeforeMP2", "sbValueBeforeAMD305", "sbValueBehindND525", "sbValueBeforeMR525", "sbValueBeforeMM005", "sbValueAfterMD3", "sbValueBeforeND2", "sbValueBeforeAMD2", "sbValueBehindMD25", "sbValueAfterMP5", "sbValueBehindMD3", "sbValueBehindMD525", "sbValueBeforeMD1", "sbValueBeforeMD85", "sbValueInsideAMD25", "sbValueBeforeMF3", "sbValueWithoutMD3", "sbValueBeforeMD05", "sbValueBeforeMD25", "sbValueBeforeMP05", "sbValueBeforeMT3", "sbValueBeforeMD55", "sbValueBeforeMC3", "sbValueBeforeND525", "sbValueBeforeMS1", "sbValueBeforeMS2", "sbValueBeforeMG3", "sbValueAfterMD512", "sbValueAfterMP512", "sbValuebeforeMD2", "sbValuebeforeMD5", "sbValueBeforeMR5", "sbValueWithoutMF3", "sbValueBeforeMP305", "sbValueBetweenMD5", "sbValueBeforemd05", "sbValueBeforemd2", "sbValueInsideAMD3", "sbValueBeforeMM55", "sbValueBeforeMS512", "sbValueBeforemd5", "sbValueAfterMP1", "sbValuebeforeND3", "sbValueBeforemd25", "sbValueBeforeMT005", "sbValueWithoutMF25", "sbValueBeforeMF5", "sbValueBehindND5", "sbValueBeforeMP525", "sbValuebeforeMD3", "sbValueWithoutMD25", "sbValueBeforeMS5", "sbValueWithoutMD35", "sbValueBetweenmd5", "sbValueBeforeMD35", "sbValueBeforeAMD05", "sbValueBeforeMG25", "sbValueBeforeMS3", "sbValueBeforeMD305", "sbValueBeforeMP005", "sbValueInsideMD05", "sbValuebeforeND5", "sbValueInsideAMD05", "sbValueBetweenmd3", "sbValueAfterMD55", "sbValueBeforeAMD5", "sbValueBeforeAMD512", "sbValueBeforeMG35", "sbValueBeforeMD525", "sbValueBeforeAMD1", "sbValueInsideMD5", "sbValueAfterMD1", "sbValueBeforeMD3", "sbValueAfterMP3", "sbValueBehindMD5", "sbValueWithoutMD5", "sbValueBeforeMC35", "sbValueBeforeMS85"], "time": ["timeout", "temp", "etime", "seed", "speed", "times", "host", "hour", "depth", "version", "money", "delay", "cost", "year", "length", "mode", "random", "tz", "count", "age", "month", "rate", "port", "work", "clock", "size", "name", "date", "TIME", "value", "q", "start", "counter", "ime", "type", "error", "duration", "id", "timer", "race", "sleep", "Time"], "rand": ["rss", "root", "seed", "clean", "rh", "raid", "depth", "dist", "version", "winner", "right", "delay", "core", "year", "rage", "bit", "length", "random", "pick", "bug", "count", "alpha", "rule", "ng", "ro", "order", "win", "rc", "rate", "reg", "max", "dr", "Rand", "rank", "index", "serial", "nd", "q", "range", "error", "type", "rr", "r", "risk", "id", "pattern", "round", "mid", "re", "name"], "array": ["row", "integer", "section", "function", "multi", "string", "instance", "cache", "vector", "ray", "view", "table", "expression", "area", "angle", "list", "number", "Array", "database", "pair", "our", "object", "address", "archive", "bug", "sample", "batch", "app", "all", "element", "arr", "now", "index", "air", "value", "feature", "image", "a", "record", "range", "error", "r", "module", "arrow", "collection"], "strTemp": ["objtemp", "strVar", "brVar", "crtemp", "objTemp", "crTemp", "strTem", "strBase", "crTemplate", "brTemp", "stringTem", "arrBase", "stringTemp", "drTemp", "crTem", "arrtemp", "objFake", "strFake", "brTem", "objTem", "brTest", "StrBase", "strtemp", " strFake", "strTemplate", " strtemp", "arrTest", "stringFake", "drTemplate", "brtemp", " strTest", "drtemp", " strBase", "arrTemp", " strVar", "Strtemp", " strTem", "drTem", "drVar", " strTemplate", "stringtemp", "strTest", "arrTem", "StrTemp"], "i": ["hi", "si", "ip", "u", "multi", "n", "ii", "c", "k", "pi", "o", "y", "d", "abi", "ci", "di", "io", "z", "key", "slice", "ji", "ui", "in", "ri", "ie", "p", "l", "phi", "j", "I", "eni", "x", "index", "f", "field", "e", "li", "start", "h", "v", "gi", "ti", "ai", "yi", "b", "xi", "id", "info", "uri", "ix", "mu", "end"]}}
{"id1": "8468859", "id2": "755203", "code1": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"connect": ["run", " reconnect", "host", "select", " connection", "log", "con", "open", "patch", "add", "Connect", "client", "construct", "conn", "on", "boot", "download", "establish", "build", "connection", "init", "exec", "find", "port", "config", "read", "nect", "stop", "bind", "socket", "close", "start", "stat", "login", "write", "en", "sign", "connected", " disconnect", "create"], "status": ["stage", "temp", "si", "use", "Status", "speed", "full", "current", "step", "str", "version", "state", "continue", "response", "log", "edit", "sync", "skip", "ui", "active", "summary", "progress", "content", "user", "min", "unit", "count", "fail", "server", "wait", "complete", "standard", "index", "session", "code", "success", "stat", "login", "result", "output", "type", "style", "id", "parent", "update", "source", "site"], "reply": ["action", "ping", "vote", "fee", "send", "bot", "respond", "py", "request", "call", "dy", "comment", "state", "response", " response", "answer", "post", "sync", "second", "random", "address", "ret", "count", "resp", "connection", "base", "prefix", "server", "query", "link", "code", "Reply", "repl", "result", "next", "error", "data", "message", "info", "update", "reason"], "isConnected": [" isAcceptable", "isaConnecting", "isaAdapteded", "isAdaptified", "isConnectionified", " isConnectished", " isConnectable", "isaAdaptified", "isFinted", " isAcceptaged", "isconnecteded", "IsConnected", "isConnectished", "isAdapted", "isFinalled", "isaAdapting", "isConnecting", "isaConnected", "isConnectted", " isConnectioned", "isaAdapted", "IsConnectioned", "isFinaged", "isConnectioned", "IsConnections", "isconnectedp", "isNECTished", "isConnectioning", "isConnectionalled", "isaConnectified", " isConnectioning", "isAcceptted", "isaConnecteded", "isConnectaged", "isNECTed", "IsConnectionp", "IsConnectioning", "isFined", "isConnectionished", "isConnectioneded", "isNECTing", " isConnectionalled", "IsConnects", "isconnecteds", "isAcceptable", "isFining", " isConnectaged", "isConnecteded", " isConnectted", "isNECTalled", "isFinable", " isConnectionished", "IsConnectp", "IsConnecting", "isConnects", "isAdapteded", "isConnections", "isConnectalled", "isAccepted", "isConnectable", " isAccepted", "isConnectionp", "isFinished", "isConnectified", " isAcceptted", " isConnecting", " isConnectalled", "isAcceptaged", "isconnecteding", "isAdapting", "isConnectp"]}}
{"id1": "21010945", "id2": "4938100", "code1": "    private static List runITQLQuery(String itqlQuery) throws Exception {\n        String escapedItqlQuery = URLEncoder.encode(itqlQuery, \"UTF-8\");\n        String url = \"http://\" + Config.getProperty(\"FEDORA_SOAP_HOST\") + \":\" + Config.getProperty(\"FEDORA_SOAP_ACCESS_PORT\") + \"/fedora/risearch?type=tuples\" + \"&lang=iTQL\" + \"&format=CSV\" + \"&distinct=on\" + \"&stream=on\" + \"&query=\" + escapedItqlQuery;\n        logger.debug(\"url for risearch query: \" + url);\n        URL urlObject = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) urlObject.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        logger.debug(\"response code: \" + con.getResponseCode());\n        if (con.getResponseCode() != 200 && con.getResponseCode() != 302) {\n            throw new FedoraAccessException(\"Could not access the risearch service at url: \" + url);\n        }\n        ArrayList arrayList = new ArrayList();\n        String inputLine;\n        int counter = 0;\n        while ((inputLine = br.readLine()) != null) {\n            logger.debug(\"reading line:\" + inputLine);\n            if (inputLine.indexOf(\"<html>\") >= 0) {\n                logger.error(\"problem quering the relationship\");\n                throw new Exception(\"Problem querying relationships; probably a bad ITQL query:\" + itqlQuery);\n            }\n            if (counter >= 1 && inputLine.indexOf(\"/\") >= 0 && inputLine.trim().length() > 0) {\n                logger.debug(\"adding line:\" + inputLine);\n                inputLine = inputLine.substring(inputLine.indexOf(\"/\") + 1);\n                arrayList.add(inputLine);\n                logger.debug(\"found relationship to item: \" + inputLine);\n            }\n            counter++;\n        }\n        br.close();\n        logger.debug(\"num relationships found: \" + arrayList.size());\n        return arrayList;\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"runITQLQuery": ["runItQLquery", "runITQLString", "runITQQuery", "runITQRequest", "runITqlString", "runITqlRequest", "runITSQLRequest", "runItQLQuery", "runITQString", "runITQLquery", "runItqlRequest", "runITSQLString", "runITqlQuery", "runItqlString", "runItQLRequest", "runITQquery", "runITqlquery", "runItQLString", "runItqlquery", "runITSQLQuery", "runITSQLquery", "runITQLRequest", "runItqlQuery"], "itqlQuery": ["itsqlRequest", "itsqlStatement", "ItqlString", "itsqlCommand", "itqlCommand", "itsqlquery", "itqlquery", "itQLRequest", "ItqlCommand", "itsqlQuery", "itwlRequest", "itwlquery", "itwlCommand", "itqlString", "ItsqlRequest", "itQLString", "pitSQLQu", "ItqlQuery", "itSQLQu", "ItqlStatement", "itSQLquery", "ItqlRequest", "Itsqlquery", "pitSQLString", "itSQLString", "pitqlQu", "ItsqlQuery", "itqlQu", "ItsqlString", "itQLQuery", "itsqlString", "itwlQuery", "itSQLStatement", "pitSQLquery", "pitqlString", "itqlStatement", "itSQLQuery", "ItsqlCommand", "pitqlQuery", "pitSQLQuery", "itQLquery", "itQLCommand", "ItsqlStatement", "Itqlquery", "itsqlQu", "pitqlquery", "itQLQu", "itqlRequest", "itQLStatement"], "escapedItqlQuery": ["escapedItQLString", "escapedItqlString", "escapedItqRequest", "escapedItqString", "escapedITqlquery", "escapeditqlRequest", "escapedItqlquery", "escapedItQLQu", "escapedItsqlString", "escapedItsqlQu", "escapeditqlString", "escapedITqlQuery", "escapeditqlquery", "escapedItQLquery", "escapedItqQu", "escapedITsqlRequest", "escapedItqlRequest", "escapedItsqlRequest", "escapedItqquery", "escapeditQLQuery", "escapedITsqlquery", "escapedItqlQu", "escapedItsqlquery", "escapeditqlQuery", "escapedItqQuery", "escapedITqlQu", "escapedItQLRequest", "escapeditQLRequest", "escapedITsqlQu", "escapeditQLString", "escapedItsqlQuery", "escapedITqlRequest", "escapedItQLQuery", "escapeditQLquery", "escapedITsqlQuery"], "url": ["resource", "route", "string", "host", "href", "method", "request", "xml", "http", "service", "www", "response", "URL", "path", "ll", "ur", "feed", "Url", "email", "download", "impl", "rl", "address", "build", "lr", "loc", "l", "rule", "connection", "base", "server", "location", "coll", "config", "sl", "f", " URL", "q", "el", "image", "page", "ssl", "html", "obj", "id", "pattern", "uri", "buffer", "large", "org", "name", "file", "lc"], "urlObject": ["urlNumber", "URLOb", "UrlURL", "UrlObject", "urlObj", "Urlobject", "URLObject", "URLobject", "UrlObj", " urlURL", "urlobject", "httpURL", "httpNumber", "httpObject", " urlOb", " urlobject", "UrlNumber", "UrlOb", "httpObj", "urlOb", "urlURL", " urlObj", " urlNumber"], "con": ["ch", "ctrl", "pc", "ver", "fc", "cm", "acon", "c", "Connection", "http", "cons", "Conn", "inner", "func", "conv", "core", " connection", " CON", "xc", "can", "open", "co", "Connect", "cf", "ct", "bn", "client", "ran", "conn", "min", "cr", "cl", "connection", "part", "rc", "cn", "ocon", "exec", "coll", "syn", "bc", "fac", "enc", "non", "CON", "Con", "uc", "close", "res", "obj", "en", "conf", "nc", "ec", " conn", "sub", "connect", "inc", "un", "dec"], "br": ["Br", "ch", "ctr", "bh", "ver", "fore", "grab", "ob", " reader", "cm", "http", "str", "fin", "response", "io", "sr", "buf", "bro", "BR", "tr", "conn", "bridge", "gr", "cro", "er", "mr", "lr", "p", "cr", "err", "browser", "bl", "rc", "arr", "dr", "fac", "bc", "Reader", "bar", "res", "result", "runner", "reader", "output", "data", "hr", "obj", "r", "b", "buffer", "stream", "form", "rb", "fr"], "arrayList": [" arrayGroup", "elementList", "arrayArray", " arrayChain", " arrayTree", "inputGroup", "elementChain", "inputArray", " arrayArray", "areaChain", "elementTree", " arrayClient", "arrayTree", "inputClient", "arrayClient", "arrayGroup", "areaGroup", "areaClient", "arrayChain", "inputList", "elementArray", "areaArray", "areaList", "areaTree"], "inputLine": ["imageline", "currentLine", "interfaceFile", "rawL", " inputline", "issueLINE", "inputString", "currentline", "issueBlock", "currentString", "imageLINE", "outputPage", "imageDir", "InputLetter", "InputBlock", "inputBlock", "inputline", "inputLetter", "InputPage", "inFile", "InputLu", "InputString", "uploadline", "workFile", "Inputline", "inputFile", "uploadLin", " inputFile", " inputString", "inputL", " inputLINE", "currentFile", "imageL", "inputList", "inputPage", "interfaceLu", "rawBlock", " inputLin", "inline", "workLine", " inputList", "uploadPage", "currentBlock", " inputL", "imageLin", "inL", "inputLu", "InputFile", "imageList", "inputLINE", "workline", "qaL", "rawPage", "rawline", "qaFile", "inputLin", "InputLine", "rawLine", " inputDir", " inputLetter", " inputPage", "outputline", "currentL", "uploadLine", "imageBlock", " inputLu", "rawLin", "imageLine", "qaLine", "interfaceline", "issueLine", "issueList", " inputBlock", "inputDir", "qaLetter", "inLine", "InputL", "outputLin", "outputLine", "interfaceLine", "InputDir"], "counter": ["entry", "ctr", "ctrl", "ver", "cmp", "function", "c", "instance", "ter", "step", "cache", "inter", "currency", "cover", "inner", "continue", "trace", "time", "sum", "outer", "key", "number", "num", "cre", "second", "repeat", "child", "Counter", "nr", "handler", "count", "default", "server", "cur", "rew", "loader", "processor", "index", "field", "code", "controller", "i", "stop", "center", "result", "page", "type", "stack", "pattern", "offset", "loop", "info", "parent", "race", "name", "lc"]}}
{"id1": "23672408", "id2": "732800", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"copyIconFiles": [" copyIconTypes", "copyImageImages", "copyiconFile", "copyFileFiles", "copyImageFile", "copyIconTypes", " copyiconFile", " copyIconImages", " copyiconFiles", " copyIconFile", "copyImageFiles", "copyImageTypes", "copyIconImages", "copyiconTypes", " copyiconImages", "copyFileFile", "copyFileImages", " copyiconTypes", "copyFileTypes", "copyIconFile", "copyiconImages", "copyiconFiles"], "clazz": ["Clclass", "sllass", "Cllass", " clab", "clod", "closed", " classe", "sloss", "hellosed", "clunk", "llclass", "slaz", "classe", " cllass", "clclass", " classo", "classo", "llasso", "flazz", "plclass", "hellance", " clobe", "clance", "llazz", "llobe", "hellasso", "hellobe", "plazz", " closed", "pllass", "hellasse", " clclass", "glod", "clab", "glance", " closs", "helllass", "claz", "flaz", " clunk", " closer", "slosed", " clance", "Clazz", "glaz", "Closs", "slazz", "CLod", "CLaz", "hellazz", "closer", "llab", "sluster", "closs", "CLance", "ploser", "Clunk", "cllass", "slance", "flunk", "Cluster", "llaz", "cluster", "Claz", "glazz", "clobe", " cluster", "Clab", "Closer", " claz", "slod", "fluster", "CLazz", "llasse"], "i16": ["ini2016", "si15", "si24", "int2016", "pi24", "ai15", "I15", "l15", "ii14", "io2016", "I17", "I16", "l16", "i2016", "int15", "ii17", "si64", "ii16", "l64", "si2016", "io15", "i64", "pi16", "l24", "pi64", "int16", "ini15", "ini14", "i14", "ai14", "si14", "i15", "ai16", "I14", "io24", "i24", "ai2016", "int24", "ini16", "i17", "si16", "ini17", "ii24", "io16", "ii15", "pi15", "ii2016"], "fileType": ["iconTy", "feedPatch", "letterState", "imageFamily", "FileUnit", "fileState", "wordLength", "FileInfo", "fileInfo", "letterBlock", "documentBlock", "transferTy", "iconPath", "FileLike", " filePatch", "iconLength", "feedPath", "FileStyle", " fileLocation", "filePatch", "fileUnit", "fileSpread", " filetype", "fileLength", " fileKey", " fileFile", "feedLocation", " fileFamily", "letterSpread", " fileBlock", "imageFile", " fileInfo", "letterTy", " fileAuth", "documentType", "fileBlock", "filetype", "fileStyle", "playType", "wordAuth", "feedType", "iconStyle", " filePath", "playTy", "singleType", "imagePath", " fileLike", " fileLength", "fileAuth", "fileTime", "documentState", "wordType", "playSpread", "messagetype", "imageType", "transferFamily", "feedInfo", "singleTime", "FileFamily", "transferSpread", "messagePatch", "letterType", "messageType", "filePath", "imageStyle", "playFamily", " fileTy", "fileLocation", "fileFile", "feedtype", "feedLike", "fileKey", "lettertype", "iconKey", "singleFile", " fileUnit", "iconAuth", "imageKey", "messagePath", "imageUnit", " fileTime", "imageTime", "documenttype", "wordTy", "FileType", "transferType", "fileFamily", " fileStyle", "FileLocation", "fileTy", "iconType", " fileState", "singleStyle", "letterFamily", "fileLike"], "desti16": ["destabi016", "destini15", "combi15", "destI15", "destI016", "desti15", "desturi64", "destf15", "destI2016", "targetI2016", "desti016", "combini16", "targeti016", "destabi15", "combi64", "desturi15", "desturi32", "targetI15", "combini15", "destsi16", "destf16", "destf2016", "desti2016", "destini16", "targeti2016", "combi16", "desturi16", "destf016", "destsi64", "targeti16", "combini64", "destsi15", "destsi32", "destini32", "targetI016", "combi32", "destini64", "destabi16", "desti64", "targetI16", "destI16", "combini32", "destabi2016", "targeti15"], "src": ["resource", "cdn", "ctrl", "ug", "cmp", "view", "http", "sc", "crop", "sr", "rl", "proc", "s", "rob", "url", "scenes", "sl", "gz", "image", "socket", "ssl", "uri", "console", "file", "scene", "bs", "inst", "attr", "dest", "loc", "video", "gb", "tmp", "cur", "pkg", "filename", "output", "data", "req", "null", "iv", "grad", "stream", "pull", "root", "front", "conv", "ctx", "https", "sys", "sync", "default", "rc", "upload", "coll", "load", "usr", "lib", "uc", "st", "secure", "target", "r", "rb", "sq", "rss", "bh", "support", "dist", "cv", "input", "func", "ource", "desc", "gl", "buf", "uv", "in", "download", "config", "thumbnails", "hub", "cb", "img", "ser", "b", "back", "source", "sel"], "dst": ["idsc", "rdST", "adst", "idrd", " dsts", "dct", " dsl", "Dct", " dsc", "dST", " dST", "dsput", "Dost", "drsc", "rdsc", "sdbl", "idst", "drst", "dsc", " drd", "Drest", "dste", "dest", "sdest", "Dste", "dbl", "nst", "deddr", "Dst", "adost", "ldct", "sdsc", "drest", "nste", "ldst", "Ddr", "dsst", "drST", "Dbl", " dste", " dest", "idsl", "dedost", " dput", "dedput", "nrest", "sddest", "dost", "dsts", "ldbl", "dedst", " ddest", "idbl", "Dput", "ddr", "nsts", "drd", "sdrd", "ddest", "rdput", "iddest", "dsost", " dbl", "sdsl", "Dsts", "rdst", "adct", "adbl", "sdst", " drest", "dsl", "drput", "idest", "dsdr", "ldost", "dput"], "i32": ["ini35", "qi15", "ri32", "I32", " i33", " i31", "ini22", "I31", "qi32", "I33", "ui32", "I30", "ri33", " i34", "i33", "iu34", "ini32", "i31", "ui34", "in15", "in34", "i22", "si32", "qi33", "I35", " i30", "i30", "si33", "iu32", " i42", " i22", "ui31", "si22", "I34", "in33", "iu15", "in32", "ui30", "i15", "i34", "I42", "i42", "ri42", "ini33", "qi34", "si35", "iu33", " i35", "i35", "ri35"], "desti32": ["destiu32", "destic22", "destii32", "targeti28", "desti33", " destsi22", "destiu28", "desti15", "destiu34", "desti28", "destabi15", "desti34", "destii34", "desti22", "destiu33", " desti22", "destsi16", "targetiu28", "destsi22", "destabi22", "destin33", "destii33", "destic16", " destsi16", "targeti32", "destin34", "destabi32", "targetiu34", "destsi15", "destsi32", "destin28", " destsi15", "targetiu32", "destic32", "destin32", "destabi16", "targeti33", "destii28", "targetiu33", "destic15", " desti15", " destsi32", "targeti34"]}}
{"id1": "6501291", "id2": "8754809", "code1": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"extractFile": ["extractedFiles", "xtractfile", "xtractFile", "xtractFolder", "extressFile", "extressfile", "extendFolder", "xtractedFile", "xtractedFiles", "extractFiles", "extractedfile", "extressFolder", "xtractedFolder", "xtractedfile", "extractedFolder", "xtractFiles", "extendfile", "extractfile", "extractFolder", "extendFiles", "extressFiles", "extendFile", "extractedFile"], "input": ["pull", "media", "zip", "string", "view", "xml", "inner", "bin", "down", "io", "text", "content", "address", "archive", "single", "audio", "frame", "connection", "init", "element", "url", "load", "config", "Input", "i", "image", "format", "inf", "img", "data", "raw", "target", "parent", "source", "stream", "buffer", "binary", "name", "file"], "output": ["temp", "application", "external", "string", "current", "secret", "xml", "response", "outer", "operation", "address", "letter", "unit", "generation", "document", "connection", "model", "url", "config", "settings", "office", "complete", "example", "format", "remote", "page", "result", "next", "directory", "four", "write", "written", "style", "target", "job", "web", "source", "generated", "version", "file", "Output", "reference"], "reader": ["plus", "stream", "zip", "ini", "IN", "reading", "rake", "oder", "inner", "ler", "as", "io", "ner", "feed", "ri", "er", "err", "l", "rc", "server", "cur", "loader", "read", "Reader", "iter", "f", "per", "rer", "i", "ink", "her", "worker", "h", "writer", "editor", "der", "author", "parse", "se", "rr", "r", "b", "parser", "rar", "inc", "buffer", "source", "rx", "rb", "file"], "in": ["In", "or", "ini", "n", "IN", "is", "inner", "din", "bin", "as", "io", "ins", "doc", "ac", "user", "inn", "er", "err", "l", "init", "win", "s", "url", "gin", "loader", "read", "f", "i", "image", "socket", "writer", "h", "data", "r", "inc", "id", "source", "stream", "re", "file"], "out": ["temp", "line", "again", "cache", "instance", "over", "o", "exp", "ex", "inner", "bin", "Out", "self", "copy", "outer", "log", "io", "outs", "post", "conn", "user", "err", "up", "connection", "net", "w", "exec", "server", "pool", "off", "image", "socket", "writer", "editor", "ext", "data", "gen", "raw", "obj", "OUT", "write", "inc", "parent", "source", "buffer", "client", "file"], "buf": ["bh", "bu", "vec", "c", "cas", "cv", "bin", "fd", "ctx", "bd", "box", "queue", "la", "pad", "length", "seq", "bp", "ab", "loc", "batch", "br", "bl", "bag", "ff", "rc", "tmp", "plug", "cur", "bc", "off", "lim", "uf", "cap", "uc", "bytes", "cb", "val", "v", "bb", "data", "raw", "b", "bf", "buff", "fb", "buffer", "rb", "lc"], "len": ["lt", "line", "n", "c", "fin", "dl", "bin", "le", "Len", "z", "length", "no", "min", "count", "err", "l", "part", "base", "pos", "lin", "all", "url", "size", "sl", "f", "iter", "i", "li", "ind", "el", "pre", "cap", "lim", "val", "nt", "data", "fl", "r", "en", "id", "lf", "rev", "ln", "lc", "end"]}}
{"id1": "15129155", "id2": "20663364", "code1": "    public List<String> extractUrlList(String url) throws IOException, XPathExpressionException {\n        LinkedList<String> list = new LinkedList<String>();\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        Tidy tidy = new Tidy();\n        tidy.setErrout(new NullPrintWriter());\n        Document doc = tidy.parseDOM(conn.getInputStream(), null);\n        int len = conn.getContentLength();\n        if (len <= 0) len = 32000;\n        ByteArrayOutputStream bout = new ByteArrayOutputStream(len);\n        PrintStream ps = new PrintStream(bout);\n        tidy.pprint(doc, ps);\n        ps.flush();\n        String content = bout.toString();\n        Pattern p = Pattern.compile(\"(http://[\\\\w\\\\\\\\\\\\./=&?;-]+)\");\n        Matcher m = p.matcher(content);\n        while (m.find()) {\n            list.add(m.group());\n        }\n        return list;\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 0, "substitutes": {"extractUrlList": ["extractTextObject", "extractionURLCollection", "extractTextlist", "extractLocationCollection", "extractLocationObject", "extractURLList", "extractionUrlObject", "extractURLCollection", "extractURLlist", "extractionURLList", "extractLocationlist", "extractionUrlList", "extractionUrlCollection", "extractUrlCollection", "extractURLObject", "extractUrllist", "extractionURLlist", "extractionURLObject", "extractTextCollection", "extractionUrllist", "extractUrlObject", "extractLocationList", "extractTextList"], "url": ["resource", "string", "href", "host", "xml", "http", "www", "input", "URL", "path", "ll", "ur", "feed", "Url", "email", "download", "address", "l", "connection", "base", "out", "server", "location", "sl", "f", "i", "filename", "image", "page", "html", "ssl", "data", "obj", "uri", "source", "text", "src", "name", "file"], "list": ["item", "live", "we", "g", "string", "rest", "map", "table", "str", "dl", "ist", "msg", "ll", "listed", "queue", "tree", "batch", "LIST", "bl", "l", "part", "dict", "base", "cl", "all", "chain", "out", "coll", "arr", "load", "x", "left", "array", "pool", "iter", "detail", "code", "e", "li", "set", "i", "val", "member", "result", "test", "type", "parse", "loop", "lists", "lc"], "conn": ["dc", "ch", "n", "c", "Connection", "g", "host", "rec", "http", "Conn", "ann", "conv", "dn", "ctx", "con", "open", "rt", "sync", "ct", "cf", "client", "loc", "resp", "connection", "mc", "cn", "rc", "cp", "cmd", "exec", "server", "sb", "enc", "cli", "session", "Con", "pub", "cb", "nt", "jp", "po", "conf", "nc", "connect", "db", "lc"], "tidy": ["trawl", "ttickle", "ttriage", "ttidi", " tidi", "matidy", "ntriage", " totally", "Tidy", "pidy", "ttrie", "potally", "matickle", "totally", "ntidy", "pick", " tickle", "matry", "tick", "trie", "Tick", "Trawl", "tickle", "Try", "ttidy", "matrawl", " trawl", "Triage", " tick", "pidi", "Tickle", "ntrie", "tractor", "ttractor", " tractor", "practor", "ntickle", "Totally", "tidi", "priage", "Trie", "triage", "pickle", " triage"], "doc": ["dc", "df", "g", "c", "n", "Doc", "exp", "xml", "d", "str", "di", "api", "div", "oc", "dict", "up", "l", "document", "pos", "coll", "sp", "index", "f", "dom", "h", "val", "html", "data", "docs", "md", "obj", "po", "id", "DOC", "body", "db", "file", "dec"], "len": ["span", " Len", "lt", "line", " length", "n", "limit", "fin", "dl", "ann", "bin", "Len", "ll", "num", "length", "seq", "lit", "count", "loc", "ld", "lang", "l", "part", "base", "pos", "lin", "ls", "size", "sl", "f", "lp", "li", "lim", "el", "cap", "lan", "val", "html", "elt", "fl", " lang", "en", "lf", "lon", "ln", "lc"], "bout": ["brOUT", "Bin", "mbouts", "BOUT", "ain", "Bouts", "bbOUT", " bin", "bin", "bbouts", "mbin", "bouts", " bOUT", "boff", "mbout", "broff", "Boff", "mbstream", "aout", "brin", "brout", "aouts", "bOUT", "bbout", "Bout", " bouts", "bstream", "astream", "Bstream", "bbin", "bboff"], "ps": ["ks", "mp", "pps", "ms", "pres", "bs", "pr", "pi", "py", "pse", "eps", "proxy", "pl", "gs", "Ps", "os", "pp", "pers", "fs", "s", "qs", "pe", "vs", "pa", "out", "ops", "sp", "cs", "aps", "ep", "ns", "ds", "ips", "ts", "po", "PS", "rs", "pas", "par", "ss"], "content": ["resource", "temp", "media", "section", "string", "c", "word", "xml", "expression", "str", "comment", "cover", "response", "input", "path", "con", "cont", "document", "connection", "model", "Content", "load", "work", "config", "code", "value", "html", "result", "page", "output", "ext", "data", "raw", "ontent", "message", "source", "text", "body", "activity"], "p": ["ap", "mp", "rep", "ip", "g", "c", "n", "pr", "py", "pi", "op", "d", "pp", "tp", "l", "s", "pe", "cp", "pa", "sp", "f", "per", "comp", "e", "lp", "i", "q", "h", "P", "jp", "r", "po", "t", "parser", "pattern", "b", "pro"], "m": ["body", "mp", "media", "ms", "pm", "line", "u", "cm", "n", "c", "rm", "em", "im", "o", "sm", "um", "d", "hm", "match", "perm", "mr", "wm", "om", "M", "vm", "l", "mc", "part", "ma", "machine", "fm", "am", "rem", "gm", "dm", "h", "v", "mi", "md", "r", "mm", "b", "tm", "source", "me", "mu", "bm"]}}
{"id1": "21821404", "id2": "6890417", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        PostParameter a1 = new PostParameter(\"v\", Utils.encode(\"1.0\"));\n        PostParameter a2 = new PostParameter(\"api_key\", Utils.encode(RenRenConstant.apiKey));\n        PostParameter a3 = new PostParameter(\"method\", Utils.encode(\"feed.publishTemplatizedAction\"));\n        PostParameter a4 = new PostParameter(\"call_id\", System.nanoTime());\n        PostParameter a5 = new PostParameter(\"session_key\", Utils.encode(\"5.b2ca405eef80b4da1f68d0df64e471be.86400.1298372400-350727914\"));\n        PostParameter a8 = new PostParameter(\"format\", Utils.encode(\"JSON\"));\n        PostParameter a9 = new PostParameter(\"template_id\", Utils.encode(\"1\"));\n        PostParameter a10 = new PostParameter(\"title_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        PostParameter a11 = new PostParameter(\"body_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        RenRenPostParameters ps = new RenRenPostParameters(Utils.encode(RenRenConstant.secret));\n        ps.addParameter(a1);\n        ps.addParameter(a2);\n        ps.addParameter(a3);\n        ps.addParameter(a4);\n        ps.addParameter(a5);\n        ps.addParameter(a8);\n        ps.addParameter(a9);\n        ps.addParameter(a10);\n        ps.addParameter(a11);\n        System.out.println(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        URL url = new URL(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "label": 1, "substitutes": {"getWebPage": ["parsewebpage", "getwebpages", "parsewebPage", "getVirtualPage", "getVirtualpages", "getwebpage", "getWebpage", "parseWebpages", "parsewebpages", "parseWebpage", "getVirtualpage", "parseWebPage", "getwebPage", "getWebpages"], "urlObj": [" urlObject", "URLobj", "resourceObject", "urlExt", "httpobj", "blogobj", "URLObject", "UrlObj", "Urlobj", "urlobj", " urlExt", "URLObj", " urlobj", "strobj", "strObject", "blogObj", "httpOb", "resourceobj", "resourceObj", "URLExt", " urlInst", "blogInst", " urlOb", "strObj", "strInst", "resourceExt", "UrlOb", "urlInst", "urlOb", "httpObj", "urlObject", "blogObject"], "content": ["resource", "online", "section", "clean", "string", "c", "css", "lines", "comment", "response", "core", "java", "continue", "report", "cont", "feed", "empty", "json", "object", "address", "header", "document", "out", "model", "server", "Content", "url", "load", "coll", "work", "array", "code", "value", "page", "result", "html", "output", "data", "write", "raw", "comments", "message", "source", "buffer", "text", "body", "file"], "is": ["il", "or", "isp", "ires", "us", "isa", "ip", "ios", "im", "ois", "isl", "est", "you", "rest", "site", "ir", "irc", "was", "iris", "as", "be", "io", "ais", "abs", "os", "IS", "ui", "cms", "in", "ins", "ri", "does", "ie", "it", "fs", "s", "Is", "out", "iss", "iso", "ar", "ops", "x", "its", "isi", "isc", "i", "any", "mis", "bis", "lis", "ser", "ai", "al", "nis", "r", "ps", "id", "es", "info", "stream", "ris", "ise", "problem"], "reader": ["or", "row", "actor", " Reader", "reading", "oder", "inner", "ler", "io", "ner", "driver", "in", "ri", "er", "handler", "bird", "ro", "l", "rc", "server", "x", "loader", "read", "Reader", "iter", "rer", "e", "director", "i", "worker", "h", "writer", "editor", "ser", "rr", "r", "parser", "rar", "buffer", "stream", "rx"], "line": ["item", "inline", "entry", "row", "pass", "section", "string", "col", "word", "lines", "ine", "LINE", "str", "character", "comment", "Line", " inline", "response", "char", "key", "object", "user", "cr", "cl", "l", "part", "connection", "lin", "cell", "out", "server", "url", "block", "link", "f", "code", "cle", "strip", "page", "data", "lf", "message", "buffer", "source", "text", "body", "column", "name", "file", "lc"]}}
{"id1": "23672408", "id2": "19784131", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static String getMD5Hash(String original) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            StringReader sr = null;\n            int crypt_byte = 0;\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(original.getBytes());\n            byte[] digest = md.digest();\n            sr = new StringReader(new String(digest, \"ISO8859_1\"));\n            while ((crypt_byte = sr.read()) != -1) {\n                String hexString = Integer.toHexString(crypt_byte);\n                if (crypt_byte < 16) {\n                    hexString = \"0\" + hexString;\n                }\n                sb.append(hexString);\n            }\n        } catch (NoSuchAlgorithmException nsae) {\n        } catch (IOException ioe) {\n        }\n        return sb.toString();\n    }\n", "label": 0, "substitutes": {"copyIconFiles": [" copyIconTypes", "copyImageImages", "copyiconFile", "copyFileFiles", "copyImageFile", "copyIconTypes", " copyiconFile", " copyIconImages", " copyiconFiles", " copyIconFile", "copyImageFiles", "copyImageTypes", "copyIconImages", "copyiconTypes", " copyiconImages", "copyFileFile", "copyFileImages", " copyiconTypes", "copyFileTypes", "copyIconFile", "copyiconImages", "copyiconFiles"], "clazz": ["Clclass", "sllass", "Cllass", " clab", "clod", "closed", " classe", "sloss", "hellosed", "clunk", "llclass", "slaz", "classe", " cllass", "clclass", " classo", "classo", "llasso", "flazz", "plclass", "hellance", " clobe", "clance", "llazz", "llobe", "hellasso", "hellobe", "plazz", " closed", "pllass", "hellasse", " clclass", "glod", "clab", "glance", " closs", "helllass", "claz", "flaz", " clunk", " closer", "slosed", " clance", "Clazz", "glaz", "Closs", "slazz", "CLod", "CLaz", "hellazz", "closer", "llab", "sluster", "closs", "CLance", "ploser", "Clunk", "cllass", "slance", "flunk", "Cluster", "llaz", "cluster", "Claz", "glazz", "clobe", " cluster", "Clab", "Closer", " claz", "slod", "fluster", "CLazz", "llasse"], "i16": ["ini2016", "si15", "si24", "int2016", "pi24", "ai15", "I15", "l15", "ii14", "io2016", "I17", "I16", "l16", "i2016", "int15", "ii17", "si64", "ii16", "l64", "si2016", "io15", "i64", "pi16", "l24", "pi64", "int16", "ini15", "ini14", "i14", "ai14", "si14", "i15", "ai16", "I14", "io24", "i24", "ai2016", "int24", "ini16", "i17", "si16", "ini17", "ii24", "io16", "ii15", "pi15", "ii2016"], "fileType": ["iconTy", "feedPatch", "letterState", "imageFamily", "FileUnit", "fileState", "wordLength", "FileInfo", "fileInfo", "letterBlock", "documentBlock", "transferTy", "iconPath", "FileLike", " filePatch", "iconLength", "feedPath", "FileStyle", " fileLocation", "filePatch", "fileUnit", "fileSpread", " filetype", "fileLength", " fileKey", " fileFile", "feedLocation", " fileFamily", "letterSpread", " fileBlock", "imageFile", " fileInfo", "letterTy", " fileAuth", "documentType", "fileBlock", "filetype", "fileStyle", "playType", "wordAuth", "feedType", "iconStyle", " filePath", "playTy", "singleType", "imagePath", " fileLike", " fileLength", "fileAuth", "fileTime", "documentState", "wordType", "playSpread", "messagetype", "imageType", "transferFamily", "feedInfo", "singleTime", "FileFamily", "transferSpread", "messagePatch", "letterType", "messageType", "filePath", "imageStyle", "playFamily", " fileTy", "fileLocation", "fileFile", "feedtype", "feedLike", "fileKey", "lettertype", "iconKey", "singleFile", " fileUnit", "iconAuth", "imageKey", "messagePath", "imageUnit", " fileTime", "imageTime", "documenttype", "wordTy", "FileType", "transferType", "fileFamily", " fileStyle", "FileLocation", "fileTy", "iconType", " fileState", "singleStyle", "letterFamily", "fileLike"], "desti16": ["destabi016", "destini15", "combi15", "destI15", "destI016", "desti15", "desturi64", "destf15", "destI2016", "targetI2016", "desti016", "combini16", "targeti016", "destabi15", "combi64", "desturi15", "desturi32", "targetI15", "combini15", "destsi16", "destf16", "destf2016", "desti2016", "destini16", "targeti2016", "combi16", "desturi16", "destf016", "destsi64", "targeti16", "combini64", "destsi15", "destsi32", "destini32", "targetI016", "combi32", "destini64", "destabi16", "desti64", "targetI16", "destI16", "combini32", "destabi2016", "targeti15"], "src": ["resource", "cdn", "ctrl", "ug", "cmp", "view", "http", "sc", "crop", "sr", "rl", "proc", "s", "rob", "url", "scenes", "sl", "gz", "image", "socket", "ssl", "uri", "console", "file", "scene", "bs", "inst", "attr", "dest", "loc", "video", "gb", "tmp", "cur", "pkg", "filename", "output", "data", "req", "null", "iv", "grad", "stream", "pull", "root", "front", "conv", "ctx", "https", "sys", "sync", "default", "rc", "upload", "coll", "load", "usr", "lib", "uc", "st", "secure", "target", "r", "rb", "sq", "rss", "bh", "support", "dist", "cv", "input", "func", "ource", "desc", "gl", "buf", "uv", "in", "download", "config", "thumbnails", "hub", "cb", "img", "ser", "b", "back", "source", "sel"], "dst": ["idsc", "rdST", "adst", "idrd", " dsts", "dct", " dsl", "Dct", " dsc", "dST", " dST", "dsput", "Dost", "drsc", "rdsc", "sdbl", "idst", "drst", "dsc", " drd", "Drest", "dste", "dest", "sdest", "Dste", "dbl", "nst", "deddr", "Dst", "adost", "ldct", "sdsc", "drest", "nste", "ldst", "Ddr", "dsst", "drST", "Dbl", " dste", " dest", "idsl", "dedost", " dput", "dedput", "nrest", "sddest", "dost", "dsts", "ldbl", "dedst", " ddest", "idbl", "Dput", "ddr", "nsts", "drd", "sdrd", "ddest", "rdput", "iddest", "dsost", " dbl", "sdsl", "Dsts", "rdst", "adct", "adbl", "sdst", " drest", "dsl", "drput", "idest", "dsdr", "ldost", "dput"], "i32": ["ini35", "qi15", "ri32", "I32", " i33", " i31", "ini22", "I31", "qi32", "I33", "ui32", "I30", "ri33", " i34", "i33", "iu34", "ini32", "i31", "ui34", "in15", "in34", "i22", "si32", "qi33", "I35", " i30", "i30", "si33", "iu32", " i42", " i22", "ui31", "si22", "I34", "in33", "iu15", "in32", "ui30", "i15", "i34", "I42", "i42", "ri42", "ini33", "qi34", "si35", "iu33", " i35", "i35", "ri35"], "desti32": ["destiu32", "destic22", "destii32", "targeti28", "desti33", " destsi22", "destiu28", "desti15", "destiu34", "desti28", "destabi15", "desti34", "destii34", "desti22", "destiu33", " desti22", "destsi16", "targetiu28", "destsi22", "destabi22", "destin33", "destii33", "destic16", " destsi16", "targeti32", "destin34", "destabi32", "targetiu34", "destsi15", "destsi32", "destin28", " destsi15", "targetiu32", "destic32", "destin32", "destabi16", "targeti33", "destii28", "targetiu33", "destic15", " desti15", " destsi32", "targeti34"]}}
{"id1": "13757855", "id2": "13886238", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"process": ["resource", "processing", "run", "project", "request", "call", "view", "transform", "path", "construct", "build", "proc", "exec", "load", "processor", "code", "evaluate", "handle", "output", "parse", "submit", "Process", "update", "cess", "create"], "tpl": ["Tplate", "pPL", "itpl", "stPL", "qtfc", "tyl", "templ", "tPL", "qtple", "psl", "stplate", "tplate", "Tpp", " tplug", "qtcp", "Tpl", "pcl", "tcp", "Tplates", "atml", "lplate", "Tml", " tple", "latpl", "latyl", "fplug", "templates", "stpl", "tcl", " ttemplate", "tmyl", "tper", " tplates", " tcl", "tipl", "itplate", "qtbl", "fplate", "lpl", "lcl", " tfc", "lPL", "tfc", "tmpl", "qtpl", "latple", "tpp", "latcp", " tbl", "lple", " tsl", "atplug", "TPL", "Ttemplate", "Tcl", "temtemplate", "tplug", "atpl", "Tbl", " tper", "fml", "pipl", "atplate", "tsl", "itPL", " tPL", "lper", "qtyl", "tbl", "Tipl", "tmple", "itplates", "tmcp", "Tper", "tml", "ttemplate", "ppl", " tplate", " tpp", "tplates", "stpp", " tipl", "tple", "temPL", "Tple", "Tsl", " tml", "Tfc", "lml", "fpl"], "model": ["media", "project", "m", "xml", "language", "node", "copy", "log", "params", "param", "json", "doc", "command", "document", "location", "config", "where", "graph", "result", "data", "models", "module", "Model", "conf", "message", "body"], "packageName": ["contextNames", "groupKey", " packageNames", "modulename", "PackageNames", "moduleName", "packageKey", "projectUrl", " packageInfo", " packagename", "projectName", "PackageInfo", "packagename", "groupname", "contextName", "projectname", "packageUrl", "PackageName", "packageInfo", "contextInfo", "Packagename", "moduleUrl", "groupName", "projectKey", "contextname", "packageNames", "moduleKey", "groupUrl"], "outFileName": ["outfileTime", "OutDirLine", "outfileMode", "outStreamType", " outDirPath", "outFileCopy", "outFilesPath", "outStreamInfo", "diffFileName", "outLinename", "outFilename", "OutFilename", "OUTFileMode", "outFileNames", "outLineInfo", "outFileType", "outStreamName", "outLineName", " outFilePath", "OutDirName", "OutFileName", "OUTBufferNames", " outDirTime", "outDirEnd", "diffFileInfo", "difffileOnce", "OutDirname", "outfileInfo", "outDirInfo", "outfileName", "outDirTime", "diffFileTime", "outFileInfo", "inFileCopy", "outFullName", "outFilenameNames", "outLineNames", "outLineTime", "inDirEnd", "difffileInfo", "outFileEnd", "outFullPath", "outFilenameHalf", "OutDirNames", "outBufferName", "outFilesName", "outFileHalf", "outFullNames", "outFullLine", "outFileLine", "outfileNames", "outBufferMode", "outBufferHalf", "outFullInfo", "outfileHalf", "inFileEnd", " outDirName", "inFilePath", "outFullType", "OUTBufferName", "outDirOnce", "difffileTime", "inDirCopy", "OUTBufferHalf", "outDirCopy", "outfileEnd", "OutFileLine", "outFilenameName", "OUTFileNames", "inFileName", " outFileType", "outFilesTime", "diffFileOnce", "outfileOnce", "OUTBufferMode", " outFileLine", " outFullInfo", " outFileInfo", "outDirName", "outRuleName", "outLineOnce", "outDirLine", "outFilenameMode", "outFilenamePath", "outLineLine", "outDirPath", " outFullType", "outFileOnce", "outFilenameEnd", " outDirLine", "outFilesLine", "outFilenameCopy", "outFullTime", "outDirname", "inDirPath", "outFileTime", "outfilePath", "OUTFileHalf", "outDirNames", " outFileTime", "outfileCopy", "inDirName", "outFileMode", "outRuleType", "outFilePath", " outFullName", "outRuleInfo", "outFullname", "OutFileNames", "outBufferNames", "difffileName", "OUTFileName"], "xsltParam": ["xslicVal", "xsltVal", "xsltMode", "xsltparam", "xsldparam", "xldVal", "xslpMode", "xltparam", "xltParam", "xslpParam", "xslpVal", "xsldParam", "xldparam", "xldMode", "xltMode", "xltVal", "xslicMode", "xsldVal", "xsldMode", "xslicparam", "xslpparam", "xslicParam", "xldParam"], "artifact": ["Arturation", "Artfact", "artfact", "ARTfact", "Artifest", "Artifacts", "ARTifact", "advertribution", "artribution", "advertifact", "ARTifest", "aratfact", "aratifact", "Artribution", "arturation", " arturation", "artifest", "aratifest", "advertifacts", " artifacts", "adverturation", "Artifact", "aratifacts", "ARTifacts", "artifacts", " artribution"], "destinationPath": ["tempinationpath", "destationpath", "restinatorHalf", "destributionpath", "destensionText", "destinatorPoint", "distinatorName", "destinatingLocation", "distributionpath", "destiningPath", "destinatorFile", "destplingUrl", "destiningDir", "tempinatedPath", "constinatorWidth", "destinateName", "datinationLocation", "destinateHalf", "destinationCase", "tempinatedpath", "destributionCry", "destinatepath", "desturationpath", "desticationFile", "destinationName", "distinationCry", "DestinationPart", "destationPath", "datinateLocation", "restificationpath", "restificationLocation", "destificationDir", "distinationDir", "restificationPoint", "restinatorPath", "desturationHandler", "destinatedKey", "destinatePoint", "destinatorUrl", "DestinatingPoint", "DestinatingPath", "destinationHandler", "datinateTime", "distinationPath", "destinationsPoint", "destinatedHalf", "distributionCase", "tempinationDir", "destinatorCry", "destinatePart", "restinationPoint", "constinationsName", "destinatorLocation", "destiationDir", "destinatingName", "combinationHandler", "destinationpath", "destinationContext", "DestinatingName", "destinationsPath", "destinationPoint", "constinationsPath", " destinationDir", "constinationspath", "restinationLocation", "destiationLog", "constinationsPoint", "destinatingText", "destributionDir", "destinatingPath", "destificationPart", "constinationName", "restinatorString", "destplingAuth", "DestificationPath", " destificationPath", "desticationPath", "destcreationPath", "destificationAuth", "destinatingPoint", "DestificationName", "distinatorCry", "destinatePath", "destinateTime", "desturationName", "destinerContext", "distributionDir", "constinationPath", "datinationpath", "DestinationName", "destificationName", "distinationStep", "distinationFile", "distinationKey", "tempinatedDir", "destplingLog", "destinateDir", "destiningContext", "destinatedPath", "destplingDir", "restinationString", "destinateLocation", "restinationHalf", "destinatedpath", "destributionName", "destensionName", " destinationLog", "constinationDir", "desturationPath", "restificationPath", "desticationPart", "destinatedString", "destinatedFile", "destinationsName", "destplingWidth", "destificationPoint", "destinationLog", "constinationContext", "distinationCase", "restinationpath", "destinatorHalf", "distinatorKey", "constinationWidth", "DestinationText", "destificationLocation", "destcreationWidth", "destinationText", "destinatorString", "destinationLocation", "destinatorTime", "destiationPath", "destinationPart", "tempinationHalf", "desticationKey", "tempinationPath", "combinatorpath", "constinatorContext", " destificationAuth", "destinateHandler", "constinatorPath", "constinatorDir", "combinationpath", "destinatingpath", " destificationDir", "destinerPath", "destensionPath", "destinatorCase", "destinatorKey", "combinatorName", "destinationWidth", "destinatorpath", "destiningName", "destensionPoint", "distinationpath", "combinatorHandler", "destinationString", "constinatorpath", "destiationAuth", "constinatorUrl", "destinatorContext", "destinationUrl", "destinationDir", "destinatorHandler", "destationLocation", "distributionPath", "constinationpath", "destificationLog", "distinatorFile", "combinatorPath", "datinationPath", "destinationKey", "destificationpath", "destinatorStep", "destinatedStep", "destationTime", "destcreationUrl", "destinatorPath", "destinationStep", "combinationName", "restinationPath", "DestinatingText", "tempinatedHalf", "distinationName", "datinatepath", "destignmentCase", "datinationTime", "destinatorDir", "destinatorName", "destinationAuth", "destinateText", "destinationHalf", "desticationStep", "destificationPath", "destignmentCry", "destinatedPoint", "destiningpath", "destinateString", "combinationPath", "datinatePath", "destinatedCase", "destignmentPath", " destinationAuth", "desticationName", "distinatorStep", "distinatorCase", "destributionPath", "destinationFile", "destinerpath", "destplingPath", "destributionCase", "destinerDir", "destignmentName", "DestinationPath", "destinationTime", "restinatorPoint", "destinatorWidth", "constinationPoint", "destiningPoint", "DestificationPart", "DestinationPoint", "destinatedDir", "destinationspath", " destificationLog", "distinatorPath", "constinationUrl", "destinationCry"], "in": ["In", "n", "c", "cache", "IN", "ex", "d", "din", "bin", "input", "con", "ins", "doc", "min", "connection", "x", "config", "i", "image", "reader", "data", "r", "t", "inc", "source", "name"], "out": ["temp", "group", "line", "again", "full", "string", "cache", "o", "ex", "str", "comment", "version", "bin", "state", "Out", "with", "copy", "msg", "outer", "manager", "log", "io", "path", "outs", "key", "list", "sys", "post", "doc", "user", "conn", "err", "store", "up", "connection", "w", "part", "all", "prefix", "exec", "server", "index", "pool", "cli", "session", "dump", "lib", "writer", "free", "page", "result", "ne", "output", "gen", "error", "write", "obj", "OUT", "point", "parent", "lock", "source", "client", "name", "file", "Output"], "root": ["cat", "history", " roots", "instance", "resources", "cache", "include", "results", "values", "xml", "node", "transform", "options", "path", "params", "Root", "tree", "meta", "json", "roots", "query", "url", "loader", "index", "graph", "_", "format", " result", "module", "r", "id", "pattern", "parent", "collection", "modules"]}}
{"id1": "12066447", "id2": "23672408", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"truncate": ["trrenational", "autuncator", "trunator", "tratenator", "autuncate", "autatenate", "tratenation", "trrenate", "autatenational", "trrenation", "truncational", "trunational", "truncator", "tratenate", "autatenation", "trrenator", "autatenator", "trunation", "trunate", "autuncational", "truncation", "tratenational", "autuncation"], "file": ["File", "resource", " File", "folder", "or", "body", "local", "class", "plus", "line", "function", "full", "zip", "string", "cache", "current", "http", "time", "log", "path", "io", "queue", "this", "files", "object", "ile", "address", "archive", "handler", "single", "it", "l", "connection", "base", "document", "out", "model", "future", "url", "get", "f", "FILE", "e", "per", "filename", "image", "format", "fp", "page", "directory", "type", "data", "info", "stream", "source", "binary", "uri", "name", "db", "parent", "one"], "backupRoot": ["BackbackDir", "backupPath", "backdownroot", "backdownRoot", "backureDir", "BackupDirectory", "backbaseroot", "backupDir", "BackureDirectory", "backflowFile", "Backuproot", "BackdownDirectory", "backflowRoot", "BackureDir", "backuproot", "backUpFolder", "BackupFile", "backupsroot", "frontupDir", "BackdownPath", "BackbackFile", "frontupRoot", "frontdownroot", "backdownPath", "backbackRoot", "backflowDir", "backdownDirectory", "backbackDirectory", "BackupDir", "backbackDir", "backureHome", "frontdownDir", "backbaseDirectory", "Backdownroot", "backdownFolder", "backureDirectory", "frontuproot", "backbackFile", "backupHome", "backUproot", "frontdownFolder", "BackupPath", "backbackHome", "backupsRoot", "frontupFolder", "backdownDir", "backupFolder", "backureRoot", "BackdownRoot", "backUpRoot", "backdownHome", "BackbackRoot", "backbasePath", "frontdownRoot", "backbaseRoot", "backupsDirectory", "BackupRoot", "backflowroot", "backupsDir", "backUpDir", "BackupHome", "BackureHome", "backbackroot", "BackureRoot", "backupsPath", "backdownFile", "backupsFolder", "backupDirectory", "backupFile", "Backbackroot"], "df": ["dc", "fe", "deb", "dp", "pd", "fc", "pdf", "sf", "d", "dl", "raf", "func", "da", "dn", "fd", "di", "io", " def", "cf", "fn", "def", "dict", "fs", "dd", "DF", "tf", "dt", "f", "af", "CF", "ds", "xf", "format", "dm", "fp", "data", "dq", "md", "fb", "bf", "de", "db", "fr", "flow"], "date": ["created", "stage", "day", "use", "dose", "fee", "string", "m", "dat", "ate", "d", "str", "version", "input", "ge", "time", "log", "year", "open", "modified", "ale", "sync", "days", "min", "custom", "atom", "re", "bug", "age", "valid", "rule", "tag", "out", "pe", "updated", "j", "url", "work", "x", "dt", "complete", "dates", "code", "value", "Date", "pre", "format", "output", "diff", "data", "type", "style", "module", " Date", "D", "back", "update", "message", "form", "name", "db", "create"], "zipFile": ["zipModel", "zFiles", "zipEntry", " zipFiles", "Zipfile", " zipfile", "sqlModel", "zipFiles", "ressModel", "zFile", "ZipFiles", "sqlFile", "sqlfile", "zSection", "zipSection", " zipEntry", "sqlSection", "ZipEntry", "ressfile", "ressSection", "ressFile", "zModel", "ZipFile", "zfile", "zEntry", "zipfile"], "zos": ["nz", "robe", "js", "zes", "budget", "ozo", "exit", "ses", "zen", "zip", "osi", "css", "zona", "zero", "rez", "dos", "fits", "proxy", "zn", "inos", "bitcoin", "eros", " sands", "z", "os", "outs", "iffs", "uz", "obb", "bos", "tz", "zag", "address", "nox", "liquid", "zan", "ZA", "asio", "chini", "ls", "los", "bes", "zx", "dylib", "ops", "jas", "cos", "zar", "zy", "settings", "webkit", "hess", "zo", "han", "gz", "zb", "her", "ros", "zh", "closure", "ssl", "cash", "zer", "kos", "ils", "zi", "zon", "lins", "forge", "las", "zl", "zik", "zzy"], "fis": ["rafias", "fisl", "biss", " fits", "Fias", "Fiss", " fias", "fisp", "lias", "fits", "bisl", " fisp", "lids", "Fisp", "flris", "liss", "flids", "fiz", "fils", "viz", "infils", " fiss", "infiss", "bos", "fris", "fids", "rafris", " fiz", "infis", "infiz", "vis", "vils", "Fisl", "flias", " fris", "rafiss", "flis", "Fis", "infits", "fliss", " fils", "Fos", "fos", "fias", "bis", "lis", " fisl", "Fris", " fos", "infids", "infias", "rafis", "fiss", "flisp", "vits"], "entry": ["or", "row", "ry", "si", "so", "zip", "and", "exp", "Entry", "comment", "ge", "ion", "z", "feed", "add", "key", "card", "ui", "the", "address", "letter", "archive", "ie", "it", " Entry", "cell", "element", "event", "server", "index", "per", "zo", "array", "e", "ries", "her", "image", "auto", "record", "next", "reader", "data", "se", "term", "obj", "style", "r", "de", "info", "uri", "offset", "ace", "cel", "lc", "extra"], "buffer": ["row", "seed", "position", "cache", "channel", "vector", "uffer", "padding", "comment", "layer", "shape", "wave", "sequence", "feed", "buf", "queue", "slice", "number", "pad", "FFER", "length", "address", "header", "batch", "device", "server", "Buffer", "iter", "writer", "bytes", "transfer", "page", "memory", "result", "reader", "border", "data", "bb", "null", "b", "beta", "buff", "flush", "binary", "available", "reference"], "readed": ["texted", " ReadED", "readized", "readable", "readED", "bootable", "intED", "inted", "inputned", " readned", " readized", "inputed", "intized", " Readled", " Readed", " readended", "textended", "readered", "bootED", "readled", " Readned", " Readered", " readled", "booted", "inputED", " readED", "bootered", "readned", "textED", " Readable", "intended", " readered", "textized", "readended", " readable", "inputled"]}}
{"id1": "12579075", "id2": "6625074", "code1": "    public static XMLConfigurator loadFromSystemProperty(String propertyName) throws IOException {\n        String urlStr = System.getProperty(propertyName);\n        if (urlStr == null || urlStr.length() == 0) {\n            return null;\n        }\n        InputStream in = null;\n        DOMRetriever xmlDoc = null;\n        try {\n            URL url = new URL(urlStr);\n            xmlDoc = new DOMRetriever(in = url.openStream());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (in != null) in.close();\n        }\n        return newInstance(xmlDoc);\n    }\n", "code2": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"loadFromSystemProperty": ["loadFromLocalProperty", "loadFromsystemProperty", "loadFormSystemString", "loadFromSysString", "loadFromLocalString", "loadFromSystemString", "loadFromSysperties", "loadFromSystemproperty", "loadFromSysProperty", "loadFromLocalproperty", "loadFormsystemProperty", "loadFormSystemperties", "loadFromsystemperties", "loadFromLocalperties", "loadFormsystemString", "loadFormSystemProperty", "loadFormSystemproperty", "loadFromSystemperties", "loadFromsystemproperty", "loadFromSysproperty", "loadFromsystemString", "loadFormsystemperties", "loadFormsystemproperty"], "propertyName": ["filePart", "fileName", "PropertyStr", "propertyValue", "propName", "propertyString", "fileNames", "propNames", "fileString", "PropertyValue", " propertyPath", " propertyStr", "propertyNames", "propertyPart", " propertyPart", "propPart", "propertyPath", " propertyValue", "PropertyPath", " propertyNames", "PropertyName", " propertyString", "propString", "propStr", "propPath", "propertyStr", "propValue"], "urlStr": ["urlName", "httpStr", " urlWr", "UrlName", "httpText", "urlstr", "URLName", "URLSt", " urlName", "uriName", " urlString", "httpstr", "urlText", "urlWr", "UrlSt", "Urlstr", "URLStr", "resourceSt", "URLString", "UrlText", "UrlString", "uriWr", "urlSt", "UrlWr", "uristr", "UrlStr", "uriStr", " urlSt", "URLstr", "httpName", "resourceStr", "urlString", "URLWr", " urlstr", " urlText", "resourceString"], "in": ["resource", "In", "again", "serv", "n", "c", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "ic", "as", "con", "ins", "doc", "ac", "cf", "conn", "min", "inn", "p", "err", "l", "isin", "part", "init", "out", "gin", "fac", "f", "session", "i", "nin", "a", "image", "socket", "login", "ssl", "reader", "data", "r", "inc", "id", "source", "stream", "client", "src", "file"], "xmlDoc": ["webUrl", "domDoc", "mlStr", " xmlConfig", "officeStr", "webDocument", "officeDocument", "externalStr", "mlUrl", "mlDocument", "xmlConfig", "jsonDocument", "externalDocument", "domUrl", "domDocument", "jsonDoc", "mlConfig", "externalConfig", "jsonStr", "externalDoc", "webDoc", "xmlStr", " xmlDocument", "xmlUrl", "xmlDom", "domStr", "webStr", "xmlDocument", "officeDoc", "jsonDom", "officeDom", " xmlStr", " xmlDom", "mlDoc"], "url": ["resource", "fr", "string", "instance", "http", "str", "www", "input", "URL", "ll", "inst", "io", "open", "feed", "gl", "Url", "download", "client", "user", "bel", "browser", "l", "connection", "base", "ls", "server", "config", "sl", "f", "el", "image", "socket", "inf", "ssl", "reader", "data", "b", "id", "web", "uri", "stream", "buffer", "source", "src", "file"]}}
{"id1": "10451698", "id2": "19335986", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "label": 1, "substitutes": {"copy": ["run", "cop", "paste", "share", "cat", "zip", "rm", "py", "Copy", "move", "process", "ignore", "list", "sync", "download", "archive", "part", "replace", "drop", "cp", "clone", "delete", "get", "load", " cp", "dump", "split", "transfer", "file", "remote", "change", "clip", "write", "type", "parent", "update", "lock", "ssh", "create"], "source": ["folder", "resource", "slave", "root", "plus", "class", "use", "section", "seed", "project", "string", "current", "site", "cache", "Source", "sf", "view", "proxy", "service", "scope", "ource", "path", "from", "slice", "client", "ce", "object", "archive", "unit", "ie", "connection", "document", "storage", "model", "server", "url", "config", "flat", "iter", "filename", "SOURCE", "start", "image", "remote", "result", "directory", "reader", "data", "secure", "target", "null", "parent", "stream", "info", "src", "name", "file"], "destinationDirectory": ["destinationsFolder", "destructionFolder", "destinatorDirectory", "destributionFile", "DestinationDir", "destributionDirectory", "destinatorPath", "destinationHome", "destinationPoint", " destinationDir", "destippingDir", "destinatorPoint", " destinationsDir", "destributionHome", "destructionDir", "destificationDirectory", "destributionFolder", "destributionDir", " destinationsFile", "DestinationDirectory", "destarationPoint", "destinationsDirectory", "DestinationFolder", "destinationPath", " destinationsFolder", "DestributionHome", "destributionPath", "destinationFile", "destarationPath", "destinationsDir", "destarationDirectory", "destructionDirectory", "destributionPoint", "destinationsFile", "destificationDir", "DestinationPath", "DestinationHome", " destinationsDirectory", "DestributionPoint", "destippingFolder", "DestinationPoint", " destinationFolder", "DestributionPath", "destificationFolder", "DestributionDirectory", "destippingDirectory", "destificationHome", "destippingHome", "destinationFolder", "destinationDir", " destinationFile", "DestributionFolder", "destructionFile", "DestributionDir"], "newDir": ["NewFolder", " newFolder", "NewFile", "Newdir", "nextDirectory", "nextFile", "newdir", "newFolder", "NewDirectory", "nextFolder", " newdir", "newDirectory", "nextDir", "nextdir", "NewDir", " newDirectory"], "children": ["names", "pages", "packages", "each", "words", "father", "current", "parents", "opens", "values", "list", "ools", "files", " Children", "ins", "events", "ums", "members", "content", "child", "begin", "loc", "tests", "roots", "when", "url", "ren", "projects", "scenes", "balls", "kids", "other", "blocks", "ul", "iblings", "filename", "uc", "Children", "rules", "data", "items", "mount", "sub", "parent", "web", "iv", "pes", "collection", "which", "sort", "rows"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "n", "ii", "k", "m", "pi", "ini", "o", "y", "d", "inner", "ci", "di", "io", "key", "slice", "ji", "ui", "in", "ri", "ie", "p", "it", "part", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "ori", "q", "start", "h", "gi", "v", "ti", "type", "ai", "mi", "b", "xi", "id", "info", "uri", "iv", "ix", "mu", "lc", "end"], "newFile": ["Newfile", "oldDir", "createFile", "nextSource", "newSource", "oldFiles", "NewFile", " newSourceFile", "nextfile", "newFiles", "createSource", " newfile", "NewFiles", "nextFile", "nextSourceFile", "nextFiles", "NewDirectory", "NewSourceFile", "newDirectory", "newfile", "nextDir", "oldFile", "createDir", "newSourceFile", "NewSource", "NewDir", "createfile", "oldDirectory", " newFiles", " newDirectory"], "output": ["resource", "temp", "application", "external", "again", "current", "ilo", "o", "option", "service", "response", "core", "outer", "after", "display", "operation", "object", "address", "unit", "generation", "connection", "out", "config", "complete", "oper", "other", "control", "image", "socket", "writer", "result", "page", "four", "error", "ou", "write", "kernel", "change", "target", "put", "web", "parent", "generated", "binary", "update", "console", "file", "Output", "flow"], "input": ["resource", "temp", "pull", "plus", "operator", "instance", "current", "context", "request", "http", "inner", "self", "feed", "text", "this", "in", "child", "ack", "print", "audio", "connection", "out", "storage", "exec", "work", "config", "index", "Input", "before", "ink", "image", "socket", "inf", "reader", "data", "error", "raw", "inc", "parent", "stream", "client", "buffer", "form", "keep", "flow"], "buff": ["bound", "txt", "fe", "ob", "cast", "comment", "bin", "uff", "shape", "feed", "char", "buf", "slice", "cod", "pad", "cf", "length", "boot", "count", "bug", "batch", "comb", "ph", "ff", "oct", "gb", "hello", "cp", "cmd", "cur", "load", "f", "gz", "uf", "bind", "cb", "bb", "data", "Buff", "b", "fb", "flush", "pack", "info", "buffer", "back", "text", "rb"], "read": ["reads", "ask", "run", "pass", "use", "ip", "send", "n", "and", " write", "readable", "k", "reading", "fill", "select", "READ", "lex", "io", "open", "feed", "add", "slice", "sync", "skip", "length", " count", "count", "seek", "play", "Read", " load", "rate", "exec", "find", "get", "load", "x", "config", "wait", "size", "f", "iter", "index", "len", "allow", "ink", "ind", "ok", "check", "start", "close", "transfer", "next", "reader", "se", "type", "write", "parse", "b", "en", "id", "loop", "buffer", "text", "end"]}}
{"id1": "14038176", "id2": "23152865", "code1": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "code2": "    protected JavaFileObject open(String className) throws IOException {\n        JavaFileObject fo = getClassFileObject(className);\n        if (fo != null) return fo;\n        String cn = className;\n        int lastDot;\n        while ((lastDot = cn.lastIndexOf(\".\")) != -1) {\n            cn = cn.substring(0, lastDot) + \"$\" + cn.substring(lastDot + 1);\n            fo = getClassFileObject(cn);\n            if (fo != null) return fo;\n        }\n        if (!className.endsWith(\".class\")) return null;\n        if (fileManager instanceof StandardJavaFileManager) {\n            StandardJavaFileManager sfm = (StandardJavaFileManager) fileManager;\n            fo = sfm.getJavaFileObjects(className).iterator().next();\n            if (fo != null && fo.getLastModified() != 0) {\n                return fo;\n            }\n        }\n        if (className.matches(\"^[A-Za-z]+:.*\")) {\n            try {\n                final URI uri = new URI(className);\n                final URL url = uri.toURL();\n                final URLConnection conn = url.openConnection();\n                return new JavaFileObject() {\n\n                    public Kind getKind() {\n                        return JavaFileObject.Kind.CLASS;\n                    }\n\n                    public boolean isNameCompatible(String simpleName, Kind kind) {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public NestingKind getNestingKind() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Modifier getAccessLevel() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public URI toUri() {\n                        return uri;\n                    }\n\n                    public String getName() {\n                        return url.toString();\n                    }\n\n                    public InputStream openInputStream() throws IOException {\n                        return conn.getInputStream();\n                    }\n\n                    public OutputStream openOutputStream() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Writer openWriter() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public long getLastModified() {\n                        return conn.getLastModified();\n                    }\n\n                    public boolean delete() {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            } catch (URISyntaxException ignore) {\n            } catch (IOException ignore) {\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"fetchUrl": ["forkLocation", "fprocessLink", "fprocessContent", "porkLocation", "fdownloadUrl", "fprocessLocation", "forkContent", "fdownloadLink", "porkContent", "fetchLocation", "forkUrl", "petchLink", "forkLink", "fetchContent", "petchLocation", "fetchLink", "fdownloadContent", "petchUrl", "porkLink", "porkUrl", "petchContent", "fprocessUrl", "fdownloadLocation"], "urlString": ["httpStr", "urlStr", " urlName", "URLStr", "URLString", " urlstring", "URLService", " urlStream", "resourceStream", "urlService", " urlStr", "httpString", "urlStream", "httpName", "resourceService", "resourceStr", "resourceString", " urlService", "urlstring", "resourcestring", "URLStream", "httpstring", "resourceName", "urlName"], "url": ["resource", "string", "blog", "http", "service", "URL", "log", "ur", "feed", "Url", "user", "object", "bel", "build", "browser", "l", "connection", "base", "server", "loader", "sl", "f", "image", "ssl", "bb", "r", "b", "plugin", "uri", "stream", "buffer", "source", "org", "file"], "reader": ["resource", "or", "row", "reading", "upper", "http", "oder", "ler", "input", "layer", "io", "feed", "driver", "in", "ri", "er", "cher", "handler", "err", "bird", "rc", "server", "loader", "read", "Reader", "per", "iter", "e", "rer", "i", "worker", "editor", "writer", "result", "bb", "rr", "r", "rx", "parser", "rar", "buffer", "stream", "uri", "source"], "line": ["inline", "entry", "row", "pass", "string", "word", "LINE", "str", "comment", "character", "le", "Line", "response", "log", "feed", "char", "number", "key", "column", "content", "object", "letter", "header", "cl", "l", "part", "base", "lin", "cell", "sl", "block", "link", "iter", "e", "code", "len", "page", "result", "next", "error", "data", "raw", "style", "id", "message", "lf", "buffer", "source", "text", "body", "sel", "name", "job", "file", "lc"], "builder": ["entry", "row", "string", "upper", "board", "oder", "response", "layer", "api", "feed", "builders", "this", "driver", "database", "object", "letter", "creator", "keeper", "address", "build", "db", "base", "array", "sb", "iter", "building", "holder", "wrapper", "bean", "Builder", "editor", "writer", "to", "result", "runner", "bb", "r", "b", "null", "parser", "message", "info", "buffer", "uri", "web", "block", "core"]}}
{"id1": "22410173", "id2": "7103223", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public void testPost() throws Exception {\n        HttpPost request = new HttpPost(baseUri + \"/echo\");\n        request.setEntity(new StringEntity(\"test\"));\n        HttpResponse response = client.execute(request);\n        assertEquals(200, response.getStatusLine().getStatusCode());\n        assertEquals(\"test\", TestUtil.getResponseAsString(response));\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "source": ["resource", "route", "use", "site", "Source", "inner", "input", "copy", "ource", "path", "down", "from", "slice", "ins", "unit", "ie", "up", "connection", "base", "url", "size", "iter", "SOURCE", "start", "internal", "sin", "image", "reader", "ources", "target", "id", "parent", "stream", "src", "name", "file"], "dest": ["folder", "temp", "done", "exit", "project", "dist", "bin", "destroy", "desc", "down", "path", "die", "this", "comb", "connection", "orig", "tmp", "delete", "thin", "flat", "home", "Dest", "transfer", "img", "output", "test", "true", "target", " destination", "de", "wb", "src", "name", "later", "file"], "in": ["resource", "In", "pull", "again", "n", "c", "ini", "IN", "m", "cin", "inner", "din", "bin", "src", "input", "as", "con", "this", "pin", "ins", "min", "conn", "inn", "ie", "err", "up", "init", "win", "s", "url", "work", "gin", "f", "inside", "i", "by", "nin", "a", "image", "socket", "start", "file", "login", "reader", "data", "r", "b", "plugin", "inc", "id", "info", "lock", "client", "re", "name"], "out": ["timeout", "temp", "not", "at", "again", "cat", "n", "c", "channel", "o", "option", "call", "ex", "exp", "inner", "bin", "with", "Out", "self", "log", "outer", "io", "outs", "this", "sync", "conn", "no", "our", "err", "up", "connection", "init", "net", "w", "exec", "url", "index", "pool", "off", "password", "i", "lib", "socket", "plain", "writer", "to", "ext", "img", "output", "ou", "write", "data", "obj", "OUT", "vert", "inc", "id", "parent", "client", "name", "file", "extra"]}}
{"id1": "21642215", "id2": "7545002", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "    public static String POST(String url, String[][] props) throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        for (int i = 0; i < props.length; ++i) {\n            conn.addRequestProperty(props[i][0], props[i][1]);\n        }\n        conn.connect();\n        try {\n            return new String((byte[]) conn.getContent());\n        } finally {\n            conn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"addIDs": ["loadID", "loadLinks", "addIDS", "findIDs", "findLinks", "loadIDS", "addLinks", "loadIDs", "findIDS", "addID", " addIDS", " addID", "findID", " addLinks"], "row": ["item", "entry", "group", "ry", "scan", "col", "table", "view", "copy", "report", "feed", "list", "key", "post", "tr", "user", "bug", "batch", "up", "ro", "cell", "server", "query", "index", "per", "array", "tab", "head", "record", "result", "reader", "raw", "r", "job", "info", "column", "builder", "Row", "ow", "rows"], "name": ["Name", "resource", "username", "description", "n", "string", "word", "title", "str", "named", "time", "path", "search", "key", "number", "connection", "prefix", "query", "size", "filename", "image", "start", "ame", "NAME", "filter", "type", "info", "source", "alias", "file"], "in": ["resource", "string", "In", "token", "container", "again", "serv", "at", "n", "c", "ini", "IN", "rec", "m", "cin", "ex", "cache", "xml", "http", "is", "inner", "din", "bin", "with", "input", "ic", "as", "path", "con", "pin", "ins", "doc", "conn", "min", "inn", "user", "err", "it", "l", "init", "s", "win", "out", "query", "gin", "f", "iter", "session", "i", "nin", "a", "image", "record", "socket", "login", "ssl", "file", "reader", "gen", "diff", "r", "b", "inc", "buffer", "stream", "source", "lock", "re", "update"], "urlName": ["filePart", "fileName", "urlPart", "UrlName", "toolPath", "lname", "URLName", "urlStr", "UrlPart", "lName", "toolName", " urlname", "urlPath", " urlPath", "URLPath", " urlType", "Urlname", "lPath", "urlname", "filePath", "UrlStr", " urlStr", "lStr", "toolname", "filename", " urlPart", "URLname", "lType", "UrlType", "urlType", "UrlPath"], "url": ["resource", "channel", "http", "service", "input", "URL", "path", "io", "open", "feed", "gl", "Url", "client", "user", "bel", "l", "connection", "base", "out", "server", "loader", "sl", "f", "link", " URL", "hub", "image", "socket", "ssl", "reader", "fl", "r", "b", "web", "uri", "stream", "source", "buffer", "org", "file"], "inputLine": ["InputLo", "typeline", "readSync", "rawL", " inputline", "readLook", "inputString", "againLINE", "inputStream", "dataLINE", "readline", "InputBlock", "requestUrl", "inputBlock", "searchLine", "formLINE", "formLin", "indexEntry", "inputline", "dataLink", "formline", "inputLo", " inputSync", "htmlString", "dataRoute", "InputStream", "issueline", "uploadline", "formLine", "Inputline", " inputEntry", "responseFile", "requestEmail", "dataLook", "inputFile", "inputLook", "uploadLin", "dataUrl", " inputFile", "dataSync", "typeLink", "indexLine", "rawFile", " inputString", "htmlline", "typeLine", "inputL", " inputLINE", "inputLink", "InputLink", " inputLo", "updateLine", "input\n", "againLine", "inputWrite", "dataLo", "uploadSel", "dataLine", "indexLINE", "againUrl", "output\n", "execEmail", "readL", " inputLin", "accessLINE", "execLine", "readLin", "baseline", "dataFile", " inputL", "Input\n", "requestLINE", " inputStream", "requestLine", "dataline", " inputUrl", "accessSync", "InputRoute", "requestline", "readFile", " inputWrite", "htmlLine", "InputFile", "inputLINE", "baseLine", "responseLink", "accessLine", "rawline", "inputLin", "dataSource", "updateLin", " inputLook", "htmlLINE", "InputLine", "searchStream", "rawLine", "baseLINE", "againWrite", "typeLINE", "inputSource", "readLine", "responseLine", "inputSync", " inputLink", "uploadLine", "inputUrl", "updateline", "indexSync", "accessEntry", " inputSel", "InputSource", "responseLINE", " inputEmail", "execUrl", "dataLin", "searchFile", "baseFile", " inputRoute", "dataBlock", "inputEntry", "requestString", "issueLine", "updateLINE", " inputBlock", " inputSource", "dataWrite", "inputSel", "inputRoute", " input\n", "InputLINE", "InputSync", "issueLin", "InputL", "execline", "inputEmail", "searchL", "issueSel"], "score": ["scoring", "live", "ranking", "status", " Score", "seed", "fee", "speed", "Score", "player", "winner", "time", "cost", "sc", "match", "ner", "key", "fit", "length", "count", "weight", "grade", "rate", "confidence", "width", "rank", "price", "size", "game", "index", "code", "gain", "value", "rice", "feature", "result", "loss", "test", "level", "error", "message", "core"], "metaboliteID": ["metovaliteName", "metabolitionID", "metabololeName", "metabolheticId", "metmboliqueType", "metabolheticIndex", "metabolitionId", "metabolitableID", "metabolitationId", "metmboliteIDs", "metabolriteIN", "metovaliteAddress", "metabolicizeID", "metovalriteIN", "metabolizeName", "metabolriteScore", "metabolidateScore", "metabolriteAddress", "metabolizeScore", "metabolriteId", "metovalriteIndex", "metabolverseIN", "metabolitableName", "metabolheticID", "metovaliteIndex", "metaboliciteName", "metovalriteId", "metaboliteIDs", "metaboliciteInfo", "metmboliqueIDs", "metovalriteAddress", "metabolitableType", "metaboliqueIDs", "metabolriteIndex", "metabololeSize", "metaboliqueID", "metabolidateInfo", "metmboliqueID", "metabolitationName", "metabolizeID", "metabolitableSize", "metmboliteID", "metaboliciteScore", "metabolicizeName", "metovaliteId", "metabolheticAddress", "metmboliteIndex", "metaboliqueId", "metmbolitableIndex", "metaboliteType", "metovaliteIN", "metovalriteID", "metaboliqueType", "metabolriteInfo", "metaboliteAddress", "metabolriteSize", "metabolriteName", "metabololeIndex", "metabolriteType", "metabolitionAddress", "metovalriteName", "metabolizeInfo", "metaboliteScore", "metabolitionIndex", "metabolverseName", "metaboliteName", "metaboliteId", "metabolverseId", "metaboliciteID", "metabolitationIN", "metabolriteIDs", "metabolitableId", "metaboliteIndex", "metmboliteId", "metmbolitableSize", "metabolitationID", "metabolitableIndex", "metaboliteSize", "metabolicizeScore", "metabolidateName", "metabolidateID", "metabolitableIDs", "metabololeID", "metabolverseID", "metmboliqueId", "metmbolitableID", "metmboliteName", "metmboliteType", "metaboliteInfo", "metabolicizeInfo", "metmbolitableName", "metabolriteID", "metaboliteIN", "metmboliteSize", "metovaliteID"], "dataScore": [" dataMatch", "laScore", " dataLevel", " dataRank", "DataScore", "DataMatch", "inputMatch", "laPath", "numberType", "dataID", "videoType", "DataSize", "doubleWeight", "inputSource", "DataRank", "dataRank", "laSum", "styleWeight", "DataSum", "dataWeight", "numberGrade", " dataSum", "inputScore", "DataPath", "dataPath", "videoScore", "numberWeight", "styleSize", "dataMatch", "dataSize", "indexScore", "DataLevel", "indexPath", "doubleScore", "numberScore", "inputPath", "dataType", "numberLevel", " dataPath", "styleScore", "dataSum", "indexSource", " dataGrade", "doubleRank", "indexID", "styleType", "dataGrade", " dataSize", " dataSource", " dataWeight", "numberRank", "DataGrade", "inputID", " dataType", "videoSize", "laLevel", "dataSource", "inputSize", " dataID", "videoWeight", "doubleType", "dataLevel"], "data": ["resource", "done", "media", "zip", "string", "map", "dat", "results", "area", "response", "input", "empty", "key", "number", "ui", "pad", "json", "div", "content", "weight", "sample", "batch", "missing", "alpha", "DATA", "size", "array", "code", "value", "image", "split", "result", "change", "error", "picture", "style", "ata", "info", "source", "message", "text", "body", "buffer", "extra"], "molecularWeight": ["molecularWidth", "mosellularWidth", "moleularWidth", "mosellularFlow", "mosecularWidth", "moleuralWeight", "molellularFlow", "moleciumWidth", "molecularSize", "molescularWeight", "molellularWeight", "moleculeSize", "mosecularFlow", "molescularWidth", "moleuralWidth", "moleciumWeight", "mosellularWeight", "moleculeWeight", "mosecularWeight", "molecularFlow", "molesularWeight", "moleularSize", "moleuralSize", "moleculeWidth", "molesularWidth", "molesularSize", "moleularWeight", "moleciumFlow", "molescularSize", "moleculeFlow", "molellularWidth"]}}
{"id1": "19584877", "id2": "15768167", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFiletoString", "encodeFile2File", "encodeString2File", "encodeFiletoStream", "encodeFiletoFile", "encodeStringToString", "encodeFileToString", "encodeFileToStream", "encodeStringToFiles", "encodeStringToFile", "encodeFile2Files", "encodeString2String", "encodeFileFromFiles", "encodeFileFromString", "encodeStringToStream", "encodeFileFromStream", "encodeString2Stream", "encodeString2Files", "encodeFileToFiles", "encodeFile2String", "encodeFile2Stream", "encodeFiletoFiles", "encodeFileFromFile"], "infile": [" infp", "inputfilename", "infp", "inputFile", "outfiles", " infiles", "Infilename", "inputfp", "inputfiles", "outfilename", "Infile", "outfp", " infilename", "InFile", "inFile", "inputfile", "Infiles", "outFile", "infiles", "infilename"], "outfile": [" outname", "OutFile", "outfolder", "infp", "newFile", "Outname", "newname", "outname", " outFile", "newfolder", "outfilename", "outfp", " outfilename", " outfolder", "Outfile", "outputfp", "Outfolder", "newfile", "infolder", "outputfolder", "outFile", "outputfile", "outputfilename", " outfp", "infilename"], "in": ["In", "inas", "pass", "again", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "ic", "as", "con", "pin", "ins", "ac", "min", "conn", "inn", "into", "err", "isin", "init", "win", "s", "base", "rin", "gin", "thin", "inside", "i", "nin", "a", "image", "socket", "sin", "login", "reader", "data", "vin", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "In", "or", "exit", "again", "line", "cache", "o", "ex", "inner", "bin", "Out", "copy", "outer", "io", "outs", "co", "post", "sync", "on", "conn", "no", "err", "up", "net", "base", "exec", "work", "name", "session", "off", "home", "image", "lib", "socket", "to", "writer", "output", "error", "ou", "write", "obj", "OUT", "point", "job", "inc", "parent", "source", "client", "one", "file"], "buffer": ["seed", "cache", "uffer", "limit", "padding", "input", "layer", "wave", "feed", "buf", "slice", "queue", "length", "address", "count", "batch", "base", "server", "url", "size", "Buffer", "iter", "len", "value", "split", "bytes", "transfer", "result", "border", "bb", "reader", "data", "write", "type", "raw", "null", "b", "fb", "buff", "flush", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", "tell", " Read", "use", "ip", " skip", "send", "n", " write", "current", "reading", "fill", "limit", "select", "input", "copy", "READ", "lex", "io", "feed", "add", "slice", "sync", "length", " count", "count", "seek", "play", "Read", "ad", "exec", "find", "get", "load", "x", "wait", "size", "work", "f", "iter", "len", "i", "allow", "ind", "_", "start", "ride", "close", "connect", "check", "reader", " copy", "parse", "write", "next", "se", "raw", "inc", "id", "sleep", "end"], "success": ["rolled", "done", "pass", "status", "again", "respons", "initial", "method", "results", "failed", "comment", "winner", " Success", "continue", "response", "func", "fast", "right", "path", "open", "Success", "modified", "ceed", "primary", "first", "warning", "construct", "content", "ccess", "growth", "roll", "good", "valid", "successful", "flash", " successful", "default", "danger", "model", "fail", " succeed", "complete", " succ", "value", "rolling", "result", "better", "true", "error", "data", "follow", "xx", "null", "successfully", "message", "cess"]}}
{"id1": "16851955", "id2": "11032546", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 1, "substitutes": {"testTrainingBackprop": ["testTrainingFrontprop", "testTrainBackdrop", "testTrainingFrontdrop", "testTrainingBACKpointer", "testTrainingBACKdrop", "testTrainingBackpointer", "testTrainingBACKpressure", "testTrainBACKpressure", "testTrainBackprop", "testTrainingFrontpointer", "testTrainBackpressure", "testTrainingBackpressure", "testTrainBACKprop", "testTrainBackpointer", "testTrainingBACKprop", "testTrainBACKdrop", "testTrainingBackdrop", "testTrainBACKpointer", "testTrainingFrontpressure"], "temp": ["folder", "txt", "wrap", "pipe", "local", "pdf", "container", "full", "zip", "clean", "cache", "current", "dat", "ex", "http", "input", "copy", "path", "io", "empty", "this", "dest", "form", "archive", "base", "out", "storage", "model", "tmp", "tem", "config", "fake", "f", "flat", "session", "emp", "writer", "v", "test", "output", "Temp", "data", "directory", "save", "stable", "porary", "mount", "parent", "buffer", "lock", "font", "cel", "file", "template"], "layers": ["lobs", " lients", "lowers", "slowers", "dlayers", "nlayers", "slays", "licikes", "placks", "Layers", "lasks", "backs", " languages", "lacks", "liayers", "slacks", "fllements", "planguages", "languages", "blayers", " lowers", "bowers", "players", "flasses", "lients", "lagers", "liacks", "liores", "gients", "lasses", " lays", "dlasks", "flanguages", "flayers", "liibraries", "likes", "licayers", "dlacks", "gayers", "Lobs", " likes", " lasks", "licagers", "bllements", " lobs", "Lients", "lores", "blanguages", "nlibraries", " lagers", "llements", "nlagers", "slayers", " libraries", "dlores", "licibraries", " lasses", "gobs", "lays", "nlikes", "plasks", "bays", "bayers", "libraries", "dlibraries", " lores", "dlanguages", " llements", " lacks", "blasses"], "fann": ["larn", "sfannon", "fain", "xfanny", "elfnn", "gana", "garn", "elfann", "fanny", "lnn", "fana", "fnn", "lann", "Fannon", "xfann", "xfannon", "lana", "xfain", "elfana", "sfann", "Fanny", "gann", "farn", "elfarn", "Fann", "gnn", "sfanny", "sfain", "Fain", "fannon"], "trainer": ["strainer", "tacker", "striner", "tracer", "rain", "Triner", "retacer", "traacer", "Tracker", "tracker", "triner", "stracker", "racker", "racer", "Trainer", "retiner", "traacker", "traainer", " tracker", "strayer", "rainer", "trayer", "stracer", " train", "tacer", "train", "retainer", "retayer", "trarain", " tracer", "trrain", "strain", "Tracer", "Trrain", "Trayer", "tainer"], "desiredError": ["desirableSize", "deservedOrder", "desciredError", "despectedProblem", "DesireException", "desidedFailure", "desizedException", "desiringError", "DesireSize", "reservedOrder", "desivedError", "desiredEvent", "descirederror", "desirableOrder", "desivedSize", "descidedFailure", "deservedError", "despectederror", "DesiredException", "reservedEvent", "resiredOrder", "desiredException", "despectedError", "descidederror", "resiredError", "desiringFailure", "designedError", "desiredFailure", "desciredFailure", "desizedSize", "descidedError", "desidedProblem", "DesiredSize", "designedOrder", "desivedException", "desirableEvent", "desirederror", "desireError", "resiredEvent", "desiredProblem", "descidedProblem", "desidedError", "desciredProblem", "despectedFailure", "desizedError", "DesiredError", "desirableError", "desiredOrder", "deservedEvent", "reservedSize", "desiredSize", "desireSize", "desireException", "DesireError", "desidederror", "desiringerror", "desiringProblem", "resiredSize", "deservedSize", "designedSize", "designedEvent", "reservedError"], "mse": ["fmce", "gmse", "fmte", "mce", " mSE", " mce", "gmge", "mte", "fmze", "Mte", "MSE", "Mze", "fSE", "fce", " mge", "fse", " mte", "mge", "gmSE", "Mse", "Mce", "fmse", "mze", " mze", "gmce", "fge", "Mge", "mSE"]}}
{"id1": "22993368", "id2": "7458833", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeStringToFiles", "decodeFileAsFiles", "decodeStringToFile", "decodeFileAsStream", "decodeString2Stream", "decodeFileFromStream", "decodeFileFromFiles", "decodeStringToString", "decodeFile2File", "decodeFileAsString", "decodeFileFromFile", "decodeStringToStream", "decodeFileToString", "decodeString2String", "decodeFile2String", "decodeFile2Files", "decodeFileToStream", "decodeFileToFiles", "decodeFileAsFile", "decodeString2File", "decodeString2Files", "decodeFileFromString", "decodeFile2Stream"], "infile": [" infp", " instream", "minbase", "Inbase", "inputfilename", "infp", "minstream", "outfiles", " infiles", "minFile", "inputfp", "inputfiles", "minfile", "outfilename", "Infile", "inbase", " inbase", "outfp", " infilename", "instream", "InFile", "inFile", "inputfile", " inFile", "Instream", "infiles", "infilename"], "outfile": ["outputpath", "outfolder", " outdatabase", "inputFile", "outputFile", "inputdatabase", " outFile", "outfilename", "inputpath", " outfilename", " outfolder", "outpath", " outpath", "outputdatabase", "inFile", "inputfile", "infolder", "outputfolder", "outFile", "outputfile", "outputfilename", "infilename", "outdatabase"], "in": ["In", "inas", "pass", "again", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "ic", "as", "con", "pin", "ins", "ac", "min", "conn", "inn", "into", "err", "isin", "init", "win", "s", "rin", "lin", "gin", "thin", "inside", "i", "nin", "a", "socket", "sin", "login", "reader", "data", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "In", "or", "pass", "exit", "line", "again", "cache", "channel", "o", "ex", "inner", "bin", "Out", "copy", "outer", "log", "io", "outs", "co", "post", "sync", "conn", "no", "err", "up", "net", "base", "exec", "work", "name", "session", "off", "home", "image", "lib", "socket", "to", "writer", "output", "error", "ou", "write", "obj", "OUT", "point", "job", "inc", "parent", "client", "one", "file"], "buffer": ["seed", "channel", "cache", "uffer", "limit", "padding", "bin", "input", "layer", "wave", "feed", "buf", "queue", "slice", "length", "address", "count", "batch", "base", "server", "url", "size", "Buffer", "iter", "value", "split", "bytes", "transfer", "result", "border", "bb", "reader", "data", "write", "type", "raw", "null", "b", "buff", "flush", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", "tell", " Read", "use", "ip", " skip", "send", "n", " write", "current", "reading", "fill", "limit", "select", "copy", "READ", "lex", "io", "feed", "add", "slice", "sync", "length", " count", "count", "seek", "play", "Read", "ad", "exec", "find", "get", "load", "x", "wait", "size", "work", "f", "iter", "len", "i", "allow", "ind", "_", "start", "ride", "check", "connect", "next", "reader", " copy", "parse", "write", "se", "raw", "r", "inc", "id", "sleep", "end"], "success": ["rolled", "done", "pass", "status", "again", "initial", "method", "results", "failed", "comment", "winner", " Success", "continue", "response", "func", "right", "fast", "path", "open", "Success", "primary", "ceed", "first", "warning", "construct", "content", "ccess", "positive", "growth", "roll", "good", "valid", "successful", "flash", " successful", "default", "danger", "model", "fail", " succeed", "complete", " succ", "value", "rolling", "result", "better", "true", "follow", "data", "error", "xx", "null", "successfully", "message", "cess"]}}
{"id1": "822452", "id2": "15768167", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "14590676", "id2": "720361", "code1": "    public static void download(String address, String localFileName) {\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            URL url = new URL(address);\n            out = new BufferedOutputStream(new FileOutputStream(localFileName));\n            conn = url.openConnection();\n            in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n            System.out.println(localFileName + \"\\t\" + numWritten);\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        } finally {\n            try {\n                if (in != null) in.close();\n                if (out != null) out.close();\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        int result = 20;\n        if (args.length == 1) {\n            StringBuffer urlString = new StringBuffer(args[0]);\n            if (urlString.lastIndexOf(\"/\") != urlString.length() - 1) {\n                urlString.append('/');\n            }\n            urlString.append(\"GetConfig.jsp\");\n            URLConnection conn = new URL(urlString.toString()).openConnection();\n            System.out.println(Configuration.readObject(conn.getInputStream()));\n            result = 0;\n        } else {\n            System.err.println(\"usage: GetConfig <URL>\");\n        }\n        System.exit(result);\n    }\n", "label": 0, "substitutes": {"download": ["zip", "register", "append", "copy", "log", "open", "process", "Download", "release", " Download", "upload", "exec", "get", "load", "read", "link", "dump", "split", " downloading", "transfer", "save", "data", "parse", "update", "binary", "file"], "address": ["resource", "route", "ip", "position", "string", "host", "Address", "expression", "state", "URL", "path", "network", "number", "email", "audio", "connection", "base", "prefix", "port", "server", "addr", "location", "localhost", "password", "image", "socket", "remote", "directory", "output", "point", "target", "uri", "source", "name", "ress", "reference"], "localFileName": [" localSourceFileCopy", "localSourceFileAddress", "localBufferPath", " localSourceFileName", " localSourceFilename", "localPathPath", "localSourceFileTarget", "finalFilenameName", "localFilePath", "localFilesAddress", " localFileInfo", " localFullPath", "localFileAddress", "localPathName", "finalFileTarget", "localFilename", "localPathCopy", " localSourceFilePath", "localFullCopy", "localFilenameAddress", "localBufferAddress", " localFileCopy", "localFileTarget", "localSourceFilePath", "localFullname", " localFileAddress", " localFullAddress", "finalFilenameAddress", "localFileInfo", "localSourceFileInfo", " localFilename", " localFullInfo", "localSourceFileCopy", "localFilenameName", "finalFileName", " localFilePath", "finalFilenamePath", "localSourceFilename", "localPathname", "localFilesTarget", "localFilenamePath", "finalFileAddress", "localFilenameTarget", "localFullInfo", "localFileCopy", "localFilesName", "localFullAddress", "localSourceFileName", "localBufferName", "localFilesPath", "finalFilePath", "localFullName", "localFullPath", "localBufferInfo", "finalFilenameTarget", " localFullName"], "out": ["again", "global", "ex", "state", "with", "log", "con", "w", "pool", "image", "socket", "writer", "plain", "error", "write", "file", "flow", "cache", "o", "comment", "bin", "outer", "io", "user", "connection", "init", "dump", "code", "login", "output", "OUT", "null", "block", "at", "n", "instance", "channel", "exp", "copy", "outs", "co", "sys", "sync", "no", "net", "cli", "lib", "ext", "ou", "obj", "lock", "client", "name", "Output", "group", "window", "line", "string", "inner", "Out", "screen", "list", "object", "err", "up", "exec", "result", "point", "b", "inc", "source"], "conn": ["ch", "pc", "not", "n", "c", "Connection", "cache", "act", "ca", "http", "Conn", "conv", "ci", "ctx", "con", "api", "open", "co", "client", "impl", "ie", "err", "l", "connection", "init", "win", "net", "cn", "cp", "server", "config", "enc", "cli", "socket", "cb", "ssl", "nt", "ai", "conf", "nc", "connect", "core"], "in": ["In", "again", "ini", "oin", "n", "IN", "rec", "cin", "ex", "is", "din", "inner", "bin", "input", "as", "con", "pin", "ins", "ac", "on", "user", "inn", "into", "err", "connection", "init", "win", "lin", "exec", "gin", "index", "cli", "i", "by", "nin", "el", "image", "lib", "socket", "login", "file", "reader", "data", "b", "en", "inc", "id", "source", "client"], "url": ["resource", "pull", "ob", "string", "channel", "blog", "host", "http", "service", "URL", "log", "ll", "con", "api", "open", "Url", "rl", "client", "impl", "err", "rel", "l", "connection", "base", "ls", "server", "coll", "cur", "sl", "f", "cert", "nl", "image", "socket", "ssl", "b", "job", "web", "id", "uri", "connect", "org", "file"], "buffer": ["resource", "cache", "capacity", "uffer", "limit", "bin", "input", "copy", "layer", "wave", "feed", "buf", "queue", "slice", "FFER", "length", "count", "batch", "base", "phrase", "load", "read", "Buffer", "iter", "bytes", "transfer", "page", "border", "result", "reader", "reference", "data", "null", "b", "buff", "flush", "offset", "binary", "source", "padding"], "numRead": ["netReader", " numWrite", "nWrite", "nWritten", "maxWrite", " numReader", "netWritten", "numberWritten", "nRead", "numberRead", "NumWritten", "NumWrite", "nReader", "maxReader", "maxWritten", "netRead", "numberReader", "NumRead", "numWrite", "netWrite", "numberWrite", "maxRead", "NumReader", "numReader"], "numWritten": [" numWrite", "nWrite", "nWritten", "nRead", "NumWritten", "NumWrite", "numwritten", "umRead", "nwritten", "NumRead", "Numwritten", "numWrite", "umWritten", "umWrite", "umwritten", " numwritten"]}}
{"id1": "6379126", "id2": "23152865", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    protected JavaFileObject open(String className) throws IOException {\n        JavaFileObject fo = getClassFileObject(className);\n        if (fo != null) return fo;\n        String cn = className;\n        int lastDot;\n        while ((lastDot = cn.lastIndexOf(\".\")) != -1) {\n            cn = cn.substring(0, lastDot) + \"$\" + cn.substring(lastDot + 1);\n            fo = getClassFileObject(cn);\n            if (fo != null) return fo;\n        }\n        if (!className.endsWith(\".class\")) return null;\n        if (fileManager instanceof StandardJavaFileManager) {\n            StandardJavaFileManager sfm = (StandardJavaFileManager) fileManager;\n            fo = sfm.getJavaFileObjects(className).iterator().next();\n            if (fo != null && fo.getLastModified() != 0) {\n                return fo;\n            }\n        }\n        if (className.matches(\"^[A-Za-z]+:.*\")) {\n            try {\n                final URI uri = new URI(className);\n                final URL url = uri.toURL();\n                final URLConnection conn = url.openConnection();\n                return new JavaFileObject() {\n\n                    public Kind getKind() {\n                        return JavaFileObject.Kind.CLASS;\n                    }\n\n                    public boolean isNameCompatible(String simpleName, Kind kind) {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public NestingKind getNestingKind() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Modifier getAccessLevel() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public URI toUri() {\n                        return uri;\n                    }\n\n                    public String getName() {\n                        return url.toString();\n                    }\n\n                    public InputStream openInputStream() throws IOException {\n                        return conn.getInputStream();\n                    }\n\n                    public OutputStream openOutputStream() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Writer openWriter() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public long getLastModified() {\n                        return conn.getLastModified();\n                    }\n\n                    public boolean delete() {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            } catch (URISyntaxException ignore) {\n            } catch (IOException ignore) {\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"gerarTutorialPage": ["riarTourDir", "riarTutorialpage", "riarTinyElement", "riartutorialpage", "riarTutorialPage", "riarTravispage", "riarTravisDir", "riartourElement", "riarTutorialDir", "riarTourElement", "riartutorialDir", "riarTravisPage", "riarTinyPage", "riartutorialElement", "riarTourPage", "riarTinypage", "riarTourpage", "riarTutorialElement", "riartourPage", "riarTravisElement", "riartourDir", "riartourpage", "riartutorialPage", "riarTinyDir"], "indexDir": ["zipDir", "includeTier", "indexDIR", "zipJar", "indexJar", "includeDir", "zipTier", "includeDIR", "IndexJar", "indexTier", "zipDIR", "IndexTier", "includeJar", "IndexDir", "IndexDIR"], "cssDir": ["catsDir", "fontDir", "javascriptDb", "piecesD", "ssD", "fontDie", "CSSDIR", "gzDir", "cssDar", "javascriptDir", "fontDIR", "piecesDIR", "piecesDie", "ssDb", "gzUrl", "codesLen", "cssDoc", "CSSDirectory", "cssD", "CSSDir", "gzDIR", "codesDoc", "cssDIR", "ssDIR", "CSSDar", "catsDoc", "cssDb", "cssDie", "catsLen", "gzDirectory", "ssDar", "javascriptDar", "ssDie", "piecesDir", "ssDirectory", "CSSDb", "javascriptDIR", "CSSDoc", "cssUrl", "CSSLen", "fontD", "ssUrl", "ssDir", "cssDirectory", "CSSUrl", "codesDir", "cssLen"], "capDir": ["casVol", "apsdir", "casDir", "apsVol", "apsDirectory", "capVol", "CapDirectory", "capDirectory", "casDirectory", "casdir", "capdir", "CapDir", "Capdir", "apsDir", "CapVol"], "licDir": ["licManager", "libDir", "libManager", "voldir", "lifManager", "licDoc", "lifDir", "volManager", "volDir", "licdir", "volDoc", "lifDoc", "libdir", "lifdir", "libDoc"], "midDir": ["limdir", "limTier", "mindDIR", "mindDir", "casDir", "midDIR", "casdir", "midTier", "casDIR", "limDir", "middir", "mindTier", "casTier", "limDIR", "minddir"], "filesDir": ["filesFolder", "videosFile", "filesFile", "filesVol", "imagesFolder", "locksDir", "filesPos", "imagesFile", "videosDirectory", " filesPos", " filesVol", "stylesDirectory", "filesDur", "locksDur", "stylesDIR", "videosFolder", "FilesDirectory", "opensDirectory", "stylesDir", "filesDirectory", "FilesDir", "pagesDir", "pagesVol", "locksDIR", "ballsPos", "locksDirectory", "filesDIR", "ballsVol", "opensDIR", "imagesDirectory", "FilesFolder", "imagesDir", "ballsDir", "FilesFile", "pagesPos", "opensDur", "opensDir", "stylesDur"], "videosDir": ["videoDirectory", "videosFile", " videosFile", " videosDb", "videosDb", "videosUrl", "videosDirectory", "videoDb", " videosDirectory", "viewsFile", "viewsDirectory", "viewsUrl", "videoFile", "videoDir", " videosUrl", "videoUrl", "imagesDir", "viewsDir", "imagesDb"], "imagensDir": ["imagentsDIR", "imagenciesDirectory", " imagersJar", "imagenDir", " imagersDir", " imagensDirectory", "imagentsDir", "imgensDIR", "imagersJar", "imagersDIR", "imgensDirectory", "imagersDir", "imagensJar", "imagensDirectory", "imagentsFile", "imagensFile", "imagentsDirectory", "imgentsDIR", "imgensDir", "imagenciesDir", "imgentsDirectory", "imgentsFile", "imagenJar", " imagersDirectory", "imagenciesDIR", " imagensFile", "imagersFile", "imagenciesFile", "imagentsJar", " imagensJar", "imagersDirectory", "imgentsDir", "imagensDIR", "imagenFile", " imagersFile", "imagenDirectory", "imgensFile"], "local": ["temp", "pass", "username", "global", "defined", "current", "present", "initial", "LOC", "request", "http", "d", "total", "inner", "safe", "state", "self", "input", "path", "log", "same", "partial", "util", "json", "active", "user", "dir", "shared", "loc", "p", "Local", "valid", "l", "part", "base", "Location", "prefix", "tmp", "upload", "small", "location", "standard", "where", "serial", "pal", " Local", "localhost", "basic", "home", "internal", "personal", "remote", "relative", "directory", "managed", "data", "conf", "back", "lock", "available", "specified", "name", "file"], "srcCss1": ["srcPcss4", "srcPcss2", "srcCpe2", "srcCssPre", "srcPss1", "srcCcssPre", "srcRcss2", "srcRss0", "srcRss2", "srcPssPre", "srcCrss3", "srcCass11", "srcCcss2", "srcPss4", "srcCcss11", "srcRcss0", "srcCse1", "srcCrss81", "srcCrss11", "srcCcss4", "srcCss81", "srcPcssPre", "srcCcss81", "srcRcss81", "srcCcss1", "srcCass1", "srcCse11", "srcCpe1", "srcRcss11", "srcPss81", "srcPcss1", "srcRcss1", "srcCcss0", "srcPss3", "srcRss1", "srcPcss3", "srcCfg1", "srcCrss2", "srcCpe4", "srcPcss81", "srcCcss3", "srcCrss1", "srcCpePre", "srcCass81", "srcCfg4", "srcCss11", "srcCse2", "srcCfgPre", "srcCass0", "srcRss81", "srcCse0", "srcPss2", "srcRss11", "srcCass3", "srcCass2", "srcCss0", "srcCfg2"], "destCss1": ["destPcss81", "destCass3", "destPcss1", "destCcss3", "destCxxCard", "destCxx3", "destPcss0", "destCcss0", "destPcss2", "destCassCard", "destCss0", "destCfg1", "destCfg0", "destCcssCard", "destCssCard", "destCass1", "destCrss3", "destCss81", "destPss1", "destCrss0", "destCxx1", "destCfg3", "destCfg2", "destPssCard", "destCrss2", "destCcss2", "destCcss1", "destPss0", "destCxx2", "destCrss1", "destCcss81", "destPcss3", "destPss81", "destPss2", "destCrss81", "destPss3", "destPcssCard", "destCass81", "destCass2"], "srcCss2": ["srcChess1", "srcPcss2", "srcPss1", "srcCcssTwo", "srcCrss3", "srcAcss4", "srcUssB", "srcPss27", "srcCcss2", "srcCross52", "srcChessTwo", "srcChess2", "srcCass4", "srcCrssL", "srcAcss2", "srcCass52", "srcAcss52", "srcCcss4", "srcUcssTwo", "srcChessB", "srcCssTwo", "srcCcss1", "srcUss2", "srcCass1", "srcCssB", "srcPcssL", "srcPcss27", "srcPcss1", "srcAccss2", "srcCrss27", "srcCross1", "srcCssL", "srcUcss1", "srcUcss2", "srcAcss1", "srcPss3", "srcCcss27", "srcPssL", "srcCng27", "srcPcss3", "srcAccss4", "srcCfgTwo", "srcCfg1", "srcCcss52", "srcCcssL", "srcCrss2", "srcAccss52", "srcCng1", "srcCcss3", "srcCss27", "srcCfg3", "srcCrss1", "srcCng2", "srcUcssB", "srcCross4", "srcAccss1", "srcUssTwo", "srcCcssB", "srcCfgB", "srcCss52", "srcPss2", "srcCross2", "srcUss1", "srcCfgL", "srcCass2", "srcCfg2"], "destCss2": ["destCcss4", "destCcss3", "destCess2", "destNss2", "destCfgB", "destNss1", "destNss72", "destCess32", "destCfg72", "destCestB", "destNcss32", "destCest2", "destCfg1", "destCss72", "destNcss1", "destNcss72", "destCess4", "destCfg3", "destCfg2", "destCcss32", "destCest3", "destNcssB", "destCcss2", "destNssB", "destCfg32", "destCest1", "destCcss1", "destCfg4", "destNss32", "destNcss4", "destCess72", "destNss4", "destNcss3", "destCcssB", "destCss32", "destCcss72", "destCssB", "destNss3", "destCess1", "destNcss2"], "srcCss3": ["srcCssAND", "srcCstyle2", "srcCsh3", "srcClass93", "srcCsh183", "srcCsh2", "srcCass4", "srcCss183", "srcRcss1", "srcPss3", "srcPcss3", "srcScss93", "srcCfg1", "srcCrssAND", "srcScstyle15", "srcCfg4", "srcPssAND", "srcCass3", "srcRcss2", "srcCrss3", "srcRss183", "srcCcss2", "srcCcss4", "srcCshThird", "srcCss15", "srcRss3", "srcScstyle3", "srcRss1", "srcCcssAND", "srcCrss2", "srcCfg3", "srcScss3", "srcCcssThird", "srcCsl2", "srcCfg2", "srcCslThird", "srcCstyleAND", "srcCass1", "srcCcss1", "srcCsl3", "srcScstyle2", "srcPcssAND", "srcClass3", "srcCss93", "srcCcss3", "srcCrss6", "srcCstyle15", "srcCcss6", "srcPcss6", "srcPss2", "srcRssThird", "srcPcss2", "srcRss2", "srcCssThird", "srcRcss4", "srcClass15", "srcRcss3", "srcCcss15", "srcScss2", "srcCcss93", "srcCstyle6", "srcCcss183", "srcCsl183", "srcRss4", "srcCstyle3", "srcClass2", "srcRcssThird", "srcRcss183", "srcScstyle93", "srcScss15", "srcPss6", "srcCstyle93", "srcCass2"], "destCss3": ["destCstyle43", "destCss53", "destCrss183", "destPcss53", "destCass3", "destCcss3", "destCross03", "destCross3", "destNss2", "destCss183", "destCja183", "destCross2", "destScrss6", "destScss2", "destCss03", "destCja3", "destPcss2", "destCstyle03", "destCstyle53", "destCcss43", "destNcss43", "destScrss183", "destCrss3", "destCcss53", "destScss3", "destCcss183", "destCross53", "destCstyle3", "destPcss03", "destNss43", "destCass43", "destCstyle2", "destScss183", "destCja2", "destCrss2", "destCrss6", "destCcss2", "destPss53", "destScrss2", "destPcss3", "destPss03", "destPss2", "destCcss6", "destNcss3", "destScrss3", "destCcss03", "destCss43", "destScss6", "destPss3", "destNss3", "destCja6", "destCass2", "destNcss2"], "srcCss4": ["srcCrssFour", "srcPcss4", "srcPcss2", "srcCrss4", "srcPss1", "srcPssFour", "srcCcss2", "srcPss4", "srcCass4", "srcCcss4", "srcCass1", "srcCcss1", "srcPcssFour", "srcPcss1", "srcCassFour", "srcCrss2", "srcCrss1", "srcCssFour", "srcCcssFour", "srcPss2", "srcCass2"]}}
{"id1": "18433984", "id2": "21608109", "code1": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "code2": "    public static boolean loadContentFromURL(String fromURL, String toFile) {\n        try {\n            URL url = new URL(\"http://bible-desktop.com/xml\" + fromURL);\n            File file = new File(toFile);\n            URLConnection ucon = url.openConnection();\n            InputStream is = ucon.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            ByteArrayBuffer baf = new ByteArrayBuffer(50);\n            int current = 0;\n            while ((current = bis.read()) != -1) {\n                baf.append((byte) current);\n            }\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(baf.toByteArray());\n            fos.close();\n        } catch (IOException e) {\n            Log.e(TAG, e);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"doUpload": ["runSave", " doSave", "doSave", " doupload", "DoUpload", "runUpload", "runDownload", "DoDownload", "Doupload", "doDownload", "DoSave", " doDownload", "runupload", "doupload"], "request": ["resource", "application", "subject", "use", "current", "view", "http", "state", "match", "url", "q", "image", "transfer", "parent", " Request", "version", "file", "join", "report", "user", "header", "command", "connection", "model", "quest", "page", "data", "require", "req", "message", "stream", "re", "art", "instance", "xml", "Request", "operation", "queue", "content", "er", "frame", "document", "hello", "upload", "query", "get", "complete", "worker", "type", "submit", "raw", "QUEST", "r", "client", "temp", "requ", "accept", "string", "initial", "context", "method", "condition", "input", "path", "param", "json", "object", "child", "event", "server", "config", "session", "head", "result", "ware", "info", "buffer", "create"], "response": ["Response", "resource", "application", "status", "reply", "xml", "view", "report", "onse", "json", "content", "resp", "connection", "document", "model", "server", " Response", "Resp", "image", "result", "page", "output", "message", "stream", "client", "re"], "reqSession": ["requConn", " reqCh", "refSession", "clientSocket", "reqSocket", " reqession", " reqSocket", "qSession", "requClient", " reqSecret", "qConn", "reqConn", "reqession", "tempCh", " reqLog", "reqCh", "clientsession", "clientCh", "qClient", "requsession", "reqsession", "tempSession", "refSecret", "refession", "rbClient", " reqsession", "refLog", "reqSecret", "rbSession", "reqClient", "qsession", "rbession", "rbsession", "clientSession", "reqLog", "tempSocket", "tempsession", "requSession", "rbSecret", "rbConn", "rbLog"], "uploadFiles": ["Uploadfiles", "uploadResources", "UploadFiles", " uploadfiles", "UploadResources", "transferFile", "uploadFile", " uploadFile", "transferfiles", "transferFiles", "transferResources", "UploadFile", " uploadResources", "uploadfiles"], "tempDirName": ["tempVerName", "cacheDIRPart", "tempDirKey", "tempFolderKey", "tempFoldername", " tempDirname", "tempFileKey", "tempAreaName", "cacheDIRname", " tempFileInfo", "tempDirInfo", "tempDirectoryInfo", " tempFolderCode", "tempAreaSize", " tempFilename", "tempDirectoryname", "cacheDirPart", "cacheDirName", "TempDirectoryKey", "tempFileName", "tempFolderName", "tempAreaname", "tempDIRPart", "tempDirectoryPath", "tempDirDesc", "tempFilename", "tempDirectoryName", "tempDirPart", "tempFolderCode", "tempDirCode", " tempDirCode", " tempDirInfo", "cacheDirname", "TempDirectoryName", "TempDirectoryCode", "tempFileCode", "tempDirectoryKey", "tempFolderDesc", "tempFilePath", "tempAreaInfo", "TempDirCode", "tempDirPath", " tempDirDesc", "TempDirName", "cacheDIRName", "tempVerCode", " tempFileName", "tempDirectoryDesc", "TempDirPath", "tempDirectoryPart", "tempVername", "tempDirSize", " tempFileSize", "tempDirectorySize", "tempDirHome", " tempFolderName", " tempFoldername", "tempFileInfo", "tempDIRName", "tempFileSize", "tempVerDesc", "TempDirectoryPath", " tempDirSize", " tempFolderDesc", "cacheDirHome", "tempDirectoryCode", "tempDIRHome", "tempDirname", "tempFolderPart", "TempDirKey", "tempDirectoryHome", "tempFolderHome", "tempDIRname", "cacheDIRHome", "tempFolderPath"], "tempUploadDir": ["tempUploadDb", " tempDownloadArea", "tempCapturedir", "tempUploadPath", "tempImageDir", "temuploadDir", "tempDownloadArea", "tempUploadJar", "tempInputPath", " tempDownloadDb", "tempuploadInfo", " tempDownloaddir", "testBuildD", "TempDownloadDb", "tempTempdir", "tempBuildJar", "testBuilddir", "temUploadInfo", "tempDownloadFolder", "tempRootDb", " tempDownloadFile", "tempDownloadJar", "tempUploaddir", "tempDownloadD", "testUploadFolder", "tempWorkDir", "tempRootDirectory", "testBuildJar", "temUploadDir", "tempUploadFolder", "testAttachUrl", "tempTempFolder", "tempDownJar", "tempDownloadDb", " tempUploadFile", "tempCaptureD", "tempBuilddir", "tempWorkFile", "tempInputFolder", "tempImageDirectory", "tempUploadInfo", "tempStreamArea", "TempUploadDb", "tempDownloadFile", "tempUploadArea", "testUploadJar", "tempStreamDirectory", "tempInputDir", "tempStreamDir", "tempRootFolder", "tempBuildDir", "tempuploadFolder", "tempFileDirectory", "tempImageFolder", "testAttachFolder", "testUploadDir", "tempInputInfo", " tempStreamJar", "tempAttachDir", "tempDownloaddir", "tempDownloadUrl", "TempDownloadDirectory", " tempStreamDir", "tempDownloadManager", "tempStreamDb", "tempAttachdir", "tempDownDir", "tempBuildD", "temUploadFolder", "tempDownloadInfo", "temuploadFolder", "TempDownloadDir", "tempDownDirectory", " tempUploadJar", "tempuploadPath", "tempImagedir", "tempAttachFolder", "tempAttachUrl", "testBuildDir", " tempUploaddir", "tempStreamFolder", "tempUploadUrl", "tempTempDirectory", "TempUploadDirectory", "tempCaptureDir", "tempFileFile", " tempUploadFolder", "tempCaptureJar", " tempDownloadDir", " tempUploadArea", " tempUploadDirectory", "TempUploadDir", "tempUploadManager", "tempRootDir", " tempUploadManager", "tempDownloadPath", "tempImageManager", "temuploadPath", " tempStreamDirectory", "testUploadD", "tempWorkDirectory", "tempWorkFolder", "tempDownloadDirectory", " tempStreamFolder", "testAttachdir", "temUploadPath", " tempDownloadDirectory", "testUploaddir", "tempTempDir", "temuploadInfo", "TempDownloadFolder", "tempFileFolder", "tempUploadD", "tempTempManager", "tempUploadDirectory", "TempUploadFolder", "tempDownFolder", "tempImageArea", " tempUploadDb", "testUploadUrl", "testAttachDir", " tempDownloadFolder", "tempFileDir", "tempUploadFile", "tempuploadDir", "tempTempDb", "tempStreamJar", " tempDownloadManager", "tempDownloadDir"], "attachmentDir": ["AttachmentFile", "AttachedDir", "AttmentDir", "attachedObj", "attachmentDirectory", "attentionDb", "attmentDir", "attachedFile", "AttachedObj", "assachedDb", "attributionDir", "attachedDet", "attachmentDet", "assachedDet", "assachmentDb", "AttachmentFolder", "attentionDirectory", "AttachedFile", "attachmentObj", "assachmentFile", "attachedDirectory", "attporaryDir", "attmentFolder", "AttmentDirectory", "attentionDir", "attentionFile", "AttachmentMin", "attentionFolder", "attributionDb", "AttachmentObj", "attentionObj", "AttmentMin", "AttachmentDirectory", "attachDb", "attributionFile", "attmentObj", "attachDir", "attmentDirectory", "AttmentFolder", "attmentFile", "attachmentDb", "attachDirectory", "AttachmentDir", "attachmentFile", "attachmentFolder", "attmentMin", "assachmentDet", "attachedDb", "attachedDir", "attentionMin", "AttachedDirectory", "attporaryDb", "attachmentMin", "assachmentDirectory", "assachmentDir", "assachedDirectory", "attributionDet", "attporaryFile", "attachFile", "attporaryDet", "assachedDir", "assachedFile"], "paramMap": [" parammap", " paramList", "ParamClear", "ParameterMap", "Parammap", "paramClear", " paramZone", " paramArray", "argMap", "paramCache", "ParamMap", "argArray", " paramBlock", "ParameterCache", " paramClear", "mediaArray", " parameterList", "parammap", "paramList", "argClear", "argBlock", "mediaList", "ParamList", "paramArray", " parameterMap", "paramBlock", "ParameterList", "ParamBlock", "mediaMap", "mediamap", "ParameterZone", "ParamArray", "paramZone", " parameterZone", " parameterCache", "argList", " paramCache"]}}
{"id1": "10385815", "id2": "21308543", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 1, "substitutes": {"copy": ["Cop", "paste", "cmp", "send", "zip", "Copy", "move", "open", "Transfer", "process", "sync", "download", " Copy", "replace", "upload", "exec", "clone", "delete", "get", "split", "transfer", "file", "change", "write", "put", "update", "create"], "fileFrom": [" fileStart", "FileSource", "FileStart", "fileStart", "mailIn", "ioSource", "FileTo", "FileIn", "ioStart", "mailTo", " fileSource", "mailFrom", " fileAs", "FileFrom", "ioFrom", "fileSource", "FileAs", "mailAs", "fileAs", "ioTo", " fileIn", "fileIn"], "fileTo": ["fpto", "resourceFile", "resourceTarget", "fileTO", " fileFile", "FileTo", " fileto", "resourceFrom", "resourceTo", "fpFrom", " fileTO", "fpTO", "fileto", "fileTarget", " fileTarget", "Fileto", "FileFrom", "fpTo", "FileTarget", "fileFile", "FileFile", "FileTO"], "inputStream": ["inputContext", "outputSteam", " inputSteam", "inputFile", "InputChannel", " inputFile", "outputFile", "inputSync", "outputContext", "inputstream", "InputContext", " inputstream", "InputSteam", "InputFile", " inputContext", "Inputstream", "outputSync", " inputSync", "InputSync", "InputStream", "outputstream", "inputSteam"], "outputStream": ["referenceStream", "outputSteam", "OutputStream", "fourStream", "fourChannel", " outputChan", "outputStreamer", "referenceSocket", "outputSocket", " outputSteam", "fourStreamer", "inputSocket", "writeSocket", "fourSteam", "writeChannel", "OutputChan", "referenceSteam", "OutputStreamer", "outputPath", "OutputSteam", "outputChan", "inputPath", " outputStreamer", " outputPath", "OutputPath", "writeSteam", "inputChan", "writeStream", "OutputChannel", "referenceChannel", "inputSteam"], "inputChannel": ["inputContext", "audioClient", "butContext", "parentPassword", "InputChannel", " inputClient", "outputSocket", "butCommand", "outputContext", " inputPassword", "inputSocket", "inputCam", "butChan", " inputCam", "InputContext", "parentStream", "outputPassword", "audioChannel", " inputSocket", " inputChan", "outputChan", " inputCommand", "inputClient", " inputContext", "outputCam", "inputCommand", "parentChannel", "InputSocket", "butChannel", "InputChan", "inputPassword", "inputChan", "outputCommand", "outputClient", "audioStream", "audioCam", "parentChan", "InputStream"], "outputChannel": ["inputContext", "outputchannel", "OutputStream", "outChannel", "OutputContext", " outputQueue", " outputChan", "outputContext", " outputContext", "OutputChan", " outputchannel", "outputChan", "OutputQueue", "outStream", "outChan", "outputQueue", "inputChan", "OutputChannel", "inputQueue", "inputchannel", "outContext", "Outputchannel"]}}
{"id1": "21995302", "id2": "397240", "code1": "        public void open(Input input) throws IOException, ResolverException {\n            if (!input.isUriDefinitive()) return;\n            URI uri;\n            try {\n                uri = new URI(input.getUri());\n            } catch (URISyntaxException e) {\n                throw new ResolverException(e);\n            }\n            if (!uri.isAbsolute()) throw new ResolverException(\"cannot open relative URI: \" + uri);\n            URL url = new URL(uri.toASCIIString());\n            input.setByteStream(url.openStream());\n        }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"open": ["resource", "ize", "use", " OPEN", "initial", "o", "xml", " close", "process", "add", "build", "oc", "it", " opener", "opening", "init", "fix", " Open", " transfer", "get", "load", " opened", " start", "set", "start", "un", "close", "to", "handle", "res", "change", "Open", "parse", "write", " reopen", "en", "update", "stream", "re", " opening", "create", "end"], "input": ["resource", "temp", "pull", "class", "accept", "stream", "container", "instance", "current", "context", "request", "http", "inner", "state", "io", "feed", "text", "this", "in", "client", "object", "command", "audio", "connection", "document", "base", "out", "element", "event", "upload", "exec", "config", "Input", "i", "ink", "image", "socket", "inf", "ssl", "output", "reader", "data", "type", "error", "argument", "PUT", "inc", "source", "buffer", "form", "keep", "file"], "uri": ["resource", "route", "si", "qi", "username", "string", "instance", "pi", "http", "str", "service", "state", "response", "uid", "abi", "ci", "path", "di", "manager", "api", "via", "io", "ui", "absolute", "database", "ri", "object", "address", "bridge", "verb", "URI", "document", "base", "ki", " URI", "element", "connection", "prefix", "eni", "definition", "cli", "doi", "li", "i", "iri", "image", "result", "gi", "next", "directory", "direction", "data", "mi", "picture", "id", "info", "source", "uni", "adi", "file", "origin"], "url": ["resource", "ob", "string", "channel", "http", "state", "URL", "path", "layer", "io", "api", "feed", "char", "Url", "impl", "address", "bel", "browser", "l", "connection", "base", "ls", "plug", "server", "coll", "config", "sl", "f", "link", "li", "i", "socket", "ssl", "data", "ball", "b", "id", "stream", "text", "buffer", "source", "file", "ref"]}}
{"id1": "8490710", "id2": "21438069", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    public ProjectDeploymentConfiguration createNewProjectDeploymentConfig(int projectID, String name, String description) throws AdaptationException {\n        ProjectDeploymentConfiguration config = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProjectDeploymentConfigurations\" + \"(projectID, name, description) VALUES (\" + projectID + \", '\" + name + \"', '\" + description + \"')\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProjectDeploymentConfigurations WHERE \" + \" projectID   = \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create \" + \"ProjectDeploymentConfiguration failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            config = getProjectDeploymentConfiguration(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProjectDeploymentConfig\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return config;\n    }\n", "label": 1, "substitutes": {"actualizar": [" actualizear", "actualizado", "actualizeado", "actualisiado", " actualizas", " actualizada", "actualizas", "actualizerada", "actualizear", "actualizerar", "actualisiada", " actualizeada", " actualizado", " actualizeado", "actualizada", " actualizeas", "actualizeas", "actualizeras", "actualizerado", "actualisias", "actualisiar", "actualizeada"], "ClassNotFoundException": ["ClassNameSupportedError", "ClassNotFindException", "ClassNotPresentException", "ClassNotFoundES", "ClassNotFindError", "ClassNameFoundError", "ClassNotSupportedError", "ClassNotPresentES", "ClassNotFoundError", "ClassNameFoundES", "ClassNotSupportedES", "ClassNameFoundException", "ClassNameSupportedException", "ClassNameSupportedES", "ClassNotSupportedException", "ClassNotFindES", "ClassNotPresentError"], "Exception": [" exception", "Null", "Failure", "F", "Application", "Adapter", "Connection", "Context", "Throw", "Request", "EX", "Problem", "Error", "Warning", "Exp", "Document", "Class", "Un", "Except", "Ex", "except", "ception", "IO", "Fail", "Interface", "ceptions", "X", "Information", "Engine", "E", "Transaction", "Event", "Exc", "Unknown", "Abstract", "Element", "W", "T", "Entity", "Default", "ERROR"], "conn": ["dc", "ch", "cat", "cm", "n", "c", "Connection", "ob", "pg", "ca", "col", "ens", "Conn", "ann", "state", "oss", "ci", "ctx", "con", "util", "Connect", "ct", "oci", "client", "sql", "loc", "p", "cc", "cr", "connection", "mc", "cn", "rc", "cp", "dh", "coll", "reg", "sn", "config", "cs", "enc", "cli", "session", "ok", "pub", "h", "cb", "nt", "ou", "comm", "mm", "en", "conf", "nc", "jc", "connect", "db"], "ms": ["mb", "mp", "ks", "js", "ml", "Ms", "pm", "bs", "ens", "ys", "m", "em", "mx", "mos", "ims", "pse", "is", "cus", "gs", "hm", "ems", "os", "details", "cms", "ins", "ums", "sql", "fs", "mc", "s", "mod", "ans", "oms", "vs", "ls", "mn", "qs", "ops", "cs", "ws", "ma", "mo", "keys", "sem", "ns", "ds", "gm", "MS", "res", "ts", "mis", "mas", "mi", "models", "md", "mm", "ps", "DS", "es", "tm", "mt", "rs", "me", "bm", "mes"], "fechaSystem": ["fichaSystem", "febaSys", "febasSys", "fechasSystem", "fechassystem", "fechlaSys", "fekaSTEM", "fechlaSystem", "fechmaServer", "fechoSTEM", "fechetaSys", "febasServer", "fekasSystem", "fechasServer", "fichlaSystem", "fekaSys", "fechtaSys", "fechtasystem", "fekasSTEM", "fechmaSys", "fetchaSTEM", "fetchaSystem", "fetchmaSTEM", "fechaServer", "fekasSys", "fechaSTEM", "fekaSystem", "fetchmasystem", "fechaService", "fichlaSys", "fetchasystem", "fechmaSTEM", "fechaSys", "fechetaServer", "fechasystem", "fechlasystem", "fechasSTEM", "febaSystem", "febaServer", "febaService", "fechmaSystem", "fechlaSTEM", "fichlasystem", "fechasService", "fechmasystem", "fechosystem", "fechmaService", "fechtaSystem", "fechetaSystem", "febasService", "febasSystem", "fichasystem", "fichaSys", "fechasSys", "fechoSystem", "fetchmaSystem", "fechetaService"], "aaaammdd": ["aaaammtz", "aaammds", "aaaammsd", "aaaymmd", "aaammd", "aaaasmds", "aaaymmsd", "aaaammd", "aaaasmdd", "aaaymmdd", "aaaaammsd", "aaaaamdd", "aaaasmtz", "aaaamsd", "aaaaamsd", "aaaasmd", "aaaaammdd", "aaaamd", "aaaymmds", "aaammdd", "aaaaammd", "aaaammds", "aaaaamds", "aaammsd", "aaaamtz", "aaaaamd", "aaaamdd", "aaaaammds", "aaaaamtz", "aaammtz", "aaaamds", "aaaaammtz"], "fzafsis": ["fzAFs", "fzaphsi", "fzafsi", "fzahtics", "fzaftics", "fzhafsi", "fzahsi", "fzhaftics", "fzhahs", "fzhafsis", "fzAFsi", "fzAFtics", "fzahs", "fzhahsi", "fzhahsis", "fzhafs", "fzAFsis", "fzaphtics", "fzaphs", "fzaphsis", "fzhahtics", "fzafs"], "hhmmss": ["HHMMs", "HHmms", "hhmmds", "hhmdess", "HHMMss", "hhmls", "hhhmms", "hhmmess", "hhmdss", "HHmmss", "hhmmms", "hhMMess", "hhmms", "hhhmmmss", "hhmmmess", "HHMMds", "hhhmmmds", "hhmdds", "hhMMss", "hhmds", "hhMMs", "hhhmmds", "hhmmmss", "HHMMms", "hhmlss", "HHmmds", "hhhmmms", "hhhmmmess", "hhmmmds", "hhhmmss", "hhmlds", "hhms", "hhhmmess", "HHmmms", "hhMMds", "hhmss", "hhMMms", "hhmlms"], "sss": ["ussss", "hesss", "usss", "ssp", "rssp", "hessns", "ssns", " ssp", "rssss", "hessls", "\u00dfs", "rssses", " ssss", "ssss", "rssns", "ssses", "ssls", " ssses", "rsss", "\u00dfns", "ussses", "hessss", "\u00dfss", "rssls", "ussp", "\u00dfls"], "ss": ["ess", "rss", "struct", "pass", "js", "si", "pps", "ses", "bs", "css", "string", "pg", "sf", "eps", "str", "oss", "hh", "nn", "styles", "tz", "ass", "sq", "fs", "less", "ng", "s", "\u00df", "WS", "ls", "vs", "iss", "settings", "ws", "sl", "hess", "cs", "SS", "su", "ns", "ds", "ssl", "uss", "ts", "st", "ross", "sv", "xx", "ps", "account", "rs", "ssh"], "fzahsis": ["fzeaftics", "fzafses", "fzeajsi", "fzajsis", "fzafsi", "fzahtics", "fzaftics", "fzajtics", "fzeafsis", "fzahsi", "fzeajtics", "fzajsi", "fzavtics", "fzavsis", "fzeajses", "fzeajsis", "fzavsi", "fzajses", "fzeafsi", "fzavses", "fzeafses", "fzahses"], "afectados": ["afectionadas", "afctado", "afecantes", "rafctatos", "afecadas", "afectantes", "afectionado", "afectionanos", "afctatos", "rafectado", "rafectatos", "AFecantes", "afectanos", "afectadas", "afemptatos", "afctadas", "afemptadas", "afescantes", "afescanos", "afectado", "rafectadas", "afecanos", "AFecados", "afescados", "afecados", "rafctadas", "rafctados", "afemptados", "rafectados", "afectionantes", "afescadas", "AFecadas", "afectionatos", "rafctado", "afemptado", "afectionados", "AFectados", "afctados", "AFecanos", "AFectanos", "AFectadas", "afectatos", "AFectantes"]}}
{"id1": "9805906", "id2": "18114701", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"dump": ["df", "println", "zip", "copy", "export", "files", "download", "dir", "store", "all", "out", " dumping", "load", "f", " dumped", "Dir", "transfer", "save", "diff", "data", " dumps", "ump", "flush", "info", "update", "ln", "db"], "source": ["resource", "scene", "slave", "use", "string", "current", "Source", "view", "http", "service", "core", "input", "ource", "series", "from", "slice", "this", "address", "unit", "connection", "base", "s", "server", "iter", "SOURCE", "start", "sin", "remote", "se", "ources", "parent", "stream", "uri", "src", "site", "file"], "target": ["resource", "large", "root", "project", "effect", "host", "table", "pointer", "path", "platform", "enemy", "force", "dest", "arget", "database", "object", "address", "alias", "it", "goal", "connection", "base", "replace", "out", "port", "settings", "office", "top", "Target", "to", "result", "next", "output", "follow", "null", "parent", "master", "src", "file", "template"], "is": ["ics", "or", "us", "isa", "ses", "ios", "ip", "im", "ens", "ois", "bs", "isl", "opens", "was", "iris", "oss", "has", "as", "gets", "abs", "ais", "io", "IS", "ui", "in", "ins", "bos", "obs", "s", "Is", "ls", "iso", "iss", "ops", "its", "ws", "cs", "isi", "i", "ori", "oses", "mis", "bis", "lis", "ai", "nis", "ps", "es", "info", "ists", "ris"], "os": ["or", "ks", "us", "ios", "bs", "osi", "ens", "ies", "o", "dos", "oa", "oss", "as", "io", "ais", "outs", "aos", "boot", "bos", "oes", "acs", "oos", "fs", "ose", "obs", "s", "pos", "nos", "vs", "los", "ops", "cos", "its", "cs", "Os", "i", "ori", "ues", "ds", "ros", "oses", "ips", "ols", "ss", "ps", "es", "OS", "ows"], "done": ["ready", "did", "started", "dirty", "gone", "defined", "got", "current", "after", "empty", "none", "die", "progress", " Done", " finished", "enabled", "part", "running", "disabled", "nice", "future", "expected", "complete", "confirmed", "foo", "due", "Done", "finished", "made", "dad", "odo", "next", "checked", "data", "last", "doing", "yes", "de", "always", "one", "later", "loaded", "once"]}}
{"id1": "12197169", "id2": "15799935", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "label": 0, "substitutes": {"read": ["ready", "run", "println", "readable", "reading", "request", "continue", "report", "open", "process", "download", "print", "Read", "init", "replace", "get", "load", "work", "check", "start", "reader", "parse", "write", "loop", "stream", "create", "end"], "in": ["In", "fr", "token", "again", "at", "of", "ini", "c", "n", "IN", "scan", "o", "ex", "is", "din", "inner", "bin", "input", "path", "log", "con", "io", "from", "cms", "ins", "doc", "on", "min", "conn", "inn", "er", "ing", "err", "it", "l", "isin", "connection", "s", "out", "server", "url", "index", "f", "e", "by", "nin", "a", "image", "login", "ssl", "reader", "error", "data", "r", "b", "inc", "id", "info", "buffer", "stream", "source", "file"], "line": ["inline", "entry", "row", "status", "string", "lines", "col", "LINE", "ine", "str", "comment", "le", "Line", "ge", "log", "key", "object", "unit", "frame", "l", "L", "lin", "cell", "url", "sl", "f", "link", "e", "code", "value", "el", "record", "val", "page", "ne", "reader", "se", "data", "parse", "b", "id", "message", "lf", "source", "buffer", "text", "block", "name", "file", "lc", "end"], "i": ["si", "qi", "u", "ip", "n", "ii", "ini", "pi", "o", "is", "abi", "ci", "di", "io", "slice", "ui", "ri", "bi", "ie", "p", "l", "phi", "j", "I", "eni", "x", "fi", "ski", "index", "f", "e", "oi", "li", "ori", "ni", "gi", "ti", "ai", "b", "zi", "xi", "info", "ix", "uni"], "logDatum": ["logDatatum", "exDDam", "logDatata", "logDum", "logDData", "exDDatum", "logDDam", "logdata", "logDsict", "LogData", "logDam", "logDatam", "logDictionary", "LogDatum", "logdict", "logDsatum", "logDatict", "logFam", "logDsum", "logdum", "Logdum", "exDam", "LogDum", "logDatictionary", "LogDict", "exData", "logFatum", "logDict", "logFata", "Logdatum", "exDDictionary", "logData", "logdatum", "logDDatum", "logDDictionary", "logFictionary", "Logdict", "exDictionary", "exDatum", "logDsata", "exDData", "Logdata"]}}
{"id1": "6403868", "id2": "17773263", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 0, "substitutes": {"extractUninstallFiles": ["extractUnpackFile", "extractUninstallSources", "extractUninstallFile", "extractUnzipSources", "extractUnzipfiles", "extractUnInstallSources", "extractUppackFiles", "extractUpinstallFile", "extractUnInstallFiles", "extractUpinstallSources", "extractUnpackSources", "extractUnzipFiles", "extractUnInstallFile", "extractUnpackFiles", "extractUnzipFile", "extractUpinstallfiles", "extractUnInstallfiles", "extractUppackFile", "extractUpinstallFiles", "extractUppackfiles", "extractUninstallfiles", "extractUppackSources", "extractUnpackfiles"], "_destPath": ["_destFile", "_srcFile", "_DestPath", "_distFile", "_destDirectory", "_destHome", "_destpath", "_DestDir", "_sourcePath", "_downloadDirectory", "_DestFile", "_distDir", "_Destpath", "_sourceFile", " _sourceDirectory", "_sourceHome", " _sourcePath", "_srcDirectory", " _sourceFile", "_tmpPath", "_downloadHome", "_tmpDirectory", "_downloadFile", "_downloadPath", "_sourcepath", " _sourceHome", "_distDirectory", " _destDirectory", " _destHome", "_srcPath", "_tmppath", "_DestHome", "_distPath", "_destDir", "_DestDirectory", " _destFile", "_srcDir", "_sourceDir", "_sourceDirectory", "_tmpDir"], "upgrade": ["Upge", "upgrades", "UpGrade", "upGrade", "ipinstall", "offgrades", "upgrading", " upge", "Upgrading", "offgrading", "dugrade", "duGrade", "dugrading", " upGrade", "Upgrade", "offgrade", "ipgrades", " upgrading", "upinstall", "offinstall", " upgrades", " upinstall", "duge", "ipgrading", "upge", "ipgrade"], "lastVer": ["prevver", "lastVER", "LastVersion", " lastVers", " lastver", "firstver", "nextVers", "lastVers", "firstVER", "prevVersion", " lastVER", "LastVer", "nextver", " lastVersion", "prevVer", "prevVers", "firstVer", "lastVersion", "nextVer", "lastver", "firstVersion", "nextVersion", "LastVER", "Lastver"], "oldlog": ["newpath", " oldbug", "OLDlog", "oldpath", "OldLog", " oldLog", "oldLog", "newbug", "newtext", "oldertext", "Oldlog", "olderLOG", "Oldpath", "oldtext", "newLog", "oldLOG", " oldtext", "newlog", "olderLog", "newLOG", "oldbug", "OLDLog", " oldpath", " oldLOG", "OldLOG", "OLDbug", "olderlog"], "destPath": ["secureDir", "doneWin", "homeLog", "contDir", "destKit", "usrPath", "DestHome", "usrpath", "DestPath", " destHome", "exportPath", "postpath", " destCh", "Destath", "destHome", "sourceDirectory", "flatDir", "constHome", "secureWin", "securePath", "descFile", "flatFolder", " destDirectory", "donePath", "DestCh", " destWin", "srcpath", "postPath", "destLog", " destKit", "destCh", "destFolder", "exportpath", "targetpath", "DestDir", "srcPath", " destath", "descName", "contpath", "constPath", "doneDir", "exportDirectory", "flatpath", " destRoot", "destath", "destName", "destRoot", " destLog", "destPATH", "homeKit", "usrFile", "constFile", "DestFile", "destpath", "descpath", "targetRoot", "homepath", "descCh", "Destpath", "flatPath", "sourceDir", "constpath", "DestRoot", "targetDir", "descDir", "targetFile", "contath", "descKit", "destDir", "srcPATH", "destFile", "DestDirectory", "targetPath", " destName", "secureLog", "donepath", "destWin", " destpath", "postPATH", "contPath", "postRoot", "sourcepath", "srcDirectory", " destPATH", "destDirectory", "DestPATH", "homeDir", "sourcePath", " destFolder", "exportPATH", "targetPATH", "homePath", "homeName", "descPath", " destFile", " destDir", "DestFolder", "doneLog"], "lastVerPath": ["nextverPath", "prevverFile", " lastVerEx", "lastTestId", " lastModDir", "lastVerspath", "lastVerpath", " lastModCh", "lastVERpath", "lastVERCh", "lastTestPath", "lastVerName", "lastVersionCh", "lastModCh", "lastModpath", "lastVerFile", "lastVerId", "prevverPath", "lastVersionPath", "lastVersFile", "lastTestFile", "lastVerEx", "nextVerpath", "lastVersCh", " lastVerId", "lastVersionEx", "prevVerpath", " lastVerFile", " lastVerDir", " lastVersionFile", "lastVersionName", "lastverEx", "prevVerPath", "lastModPath", "lastVersionFile", "lastModDir", "lastverId", " lastVersionEx", "prevVerFile", "lastverFile", "nextverFile", "prevVerName", "lastVERPath", "nextverCh", "nextVerFile", "lastModName", "lastverCh", "nextVerCh", " lastVersionPath", " lastVersionId", "lastTestpath", " lastVersionCh", " lastVerCh", "lastVEREx", "lastVERDir", "prevverpath", " lastVersionpath", " lastModpath", "lastverpath", "lastverName", "lastVersPath", "lastverPath", "nextVerPath", "nextverpath", "lastModFile", "lastVersionId", " lastVerpath", "lastverDir", "lastVersionpath", " lastModPath", "lastVerCh", "lastVerDir", "prevverName"], "bkdir": ["bvloc", "Bkdir", "bkkdir", "bKDir", "bkkir", "bkkDir", " bakdir", " bakDir", "bkdesc", "bakpath", "bckdir", " bktfile", "bkkpath", " bkir", "bktloc", " bkdesc", "bkir", "bktdir", "bkdirectory", " bktloc", "bvpath", "bakir", " bktdesc", "Bckdirectory", "bakloc", " bktdir", "bkkloc", "bKpath", " bkDir", "bvdir", " bkpath", "bkkdesc", "BckDir", "bkbfile", "BkDir", "bakdirectory", "bkgdir", "bkDir", "bkbdesc", " bakloc", "bkgDir", "bckDir", " bkfile", " bakpath", "bktfile", "bkpath", "bakdir", "bKdirectory", "bkgir", "bkbloc", " bkloc", "Bkpath", "bKdir", "bckdirectory", "bkkfile", "bkloc", " bakir", "bakDir", "bkfile", "bckpath", "Bckpath", "bvDir", "bkbdir", "bktdesc", "Bckdir", "Bkdirectory"], "oldClassCopied": ["oldFilecopying", "oldClassSkored", "oldFileCopies", "oldClasscopies", "oldClassCrossied", "oldFileCopiated", "oldClassSkies", "oldClassCopie", "oldclassCopie", "oldClasscopying", "oldClassCrossiated", "oldFilecopie", "oldFileCopied", "oldClassSkie", "oldclassCopored", "oldClassCopies", "oldClassCopified", "oldFilecopied", "oldClasscopored", "oldClassCopyie", "oldClassCopyied", "oldClassCopying", "oldclassCopies", "oldClassCopored", "oldClassCrossified", "oldFileCopyified", "oldClassCrossying", "oldFilecopies", "oldClassCopyying", "oldFileCopified", "oldClassSkied", "oldClassCopyified", "oldFileCopie", "oldClassCopiated", "oldClasscopie", "oldFileCopying", "oldclassCopied", "oldFileCopyying", "oldFileCopyied", "oldClasscopied", "oldFileCopyiated", "oldClassCopyiated", "oldClassCopyies"], "ls": ["lt", "fts", "bps", "bs", "lines", "LS", "dl", "lbs", "ll", "ails", "iffs", "list", "la", "files", "rl", "locks", "lr", "fs", "lb", "l", "less", "qs", "vs", "los", "als", "ches", "cs", "lp", "lv", "ns", "tl", "ols", "lis", "mails", "fl", "ils", "acl", "igs", "lf", "wl", "lists", "les", "sels", "ln", "irs", "lc"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "ini", "ii", "c", "m", "pi", "o", "y", "d", "inner", "abi", "ci", "ij", "di", "io", "z", "slice", "ji", "ui", "ri", "min", "p", "it", "l", "part", "phi", "s", "j", "I", "fi", "x", "eni", "uli", "index", "f", "e", "oi", "li", "q", "ind", "start", "v", "gi", "ti", "type", "ai", "mi", "yi", "b", "xi", "t", "id", "info", "uri", "ix", "mu", "lc", "end"]}}
{"id1": "16760971", "id2": "10214218", "code1": "    public static String generateHash(String key) {\n        key += \"use_your_key_here\";\n        MessageDigest md;\n        try {\n            md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            StringBuffer buff = new StringBuffer();\n            for (int l = 0; l < bytes.length; l++) {\n                String hx = Integer.toHexString(0xFF & bytes[l]);\n                if (hx.length() == 1) buff.append(\"0\");\n                buff.append(hx);\n            }\n            return buff.toString().trim();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"generateHash": ["generatesMac", "generatedSalt", "generoseKey", "generatesKey", "generateKey", "generateSalt", "generoseSalt", "generatesSalt", " GeneratedHash", "generateMac", " GenerateKey", "generoseMac", " GenerateSalt", " GeneratedMac", "generatedKey", "generatesHash", " GenerateHash", "generoseHash", " GenerateMac", " GeneratedSalt", " GeneratedKey", "generatedMac", "generatedHash"], "key": ["body", "token", "Key", "seed", "fee", "full", "k", "string", "mac", "word", "secret", "str", "self", "msg", "path", "proof", "KEY", "hex", "char", "pair", "trust", "ce", "user", "address", "rule", "connection", "base", "pe", "prefix", "url", "work", "keys", "block", "date", "code", "cert", "password", "hash", "data", "type", "point", "id", "message", "cy", "sign", "crypt", "text", "ace", "name", "file"], "md": ["dc", "df", "mb", "mg", "mp", "mail", "pd", "ms", "mage", "pm", "od", "mand", "cm", "mac", "Cmd", "m", "rm", "clean", "mem", "sm", " MD", "d", "hm", "di", "MD", "bd", "wd", "hd", "ad", "dd", "ld", "mc", "cd", "mod", "cmd", "dh", "dr", "ma", "mag", "nd", "am", "ds", "dm", "hash", "editor", " Md", "nm", "amd", "dig", "rpm", "mm", "metadata", "po", "message", "mad", "mt", "me", "bm", "mo"], "bytes": ["pages", "Bytes", "words", "codes", "bps", "zip", "bs", "lines", "ones", "values", "errors", "bits", "objects", "bles", "outs", "letters", "os", "files", "boot", "seconds", "pieces", "gb", "cells", "s", "pins", "strings", "ls", "vs", " bits", "ops", "keys", "blocks", "ips", "vals", "bis", "parts", "data", "items", "b", "fb", "es", "binary", "les", "rows"], "buff": ["mb", "txt", "nb", "ob", "append", "py", "pb", "cpp", "cast", "fx", "uff", "ctx", "bd", "buf", "agg", "obb", "pp", "bug", "eb", "batch", "abb", "ph", "ff", "app", "gb", "amp", "fw", "tf", "bag", "cp", "tmp", "sb", "Buffer", "f", "flat", "uf", "kb", "bo", "cb", "html", "bis", "bb", "diff", "Buff", "b", "fb", "bf", "tt", "hack", "buffer", "bm"], "l": ["il", "ol", "u", "n", "c", "col", "o", "d", "dl", "pl", "le", "ll", "z", "la", "ly", "ell", "rl", "length", "p", "bl", "cl", "lb", "L", "ls", "j", "x", "sl", "f", "e", "lp", "lv", "i", "li", "nl", "el", "ul", "h", "v", "al", "fl", "b", "t", "kl", " L", "ln", "lu", "jl", "lc"], "hx": ["Hy", "Hxa", "hsx", "hmy", "hswx", "hc", "hy", "Hc", "dhc", "Hxc", " hxc", "hwx", "Hrx", "hmxa", "hxa", " hex", "hex", "dhex", "hmxs", " hrx", " hxs", "hmx", "hsrx", "dhx", "hxc", "hrx", " hwx", "hsxc", "Hwx", "Hxs", " hc", " hy", "Hex", "hxs", "Hx", "dhxc", " hxa"]}}
{"id1": "14783950", "id2": "647224", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compresswithJar", "compressedUsingSax", "compresswithZip", "compressUsingZip", "compressWithJar", "compressInJar", "compresswithSax", "compressInSax", "compressedWithJar", "compressUsingJar", "compressedUsingJar", "compressedWithSax", "compressUsingSax", "compressWithSax", "compressInZip", "compressedWithZip", "compressedUsingZip"], "fileList": ["inputEx", "Filelist", " fileStream", "fileCollection", "ziplist", "FileChain", "inputStream", " fileEx", "fileStream", "stringChain", "modelList", "modelEx", "FileSet", "FileStream", "fileString", "wordString", "stringList", "FileList", "zipList", "filelist", "inputCollection", "stringlist", "fileEx", " fileCollection", "modelCollection", " fileSet", "FileString", "FileName", "zipSet", "fileSet", "wordStream", "fileChain", "inputList", "wordList", "stringName", " filelist", "modelStream", "zipName", " fileString", "wordName", " fileChain"], "zipFileName": ["zipDirNames", "zipGlobalname", "folderFilePath", "zipFilename", "archiveFileName", "zipDirname", "zipFullname", "zipFullName", "zipGlobalPath", "folderGlobalname", "folderGlobalName", "archiveDirPath", "archiveDirDir", "zipFullPath", "zipFullDir", "zipFilePath", "folderFilename", "folderGlobalPath", "archiveFilePath", "folderGlobalNames", "zipGlobalName", "zipDirDir", "zipPackageDir", "zipDirName", "zipGlobalNames", "zipFileNames", "folderFileNames", "zipPackagePath", "zipFullNames", "archiveDirName", "zipFileDir", "archiveFileDir", "zipPackageName", "folderFileName", "zipDirPath"], "fos": ["afaos", "flosh", "flos", "afis", "fosh", "infos", "infoS", "faos", "infis", "foS", "FoS", "flis", "Fis", "infaos", "afoS", "Fos", " fosh", "Fosh", "Faos", "afos"], "zos": ["nz", "budget", "zes", "zers", "ozo", "ses", "zen", "zip", "osi", "css", "rez", "dos", "fits", "inos", "abi", "z", "os", "outs", "obb", "bos", "packs", "zag", "seconds", "iframe", "tz", "bag", "zan", "ZA", "phi", "chini", "bes", "lol", "zx", "uz", "jas", "cos", "zar", "webkit", "zy", "fi", "ZI", "zo", "gz", "zb", "oses", "ros", "LOS", "onz", "closure", "bis", "zer", "kos", "spin", "zi", "zon", "lins", "zz", "es", "zl", "loop", "jobs", "zik", "zzy"], "iter": ["fr", "liter", "ip", "ter", "ir", "inter", "upper", "http", "ator", "is", "iz", "inner", "former", "walker", "outer", "ner", "list", "slice", "enter", "Iterator", "er", "izer", "loc", "iterator", "it", "ie", "fer", "err", "inse", "cher", "order", "ener", "chain", "coll", "index", "f", "ite", "e", "itter", "i", "set", "el", "iner", "next", "finder", "test", "parse", "ser", "Iter", "gener", "inc", "oper", "keep", "file", "sort", "end"], "fileName": ["simpleOpen", "fullName", "filePart", "fName", "pageString", "simpleName", "FileFull", " fileLine", "fileType", "filenamename", " fileFull", "Filename", "filenameInfo", "FileUrl", "localPath", "pagename", "fileString", "fileLine", "FilePart", "FileInfo", " fileUrl", "FileType", "fileInfo", "filenameName", "filenameFull", "localName", " fileInfo", " fileType", " fileOpen", "fullPath", "filePath", "currentName", "FileLine", "FileString", "FileName", "fPart", "FileData", "fLine", "currentData", "fileFull", "currentUrl", "filename", " fileData", "pageName", "fileOpen", "fileUrl", "simplePath", " filename", "fileData", " filePart", "localPart", "pageType", "localname", "FilePath", " filePath", " fileString", "currentname", "fname", "fullOpen"], "ind": ["pull", "fr", "mind", "Ind", "ii", "d", "pend", "ci", "z", "pt", "in", "wind", "length", "div", "inn", "dir", "count", "loc", "ad", "ld", "pos", "rib", "j", "cond", "x", "index", "IND", "nd", "ord", "len", "i", "eff", "start", "bind", "val", "ded", "vert", "inc", "id", "ix", "mid", "end"], "shortName": ["fullName", "longname", "smallPath", "shortname", "fullname", "ShortPath", "shortPath", " shortPath", "shortString", "smallname", "shortLine", "fullLine", " shortname", "longLine", "ShortString", " shortString", "fullString", "ShortPart", "longPath", "fullPath", "shortPart", "Shortname", "ShortName", " shortLine", "smallName", "longPart", "smallPart", "longName"], "fis": ["cfiss", "gris", "Fiss", "cfs", " fs", "afis", "fios", "pis", "gis", " fiss", "fris", "Fs", " fios", "fs", "pris", "afiss", " fris", "fisa", "Fis", "pios", "cfis", "Fos", "gios", "gisa", "afos", "cfris", "afris", "fiss", "pisa", "cfos", " fisa"], "buf": ["done", "bh", "bu", "grab", "vec", "pb", "cv", "bin", "fd", "bd", "box", "queue", "la", "seq", "bp", "loc", "batch", "br", "bl", "bag", "ff", "lb", "rc", "tmp", "cur", "bc", "uf", "lim", "uc", "bytes", "cb", "v", "bb", "data", "feat", "Buff", "b", "fb", "buff", "ba", "bf", "buffer", "wb", "rb"], "bytesRead": ["bitsRead", " bytesLength", "bitsLength", "flowsNeed", "flowsRead", "bytesLength", "bytesWrite", "secondsLength", "secondsNeed", "tesLoad", "wordsLength", "tesSkip", "bytesLoad", "tesWrite", " bytesSkip", "tesRead", "bitsUse", "secondsWrite", "bitsSkip", "bitsWrite", "bitsLoad", " bytesUse", "flowsLength", " bytesNeed", "bytesUse", "wordsWrite", " bytesLoad", "flowsWrite", "bytesNeed", "secondsRead", "bytesSkip", "wordsRead", " bytesWrite", "wordsUse"]}}
{"id1": "10445819", "id2": "15351863", "code1": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"getReader": ["getreader", "loadStream", "readreader", "getParser", "newParser", "readStream", "loadParser", "loadreader", "loadReader", "newStream", "newReader", "newreader", "getStream", "readReader", "readParser"], "stream": ["resource", "temp", "draw", "window", "clean", "zip", "channel", "instance", "host", "http", "input", "cont", "feed", "open", "slice", "sync", "impl", "content", "object", "child", "roll", "valid", "trans", "document", "sw", "Stream", "upload", "coll", "url", "port", "read", "sl", "f", "serial", "control", "pool", "wrapper", "draft", "v", "reader", "output", "data", "raw", "null", "source", "body", "form", "ream", "file"]}}
{"id1": "310182", "id2": "18433984", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "subverting", "unverted", "Conversion", "converted", "CONverted", "unception", "CONverting", "conversion", " deconverting", "Convert", " deconvert", "conception", " deconverted", "subversion", "oconverted", "Conception", "subverted", "CONception", "oconvert", "oconversion", "subvert", "unvert", "CONversion", "CONvert", "converting", " deconversion", "unversion", "Converted", "oconverting"], "src": ["resource", "scene", "stage", "sth", "username", "cmp", "SourceFile", "string", "href", "Source", "spec", "cpp", "dist", "input", "ource", "path", "inst", "ctx", "sc", "buf", "slice", "sys", "attr", "rl", "download", "impl", "fn", "loc", "proc", "video", "gb", "s", "rc", "storage", "upload", "tmp", "url", "component", "load", "sn", "config", "sb", "code", "gz", "filename", "sin", "Dest", "fp", "cb", "ssl", "img", "reader", "st", "RC", "supp", "secure", "obj", "req", "feat", "rb", "prot", "back", "source", "stream", "uri", "sel", "name", "sit", "file", "ref"], "dest": ["dc", "txt", "temp", "class", " dst", "dat", "dist", "bin", "path", "di", "disk", "dir", "fn", "orig", "tmp", "home", "lib", "Dest", "std", "img", "test", "obj", "target", "null", " destination", "source", "cont"], "in": ["In", "inas", "pass", "ini", "n", "IN", "ex", "is", "d", "din", "bin", "input", "as", "io", "pin", "ins", "doc", "inn", "err", "up", "isin", "win", "f", "i", "a", "inf", "val", "login", "reader", "data", "r", "ps", "t", "inc", "source", "stream", "file"], "p": ["pc", "cop", "pd", "pm", "g", "c", "pr", "pi", "op", "py", "pb", "pg", "o", "m", "d", "np", "pp", "bp", "tp", "wp", "l", "part", "s", "pe", "cp", "pa", "j", "sp", "per", "f", "e", "lp", "i", "pre", "h", "fp", "v", "P", "jp", "r", "po", "ps", "t", "parser", "b"], "ds": ["dc", "hs", "words", "dl", "gs", "da", "obs", "s", "icks", "ges", "dm", "ts", "sts", "db", "df", "js", "pd", "bs", "ys", "dat", "lines", "dos", "d", "utils", "ads", "styles", " props", " sd", "amps", "ld", "ans", "Ds", "lp", "ns", "data", "posts", "parts", "docs", "ps", "DS", "ss", "dp", "scripts", "uds", "di", "os", "sync", "sys", "ins", "xs", "tests", "dds", "ls", "dt", "cs", "des", "nas", " DS", "ups", "ks", "eps", "dist", "cons", "ays", "tools", "ants", "groups", "plugins", "dd", "qs", "vs", "services", "dates", "ths", "els", "gd", "ded", "vals", "points", "ils", " ps", "ipes", "rs", "models"], "format": ["struct", "class", "function", "at", "act", "string", "host", "table", "spec", "version", "language", "atter", "path", "fd", "api", "magic", "letter", "unit", "handler", "fn", "frame", "nat", "scale", "tag", "part", "layout", "Format", "model", "prefix", "ant", "url", "config", "f", "sche", "filename", "record", "fp", "filter", "data", "type", "feat", "style", "plugin", "t", "parser", "pattern", "source", "form", "name", "file", "template"], "hasPixelData": ["showsPixeldata", "haspixeldata", "showsPixelDATA", "hasByteDATA", "hasPixeldata", "hasPixelDATA", "showsPixelStyle", " hasPixelSize", " hasPixeldata", "showsBytedata", "showsByteStyle", "haspixelSize", "showsPixelData", "hasByteData", "hasByteStyle", "hasBytedata", "haspixelData", "hasPixelStyle", "showsByteData", "hasPicturedata", "hasByteSize", "hasPictureSize", "hasPixelSize", "hasPictureData", "showsByteDATA"], "inflate": ["inFlated", "inadequating", "infloace", "insflode", "InFlate", "infolATE", "inadequode", "insvenATE", "inFlate", "insflating", "InFlace", "insflATE", "inffated", "inflation", "invenate", "inflace", "infolode", "inFlation", "infloate", "insvenate", "invenATE", "infloated", "inffation", "invenating", "InFlated", "insvenating", "insflate", "inflATE", "inflating", "Inflace", "infface", "inFlace", "infolate", "Inflated", "inffate", "Inflate", "inadequate", "insvenode", "inflated", "infolating", "infloation", "inflode", "invenode", "Inflation", "InFlation", "inadequATE"], "pxlen": ["fxdata", "pnglen", "pxlin", "mxln", "axlon", "pxcount", "fxln", "pglen", "txln", "pcln", "ppl", "pxlon", "txlin", "camlen", "fxl", "pgden", "pngsize", "axlin", "mxlen", "camln", "fxden", "xplength", "ppLen", "mxdata", "pxLen", "pxdata", "pclen", "pclin", "axln", "pxln", "axlen", "txlen", "pngcount", "campos", "mxpos", "fxLen", "xpsize", "xpcount", "pxsize", "pgl", "pxpos", "ppden", "pgLen", "fxpos", "pxlength", "fxlen", "mxlength", "mxcount", "xplen", "mxsize", "camdata", "pxden", "pclon", "pplen", "pxl", "pnglength", "txlon"], "out": ["group", "line", "again", "cache", "step", "inter", "state", "Out", "copy", "log", "io", "outs", "list", "co", "post", "sys", "pad", "user", "conn", "store", "err", "up", "server", "query", "work", "cli", "session", "dump", "lib", "v", "page", "output", "gen", "error", "obj", "OUT", "point", "parent", "lock", "re"]}}
{"id1": "1180878", "id2": "22135199", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchUrldata", "fetchUrlDATA", "fetchHTTPDATA", "fetchHTTPdata", "fetchUrlData", "frieveURLdata", "frieveUrlData", "frieveUrlDATA", "fetchURLdata", "fetchJSONData", "fetchURLDATA", "fetchJSONDATA", "fetchHTTPData", "fetchJSONdata", "frieveURLData", "frieveUrldata", "frieveURLDATA"], "url": ["resource", "username", "string", "host", "href", "view", "http", "xml", "www", "URL", "path", "ur", "api", "feed", "gl", "Url", "download", "user", "address", "loc", "l", "connection", "base", "ls", "server", "location", "sl", "f", "filename", "image", "el", "page", "html", "ssl", "data", "fl", "uri", "source", "text", "src", "name", "file"], "proxyHost": ["ProxyDomain", "Proxyhost", "ProxyServer", " proxyAddress", "cachehost", "proxyHead", "ProxyAddress", "baseHead", "baseHost", " proxyPath", "serverHost", "proxyAddress", "proxyDomain", "ProxyPort", "serverServer", "serverPath", "proxyServer", "baseDomain", "remoteHead", "serverAddress", "cacheHost", "ProxyHead", "ProxyHost", "remoteHost", "baseAddress", " proxyhost", "cachePort", "remoteDomain", "remoteAddress", "cacheAddress", " proxyServer", "proxyPath", "ProxyPath", "proxyhost"], "proxyPort": [" proxyport", "ProxyServer", " proxyAddress", "ProxyAddress", "proxyport", "proxyAddress", "Proxyport", "httpServer", "ProxyPort", "httpPort", "httpHost", "proxyServer", "cacheHost", "ProxyHost", "cachePort", "cacheport", "cacheAddress", "httpAddress", " proxyServer"], "con": ["ch", "ctrl", "pc", "ca", "http", "ci", "can", "out", "fac", "don", "pub", "socket", "gen", "ai", "fl", "ec", "ver", "fa", "an", "c", "cache", "rec", "cone", "fun", "xc", "pin", "cc", "cl", "connection", "mc", "win", "cn", "cp", "ocon", "cur", "x", "per", "pre", "login", "en", "conf", "sub", "connect", "re", "cm", "n", "act", "go", "conv", "open", "co", "sync", "cf", "ac", "min", "cr", "part", "rc", "ls", "f", "Con", "uc", "fan", "com", "run", "fc", "cas", "cons", "func", "canon", "ran", "conn", "on", "exec", "syn", "bc", "CON", "close", "remote", "change", "inc", "pen", "un", "common"], "is": ["ib", "il", "ics", "or", "js", "us", "si", "isa", "ios", "im", "serv", "bs", "isl", "act", "ir", "was", "state", "iris", "oss", "has", "as", "ci", "api", "can", "ais", "os", "IS", "abs", "cms", "in", "ri", "conn", "are", "does", "ie", "it", "p", "fs", "isin", "s", "Is", "out", "vs", "iss", "iso", "ar", "get", "sp", "ops", "cos", "its", "ws", "cs", "isi", "isc", "i", "ori", "bis", "mis", "lis", "ai", "isu", "ps", "id", "es", "info", "ris"], "u": ["iu", "us", "uci", "c", "ru", "m", "o", "http", "U", "ur", "io", "api", "os", "yu", "ue", "ui", "uv", "cu", "user", "conn", "p", "up", "l", "ut", "f", "fu", "su", "i", "q", "ul", "h", "uc", "hu", "file", "v", "ou", "tu", "b", "uri", "nu", "client", "lu", "un"], "proxy": ["resource", "timeout", "fe", "pc", "cop", "plus", "shadow", "ip", "zip", "c", "cache", "host", "http", "roxy", "pse", "copy", "api", "phone", "force", "pin", "xy", "address", " proxies", "p", "l", "connection", "pe", "pa", "port", "server", "Proxy", "clone", "x", "config", "bean", "pool", "f", "wrapper", " Proxy", "lib", "socket", "remote", "ssl", "type", "web", "XY", "uri", "prot", "client", "create"], "baos": ["abis", "caOS", "aas", "caos", "boas", "paOS", "abos", "bao", "Baros", "bolos", "bais", "baas", "balos", "paos", "baOs", "BAOs", "alos", "pais", "aos", "Bais", "BAis", "calos", "boos", "haOS", "Baos", "baOS", "baros", "caas", "hais", "aOS", "BAos", "haos", "hao", "BAOS", "BAros", "abros", "BaOs", "pao", "boOS", "abOs", "BAo"]}}
{"id1": "19322941", "id2": "19134229", "code1": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"test_lookupResourceType_FullSearch_TwoWordsInMiddle": ["test_lookupResourceType_FullSearch_FourW", "test_lookupResourceType_FullSearchWithTwoW", "test_lookupResourceType_FullSearchWithTwowords", "test_lookupResourceType_FullSearch_FourWords", "test_lookupResourceType_FullSearch_ThreeW", "test_lookupResourceType_FullSearchWithtwoWord", "test_lookupResourceType_FullSearchWithTwoWord", "test_lookupResourceType_FullSearch_Twowords", "test_lookupResourceType_FullSearch_TwoWord", "test_lookupResourceType_FullSearch_ThreeWord", "test_lookupResourceType_FullSearch_TwoW", "test_lookupResourceType_FullSearch_Fourwords", "test_lookupResourceType_FullSearch_twoWord", "test_lookupResourceType_FullSearch_FourWord", "test_lookupResourceType_FullSearch_TwoWords", "test_lookupResourceType_FullSearchWithTwoWords", "test_lookupResourceType_FullSearch_twowords", "test_lookupResourceType_FullSearchWithtwoWords", "test_lookupResourceType_FullSearch_Threewords", "test_lookupResourceType_FullSearch_twoW", "test_lookupResourceType_FullSearch_twoWords", "test_lookupResourceType_FullSearchWithtwowords", "test_lookupResourceType_FullSearch_ThreeWords", "test_lookupResourceType_FullSearchWithtwoW"], "url": ["resource", "entry", "position", "string", "c", "channel", "method", "http", "URL", "path", "log", "contact", "feed", "https", "Url", "conn", "object", "address", "user", "bug", "l", "document", "base", "server", "location", "system", "config", "sl", "f", "link", "image", "page", "ssl", "b", "web", "uri", "client", "org", "file"], "connection": ["resource", "entry", "application", "use", "section", "function", "position", "c", "Connection", "channel", "cache", "context", "method", "http", "expression", "proxy", "character", "service", "condition", "response", "ion", "con", "contact", "io", "number", "operation", "database", "relation", "conn", "object", "translation", "handler", "loc", "bug", "db", "l", "document", "j", "event", "communication", "server", "established", "location", "config", "bc", "link", "session", "wrapper", "password", "image", "connect", "result", "b", "connected", "uri", "client", "body", "version", "which"]}}
{"id1": "16378239", "id2": "8815137", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "label": 1, "substitutes": {"byReference": ["toref", "toReference", "ByReference", "ofReference", "ByLink", "orref", "orLink", "toExternal", "ofref", "orExternal", "orReference", "ofLink", "ByExternal", "ofExternal", "toLink", "Byref"], "inputStream": ["outputSteam", "InputReader", "inputFile", " inputObject", "outputFile", "inputString", "inputObject", " inputString", "tempStream", "inputstream", "tempReader", "tempstream", " inputstream", "inSteam", "outputStream", "InputSteam", "inReader", "instream", "inStream", "InputFile", "Inputstream", "outputString", "tempSteam", "inputReader", "InputString", "InputObject", "outputObject", "InputStream", "outputstream", "inputSteam"], "tempFile": ["fakeFile", " tempStream", "tempFiles", "tmpF", "tmpContent", "TempContent", "tempF", "tempStream", "tmpPage", "tmpFile", "TempFiles", " tempPage", "tmpFiles", "fakePage", " tempFiles", " tempContent", "fakeF", " tempF", "tmpStream", "Tempfile", "tempPage", "tmpfile", "fakeDir", "TempFile", "tempfile", "tmpDir", "tempContent", " tempDir", " tempfile", "fakefile", "fakeStream", "fakeFiles", "tempDir"], "out": ["resource", "temp", "line", "again", "instance", "o", "ex", "Out", "copy", "path", "outer", "io", "outs", "this", "sync", "in", "object", "conn", "user", "err", "connection", "part", "base", "init", "exec", "server", "url", "array", "f", "pool", "a", "image", "to", "writer", " in", "ext", "result", "plain", "output", "data", "write", "obj", "OUT", "null", "flush", "source", "client", "later", "file", "extra"]}}
{"id1": "6840241", "id2": "14191679", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"copy": ["slave", "share", "cop", "cmp", "ip", "proxy", "cover", "Copy", "io", "open", "process", "sync", "download", "opy", "mop", "clone", "server", "load", "system", "size", "image", "transfer", "clip", "write", "type", "loop", "create"], "source": ["resource", "slave", "si", "use", "seed", "channel", "Source", "proxy", "inner", "service", "input", "ource", "from", "slice", "this", "address", "handler", "iterator", "ie", "connection", "server", "sp", "size", "iter", "e", "wrapper", "rice", "ink", "i", "session", "SOURCE", "start", "image", "sin", "result", "se", "reader", "data", "ources", "target", "null", "parent", "stream", "src"], "sink": ["Sink", "tink", "partsINK", "dsider", "dsink", "sinker", " sigh", "pider", "asink", "Source", "sider", "asinker", "tource", " sinker", "tider", "outsource", "partsinker", "pink", "asigh", "outsink", "sINK", "sigh", "tinker", "asource", "dsource", "outsinker", "pource", "dsinker", "outsigh", "partsource", "partsink", "SINK", "pinker", "Sinker", "pINK"]}}
{"id1": "7872659", "id2": "21348951", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndmovieindexfile", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndMovieindexPath", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndmovieIndexfile", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndMovieIndexPath"], "completePath": [" CompleteHome", "successPath", " completePoint", "completeDir", "completeCh", "correctPoint", "progressLoader", "itepath", "progresspath", "completeFile", "correctRoot", " CompleteFile", "donePath", "execLoader", " completepath", "donepath", "successMusic", " completeCorp", " completeRoot", "CompletePath", "completeLoader", "completepath", "flatPoint", "itePath", "progressVol", "successpath", "correctCorp", "iteCh", " completeDir", "execPath", " completeMusic", "CompleteFile", "execVol", "doneLoader", "completeVol", "completeMusic", "completeRoot", "iteMusic", "execpath", "flatCorp", "completeCorp", "CompleteDir", "correctPath", " CompleteDir", "flatPath", " completeFile", " completeHome", "progressPath", "completePoint", " CompletePath", "flatRoot", "CompleteHome", "doneVol", "successCh", " completeCh", "completeHome"], "masterFile": ["cacheFILE", "masterName", "mastersFILE", "MasterFilename", "configName", "masterFilename", "MasterName", "mastersFile", "MasterFile", "configPath", "configFilename", "MasterPath", "mastersPath", "masterFILE", "masterPath", " masterPath", "cacheFile", "masterFiles", "configFile", "cacheFiles", "MasterFiles", "mastersFiles", " masterFilename", "cachePath", "MasterFILE", " masterName"], "CustRatingFileName": ["CustRateFilenameSize", "CustIndexFileName", "CustIndexFileVersion", "CustRatingLineName", "CustIndexFilesName", "CustRateFilePath", "CustIndexFileType", "CustRatingLineVersion", "CustRateFilenameDesc", "CustRatingClassPath", "CustIndexFilesType", "CustRatingFullDesc", "CustRatingFileType", "CustRatingFullPath", "CustRatingLinePath", "CustRatingLineType", "CustRatingFilenamePath", "CustRatingClassVersion", "CustRateFileSize", "CustRatingFilenameName", "CustRatingFileSize", "CustRatingClassName", "CustRatingFileDesc", "CustRateFilenameName", "CustRatingFilesPath", "CustRatingFilesDesc", "CustRatingFilesType", "CustRatingFilesName", "CustRatingFullSize", "CustRateFileName", "CustRateFileDesc", "CustIndexFilesVersion", "CustRatingClassType", "CustRatingFilesSize", "CustRateFilenamePath", "CustIndexFilePath", "CustRatingFilenameSize", "CustRatingFullName", "CustRatingFileVersion", "CustRatingFilePath", "CustIndexFilesPath", "CustRatingFilesVersion", "CustRatingFilenameDesc"], "MovieIndexFileName": ["MovieEditFUrl", "MovieConfigFileName", "MovieIndexFolderFile", "MovieIndexFName", "MovieIndexFSize", "MovieEditFileName", "MovieConfigFileFile", "MovieIndexClassSize", "MovieConfigFileVersion", "MovieIndexFolderName", "MovieIndexFILEFile", "MovieEditFileUrl", "MovieIndexFUrl", "MovieIndexClassName", "MovieConfigFolderVersion", "MovieEditFSize", "MovieIndexPlaceVersion", "MovieEditFileSize", "MovieIndexPlaceFile", "MovieIndexClassname", "MovieIndexFileFile", "MovieIndexFileVersion", "MovieEditFname", "MovieIndexClassUrl", "MovieIndexFileUrl", "MovieIndexFilesName", "MovieEditFilename", "MovieConfigFileHandle", "MovieIndexFilesname", "MovieConfigFolderName", "MovieIndexFilesUrl", "MovieIndexPlaceName", "MovieConfigFolderFile", "MovieIndexPlaceHandle", "MovieIndexFilename", "MovieIndexFILEHandle", "MovieIndexFname", "MovieIndexFileHandle", "MovieIndexFILEVersion", "MovieIndexFolderHandle", "MovieIndexFolderVersion", "MovieEditFName", "MovieIndexFILEName", "MovieIndexFileSize", "MovieConfigFolderHandle", "MovieIndexFilesSize"], "inFile": ["outfile", "outSourceFile", "incSourceFile", "inputFile", " infile", "outC", "InSourceFile", "inputSourceFile", "inF", " inF", "infile", "incC", "Infile", "InF", "InFile", "inputfile", " inSourceFile", "inSourceFile", "outFile", "inputF", "incFile", "incfile"], "inC": ["inCI", "outCL", " inCL", " inCC", "inputFile", "inputC", "innerCI", "outC", "inB", "InB", " inB", "inF", " inF", "inCC", "innerCC", "InCI", "InF", "innerC", "outF", "InFile", "outCC", "InC", "outFile", "InCC", "inputF", "inputCC", "outCI", "inCL", "outB", "innerFile", "InCL"], "outFile1": ["outPath1", "againCFirst", "outPlace1", "outputfileId", "outF2", "outputfile2", "outputFileId", "outFilesFirst", "outPath2", "outfile1", "outFName", "againFile2", "outFiles3", "outFiles2", "outFId", "againC3", "outPathFirst", "outfile2", "againC1", "outputFileName", "outputfile1", "outPlaceId", "outF1", "outFiles1", "outFileId", "outFileName", "outputFile1", "outC3", "outputfileName", "againC2", "outPlace2", "outPlaceName", "againFile3", "againFile1", "outCFirst", "outfileId", "outFile3", "outFileFirst", "againFileFirst", "outfileName", "outputFile2", "outPath3"], "outC1": ["outF8", "newc81", "outFOne", "againB2", "outCFOne", "outB2", "outF2", "outB8", "outDOne", "newC81", "againB8", "outcFirst", "newcOne", "outD81", "outCOne", "againC8", "outD1", "outB1", "outD8", "newc1", "againC1", "outBOne", "outC81", "outF1", "newC1", "newCFirst", "outD2", "againC2", "outDFirst", "outc81", "againCOne", "newCOne", "outCFFirst", "againB1", "outCFirst", "outCF1", "outC8", "newcFirst", "againBOne", "outc1", "outCF81", "outcOne"], "outFile2": ["againLine2", "outputfileTwo", "outputFile5", "outChannel1", "outfile5", "outFiles4", "outFilesTwo", "outChannel6", "outputfile2", "outLine6", "outLine1", "againFileTwo", "outFiles6", "outDirectory5", "outputfile5", "outDirectoryTwo", "outFiles2", "outDirectory2", "outChannel2", "againFile2", "againLine1", "outFile5", "outfile4", "againFile6", "outfile2", "outFile6", "outfileTwo", "outFiles1", "outChannelTwo", "againLineTwo", "outFiles5", "outputFileTwo", "outFile4", "againFile1", "outputfile4", "outLineTwo", "outFileTwo", "outLine2", "againLine6", "outDirectory4", "outputFile4", "outputFile2"], "outC2": ["OutC4", "OutC1", "againB4", "againB2", "outB2", "outF2", "againCTwo", "outCache4", "againC4", "outC4", "OutCII", "outFileII", "outB1", "outCII", "againC1", "outF1", "outCache1", "outB4", "outFII", "againC2", "outCache2", "outBTwo", "OutFII", "outFile4", "outCTwo", "againB1", "outCacheII", "OutF1", "OutF4", "OutC2", "outFileTwo", "OutF2", "againBTwo", "outF4", "outFTwo"], "fileSize": [" fileAddress", "fileSIZE", " fileLength", "resourceSIZE", " fileMode", "bufferSize", "bufferLength", "fileLength", "imageSIZE", "FileAddress", "resourceSize", "resourceAddress", "FileSIZE", " fileSIZE", "imageSize", "FileSize", "FileMode", "bufferMode", "FileLength", "fileAddress", "fileMode", "imageLength"], "totalNoDataRows": ["totalNoPageRues", "totalNoDataLues", "totalNoPageLrows", "totalNoDataLrows", "totalNoPageLues", "totalNoDataCues", "totalNoDataChrows", "totalNoPageLOWS", "totalNoDataRues", "totalNoPageLows", "totalNoDataChues", "totalNoPageROWS", "totalNoDataCrows", "totalNoDataLows", "totalNoPageRows", "totalNoDataChows", "totalNoDataCows", "totalNoDataChOWS", "totalNoDataRrows", "totalNoDataLOWS", "totalNoDataROWS", "totalNoPageRrows", "totalNoDataCOWS"], "mappedBuffer": ["mappedStream", "mapedBuffer", "machedChannel", "machedbuffer", "MappingChannel", "mapedStream", "MachedURL", "machedBuffer", "mashedChannel", "MappedURL", "mapedURL", "mippedStream", "machedURL", "MappedBuff", "MappingFile", "mppedStream", "MappingBuffer", "mactedbuffer", "mippedBuffer", "mappingBuffer", "MachedStream", "machedStream", "mactedBuffer", "mippedBuff", "machedFile", "Machedbuffer", "mactedBuff", "MachedBuff", "mappedbuffer", "mippedURL", "machedBuff", "mappingChannel", "MappingBuff", "MappedChannel", "mashedFile", "mactedStream", "MappedBuffer", "MappedStream", "MachedBuffer", "mashedBuffer", "mapedFile", "mappingbuffer", "Mappedbuffer", "mappingStream", "mappingFile", "MappedFile", "mappedChannel", "mapedBuff", "mappedFile", "MachedChannel", "mappedURL", "mppedBuff", "mappingBuff", "MachedFile", "mppedBuffer", "mappedBuff", "mashedBuff", "mppedChannel"], "startIndex": ["startindex", "startOffset", "initInfo", "endindex", "endSection", "useindex", "stopIndex", "startingIndex", "startingPosition", "startCode", " startindex", "StartInfo", "useIndex", " startSection", "usePosition", "stopRow", " startCode", " startPoint", " startInfo", "startInfo", "StartIndex", "startSection", "endInfo", "StartPosition", "startingSection", "initIndex", " startRow", "startingPoint", "StartOffset", "endIndex", "endCode", "stopindex", "initOffset", "endPosition", "startPosition", "endPoint", "Startindex", "initindex", "useInfo", "stopCode", "startPoint", " startPosition", "startRow", "endRow", " startOffset"], "count": ["group", "c", "current", "cache", "col", "call", "depth", "limit", "total", "more", "self", "sum", "time", "old", "Count", "number", "key", "force", "add", "first", "list", "length", "child", "weight", "part", "order", "all", "coll", "find", "thread", "max", "size", "index", "pool", "other", "code", "len", "i", "allow", "ind", "start", "close", "counter", "test", "follow", "type", "found", "id", "loop", "name", "keep"], "currentMovie": ["currentlyMusic", " currentMusic", "parentMovie", "currentFilm", "validMovie", "thismovie", "reportedMusic", "currentmovie", "currentPicture", "CurrentFilm", "parentFilm", "CurrentTheme", "CurrentMovie", "reportedFilm", "reportedMovie", "Currentmovie", "thisMovie", "defaultImage", "validFilm", "currentTheme", "reportedPicture", "defaultMovie", "reportedTheme", "validmovie", "currentImage", "defaultFilm", "parentPicture", "reportedImage", "currentMusic", "reportedmovie", "currentlyMovie", "defaultMusic", " currentFilm", " currentPicture", "thisPicture", "currentlyPicture", " currentImage", "thisFilm", "parentmovie", " currentmovie", "validTheme"], "movieName": ["moviename", "camFamily", " movieInfo", " movieId", "filmFamily", "filmname", "movieId", "filmName", "voiceId", "moneyNumber", "voiceInfo", "movieInfo", " movieFamily", "MovieName", "filmNumber", " moviename", "camName", "moneyName", "movieNumber", "movieFamily", "voicename", "camname", "MovieInfo", "voiceName", "MovieNumber", "MovieFamily", "Moviename", "MovieId", "moneyFamily"], "customer": ["ustomor", "ustomers", " customeri", " customER", "mixER", "CustomER", "ustomer", "Customers", "Customer", "customER", "customor", "mixor", " customers", "ustomER", "customers", "mixer", "customeri", "Customor", "ustomeri", "Customeri", "mixers"], "rating": ["resource", "Rating", "setting", "attribute", "ranking", "string", "packing", "reading", "http", "ruby", "comment", "number", "rage", "ring", "ing", "missing", "alpha", "including", "rate", "rc", "url", "score", "rank", "rice", "value", "feature", "rolling", "writer", "RC", "rated", "reader", "range", "type", "data", "writing", "error", "rr", "r", "rates", "id", "info", "radius", "padding"], "outBuf1": ["outBum1", "outFuf1", "outBuf01", "outBbuf11", "outDuff3", "outBummerCloud", "outBiff1", "outDuf3", "outBuff0", "outBaf1", "outKbuffOne", "outBuffn", "outBuff2", "outBbufOne", "outDuffn", "outBuf3", "outCuf1", "outCuf0", "outBummerOne", "outBalth2", "outKbuf1", "outBbuffOne", "outFufOne", "outKuf1", "outBuff1", "outBbuf1", "outBafOne", "outBufOne", "outKbuff1", "outBufn", "outKbuff8", "outKuf2", "outDuf11", "outFuf91", "outBuf8", "outBaf8", "outBbufn", "outFafOne", "outBbuf91", "outBaf3", "outFuf01", "outBaft1", "outBuffCloud", "outBum91", "outBbuff0", "outBuff8", "outBuff3", "outBuff11", "outBbuff1", "outCuff0", "outFaf1", "outFbuf01", "outBafCloud", "outBbuf2", "outKbuf2", "outBum01", "outBbuff8", "outBalth1", "outCuffOne", "outBuf0", "outKbuff3", "outBiff01", "outKufOne", "outFufCloud", "outBummer1", "outKbuf3", "outBiff91", "outBiffOne", "outBuf91", "outFbuf91", "outKuf3", "outFbufOne", "outBumOne", "outBalth3", "outKuf8", "outDuff11", "outBaf0", "outFbuf1", "outDufn", "outCufOne", "outBuf11", "outDuff1", "outBbuff3", "outBaftn", "outBbuf01", "outCuff1", "outBufCloud", "outBaft3", "outBaft11", "outBbuf3", "outDuf1", "outFafCloud", "outBuffOne"], "outBuf2": ["outFbuff2", "outFufB", "outFuf4", "outBuf12", "outBuf200", "outWBuff8", "outWBuff4", "outFbuff1", "outFuf1", "outBuf20", "outBum82", "outFuf20", "outBait4", "outFuf12", "outWBuff2", "outWBuf0", "outBbufTwo", "outBbuffer4", "outFbuffTwo", "outWBuf4", "outBuff0", "outBoff8", "outWBbuff8", "outBbuff4", "outFbuf12", "outFbuff4", "outWBuf8", "outFuf8", "outBuff2", "outBuf4", "outWBbuff2", "outBait200", "outBbuff2", "outWBbuffTwo", "outBbuffTwo", "outFbuff8", "outFbuff82", "outBbuff200", "outBuffTwo", "outBbuf12", "outBait2", "outFuf2", "outBbuff20", "outBufB", "outBuff1", "outBum8", "outBbuf1", "outBufTwo", "outBuf8", "outBbufB", "outFbuff20", "outBbuffer2", "outBbuff0", "outBuff8", "outBait8", "outBbuff1", "outBum20", "outBbuf2", "outBbuff8", "outBuf0", "outBoffTwo", "outBuber82", "outWBuff0", "outFufTwo", "outBuff4", "outWBuf2", "outBum2", "outBoff2", "outFbufB", "outBbuff82", "outBbufferB", "outFuf82", "outBuber8", "outBoff200", "outBuber2", "outBbuffer12", "outBuf82", "outBaitTwo", "outBait0", "outFbuf4", "outFbuf2", "outWBbuff200", "outBbuf4", "outWBuf200", "outWBufTwo", "outBuff12", "outBuffB", "outBuber20"], "endOfIndexFile": ["endOfindexfile", "endOfLinkDir", "endOfindexTime", "endOfindexFolder", "endofIndexDir", "endofLinkFile", "endedfile", "endOfClientTime", "endOfClientFile", "endOfIndexfile", "endOfImageTime", "endOfindexFiles", "endOfIndexFolder", "endofindexFile", "endOfDataFile", "endOfLinkFiles", "End\n", "endOfindexDir", "end\n", "endofIndexFiles", "endOfIndexTime", "endOfindexFile", "endfile", "Endfile", "endOfLinkFile", "endofIndexTime", "endOfLinkfile", " end\n", "endofindexTime", "endofLinkTime", "endOfIndexDir", "endOfImageFiles", "endOfDataTime", "endOfImageFile", "endOfClientFiles", "endOfLinkTime", " endfile", "endofLinkDir", "endofindexFolder", "endofindexFiles", "endofIndexFolder", "endOfImageFolder", "endOfDatafile", "endofLinkFiles", "ended\n", "endOfIndexFiles", "endofIndexFile", "endOfClientDir", "endOfDataDir"]}}
{"id1": "3024992", "id2": "17996547", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter_nulls", "testCopy_readerToWriter_writers", "testCopy_readerToWriter_stds", "testCopy_readerToWriter_std_", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_Nulls", "testCopy_readerToWriter_stdIn", "testCopy_readerToWriter2Nullin", "testCopy_readerToWriter2null_", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter_stdin", "testCopy_readerToWriter2nulls", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter2nullIn", "testCopy_readerToWriter_writerin", "testCopy_readerToWriter_writerIn", "testCopy_readerToWriter_Nullin", "testCopy_readerToWriter2Nulls", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter_null_", "testCopy_readerToWriter_writer_"], "baout": ["BAOUT", "baOut", "baash", "Baouts", "baouts", "Baout", "BAash", " baouts", "BaOUT", "baOUT", " bain", "BAOut", "aeouter", "Baash", " baOut", "bonout", "BAout", "BAio", "BaOut", "bain", "aeout", "BAin", "aeOut", "Baouter", "aeOUT", "bonash", "BAouts", "bonio", "baio", "bonin", "Bain", "Baio", "BAouter", "baouter"], "out": ["class", "line", "Out", "copy", "outer", "io", "Writer", "outs", "in", "er", "err", "s", "array", "test", "output", "reader", "write", "OUT", "r", "null", "buffer", "able", "file", "Output", "flow"], "writer": ["temp", "riter", "entry", "class", "writ", "writers", "player", "pointer", "wer", "ee", "copy", "outer", "Writer", "io", "wa", "driver", "in", "letter", "er", "unit", "RW", "w", "work", "x", "rw", "her", "worker", "reader", "output", "data", "write", "writing", "null", "r", "buffer", "source", "builder", "file"]}}
{"id1": "8093133", "id2": "18046717", "code1": "    public static Object loadXmlFromUrl(URL url, int timeout, XML_TYPE xmlType) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        BufferedInputStream buffInputStream = new BufferedInputStream(connection.getInputStream());\n        return loadXml(buffInputStream, xmlType);\n    }\n", "code2": "    private String getFullClassName(URL url, String className) throws Exception {\n        JarInputStream jis = new JarInputStream(url.openStream());\n        ZipEntry zentry = null;\n        while ((zentry = jis.getNextEntry()) != null) {\n            String name = zentry.getName();\n            int lastPos = name.lastIndexOf(\".class\");\n            if (lastPos < 0) {\n                continue;\n            }\n            name = name.replace('/', '.');\n            int pos = -1;\n            if (className != null) {\n                pos = name.indexOf(className);\n                if (pos >= 0 && name.length() == pos + className.length() + 6) {\n                    jis.close();\n                    return (name.substring(0, lastPos));\n                }\n            }\n        }\n        jis.close();\n        return (null);\n    }\n", "label": 0, "substitutes": {"loadXmlFromUrl": ["loadXMLFromurl", "loadXmlfromurl", "loadXmlWithFile", "loadXMLfromURL", "loadXmlfromURL", "loadXmlAsurl", "loadXmlAsURL", "loadXmlFromFile", "loadXMLFromURL", "loadXMLfromUrl", "loadXmlFromURL", "loadXMLfromurl", "loadXmlWithUrl", "loadXMLFromFile", "loadXmlFromurl", "loadXmlAsFile", "loadXmlWithurl", "loadXMLFromUrl", "loadXmlfromUrl", "loadXMLfromFile", "loadXmlAsUrl", "loadXmlfromFile", "loadXmlWithURL"], "url": ["resource", "string", "host", "http", "str", "service", "URL", "path", "io", "open", "feed", "Url", "client", "user", "object", "address", "conn", "loc", "l", "base", "server", "location", "config", "loader", "sl", "link", "image", "page", "ssl", "obj", "id", "uri", "source", "buffer", "org", "file"], "timeout": ["resource", "token", "window", "cache", "capacity", "limit", "delay", "time", "io", "key", "network", "sync", "length", "client", "seconds", "unit", "out", "port", "server", "wait", "size", "config", "scroll", "period", "socket", "resolution", "Timeout", "ssl", "until", "type", "data", "duration", "offset", "buffer", "lock", "sleep"], "xmlType": ["elementStyle", "xmltype", "elementType", "writerModel", "phpType", " xmlTypes", " xmlStyle", " xmlFile", " xmlModel", "phpTypes", "phpClass", "xmlFile", "mlFile", " xmltype", " xmlClass", "xmlClass", "xmlModel", "elementModel", "elementtype", "mlType", "mlTypes", "xmlTypes", "mlClass", "phpFile", "xmlStyle", "writerType", "writertype", "writerStyle"], "connection": ["resource", "entry", "application", "closed", "section", " Connection", "use", "function", "container", "position", "c", "Connection", "channel", "context", "union", "http", "proxy", "character", "condition", "response", "ion", "con", "io", "open", "network", "database", "relation", "client", "conn", "handler", "unit", "which", "loc", "l", "event", "communication", "server", "config", "bc", "index", "wrapper", "socket", "writer", "directory", "reader", "b", "connected", "uri", "connect", "collection", "version", "builder", "lc"], "buffInputStream": ["buffinputstream", "buffInstream", "BuffInputstream", "BuffInputStream", "BuffOutputStream", "buffinputStream", "BuffReadSteam", "buffReadSteam", "buffOutputSteam", "buffOutputstream", "buffInSteam", "BuffReadStream", "buffInStream", "BuffInputSteam", "BuffOutputstream", "buffReadStream", "buffInputSteam", "BuffOutputSteam", "buffInputstream", "BuffReadstream", "buffReadstream", "buffinputSteam", "buffOutputStream"]}}
{"id1": "3683344", "id2": "17996547", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 0, "substitutes": {"genRandomGUID": [" genRandGIP", " genRandomGUIP", " genRandUID", " genRandUUID", " genRandomGID", " genRandGUID", " genRandomGuid", " genRandomUuid", " genRandomIGID", " genRandomUUID", " genRandGID", " genRandomGUuid", " genRandomUIP", " genRandomGIP", " genRandUuid", " genRandomGUUID", " genRandomUID", " genRandomIGUID", " genRandomIGIP", " genRandomIGuid", " genRandUIP", " genRandGuid"], "secure": ["timeout", "seed", "zip", "exclusive", "host", "secret", "depth", "str", "proxy", " Secure", "safe", "fast", "Secure", "protect", "https", "force", "sensitive", "sys", "active", " insecure", "random", "weak", "server", "security", "config", "sec", "session", "allow", "password", "q", "close", "remote", "ssl", "stable", "require", "forced", "debug", "deep", "client", "ssh", "encrypted", "smart"], "valueBeforeMD5": ["valueBeforeMR85", "valueBeforeMP2", "valueBeforeMC8", "valueBeforeM3", "valueBeforeAMD3", "valueBeforeMC5", "valueBeforeMR5", "valueAfterMD85", "valueBeforeMT3", "valueBeforeMT55", "valueBeforeMD55", "valueBeforeSHA5", "valueBeforeMD3", "valueAfterMD3", "valueBeforeMS5", "valueBeforeMT2", "valueAfterMC5", "valueBeforeMT05", "valueBeforeAMD05", "valueBeforeMR8", "valueAfterMD05", "valueBeforeMS1", "valueAfterMC8", "valueBeforeMT5", "valueBeforeMD85", "valueBeforemd5", "valueBeforeSHA3", "valueAfterMS5", "valueBeforeMD2", "valueBeforeMC85", "valueAfterMS2", "valueAfterMD55", "valueAfterMC3", "valueBeforeMD1", "valueAfterMD2", "valueBeforeM1", "valueBeforeMP5", "valueBeforeMD8", "valueAfterMS3", "valueAfterMC85", "valueBeforeSHA2", "valueBeforeMR3", "valueBeforeAMD5", "valueBeforemd85", "valueBeforemd3", "valueBeforeAMD20", "valueBeforeMS2", "valueBeforeM5", "valueAfterMS1", "valueBeforeMD20", "valueBeforeMP3", "valueAfterMD8", "valueBeforeM2", "valueBeforeMC3", "valueBeforeMT20", "valueBeforemd8", "valueBeforeMD05", "valueBeforeMS3", "valueBeforeSHA1", "valueAfterMD1", "valueAfterMD20", "valueBeforeMP55"], "valueAfterMD5": ["valueAfterMFTE", "valueAfterASTody", "valueAfterDM5", "valueAfterMT3", "valueAfterAST5", "valueBeforeMD3", "valueAfterMD3", "valueAfterHTMLody", "valueAfterDM3", "valueAfterMT5", "valueAfterGM3", "valueAfterAST005", "valueBeforeVM3", "valueAfterMC1", "valueAfterMF5", "valueAfterM1", "valueBeforeMP3", "valueAfterDF005", "valueAfterAST512", "valueBeforeMD005", "valueAfterVM005", "valueAfterVM3", "valueBeforeMC5", "valueAfterMC2", "valueAfterDMody", "valueBeforeAST3", "valueAfterAMD5", "valueAfterAST2", "valueAfterHTML512", "valueAfterDM512", "valueBeforeMDTE", "valueBeforeMDody", "valueBeforeMDql", "valueAfterMD2", "valueAfterAMD005", "valueAfterAMD3", "valueAfterMPTE", "valueAfterMDTE", "valueBeforeVM5", "valueAfterMP2", "valueAfterM3", "valueBeforeMPTE", "valueBeforeMC3", "valueAfterDF5", "valueBeforeMP1", "valueAfterHTML5", "valueBeforeVM005", "valueAfterVM5", "valueBeforeMD05", "valueAfterM2", "valueBeforeASTody", "valueAfterGM005", "valueBeforeAST005", "valueAfterMD512", "valueAfterMDody", "valueBeforeMD512", "valueAfterAST3", "valueAfterMF3", "valueAfterMD05", "valueBeforeMD2", "valueBeforeAST2", "valueBeforeAST5", "valueAfterMD005", "valueAfterHTMLTE", "valueAfterM5", "valueAfterHTML3", "valueAfterMF05", "valueAfterMD1", "valueBeforeMP2", "valueAfterMP5", "valueAfterMP005", "valueAfterGM2", "valueAfterMCql", "valueAfterMC5", "valueBeforeMCql", "valueAfterDF3", "valueAfterMP3", "valueAfterMC3", "valueBeforeMD1", "valueAfterGM5", "valueBeforeAST512", "valueAfterMDql", "valueBeforeMP5", "valueAfterMP1", "valueAfterHTML05", "valueAfterMTql", "valueAfterMP05", "valueBeforeMP05"], "md5": ["MD25", "cmd05", "mand2", "mand5", "MD2", "amd512", " md25", "cmd65", "mandkey", " md65", "MD5", " MD3", "amd25", "cmd53", " md53", "md2", "cmd2", "cmd3", " md05", "md53", "mdkey", "md05", " MD53", " md2", " MD5", " MD05", "md1", "mand65", "md65", "md512", "cmd512", "mand3", " md512", "mand1", "cmdkey", " md1", "MD512", "amd2", "md3", " mdkey", "mand512", "cmd1", "amd5", " md3", "md25", "cmd5"], "sbValueBeforeMD5": ["sbValueBeforeAMD25", "sbValueBeforeND85", "sbValueBeforeMP85", "sbValueBetweenMD305", "sbValueInsideAMD5", "sbValueAfterMD005", "sbValuebeforeND2", "sbValueBehindND25", "sbValueBeforeMP512", "sbValueBeforeMT5", "sbValueBeforeMM5", "sbValueBeforeMD005", "sbValueBeforeMP1", "sbValueAfterMP005", "sbValueBeforeMG5", "sbValueInsideMD25", "sbValueBeforeND3", "sbValueAfterMP55", "sbValueBeforeMR3", "sbValueAfterMD5", "sbValueBeforeAMD3", "sbValuebeforeMD85", "sbValueBeforeND5", "sbValueBeforeMP55", "sbValueBeforeMT55", "sbValueBeforeMP3", "sbValueBetweenmd2", "sbValueBeforeMD2", "sbValueBetweenMD3", "sbValueBeforeMD512", "sbValueWithoutMF5", "sbValueBeforemd3", "sbValueBeforeMF25", "sbValueBetweenMD2", "sbValueBeforeMP5", "sbValueBeforeMC25", "sbValueBeforeMF35", "sbValueBetweenmd305", "sbValueBeforeMR25", "sbValueWithoutMF35", "sbValuebeforeND85", "sbValueBeforeND25", "sbValueBeforeMP25", "sbValueBeforeMC5", "sbValueInsideMD3", "sbValueBeforeMM3", "sbValueBeforemd305", "sbValueBehindND3", "sbValueBeforeMP2", "sbValueBeforeAMD305", "sbValueBehindND525", "sbValueBeforeMR525", "sbValueBeforeMM005", "sbValueAfterMD3", "sbValueBeforeND2", "sbValueBeforeAMD2", "sbValueBehindMD25", "sbValueAfterMP5", "sbValueBehindMD3", "sbValueBehindMD525", "sbValueBeforeMD1", "sbValueBeforeMD85", "sbValueInsideAMD25", "sbValueBeforeMF3", "sbValueWithoutMD3", "sbValueBeforeMD05", "sbValueBeforeMD25", "sbValueBeforeMP05", "sbValueBeforeMT3", "sbValueBeforeMD55", "sbValueBeforeMC3", "sbValueBeforeND525", "sbValueBeforeMS1", "sbValueBeforeMS2", "sbValueBeforeMG3", "sbValueAfterMD512", "sbValueAfterMP512", "sbValuebeforeMD2", "sbValuebeforeMD5", "sbValueBeforeMR5", "sbValueWithoutMF3", "sbValueBeforeMP305", "sbValueBetweenMD5", "sbValueBeforemd05", "sbValueBeforemd2", "sbValueInsideAMD3", "sbValueBeforeMM55", "sbValueBeforeMS512", "sbValueBeforemd5", "sbValueAfterMP1", "sbValuebeforeND3", "sbValueBeforemd25", "sbValueBeforeMT005", "sbValueWithoutMF25", "sbValueBeforeMF5", "sbValueBehindND5", "sbValueBeforeMP525", "sbValuebeforeMD3", "sbValueWithoutMD25", "sbValueBeforeMS5", "sbValueWithoutMD35", "sbValueBetweenmd5", "sbValueBeforeMD35", "sbValueBeforeAMD05", "sbValueBeforeMG25", "sbValueBeforeMS3", "sbValueBeforeMD305", "sbValueBeforeMP005", "sbValueInsideMD05", "sbValuebeforeND5", "sbValueInsideAMD05", "sbValueBetweenmd3", "sbValueAfterMD55", "sbValueBeforeAMD5", "sbValueBeforeAMD512", "sbValueBeforeMG35", "sbValueBeforeMD525", "sbValueBeforeAMD1", "sbValueInsideMD5", "sbValueAfterMD1", "sbValueBeforeMD3", "sbValueAfterMP3", "sbValueBehindMD5", "sbValueWithoutMD5", "sbValueBeforeMC35", "sbValueBeforeMS85"], "time": ["timeout", "temp", "etime", "seed", "speed", "times", "host", "hour", "depth", "version", "money", "delay", "cost", "year", "length", "mode", "random", "tz", "count", "age", "month", "rate", "port", "work", "clock", "size", "name", "date", "TIME", "value", "q", "start", "counter", "ime", "type", "error", "duration", "id", "timer", "race", "sleep", "Time"], "rand": ["rss", "root", "seed", "clean", "rh", "raid", "depth", "dist", "version", "winner", "right", "delay", "core", "year", "rage", "bit", "length", "random", "pick", "bug", "count", "alpha", "rule", "ng", "ro", "order", "win", "rc", "rate", "reg", "max", "dr", "Rand", "rank", "index", "serial", "nd", "q", "range", "error", "type", "rr", "r", "risk", "id", "pattern", "round", "mid", "re", "name"], "array": ["row", "integer", "section", "function", "multi", "string", "instance", "cache", "vector", "ray", "view", "table", "expression", "area", "angle", "list", "number", "Array", "database", "pair", "our", "object", "address", "archive", "bug", "sample", "batch", "app", "all", "element", "arr", "now", "index", "air", "value", "feature", "image", "a", "record", "range", "error", "r", "module", "arrow", "collection"], "strTemp": ["objtemp", "strVar", "brVar", "crtemp", "objTemp", "crTemp", "strTem", "strBase", "crTemplate", "brTemp", "stringTem", "arrBase", "stringTemp", "drTemp", "crTem", "arrtemp", "objFake", "strFake", "brTem", "objTem", "brTest", "StrBase", "strtemp", " strFake", "strTemplate", " strtemp", "arrTest", "stringFake", "drTemplate", "brtemp", " strTest", "drtemp", " strBase", "arrTemp", " strVar", "Strtemp", " strTem", "drTem", "drVar", " strTemplate", "stringtemp", "strTest", "arrTem", "StrTemp"], "i": ["hi", "si", "ip", "u", "multi", "n", "ii", "c", "k", "pi", "o", "y", "d", "abi", "ci", "di", "io", "z", "key", "slice", "ji", "ui", "in", "ri", "ie", "p", "l", "phi", "j", "I", "eni", "x", "index", "f", "field", "e", "li", "start", "h", "v", "gi", "ti", "ai", "yi", "b", "xi", "id", "info", "uri", "ix", "mu", "end"]}}
{"id1": "2518655", "id2": "10715601", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"fnOut": ["fnEx", "FNOutput", "fpIn", "fpOut", "FNOut", "fpOUT", "FNIn", "fnOUT", "fpFile", " fnIn", "fpOutput", "lsFile", "fpEx", " fnOUT", "lsOutput", "lsOut", "fnFile", " fnOutput", "FNEx", " fnFile", "fnOutput", "lsOUT", " fnEx", "fnIn"], "writer": ["temp", "riter", "usher", "entry", "writ", "war", "nw", "writers", "word", "inner", "ler", "winner", "walker", "layer", "outer", "fd", "Writer", "wa", "key", "driver", "er", "handler", "wire", "w", "out", "server", "work", "loader", "ws", "per", "director", "worker", "a", "editor", "widget", "wr", "socket", "reader", "output", "writing", "write", "r", "parser", "buffer", "builder", "file"], "i": ["iu", "hi", "si", "chi", "qi", "ip", "u", "multi", "n", "ii", "c", "k", "pi", "m", "o", "ini", "abi", "ci", "di", "io", "z", "key", "ji", "ui", "ri", "bi", "ie", "p", "strength", "part", "phi", "s", "j", "I", "fi", "x", "eni", "index", "f", "e", "oi", "li", "ori", "h", "v", "gi", "ti", "type", "mi", "ai", "b", "xi", "id", "uri", "ix"], "fInput": ["sfInput", "sfFormat", "fOutput", "finput", "fSource", " fSource", "sfOutput", "sfSource", " finput", "fileInput", "fFormat", "fileOutput", "sfinput", "fileSource", " fFormat", "fileFormat", " fOutput", "fileinput"], "in": ["In", "inas", "line", "scan", "again", "ini", "c", "n", "IN", "cin", "reading", "din", "inner", "bin", "input", "ner", "pin", "ins", "min", "conn", "inn", "kin", "isin", "init", "s", "rin", "lin", "out", "connection", "win", "gin", "f", "inside", "nin", "socket", "sin", "login", "reader", "data", "vin", "b", "inc", "id", "ln", "version"]}}
{"id1": "8665649", "id2": "22977189", "code1": "    private BufferedImage _getImage(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.connect();\n        InputStream in = null;\n        try {\n            in = conn.getInputStream();\n            return ImageIO.read(in);\n        } finally {\n            IOUtilities.close(in);\n        }\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 0, "substitutes": {"_getImage": ["_downloadimage", "_readThumbnail", "_readimage", "_getimage", "_parseThumbnail", "_downloadThumbnail", "_readImage", "_getImages", "_readImages", "_getThumbnail", "_parseimage", "_parseImage", "_downloadImages", "_downloadImage", "_parseImages"], "urlStr": ["imageSTR", "strText", "imageStr", "urlstr", "imageString", "strStr", " urlString", "urlText", "strstr", "urlSTR", "fileString", "strString", "urlSt", "imagestr", " urlSTR", " urlSt", "imageSt", "fileSt", "urlString", " urlstr", "fileSTR", "imageText", "fileStr", " urlText"], "url": ["resource", "ch", "c", "channel", "host", "blog", "http", "str", "www", "URL", "log", "ll", "path", "feed", "Url", "rl", "impl", "object", "user", "build", "loc", "browser", "l", "connection", "ls", "server", "config", "loader", "sl", "f", "image", "page", "ssl", "bb", "fl", "r", "b", "job", "web", "uri", "client", "org", "lc"], "conn": ["ch", "pc", "n", "c", "Connection", "act", "http", "Conn", "conv", "ci", "ctx", "con", "api", "open", "co", "rt", "sync", "ct", "impl", "client", "ad", "err", "connection", "cn", "out", "cp", "ls", "exec", "cmd", "cur", "enc", "cli", "h", "socket", "cb", "close", "ssl", "nt", "conf", "nc", "connect"], "in": ["In", "inas", "pc", "token", "again", "n", "c", "ini", "IN", "m", "rec", "cin", "ex", "is", "din", "inner", "bin", "input", "as", "fd", "con", "pin", "ins", "ac", "min", "inn", "err", "kin", "connection", "isin", "s", "win", "rin", "out", "init", "gin", "f", "gz", "i", "nin", "image", "socket", "login", "ssl", "reader", "data", "ax", "r", "null", "b", "inc", "id", "source", "stream"]}}
{"id1": "949327", "id2": "8079516", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"f": ["fa", "df", "folder", "fe", "ref", "fr", "F", "fc", "function", "of", "g", "c", "n", "m", "sf", "d", "fo", "fun", "fx", "self", "path", "fd", "io", "feed", "this", "cf", "fold", "fn", "p", "fs", "l", "ff", "tf", "s", "w", "j", "x", "fi", "flat", "e", "fm", "filename", "a", "h", "fp", "inf", "v", "fen", "r", "b", "bf", "t", "lf", "form", "name", "file", "rf"], "in": ["fe", "again", "serv", "g", "ini", "m", "cin", "ex", "with", "con", "inn", "p", "l", "isin", "w", "rin", "nin", "image", "socket", "v", "ssl", "gen", "t", "fa", "In", "or", "c", "rec", "d", "str", "bin", "ic", "pin", "connection", "init", "win", "login", "data", "n", "IN", "din", "ins", "ac", "min", "part", "lin", "get", "thin", "reader", "diff", "r", "lock", "pass", "token", "is", "inner", "input", "err", "it", "up", "exec", "gin", "config", "session", "a", "vin", "b", "inc", "source"], "cbuf": ["fbuff", "ebuf", "cfur", "zbuu", "rbull", "cbur", "cfuf", "cbuff", "bbuff", "bcuf", "rbuc", "cbutf", "fbbuf", "cfuff", "fbuc", "bcull", "fbuf", "bbull", "cbuc", "cburs", "cbault", "cfuc", "cbbuf", "cfbuf", "bcul", "rbuu", "rbul", "buf", "cbul", "bburs", "CBuc", "CBuff", "cbull", "bcuc", "CBul", "CBuf", "dbuf", "rbutf", "zbuf", "cbuu", "bcur", "bault", "rburs", "rbux", "ebuff", "ebutf", "zbutf", "rbuf", "zbuff", "cbux", "rbault", "rbbuf", "bbuf", "bcux", "ebuu", "dbuc", "dbur", "bux", "buff", "bcault", "dbuff", "rbuff", "bcurs", "bcuff"], "read": ["each", " Read", "use", "draw", "full", "g", "want", "call", "view", "log", "ak", "count", "build", "valid", "oct", "w", "orig", "ink", "q", "start", "check", "socket", "val", "error", "write", "sleep", "text", "y", "select", "d", "report", "lex", "io", " reading", "feed", "add", "only", "hex", "length", "repeat", "play", "pe", "find", "x", "wait", "iter", "allow", "used", "record", "last", "data", "en", "stream", "connect", "cel", "re", "end", "reads", "send", "know", "old", "open", "sync", "skip", "num", "ed", "seek", "ing", "er", "print", "insert", "rc", "get", "load", "work", "size", "index", "ok", "level", "reader", "type", "parse", "raw", "r", "id", "loop", "name", "ize", "pass", "run", "k", "readable", " write", "reading", "fill", "input", "READ", "key", "bit", " READ", "child", "ack", "Read", "it", "config", "ind", "bind", "un", "close", "ride", "change", "se", "put", "inc", "buffer", "update", "create"], "totRead": ["totoRead", "totaRead", " totBuild", "TottRead", "tottLength", "TottLoad", "dotReader", "towWrite", " totWrite", "totClose", "tetRead", "dottWrite", "totoReading", "dotUse", "tobyUse", "tazonClose", "totLoad", " totalBuild", "TottWrite", "tottedRead", "tochWrite", "toyRead", "tcotRead", "TotaDraw", "tottDraw", "ntottReader", "toyLoad", "totiRead", "totalLink", "tottAccept", "nottWrite", "tottBuild", "dottReader", "tcotClose", "tollWrite", "totReader", "TottConnect", "totaBuild", "tochLoad", "totaDraw", "totoSearch", "ntottLoad", "tntLoad", "TotReading", "totConnect", "tochRead", "totReading", "totiLink", "intotRead", "tobyRead", "intotLoad", "TottGet", "tollReading", " totLink", "nottAccept", "tetLoad", "totSearch", "tollRead", "totingFollow", "tottedGet", "tottFollow", "totoWrite", "TottReader", "tobyLoad", "TottReading", "totaLoad", "tntReader", "tobyFind", "intottLoad", "totBuild", "tetWrite", "TotGet", "TotLoad", "toyWrite", "dottLoad", "totaWrite", "totalWrite", "totalBuild", "totoLength", "totWrite", "notRead", "tottReading", "tottSearch", "octotLength", "totingSearch", "totingGet", "towReading", "TotConnect", "totingRead", "intottClose", "tcotBuild", "TotaRead", "dotReading", "TotSearch", "totLength", "tottedFollow", "totaReading", "tottWrite", "notAccept", "totiWrite", "dottFind", "tottRead", "totUse", "totoLoad", "totaLink", "totoConnect", "tochReader", "tatRead", "intottBuild", "TotWrite", "tetReading", "tottLoad", "totaReader", "totoFind", "tazonLoad", "TotaWrite", "TotRead", "octotoWrite", "tottFind", "totiBuild", "octotReading", "tottClose", "dotLoad", "TotaLoad", "towLength", "tatReader", "ntotWrite", "dottRead", "ntotReader", "totGet", "octotoRead", "towAccept", "octotWrite", "toyDraw", "TotFollow", "tntRead", "tatLoad", "tottGet", "dotRead", "totFind", "totingWrite", "tottReader", "dotWrite", "TottSearch", "totingConnect", "nottRead", "totAccept", "intottRead", "TotDraw", "ntottWrite", "towLoad", "tottUse", "ntotRead", "tottedWrite", "TotReader", "dottUse", "octotoReading", "totDraw", "towRead", "totalRead", " totalRead", "intotClose", "intotBuild", "tazonBuild", "ntottRead", "dotFind", "tatWrite", "dottReading", "tntWrite", "totLink", "totalLoad", "TottFollow", "totoUse", "octotoLength", "octotRead", "tcotLoad", " totalLink", "tazonRead", "notLoad", "ntotLoad", "totalAccept", "tollLoad", "notWrite", " totalWrite", "totFollow", "tottConnect", "nottLoad"], "out": ["In", "plus", "again", "n", "c", "g", "o", "ex", "exp", "d", "bin", "Out", "outer", "io", "outs", "sync", "ac", "conn", "fn", "p", "err", "up", "l", "part", "w", "s", "net", "init", "connection", "exec", "x", "off", "a", "h", "writer", "socket", "v", "ext", "output", "obj", "OUT", "r", "b", "t", "inc", "conf", "parent", "client", "file"], "i": ["hi", "ini", "ii", "g", "m", "current", "ci", "z", "bi", "my", "p", "l", "phi", "eni", "q", "start", "gi", "v", "ai", "yi", "uri", "iu", "c", "y", "o", "d", "ic", "io", "slice", "ji", "length", "init", "fi", "x", "ori", "ni", "ti", "data", "mi", "ik", "one", "chi", "multi", "pi", "abi", "di", "ei", "ie", "j", "I", "index", "oi", "li", "h", "r", "zi", "xi", "id", "name", "si", "qi", "ip", "u", "k", "ix", "is", "input", "api", "key", "ui", "ri", "it", "e", "ind", "b", "info", "buffer", "source", "me"]}}
{"id1": "5551393", "id2": "4938100", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"getMD5": ["getMD256", " getM4", " getMD256", " getM5", "getMD512", "getmd256", "getSHA5", " getM512", " getMD4", " getMD512", "getM256", "getmd5", "getM4", "getM512", "getMD4", "getM5", "getSHA256", "getmd4", " getM256", "getmd512", "getSHA512", "getSHA4"], "source": ["resource", "temp", "seed", "string", "Source", "sm", "proxy", "service", "input", "ource", "slice", "dest", "length", "content", "object", "address", "unit", "base", "expected", "security", "url", "config", "size", "code", "SOURCE", "start", "bytes", "result", "output", "secure", "data", "style", "target", "message", "info", "buffer", "text", "src", "name", "file", "template"], "tmp": ["txt", "temp", "mp", "cmp", "zip", "cache", "current", "py", "stuff", "cpp", "copy", "params", "ignore", "buf", "dest", "meta", "vm", "default", "part", "storage", "array", "foo", "sb", "code", "emp", "var", "fp", "cb", "result", "html", "test", "output", "nm", "data", "Temp", "obj", "b", "metadata", "bf", "tt", "binary", "buffer", "body", "src", "rb", "vt"], "md": ["mb", "mg", "mp", "pd", "ms", "pm", "od", "mand", "cm", "mac", "rm", "m", "zip", " MD", "d", "mmm", "di", "MD", "bd", "meta", "wd", "hd", "ad", "dd", "ld", "mc", "cd", "mod", "cmd", "mn", "mag", "ma", "nd", "oda", "ind", "gd", "dm", "editor", "nm", "amd", "mi", "rpm", "sd", "mm", "vd", "bf", "mad", "mt", "mu", "mo"]}}
{"id1": "13666876", "id2": "18211588", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"transformSingleFile": [" transformSingleFiles", "transformSinglePath", "transformMultifile", "transformOneSourceFile", "transformsingleSourceFile", "transformMultiFile", "transform1Path", "transformOneFile", "transformOnePath", "transformMultiFiles", " transformSingleSourceFile", " transformOneSourceFile", "transformMultiSourceFile", "transformSingleFiles", " transformSinglefile", "transformSinglefile", " transformOneFile", "transformsingleFile", "transform1Files", "transform1SourceFile", "transformOneFiles", "transformSingleSourceFile", "transform1File", "transformsingleFiles", " transformOnefile", "transformsinglefile", " transformSinglePath", " transformOnePath", "transformOnefile", " transformOneFiles"], "xed": [" xedited", "rexed", "xted", " Xed", " xED", "xED", "xteds", "rexeded", "xxeds", "xedited", "exEd", "xtEd", "exeb", "Xended", "xended", "exeds", "xxed", " xended", "xEd", "xxeded", "xeds", "exeded", "Xed", "rexED", "exed", "Xeded", "xxedited", "exED", "xxeb", " Xeds", "Xedited", "xxED", " Xeded", " xEd", " xeds", " xeded", "xtED", "xxended", "xeded", "xeb", " Xeb", "rexeds"], "node": ["slave", "row", "root", "live", "route", "day", "instance", "op", "option", "Node", "copy", "path", "shape", "none", "tree", "object", "child", "no", "loc", "document", "part", "event", "query", "component", "load", "location", "config", "index", "set", "image", "page", "error", "menu", "message", "parent", "source", "ode", "leaf", "name", "file", "edge"], "dob": ["dub", " dOb", "adod", "ddod", "ddOb", "ddob", "dOB", "adub", "DOb", " dub", "dOb", "adOB", "ddOB", "Dub", " dOB", "Dob", "adob", "DOB", " dod", "ddub", "dod"], "mySrc": ["MyAsrc", "mysRC", "mysrb", " mySst", "mySst", " myEsst", "myAssrc", "myAsrb", "myAsRC", "myEssrc", " myEsrc", "MySRC", " myEssrc", "MySrc", "mySRC", "MyEsRC", "MyEsrb", " myEsRC", "myDrc", "MyAsource", "MySource", "myDsource", "MyEsrc", " mySsrc", "myDst", "myDsrc", "myEsrb", "myAsst", "myAsrc", "myEsource", "myssrc", "mySrb", "MyEssrc", "myEsrc", " mySRC", "mySsrc", "myDssrc", "MyAssrc", "mysrc", "myEsst", "MySsrc", "myEsRC", "MyAsRC", "myAsource", "myDRC", "mySource", "myDsRC", "MySrb"], "mySrcF": ["myCrcM", "mySourceE", "mySRCM", "myCrcF", "myEssrcFile", "myCrcE", "myEsrcf", "myCRCF", "mySourceF", "mySrcf", "myCRCE", "myCRCf", "myCRCM", "mySsrcf", "mySRCE", "mySrcFile", "myEssrcF", "mySckM", "myCrcf", "mySourceFile", "mySsrcFile", "mySourcef", "myEssrcE", "mySRCFile", "myEsrcE", "mySsrcF", "myEsrcF", "mySRCf", "myEsrcFile", "mySrcM", "mySckE", "mySrcE", "mySsrcE", "myEssrcf", "mySckF", "mySsrcM", "mySckf", "mySRCF"], "myOutF": [" myOutputC", "myoutFF", "MyInQ", "myoutFile", "myoutF", "myOutFile", "MyInPF", " myOutC", "myInD", "MyInF", "myOUTF", "myInQ", "MyOutD", "myOutE", "myOUTFF", "myOutPF", "myInPF", "myOutFF", "MyOutFile", "myOutputFile", "myInF", "MyOutPF", "myOutC", "myOutD", "MyOutQ", " myOutE", "myOutQ", "myOUTD", "myoutPF", "myOutputC", " myOutFile", "MyInFile", "myOUTFile", "myInC", "myOutputF", " myOutputFile", "myInE", "myoutE", "MyOutE", "myOUTQ", " myOutputF", " myOutputE", "myoutC", "myOUTE", "myInFF", "MyInD", "myOUTPF", "MyInE", "MyOutF", "myInFile", "MyOutFF", "myOutputE", "MyInFF"], "co": ["che", "fe", "cho", "ctrl", "pc", "fc", "cmp", "gro", "so", "ob", "c", "oe", "cache", "ca", "o", "ko", "fo", "ee", "cca", "ci", "con", "can", "colo", "la", "flo", "cf", "OO", "cu", "CO", " Co", "ce", "no", "loc", "CC", "cc", "ico", "mc", "BO", "rc", "pe", "coll", "cur", "cos", "bc", "company", "isco", "code", "bo", "auto", "cb", "lo", "bb", " CO", "po", "oo", "Co", "coe", "conf", "aco", "ck", "mo", "lc"], "x3dvFile": ["x3dvSource", "x3rdVFiles", "x3rdVfile", "x3dvsFiles", "x3dsvSource", "x3ndvFiles", "x3ndvFile", "x3dfFile", "x3dvsfile", "x3dvFiles", "x3dvfile", "x3dVPage", "x3dVSource", "x3rdVFile", "x3dfFiles", "x3dvsFile", "x3dsvfile", "x3ndsvFile", "x3rdvFiles", "x3ndsvSource", "x3ndvfile", "x3dsvFile", "x3dfSource", "x3rdvfile", "x3dffile", "x3dsvPage", "x3rdvPage", "x3rdVPage", "x3ndsvFiles", "x3dVFiles", "x3dvsPage", "x3ndvSource", "x3ndsvfile", "x3dsvFiles", "x3dVFile", "x3dVfile", "x3dvPage", "x3rdvFile"], "fis": ["elfisa", "refiss", "fus", " fs", "elfus", "refi", " fiss", "elfbs", "Fs", "fs", "Fus", "refisa", "refis", "fbs", " fi", "elfi", "fi", "elfs", " fus", "fisa", "elfis", "elfiss", "Fis", " fbs", "Fbs", "fiss", " fisa"], "gzos": ["wxo", "bagops", "zipo", "zxops", "bagOS", "gzops", "gzo", "zxOS", "bagos", "bagis", "bago", "zipos", "zipis", "wxis", "zxis", "gzOS", "zxos", "zxo", "zo", "zipops", "zops", "wxos", "zis", "zos", "wxOS", "zipOS", "zOS", "gzis"], "buf": ["done", "bh", "grab", "vec", "cas", "cv", "bin", "bd", "box", "queue", "la", "pad", "seq", "loc", "fab", "batch", "br", "bag", "ff", "uint", "lb", "port", "cur", "bc", "block", "len", "av", "uf", "cap", "uc", "bytes", "cb", "result", "data", "feat", "Buff", "b", "fb", "buff", "ba", "bf", "buffer", "ab", "rb", "db", "dec"], "ret": ["det", "rep", "ry", "reply", "fin", "fun", "continue", "ft", "match", "rt", "bit", " RET", "num", "rf", "count", "default", "rc", "out", "rets", "reg", "f", "len", "success", "pet", "val", "res", "result", "nt", "repl", "att", "obj", "alt", "r", "b", "en", "bf", "id", "Ret", "ver", "RET", "re", "ref"]}}
{"id1": "11475527", "id2": "807346", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "label": 1, "substitutes": {"addDataFromURL": ["addDatafromFile", "addDataWithFile", "addDataForUrl", "addTextfromurl", "addTextfromFile", "addDataForFile", "addTextfromUrl", "addDatafromURL", "addDataFromUrl", "addDataForURL", "addDataForurl", "addDataWithURL", "addTextFromURL", "addDataWithUrl", "addTextFromUrl", "addDataWithurl", "addDatafromUrl", "addTextFromurl", "addDatafromurl", "addDataFromFile", "addTextFromFile", "addDataFromurl", "addTextfromURL"], "theurl": [" thelog", "thereurl", "theuri", "thelog", "youurl", " thepublic", " theUrl", " TheURL", "thepublic", "youUrl", "testURL", "youURL", "youlog", "thereURL", " theuri", " Theurl", "theURL", " TheUrl", "theUrl", "pythonURL", "testUrl", " theURL", "myURL", "thereuri", "myurl", "myUrl", "testurl", "testlog", "pythonuri", "pythonurl", " Thepublic", "mypublic"], "line": ["entry", "row", "pass", "string", "lines", "LINE", "ine", "str", "comment", "character", "le", "Line", "log", "feed", "key", "number", "char", "sync", "object", "no", "letter", "unit", "l", "part", "connection", "base", "cl", "lin", "out", "pe", "cell", "model", "url", "f", "link", "code", "len", "i", "nl", "li", "el", "reader", "write", "style", "id", "source", "buffer", "text", "block", "name", "file"], "in": ["fa", "In", "or", "pass", "again", "serv", "ini", "oin", "IN", "m", "cin", "is", "din", "inner", "bin", "fin", "input", "io", "pin", "ins", "conn", "inn", "it", "err", "l", "isin", "init", "s", "win", "lin", "out", "rin", "url", "read", "inside", "i", "nin", "a", "image", "socket", "record", "login", "arin", "reader", "r", "b", "inc", "info", "source", "stream", "client", "file"], "data": ["entry", "plus", "lines", "o", "dat", "d", "inner", "input", "da", "di", "open", "this", "la", "conn", "er", "handler", "default", "l", "connection", "up", "out", "url", "DATA", "like", "f", "iter", "i", "start", "writer", "result", "next", "reader", "output", "r", "ata", "info", "buffer", "stream", "source", "body", "one", "file", "end"], "e": ["eu", "fe", "or", "je", "oe", "o", "ee", "ge", "be", "ue", "ale", "ke", "ce", "er", "ie", "err", "ef", "eme", "ea", "ception", "pe", "element", "event", "ade", "exc", "f", "E", "ele", "ep", "ede", "ze", "ne", "ae", "error", "se", "ev", "en", "de", "ec", "es", "me", "ace", "et", "one", "ise", "edge"]}}
{"id1": "22264586", "id2": "7499186", "code1": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"copyFiles": ["clonePages", "cloneFile", "transferFile", "CopyChildren", "Copyfiles", "clonefiles", "copyFile", "CopyFiles", " copyfiles", "copyPages", "transferChildren", "transferPages", "transferFiles", " copyPages", "copyChildren", " copyChildren", "cloneFiles", "transferfiles", " copyFile", "CopyFile", "copyfiles"], "strPath": ["stFile", " strpath", "strName", "striFile", "stPath", " strName", "strFile", "striLog", "STRpath", "StrLog", "STRLog", "stName", "stripath", "striPath", "strpath", "StrFile", "stpath", "strLog", "Strpath", "STRFile", "StrName", "StrPath", "STRPath", " strFile"], "dstPath": ["dstsFile", "dblpath", "dstFile", "ddestDir", "drcpath", "dndPath", "fstsDir", "sdndPath", "dblFile", "sdstName", "drcDir", "sdndName", "ddestFile", "dstName", "drcName", "sdndpath", "fstPath", "sdndDir", "sdstPath", "dstDir", "dblPath", "dndDir", "dndpath", "ddestName", "sdstDir", "fstspath", "dstspath", "drcPath", "dblDir", "dstpath", "dndName", "sdstpath", "fstsPath", "fstFile", "fstsFile", "fstDir", "ddestPath", "dstsPath", "ddestpath", "dstsDir", "fstpath"], "src": ["txt", "cmp", "project", "obl", "front", "host", "Source", "ruby", "dist", "scripts", "self", "input", "ource", "path", "inst", "ctx", "sc", "slice", "this", "sys", "in", "sync", "client", "download", "loc", "sup", "s", "rc", "rob", "ls", "reverse", "upload", "tmp", "cur", "url", "config", "sb", "sl", "back", "SOURCE", "split", "sin", "cb", "RC", "img", "st", "ssl", "secure", "ources", "sub", "rs", "source", "stream", "sel", "sit", "rb", "iv", "sq", "sort"], "dest": ["dc", "folder", "cdn", "txt", "done", "slave", "temp", "wh", "cat", "project", "front", "zip", "rest", "later", "dat", "dist", "d", "destroy", " Dest", "desc", "di", "wd", "div", "sup", "dd", "comb", "trans", "default", "out", "tmp", "delete", "du", "thin", "flat", "des", "ds", "home", "gd", "Dest", "result", "img", "secure", "test", "style", "target", "prop", "de", "source", "wb", "dep", "db"], "list": ["status", "full", "map", "dl", "ll", "none", "files", "pair", "members", "dir", "p", "l", "s", "delete", "url", "like", "val", "stat", "filter", "write", "lists", "parent", "version", "lc", "names", "entry", "lines", "str", "la", "LIST", "bl", "cl", "strings", "keys", "code", "data", "null", "stream", "sort", "www", "listed", "queue", "part", "all", "ls", "coll", "arr", "load", "size", "array", "set", "diff", "type", "stack", "id", "cont", "name", "group", "run", "string", "parents", "is", "remove", "path", "key", "json", "batch", "base", "chain", "config", "read", "split", "test", "info", "source"], "i": ["hi", "si", "qi", "ip", "u", "multi", "n", "ii", "c", "m", "pi", "o", "y", "abi", "ci", "di", "io", "key", "slice", "ji", "ui", "ri", "length", "me", "bi", "ie", "p", "part", "phi", "j", "I", "x", "index", "f", "e", "oi", "li", "a", "start", "gi", "v", "ti", "type", "ai", "data", "r", "b", "xi", "id", "info", "uri", "ix", "mu"], "dest1": ["srcOne", "sourceone", "Dest0", "Dest2", "dest0", "source2", "destOne", "DestOne", "homeone", "source0", "src2", "source1", "src0", "dest2", " destone", "sourceOne", "destone", "home1", "Dest1"], "src1": ["srcOne", "sourceone", "rc1", "source2", " src2", "rcOne", "src2", "rcone", "source1", " srcone", " srcOne", "sourceOne", "rc2", "srcone"], "sourceChannel": ["srcChan", "SourceStream", "ourceChan", "Sourcechannel", "sourceContext", "SourceContext", "targetChan", "ourceStream", " sourcechannel", "SourceChan", "srcStream", "srcContext", " sourceChan", "sourcechannel", "SourceChannel", "ourceChannel", "targetContext", "targetchannel", "sourceStream", "srcChannel", " sourceStream", "sourceChan", "targetStream", " sourceContext", "ourceContext"], "targetChannel": ["TargetChannel", "destContext", "TargetContext", "TargetManager", " targetConnection", "sourceContext", "targetChan", "destChannel", " targetManager", "destConnection", "argetManager", " targetContext", "targetManager", "destChan", " targetChan", "argetChan", " targetchannel", "sourcechannel", "targetConnection", "Targetchannel", "argetChannel", "targetContext", "targetchannel", "argetchannel", "TargetConnection", "sourceChan", "TargetChan"]}}
{"id1": "20208819", "id2": "6517139", "code1": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "label": 1, "substitutes": {"hash": ["SHA", "string", "Hash", "str", "sum", "copy", "num", "build", " hashes", "print", " hashing", "get", "mix", "code", "dump", "format", "check", "output", "parse", "raw", "pack", "update", " Hash"], "input": ["temp", "plus", "accept", "seed", "string", "instance", "current", "context", "request", "str", "inner", "feed", "in", "length", "address", "audio", "upload", "url", "config", "array", "Input", "image", "inf", "output", "reader", "data", "addin", "raw", "null", "parent", "source", "buffer", "text", "binary", "form"], "algorithm": ["calgebra", "aligebra", "aligorithm", " alphabet", " algebra", "aligo", "Algorithm", "Algorith", "algorith", "calgorith", "alphabet", "calgo", "Algebra", " algo", "calgorithm", "algebra", " algorith", "aliphabet", "Alphabet", "algo", "Algo"], "dig": ["rg", "wrap", "fe", "grab", "cmp", "pm", "im", "g", "push", "prep", "and", "dat", "exp", "ex", "um", "d", "rand", "imag", "tool", "log", "Dig", "add", "cod", "pin", "num", "div", "alg", "build", "ag", "comb", "ld", "lab", "ng", "init", "cd", "dim", "rob", "mod", "del", "get", "mix", "enc", "sem", "test", "gen", "de", "sign", "rd", "grad", "me", "ig", "db", "dec"], "result": ["df", "group", "root", "ger", "function", "Result", "global", "string", "current", "results", "cover", "response", "sum", "report", "manager", "api", "match", "card", "this", "dest", "json", "length", "user", "our", "ret", "db", "up", "valid", "default", "future", "consumer", "url", "work", "array", "iter", "su", "value", "success", "format", "res", "record", "page", "output", "runner", "data", "test", "member", "counter", "diff", "null", "message", "buffer", "source", "master", "uri", "re", "builder"], "digest": ["bigest", "digse", "signEST", "signse", "bigested", " Digester", "bigester", " digests", "generEST", "Digester", " digse", "Digested", "signest", "digested", " digEST", "digester", "DigEST", " digester", " digested", "generest", " Dige", "signester", "dige", "generester", "digEST", " Digest", "bigests", "Digests", "digests", " DigEST", "Digest", "Dige", " dige", "Digse", "generests"], "hex": ["temp", "row", "ctr", "wh", "zip", "utf", "string", "zero", "rh", "ex", "shift", "pixel", "bin", "transform", "sum", "ticket", "char", "bit", "num", "length", "address", "header", "ph", "oct", "uint", "throw", "pex", "mix", "array", "index", "iter", "hess", "rex", "head", "sex", "cube", "xf", "h", "format", "check", "data", "digit", "null", "buff", "pattern", "text", "form"], "i": ["iu", "hi", "si", "qi", "multi", "n", "ii", "c", "pi", "o", "y", "d", "abi", "ci", "di", "io", "z", "ui", "ri", "bi", "p", "it", "l", "phi", "j", "I", "x", "uli", "index", "f", "e", "oi", "li", "a", "h", "v", "gi", "ti", "ai", "b", "xi", "t", "id", "info", "uri", "ix", "mu"], "u": ["iu", "bu", "us", "uu", "c", "string", "ru", "o", "d", "uid", "U", "ue", "ur", "yu", "char", "ui", "uv", "cu", "num", "mu", "sup", "p", "l", "up", "pu", "cur", "chu", "x", "du", "f", "fu", "e", "su", "q", "ul", "uf", "h", "hu", "uc", "v", "ou", "tu", "b", "back", "nu", "uri", "uni", "lu", "un"], "highCount": ["largeC", "hiCode", "lowCast", "lowSize", "higherCode", "highC", "HighC", "fullCast", "highercount", "highCode", "lowcount", "fullCount", "largeCode", "lowLength", "HighCount", "hiCount", "hiSize", "fullcount", "largeCount", "higherSize", "lowCode", "hiLength", "HighCode", "highLength", "HighSize", "highSize", "higherC", "higherCast", "higherCount", "largeSize", "highCast", "HighLength", "highcount"], "lowCount": ["lowerLength", "LowC", "lowerCount", "lowCast", "lowSize", "slowCount", "highC", "LowCast", "highSum", "lowerCast", "lowerSum", "lowLength", "lowerC", "slowLength", "LowCount", "slowSum", "highLength", "lowSum", "lowC", "highSize", "slowCast", "LowSize", "lowerSize", "highCast"]}}
{"id1": "21821404", "id2": "7118860", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "label": 1, "substitutes": {"getWebPage": ["parsewebpage", "getwebpages", "parsewebPage", "getVirtualPage", "getVirtualpages", "getwebpage", "getWebpage", "parseWebpages", "parsewebpages", "parseWebpage", "getVirtualpage", "parseWebPage", "getwebPage", "getWebpages"], "urlObj": [" urlObject", "URLobj", "resourceObject", "urlExt", "httpobj", "blogobj", "URLObject", "UrlObj", "Urlobj", "urlobj", " urlExt", "URLObj", " urlobj", "strobj", "strObject", "blogObj", "httpOb", "resourceobj", "resourceObj", "URLExt", " urlInst", "blogInst", " urlOb", "strObj", "strInst", "resourceExt", "UrlOb", "urlInst", "urlOb", "httpObj", "urlObject", "blogObject"], "content": ["resource", "online", "section", "clean", "string", "c", "css", "lines", "comment", "response", "core", "java", "continue", "report", "cont", "feed", "empty", "json", "object", "address", "header", "document", "out", "model", "server", "Content", "url", "load", "coll", "work", "array", "code", "value", "page", "result", "html", "output", "data", "write", "raw", "comments", "message", "source", "buffer", "text", "body", "file"], "is": ["il", "or", "isp", "ires", "us", "isa", "ip", "ios", "im", "ois", "isl", "est", "you", "rest", "site", "ir", "irc", "was", "iris", "as", "be", "io", "ais", "abs", "os", "IS", "ui", "cms", "in", "ins", "ri", "does", "ie", "it", "fs", "s", "Is", "out", "iss", "iso", "ar", "ops", "x", "its", "isi", "isc", "i", "any", "mis", "bis", "lis", "ser", "ai", "al", "nis", "r", "ps", "id", "es", "info", "stream", "ris", "ise", "problem"], "reader": ["or", "row", "actor", " Reader", "reading", "oder", "inner", "ler", "io", "ner", "driver", "in", "ri", "er", "handler", "bird", "ro", "l", "rc", "server", "x", "loader", "read", "Reader", "iter", "rer", "e", "director", "i", "worker", "h", "writer", "editor", "ser", "rr", "r", "parser", "rar", "buffer", "stream", "rx"], "line": ["item", "inline", "entry", "row", "pass", "section", "string", "col", "word", "lines", "ine", "LINE", "str", "character", "comment", "Line", " inline", "response", "char", "key", "object", "user", "cr", "cl", "l", "part", "connection", "lin", "cell", "out", "server", "url", "block", "link", "f", "code", "cle", "strip", "page", "data", "lf", "message", "buffer", "source", "text", "body", "column", "name", "file", "lc"]}}
{"id1": "12380475", "id2": "20924119", "code1": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"transport": ["ransport", "transpoint", "transports", "protprocess", "ranspoint", "protmission", "transmission", " transmission", "transporter", "protport", "ransprocess", " transports", "protports", " transporter", "ransmission", "transprocess", " transpoint", "protporter", "ransporter", "ransports", "protpoint", " transprocess"], "file": ["File", "resource", "folder", "entry", "local", "route", "class", "use", "line", "project", "full", "string", "channel", "cache", "http", "comment", "service", "path", "log", "io", "queue", "content", "object", "dir", "user", "ile", "handler", "single", "connection", "document", "base", "out", "model", "server", "url", "f", "FILE", "e", "filename", "image", "auto", "socket", "fp", "handle", "page", "change", "directory", "reader", "data", "type", "parent", "source", "stream", "info", "name", "db"], "files": ["pages", "ups", "names", "boxes", "views", "classes", "books", "bs", "lines", "sites", "results", "headers", "images", "objects", "ins", "events", "ums", "dir", "fs", "facts", "s", "cells", "ls", "balls", "keys", "f", "ions", "blocks", "thumbnails", "phones", "features", "flows", "items", "Files", "iles", "users", "issues", "pes", "models"], "i": ["hi", "si", "chi", "ip", "u", "multi", "n", "ii", "c", "k", "pi", "col", "o", "ini", "m", "d", "abi", "ci", "di", "io", "key", "slice", "vi", "ui", "ri", "p", "it", "j", "I", "x", "index", "f", "e", "oi", "li", "h", "ni", "v", "ti", "mi", "ai", "b", "xi", "id", "info", "uri", "end"], "inChannel": [" inchannel", "outchannel", "inputChannel", "inputStream", " inMessage", " inStream", "InChan", "inCh", "inputCh", "inchannel", "outMessage", "inStream", "InMessage", "outStream", "inChan", "InFile", "inFile", "inMessage", " inFile", " inCh", "outFile", "inputChan", "InStream", "InCh", "InChannel", " inChan", "Inchannel"], "outChannel": [" outChan", "OutStream", "outchannel", "ioChan", "OutChannel", " outHandler", "Outchannel", "inchannel", "ioChannel", "inStream", "inHandler", "outStream", " outConnection", "ioHandler", "inChan", "outChan", "OutChan", "ioConnection", "inConnection", " outchannel", "outConnection", " outStream", "outHandler"]}}
{"id1": "4938100", "id2": "18631594", "code1": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "label": 1, "substitutes": {"sha1": ["sha256", "hash64", "hash1", " SHA64", "hashOne", "shaOne", " SHA1", "hash256", " SHAOne", "SHAOne", " SHA256", "SHA64", "sha64", "SHA1", "SHA256"], "text": ["struct", "txt", "font", "class", "token", "Text", "string", "word", "secret", "str", "version", "input", "EXT", "path", "hex", "number", " Text", "this", "key", "content", "object", "letter", "translation", " TEXT", "connection", "url", "contract", "config", "code", "value", "password", "image", "format", "bytes", "TEXT", "editor", "ext", "test", "output", "data", "message", "pattern", "source", "name", "template"], "UnsupportedEncodingException": ["UnsupportedEncoderception", "UnsupportedEncodedException", "UnsupportedEncoderEx", "UnsupportedEncodedception", "UnsupportedEncasingEx", "UnsupportedEncodedEx", "UnsupportedEncasingception", "UnsupportedEncodingception", "UnsupportedEncasingException", "UnsupportedEncoderException", "UnsupportedEncodingEx"], "md": ["df", "mb", "mg", "mp", "pd", "ms", "pm", "od", "mand", "rm", "mac", "map", "m", "Cmd", "sm", " MD", "d", "sha", "di", "MD", "bd", "meta", "wd", "mode", "hd", "ad", "dd", "valid", "mc", "ld", "cd", "mod", "cmd", "mn", "ma", "mag", "code", "am", "gd", "ind", "hash", "dm", "editor", "nm", "amd", "data", "dig", "mm", "metadata", "bf", "vd", "message", "mad", "mt", "me", "body", "mo"], "sha1hash": ["wa3sum", "sha3sum", "SHA1hash", "sha2address", "sha41hash", "sha1dash", "SHA1sum", "sha1hex", "wa1sum", "SHA2Hash", "sha41sum", "sha001hash", "SHA1address", "sha2sum", "sha5sum", "sha91hash", "SHA2sha", "SHA1sha", "sha4sum", "wa3dash", "sha4hex", "sha1Hash", "sha5hash", "sha3hash", "sha256sum", "SHA2check", "wa3hash", "sha1sum", "sha41address", "SHA1check", "sha2sha", "sha256hash", "wa3hex", "sha41check", "SHA1Hash", "sha1check", "sha256sha", "sha3dash", "sha5Hash", "sha001sum", "sha91address", "SHA2sum", "sha2check", "sha1address", "sha4hash", "sha4dash", "sha2Hash", "wa1dash", "sha91sum", "sha256Hash", "sha3hex", "sha91check", "sha001dash", "sha2hash", "wa1hash", "SHA2hash", "sha5sha", "wa1hex", "sha001hex", "sha1sha", "SHA2address"]}}
{"id1": "10795866", "id2": "812803", "code1": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"upload": [" transform", "paste", "run", "full", "zip", "clean", "view", "transform", "report", "open", "process", "post", "download", " Upload", "up", "url", "delete", "load", "Upload", "dump", "image", "transfer", "save", "output", "info", "stream", " thumbnail", "create"], "destDir": ["destPath", "distdir", "srcDir", " destDirectory", "DestDirectory", "destFile", "DestPath", "destDIR", "srcDirectory", "Destdir", "destdir", "DestFile", "destDirectory", "distDIR", "srcFile", "DestDir", "distDir", "srcPath", "srcDIR", "srcdir", "distFile", " destdir", "DestDIR", " destPath"], "fos": ["Foses", "lOS", "sfis", "fo", " fOS", " foses", "fdos", "fios", "nows", "foos", "paos", "fdios", "no", "fdOS", "faos", " fios", " fo", "nos", "pos", "los", "foows", "noss", "fOS", " fows", "foo", " foser", "fdoser", "foses", " fis", "Fos", " faos", "fis", "lo", "FOS", "Fios", "Faos", "lis", "fooss", " foss", "sfo", "sfOS", "Fo", "fows", "po", "foss", "poses", "Foser", "sfos", "foser"]}}
{"id1": "21921000", "id2": "411595", "code1": "    @Override\n    public void parse() throws IOException {\n        URL url = new URL((new DataUrlResolver()).getDataUrl(DomainName.CROATIA));\n        URLConnection con = url.openConnection();\n        BufferedReader bStream = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String str;\n        bStream.readLine();\n        while ((str = bStream.readLine()) != null) {\n            String[] tokens = str.split(\"(\\\\s+)\");\n            String charCode = tokens[0].replaceAll(\"([0-9+])\", \"\");\n            Float value = Float.parseFloat(tokens[2].trim().replace(\",\", \".\"));\n            CurrencyUnit unit = new CurrencyUnit(charCode, value, DEFAULT_MULTIPLIER);\n            this.set.add(unit);\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 0, "substitutes": {"parse": ["ize", " discover", "run", "execute", " parsed", " setup", " feed", "process", "add", "construct", "build", "print", " load", "init", " parsing", " parser", "Parser", "load", " analyse", "next", " convert", " init", " analyze", "parser", "end"], "url": ["resource", "zip", "string", "host", "http", "service", "www", "URL", "log", "path", "ur", "open", "this", "Url", "conn", "user", "address", "l", "connection", "base", "ls", "server", "sl", "f", "ssl", "bb", "data", "b", "web", "uri", "source", "client", "org", "file"], "con": ["fa", "resource", "pc", "fc", "n", "c", "Connection", "channel", "ca", "http", "cons", "Conn", "ann", "func", "conv", "log", "ctx", "can", "open", "sync", "in", "client", "conn", "cr", "connection", "cn", "out", "exec", "coll", "bc", "f", "CON", "Con", "pub", "connect", "un", "socket", "plain", "close", "login", "r", "b", "conf", " conn", "com", "file"], "bStream": [" bReader", "bConnection", "rbFile", "bReader", "aStream", "bsW", "bbReader", "aFile", "bbW", "rbReader", "rbstream", " bFile", "bbstream", " bstream", "aReader", "aRead", "bFile", "bsConnection", "bbConnection", "rbStream", "bbStream", " bW", "bW", " bRead", "bbRead", " bConnection", "bstream", "astream", "bsstream", "bRead", "bsStream"], "str": ["fr", "status", "pass", "stri", "line", "kr", "n", "string", "c", "pr", "step", "spec", "input", "char", "key", "sr", "in", "doc", "STR", "div", "tr", "er", "p", "br", "err", "cr", "l", "part", "s", "coll", "arr", "sp", "cur", "sl", "f", "enc", "i", "strip", "res", "result", "st", "data", "obj", "r", "id", "Str", "text", "name", "dec"], "tokens": ["pokents", "Tokicks", "token", "tokes", "pokets", "tractens", "Takents", "Token", "Tokes", "Tokets", "Tokens", "takos", "taks", "Takets", "poks", "tarses", "Tokents", "tops", "tokenets", "Tokos", "tokenen", "tarsens", "toksos", "tokicks", "Taken", "pokens", "pokenents", "Takes", "tokenicks", "tractents", "tarsen", "pokenets", "takicks", "topets", "tokets", "tokents", "topents", "toksets", "tarsicks", "topens", "tractos", "takets", "toksens", "pokenens", "Takos", "Takicks", "takes", "takens", "taken", "toksents", "toks", "takents", "Takens", "tokenents", "tractets", "tokenes", "tokos", "tokenens"], "charCode": ["CharNumber", " charNumber", "CharCount", " charType", "charactercode", "CharType", "characterNumber", "charName", "charNumber", " charName", "Charcode", " charcode", "characterCount", "CharName", "characterType", "characterName", "charcode", " charCount", "charType", "charCount", "CharCode", "characterCode"], "value": ["entry", "fe", "amount", "function", "string", "current", "volume", "values", "money", "key", "number", "flo", "num", "object", "weight", "count", "grade", "default", "scale", "base", "rate", "element", "dollar", "price", "size", "name", "Value", "format", "val", "v", "result", "range", "VALUE", "data", "type", "version", "flow"], "unit": ["item", "class", "u", "position", "string", "instance", "option", "union", "currency", "Unit", "number", "num", "letter", "it", "scale", "base", "rate", "out", "element", "component", "size", "category", "units", "factor", "format", "split", "output", "type", "data", "term", "point", "target", "uni", "version", "un", "flow"]}}
{"id1": "947406", "id2": "18793482", "code1": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["Cop", "paste", "cop", "cmp", "cat", "zip", "log", "Copy", "sync", "download", "p", "it", " Copy", "csv", "replace", " transfer", "cp", "clone", "get", "dump", " cp", "split", "transfer", "clip", "write", "put", "file"], "src": ["resource", "txt", "bh", "js", "use", "string", "href", "dist", "stab", "input", "ource", "inst", "sc", "ins", "files", "fn", "loc", "gb", "s", "rc", "rob", "url", "cur", "config", "name", "sl", "sb", "filename", "sin", "img", "data", "id", "sub", "rs", "source", "stream", "uri", "sel", "rb", "sit", "sq"], "dest": ["folder", "txt", "temp", "done", "class", "rest", "dat", "opt", "d", "dist", "bin", "destroy", " Dest", "desc", "die", "wd", "dir", "sup", "comb", "orig", "replace", "tmp", "delete", "thin", "flat", "des", "home", "Dest", "result", "img", "output", "st", "test", "obj", "target", "prop", "de", "source", "const", "wb", "name", "later"], "in": ["In", "pull", "pass", "issue", "again", "ini", "IN", "m", "cin", "is", "inner", "din", "bin", "input", "as", "con", "this", "pin", "ins", "cf", "download", "conn", "inn", "err", "kin", "trans", "up", "it", "isin", "init", "s", "base", "win", "rin", "lin", "url", "work", "gin", "thin", "i", "nin", "a", "lib", "socket", "login", "reader", "diff", "data", "vin", "r", "b", "inc", "id", "info", "source", "lock"], "out": ["timeout", "or", "exit", "again", "at", "cache", "o", "ex", "exp", "call", "inner", "bin", "Out", "log", "outer", "io", "outs", "os", "this", "sync", "aos", "conn", "no", "user", "our", "err", "up", "app", "part", "net", "w", "init", "exec", "x", "index", "pool", "off", "nin", "image", "lib", "socket", "writer", "plain", "ext", "img", "output", "ou", "data", "write", "obj", "OUT", "vert", "inc", "id", "source", "client", "one", "file"], "buf": ["bh", "nb", "c", "cv", "bin", "fd", "ctx", "bd", "box", "queue", "pad", "bn", "num", "seq", "ab", "bp", "count", "loc", "batch", "p", "br", "bag", "ff", "fab", "orig", "pos", "rc", "cur", "bc", "f", "block", "len", "off", "uf", "cap", "uc", "bytes", "cb", "v", "result", "data", "raw", "feat", "fl", "b", "bf", "buff", "fb", "buffer", "rb", "ref"], "n": ["nb", "u", "N", "c", "k", "m", "o", "d", "na", "dn", "z", "number", "nn", "num", "length", "no", "nr", "count", "p", "l", "ng", "w", "j", "max", "sn", "x", "size", "index", "f", "nd", "len", "ns", "i", "ind", "nin", "rn", "v", "ne", "nt", "write", "b", "en", "t", "nc", "un"]}}
{"id1": "12454178", "id2": "5551393", "code1": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "code2": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "label": 0, "substitutes": {"alterar": [" cryaran", " cultivaran", " creAr", " cryAr", " crea", " celebrAr", " celebra", " cultivAr", " cultiva", " celebrar", " celebraran", " crear", " cultivar", " crearan", " crya", " cryar"], "t": ["xt", "det", "wt", "at", "u", "n", "c", "you", "m", "o", "table", "te", "y", "d", "tw", "tool", "tools", "pt", "rt", "tree", "this", "in", "the", "let", "tr", "tp", "p", "bolt", "trans", "it", "l", "tf", "s", "qt", "ta", "ant", "x", "dt", "ot", "ut", "f", "flat", "e", "i", "unt", " mt", "to", "v", "ts", "nt", "att", "type", "st", "ti", "target", "tt", "T", "tm", "et", "tc", "tower", "template"], "stmt": ["istau", "stmd", "tpt", "ctmb", "stbm", "tmr", "strmt", "swmt", "istdb", "Stau", "formmm", "formrm", " stmm", "ustnt", "stgr", "Stmb", "smr", "istmt", " stgr", " stpt", "strdb", " stdb", "stpt", "Stmt", "strm", " stv", "putnt", "swmd", "stv", " stmb", "sdb", " stmn", "Stmd", "stct", " stbm", " stct", "stnt", "Stmm", " stnt", "tmt", "strmn", "stmr", "Stct", "spt", "swau", "Strm", "Stgr", " stau", "stmb", "ctgr", " stmd", "istmn", "formmt", "tdb", "putau", "ustmt", "ctct", "stmn", "stmm", " stmr", "ctmt", " strm", "putmt", "ustau", "swbm", "Stv", "strau", "smt", "Stbm", "formv", "stdb", "stau", "ustmd", "putmd"], "sql": ["lambda", "seed", "serv", "zip", "string", "pr", "statement", " SQL", "limit", "expression", "dl", "log", "params", "sol", "details", "database", "printf", "conn", "insert", "up", "s", "base", "setup", "ls", "cmd", "shell", "query", "QL", "url", "where", "sl", "q", "plan", "stat", "result", "ql", "job", "mt", "lock", "SQL", "db", "sq"], "id_disciplina": ["id_disrequinea", "id_disciplineissa", "id_Disciplini", "id_disciina", "id_distciina", "id_Disciplineini", "id_distciana", "id_Disciplina", "id_disciplineina", "id_disciana", "id_distrequina", "id_distciplinea", "id_Disciplinea", "id_disciplineino", "id_Disciplineissa", "id_distrequINA", "id_distciplino", "id_Disciplissa", "id_disciplini", "id_distciino", "id_discomplissa", "id_disciplana", "id_discomplinea", "id_disciplineinea", "id_Disciplineina", "id_discomplino", "id_distciplina", "id_disciINA", "id_disrequini", "id_distciplINA", "id_distrequini", "id_Disciplineinea", "id_discomplina", "id_disguina", "id_disguissa", "id_disciplineana", "id_disrequINA", "id_disguinea", "id_disciplineini", "id_distciplini", "id_disciino", "id_distciplana", "id_distciini", "id_disciplINA", "id_distrequinea", "id_discomplana", "id_disguini", "id_discomplini", "id_disciini", "id_disciplinea", "id_disciplino", "id_disciinea", "id_disrequina", "id_disciplineINA", "id_disciplissa"], "item": ["action", "entry", "or", "ip", "at", "container", "instance", "m", "site", "o", "request", "area", "service", "edit", "queue", "Item", "object", "er", "unit", "it", "p", "seller", "order", "pe", "event", "server", "url", "index", "other", "article", "bar", "e", "i", "q", "page", "v", "result", "reader", "data", "type", "items", "r", "id", "hop", "info", "parent", "source", "name"]}}
{"id1": "5760649", "id2": "16353490", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    private String executePost(String targetURL, String urlParameters) {\n        URL url;\n        HttpURLConnection connection = null;\n        try {\n            url = new URL(targetURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(urlParameters.getBytes().length));\n            connection.setRequestProperty(\"Content-Language\", \"en-US\");\n            connection.setUseCaches(false);\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            wr.writeBytes(urlParameters);\n            wr.flush();\n            wr.close();\n            InputStream is = connection.getInputStream();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n            String line;\n            StringBuffer response = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                response.append(line);\n                response.append('\\r');\n            }\n            rd.close();\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createFile": ["CreateFile", "saveContent", "saveResource", "CreateContent", " createResource", " createFolder", "createContent", "createResource", "saveFile", "CreateResource", " createContent", "CreateFolder", "saveFolder", "createFolder"], "src": ["resource", "txt", "rss", "username", "SourceFile", "string", "resources", "href", "Source", "ruby", "input", "path", "sc", "buf", "slice", "files", "dest", "content", "fn", "loc", "proc", "gb", "s", "rc", "rob", "upload", "url", "load", "sb", "sl", "fp", "cb", "ssl", "img", "secure", "data", "obj", "r", "rb", "sit", "source", "stream", "uri", "sel", "name", "file"], "filename": ["resource", "txt", "route", "username", "SourceFile", "string", "utf", "sf", "title", "Filename", "path", "fil", "files", "rl", "length", "fn", "l", "s", "prefix", "ename", "url", "location", "loader", "f", "FILE", "ames", "dll", "ame", "fp", "nil", "directory", "output", "acl", "feat", "metadata", "uri", "source", "wb", "name", "which", "file"], "fis": ["cfais", "fIS", "Fiss", " fais", "sfis", " fiss", "fris", "fais", "fbs", "FIS", "sfris", " fris", "Fais", " fIS", "Fis", "sfiss", "Fos", "cfis", "cfIS", " fbs", "cfris", "Fris", "Fbs", "fiss", "cfbs", "sfos", "cfos"], "fos": ["foros", "affos", "sfis", " fops", " fOS", "fbos", "fios", "affis", "bios", "affbos", "bos", "fops", "Fops", "fas", " fios", "foris", " fas", "sfios", "fOS", "affios", "Fis", "Fos", "Fios", "FOS", "forOS", "bis", "bbos", "sfops", "Fas", "Fbos", "foras", "sfos"]}}
{"id1": "20208819", "id2": "6756635", "code1": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"hash": ["SHA", "string", "Hash", "str", "sum", "copy", "num", "build", " hashes", "print", " hashing", "get", "mix", "code", "dump", "format", "check", "output", "parse", "raw", "pack", "update", " Hash"], "input": ["temp", "plus", "accept", "seed", "string", "instance", "current", "context", "request", "str", "inner", "feed", "in", "length", "address", "audio", "upload", "url", "config", "array", "Input", "image", "inf", "output", "reader", "data", "addin", "raw", "null", "parent", "source", "buffer", "text", "binary", "form"], "algorithm": ["calgebra", "aligebra", "aligorithm", " alphabet", " algebra", "aligo", "Algorithm", "Algorith", "algorith", "calgorith", "alphabet", "calgo", "Algebra", " algo", "calgorithm", "algebra", " algorith", "aliphabet", "Alphabet", "algo", "Algo"], "dig": ["rg", "wrap", "fe", "grab", "cmp", "pm", "im", "g", "push", "prep", "and", "dat", "exp", "ex", "um", "d", "rand", "imag", "tool", "log", "Dig", "add", "cod", "pin", "num", "div", "alg", "build", "ag", "comb", "ld", "lab", "ng", "init", "cd", "dim", "rob", "mod", "del", "get", "mix", "enc", "sem", "test", "gen", "de", "sign", "rd", "grad", "me", "ig", "db", "dec"], "result": ["df", "group", "root", "ger", "function", "Result", "global", "string", "current", "results", "cover", "response", "sum", "report", "manager", "api", "match", "card", "this", "dest", "json", "length", "user", "our", "ret", "db", "up", "valid", "default", "future", "consumer", "url", "work", "array", "iter", "su", "value", "success", "format", "res", "record", "page", "output", "runner", "data", "test", "member", "counter", "diff", "null", "message", "buffer", "source", "master", "uri", "re", "builder"], "digest": ["bigest", "digse", "signEST", "signse", "bigested", " Digester", "bigester", " digests", "generEST", "Digester", " digse", "Digested", "signest", "digested", " digEST", "digester", "DigEST", " digester", " digested", "generest", " Dige", "signester", "dige", "generester", "digEST", " Digest", "bigests", "Digests", "digests", " DigEST", "Digest", "Dige", " dige", "Digse", "generests"], "hex": ["temp", "row", "ctr", "wh", "zip", "utf", "string", "zero", "rh", "ex", "shift", "pixel", "bin", "transform", "sum", "ticket", "char", "bit", "num", "length", "address", "header", "ph", "oct", "uint", "throw", "pex", "mix", "array", "index", "iter", "hess", "rex", "head", "sex", "cube", "xf", "h", "format", "check", "data", "digit", "null", "buff", "pattern", "text", "form"], "i": ["iu", "hi", "si", "qi", "multi", "n", "ii", "c", "pi", "o", "y", "d", "abi", "ci", "di", "io", "z", "ui", "ri", "bi", "p", "it", "l", "phi", "j", "I", "x", "uli", "index", "f", "e", "oi", "li", "a", "h", "v", "gi", "ti", "ai", "b", "xi", "t", "id", "info", "uri", "ix", "mu"], "u": ["iu", "bu", "us", "uu", "c", "string", "ru", "o", "d", "uid", "U", "ue", "ur", "yu", "char", "ui", "uv", "cu", "num", "mu", "sup", "p", "l", "up", "pu", "cur", "chu", "x", "du", "f", "fu", "e", "su", "q", "ul", "uf", "h", "hu", "uc", "v", "ou", "tu", "b", "back", "nu", "uri", "uni", "lu", "un"], "highCount": ["largeC", "hiCode", "lowCast", "lowSize", "higherCode", "highC", "HighC", "fullCast", "highercount", "highCode", "lowcount", "fullCount", "largeCode", "lowLength", "HighCount", "hiCount", "hiSize", "fullcount", "largeCount", "higherSize", "lowCode", "hiLength", "HighCode", "highLength", "HighSize", "highSize", "higherC", "higherCast", "higherCount", "largeSize", "highCast", "HighLength", "highcount"], "lowCount": ["lowerLength", "LowC", "lowerCount", "lowCast", "lowSize", "slowCount", "highC", "LowCast", "highSum", "lowerCast", "lowerSum", "lowLength", "lowerC", "slowLength", "LowCount", "slowSum", "highLength", "lowSum", "lowC", "highSize", "slowCast", "LowSize", "lowerSize", "highCast"]}}
{"id1": "7166270", "id2": "7458833", "code1": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"issueCommandToServer": [" sendCommandToServer", " sendCommandtoClient", " sendCommandToService", " sendRequestToServer", " sendCommandWithServer", " sendCommandFromClient", " sendCommandtoserver", " sendRequestFromService", " sendRequestFromClient", " sendRequestFromserver", " sendRequestToserver", " sendCommandWithService", " sendCommandFromserver", " sendCommandtoServer", " sendRequestToService", " sendCommandFromServer", " sendCommandFromService", " sendCommandWithClient", " sendRequestFromServer", " sendCommandtoService", " sendCommandToClient", " sendRequestToClient", " sendCommandToserver", " sendCommandWithserver"], "command": ["action", "resource", "timeout", "application", "attribute", "function", "description", "string", "execute", "request", "method", "script", "service", "sequence", "patch", "operation", "queue", "address", "document", "connection", "domain", "cmd", "event", "query", "component", "code", "value", "password", "Command", "argument", "directory", "data", "menu", "module", "comm", "message", "pattern", "buffer", "text", "version"], "changeCapsule": ["changecAPSule", "changeCapsulation", "changeCAPSulation", "changeCapsure", "changeCapesule", "changeCapule", "changeCapules", "changeCAPSules", "changeCapsules", "changeCorpulate", "changecapsulation", "changeCapole", "changeScapsole", "changeCambure", "changeCapsole", "changecapsule", "changecapsulate", "changeCapesulation", "changeCambule", "changecapsules", "changeCambulate", "changeScapole", "changecAPSulate", "changecAPSulation", "changeCapsulate", "changeScapsule", "changeCAPSule", "changeCorpure", "changeScapsure", "changeCAPSulate", "changeScapule", "changeCapesulate", "changeScapsulate", "changeScapure", "changeCorpole", "changeCapure", "changeScapulate", "changeCapulate", "changeCambole", "changeCapulation", "changeCapesules", "changecAPSules", "changeCorpule"], "urlConn": ["httpFs", "serverConn", " urlEnc", "userConn", "httpConn", "userConnection", "urlConnection", " urlConnection", "serverConnect", "httpCo", "UrlAuth", "serverCo", "serverAuth", " urlDec", "serverExec", "httpDec", " urlConnector", "httpOpen", "httpConnection", "serverConnection", " urlFs", "lFs", "httpConnect", "urlOpen", " urlOpen", "UrlEnc", "serverDec", "urlCo", "lConnection", " urlConnect", "urlExec", "lConn", " urlExec", "urlEnc", "UrlConn", " urlCo", "serverConnector", "urlAuth", "UrlConnector", "urlFs", " urlAuth", "UrlExec", "userOpen", "serverEnc", "UrlConnect", "urlConnect", "userConnect", "urlDec", "urlConnector", "lConnect"], "wr": ["wh", "war", "wt", "raft", "kr", "nw", "rh", "wer", "tw", "wx", "shr", "Writer", "wa", "WR", "sr", "wcs", "wd", "conn", "nr", "wk", "mr", "wp", "err", "cr", "RW", "wire", "sw", "fw", "w", "NW", "Wr", "wb", "usr", "ws", "rw", "worker", "vr", "writer", "hr", "rr", "r", "wl", "rx", "wm"], "content": ["resource", "temp", "section", "description", "string", "c", "context", "request", "method", "xml", "script", "comment", "equ", "cont", "wave", "json", "child", "header", "document", "exec", "server", "Content", "url", "work", "config", "array", "enc", "code", "value", "password", "format", "output", "data", "write", "raw", "esc", "message", "buffer", "const", "text", "body", "source", "activity", "create"], "input": ["resource", "rss", "temp", "pull", "inch", "request", "xml", "inner", "self", "ctx", "wave", "enter", "in", "json", "active", "conn", "ack", "er", "audio", "amp", "w", "init", "rc", "out", "element", "cur", "usr", "iter", "Input", "inside", "i", "worker", "ink", "image", "through", "socket", "writer", "inf", "ssl", "reader", "output", "data", "error", "raw", "hr", "rr", "r", "acl", "inc", "buffer", "stream", "source", "form", "keep"], "response": ["Response", "resource", "application", "line", "respond", "string", "site", "vector", "reply", "request", "secret", "service", "answer", "report", "api", "wave", "feed", "onse", "tree", "json", "object", "resp", "connection", "generation", "ception", "model", "server", " Response", "office", "array", "value", "image", "writer", "result", "page", "output", "data", "message", "buffer", "uri", "collection", "reference"], "str": ["fr", "stri", "line", "kr", "string", "pr", "exp", "spec", "ner", "char", "list", "STR", "div", "tr", "letter", "er", "err", "br", "cr", "cl", "l", "exec", "coll", "url", "arr", "sp", "dr", "sl", "f", "enc", "iter", "i", "result", "st", "data", "type", "hr", "obj", "style", "r", "raw", "strike", "id", "Str", "text", "name", "lc", "dec"]}}
{"id1": "22264586", "id2": "732800", "code1": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"copyFiles": ["clonePages", "cloneFile", "transferFile", "CopyChildren", "Copyfiles", "clonefiles", "copyFile", "CopyFiles", " copyfiles", "copyPages", "transferChildren", "transferPages", "transferFiles", " copyPages", "copyChildren", " copyChildren", "cloneFiles", "transferfiles", " copyFile", "CopyFile", "copyfiles"], "strPath": ["stFile", " strpath", "strName", "striFile", "stPath", " strName", "strFile", "striLog", "STRpath", "StrLog", "STRLog", "stName", "stripath", "striPath", "strpath", "StrFile", "stpath", "strLog", "Strpath", "STRFile", "StrName", "StrPath", "STRPath", " strFile"], "dstPath": ["dstsFile", "dblpath", "dstFile", "ddestDir", "drcpath", "dndPath", "fstsDir", "sdndPath", "dblFile", "sdstName", "drcDir", "sdndName", "ddestFile", "dstName", "drcName", "sdndpath", "fstPath", "sdndDir", "sdstPath", "dstDir", "dblPath", "dndDir", "dndpath", "ddestName", "sdstDir", "fstspath", "dstspath", "drcPath", "dblDir", "dstpath", "dndName", "sdstpath", "fstsPath", "fstFile", "fstsFile", "fstDir", "ddestPath", "dstsPath", "ddestpath", "dstsDir", "fstpath"], "src": ["txt", "cmp", "project", "obl", "front", "host", "Source", "ruby", "dist", "scripts", "self", "input", "ource", "path", "inst", "ctx", "sc", "slice", "this", "sys", "in", "sync", "client", "download", "loc", "sup", "s", "rc", "rob", "ls", "reverse", "upload", "tmp", "cur", "url", "config", "sb", "sl", "back", "SOURCE", "split", "sin", "cb", "RC", "img", "st", "ssl", "secure", "ources", "sub", "rs", "source", "stream", "sel", "sit", "rb", "iv", "sq", "sort"], "dest": ["dc", "folder", "cdn", "txt", "done", "slave", "temp", "wh", "cat", "project", "front", "zip", "rest", "later", "dat", "dist", "d", "destroy", " Dest", "desc", "di", "wd", "div", "sup", "dd", "comb", "trans", "default", "out", "tmp", "delete", "du", "thin", "flat", "des", "ds", "home", "gd", "Dest", "result", "img", "secure", "test", "style", "target", "prop", "de", "source", "wb", "dep", "db"], "list": ["status", "full", "map", "dl", "ll", "none", "files", "pair", "members", "dir", "p", "l", "s", "delete", "url", "like", "val", "stat", "filter", "write", "lists", "parent", "version", "lc", "names", "entry", "lines", "str", "la", "LIST", "bl", "cl", "strings", "keys", "code", "data", "null", "stream", "sort", "www", "listed", "queue", "part", "all", "ls", "coll", "arr", "load", "size", "array", "set", "diff", "type", "stack", "id", "cont", "name", "group", "run", "string", "parents", "is", "remove", "path", "key", "json", "batch", "base", "chain", "config", "read", "split", "test", "info", "source"], "i": ["hi", "si", "qi", "ip", "u", "multi", "n", "ii", "c", "m", "pi", "o", "y", "abi", "ci", "di", "io", "key", "slice", "ji", "ui", "ri", "length", "me", "bi", "ie", "p", "part", "phi", "j", "I", "x", "index", "f", "e", "oi", "li", "a", "start", "gi", "v", "ti", "type", "ai", "data", "r", "b", "xi", "id", "info", "uri", "ix", "mu"], "dest1": ["srcOne", "sourceone", "Dest0", "Dest2", "dest0", "source2", "destOne", "DestOne", "homeone", "source0", "src2", "source1", "src0", "dest2", " destone", "sourceOne", "destone", "home1", "Dest1"], "src1": ["srcOne", "sourceone", "rc1", "source2", " src2", "rcOne", "src2", "rcone", "source1", " srcone", " srcOne", "sourceOne", "rc2", "srcone"], "sourceChannel": ["srcChan", "SourceStream", "ourceChan", "Sourcechannel", "sourceContext", "SourceContext", "targetChan", "ourceStream", " sourcechannel", "SourceChan", "srcStream", "srcContext", " sourceChan", "sourcechannel", "SourceChannel", "ourceChannel", "targetContext", "targetchannel", "sourceStream", "srcChannel", " sourceStream", "sourceChan", "targetStream", " sourceContext", "ourceContext"], "targetChannel": ["TargetChannel", "destContext", "TargetContext", "TargetManager", " targetConnection", "sourceContext", "targetChan", "destChannel", " targetManager", "destConnection", "argetManager", " targetContext", "targetManager", "destChan", " targetChan", "argetChan", " targetchannel", "sourcechannel", "targetConnection", "Targetchannel", "argetChannel", "targetContext", "targetchannel", "argetchannel", "TargetConnection", "sourceChan", "TargetChan"]}}
{"id1": "2521141", "id2": "14231545", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"copy": ["ize", "paste", "cop", "share", "cat", "zip", "rm", "ge", "Copy", "move", "open", "ignore", "sync", "download", "opy", "archive", "pe", "cp", "upload", "clone", "delete", "get", "load", "config", "link", " cp", "dump", "image", "ame", "transfer", "file", "change", "directory", "type", "write", "diff", "clip", "update", "source", "attach", "create"], "from_name": [" from_key", "fromFpath", "from__path", "from_memory", "to_filename", "from_path", "source_name", "from_names", " from_names", "from__memory", "to_path", "source_memory", "from_Name", "fromMfile", "from_key", "fromFmemory", "from_filename", "source_path", "fromFname", "from__name", " from_Name", "fromFfilename", "fromMname", "source_filename", "fromMnames", "from__filename"], "to_name": ["from_filename", "toamname", " to_home", "to_path", "toamhome", "to_Name", "to_home", " to_path", "toampath", "toamfile", " to_Name", "to_filename", "from_path"], "from_file": ["from___filename", "fromappfunction", "from___auto", "from_directory", "fromCname", "fromapplane", "fromapplog", " from__file", "from__directory", " from_files", "remote_file", "from___file", "source_name", "fromCfile", "source_resource", "fromCbrain", "source_files", " from_auto", "source_brain", " from_filename", "from_lane", "from___name", " from_directory", "from_resource", "from_brain", "from_filename", "from_folder", "remote_log", " from__filename", "from__files", "remote_lane", "from__file", "from_files", "fromappfile", " from_folder", "from__name", "from__auto", "from_source", "source_file", "from_auto", " from__auto", "fromCfilename", "remote_function", "from_log", "from__resource", "source_filename", "source_directory", "from_function", " from__name", " from_source", "from__filename"], "to_file": ["eto_file", "eto___name", "to_model", "to___name", "from_load", "to_queue", "intojname", "toJname", "from_bar", " to_files", "to67name", "to67file", "to67dir", "from_binary", "to_filename", "to_dir", " to_queue", "eto___remote", "to_binary", "to64use", "from_stream", "to___remote", "eto___file", "to64file", " to_model", "from_dir", "source_files", "to64name", "to_load", "to___file", "to__load", "into_function", "intojfile", "from_model", " to_filename", "intojfunction", "into_name", "into_file", "to__file", "into_use", "to_stream", "to64function", "to_use", "tojname", "tojfunction", "from_files", "eto_remote", "tojuse", "eto_name", "to__dir", "tojfile", "to_files", "to_server", " to_class", "to_function", "to__name", "toJfile", "to_bar", "source_file", "to67load", "to_class", "to_remote", "toJbar", "intojuse", "toJstream", "source_filename", "source_server"], "parent": ["resource", "Parent", "container", "global", "function", "full", "current", "manager", "fat", "address", "p", "rule", "out", "pa", "port", "url", "location", "pool", "am", "po", "uri", "file", "or", "mother", "cache", "patch", "tree", "user", "loc", "connection", "per", "page", "term", "null", "par", "folder", "root", "owner", "host", "old", "search", "ac", "div", "content", "part", "complete", "size", "home", "any", "memory", "author", "type", "target", "id", "client", "name", "temp", "ip", "string", "parents", "path", "api", "ppa", "child", "unit", "handler", "server", "session", "remote", "test", "directory", "point", "inc", "source"], "dir": ["folder", "dc", "entry", "group", "root", "dis", "or", "class", "keep", "container", "cat", "global", "cache", "ir", "exp", "d", "path", "di", "manager", "io", "die", "in", "doc", "dev", "wd", "div", "object", "user", "tr", "def", "loc", "build", "rel", "dict", "part", "out", "coll", "url", "cur", "dr", "nav", "f", "per", "iter", "director", "home", "Dir", " directory", "directory", "data", "md", "r", "module", "id", "lock", "ver", "block", "dep", "name", "db", "file", "dec"], "from": ["fe", "or", "fr", "ch", "entry", "cor", "who", "so", "cm", "cache", "low", "context", "view", "http", "with", "self", "From", "vol", "con", "api", "can", "feed", "add", "this", "io", "flo", "cf", "empty", "client", "ce", "conn", "address", "ra", "cr", "connection", "part", "base", "normal", "when", "pe", "two", "server", "url", "component", "get", "left", "find", "name", "bean", "per", "link", "e", "without", "by", "auto", "start", "range", "se", "parse", "ou", "source", "stream", "form", "one", "file"], "to": ["or", "token", "not", "so", "op", "pi", "o", "see", "http", "proxy", "with", "about", "as", "io", "api", "via", "co", "fat", "dest", "flo", "sync", "on", "conn", "tto", "that", "store", "connection", "base", "TO", "out", "storage", "two", "thro", "server", "will", "To", "size", "office", "per", "session", "su", "by", "value", "top", "socket", "auto", "until", "output", "type", "write", "too", "target", "po", "fb", "t", "ver", "client", "one", "db", "file"], "buffer": ["resource", "row", "window", "seed", "position", "channel", "uffer", "total", "comment", "padding", "character", "layer", "shape", "texture", "wave", "feed", "buf", "queue", "slice", "number", "length", "address", "header", "batch", "default", "document", "server", "url", "variable", "read", "Buffer", "iter", "writer", "transfer", "page", "memory", "bb", "reader", "border", "data", "null", "b", "buff", "flush", "message", "duration", "binary", "source", "block", "reference"], "bytes_read": ["gets_pass", "gets_reads", "bytes_before", "bytes___allow", "bytesXcurrent", "bytes___reads", "bytesXbefore", " bytes_found", "bytes_reads", "byte_read", "gets___pass", "byteslexload", "byte_current", "bytesXread", "gets_allow", "bytesXload", "bytes_pass", "byteslexread", " bytes_write", "bytes_write", "bytes___pass", "gets___allow", "bytes_load", "bytes___read", "gets_read", "gets___reads", "byteslexcurrent", "byte_load", "bytes_allow", "byteslexbefore", "bytes_current", " bytes_en", "bytes_en", "gets___read", "bytes_found", "byte_before"]}}
{"id1": "21368981", "id2": "17773263", "code1": "    public APIResponse create(Application application) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/application/create\").openConnection();\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n        connection.setUseCaches(false);\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\")));\n        connection.getOutputStream().flush();\n        connection.getOutputStream().close();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\")).readLine()));\n            response.setDone(true);\n            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));\n            connection.getInputStream().close();\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Create Application Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 0, "substitutes": {"create": ["Create", "creat", "run", "send", "execute", "request", "call", "POST", "api", "open", "add", "process", "post", "construct", "setup", "delete", "get", "complete", "start", "save", "type", "write", "make", "message", "update"], "application": ["resource", "attribute", "class", "external", "Application", "project", "instance", "current", "request", "xml", "http", "expression", "version", "service", "language", "layer", "api", "database", "object", "address", "unit", "audio", "app", "document", "base", "video", "component", "system", "x", "config", "bean", "array", "a", "page", "apply", "output", "apache", "message", "name", "android"], "response": ["Response", "resource", "entry", "status", "function", "description", "position", "respond", "site", "host", "reply", "request", "http", "view", "version", "service", "more", "report", "answer", "manager", "api", "feed", "onse", "tree", "json", "object", "user", "handler", "dict", "resp", "document", "ception", "offer", "part", "model", "server", "index", "session", "value", "success", "image", "example", "writer", "result", "page", "next", "output", "error", "data", "ae", "esi", "message", "client", "collection", "reference"], "connection": ["function", "Connection", "current", "environment", "log", "manager", "engine", "network", "database", "url", "location", "machine", "image", "socket", "writer", "error", "connected", "uri", "text", "collection", "version", "timeout", "entry", "cache", "statement", "expression", "proxy", "ion", "io", "relation", "bug", "loc", "command", "office", "link", "password", "graph", "message", "connect", "section", "entity", "channel", "creation", "union", "character", "node", "operation", "creator", "document", "part", "query", "component", "cli", "client", "reference", "position", "context", "inner", "condition", "number", "conn", "object", "translation", "handler", "event", "communication", "server", "system", "config", "bc", "session", "wrapper", "remote", "directory", "source", "builder"], "obj": ["txt", "cdn", "js", "nb", "line", "so", "ob", "n", "Obj", "map", "act", "o", "oa", "obo", "ctx", "objects", "co", "list", "rt", "json", "active", "object", "conn", "ass", "ose", "adj", "resp", "part", "out", "j", "tmp", "coll", "arr", "code", "ns", "res", "result", "output", "data", "bj", "r", "po", "b", "info", "body", "aj", "art"]}}
{"id1": "2022160", "id2": "18693224", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"write": ["pipe", "run", "writ", "cycle", "send", "append", "call", "service", "copy", "export", "lex", "open", "feed", "process", "add", "sync", "Write", "play", "store", "w", "out", "exec", "size", "read", "wrote", "code", "dump", "set", "writer", "close", "next", "output", "writing", "written", "data", "put", "flush", "end", "update", "connect", "create", "kill", "flow"], "byteBuffers": ["ByteBuffers", "connectionBufferers", "bytebuffors", "bytesBuffapers", "bytebuffered", "connectionBuffers", "byteOffters", "bytePackerers", "bytesDefers", "bytebuffers", "byteOrdinals", "byteBuildatters", "byteInfatters", "byteAkizers", "ByteBufferers", "byteIntegeners", "byteChings", "wordBuffatters", " byteOrdiners", "byteAkelines", "wordBufferers", "bytesAkelines", "byteBuffelines", "bytesPackerers", "bytebuffinals", " byteOrdeners", "byteChERS", "ByteBuffERS", "byteBuffors", "byteCornered", "byteBuffinals", "bytesBufferers", "bytebuffelines", "connectionBuffeners", "bytesDefelines", "byteOffers", "byteHeadings", "bytesCornatters", "byteWriters", "byteIntegelines", "bytesDefERS", "byteBuilderers", " byteCompERS", " byteCompares", "byteInferers", " byteBuffinals", " byteOrdinals", "doubleBuffERS", "byteIntegERS", "byteBufferelines", "connectionbufferers", "byteOrdeners", "byteCompERS", "byteBuildERS", "doubleHeadered", "byteWritiners", "bytebuffizers", "ByteOrdERS", "byteOffERS", "byteBuffings", "doubleBuffers", "byteCornares", "bytesBuffors", " byteBuffiners", "byteIntegers", " byteBufferers", "byteWritors", "byteOrdlers", "bytebuffatters", "byteCorners", "byteDefers", "ByteOrderers", "doubleHeadERS", " byteBuffeners", "bytebuffings", "bytesBuffERS", "bytesBuffered", "byteCornERS", "byteCornlers", "byteInfers", "byteBuffatters", "byteBuffered", "byteBufferatters", "byteCompares", "byteBuffizers", "byteOrdiners", "byteBufflers", " byteOrdERS", "bytesPackERS", "byteCornatters", "ByteOrders", "byteAkors", "byteHeadered", "bytesAkers", "byteOrders", "byteBuffERS", "byteHeaders", "bytesBuffers", "byteBufferapers", "byteIntegatters", "bytebuffeners", "doubleBuffings", "doubleBuffered", " byteBuffters", "connectionbuffeners", " byteOffors", "byteAkers", "bytesPackapers", "bytesDefatters", "bytePackERS", "byteCompers", "bytebuffests", "connectionBuffERS", "bytesBuffelines", "byteWritlers", "byteWritizers", "byteWritelines", "doubleHeaders", "ByteOrdresses", "byteOrdapers", "byteDefelines", " byteOffters", " byteOrdlers", "byteBuffeners", "ByteBufflers", "byteBufferers", "bytebufflers", "byteCornests", "wordBuffers", "byteBuffests", "bytesBuffests", " byteBuffares", "connectionbuffERS", " byteBuffERS", "bytePackers", "byteOrdresses", " byteBuffors", "byteOrderers", "byteBuffererers", "doubleHeadings", "bytesAkors", "bytesCorners", "bytesAkizers", "byteChers", " byteOffERS", "ByteBuffresses", " byteBufflers", "byteChered", "byteInteginals", "bytebuffERS", " byteComplers", "byteOrdERS", " byteOrders", "bytesBuffatters", "bytesPackers", "byteBuffapers", "bytebuffresses", "byteBuffares", "bytePackapers", "bytebuffiners", "byteBuffresses", "byteComplers", "bytebuffters", "byteDefERS", "byteBufferERS", "byteInfERS", "byteBuffereners", " byteOffers", "wordBuffERS", " byteCompers", "byteOffors", "byteBuilders", "byteHeadERS", "byteDefatters", "bytesBuffizers", "bytebufferers", "byteWriterers", "byteBuffiners", " byteOrderers", "byteBuffters", "byteBufferlers", "bytesCornests", "bytesCornered", "connectionbuffers"], "m_initialOutBuffer": ["m_initialOutputBuffer", "m_initialOutputChannel", "m_finalOutBuffer", "m_originalOutAddress", "m_initialClientLine", "m_initialSocketLayer", "m_finaloutBuff", "m_initialAuthLine", "m_originalOutBuffer", "m_initialOutputLayer", "m_initialClientBuffer", "m_initialoutCache", "m_finalInBuff", "m_initialNewBuff", "m_finalOutMessage", "m_initialClientBuff", "m_initialInBuffer", "m_initialInBuff", "m_initialSocketHeader", "m_finaloutChannel", "m_finalOutChannel", "m_initialInHeader", "m_finalInBuffer", "m_initialNewFile", "m_initialShortCache", "m_initialInMessage", "m_initialoutChannel", "m_initialOutputBuff", "m_initialShortChannel", "m_finalOutBuff", "m_initialOutAddress", "m_initialNewMessage", "m_finalInChannel", "m_initialoutBuffer", "m_initialInAddress", "m_finalInMessage", "m_initialSocketFile", "m_originaloutBuffer", "m_initialAuthBuffer", "m_initialAuthFile", "m_initialOutLine", "m_InitialOutputFile", "m_initialOutMessage", "m_initialSocketBuffer", "m_initialNewBuffer", "m_initialOutputHeader", "m_InitialOutFile", "m_initialOutputFile", "m_initialInLayer", "m_initialOutFile", "m_InitialOutLayer", "m_finalOutCache", "m_finalInLine", "m_originalOutLine", "m_initialAuthAddress", "m_initialOutputMessage", "m_initialOutCache", "m_initialoutLine", "m_initialShortBuffer", "m_finaloutBuffer", "m_InitialOutputLayer", "m_initialOutHeader", "m_initialClientFile", "m_InitialOutBuffer", "m_finaloutFile", "m_originaloutAddress", "m_originaloutFile", "m_initialShortFile", "m_InitialOutputBuffer", "m_finalOutFile", "m_initialoutAddress", "m_InitialOutHeader", "m_initialInLine", "m_finalInFile", "m_initialInChannel", "m_initialoutBuff", "m_originaloutLine", "m_initialOutChannel", "m_initialoutFile", "m_initialOutLayer", "m_finalOutLine", "m_initialOutBuff", "m_initialInFile", "m_finalInCache", "m_InitialOutputHeader", "m_initialInCache", "m_originalOutFile"], "buffer": ["resource", "view", "engine", "address", "cell", "port", "shell", "url", "pool", "holder", "writer", "transfer", "flush", "console", "file", "timeout", "cache", "uffer", "comment", "feed", "slice", "header", "cur", "iter", "page", "output", "data", "null", "buff", "message", "block", "re", "row", "ker", "channel", "table", "copy", "queue", "bridge", "er", "document", "phrase", "array", "f", "worker", "callback", "reader", "fb", "stack", "binary", "client", "temp", "window", "string", "limit", "input", "response", "layer", "wave", "buf", "FFER", "object", "batch", "base", "event", "server", "config", "loader", "bc", "read", "Buffer", "back", "source", "builder", "template"], "buffers": ["bufors", "buffering", "buffators", "phers", "buffars", "bufaches", "ufors", "ufering", "bufered", "affors", "bufars", "ufers", " bufferers", "phresses", "transformERS", "buffages", " buffages", "affering", "Buffered", "bufages", "phators", " buffators", "transformler", "transformering", "buffors", "bufators", " buffars", "ufaches", "bufler", "bufers", " buffresses", "buffresses", "transformers", "buffERS", "bufferers", "affers", "affaches", " buffler", " buffERS", "Bufferers", "buferers", " buffering", "phages", "Buffers", "bufERS", "Buffars", "buffaches", "bufresses", "buffered", "bufering", " buffered", "buffler"], "result": ["resource", "or", "row", "status", "acc", "use", "function", "Result", "cache", "request", "results", "view", "comment", "inner", "winner", "response", "report", "manager", "search", "match", "sr", "card", "driver", "json", "user", "ret", "er", "err", "valid", "up", "successful", "default", "flash", "grade", "rc", "out", "rate", "event", "future", "consumer", "url", "complete", "cup", "f", "date", "session", "success", "res", "val", "runner", "error", "data", "test", "true", "output", "diff", "r", "message", "info", "ver", "re"], "encrypted": ["body", "entry", "temp", "channel", "cache", " data", "secret", "padding", "inner", "layer", "text", "pad", "flash", "selected", "config", "loader", "image", "internal", "transfer", "reader", "packed", "flush", "interrupted", "binary", "stream", "available", "source", "extra"]}}
{"id1": "19944975", "id2": "13414771", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"writeConfiguration": ["writeSection", "writeReport", " writeSection", "saveConfiguration", "saveReport", "saveConfig", "WriteConfiguration", "writeConfig", "WriteReport", "WriteSection", " writeConfig", "WriteConfig", "saveSection", " writeReport"], "out": ["resource", "temp", "inas", "external", "window", "line", "again", "at", "project", "string", "c", "m", "IN", "o", "ex", "exp", "xml", "inner", "scope", "Out", "report", "path", "io", "outs", "list", "key", "sync", "this", "object", "conn", "user", "err", "connection", "w", "base", "init", "prefix", "exec", "server", "config", "pool", "dump", "password", "filename", "lib", "writer", "res", "plain", "ext", "output", "reader", "write", "obj", "OUT", "flush", "parent", "client", "name", "file"], "url": ["resource", "ob", "string", "channel", "xml", "http", "service", "URL", "path", "ll", "io", "open", "feed", "api", "Url", "object", "conn", "address", "rel", "l", "connection", "base", "server", "location", "config", "sl", "f", "image", "page", "ssl", "data", "r", "b", "web", "uri", "stream", "source", "org", "file"], "in": ["resource", "In", "inas", "again", "serv", "n", "c", "ini", "IN", "cin", "xml", "is", "din", "inner", "bin", "input", "copy", "as", "pin", "cms", "ins", "ac", "conn", "min", "inn", "err", "kin", "isin", "s", "rin", "win", "lin", "gin", "f", "inside", "i", "nin", "a", "socket", "login", "ssl", "reader", "data", "r", "b", "inc", "id", "source", "stream", "file"]}}
{"id1": "9096319", "id2": "10281203", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 1, "substitutes": {"handleNodeRegainedService": ["handleNodeRegainingService", "handleNodeReginedServices", "handleNodeRegainsService", "handleNoderegainsEvent", "handleNodeRegainingEvent", "handleNodeReginedService", "handleNoderegainsService", "handleNodeRegainedEvent", "handleNodeReginedEvent", "handleNodeRegainedServices", "handleNodeRegainsEvent", "handleNoderegainsServices", "handleNoderegainedService", "handleNoderegainedEvent", "handleNodeRegainingServices", "handleNoderegainedServices", "handleNodeRegainsServices"], "eventID": ["issueID", "serviceTime", " eventName", "issueName", " eventid", "serviceId", "updateName", "issueid", "serviceid", "nodeTime", "updateid", "updateID", "serviceName", "eventId", " eventId", "eventid", "updateId", "nodeName", "issueId", "eventName", "nodeId"], "nodeID": [" nodeResult", " nodeName", " nodeRI", "globalid", "globalID", "eventPath", " nodePath", "resourceID", "serviceId", "odeName", "siteid", " nodeKey", "sourceId", "eventResult", "odeID", "sourceID", "objectName", "odeId", "serviceid", "objectid", "resourceKey", "resourceId", "nodeResult", "odeResult", " nodeId", "nodeKey", "nodeid", "eventId", "eventid", "nodePath", "packageId", "objectID", "nodeRI", "packageID", "siteID", "odeRI", "siteName", "nodeName", "siteId", "sourceRI", "eventName", "nodeId", "globalId", "globalPath", "objectId", "eventKey", "packageid", " nodeid"], "ipAddr": ["ipAddrt", " ipApprs", " ipAttr", "ipAder", " ipAddrs", "ipAppvr", "ipAttr", " ipAddress", "ipaddri", " ipAddvr", "ipCher", "IPAddressrs", "IPAddressn", " ipAppvr", "ipadder", "ipaddrs", " ipAttvr", "ipAddresser", "ipAddressn", "ipAddressvr", "ipAddressr", "IPAddr", "ipAddressrs", " ipAdder", " ipAttrs", "ipApprs", "ipOffrs", "ipAddn", "ipaddvr", "ipAdn", "IPAddrs", "IPAddressr", " ipAtter", "IPAddrt", "ipAddressri", "ipAdder", "IPAddressri", "ipChn", "ipOffrt", "ipAddressress", "ipAdr", " ipAppr", "ipAddri", "ipAddressrt", "ipChr", "ipaddress", " ipAttri", "ipAddress", "ipAppr", "ipAddvr", "ipAttvr", "ipAddrs", "ipAtter", "ipChrs", "IPAddn", "ipAttri", " ipAddri", "IPAdder", "ipOffri", "ipOffr", "ipAttrs", "IPAddressrt", "IPAddri", "IPAddresser", "ipAdrs", "ipaddr"], "serviceID": [" serviceX", "skillName", "skillId", "serverId", "featureHandle", " serviceType", "serviceHandle", "skillID", " serviceName", " serviceIDs", "serverName", "featureId", "resourceID", "skillNAME", "serviceId", "featureIP", "eventX", "serviceX", " serviceNAME", "serverX", " serviceHandle", " serviceIP", "resourceId", "ServiceName", "resourceType", "serviceName", "serviceNAME", " serviceId", "serverID", "eventId", "eventIDs", "serviceIDs", "ServiceNAME", "ServiceType", "processName", "featureID", "serviceIP", "eventName", "ServiceIDs", "ServiceIP", "ServiceId", "processID", "ServiceHandle", "serviceType", "processId", "ServiceID"], "eventTime": ["errorTIME", "eventPoint", "EventName", "errorType", " eventPoint", " eventTim", " eventName", "errorTime", "eventType", "processTime", "EventTim", "EventID", "changeType", "eventTim", "errorPoint", "EventTime", "eventTIME", "changeTIME", "processName", "processTim", "eventName", "changeTime", "processID", " eventType", " eventTIME", "changePoint"], "log": ["or", "entry", "ch", "temp", "cat", "full", "c", "blog", "host", "cache", "exp", "call", "http", "tool", "pl", "ge", "path", "lex", "feed", "key", "conn", "bug", "build", "it", "cl", "l", "connection", "w", "tag", "net", "out", "pe", "event", "Log", "port", "model", "get", "thread", "plug", "config", "sec", "url", "contract", "pool", "crit", "stop", "format", "stat", "lo", "level", "type", "gen", "error", "output", "write", "LOG", "debug", "put", "sign", "fail", "info", "og", "lock", "com", "loop", "db"], "dbConn": ["realColl", "databaseconn", "dbConnection", "dbconn", "databaseLoc", "cbConn", "cbConnect", "bbconn", "fbCon", "Dbconn", "databaseConn", " dbCon", "dbCt", " dbLoc", "bbCon", " dbConnect", "fbCt", "DbConnection", "logconn", "DBConnect", "dbLoc", "databaseConnection", "DBConn", "realCon", "DbLoc", "logDb", "DBCon", " dbconn", "logConn", "bbConnect", "realConn", "logConnect", "DbCt", " dbColl", "fbColl", "bbConnection", "DbConn", "dbConnect", " dbCt", "cbconn", "DbDb", "dbColl", "DBconn", "dbCon", "bbConn", "DBConnection", "realCt", "DBCt", "fbConn", "DbConnect", " dbDb", " dbConnection", "dbDb", "cbConnection"], "outageUpdater": ["outageuplaser", "outageuplusher", "outageUpraser", "outageUpdarer", "outageUpfatter", "outageUpdatatter", "outageUdater", "outageUpdrator", "outageChdoder", "outageUnaser", "outageUpdrarer", "outageUpnager", "outageUpdatarer", "outageUpndter", "outageUpdatater", "outageUpratter", "outageupdatter", "outageUptaser", "outageUpnaser", "outageUpndatter", "outageChdroder", "outageUpdatable", "outageUpdatedapper", "outageupdaser", "outageUpmager", "outageUpdroder", "outageUpnoster", "outageUpnater", "outageUppter", "outageUpdrusher", "outageUtdarter", "outageUtdatatter", "outageupdusher", "outageAppdater", "outageUpdatedrATER", "outageUpdator", "outageUpdatedaser", "outageAppnter", "outageUpdatedratable", "outageChdater", "outageUpstater", "outageAppdager", "outageAppnator", "outageUptatable", "outageUpdATER", "outageUnarer", "outageUdaser", "outageUplaser", "outageUppatter", "outageupdater", "outageUdarer", "outageUpnoder", "outageUpdusher", "outageUpnter", "outageUplater", "outageUnater", "outageUpdaser", "outageUpfapper", "outageUpdrater", "outageUplusher", "outageUpdatedraser", "outageUppATER", "outageuplater", "outageUpfaser", "outageChdoster", "outageAppdator", "outageUpdraser", "outageUprater", "outageUpdoder", "outageUplatter", "outageUpdatATER", "outageUpmator", "outageChdator", "outageUpdatedATER", "outageUpdatarter", "outageUpnator", "outageUppaser", "outageUpdatatable", "outageAppnater", "outageUpnarer", "outageUplapper", "outageUpdataser", "outageUtdter", "outageUpparter", "outageUpdsoder", "outageUprusher", "outageUpdapper", "outageUptater", "outageUpndater", "outageAppdter", "outageUpnATER", "outageUpfater", "outageUpdarter", "outageUpmter", "outageChdrater", "outageUnATER", "outageUpdatedatable", "outageUpdratter", "outageUtdater", "outageUpstager", "outageUtdatarter", "outageUpdter", "outageUpdroster", "outageUpdatedater", "outageUpdatedrater", "outageUpndarter", "outageUpstator", "outageChdroster", "outageUpdager", "outageChdrator", "outageUtdatter", "outageUpdatter", "outageUpdrapper", "outageUpdsater", "outageUpmater", "outageUpdatedrapper", "outageUpdsator", "outageUpdsoster", "outageUpdoster", "outageUpdratable", "outageUpdatedrarer", "outageUpdrATER", "outageUdATER", "outageUptarer", "outageUppater", "outageUtdatater", "outageUpdatedarer", "outageUpdatedratter", "outageAppnager", "outageUpdatedatter", "outageuplatter", "outageUpstter"]}}
{"id1": "1362", "id2": "17538992", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public static boolean check(String urlStr) {\n        try {\n            URL url = new URL(urlStr);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            urlConnection.setConnectTimeout(2000);\n            urlConnection.getContent();\n        } catch (Exception e) {\n            logger.error(\"There is no internet connection\", e);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubblingOrder", "ubbleSort", "bubblerSort", "ubblingSort", "bubblingCompare", "bubblersort", "bubblessort", "bubblesOrder", "ubblingCompare", "bubbleOrder", "bubblesCompare", "bubblesort", "bubbleCompare", "ubblingOrder", "ubbleCompare", "bubblerOrder", "bubblingsort", "ubblingsort", "bubblingSort", "bubblerCompare", "ubbleOrder", "bubblesSort", "ubblesort"], "a": ["an", "another", "va", "aux", "ama", "u", "at", "c", "access", "m", "apps", "o", "oa", "A", "area", "d", "na", "as", "au", "abs", "aa", "empty", "sa", "list", "la", "active", "ac", "ack", "address", "sup", "p", "aaa", "alpha", "ad", "l", "s", "ans", "all", "ga", "aw", "work", "ma", "array", "f", "index", "e", "am", "auto", "any", "tta", "result", "img", "ae", "data", "something", "b", "ba", "ata", "ab", "aj"], "swapped": [" swaped", "swaps", "rewaped", "rewap", " swap", "wap", "Swapping", "Swaped", "waps", " swapping", "wapped", "Swapped", " swaps", "flapped", "Swoped", "Swap", "flap", "rewoped", "floped", "swap", "wapping", "rewapped", "flapping", "waped", "swapping", "swoped", "swaped", "rewaps", "rewapping"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "k", "ii", "ini", "m", "pi", "y", "d", "ci", "di", "api", "io", "key", "ui", "in", "ri", "bi", "ie", "p", "it", "sup", "l", "ami", "init", "ki", "j", "I", "eni", "x", "fi", "index", "f", "e", "oi", "li", "ind", "ori", "anti", "h", "ni", "start", "v", "gi", "ti", "next", "mini", "mi", "ai", "module", "b", "xi", "id", "info", "uri", "iv", "ix", "uni", "adi"], "tmp": ["txt", "temp", "mp", "yy", "nb", "cmp", "front", "m", "append", "stuff", "area", "angle", "mmm", "prev", "dest", "pad", "qq", "pp", "tv", "sup", "p", "alpha", "ie", "xxx", "amp", "part", "j", "addr", "x", "foo", "f", " ff", "pre", "emp", "tc", "v", "bb", "test", "st", "obj", "b", "t", "tt", "kk", "opp", "vt"]}}
{"id1": "14054923", "id2": "22268798", "code1": "    protected Document getRawResults(String urlString, Map args) throws Exception {\n        int count = 0;\n        Iterator keys = args.keySet().iterator();\n        while (keys.hasNext()) {\n            String sep = count++ == 0 ? \"?\" : \"&\";\n            String name = (String) keys.next();\n            if (args.get(name) != null) {\n                urlString += sep + name + \"=\" + args.get(name);\n            }\n        }\n        URL url = new URL(urlString);\n        URLConnection conn = url.openConnection();\n        conn.connect();\n        SAXBuilder builder = new SAXBuilder();\n        return builder.build(conn.getInputStream());\n    }\n", "code2": "    @Override\n    public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException {\n        String uniqueName = path.getBaseName();\n        URL url = buildURL(uniqueName);\n        URLContent content = new URLContent(url, this.getName(), uniqueName);\n        content.setUniqueName(uniqueName);\n        content.setReadable(true);\n        content.setWritable(writable);\n        content.setExists(true);\n        try {\n            URLConnection connection = url.openConnection();\n            String mimeType = connection.getContentType();\n            content.setMimeType(mimeType);\n            content.setWritable(true);\n        } catch (IOException ex) {\n            throw new ContentException(\"unable to obtain mime type of \" + url, ex);\n        }\n        return content;\n    }\n", "label": 0, "substitutes": {"getRawResults": ["processrawResult", "getRawResponse", "processrawResources", "getrawResponse", "getRowResources", "getFullResult", "getFullResources", "getFullResults", "processrawResponse", "processrawResults", "getrawResults", "getRawResources", "getFullResponse", "processRawResources", "processRawResults", "getrawResult", "processRawResponse", "getRowResponse", "getrawResources", "getRawResult", "processRawResult", "getRowResults", "getRowResult"], "urlString": ["httpStr", "fileName", "httpText", "stringString", "filestring", "stringstring", "stringStream", "urlStr", "updateStr", " urlName", "urlArray", "httpArray", "urlText", "fileString", " urlstring", "resourceArray", "updatestring", "httpStream", " urlStream", "updateString", "fileArray", "stringArray", " urlStr", "httpString", "updateText", "urlStream", " urlArray", "resourceString", "urlstring", "resourcestring", "httpstring", "resourceName", " urlText", "urlName"], "count": ["group", "cmp", "cache", "current", "col", "call", "more", "sum", "match", "Count", "list", "number", "key", "force", "num", "length", "second", "seq", "weight", "p", "part", "base", "coll", "size", "index", "array", "code", "i", "head", "start", "counter", "last", "found", "id", "message", "loop", "parent", "offset"], "keys": ["names", "ers", "ks", "kes", "Keys", "ms", "bs", "n", "writers", "lines", "opens", "results", "values", "errors", "ids", "headers", "drivers", "os", "key", "list", "builders", "files", "ors", "ins", "events", "groups", "xs", "locks", "obs", "s", "qs", "fields", "vs", "ops", "index", "iter", "vers", "ns", "blocks", "ips", "links", "vals", "cats", "states", "items", "ps", "es", "users", "lists", "rows"], "sep": ["semg", "semps", "SEg", " sepse", "semf", "sempe", "semp", "seg", " sef", "psepe", "sepe", "SEp", "sepse", "SEps", " seg", "sef", "psef", "SEpse", " sepe", "pseg", "seps", "sempse", "psep", " seps"], "name": ["Name", "names", "resource", "entry", "pass", "ip", "line", "n", "string", "known", "word", "request", "call", "ex", "str", "named", "old", "time", "layer", "path", "label", "search", "api", "key", "none", "attr", "active", "client", "object", "no", "child", "address", "min", "default", "part", "connection", "base", "prefix", "size", "f", "field", "session", "value", "space", "cap", "ame", "var", "NAME", "ext", "member", "data", "type", "id", "info", "parent", "alias", "block", "file", "common"], "url": ["resource", "c", "channel", "blog", "host", "http", "www", "URL", "path", "ll", "layer", "open", "key", "Url", "impl", "object", "address", "user", "build", "loc", "browser", "l", "connection", "base", "ls", "server", "sl", "f", "uc", "page", "ssl", "fl", "obj", "r", "b", "web", "uri", "client", "org"], "conn": ["dc", "ch", "n", "c", "Connection", "channel", "act", "http", "Conn", "ann", "conv", " connection", "path", "ctx", "con", "open", "util", "rt", "ct", "cf", "loc", "err", "db", "l", "connection", "net", "cn", "out", "rc", "cp", "coll", "server", "cur", "enc", "cli", "connect", "socket", "close", "cb", "ssl", "nt", "nc", "connected", "client"], "builder": ["or", "entry", "slave", "row", "instance", "pb", "http", "oder", "inner", "response", "layer", "outer", "builders", "driver", "object", "bridge", "creator", "build", "default", "l", "event", "server", "config", "loader", "now", "building", "sb", "bean", "e", "wrapper", "Builder", "writer", "result", "runner", "reader", "r", "b", "parser", "job", "buffer", "client"]}}
{"id1": "18782385", "id2": "12766394", "code1": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"saveFile": [" saveDirectory", "writeImage", "saveFiles", "uploadImage", "uploadFile", "uploadFiles", "saveImage", "saveDirectory", " saveImage", "writeFile", "uploadDirectory", " saveFiles", "writeDirectory", "writeFiles"], "window": ["stage", "draw", "media", "view", "microsoft", "wx", "scope", "wall", "time", "manager", " host", " wizard", "w", "game", "machine", "space", "image", "parent", "console", "GUI", "file", "flow", " dialog", "band", "command", "video", "win", "layout", "office", " Window", " office", "button", "Window", "angular", " video", " container", "project", "host", "gallery", "driver", "doc", "browser", "frame", "document", "device", " widget", "hw", "scroll", "home", "dom", "menu", "target", "client", " world", " GUI", "volume", "gui", "motion", "input", "layer", "screen", "wa", "box", "ui", "visual", "audio", " wid", "youtube", "show", "event", " canvas", "server", "system", "session", "feature", "widget", "remote", "img", "directory", "style", "buffer"], "stream": [" webpage", " buffer", " streams", " form", " temp", "io", " app", "os", " webcam", " prog", " this", " console", "document", "w", "out", "Stream", "OU", "f", " OUT", " w", " bout", " resource", "output", " upload", " video", "file"], "outputDoc": ["targetFile", "targetDiv", "inputFile", "updateDiv", "outputDocument", "outputFile", "OutputFile", "targetDoc", "inputDocument", " outputDocument", "inputDoc", "externalDocument", "OutputDoc", "OutputDir", "externalFile", "updateDir", "targetDocument", "updateDoc", " outputDiv", "externalDoc", "externalDiv", "updateDocument", "OutputDocument", " outputDir", "inputDir", "outputDir", "outputDiv", " outputFile", "OutputDiv"], "dtd": ["fddd", "DTD", "Ddt", "Dtd", "Ddl", "sdt", "ddl", "fddl", " ddl", "ddd", "Dlt", " ddd", " ddt", "slt", "fdtd", "dTD", "ddt", "sTD", "std", " dlt", " dTD", "fdTD", "dlt", "Ddd"], "uiElement": ["UIelement", "suElement", "apiE", "uiObject", "uniEntity", "uriEl", "UIE", "uelement", "uElement", "apiEl", "guiDoc", "UIObject", "UIMember", "apiEntity", "urielement", "cliEntry", "uiEngine", "ioEl", "uEl", "uriEngine", "uiDoc", "volumeDocument", "guielement", "guiMember", " UIEditor", "UIDoc", "guiEntity", "uiE", "luEntity", "utilEl", "uriEntity", "uriElement", "suEngine", "utilElement", "uriEmail", "UIEntry", "UIEle", "uiEle", "uniE", "luEmail", "ouEle", "uiDocument", "uiEmail", "uiEntity", "guiModule", "utilDoc", "luEngine", "uriDocument", "uiModule", "suEntity", "guiElement", "UIModule", "uiEditor", "uiEl", "ouEl", "uniMember", "cliEl", "UIDocument", "uniElement", "guiE", "uiMember", "uiEntry", "clielement", "uSource", "UIEl", "UISource", "apiElement", "suEmail", "ioDoc", " UIEle", "ioElement", "uriE", "cliElement", "ouElement", "guiEl", "uiSource", "uniEl", "volumeEntry", "UIEditor", "unielement", "uriEntry", " UIEl", "uielement", " UIElement", "ouEditor", "UIElement", "cliSource", "volumeObject", "luElement", "ioModule", "uriObject"], "currentLFClassName": ["currentLELFCLASSDesc", "currentLFClassAlias", "currentLDFClassDesc", "currentLDFClassname", "currentLFFileDesc", "currentLELFClassAlias", "currentLDFFileName", "currentLDFClassName", "currentLELFClassName", "currentLFClassPath", "currentLFCLASSDesc", "currentLFclassname", "currentLFFileName", "currentLFclassDesc", "currentLELFCLASSAlias", "currentLFClassname", "currentLFFileString", "currentLFFunctionDesc", "currentLDFFileDesc", "currentLFclassName", "currentLELFCLASSPath", "currentLFFilename", "currentLDFClassString", "currentLELFCLASSName", "currentLDFFileString", "currentLELFClassPath", "currentLFclassString", "currentLFclassAlias", "currentLFFunctionAlias", "currentLDFFilename", "currentLFClassDesc", "currentLFFunctionPath", "currentLFCLASSPath", "currentLELFClassDesc", "currentLFCLASSAlias", "currentLFFunctionName", "currentLFClassString", "currentLFCLASSName", "currentLFclassPath"], "systemLFClassName": ["systemLFclassDesc", "systemLfClassName", "systemLFFullDesc", "systemLFPackagename", "systemLfPackageName", "systemLfClassDesc", "systemLFclassName", "systemLFFullString", "systemLfPackageString", "systemLFClassDesc", "systemLFclassString", "systemLFPackageDesc", "systemLFPackageCode", "systemLFFullName", "systemLfClassname", "systemLFClassname", "systemLfPackageCode", "systemLfPackagename", "systemLFPackageName", "systemLFPackageString", "systemLfPackageDesc", "systemLfClassCode", "systemLfClassString", "systemLFClassCode", "systemLFClassString"], "mainWindowElement": ["mainQueueEl", "mainFlowBuilder", "mainWebMember", "mainFrameFrame", "mainFrameEnvironment", "mainWebEngine", " mainWheelMember", "mainWheelEl", "mainWebBuilder", "mainWindowE", "mainFrameElement", "currentFrameEl", "mainTimeEl", "mainWindowAddress", "mainHostAddress", "mainMenuContainer", "mainMenuElement", "mainMenuEl", "mainFrameEl", "mainWindowsElement", "mainFlowEnvironment", " mainWindowMember", " mainWheelEl", "mainFlowEngine", "mainTimeelement", " mainWebElement", "centralWindowelement", "MainFrameE", "mainFlowObject", " mainWheelEnvironment", "MainWindowFrame", "mainGroupEnvironment", "mainFrameE", "MainFrameEl", " mainWindowBuilder", "mainWindowObject", "centralWindowElement", "centralFrameelement", "mainHostE", "mainStreamContainer", " mainHostE", " mainWindowEl", " mainWindowAddress", "mainWindowelement", "mainScreenelement", "mainFlowElement", "mainStreamElement", "currentWindowContainer", " mainWheelElement", "mainWebAddress", "mainStreamEl", "mainWindowsFrame", "mainWindowPage", "mainWindowEnvironment", "mainWindowEl", "MainWindowElement", "mainFrameelement", "mainWebElement", " mainWindowObject", " mainHostAddress", " mainHostBuilder", "currentWindowElement", "MainWindowE", "mainWebEnvironment", "mainMenuPage", "mainGroupEngine", "mainGroupObject", "mainWindowBuilder", "mainWebObject", "mainWebEl", "mainWheelElement", "mainWheelMember", "mainWindowEngine", "mainStreamPage", "mainWindowsE", "centralFrameElement", "mainWindowFrame", "mainWindowMember", "currentWindowPage", "mainFlowAddress", "MainFrameElement", "currentFrameElement", "mainHostBuilder", "mainFrameContainer", "mainScreenElement", "currentFrameContainer", "mainWindowContainer", "mainScreenEl", "mainWebE", "currentWindowEl", "currentFramePage", "centralFrameEl", "mainQueueElement", "mainGroupElement", "mainTimeElement", "centralWindowEl", "mainHostElement", " mainWindowEngine", " mainWebEnvironment", " mainWindowE", "mainFramePage", " mainWebEngine", "mainFlowE", "mainQueueFrame", " mainHostElement", "mainFrameMember", "mainWindowsEl", " mainWebObject", "MainWindowEl", "MainFrameFrame", " mainWindowEnvironment", "mainWheelEnvironment", "mainQueueE"], "volumeElement": ["VolumeEntry", "soundElement", "volumeLayer", "VolumeElement", "audioElement", "VolumeEl", "volumelement", "audioPart", "audiolement", "voiceContainer", "volumeEntry", "audioEntry", "volumeEngine", "volumeEl", " volumelement", "voiceLayer", "volumeContainer", "VolumeContainer", "soundPart", " volumeEntry", "audioEngine", "voiceEntry", " volumeContainer", "voiceElement", "audioLayer", " volumeLayer", "soundEl", "audioEl", "volumePart", " volumeEngine", "voiceEngine", " volumePart", "voiceEl", " volumeEl", "soundlement"], "player": ["live", "watch", "position", "act", "ayer", " Player", "ler", "layer", "monitor", "ater", "mor", "apper", "driver", "players", "roller", "active", "min", "Play", "er", "play", "handler", "audio", "aster", "video", "app", "part", "db", "profile", "plays", "playing", "game", "loader", "ower", "per", "e", "caster", "Player", "transfer", "ser", "par", "able", "ader", "file"]}}
{"id1": "7351534", "id2": "5632808", "code1": "    public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception {\n        InputSource source = null;\n        InputStream stream = null;\n        if (resolver != null) {\n            try {\n                source = resolver.resolveEntity(null, systemId);\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (source != null) {\n            try {\n                stream = source.getByteStream();\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (stream == null) {\n            URL url = new URL(systemId);\n            stream = url.openStream();\n        }\n        return stream;\n    }\n", "code2": "        @Override\n        public void respondGet(HttpServletResponse resp) throws IOException {\n            setHeaders(resp);\n            final OutputStream os;\n            if (willDeflate()) {\n                resp.setHeader(\"Content-Encoding\", \"gzip\");\n                os = new GZIPOutputStream(resp.getOutputStream(), bufferSize);\n            } else os = resp.getOutputStream();\n            transferStreams(url.openStream(), os);\n        }\n", "label": 0, "substitutes": {"getStreamFromSystemIdentifier": ["getStreamFromSystemIdentification", "getStreamFromsystemidentifer", "getStreamFromsystemidentifiers", "getStreamFromSystemIdification", "getStreamFromsystemIdentifiers", "getStreamFromSystemidentifiers", "getStreamFromsystemIdentifer", "getStreamFromSystemIdentifiers", "getStreamFromSystemIdifer", "getStreamFromSystemIdifier", "getStreamFromSystemIdifiers", "getStreamFromSystemIdentifer", "getStreamFromSystemidentifer", "getStreamFromsystemIdentification", "getStreamFromsystemidentifier", "getStreamFromsystemidentification", "getStreamFromSystemidentification", "getStreamFromsystemIdentifier", "getStreamFromSystemidentifier"], "systemId": ["serverid", " systemPath", "serverId", "ystemId", "systemID", "securityID", "systemName", "customID", "securityid", " systemName", "SystemName", "systemPath", "securityId", "serviceId", "customid", "customId", "ystemid", "ystemName", "customName", "serviceid", "securityName", "machineId", " systemid", " systemID", "sysid", "Systemid", "serverID", "machineID", "sysPath", "systemid", "SystemId", "SystemID", "ystemID", "servicePath", "machineid", "sysId"], "resolver": [" resolve", "presolve", "presolver", "Resolver", "resolving", "Resolution", "reolving", "resol", "resolve", "reolve", "Resol", " resol", "reol", "Resolving", "presolution", "resolution", "reolver", "presolving", " resolution", "reolution", "Resolve", " resolving"], "source": ["resource", "slave", "large", "class", "container", "entity", "seed", "position", "string", "instance", "channel", "resources", "context", "Source", "o", "spec", "proxy", "service", "scope", "response", "ource", "path", "text", "slice", "from", "sync", "client", "ce", "object", "creator", "handler", "unit", "connection", "document", "element", "storage", "model", "server", "component", "size", "sl", "iter", "e", "session", "i", "SOURCE", "remote", "result", "reader", "secure", "type", "ources", "parse", "data", "null", "target", "id", "parent", "uri", "info", "src", "name"], "stream": ["resource", "or", "row", "temp", "live", "wh", "speed", "clean", "string", "channel", "zip", "host", "context", "instance", "view", "proxy", "src", "service", "input", "response", "report", "log", "path", "cont", "feed", "dest", "length", "content", "child", "object", "handler", "trans", "flash", "valid", "document", "sw", "connection", "steam", "Stream", "model", "port", "event", "server", "load", "read", "sl", "pool", "session", "wrapper", "allow", "image", "result", "reader", "output", "data", "message", "parent", "client", "body", "form", "buffer", "file"], "url": ["resource", "large", "zip", "string", "channel", "host", "http", "proxy", "service", "ource", "URL", "path", "feed", "gl", "Url", "client", "object", "address", "loc", "l", "connection", "base", "server", "location", "loader", "sl", "link", "control", "image", "page", "ssl", "data", "id", "web", "uri", "src", "file"]}}
{"id1": "13666876", "id2": "755203", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"transformSingleFile": [" transformSingleFiles", "transformSinglePath", "transformMultifile", "transformOneSourceFile", "transformsingleSourceFile", "transformMultiFile", "transform1Path", "transformOneFile", "transformOnePath", "transformMultiFiles", " transformSingleSourceFile", " transformOneSourceFile", "transformMultiSourceFile", "transformSingleFiles", " transformSinglefile", "transformSinglefile", " transformOneFile", "transformsingleFile", "transform1Files", "transform1SourceFile", "transformOneFiles", "transformSingleSourceFile", "transform1File", "transformsingleFiles", " transformOnefile", "transformsinglefile", " transformSinglePath", " transformOnePath", "transformOnefile", " transformOneFiles"], "xed": [" xedited", "rexed", "xted", " Xed", " xED", "xED", "xteds", "rexeded", "xxeds", "xedited", "exEd", "xtEd", "exeb", "Xended", "xended", "exeds", "xxed", " xended", "xEd", "xxeded", "xeds", "exeded", "Xed", "rexED", "exed", "Xeded", "xxedited", "exED", "xxeb", " Xeds", "Xedited", "xxED", " Xeded", " xEd", " xeds", " xeded", "xtED", "xxended", "xeded", "xeb", " Xeb", "rexeds"], "node": ["slave", "row", "root", "live", "route", "day", "instance", "op", "option", "Node", "copy", "path", "shape", "none", "tree", "object", "child", "no", "loc", "document", "part", "event", "query", "component", "load", "location", "config", "index", "set", "image", "page", "error", "menu", "message", "parent", "source", "ode", "leaf", "name", "file", "edge"], "dob": ["dub", " dOb", "adod", "ddod", "ddOb", "ddob", "dOB", "adub", "DOb", " dub", "dOb", "adOB", "ddOB", "Dub", " dOB", "Dob", "adob", "DOB", " dod", "ddub", "dod"], "mySrc": ["MyAsrc", "mysRC", "mysrb", " mySst", "mySst", " myEsst", "myAssrc", "myAsrb", "myAsRC", "myEssrc", " myEsrc", "MySRC", " myEssrc", "MySrc", "mySRC", "MyEsRC", "MyEsrb", " myEsRC", "myDrc", "MyAsource", "MySource", "myDsource", "MyEsrc", " mySsrc", "myDst", "myDsrc", "myEsrb", "myAsst", "myAsrc", "myEsource", "myssrc", "mySrb", "MyEssrc", "myEsrc", " mySRC", "mySsrc", "myDssrc", "MyAssrc", "mysrc", "myEsst", "MySsrc", "myEsRC", "MyAsRC", "myAsource", "myDRC", "mySource", "myDsRC", "MySrb"], "mySrcF": ["myCrcM", "mySourceE", "mySRCM", "myCrcF", "myEssrcFile", "myCrcE", "myEsrcf", "myCRCF", "mySourceF", "mySrcf", "myCRCE", "myCRCf", "myCRCM", "mySsrcf", "mySRCE", "mySrcFile", "myEssrcF", "mySckM", "myCrcf", "mySourceFile", "mySsrcFile", "mySourcef", "myEssrcE", "mySRCFile", "myEsrcE", "mySsrcF", "myEsrcF", "mySRCf", "myEsrcFile", "mySrcM", "mySckE", "mySrcE", "mySsrcE", "myEssrcf", "mySckF", "mySsrcM", "mySckf", "mySRCF"], "myOutF": [" myOutputC", "myoutFF", "MyInQ", "myoutFile", "myoutF", "myOutFile", "MyInPF", " myOutC", "myInD", "MyInF", "myOUTF", "myInQ", "MyOutD", "myOutE", "myOUTFF", "myOutPF", "myInPF", "myOutFF", "MyOutFile", "myOutputFile", "myInF", "MyOutPF", "myOutC", "myOutD", "MyOutQ", " myOutE", "myOutQ", "myOUTD", "myoutPF", "myOutputC", " myOutFile", "MyInFile", "myOUTFile", "myInC", "myOutputF", " myOutputFile", "myInE", "myoutE", "MyOutE", "myOUTQ", " myOutputF", " myOutputE", "myoutC", "myOUTE", "myInFF", "MyInD", "myOUTPF", "MyInE", "MyOutF", "myInFile", "MyOutFF", "myOutputE", "MyInFF"], "co": ["che", "fe", "cho", "ctrl", "pc", "fc", "cmp", "gro", "so", "ob", "c", "oe", "cache", "ca", "o", "ko", "fo", "ee", "cca", "ci", "con", "can", "colo", "la", "flo", "cf", "OO", "cu", "CO", " Co", "ce", "no", "loc", "CC", "cc", "ico", "mc", "BO", "rc", "pe", "coll", "cur", "cos", "bc", "company", "isco", "code", "bo", "auto", "cb", "lo", "bb", " CO", "po", "oo", "Co", "coe", "conf", "aco", "ck", "mo", "lc"], "x3dvFile": ["x3dvSource", "x3rdVFiles", "x3rdVfile", "x3dvsFiles", "x3dsvSource", "x3ndvFiles", "x3ndvFile", "x3dfFile", "x3dvsfile", "x3dvFiles", "x3dvfile", "x3dVPage", "x3dVSource", "x3rdVFile", "x3dfFiles", "x3dvsFile", "x3dsvfile", "x3ndsvFile", "x3rdvFiles", "x3ndsvSource", "x3ndvfile", "x3dsvFile", "x3dfSource", "x3rdvfile", "x3dffile", "x3dsvPage", "x3rdvPage", "x3rdVPage", "x3ndsvFiles", "x3dVFiles", "x3dvsPage", "x3ndvSource", "x3ndsvfile", "x3dsvFiles", "x3dVFile", "x3dVfile", "x3dvPage", "x3rdvFile"], "fis": ["elfisa", "refiss", "fus", " fs", "elfus", "refi", " fiss", "elfbs", "Fs", "fs", "Fus", "refisa", "refis", "fbs", " fi", "elfi", "fi", "elfs", " fus", "fisa", "elfis", "elfiss", "Fis", " fbs", "Fbs", "fiss", " fisa"], "gzos": ["wxo", "bagops", "zipo", "zxops", "bagOS", "gzops", "gzo", "zxOS", "bagos", "bagis", "bago", "zipos", "zipis", "wxis", "zxis", "gzOS", "zxos", "zxo", "zo", "zipops", "zops", "wxos", "zis", "zos", "wxOS", "zipOS", "zOS", "gzis"], "buf": ["done", "bh", "grab", "vec", "cas", "cv", "bin", "bd", "box", "queue", "la", "pad", "seq", "loc", "fab", "batch", "br", "bag", "ff", "uint", "lb", "port", "cur", "bc", "block", "len", "av", "uf", "cap", "uc", "bytes", "cb", "result", "data", "feat", "Buff", "b", "fb", "buff", "ba", "bf", "buffer", "ab", "rb", "db", "dec"], "ret": ["det", "rep", "ry", "reply", "fin", "fun", "continue", "ft", "match", "rt", "bit", " RET", "num", "rf", "count", "default", "rc", "out", "rets", "reg", "f", "len", "success", "pet", "val", "res", "result", "nt", "repl", "att", "obj", "alt", "r", "b", "en", "bf", "id", "Ret", "ver", "RET", "re", "ref"]}}
{"id1": "5125848", "id2": "9272325", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {\n        HttpURLConnection urlConn = null;\n        try {\n            String params = generatorParamString(parameters);\n            URL url = new URL(reqUrl);\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setRequestMethod(\"POST\");\n            urlConn.setConnectTimeout(5000);\n            urlConn.setReadTimeout(5000);\n            urlConn.setDoOutput(true);\n            byte[] b = params.getBytes();\n            urlConn.getOutputStream().write(b, 0, b.length);\n            urlConn.getOutputStream().flush();\n            urlConn.getOutputStream().close();\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n        return urlConn;\n    }\n", "label": 0, "substitutes": {"combineJs": ["combinScript", "combinedjs", "Combinatejs", "combinateJs", "combinateScript", "combinedJS", "CombineScript", "CombinateJs", "CombinateJS", "combinJs", "combinateJS", "combineScript", "combinatejs", "combinjs", "Combinejs", "combineJS", "combinejs", "CombineJs", "CombinateScript", "combinJS", "CombineJS", "combinedScript", "combinedJs"], "base": ["resource", "root", "bot", "string", "cache", "site", "http", "area", "proxy", "log", "api", "absolute", "address", "build", "store", "Base", "part", "out", "prefix", "builder", "server", "config", "f", "bas", "based", "home", "image", "page", "relative", "data", "b", "info", "source", "uri", "db", "file", "ref"], "linkJs": [" linkJS", "linkedScript", "linkedjs", "linkedJS", "linkedJs", "linkLinks", "loadScript", "linkedLinks", " linkLinks", "loadjs", "loadJS", "likeLinks", "likeJs", " linkScript", " linkjs", "likejs", "likeJS", "linkJS", "linkScript", "loadJs", "linkjs"], "newFiles": ["oldResources", "addResources", "newfiles", "newLinks", "oldLinks", "oldfiles", "addLinks", "addfiles", " newfiles", " newLinks", "oldFiles", " newResources", "newResources", "addFiles"], "dir": ["folder", "or", "root", "local", " block", "keep", "container", "zip", "cache", "ir", "http", "d", " repo", "dist", " Dir", "src", "log", "manager", "in", " folder", "wd", "div", "object", " db", "DIR", "download", "loc", "build", " d", "out", "domain", " module", " director", "work", " dep", "session", "home", "Dir", " directory", "lib", "editor", "relative", "directory", "direction", " download", "md", "module", "b", "plugin", "id", "lock", "uri", "source", "dep", "db", "file", " manager"], "name": [" zip", " root", " dest", " repo", " abs", " title", " app", " folder", " suffix", " cache", " prefix", " info", " relative", " id", " module", " parent", "Dir", " bundle", " head", " resource", " source", " init", " build", " manager"], "minDir": [" minManager", "minDriver", "tempdir", " minDriver", " minFile", "MinFile", " minMin", "initManager", "minJar", " minDb", " minDirectory", "tempMin", "miniFile", "minFile", "versionFolder", "versionManager", "MinDir", " minFolder", "MinJar", "minDest", "versionDirectory", "MinDest", " minDest", "MinDb", "blockdir", "minMin", "miniDest", "Mindir", "blockDriver", "miniDir", "MinMin", "blockFile", "initDirectory", "blockDir", "minDb", "minFolder", " mindir", " minJar", "versionDir", "tempJar", "initDir", "mindir", "minDirectory", "minidir", "miniDriver", "miniDb", "tempDir", "initFolder", "minManager"], "combineFile": ["combinedDir", "combinedWriter", "combicateSourceFile", "combineReader", "combicateLog", "combinateDir", "combinerWriter", "CombinateWriter", "combinateWriter", "combinerFile", "comboseWriter", "joineDir", "CombineLog", "joinateFile", "CombineFile", "combineLog", "combinerSourceFile", "joinateDir", "combinateLog", "combinedFile", "comboseDir", "combinedReader", "joinateWriter", "combinateSourceFile", "combinerLog", "joinateReader", "CombineWriter", "combicateWriter", "comboseFile", "joineFile", "combineDir", "joineReader", "combinateFile", "CombineSourceFile", "CombinateLog", "CombinateSourceFile", "combicateFile", "combineSourceFile", "comboseReader", "CombinateFile", "joineWriter", "combinateReader"], "concatFile": ["conateDir", "ConcatStream", "concatStream", "concentDir", "concentWriter", "Concatfile", "concatsWriter", "concatfile", "concStream", "concfile", "conateFile", "concentStream", "concatDir", "concFiles", "concatFiles", "Concatsfile", "conatefile", "concatsFiles", "concatsfile", "concentFile", "concFile", "ConcatsDir", "concWriter", "ConcatsFiles", "concatsStream", "conateFiles", "ConcatFiles", "ConcatDir", "concatsDir", "ConcatsStream", "ConcatsFile", "concDir", "ConcatsWriter", "ConcatFile", "ConcatWriter", "concatsFile"], "combineWriter": ["combiseFile", "combineWalker", "combineReader", "combinerWalker", "combinerWriter", "combiseReader", "combinateWriter", "comboseWriter", "combinerRW", "CombineFile", "mixinerRW", "combinateReader", "mixineRW", "ComboseFile", "comboseRW", "CombineWrite", "combinerReader", "combideReader", "comboseWrite", "CombineReader", "mixineWriter", "mixinerWalker", "combiseWriter", "combinateWrite", "CombineWriter", "mixinerReader", "comboseFile", "combinateFile", "combideWriter", "ComboseReader", "combiseWrite", "comboseWalker", "mixineReader", "mixineWalker", "ComboseWrite", "combineRW", "combideWalker", "comboseReader", "combineWrite", "mixinerWriter", "ComboseWriter", "combideRW"], "concatWriter": ["convertFile", "ConcatWrite", "syncWriter", "concilFile", "syncatFile", "concatsWriter", "syncWrite", "syncatReader", "syncatWrite", "concWrite", "convertWrite", "convertDriver", "syncFile", "convertWriter", "concilDriver", "concilWrite", "concatsDriver", "concatsFile", "concFile", "ConcatDriver", "concWriter", "concatDriver", "concReader", "concatReader", "convertReader", "concilWriter", "concatsReader", "ConcatsDriver", "syncReader", "ConcatsWrite", "syncatWriter", "ConcatsFile", "ConcatsWriter", "ConcatFile", "concatWrite", "ConcatWriter", "concatsWrite"], "fails": ["Fls", "foralls", "frors", "forils", "failed", "ifils", "infails", "ifails", "infils", "fakes", "Fails", "fils", "Falls", "Fakes", "faults", "Fils", " fls", "dfils", "Failing", "Frors", "Faults", "failing", "dfailed", "ifls", "dfails", "tails", " frors", " fils", "dfailing", " fakes", " failing", "tls", "tils", "trors", "Failed", " failed", "forails", "falls", "infaults", "ifakes", "foraults", "fls", "infalls"], "link": [" page", " item", "line", "Link", " node", " config", " tag", "comment", " inline", "open", "match", "add", "linked", " comment", "address", "bug", "loc", " http", " document", "dd", " site", "l", "connection", " location", " module", "load", " entry", "e", "li", "ink", " html", "image", " anchor", " target", "links", " resource", "follow", "parse", " lang", " source", "style", "message", " Link", "uri", "info", "block"], "path": ["entry", "attribute", "route", "class", "string", "href", "step", "Path", "pointer", "script", "node", "input", "key", "attr", "wd", "content", "loc", "location", "code", "value", "ath", "filename", "data", "type", "PATH", "point", "id", "pattern", "info", "uri", "source", "text", "src", "file"], "url": ["resource", "pull", "route", "string", "channel", "host", "http", "xml", "str", "www", "URL", "log", "api", "open", "key", "Url", "download", "ri", "address", "build", "loc", "browser", "l", "connection", "server", "location", "loader", "sl", "f", "image", "result", "html", "ssl", "page", "data", "r", "b", "web", "uri", "stream", "source", "file"], "inputStream": ["outputChannel", "InputReader", "outputWriter", "inputFile", "inputWriter", "inputChannel", "outputStreamer", "InputChannel", "outputFile", " inputFile", "downReader", "inputstream", "InputWriter", "downStream", " inputstream", "inputStreamer", "InputFile", "Inputstream", "inputReader", "InputStreamer", " inputWriter", "downFile", "outputReader", "InputStream", "outputstream", "downStreamer", " inputChannel"], "jsFile": [" jsStream", "Jsfile", "javascriptWriter", "jsSource", "javascriptSource", "javascriptDir", "JsLog", "scriptPath", " jsWriter", "jsWriter", " jsLog", "jsReader", "jsfile", "jsPath", "JsStream", "javascriptLog", "jsDir", "JsFile", "jsonSource", " jsfile", "scriptFile", "jsonPath", "scriptSource", "javascriptStream", "jsonFile", "JsReader", "JsWriter", "jsonDir", "jsLog", "javascriptPath", " jsReader", "javascriptReader", "javascriptfile", "jsStream", "javascriptFile", "scriptDir"], "fileName": ["fileSize", " fileSize", "fileNumber", "FileNumber", "filePath", "resourcePath", "FilePath", " filePath", "resourceNumber", "FileName", "resourceName", "resourceSize", "FileSize", " fileNumber"], "outputStream": ["responseSteam", "Outputstream", "outputSteam", "OutputStream", " outputWriter", "responseStream", "resourceSteam", "outputWriter", "inputFile", "inputWriter", "outputFile", "resourceReader", "OutputFile", " outputSteam", "responseWriter", " outputReader", "OutputWriter", "responseReader", "OutputSteam", "resourceStream", " outputstream", "OutputReader", "resourcestream", " outputFile", "outputReader", "outputstream", "inputSteam"], "first": ["root", "each", "use", "again", "full", "th", "current", "initial", "right", "self", "same", "prev", "then", "primary", "only", "second", "user", "count", "it", "alpha", "p", "default", "First", "must", "all", "replace", "left", "now", "other", "third", "before", "success", "start", "top", "auto", "split", "result", "last", "next", "error", "st", "found", "stack", "always", "required", "one"], "reader": ["resource", "entry", "reads", "context", " Reader", "reading", "xml", "inner", "input", "report", "io", "feed", "driver", "in", "object", "er", "handler", "dd", "rc", "server", "config", "loader", "read", "Reader", "f", "e", "image", "h", "writer", "data", "r", "parser", "info", "source", "stream", "buffer", "builder", "file"], "jsCompressor": ["jsRepression", " jsCompression", "jsExporter", "jsExpress", "jsReporter", "jsCompress", " jsCompress", "jsRepressor", "jsExpression", "jsExpressor", "jsRepress", " jsComporter", "jsCompression", "jsComporter"], "s": ["words", "S", "ings", "ses", "g", "n", "ens", "m", "lines", "is", "sets", "scripts", "gs", "gets", "abs", "objects", "os", "sys", "groups", "xs", "ing", "fs", "l", "qs", "strings", "ls", "ws", "ments", "ns", "ions", "types", "v", "states", "ts", "ps", "comments", "t", "en", "es", "ss"], "s1": ["ings2", "ysB", "s81", "es2", "ys01", "ats2", "sPre", "ets2", "atsPre", "esAP", "esB", "qs2", "es1", "esPre", "ings1", "ys1", "ets1", "es81", "sB", "etsPre", "ys2", "sAP", "etsAP", "qs81", "sIP", "qs1", "ingsB", "es01", "esIP", "qsIP", "atsAP", "s01", "ats1", "ings01"], "i": ["si", "qi", "ip", "u", "ii", "c", "m", "pi", "o", "is", "d", "ic", "z", "ui", "bi", "ing", "p", "l", "phi", "w", "j", "I", "ifier", "x", "f", "e", "q", "a", "v", "b", "xi", "t", "id", "ik"], "s2": ["ings2", "sSecond", "es2", "ets62", "sCloud", "ets2", "es82", "ets82", "qs2", "es1", "qsSecond", "ets1", "es12", "s62", "etsSecond", "es62", "sets2", "ings12", "etsCloud", "s12", "ls1", "qs1", "esCloud", "qs12", "esSecond", "lsSecond", "sets82", "ls62", "ingsSecond", "setsCloud", "ls2", "s82", "ings1", "sets1"], "i1": ["iOne", "a1", "e0", "sFirst", "eFirst", "eOne", "a2", "l2", "pi1", "sOne", "a9", "iFirst", "i2", "s4", "l0", "pi2", "l1", "pi9", "e1", "lOne", "pi0", "i9", "s9", "pi4", "e2", "piFirst", "i4", "s0", "i0", "a4"]}}
{"id1": "5760649", "id2": "8216539", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"createFile": ["CreateFile", "saveContent", "saveResource", "CreateContent", " createResource", " createFolder", "createContent", "createResource", "saveFile", "CreateResource", " createContent", "CreateFolder", "saveFolder", "createFolder"], "src": ["resource", "txt", "rss", "username", "SourceFile", "string", "resources", "href", "Source", "ruby", "input", "path", "sc", "buf", "slice", "files", "dest", "content", "fn", "loc", "proc", "gb", "s", "rc", "rob", "upload", "url", "load", "sb", "sl", "fp", "cb", "ssl", "img", "secure", "data", "obj", "r", "rb", "sit", "source", "stream", "uri", "sel", "name", "file"], "filename": ["resource", "txt", "route", "username", "SourceFile", "string", "utf", "sf", "title", "Filename", "path", "fil", "files", "rl", "length", "fn", "l", "s", "prefix", "ename", "url", "location", "loader", "f", "FILE", "ames", "dll", "ame", "fp", "nil", "directory", "output", "acl", "feat", "metadata", "uri", "source", "wb", "name", "which", "file"], "fis": ["cfais", "fIS", "Fiss", " fais", "sfis", " fiss", "fris", "fais", "fbs", "FIS", "sfris", " fris", "Fais", " fIS", "Fis", "sfiss", "Fos", "cfis", "cfIS", " fbs", "cfris", "Fris", "Fbs", "fiss", "cfbs", "sfos", "cfos"], "fos": ["foros", "affos", "sfis", " fops", " fOS", "fbos", "fios", "affis", "bios", "affbos", "bos", "fops", "Fops", "fas", " fios", "foris", " fas", "sfios", "fOS", "affios", "Fis", "Fos", "Fios", "FOS", "forOS", "bis", "bbos", "sfops", "Fas", "Fbos", "foras", "sfos"]}}
{"id1": "23273706", "id2": "942693", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectDocumentMeta", "getProjectTreeInfo", "getProjecttreeData", "getprojecttreeInfo", "getprojecttreeDATA", "getProjectPageData", "getprojectTreeData", "getProjecttreeDATA", "getProjectTreeDATA", "getProjecttreeInfo", "getProjecttreeMeta", "getprojectTreeDATA", "getProjectPageInfo", "getprojectTreeMeta", "getprojecttreeData", "getprojecttreeMeta", "getProjectTreeMeta", "getProjectDocumentData", "getprojectTreeInfo", "getProjectPageMeta", "getProjectDocumentInfo", "getProjectPageDATA", "getProjectDocumentDATA"], "treeData": ["treeDec", "reeArray", "bodyDat", "TreeInfo", " treeText", "treeString", "reeString", "storyData", "monkeyArray", "bodyList", "storyDec", "reeData", "contentDat", "treeText", "TreeArray", " treeDec", "treeList", "contentInfo", "storyArray", "TreeData", " treeArray", "bodyData", " treeString", "reeText", "bodyString", "treeInfo", " treeList", "reeInfo", " treeInfo", "reeDat", "contentText", " treeDat", "monkeyDat", "TreeString", "treeDat", "storyDat", "monkeyDec", "monkeyData", "treeArray", "TreeList", "reeList", "contentData"], "filename": ["folder", "txt", "username", "SourceFile", "string", "jpg", "kj", "xml", "title", "Filename", "path", "kn", "fd", "fil", "sheet", "whatever", "files", "database", "ppa", "framework", "fn", "prefix", "tmp", "upload", "url", "location", "dylib", "FILE", "dll", "password", "journal", "figure", "fp", "ername", "directory", "nil", "data", "wav", "metadata", "kl", "uri", "name", "file"], "urlString": ["URLstring", "addressStr", "URLUrl", "locationUrl", "locationString", "urlStr", "addressURL", "addressString", " urlURL", "locationStr", "URLStr", "addressstring", "URLString", " urlstring", "URLURL", "urlUrl", " urlStr", "locationstring", " urlUrl", "urlstring", "urlURL"], "urldata": ["urlddata", "URldata", "URlfdata", " urLDATA", "URldATA", "urLDdata", "urlfdata", "urlledta", "urlledata", "urldATA", "urledata", "urlfat", "urLDta", "urleddata", "urLDat", "urlleddata", "urlfATA", "urlldata", "urledATA", "urlfata", " urLDta", " urlddata", "URlfat", "urLDATA", "URldat", "urLData", " urldta", "urldat", "URlddata", " urldATA", "urllATA", " urLData", "urlledATA", "URlfata", " urLDdata", "urllat", "URlfATA", "urldta", "urledta", "urllata"], "factory": [" flier", "ufictionary", "confFactory", "cFactory", "fault", "cfFactory", "fFactory", " filler", "cfiller", "liller", "lactory", "ufiller", "confiller", "filler", "cflier", "luild", "pault", " fault", "cactory", "flier", "pFactory", "fictionary", "ufactory", "lictionary", " fuild", "cfactory", " fictionary", " fFactory", "ufuild", "cault", "ciller", "pactory", "conflier", "fuild", "confactory", "piller"], "parser": ["root", "ger", "pdf", "library", "string", "instance", "jack", "xml", "http", "utils", "raf", "manager", "api", "util", "monkey", "driver", "json", "er", "handler", "p", "up", "l", "ph", "s", "Parser", "loader", "fruit", "lp", "auto", "arser", "writer", "reader", "se", "parse", "r", "b", "plugin", "t", "parent", "uri", "builder"], "u": ["iu", "eu", " ur", "us", "uu", "c", "ru", "o", "http", "universal", "d", "U", "ur", "io", "util", "yu", "ui", "uv", "cu", "p", "l", "s", "plug", "url", "su", "uf", "ul", "hu", "ou", "tu", "b", "uri", "nu", "uni", "lu"], "is": ["ib", "or", "us", "isa", "ip", "ios", "serv", "ob", "isl", "pi", "ir", "http", "iris", "has", "as", "gets", "io", "api", "ais", "IS", "abs", "ui", "in", "ri", "are", "ie", "p", "fs", "it", "obs", "init", "s", "Is", "iso", "iss", "ar", "ops", "its", "ori", "mis", "bis", "lis", "isu", "ai", "es", "info", "uri", "ris"], "os": ["or", "us", "ms", "ol", "ios", "so", "bs", "ens", "ob", "osi", "o", "dos", "opens", "http", "oa", "fits", "oss", "as", "gets", "io", "sys", "aos", "bos", "oes", "oos", "fs", "ose", "obs", "s", "pos", "los", "iso", "ops", "cos", "Os", "oses", "ros", "bis", "ils", "ps", "es", "OS"], "iBufSize": ["iBytebufSize", "iLlfSt", "iLlfsize", "iBytebufsize", "iBytebufLength", "iBlfLen", "iBlfLength", "iByteufSize", "iBufferLength", "iBytebufLen", "iBufferSt", "iLlfLength", "iBufLen", "iByteufLen", "iLufSize", "iByteufLength", "iBufsize", "iBbufSize", "iBlfSt", "iLlfSize", "iBbufLen", "iBuffLength", "iBlfSize", "iBuffSt", "iBuffsize", "iBufSt", "iBufferSize", "iBuffersize", "iBbufLength", "iByteufsize", "iBlfsize", "iBufLength", "iLufsize", "iLufSt", "iBbufsize", "iLufLength", "iBuffLen", "iBuffSize"], "inBuf": ["outBuffbuf", "inBbuf", "inCuff", "outBuffub", "outBub", "outBuffuf", "inBlump", "inFbuf", "inBuffump", "inBunk", "inFaf", "inDbuf", "inBuff", "inCbuf", "inbuf", "inCunk", "inPlunk", " inBump", "inCump", "inDuf", "inBump", " inCbuf", "inFuff", " inBunk", " inFaf", "inPlbuf", "inBluf", " inFuff", "outBump", " inBaf", " inBbuf", "inBlbuf", "inBuffuf", "inbub", "inPluf", "inCuf", "inFuf", "inDuff", "inBub", "inBuffbuf", "inPlump", " inCunk", "inbump", "inBlub", "outBuffump", "inDaf", " inCuf", " inBuff", "outBuf", "inCaf", "inBlunk", " inFbuf", "inBuffub", "outBbuf", "inBaf", "inbbuf", " inCump", " inFuf"], "iNumRead": ["iValBuild", "iChanBuild", "pNumWritten", "iChanRead", "pNumread", "qiNumBuild", "qiValBuild", "iFatWritten", "iNumberBuild", "qiNumRead", "inumWritten", "inumRead", "qiNumREAD", "pNumberRead", "pNumberWritten", "iNumberREAD", " iFatWrite", "pNumWrite", "iNumberWrite", "iLenWritten", "iNumread", "qiValread", "inumread", "iLenRead", "iChanread", "iNumberWritten", "iFatRead", " iFatWritten", "inumWrite", "iNumWritten", "pNumberread", "iNumberRead", "iValread", " iNumWrite", "iChanREAD", "qiNumread", "iNumBuild", "pNumRead", "iLenWrite", "iNumWrite", "qiValREAD", "pNumberWrite", " iFatRead", "iValRead", "iNumREAD", "qiValRead", " iNumWritten", "iFatWrite", "iValREAD", "iNumberread"], "f": ["fa", "df", "fe", "fr", "F", "fc", "full", "g", "c", "n", "m", "o", "sf", "d", "fd", "io", "feed", "fn", "handler", "p", "fs", "l", "ff", "s", "j", "fi", "e", "uf", "h", "fp", "v", "r", "b", "t", "file", "rf"], "inputstream": ["outputchannel", "inputsystem", "inputsw", " inputStream", "inputStream", "contentsw", "outputStream", "Inputsystem", "Inputchannel", "contentstream", "Inputstream", " inputchannel", "contentStream", " inputsw", "InputStream", "contentsystem", "outputstream", " inputsystem", "Inputsw", "inputchannel"], "document": ["window", "media", "container", "project", "n", "m", "context", "xml", "d", "language", "node", "response", "list", "tree", "doc", "Document", "content", " documents", "object", "p", "l", "Documents", " documentation", "office", "e", "director", "dom", "record", "page", "html", "output", "DOM", "data", "directory", "docs", "ocument", "null", "t", "info", "source", "parent", "collection", "file"], "nodelist": ["Nodemark", "NODestyle", "nonedette", " nodeselist", "nodeestate", "Nodestyle", "nonedename", " nodesename", "nozelist", "snodselist", "anodedelist", "anodedestate", "anodedeme", "nODeline", "nozels", "anodata", "nozemark", "nodesh", "nODestyle", "nodeeme", "nodeata", " nodename", "anodeme", "nODesh", "nodedestyle", "nodename", "nodeelist", "nondeme", "nodesels", "snodeline", "anodedata", "nodeline", "nondelist", "Nodesh", "nodeme", "nondestate", "nodedata", "Nodelist", "nodata", " nodesels", "nonedels", "nodedlist", "snodelist", " nodels", "nodedeline", "NODelist", "nodlist", "nodsette", "nonedelist", "nozestyle", "nozename", "nodestate", "nODemark", "nozette", "nodselist", "nODette", "nODlist", "nodeselist", "anodestate", "snodette", "nODelist", "NODemark", "nodedeme", " nodette", "nodels", "nodestyle", "snodsette", "snodlist", "anodelist", "nodette", "nodseline", "nondata", "nozesh", "nodedelist", "nodesename", " nodesette", "snodslist", "snodseline", "nodedesh", "nodedette", "nodedemark", "nodedestate", "NODesh", "nodemark", "nodslist", "nodesette"], "num": ["span", "temp", "nb", "multi", "n", "zero", "m", "col", "um", "total", "mult", "node", "sum", "con", "np", "norm", "number", "NUM", "div", "umi", "nr", "mu", "count", "unit", "Num", "loc", "om", "comb", "part", "net", "init", "pos", "max", "index", "len", "ul", "nom", "lim", "dom", "tri", "mon", "en", "nam", "inc", "nu", "uri", "dim", "uni"], "i": ["iu", "hi", "si", "qi", "chi", "ip", "multi", "g", "ii", "ini", "c", "pi", "col", "o", "y", "m", "d", "ci", "di", "io", "slice", "ji", "ui", "in", "ri", "bi", "ie", "p", "it", "l", "part", "phi", "j", "I", "eni", "fi", "x", "index", "cli", "isi", "oi", "li", "ori", "a", "start", "v", "gi", "ti", "mi", "ai", "yi", "b", "xi", "id", "info", "uri", "iv", "ix", "mu", "ik"]}}
{"id1": "7006052", "id2": "19251426", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copySourceFileInfo", " copyFilesFrom", " copyFileFrom", "copySourceFileFile", "copySourceFileFrom", " copyFilesFile", " copyFileFile", "copyfileTo", "copyfileInfo", "copyfileFrom", "copyFilesInfo", "copyFileInfo", "copyFilesFile", "copySourceFileTo", "copyFileFile", " copyFilesTo", "copyFileFrom", " copyFileInfo", "copyfileFile", "copyFilesFrom", "copyFilesTo", " copyFilesInfo"], "src": ["resource", "txt", "js", "string", "href", "old", "path", "sc", "slice", "sync", "archive", "fn", "loc", "sup", "s", "rc", "upload", "url", "config", "sl", "sb", "code", "filename", "image", "sin", "inf", "remote", "img", "data", "b", "sub", "rs", "source", "stream", "uri", "sel", "rb", "file"], "dest": ["folder", "txt", "temp", "done", "route", "project", "opt", "dist", "bin", " Dest", "desc", "die", "dir", "loc", "sup", "comb", "default", "orig", "tmp", "delete", "flat", "des", "home", "filename", "Dest", "result", "img", "output", "test", "data", "secure", "target", "b", " destination", "sub", "source", "const", "wb", "name", "later"], "destFile": ["targetFile", "destF", " destinationF", "destDir", " destinationFiles", " destinationDir", " destF", "destfile", "destFiles", " destinationFile", "Destfile", "DestF", "DestFile", "targetFiles", " destFiles", "DestDir", " destDir", "DestFiles", "targetfile", "targetDir", " destfile"], "in": ["In", "pass", "again", "n", "ini", "IN", "cin", "is", "din", "inner", "bin", "input", "con", "pin", "ins", "impl", "inn", "err", "kin", "trans", "up", "l", "init", "win", "s", "lin", "rin", "url", "gin", "thin", "f", "inside", "i", "nin", "image", "socket", "login", "reader", "diff", "data", "r", "inc", "id", "source", "stream", "ln"], "out": ["again", "n", "cache", "o", "exp", "ex", "inner", "bin", "Out", "copy", "log", "outer", "io", "post", "sync", "this", "ac", "conn", "user", "err", "up", "part", "net", "w", "exec", "work", "cos", "pool", "other", "off", "image", "writer", "plain", "ext", "output", "data", "obj", "OUT", "null", "inc", "parent", "client", "one", "file", "extra"], "buf": ["bh", "vec", "map", "cache", "c", "cas", "cv", "bin", "path", "ctx", "bd", "box", "queue", "pad", "length", "seq", "loc", "batch", "br", "bl", "bag", "ff", "orig", "rc", "tmp", "bc", "Buffer", "pool", "block", "off", "blocks", "uf", "cap", "uc", "bytes", "cb", "v", "result", "data", "raw", "b", "bf", "buff", "fb", "buffer", "rb"], "len": ["line", "n", "c", "fin", "Len", "fd", "num", "length", "no", "min", "count", "ie", "l", "part", "base", "pos", "all", "coll", "url", "size", "f", "iter", "off", "pre", "ind", "cap", "el", "split", "li", "val", "bytes", "lim", "nt", "data", "fl", "en", "id", "lf", "rev", "body", "ln", "lc", "end"]}}
{"id1": "21827619", "id2": "3536332", "code1": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"SHA1": ["sha256", "sha384", "HA384", "shaOne", "HAOne", " SHAOne", "SHAOne", " SHA256", "HA256", "SHA384", "sha1", "SHA256", "HA1", " SHA384"], "text": ["struct", "txt", "font", "class", "token", "Text", "string", "word", "secret", "str", "version", "input", "EXT", "path", "key", "hex", "number", " Text", "this", "in", "content", "object", "letter", "translation", " TEXT", "connection", "url", "contract", "config", "code", "value", "password", "image", "format", "editor", "TEXT", "ext", "test", "output", "data", "obj", "message", "pattern", "source", "name", "template"], "UnsupportedEncodingException": ["UnsupportedEncoderception", "UnsupportedEncodedException", "UnsupportedEncoderEx", "UnsupportedEncodedception", "UnsupportedEncasingEx", "UnsupportedEncodedEx", "UnsupportedEncasingception", "UnsupportedEncodingception", "UnsupportedEncasingException", "UnsupportedEncoderException", "UnsupportedEncodingEx"], "md": ["df", "mb", "mp", "mg", "pd", "ms", "pm", "od", "mand", "rm", "mac", "map", "m", "Cmd", "sm", " MD", "d", "sha", "di", "MD", "bd", "meta", "wd", "mode", "hd", "ad", "dd", "valid", "mc", "ld", "cd", "mod", "cmd", "mn", "ma", "mag", "code", "am", "gd", "ind", "hash", "dm", "editor", "nm", "amd", "data", "dig", "mm", "metadata", "bf", "vd", "message", "mad", "mt", "me", "body", "mo"], "sha1hash": ["sha2h", "wa5hex", "sha64copy", "sha11sha", "SHA1hash", "sha4Hash", "SHA2Hash", "sha11hash", "SHA1sum", "sha1hex", "wa5copy", "wa1sum", "wa5hash", "sha4copy", "sha5copy", "wa1copy", "sha2sum", "sha5sum", "wa5sum", "SHA1sha", "sha4sum", "sha5hex", "sha4hex", "sha1Hash", "sha4sha", "sha5hash", "sha1copy", "sha256sum", "sha1sum", "SHA2h", "sha2sha", "sha256hash", "sha64hash", "sha64hex", "SHA1Hash", "SHA2sum", "sha4hash", "sha2Hash", "sha256Hash", "sha4h", "sha2hash", "wa1hash", "sha64sum", "SHA2hash", "sha256h", "sha1h", "SHA1h", "sha11sum", "wa1hex", "SHA2sha", "sha1sha"]}}
{"id1": "19739421", "id2": "88047", "code1": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"UnknownOptionException": ["UnknownParameterception", "UnknownOptionError", " UnknownOptionsception", "UnknownOptionception", "UnknownOperationception", " UnknownOptionsException", "UnknownOperationError", " UnknownOptionsError", "UnknownOperationException", "UnknownParameterError", "UnknownOptionsError", "UnknownOptionsception", " UnknownOptionception", "UnknownParameterException", " UnknownOptionError", "UnknownOptionsException"], "cmdLineParser": ["cmdLinearser", "mdLineReader", "cmdLinParser", " cmdLarser", "cmdlineparser", "mdLineBuilder", "cmdSiteParser", "cmdBlockBuilder", "mdLineRunner", "cmdlineReader", "cmdLRunner", "cmdLineJar", "cmdFileJar", "mdlineBuilder", "mdLineParser", "cmdLineHelper", "cmdLMaster", "mdLineparser", "cmdServicearser", "cmdLinJar", "cmdStringMaster", "commandLineParser", "cmdStringHelper", "cmdEntryMaster", "cmdLineparser", "mdLinearser", "mdlineParser", "cmdBlockMaster", "cmdLJar", "cmdLineRunner", "cmdFileRunner", "cmdStringReader", "mdLarser", "cmdByteJar", "cmdStringarser", " cmdLineMaster", "cmdLarser", "cmdlineJar", "cmdLBuilder", " cmdLineJar", "cmdLineWriter", "cmdStringRunner", "mdlinearser", "cmdServiceParser", "cmdByteMaster", "commandlineReader", "mdLReader", "mdLineMaster", "cmdFileReader", "mdLineJar", "cmdStringParser", "mdlineparser", "cmdEntryJar", "cmdEntryParser", "cmdByteWriter", "mdLineHelper", "commandLineJar", "cmdlineWriter", "mdLParser", "cmdFileMaster", "cmdBlockParser", "cmdLinReader", "cmdlineHelper", "cmdLparser", "cmdSiteJar", "commandlineParser", "cmdlineParser", "cmdlineBuilder", "cmdBlockarser", " cmdLJar", "cmdBlockJar", "commandlineJar", " cmdLinearser", "mdLJar", "cmdByteParser", "commandLineMaster", "cmdLineMaster", "mdlineJar", "mdlineWriter", "cmdSiteparser", "cmdStringBuilder", "commandLineReader", "cmdBlockWriter", "cmdLinMaster", "cmdStringparser", "commandlineMaster", "cmdFileParser", "cmdServiceMaster", "cmdLHelper", "cmdStringJar", "mdLineWriter", " cmdLMaster", "cmdBlockparser", "cmdLineReader", " cmdLParser", "cmdlinearser", "mdLHelper", "mdlineMaster", "cmdServiceJar", "cmdEntryarser", "cmdLineBuilder", "cmdFilearser", "cmdLParser", "cmdlineMaster", "mdLRunner", "cmdSiteWriter", "cmdStringWriter", "cmdLReader"], "formatOption": ["typeOption", " formatOperation", "FormatOption", "printfOperation", "typeOpt", "printfOption", " formatVariable", "printfElement", "formatOperation", "formatVariable", "formatParameter", "formatOpt", "formatElement", "typeVariable", "lengthOpt", " formatOpt", " formatParameter", "FormatOperation", "lengthOption", "lengthVariable", "typeParameter", "printfOpt", "lengthParameter", "FormatElement", " formatElement", "FormatOpt"], "outputEncodingOption": ["outputEncodingOperation", "outputEncasingOperation", "outputCasingOption", "outputEncodingParameter", "outputCasingParameter", "outputEncitingOperation", "outputCasingOptions", "outputCodingOptions", "outputEncordingOpt", "outputEncitingOption", "outputEncoderParameter", "outputEncasingParameter", "outputCasingOperation", "outputEncodingOpt", "outputEncitingOpt", "outputCodingOperation", "outputEncordingOptions", "outputCodingOpt", "outputEncasingOptions", "outputEncoderOpt", "outputEncordingOperation", "outputEncodingOptions", "outputEncasingOpt", "outputEncoderOption", "outputCodingParameter", "outputEncoderOperation", "outputEncitingOptions", "outputCasingOpt", "outputCodingOption", "outputEncordingParameter", "outputEncordingOption", "outputEncasingOption"], "inputEncodingOption": ["inputChodingOperation", "inputEncasingOption", "inputEncoderOperation", "inputEncasingOperation", "inputChachingOperation", "inputEncodedFunction", "inputEncoderOption", "inputEncodingFunction", "inputEncachingOpt", "inputEncachingOperation", "inputEncodedOption", "inputEncoderOpt", "inputEncachingOption", "inputChasingOption", "inputChodingFunction", "inputEncodingOperation", "inputEncodedOperation", "inputChodingOpt", "inputChodingOption", "inputChasingFunction", "inputEncoderFunction", "inputEncasingOpt", "inputChachingOpt", "inputChachingOption", "inputEncasingFunction", "inputChasingOperation", "inputEncodingOpt"], "format": ["pretty", "attribute", "cat", "at", "string", "host", "option", "title", "version", "language", "service", "atter", "transform", "export", "api", "place", "printf", "letter", "quality", "unit", "command", "alpha", "scale", "layout", "Format", "prefix", "ant", "config", "license", "size", "f", "value", "feature", "filename", "writer", "html", "filter", "output", "type", "term", "style", "target", "plugin", "pattern", "form", "name", "file", "sort", "template"], "outputEncoding": [" outputEncaping", "outputSequoder", " outputEncasing", "outputEnasing", "outputChoring", "outputencording", " outputEntining", " outputEntoding", "outputEntasing", "outputSequasing", "outputChoding", "outputEntoder", "outputEncryption", "outputSequryption", "outputEncaping", "outputencoding", "outputChasing", "outputOctoring", "outputEncaching", " outputEncording", " outputEngoding", "outputSequoding", "outputEnining", " outputEncoder", "outputEngoder", "outputChording", " outputEngaching", "outputOctoder", "outputEncining", "outputEntaping", "outputEngording", "inputChryption", "inputEncryption", "inputEncoder", " outputEncaching", "outputOctasing", "outputEngaching", "inputEncasing", "outputCompording", "outputEncording", "inputChoder", "outputencaching", "outputChryption", "outputEngoding", "outputChining", "outputOctoding", "inputChasing", "outputEncoring", "outputChoder", "outputChaching", "outputCompasing", "outputEnaping", "outputEnoding", "inputEncording", " outputEngoder", "outputDecoding", "outputCompoder", "outputDecoder", "outputEntining", "outputencoder", "inputChording", " outputEntasing", "inputEncoring", "outputEncoder", " outputEngording", "outputDecasing", "outputChaping", "outputEntryption", " outputEncining", "outputEntoding", "inputChoding", "outputEncasing", " outputEntaping", "outputDecording", "inputChoring", "outputCompoding"], "inputEncoding": ["inputEncording", "variableEncode", "outputChoding", "inputEncode", "inputEnasing", "inputEnacing", "inputEnasting", "variableEncasting", "inputEngasing", " inputDecoder", " inputEncoder", "inputEncoder", " inputEncacing", "inputEngoding", "inputDecacing", " inputEncording", "inputEncasting", "inputEngapping", "variableEncoding", "variableEncasing", "inputChasting", "inputEnode", "inputChacing", "outputEncapping", "inputChording", "inputEncasing", "inputEncapping", "outputChasing", "inputEnoder", "outputEncoder", "inputChoder", " inputDecacing", " inputDecording", "inputEngoder", "inputChapping", "inputExplode", "inputDecoding", "outputChapping", "inputChasing", "inputExploding", "variableExploding", "inputChode", "inputChoding", "inputDecording", "inputEncacing", "variableExplasing", "inputDecoder", "outputChoder", "outputEncasing", "inputEnapping", "variableExplode", " inputDecoding", "variableExplasting", "inputExplasing", "inputEnording", "inputExplasting", "inputEnoding"], "remainingArgs": ["remendingArgs", "RemingLong", "regainingGS", "remainLong", "remangingArg", "remainingArg", "resainingParts", "remainsArgs", "regainingParameters", "remainsAr", "remainArgs", "regainedArg", "RemingArgs", "remainedArray", "remendingArg", "remangingParameters", "resainedParts", "remainargs", "resainedArg", "regainedGS", "resainargs", "remainAr", "remainParameters", "remainParts", "remainsParts", "remainGS", "RemainingAr", "remingArgs", "RemangingAr", "remangingArgs", "removingGS", "remainingargs", "removingLong", "remendingargs", "resainingArray", "remainingGS", "RemangingParts", "remainedArg", "remainedLong", "remingGS", "remainingParts", "remainingLong", "remangingParts", "resainingArgs", "RemainingLong", "RemainingGS", "resainArgs", "RemainingParts", "resainArray", "RemingParts", "RemangingArg", "remainedParameters", "remainingArray", "remingLong", "regainingArg", "remainedGS", "remainedargs", "resainingArg", "RemangingArgs", "resainingargs", "remainingParameters", "remainingAr", "remangingLong", "remainedParts", "resainedArgs", "remainArray", "remangingGS", "remendingArray", "regainingArgs", "removingParts", "remainedArgs", "removingArgs", "regainedParameters", "resainArg", "resainedLong", "regainedArgs", "RemingGS", "remingParts", "RemainingArg", "RemainingArgs", "remainsArg", "remainArg", "remangingAr", "resainingLong"], "inputFile": ["InputLine", " inputDir", "Inputfile", "InputSourceFile", "sourcefile", " inputfile", "inputDirectory", " inputStream", "InputDirectory", " inputSourceFile", "inputStream", "inputLine", "inputSourceFile", " inputPath", "InputPath", "sourceLine", "localSourceFile", " inputDirectory", "localDir", "localFile", "InputFile", "sourceFile", "sourcePath", "inputPath", "sourceDirectory", "inputDir", "inputfile", "sourceDir", "sourceStream", "InputStream", "localDirectory", " inputLine", "InputDir"], "outputFile": [" outputfile", "OutputStream", "productionMessage", "outputHeader", "operationHeader", "OutputFile", " outputFolder", "Outputfile", "operationFolder", " outputMessage", "OutputFolder", "outputPath", "productionPath", "outputFolder", "outputMessage", "outputStream", "operationFile", "operationfile", "OutputHeader", "exampleStream", "exampleFile", " outputPath", "examplefile", " outputHeader", "OutputPath", " outputStream", "productionfile", "outputfile", "OutputMessage", "exampleFolder", "productionFile"], "out": ["temp", "group", "ger", "line", "again", "println", "history", "cache", "over", "word", "Out", "copy", "sum", "outer", "log", "manager", "screen", "io", "outs", "list", "post", "co", "in", "err", "up", "prefix", "server", "session", "dump", "pre", "auto", "writer", "page", "output", "gen", "error", "write", "raw", "obj", "OUT", "debug", "parent", "lock", "info", "client", "ln", "builder", "flow"]}}
{"id1": "2642914", "id2": "20735941", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTargx", "addFileToTarGarzi", "addFileToZipGszip", "addFileToTarGszip", "addFileToTarGx", "addFileToTargzi", "addFileToTarGuz", "addFileToTarGzi", "addFileToTarGgz", "addFileToTarggz", "addFileToZipGarx", "addFileToTargzip", "addFileToZipGarzip", "addFileToTarGarx", "addFileToZipGsz", "addFileToTarGux", "addFileToTargz", "addFileToZipGzi", "addFileToTarGarzip", "addFileToZipGszi", "addFileToTarGuzi", "addFileToZipGsgz", "addFileToTarGsgz", "addFileToZipGgz", "addFileToZipGarzi", "addFileToTarGarz", "addFileToTarGzip", "addFileToTarGuzip", "addFileToZipGz", "addFileToZipGzip", "addFileToTarGszi", "addFileToTarGargz", "addFileToZipGx", "addFileToZipGarz", "addFileToTarGsz"], "taro": ["Tro", "Taro", "tabo", " tabo", "ptabo", "thaco", "Targo", "Tara", "thoro", "Tamar", "tharo", "fara", " taco", "tamar", "ptaro", "atro", "atoran", "staro", "targo", " too", "taron", "stro", "staco", "Tabo", "faco", " tara", "Too", "Toro", "tara", "toro", "stamar", "tero", "taco", "ptaron", "atargo", "Toran", "storo", "loran", "ptargo", "thamar", "Taco", "laro", "fargo", "lro", "toran", "Taron", "faro", "stoo", " tro", "ptaco", "ataro", "Tero", "too", "largo", "stero", " tero", " taron", "tro", " targo"], "path": ["folder", "resource", "root", "route", "string", "c", "cache", "Path", "pointer", "str", "log", "key", "from", "object", "dir", "fn", "loc", "p", "url", "location", "ath", "filename", "image", "directory", "type", "data", "PATH", "id", "pattern", "parent", "uri", "source", "text", "name", "file", "ref"], "base": ["resource", "root", "ase", "string", "cache", "site", "http", "area", "core", "api", "key", "from", "absolute", "dir", "address", "Base", "store", "p", "default", "part", "prefix", "server", "url", "index", "bas", "home", "pre", "start", "relative", "type", "b", "bf", "id", "parent", "uri", "buffer", "back", "name", "file", "extra"], "f": ["fa", "df", "ref", "fe", "F", "fc", "of", "g", "c", "n", "m", "sf", "d", "fo", "fx", "aff", "self", "raf", "fd", "feed", "this", "cf", "framework", "fold", "fn", "p", "fs", "l", "tf", "s", "w", "j", "url", "fac", "flat", "af", "e", "i", "h", "fp", "fen", "v", "file", "inf", "found", "r", "b", "fb", "t", "bf", "lf", "form", "fr", "rf"], "entryName": ["elementType", "fileName", "entryType", "fileType", "fileTime", "EntryName", " entryPath", "EntryTime", " entryname", "archivename", "elementName", "elementTime", "entryname", "archiveSize", "archiveName", "elementPath", "resourceSize", "resourcename", " entrySize", "filePath", "resourcePath", "entrySize", " entryTime", "entryTime", " entryType", "EntryPath", "EntryType", "archivePath", "entryPath", "resourceName"], "goIn": ["poOut", "goIN", "GOin", "GoIN", "goIns", "goin", "poIns", "GoIns", "loin", "loIN", "gaIns", "coin", "GOOut", "coIns", "coIn", "gaIN", "GOIn", "loIns", "coOut", "goOut", "gaIn", "Goin", "gain", "loIn", "poIN", "GOIN", "GoIn", "poIn", "GOIns", "poin"], "tarEntry": ["TarEntry", "zipFile", "zipEntry", "zipInfo", "tarEnt", " Tarentry", "zipEnt", "tarFile", "rarInfo", "Tarentry", "rarEnt", " TarEntry", " tarentry", " tarInfo", "tarentry", "tarElement", "rarEntry", " tarEnt", "tarInfo", " tarFile", "rarFile", "TarElement", " tarElement", " TarElement"], "children": ["pages", "many", "packages", "each", "words", "well", "father", "current", "parents", "opens", "values", "far", "open", "feed", "ools", "files", "ins", "members", "content", "plugins", "loc", "bars", "roots", "all", "ales", "jobs", "when", "ren", "balls", "scenes", "kids", "other", "ports", "pool", "blocks", "ul", "iblings", "h", "Children", "output", "data", "sub", "parent", "web", "pes", "name", "which", "rows"], "child": ["entry", "ch", "row", "root", "or", "pull", "cloud", "slave", "and", "c", "channel", "hel", "comment", "layer", "feed", "key", "in", "client", "count", "build", "l", "connection", "shell", "server", "per", "pool", "code", "i", "lib", "Child", "draft", "page", "data", "cel", "id", "job", "parent", "kid", "leaf", "name", "file"]}}
{"id1": "9261777", "id2": "949327", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"source": ["resource", "token", "use", "seed", "project", "zip", "string", "Source", "request", "view", "spec", "proxy", "inner", "service", "scope", "comment", "input", "options", "ource", "copy", "path", "empty", "slice", "force", "dest", "in", "original", "address", "shared", "single", "unit", "sample", "missing", "rule", "base", "element", "prefix", "url", "query", "config", "size", "name", "index", "flat", "sl", "session", "strip", "SOURCE", "image", "start", "sin", "result", "secure", "se", "data", "parse", "style", "target", "null", "id", "parent", "uri", "text", "info", "src", "site", "file", "sort", "template"], "destination": ["dominated", "desturation", " destinating", " destipping", "destinations", "domination", " destinator", "dependension", "coordinating", "destinating", "destipping", " destension", "homeignment", "Destinations", "destinator", "Destinator", "Destinating", "coordination", "Destination", "homeinated", "databaseuration", "destinated", "Destinated", "homeination", " destignment", "Destinate", "homeinator", "destinate", "distipping", "Destignment", "coordinate", "dependination", "dependipping", "dependinated", "domuration", "databaseinated", " destinated", "dominations", "destignment", "distension", "distinated", "coordinator", " destinate", "distination", "databaseinations", "databaseination", "Desturation", "destension"], "is": ["ib", "ics", "or", "us", "ip", "isa", "ios", "serv", "zip", "bs", "ens", "isl", "ois", "osi", "ir", "ob", "act", "ii", "was", "iris", "oss", "ci", "as", "ic", "api", "abs", "ais", "IS", "io", "ui", "in", "ins", "ri", "are", "ie", "fs", "obs", "init", "s", "Is", "out", "iss", "iso", "ar", "ops", "eni", "cos", "get", "isi", "isc", "sis", "i", "ori", "sin", "close", "mis", "bis", "se", "lis", "ai", "nis", "esi", "id", "es", "info", "src", "ris"], "os": ["or", "ks", "js", "us", "ol", "ios", "so", "bs", "ens", "ob", "osi", "op", "ies", "o", "mos", "dos", "oa", "oss", "as", "oise", "io", "ais", "sys", "aos", "boot", "bos", "oes", "acs", "ose", "fs", "obs", "s", "nos", "pos", "out", "oS", "vs", "ls", "los", "ops", "cos", "ot", "Os", "i", "ds", "ori", "oses", "ros", "socket", "ou", "es", "ends", "OS", "ss", "ow"], "buffer": ["seed", "position", "string", "channel", "uffer", "limit", "padding", "copy", "layer", "wave", "sequence", "feed", "buf", "slice", "queue", "number", "pad", "address", "header", "batch", "base", "server", "url", "size", "read", "Buffer", "iter", "value", "image", "writer", "bytes", "transfer", "page", "border", "result", "reader", "bb", "data", "null", "b", "buff", "flush", "binary", "reference"], "length": ["distance", "row", "section", "line", "of", "position", "ob", "string", "full", "volume", "depth", "limit", "character", "total", "shape", "lower", "Length", "power", "partial", "division", "match", "sequence", "slice", "number", "feed", "key", "ring", "object", "address", "count", "age", "weight", "l", "part", "url", "get", "load", "left", "size", "index", "code", "len", "value", "strip", "split", "start", "quote", "last", "level", "reader", "type", "data", "range", "point", "style", "duration", "id", "offset", "lock", "block", "width", "end"]}}
{"id1": "11341711", "id2": "14093044", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Override\n    public boolean insert(String consulta, boolean autocommit, int transactionIsolation, Connection cx) throws SQLException {\n        filasInsert = 0;\n        if (!consulta.contains(\";\")) {\n            this.tipoConsulta = new Scanner(consulta);\n            if (this.tipoConsulta.hasNext()) {\n                execConsulta = this.tipoConsulta.next();\n                if (execConsulta.equalsIgnoreCase(\"insert\")) {\n                    Connection conexion = cx;\n                    Statement st = null;\n                    try {\n                        conexion.setAutoCommit(autocommit);\n                        if (transactionIsolation == 1 || transactionIsolation == 2 || transactionIsolation == 4 || transactionIsolation == 8) {\n                            conexion.setTransactionIsolation(transactionIsolation);\n                        } else {\n                            throw new IllegalArgumentException(\"Valor invalido sobre TransactionIsolation,\\n TRANSACTION_NONE no es soportado por MySQL\");\n                        }\n                        st = (Statement) conexion.createStatement(ResultSetImpl.TYPE_SCROLL_SENSITIVE, ResultSetImpl.CONCUR_UPDATABLE);\n                        conexion.setReadOnly(false);\n                        filasInsert = st.executeUpdate(consulta.trim(), Statement.RETURN_GENERATED_KEYS);\n                        if (filasInsert > -1) {\n                            if (autocommit == false) {\n                                conexion.commit();\n                            }\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    } catch (MySQLIntegrityConstraintViolationException e) {\n                        System.out.println(\"Posible duplicacion de DATOS\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLNonTransientConnectionException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLDataException e) {\n                        System.out.println(\"Datos incorrectos\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (MySQLSyntaxErrorException e) {\n                        System.out.println(\"Error en la sintaxis de la Consulta en MySQL\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (SQLException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } finally {\n                        try {\n                            if (st != null) {\n                                if (!st.isClosed()) {\n                                    st.close();\n                                }\n                            }\n                            if (!conexion.isClosed()) {\n                                conexion.close();\n                            }\n                        } catch (NullPointerException ne) {\n                            ne.printStackTrace();\n                        } catch (SQLException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"No es una instruccion Insert\");\n                }\n            } else {\n                try {\n                    throw new JMySQLException(\"Error Grave , notifique al departamento de Soporte Tecnico \\n\" + email);\n                } catch (JMySQLException ex) {\n                    Logger.getLogger(JMySQL.class.getName()).log(Level.SEVERE, null, ex);\n                    return false;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException(\"No estan permitidas las MultiConsultas en este metodo\");\n        }\n    }\n", "label": 0, "substitutes": {"makeBackup": ["createBackups", "makebackdown", "createbackUp", "createbackups", "makebackUp", "makebackup", "makePickup", "makeCleandown", "makeCleanups", "makeCleanup", "makeBackdown", "makeBackups", "makePickdown", "createbackdown", "makeBackUp", "createBackdown", "makebackups", "makeCleanUp", "createBackUp", "createbackup", "createBackup", "makePickups", "makePickUp"], "dir": ["folder", "done", "root", "run", "group", "zip", "cache", "ir", "dist", "d", "log", "manager", "desc", "path", "io", "dest", "doc", "download", "Directory", "wd", "DIR", "build", "dict", "store", "up", "init", "base", "rc", "url", "work", "config", "pkg", "director", "Dir", "lib", "directory", "direction", "data", "diff", "md", "module", "source", "dep", "name", "db", "file"], "sourcedir": ["sourcesIR", "sodeddir", "sodedIR", "sourcesore", "asortedore", "sortedIR", "asourcedore", "asourcedIR", "sodediri", "sortedir", "sourcesirs", "asortedir", "sortedirs", "sourcesdir", "seeddir", "sourcedIR", "seedIR", "ssodedir", "sourcesiri", "sourceddir", "sourcediri", "ssourceddir", "ssodediri", "seediri", "sodedirs", "sourcesir", "sodedir", "asourcedir", "asourcedirs", "asortedIR", "sourcedirs", "ssourcedir", "ssodeddir", "sortedore", "sodedore", "sourcedore", "ssourcediri", "ssourcedIR", "seedir", "asortedirs", "ssodedIR"], "destinationdir": ["destinatorDIR", "destinationsDIR", "dominationDir", "DestinationDir", "destinatedir", "destinationfolder", "destificationfolder", "Destinationdirection", "destinationfile", "Destificationdir", "dominationfile", "destinatorDir", "destificationdir", "desturationdirection", "dominatordir", "destinationsdir", "Destificationfolder", "DestificationDir", "destinatordir", "Destinationdir", "destificationdirection", "desturationdir", "destinatorfile", "Destinationfolder", "destinationsDir", "dominationdir", "destinatefolder", "Destificationdirection", "destinatefile", "destinatedirection", "destificationDir", "destinateDir", "desturationfolder", "dominatorDIR", "destinationDIR", "dominationDIR", "destinateDIR", "destinationsfile", "dominatorDir", "destinationdirection", "destinationDir", "desturationDir", "dominatorfile"], "destinationDirEnding": ["destinationDirPassning", "destinationDirSigning", "destinationDirEndING", "destinationPathBeginning", "destinationDirBeginining", "destinationPathEndging", "destinationDirectorySigning", "destinationDirBeginening", "destinationDirPassing", "destinationDirEndning", "destinationDirENDning", "destinationPathBegining", "destinationDirectorySignening", "destinationDirEndging", "destinationDirENDING", "destinationDirENDing", "destinationDirLeadING", "destinationDirPassING", "destinationDirectoryEndING", "destinationPathEndning", "destinationDirectoryEnding", "destinationDirBegining", "destinationDirEndining", "destinationDirEndening", "destinationDirLeading", "destinationPathBeginING", "destinationDirSignening", "destinationDirPassging", "destinationDirectoryEndening", "destinationPathEndING", "destinationDirectoryEndining", "destinationDirSignining", "destinationPathEnding", "destinationDirSignING", "destinationDirLeadining", "destinationDirectorySignING", "destinationDirLeadening", "destinationPathBeginging", "destinationDirBeginging", "destinationDirBeginning", "destinationDirectorySignining", "destinationDirENDging", "destinationDirBeginING"], "files": ["reports", "pages", "names", "boxes", "planes", "classes", "words", "books", "bugs", "resources", "lines", "parents", "results", "xml", "errors", "ids", "log", "images", "sections", "objects", "uploads", "events", "ins", "groups", "locks", "fs", "l", "tests", "strings", "ls", "fields", "actions", "projects", "keys", "its", "balls", "children", "index", "services", "thumbnails", "blocks", "modules", "types", "split", "ips", "features", "rules", "links", "output", " Files", "flows", "models", "data", "items", "docs", "Files", "ps", "iles", "users", "runs", "file", "rows"], "checkdir": ["worklog", "Checkfile", "workDir", "blockdirectory", "checklog", "checkDIR", "workdirectory", "Checkdir", "checkFolder", "searchdir", "workfolder", "workDIR", "checkdirectory", "lockFolder", "locklog", "ckfile", "blockdraft", "searchDir", "ckdir", "ckDir", "CheckDir", "ckfolder", "workfile", "blockdir", " checklog", "CheckDIR", "checkfile", "callfolder", "ckdirectory", "calld", "lockdir", " checkfile", "ckd", " checkDIR", " checkdirectory", "checkdraft", " checkDir", "searchdirectory", "workdir", " checkFolder", "checkDir", "workFolder", "calldirectory", "lockDir", "checkfolder", "blockDir", " checkfolder", "workdraft", " checkd", "calldir", "searchdraft", "checkd"], "date": ["mate", "day", "late", "at", "m", "dat", "ate", "d", "state", "ge", "time", "log", "contact", "open", "zone", "doc", "user", "age", "month", "tag", "rate", "event", "config", "dt", "now", "e", "set", "Date", "image", "start", "change", "ime", "data", "md", " Date", "de", "sign", "update", "mu", "name", "file"], "msec": ["rss", "misec", "Msecond", "fmsecond", "mss", "mSec", "rsecond", "lsec", "mnsec", "css", "csec", "cseconds", "fmseconds", "mif", "lsecond", "disec", " minif", "mnSec", "Mseconds", "mseconds", " mif", "Msec", " minSec", "dsecond", " msc", "msc", "fmisec", "dsec", "lseconds", "rsec", "csecond", "mnif", "msecond", "mnsc", " mSec", "Misec", "rseconds", "lss", " minsc", " minsec", "fmsec", "dseconds"], "checkFile": ["Checkfile", "workDir", "controlLine", " checkDirectory", "ckFile", "changeFilename", "ckFiles", "changeFile", " checkFilename", "ckDirectory", "checkFiles", "checkLine", "CheckFile", "workFiles", "ckfile", "CheckDir", "workfile", "checkDirectory", "changefile", "checkfile", "CheckFiles", " checkfile", "changeLine", " checkDir", "controlFile", "checkDir", " checkLine", "controlfile", "checkFilename", "CheckDirectory", " checkFiles", "workFile", "controlFilename"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "n", "ii", "ini", "pi", "im", "y", "m", "is", "ci", "di", "io", "key", "slice", "ji", "ui", "vi", "ri", "bi", "ie", "p", "part", "phi", "j", "I", "fi", "x", "eni", "index", "field", "e", "oi", "li", "gi", "v", "ti", "ai", "b", "xi", "id", "info", "uri", "ix", "mu"], "f": ["folder", "df", "fe", "F", "fc", "u", "n", "m", "o", "sf", "d", "fun", "fx", "fd", "feed", "cf", "fn", "p", "fs", "l", "w", "j", "fi", "e", "q", "h", "fp", "file", "v", "fl", "r", "b", "fb", "t", "info", "fr"], "g": ["rg", "gg", "mg", "group", "ger", "global", "u", "n", "m", "pg", "gp", "go", "d", "gs", "ge", "msg", "bg", "tg", "eg", "gu", "p", "ig", "ng", "gb", "s", "l", "w", "reg", "ga", "gin", "gar", "e", "gc", "gd", "gm", "vg", "q", "gn", "h", "gi", "sg", "r", "b", "t", "og", "gh", "erg", "G", "file"], "destinationFile": ["destiningfile", "destacementfile", "destinatorLocation", "destinatorDirectory", "DestinationDir", "DestinationFilename", "destinationDirectory", "destacementDir", "DestinationLocation", "destificationLocation", "destinationfile", "destacementFilename", "destificationDirectory", "destinationsLocation", "destinatorDir", "destationfile", "destiningFilename", "destinationLocation", "DestificationDirectory", "destinatorFile", "destationDir", "DestificationDir", "destiningDir", "DestinationDirectory", "DestificationFile", "destationFilename", "destinationsDirectory", "destificationFile", "destiningFile", "destacementFile", "destinationsDir", "destinationFilename", "destinationsFile", "destificationDir", "DestationDir", "DestinationFile", "destationFile", "DestationFile", "DestificationLocation", "Destinationfile", "destinationDir", "DestationFilename", "Destationfile"], "sourceFile": ["SourceModule", "sourceFiles", "inputFile", "srcDir", " sourcefile", "SourceFile", "sourcefile", " sourceDirectory", "inputDirectory", "ourceDirectory", "SourceDir", " sourceModule", "srcfile", "inputFiles", "ourceFile", "ourceDir", "srcFile", "ourceFiles", "sourceDirectory", "Sourcefile", "srcModule", "inputDir", " sourceFiles", "sourceDir", " sourceDir", "sourceModule"], "infile": [" instream", "diffdir", "inputFile", "inputf", "diffFile", "windir", " indata", "difffile", "outdir", "inputstream", "outdata", "winstream", "Infile", "inputdata", "instream", "diffstream", "outf", "InFile", "inFile", "inputfile", "indata", "Instream", " inFile", "inf", "outFile", "Inf", "outstream", "indir", "winFile", "winfile"], "outfile": ["expage", "OutFile", "Outline", "outfunction", "exstream", "inputFile", " outline", " outpage", " outFile", "againfile", "againFile", "outlive", "intFile", "outline", "exFile", "inputfunction", "inputline", "outpage", "Outfile", " outlive", "againpage", "inputfile", "Outlive", "intlive", "outFile", "intfile", " outfunction", "Outfunction", "Outstream", " outstream", "intstream", "exfile", "outstream", "againstream"], "c": ["ch", "pc", "u", "cm", "k", "n", "m", "string", "col", "o", "pointer", "channel", "d", "comment", "character", "abc", "ci", "xc", "z", "char", "in", "ct", "cu", "ac", "C", "p", "cr", "cl", "l", "w", "rc", "x", "index", "enc", "e", "code", "a", "h", "uc", "v", "ice", "r", "b", "dec", "t", "id", "cy", "esc", "ec", "cont", "lc", "end"]}}
{"id1": "2936678", "id2": "2199604", "code1": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 0, "substitutes": {"getUniqueKey": ["getStringLink", "makeuniqueHash", "getStringKey", "makeUniqueLink", "getPrimaryKey", "getStringkey", "makeUniquekey", "getuniqueKey", "getUniquekey", "getUniqueHash", "getuniqueHash", "makeuniqueKey", "getPrimaryLink", "getStringHash", "makeuniqueLink", "makeUniqueKey", "getPrimaryHash", "makeUniqueHash", "getuniqueLink", "makeuniquekey", "getPrimarykey", "getuniquekey", "getUniqueLink"], "digest": ["dests", "digid", "dested", "genEST", "uuester", "longest", " digests", " digit", "Digester", "Digested", "longEST", "digested", " digEST", "digester", "dest", " digid", "DigEST", "longested", " digester", " digested", "Digid", "Digit", "digEST", "uuest", "genit", "dester", "Digests", "longester", "uuid", "genest", "digests", "digit", "Digest", "uuEST"], "md": ["dc", "df", "mb", "mg", "mp", "pd", "pm", "od", "mand", "mac", "Cmd", "m", "sm", " MD", "km", "d", "hm", "MD", "bd", "meta", "wd", "alg", "hd", "ad", "dd", "ld", "mc", "med", "cd", "gb", "ud", "cmd", "dh", "mn", " dd", "mag", "ma", "nd", "gd", "dm", "hash", "v", "gen", "nm", "amd", "dig", "rpm", "sd", "mm", "metadata", "de", "vd", "mad", "mt", "grad", "mo"], "timeVal": ["TIMEValue", "TimeVal", "TIMEval", "TIMEVal", " timeValue", " timeBu", "timeSeries", "TimeValue", "rateValue", " timeSeries", "TIMESeries", " timeval", "TimeLen", "timeValue", "rateBu", "rateLen", " timeLen", "Timeval", "timeBu", "TimeSeries", "rateVal", "timeval", "TimeBu", "timeLen"], "localHost": ["LocalHost", "LocalMac", "LocalAddress", "remotePort", "privatePort", "remoteMac", " localAddress", "localAddress", "privateAddress", "LocalPort", "privatehost", "localMac", "privateHost", "remotehost", " localPort", "localhost", "Localhost", "remoteHost", "localPort", "remoteAddress", " localhost", " localMac"], "randVal": [" randLen", "RandBu", " randValue", "RandomLen", "randValue", "randBu", "RandVal", "RandomVal", "randomStr", "Randomval", " randBu", "randomVal", "randval", "RandStr", "randStr", "randomval", "randomValue", "randLen", "RandValue", "randomLen", " randval", "randomBu", "RandomValue", " randStr"], "val": ["temp", "live", "pm", "string", "pr", "values", "abc", "msg", "vol", "pt", "key", "eval", "buf", "dev", "Val", "seq", "ret", "unit", "loc", "bl", "valid", "gb", "base", "addr", "reg", "x", "sl", "enc", "VAL", "value", "ind", "el", "format", "res", "v", "vals", "result", "test", "range", "data", "az", "id", "rev", "update", "grad", "sel", "db", "ref"]}}
{"id1": "22264586", "id2": "20920051", "code1": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFiles": ["clonePages", "cloneFile", "transferFile", "CopyChildren", "Copyfiles", "clonefiles", "copyFile", "CopyFiles", " copyfiles", "copyPages", "transferChildren", "transferPages", "transferFiles", " copyPages", "copyChildren", " copyChildren", "cloneFiles", "transferfiles", " copyFile", "CopyFile", "copyfiles"], "strPath": ["stFile", " strpath", "strName", "striFile", "stPath", " strName", "strFile", "striLog", "STRpath", "StrLog", "STRLog", "stName", "stripath", "striPath", "strpath", "StrFile", "stpath", "strLog", "Strpath", "STRFile", "StrName", "StrPath", "STRPath", " strFile"], "dstPath": ["dstsFile", "dblpath", "dstFile", "ddestDir", "drcpath", "dndPath", "fstsDir", "sdndPath", "dblFile", "sdstName", "drcDir", "sdndName", "ddestFile", "dstName", "drcName", "sdndpath", "fstPath", "sdndDir", "sdstPath", "dstDir", "dblPath", "dndDir", "dndpath", "ddestName", "sdstDir", "fstspath", "dstspath", "drcPath", "dblDir", "dstpath", "dndName", "sdstpath", "fstsPath", "fstFile", "fstsFile", "fstDir", "ddestPath", "dstsPath", "ddestpath", "dstsDir", "fstpath"], "src": ["txt", "cmp", "project", "obl", "front", "host", "Source", "ruby", "dist", "scripts", "self", "input", "ource", "path", "inst", "ctx", "sc", "slice", "this", "sys", "in", "sync", "client", "download", "loc", "sup", "s", "rc", "rob", "ls", "reverse", "upload", "tmp", "cur", "url", "config", "sb", "sl", "back", "SOURCE", "split", "sin", "cb", "RC", "img", "st", "ssl", "secure", "ources", "sub", "rs", "source", "stream", "sel", "sit", "rb", "iv", "sq", "sort"], "dest": ["dc", "folder", "cdn", "txt", "done", "slave", "temp", "wh", "cat", "project", "front", "zip", "rest", "later", "dat", "dist", "d", "destroy", " Dest", "desc", "di", "wd", "div", "sup", "dd", "comb", "trans", "default", "out", "tmp", "delete", "du", "thin", "flat", "des", "ds", "home", "gd", "Dest", "result", "img", "secure", "test", "style", "target", "prop", "de", "source", "wb", "dep", "db"], "list": ["status", "full", "map", "dl", "ll", "none", "files", "pair", "members", "dir", "p", "l", "s", "delete", "url", "like", "val", "stat", "filter", "write", "lists", "parent", "version", "lc", "names", "entry", "lines", "str", "la", "LIST", "bl", "cl", "strings", "keys", "code", "data", "null", "stream", "sort", "www", "listed", "queue", "part", "all", "ls", "coll", "arr", "load", "size", "array", "set", "diff", "type", "stack", "id", "cont", "name", "group", "run", "string", "parents", "is", "remove", "path", "key", "json", "batch", "base", "chain", "config", "read", "split", "test", "info", "source"], "i": ["hi", "si", "qi", "ip", "u", "multi", "n", "ii", "c", "m", "pi", "o", "y", "abi", "ci", "di", "io", "key", "slice", "ji", "ui", "ri", "length", "me", "bi", "ie", "p", "part", "phi", "j", "I", "x", "index", "f", "e", "oi", "li", "a", "start", "gi", "v", "ti", "type", "ai", "data", "r", "b", "xi", "id", "info", "uri", "ix", "mu"], "dest1": ["srcOne", "sourceone", "Dest0", "Dest2", "dest0", "source2", "destOne", "DestOne", "homeone", "source0", "src2", "source1", "src0", "dest2", " destone", "sourceOne", "destone", "home1", "Dest1"], "src1": ["srcOne", "sourceone", "rc1", "source2", " src2", "rcOne", "src2", "rcone", "source1", " srcone", " srcOne", "sourceOne", "rc2", "srcone"], "sourceChannel": ["srcChan", "SourceStream", "ourceChan", "Sourcechannel", "sourceContext", "SourceContext", "targetChan", "ourceStream", " sourcechannel", "SourceChan", "srcStream", "srcContext", " sourceChan", "sourcechannel", "SourceChannel", "ourceChannel", "targetContext", "targetchannel", "sourceStream", "srcChannel", " sourceStream", "sourceChan", "targetStream", " sourceContext", "ourceContext"], "targetChannel": ["TargetChannel", "destContext", "TargetContext", "TargetManager", " targetConnection", "sourceContext", "targetChan", "destChannel", " targetManager", "destConnection", "argetManager", " targetContext", "targetManager", "destChan", " targetChan", "argetChan", " targetchannel", "sourcechannel", "targetConnection", "Targetchannel", "argetChannel", "targetContext", "targetchannel", "argetchannel", "TargetConnection", "sourceChan", "TargetChan"]}}
{"id1": "19944975", "id2": "16557837", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["writeSection", "writeReport", " writeSection", "saveConfiguration", "saveReport", "saveConfig", "WriteConfiguration", "writeConfig", "WriteReport", "WriteSection", " writeConfig", "WriteConfig", "saveSection", " writeReport"], "out": ["resource", "temp", "inas", "external", "window", "line", "again", "at", "project", "string", "c", "m", "IN", "o", "ex", "exp", "xml", "inner", "scope", "Out", "report", "path", "io", "outs", "list", "key", "sync", "this", "object", "conn", "user", "err", "connection", "w", "base", "init", "prefix", "exec", "server", "config", "pool", "dump", "password", "filename", "lib", "writer", "res", "plain", "ext", "output", "reader", "write", "obj", "OUT", "flush", "parent", "client", "name", "file"], "url": ["resource", "ob", "string", "channel", "xml", "http", "service", "URL", "path", "ll", "io", "open", "feed", "api", "Url", "object", "conn", "address", "rel", "l", "connection", "base", "server", "location", "config", "sl", "f", "image", "page", "ssl", "data", "r", "b", "web", "uri", "stream", "source", "org", "file"], "in": ["resource", "In", "inas", "again", "serv", "n", "c", "ini", "IN", "cin", "xml", "is", "din", "inner", "bin", "input", "copy", "as", "pin", "cms", "ins", "ac", "conn", "min", "inn", "err", "kin", "isin", "s", "rin", "win", "lin", "gin", "f", "inside", "i", "nin", "a", "socket", "login", "ssl", "reader", "data", "r", "b", "inc", "id", "source", "stream", "file"]}}
{"id1": "838844", "id2": "539195", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "subverting", "unverted", "Conversion", "converted", "CONverted", "unception", "CONverting", "conversion", " deconverting", "Convert", " deconvert", "conception", " deconverted", "subversion", "oconverted", "Conception", "subverted", "CONception", "oconvert", "oconversion", "subvert", "unvert", "CONversion", "CONvert", "converting", " deconversion", "unversion", "Converted", "oconverting"], "src": ["resource", "scene", "stage", "sth", "username", "cmp", "SourceFile", "string", "href", "Source", "spec", "cpp", "dist", "input", "ource", "path", "inst", "ctx", "sc", "buf", "slice", "sys", "attr", "rl", "download", "impl", "fn", "loc", "proc", "video", "gb", "s", "rc", "storage", "upload", "tmp", "url", "component", "load", "sn", "config", "sb", "code", "gz", "filename", "sin", "Dest", "fp", "cb", "ssl", "img", "reader", "st", "RC", "supp", "secure", "obj", "req", "feat", "rb", "prot", "back", "source", "stream", "uri", "sel", "name", "sit", "file", "ref"], "dest": ["dc", "txt", "temp", "class", " dst", "dat", "dist", "bin", "path", "di", "disk", "dir", "fn", "orig", "tmp", "home", "lib", "Dest", "std", "img", "test", "obj", "target", "null", " destination", "source", "cont"], "in": ["In", "inas", "pass", "ini", "n", "IN", "ex", "is", "d", "din", "bin", "input", "as", "io", "pin", "ins", "doc", "inn", "err", "up", "isin", "win", "f", "i", "a", "inf", "val", "login", "reader", "data", "r", "ps", "t", "inc", "source", "stream", "file"], "p": ["pc", "cop", "pd", "pm", "g", "c", "pr", "pi", "op", "py", "pb", "pg", "o", "m", "d", "np", "pp", "bp", "tp", "wp", "l", "part", "s", "pe", "cp", "pa", "j", "sp", "per", "f", "e", "lp", "i", "pre", "h", "fp", "v", "P", "jp", "r", "po", "ps", "t", "parser", "b"], "ds": ["dc", "hs", "words", "dl", "gs", "da", "obs", "s", "icks", "ges", "dm", "ts", "sts", "db", "df", "js", "pd", "bs", "ys", "dat", "lines", "dos", "d", "utils", "ads", "styles", " props", " sd", "amps", "ld", "ans", "Ds", "lp", "ns", "data", "posts", "parts", "docs", "ps", "DS", "ss", "dp", "scripts", "uds", "di", "os", "sync", "sys", "ins", "xs", "tests", "dds", "ls", "dt", "cs", "des", "nas", " DS", "ups", "ks", "eps", "dist", "cons", "ays", "tools", "ants", "groups", "plugins", "dd", "qs", "vs", "services", "dates", "ths", "els", "gd", "ded", "vals", "points", "ils", " ps", "ipes", "rs", "models"], "format": ["struct", "class", "function", "at", "act", "string", "host", "table", "spec", "version", "language", "atter", "path", "fd", "api", "magic", "letter", "unit", "handler", "fn", "frame", "nat", "scale", "tag", "part", "layout", "Format", "model", "prefix", "ant", "url", "config", "f", "sche", "filename", "record", "fp", "filter", "data", "type", "feat", "style", "plugin", "t", "parser", "pattern", "source", "form", "name", "file", "template"], "hasPixelData": ["showsPixeldata", "haspixeldata", "showsPixelDATA", "hasByteDATA", "hasPixeldata", "hasPixelDATA", "showsPixelStyle", " hasPixelSize", " hasPixeldata", "showsBytedata", "showsByteStyle", "haspixelSize", "showsPixelData", "hasByteData", "hasByteStyle", "hasBytedata", "haspixelData", "hasPixelStyle", "showsByteData", "hasPicturedata", "hasByteSize", "hasPictureSize", "hasPixelSize", "hasPictureData", "showsByteDATA"], "inflate": ["inFlated", "inadequating", "infloace", "insflode", "InFlate", "infolATE", "inadequode", "insvenATE", "inFlate", "insflating", "InFlace", "insflATE", "inffated", "inflation", "invenate", "inflace", "infolode", "inFlation", "infloate", "insvenate", "invenATE", "infloated", "inffation", "invenating", "InFlated", "insvenating", "insflate", "inflATE", "inflating", "Inflace", "infface", "inFlace", "infolate", "Inflated", "inffate", "Inflate", "inadequate", "insvenode", "inflated", "infolating", "infloation", "inflode", "invenode", "Inflation", "InFlation", "inadequATE"], "pxlen": ["fxdata", "pnglen", "pxlin", "mxln", "axlon", "pxcount", "fxln", "pglen", "txln", "pcln", "ppl", "pxlon", "txlin", "camlen", "fxl", "pgden", "pngsize", "axlin", "mxlen", "camln", "fxden", "xplength", "ppLen", "mxdata", "pxLen", "pxdata", "pclen", "pclin", "axln", "pxln", "axlen", "txlen", "pngcount", "campos", "mxpos", "fxLen", "xpsize", "xpcount", "pxsize", "pgl", "pxpos", "ppden", "pgLen", "fxpos", "pxlength", "fxlen", "mxlength", "mxcount", "xplen", "mxsize", "camdata", "pxden", "pclon", "pplen", "pxl", "pnglength", "txlon"], "out": ["group", "line", "again", "cache", "step", "inter", "state", "Out", "copy", "log", "io", "outs", "list", "co", "post", "sys", "pad", "user", "conn", "store", "err", "up", "server", "query", "work", "cli", "session", "dump", "lib", "v", "page", "output", "gen", "error", "obj", "OUT", "point", "parent", "lock", "re"]}}
{"id1": "13666876", "id2": "3430784", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "label": 1, "substitutes": {"transformSingleFile": [" transformSingleFiles", "transformSinglePath", "transformMultifile", "transformOneSourceFile", "transformsingleSourceFile", "transformMultiFile", "transform1Path", "transformOneFile", "transformOnePath", "transformMultiFiles", " transformSingleSourceFile", " transformOneSourceFile", "transformMultiSourceFile", "transformSingleFiles", " transformSinglefile", "transformSinglefile", " transformOneFile", "transformsingleFile", "transform1Files", "transform1SourceFile", "transformOneFiles", "transformSingleSourceFile", "transform1File", "transformsingleFiles", " transformOnefile", "transformsinglefile", " transformSinglePath", " transformOnePath", "transformOnefile", " transformOneFiles"], "xed": [" xedited", "rexed", "xted", " Xed", " xED", "xED", "xteds", "rexeded", "xxeds", "xedited", "exEd", "xtEd", "exeb", "Xended", "xended", "exeds", "xxed", " xended", "xEd", "xxeded", "xeds", "exeded", "Xed", "rexED", "exed", "Xeded", "xxedited", "exED", "xxeb", " Xeds", "Xedited", "xxED", " Xeded", " xEd", " xeds", " xeded", "xtED", "xxended", "xeded", "xeb", " Xeb", "rexeds"], "node": ["slave", "row", "root", "live", "route", "day", "instance", "op", "option", "Node", "copy", "path", "shape", "none", "tree", "object", "child", "no", "loc", "document", "part", "event", "query", "component", "load", "location", "config", "index", "set", "image", "page", "error", "menu", "message", "parent", "source", "ode", "leaf", "name", "file", "edge"], "dob": ["dub", " dOb", "adod", "ddod", "ddOb", "ddob", "dOB", "adub", "DOb", " dub", "dOb", "adOB", "ddOB", "Dub", " dOB", "Dob", "adob", "DOB", " dod", "ddub", "dod"], "mySrc": ["MyAsrc", "mysRC", "mysrb", " mySst", "mySst", " myEsst", "myAssrc", "myAsrb", "myAsRC", "myEssrc", " myEsrc", "MySRC", " myEssrc", "MySrc", "mySRC", "MyEsRC", "MyEsrb", " myEsRC", "myDrc", "MyAsource", "MySource", "myDsource", "MyEsrc", " mySsrc", "myDst", "myDsrc", "myEsrb", "myAsst", "myAsrc", "myEsource", "myssrc", "mySrb", "MyEssrc", "myEsrc", " mySRC", "mySsrc", "myDssrc", "MyAssrc", "mysrc", "myEsst", "MySsrc", "myEsRC", "MyAsRC", "myAsource", "myDRC", "mySource", "myDsRC", "MySrb"], "mySrcF": ["myCrcM", "mySourceE", "mySRCM", "myCrcF", "myEssrcFile", "myCrcE", "myEsrcf", "myCRCF", "mySourceF", "mySrcf", "myCRCE", "myCRCf", "myCRCM", "mySsrcf", "mySRCE", "mySrcFile", "myEssrcF", "mySckM", "myCrcf", "mySourceFile", "mySsrcFile", "mySourcef", "myEssrcE", "mySRCFile", "myEsrcE", "mySsrcF", "myEsrcF", "mySRCf", "myEsrcFile", "mySrcM", "mySckE", "mySrcE", "mySsrcE", "myEssrcf", "mySckF", "mySsrcM", "mySckf", "mySRCF"], "myOutF": [" myOutputC", "myoutFF", "MyInQ", "myoutFile", "myoutF", "myOutFile", "MyInPF", " myOutC", "myInD", "MyInF", "myOUTF", "myInQ", "MyOutD", "myOutE", "myOUTFF", "myOutPF", "myInPF", "myOutFF", "MyOutFile", "myOutputFile", "myInF", "MyOutPF", "myOutC", "myOutD", "MyOutQ", " myOutE", "myOutQ", "myOUTD", "myoutPF", "myOutputC", " myOutFile", "MyInFile", "myOUTFile", "myInC", "myOutputF", " myOutputFile", "myInE", "myoutE", "MyOutE", "myOUTQ", " myOutputF", " myOutputE", "myoutC", "myOUTE", "myInFF", "MyInD", "myOUTPF", "MyInE", "MyOutF", "myInFile", "MyOutFF", "myOutputE", "MyInFF"], "co": ["che", "fe", "cho", "ctrl", "pc", "fc", "cmp", "gro", "so", "ob", "c", "oe", "cache", "ca", "o", "ko", "fo", "ee", "cca", "ci", "con", "can", "colo", "la", "flo", "cf", "OO", "cu", "CO", " Co", "ce", "no", "loc", "CC", "cc", "ico", "mc", "BO", "rc", "pe", "coll", "cur", "cos", "bc", "company", "isco", "code", "bo", "auto", "cb", "lo", "bb", " CO", "po", "oo", "Co", "coe", "conf", "aco", "ck", "mo", "lc"], "x3dvFile": ["x3dvSource", "x3rdVFiles", "x3rdVfile", "x3dvsFiles", "x3dsvSource", "x3ndvFiles", "x3ndvFile", "x3dfFile", "x3dvsfile", "x3dvFiles", "x3dvfile", "x3dVPage", "x3dVSource", "x3rdVFile", "x3dfFiles", "x3dvsFile", "x3dsvfile", "x3ndsvFile", "x3rdvFiles", "x3ndsvSource", "x3ndvfile", "x3dsvFile", "x3dfSource", "x3rdvfile", "x3dffile", "x3dsvPage", "x3rdvPage", "x3rdVPage", "x3ndsvFiles", "x3dVFiles", "x3dvsPage", "x3ndvSource", "x3ndsvfile", "x3dsvFiles", "x3dVFile", "x3dVfile", "x3dvPage", "x3rdvFile"], "fis": ["elfisa", "refiss", "fus", " fs", "elfus", "refi", " fiss", "elfbs", "Fs", "fs", "Fus", "refisa", "refis", "fbs", " fi", "elfi", "fi", "elfs", " fus", "fisa", "elfis", "elfiss", "Fis", " fbs", "Fbs", "fiss", " fisa"], "gzos": ["wxo", "bagops", "zipo", "zxops", "bagOS", "gzops", "gzo", "zxOS", "bagos", "bagis", "bago", "zipos", "zipis", "wxis", "zxis", "gzOS", "zxos", "zxo", "zo", "zipops", "zops", "wxos", "zis", "zos", "wxOS", "zipOS", "zOS", "gzis"], "buf": ["done", "bh", "grab", "vec", "cas", "cv", "bin", "bd", "box", "queue", "la", "pad", "seq", "loc", "fab", "batch", "br", "bag", "ff", "uint", "lb", "port", "cur", "bc", "block", "len", "av", "uf", "cap", "uc", "bytes", "cb", "result", "data", "feat", "Buff", "b", "fb", "buff", "ba", "bf", "buffer", "ab", "rb", "db", "dec"], "ret": ["det", "rep", "ry", "reply", "fin", "fun", "continue", "ft", "match", "rt", "bit", " RET", "num", "rf", "count", "default", "rc", "out", "rets", "reg", "f", "len", "success", "pet", "val", "res", "result", "nt", "repl", "att", "obj", "alt", "r", "b", "en", "bf", "id", "Ret", "ver", "RET", "re", "ref"]}}
{"id1": "4686922", "id2": "23517481", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"extractResourceToFile": ["extractResourcesToFile", "extractResourceInfile", "extractResourceAndFile", "extractResourceToResource", "extractResourceInFile", "extractResourceAsResource", "extractResourceToFiles", "extractResourceAsfile", "extractResourceAndResource", "extractResourcesToFiles", "extractResourcesTofile", "extractResourceInResource", "extractResourceAsFiles", "extractResourceTofile", "extractResourceInFiles", "extractResourceAndFiles", "extractResourcesAsFile", "extractResourceAsFile", "extractResourceAndfile", "extractResourcesAsFiles", "extractResourcesAsfile", "extractResourcesAsResource", "extractResourcesToResource"], "resourcePath": ["ResourceUrl", " resourceUrl", "sourceId", " resourcepath", "serviceFolder", "stringFolder", "sourcepath", "resourceId", "sourceUrl", "resourceUrl", "sourcePath", "resourceFolder", "ResourceId", "resourcepath", "stringPath", "servicepath", "servicePath", "Resourcepath", " resourceId", "ResourcePath", "stringpath", " resourceFolder"], "dest": ["folder", "resource", "txt", "temp", "done", "route", "class", "project", "sac", "resources", "dist", "destroy", " Dest", "path", "desc", "die", "content", "sup", "store", "comb", "trans", "default", "tmp", "contract", "config", "flat", "home", "filename", "Dest", "transfer", "result", "img", "output", "data", "target", "prop", " destination", "de", "source", "const", "wb", "src", "later", "file"], "in": ["resource", "In", "pass", "plus", "again", "ini", "c", "n", "IN", "rec", "cin", "is", "din", "inner", "bin", "input", "as", "con", "this", "ins", "conn", "inn", "kin", "up", "connection", "init", "win", "rin", "lin", "isin", "url", "gin", "like", "thin", "f", "inside", "i", "nin", "image", "socket", "sin", "login", "arin", "reader", "r", "b", "inc", "id", "source", "re", "file"], "out": ["temp", "In", "again", "at", "outside", "n", "cache", "o", "ex", "bin", "Out", "copy", "outer", "io", "norm", "outs", "this", "sync", "ins", "co", "conn", "boot", "user", "cookie", "err", "up", "app", "w", "s", "net", "all", "exec", "server", "cos", "f", "i", "off", "a", "image", "lib", "writer", "auto", "socket", "ext", "output", "ax", "obj", "OUT", "null", "b", "inc", "parent", "source", "client", "one", "file"]}}
{"id1": "20375440", "id2": "20100809", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "srcFile": ["rcFiles", "rcPath", "sourceFiles", "srcDir", "destDir", "rcFile", "sourcefile", "srcFiles", "destfile", " srcDir", "destFiles", "srcfile", "rcfile", " srcfile", "sourceFile", "sourcePath", " srcPath", "srcPath", "sourceDir", " srcFiles"], "destFile": ["restFiles", "targetFile", "destPath", "tempFiles", "DestPlace", "destfile", "destFiles", "DestPath", "Destfile", "restPlace", "restfile", "tempPath", "destPlace", "DestFile", "targetFiles", "targetPlace", " destFiles", "tempFile", "restFile", "tempfile", "DestFiles", "targetfile", " destPath", " destfile"], "src": ["cmp", "bs", "dist", "func", "input", "conv", "self", "inst", "ctx", "sc", "slice", "sr", "sys", "in", "sync", "construct", "impl", "conn", "loc", "sup", "proc", "gb", "rc", "upload", "url", "cur", "config", "sec", "ws", "sb", "sl", "loader", "start", "cb", "stat", "ssl", "img", "reader", "secure", "RC", "ources", "ser", "req", "sub", "rs", "source", "stream", "client", "sel", "rb", "sq"], "dest": ["dc", "cdn", "temp", "slave", "class", "wh", "rest", "opt", "dat", "dist", "d", "destroy", "transform", " Dest", "desc", "path", "this", "ui", "dev", "div", "dir", "sup", "trans", "comb", "proc", "out", "cp", "tmp", "usr", "ws", "thin", "des", "ds", "home", "writer", "Dest", "result", "std", "img", "output", "ssl", "test", "obj", "target", "null", "de", "source", "stream", "wb", "end"], "buffer": ["row", "position", "string", "cache", "channel", "capacity", "request", "uffer", "limit", "bin", "input", "copy", "layer", "wave", "feed", "key", "buf", "number", "queue", "slice", "length", "address", "header", "batch", "base", "size", "Buffer", "iter", "value", "bytes", "writer", "transfer", "result", "memory", "reader", "data", "write", "raw", "null", "b", "buff", "flush", "message", "info", "source", "offset", "block", "reference"], "read": ["reads", "pass", "run", "use", "ip", "not", "send", "k", "n", "reading", "fill", "limit", "d", "select", "input", "copy", "READ", "shape", "open", "feed", "add", "number", "key", "sync", "skip", "text", "slice", "length", "no", "pick", "count", "build", "play", "Read", "seek", "default", "show", "exec", "find", "get", "load", "x", "work", "wait", "index", "size", "iter", "i", "allow", "ind", "ok", "check", "start", "ride", "close", "connect", "next", "reader", "level", "data", "write", "parse", "raw", "se", "b", "id", "sleep", "block", "create", "end"]}}
{"id1": "2668853", "id2": "494226", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeStringToFiles", "decodeFileAsFiles", "decodeFileAsfile", "decodeFiletoFiles", "decodeStringToFile", "decodeFileAsStream", "decodeString2Stream", "decodeFile2file", "decodeString2file", "decodeFile2File", "decodeFileTofile", "decodeStringToStream", "decodeStringTofile", "decodeFiletoFile", "decodeFile2Files", "decodeFileToStream", "decodeFileToFiles", "decodeFileAsFile", "decodeString2File", "decodeFiletofile", "decodeFiletoStream", "decodeString2Files", "decodeFile2Stream"], "infile": ["inputfilename", "infp", "inputFile", "outfiles", "minfp", " infiles", "inputfp", "minFile", "inputfiles", "minfile", "outfilename", "minfilename", "outfp", " infilename", "inFile", "inputfile", " inFile", "outFile", "infiles", "infilename"], "outfile": ["OutFile", "outfolder", "infp", "outputfull", "outputFile", " outFile", "outfilename", "outfp", " outfilename", " outfolder", "Outfile", "outputfp", "Outfull", "Outfolder", "infolder", "outputfolder", " outfull", "outFile", "outfull", "outputfile", "outputfilename", " outfp", "infilename"], "in": ["In", "inas", "again", "ini", "IN", "m", "cin", "ex", "is", "din", "inner", "bin", "input", "ic", "as", "con", "this", "pin", "ins", "ac", "min", "conn", "inn", "err", "up", "init", "win", "s", "rin", "lin", "gin", "f", "e", "inside", "i", "nin", "a", "image", "socket", "login", "reader", "data", "r", "b", "inc", "source", "re"], "out": ["In", "pass", "exit", "line", "again", "cache", "op", "o", "ex", "exp", "inner", "bin", "Out", "copy", "as", "outer", "io", "outs", "co", "post", "sync", "on", "conn", "no", "err", "up", "net", "base", "s", "exec", "work", "other", "session", "off", "home", "image", "lib", "socket", "to", "writer", "ext", "output", "error", "write", "obj", "OUT", "target", "b", "point", "inc", "lock", "client", "name", "file"], "buffer": ["resource", "row", "seed", "uffer", "limit", "bin", "pause", "input", "layer", "shape", "wave", "feed", "buf", "queue", "slice", "pad", "length", "address", "batch", "base", "server", "url", "size", "Buffer", "iter", "value", "split", "bytes", "transfer", "border", "memory", "bb", "reader", "reference", "data", "result", "null", "b", "buff", "flush", "offset", "binary", "source", "padding"], "read": [" reach", " Read", "use", "current", " sleep", "count", " r", "start", "check", "next", " send", "write", "sleep", " request", "select", "lex", "feed", "add", "length", " receive", " use", " parse", "play", " load", "find", "x", "wait", "iter", "allow", " check", "connect", "end", "reads", "tell", "send", " find", "copy", "open", "sync", "skip", "seek", "ad", "get", "load", "work", "size", "index", "reader", " copy", "parse", "r", "id", "pass", "run", "line", " reader", "k", " write", "reading", "fill", "limit", "input", "READ", "Read", "exec", " get", " ride", " connect", "ind", "ride", "se", "inc"], "success": ["rolled", "correct", "done", "pass", "status", "accept", "again", "full", "zero", "initial", "results", "failed", "winner", "safe", " Success", "continue", "response", "func", "fast", "Success", "ceed", "first", "warning", "ccess", "content", "construct", "roll", "good", "valid", "successful", "default", " successful", "fail", "danger", "selected", " succeed", "complete", " succ", "value", "ok", "rolling", "result", "better", "true", "error", "data", "follow", "found", "null", "yes", "successfully", "job", "cess"]}}
{"id1": "8329093", "id2": "3631989", "code1": "    public void parse(ParserEvent event) {\n        logger.debug(\"parse() called for link \" + event.getLink().getURI());\n        if (event.getLink().getURI().matches(itemFilter)) {\n            logger.debug(\"Content \" + event.getLink().getURI() + \" matched\");\n            Statement stmt = null;\n            ResultSet rs = null;\n            long checksum1 = 0;\n            try {\n                URL url = new URL(event.getLink().getURI());\n                checksum1 = url.openConnection().getLastModified();\n            } catch (MalformedURLException mfe) {\n                logger.error(\"Malformed url \" + event.getLink().getURI() + \" - \" + mfe.getMessage());\n                return;\n            } catch (IOException ioe) {\n                logger.error(\"Couldn't read \" + event.getLink().getURI() + \" - \" + ioe.getMessage());\n                return;\n            }\n            if ((checksum1 == 0) || (checksum1 == 1)) {\n                Adler32 adler32 = new Adler32();\n                NodeList nodes = (NodeList) event.getPageData().getData();\n                adler32.update(nodes.toHtml().getBytes());\n                checksum1 = adler32.getValue();\n            }\n            try {\n                stmt = conn.createStatement();\n                rs = stmt.executeQuery(\"SELECT * FROM documents WHERE url='\" + event.getLink().getURI() + \"'\");\n                if (rs.first()) {\n                    long checksum2 = rs.getLong(\"checksum\");\n                    if (checksum1 == checksum2) {\n                        stmt.executeUpdate(\"UPDATE documents SET checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    } else {\n                        stmt.executeUpdate(\"UPDATE documents SET checksum=\" + checksum1 + \", checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    }\n                } else {\n                    stmt.executeUpdate(\"INSERT INTO documents VALUES \" + \"(DEFAULT, '\" + event.getLink().getURI() + \"', \" + checksum1 + \", '\" + providerId + \"', \" + String.valueOf(System.currentTimeMillis()) + \")\");\n                }\n            } catch (SQLException e) {\n                logger.error(\"Could't perform database query or update - \" + e.getMessage());\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    rs = null;\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    stmt = null;\n                }\n            }\n        }\n    }\n", "code2": "    public void run() {\n        URL url;\n        try {\n            url = new URL(\"http://localhost:8080/glowaxes/dailytrend.jsp\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((str = in.readLine()) != null) {\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"parse": [" discover", " scan", " setup", "patch", "process", " split", " assemble", " merge", " parsing", "replace", " parser", "Parser", " serve", " explode", " analyse", "arse", " read", " extract", "handle", "apply", " patch", "se", "pack", " dissect", " sniff", "parser", "info", " build"], "event": ["item", "resource", "action", "entry", "attribute", "vent", "entity", "function", "g", "instance", "cache", "context", "environment", "request", "view", "xml", "comment", "response", "node", "input", "actual", "layer", "open", "text", "this", "events", "ce", "content", "object", "user", "address", "original", "handler", "app", "document", "element", "load", "x", "config", "other", "e", "Event", "image", "result", "v", "author", "error", "data", "type", "ev", "style", "message", "info", "update", "stream", "parent", "source", "version", "flow"], "stmt": ["stmd", "STmt", "tpt", "stm", " stmb", "rmt", "stql", "Stmb", "tmb", "admt", " stpt", "stpt", "adql", "spmd", "Stbl", "Stmt", "tmd", "stbl", "rql", "spbl", "adnt", "STm", " stmn", "adbl", "stct", " stct", "Stmd", "stnt", "dpt", "adpt", "tmt", " stbl", "Stct", "adart", "STmd", "dmt", "spart", "dnt", "stmb", " stmd", "rnt", " start", "tbl", "Stpt", "Stm", "stmn", "start", "spmt", "admd", "STmn", "tmn", " stm", "tm", "rpt", "dql", "tct"], "rs": ["rss", "hs", "ks", "ms", "stats", "bs", "ats", "maps", "resources", "pr", "ys", "opens", "lines", "results", "Rs", "gs", "relations", "rt", "sr", "details", "rys", "events", "ins", "otes", "mr", "xs", "obs", "qs", "rc", "ls", "acks", "ars", "cs", "ws", "icks", "vers", "ds", "ges", "ros", "eers", "res", "repl", "result", "vals", "RC", "ts", "hr", "rr", "RS", "r", "ps", "nas", "ras", "rd", "runs", "sels", "src", "ris", "odes", "ows", "rows"], "checksum1": [" checkssum1", "checksumm2", "checksUM1", "checksumbOnce", "checksnum3", " checksum91", "checksummOne", "checksumsOne", "checksque2", "checksam100", "checksnum0", "checkssum0", "checksummer2", "checksummer1", "checksUM2", "checksUM3", " checksum0", "checksumi2", "checkssum91", "checksnumOne", "checksam2", " checkssum2", "checksum91", "checksums1", "checkssum1", " checksum61", "checksnum91", " checksumOne", "checksumi1", "checksam1", "checksUMOne", "checksumi3", "checksums2", "checksumb2", "checkssum2", "checksumbOne", "checkssumOnce", "checksnum1", "checksque0", "checksull1", "checksam0", "checksummer0", "checksnum2", " checksumOnce", " checksum100", "checkssum100", " checkssum91", "checkssum3", "checksumm1", " checksum3", "checksumOnce", "checksnum61", "checksull61", " checkssum61", " checkssumOne", "checksque1", " checkssumOnce", "checksummer91", "checksull2", "checksumOne", " checkssum3", "checkssumOne", "checksum61", " checkssum100", "checksum3", "checksum100", "checksum0", "checksullOne", "checksque100", "checksumb1", "checkssum61", "checksumsOnce", " checkssum0"], "url": ["resource", "pull", "stream", "Link", "ob", "string", "channel", "blog", "http", "xml", "www", "URL", "layer", "ll", "path", "api", "match", "text", "Url", "impl", "conn", "user", "address", "object", "bel", "orb", "loc", "content", "URI", "l", "connection", "base", "ls", "server", "location", "coll", "sl", "f", "link", " URL", "ul", "el", "image", "page", "ssl", "html", "error", "data", "fl", "ball", "r", "b", "job", "web", "id", "uri", "buffer", "message", "org", "file"], "adler32": [" adlr2", "acler32", "adder16", " adger31", "adlr16", "adger2", "acler52", "adle2", "acler16", "adger31", " adger40", " adger32", "adler40", "adlor32", "adger16", "adger52", "adlor52", "adder32", "adler52", "adder40", "adle40", "aclr52", "adlr32", "adlr2", "adler2", " adlr40", " adlr16", "adder31", "aclr2", " adler31", "aclr16", " adler2", "adlr52", "adger40", " adlr32", "adle32", " adger16", "adger32", "adler16", "adlr40", "adlr31", "adlor16", "adler31", "acler2", "adlor2", "aclr32", "adle16", " adler16", " adler40"], "nodes": [" node", "tode", "nobs", "sodes", "Node", "node", "Nodes", "nubes", "Nubes", "snode", "sods", "tents", "todes", "nods", "Nents", " nubes", "snodes", "tods", "nents", "Nobs", "sents", "snobs", "snubes", "sode", " nobs", "Nods"], "checksum2": [" checkssum1", "checksha2", "checkssum82", " checksum0", "checksub2", "checksummer0", "checksum82", " checkssum2", "checksub0", "checksha1", "checksums1", "checkssum1", "checkssum0", "checksub1", "checksum0", "checksummer2", " checkssum82", "checksha82", "checksha0", "checksums0", " checksum82", "checksummer1", "checksums2", "checkssum2", " checkssum0", "checksummer82"]}}
{"id1": "19335986", "id2": "19687456", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["uncatchedexc", "unchandledexc", "Catchedexc", "uncatchedEvent", "uncatchedException", "CaughtEvent", "unchandledEvent", "unchandledException", "Caughtexc", "uncaughtexc", "uncachedException", "CatchedException", "CatchedEvent", "uncachedexc", "uncachedEvent", "uncaughtEvent", "CaughtException"], "t": [" td", "ty", "n", "c", "g", "m", "te", "d", "title", "tree", " T", "let", "ed", "tr", "ing", "p", "it", "l", "w", "s", "out", "f", "tx", "ts", "type", "r", "T"], "e": ["eu", "fe", "c", "oe", "m", "environment", "o", "d", "ee", "ge", "be", "enter", "ce", "ed", "er", "eb", "ie", "Exception", "err", "p", "ception", "s", "element", "pe", "event", "j", "exc", "f", "E", "ele", "ep", "code", "i", "el", "example", "ne", "se", "error", "data", "ae", "ev", "diff", "r", "esi", "en", "de", "es", "ec", "me", "ace"], "display": ["fe", "dis", "status", "window", "container", "position", "description", "host", "panel", "view", "d", "report", "screen", "platform", "process", "this", "design", "summary", "content", "object", "Display", "play", "p", "profile", "default", "app", "show", "layout", "config", "scroll", "hide", "image", "page", "style", "de", "me", "body", "console", "monitor"], "shell": ["mail", "status", "live", "ml", "container", "sh", "m", "host", "environment", "gui", "xml", "sym", "tool", "copy", "log", "tools", "process", "child", "sound", "Shell", "bash", "cl", "l", "app", "exec", "clone", "server", "math", "system", "help", "sb", "machine", "cli", "hell", "el", "image", "h", "kernel", "echo", "b", "loop", "launch", "lock", "buffer", "body", "console", " Shell", "poll"], "message": [" exception", "mail", "application", "status", "media", "description", "management", "m", "request", " messenger", "view", "xml", "response", "copy", "essage", "msg", "log", "report", "queue", "mess", "summary", "email", "object", "content", "address", "header", "translation", "flash", "document", "model", "event", "server", "Message", "value", "image", "page", "member", "result", "output", "error", "data", "meter", "buffer", "update", "body", "console", "monitor"], "e1": ["exc8", "exc1", "E2", " e2", "e8", "E8", "e2", "exc2", "exc3", " e8", " e3", "e3", "E1", "E3"]}}
{"id1": "22410173", "id2": "20920051", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "source": ["resource", "route", "use", "site", "Source", "inner", "input", "copy", "ource", "path", "down", "from", "slice", "ins", "unit", "ie", "up", "connection", "base", "url", "size", "iter", "SOURCE", "start", "internal", "sin", "image", "reader", "ources", "target", "id", "parent", "stream", "src", "name", "file"], "dest": ["folder", "temp", "done", "exit", "project", "dist", "bin", "destroy", "desc", "down", "path", "die", "this", "comb", "connection", "orig", "tmp", "delete", "thin", "flat", "home", "Dest", "transfer", "img", "output", "test", "true", "target", " destination", "de", "wb", "src", "name", "later", "file"], "in": ["resource", "In", "pull", "again", "n", "c", "ini", "IN", "m", "cin", "inner", "din", "bin", "src", "input", "as", "con", "this", "pin", "ins", "min", "conn", "inn", "ie", "err", "up", "init", "win", "s", "url", "work", "gin", "f", "inside", "i", "by", "nin", "a", "image", "socket", "start", "file", "login", "reader", "data", "r", "b", "plugin", "inc", "id", "info", "lock", "client", "re", "name"], "out": ["timeout", "temp", "not", "at", "again", "cat", "n", "c", "channel", "o", "option", "call", "ex", "exp", "inner", "bin", "with", "Out", "self", "log", "outer", "io", "outs", "this", "sync", "conn", "no", "our", "err", "up", "connection", "init", "net", "w", "exec", "url", "index", "pool", "off", "password", "i", "lib", "socket", "plain", "writer", "to", "ext", "img", "output", "ou", "write", "data", "obj", "OUT", "vert", "inc", "id", "parent", "client", "name", "file", "extra"]}}
{"id1": "13439950", "id2": "8069594", "code1": "    public String readRemoteFile() throws IOException {\n        String response = \"\";\n        boolean eof = false;\n        URL url = new URL(StaticData.remoteFile);\n        InputStream is = url.openStream();\n        BufferedReader br = new BufferedReader(new InputStreamReader(is));\n        String s;\n        s = br.readLine();\n        response = s;\n        while (!eof) {\n            try {\n                s = br.readLine();\n                if (s == null) {\n                    eof = true;\n                    br.close();\n                } else response += s;\n            } catch (EOFException eo) {\n                eof = true;\n            } catch (IOException e) {\n                System.out.println(\"IO Error : \" + e.getMessage());\n            }\n        }\n        return response;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"readRemoteFile": ["readStaticfile", "loadremotefile", "loadremoteResponse", "loadRemoteResponse", "readLocalFile", "readStaticFile", "readLocalResponse", "readStaticResponse", "loadremoteFiles", "loadRemotefile", "readremoteFiles", "readRemoteFiles", "readRemoteResponse", "loadRemoteFile", "readremoteResponse", "readStaticFiles", "readRemotefile", "readremoteFile", "loadremoteFile", "readremotefile", "loadRemoteFiles", "readLocalFiles", "readLocalfile"], "response": ["Response", "resource", "application", "status", "line", "description", "respond", "respons", "string", "site", "reply", "request", "http", "results", "service", "answer", "api", "feed", "onse", "json", "content", "object", "resp", "offer", "ception", "out", "server", "array", "e", "i", "value", "example", "res", "result", "next", "output", "error", "data", "message", "uri", "body", "ss"], "url": ["resource", "ob", "zip", "host", "http", "str", "URL", "ur", "open", "io", "Url", "rl", "impl", "bel", "browser", "l", "base", "ls", "server", "plug", "sl", "f", "i", "remote", "file", "ssl", "r", "b", "jar", "web", "uri", "stream", "org", "fr", "ref"], "is": ["ib", "or", "ip", "ios", "bs", "ir", "http", "str", "was", "has", "as", "api", "ais", "io", "os", "IS", "sr", "in", "ri", "are", "it", "fs", "Is", "out", "iso", "ar", "iss", "sp", "its", "i", "close", "res", "bis", "r", "b", "id", "es", "info", "uri", "src", "ris", "fr"], "br": ["ib", "body", "ch", "bh", "serv", "ob", "http", "str", "ber", "be", "io", "os", "buf", "rt", "sr", "bro", "BR", "tr", "mr", "bridge", "gr", "orb", "er", "err", "rel", "bl", "browser", "cr", "arr", "sp", "dr", "iter", "bar", "i", "res", "cb", "result", "bb", "reader", "img", "hr", "obj", "r", "b", "fb", "bed", "stream", "ab", "rb", "fr"], "s": ["resource", "status", "js", "si", "S", "u", "ses", "n", "string", "c", "m", "g", "lines", "o", "results", "sym", "sf", "str", "d", "input", "os", "details", "sr", "content", "single", "sample", "p", "l", "strings", "ls", "shell", "ws", "sl", "f", "services", "sb", "e", "su", "session", "i", "ns", "bytes", "res", "result", "ssl", "v", "data", "raw", "sv", "r", "b", "ps", "t", "message", "es", "rs", "source", "null", "site", "ss"], "eof": ["eoh", "eeoh", "oeof", "eif", "Eom", "Eok", "eol", "oeoh", "eeok", "geif", "eeef", "yeof", "eef", " eol", "EOF", "oeol", "ueom", "eaf", "Eoh", "yeOF", "ueof", "geore", "oeok", "eom", "Eaf", " eom", "eeol", "ueaf", "geOF", "ueOF", "geof", "eore", "eeaf", "Eef", "eok", "eeof", "Eif", " eaf", "Eore", "eOF", " eef", "yeif", "Eol", "yeore", " eOF", "Eof"]}}
{"id1": "6988216", "id2": "481364", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "label": 0, "substitutes": {"testSimpleQuery": [" runClientFilter", "runRawQuery", "runRawConnect", " runSimpleFilter", " runBasicQuery", " runSimpleQuery", "runRawSearch", " runClientQuery", " runClientConnect", " runBasicFilter", "runSimpleQuery", " runSimpleSearch", " runRawFilter", "runSimpleConnect", " runSimpleConnect", " runBasicSearch", " runRawConnect", "runSimpleFilter", "runSimpleSearch", "runRawFilter", " runRawSearch", " runClientSearch", " runBasicConnect", " runRawQuery"], "dummySource": ["dandySource", "dellyContent", "dumbConfig", "dellyService", "puddyType", "dandyClient", "daddyContent", "dundleSource", " dumbSource", "dandySourceFile", "duddyService", "puddyService", "pummyType", "dummyOrigin", "pummyClient", "dumbOrigin", "dummySourceFile", "puddySite", "dumbContent", "duddyType", "daddyClient", "dummyType", "dummySite", "duddySource", "puddyContent", " dummyOrigin", "pummySourceFile", "dummyConfig", "dumbSource", "daddyService", "daddySourceFile", "duddySourceFile", "pummyContent", " dumbContent", "duddyClient", "dummyClient", "duddySite", "dundleOrigin", "puddySource", "dellySource", "daddySite", "daddyType", "duddyConfig", "puddySourceFile", "pummySource", "dundleContent", " dumbConfig", "duddyOrigin", " dumbOrigin", "pummySite", "dundleConfig", "duddyContent", " dummyConfig", "puddyClient", "dummyService", "pummyService", "dandySite", "daddySource", "dellyType"], "os": ["or", "ks", "us", "ms", "ol", "ios", "bs", "osi", "ens", "css", "mos", "op", "o", "dos", "oa", "is", "oss", "as", "io", "sys", "aos", "object", "bos", "conn", "acs", "oc", "om", "oos", "fs", "ose", "obs", "s", "nos", "pos", "out", "oS", "los", "iso", "vs", "ls", "ops", "cos", "Os", "i", "ds", "ox", "ori", "oses", "ros", "ns", "ok", "ols", "ows", "ou", "ps", "uns", "es", "OS", "ss"], "dummyContent": ["dummyReader", "dummyContents", "duckyBody", "DummySource", "dellyContent", " dellyOutput", "dumpingContents", "dumperOutput", "dumpingcontent", "DuckyContent", "DummyBody", " dummyOutput", "duckyReader", " dellyContent", "duddySource", "dellyContents", "dumperReader", " dummyContents", "dumpercontent", "DuckyBody", "dumperSource", "duddyReader", "dumperBody", "duckySource", "duckyContent", "dummycontent", "dummyOutput", "DummyContent", "dumpingOutput", "duddyBody", "dellycontent", " dellycontent", " dellyContents", "dumpingContent", "DuckySource", "dummyBody", "dellyOutput", "dumperContent", "duddyContent", "DummyReader", "DuckyReader", "dumperContents", " dummycontent"], "source": ["resource", "slave", "class", "use", "seed", "string", "resources", "host", "cache", "channel", "Source", "proxy", "service", "scope", "node", "ource", "search", " sources", "sc", "text", "sync", "client", "object", "unit", "connection", "s", " Source", "storage", "element", "url", "sn", "cos", "config", "size", "sl", "e", "i", "SOURCE", "sin", "result", "reader", "secure", "ser", "ources", "target", "info", "stream", "uri", "parent", "src", "site", "core"], "content": ["resource", "body", "media", "description", "clean", "css", "host", "current", "xml", "expression", "title", "version", "cover", "comment", "service", "response", "transform", "input", "report", "news", "feed", "match", "sol", "cms", "child", "music", "address", "header", "document", "model", "server", "Content", "url", "load", "cos", "config", "size", "children", "code", "value", "image", "html", "result", "output", "data", "target", "comments", "message", "update", "text", "cont", "activity"], "qResult": ["iqresult", "qResults", "queryResults", " qResults", "rRes", "qResponse", "kReturn", "queryFilter", "iqResponse", "kResult", " qresult", "QReturn", "rResult", "queryResult", "QFilter", "qRes", "qReturn", "kResults", "QResults", "queryresult", " qResponse", "qFilter", "kFilter", "qSource", "iqResult", "queryReturn", "rresult", "iqResults", "querySource", "kresult", "kSource", "kRes", "rSource", "queryRes", "queryResponse", "QResult", "qresult"], "results": ["reports", "pages", "resources", "lines", "values", "errors", "ids", "response", "objects", "versions", "details", "shows", "files", "events", "ins", "Results", "groups", "members", "RESULTS", "successful", "tests", "qs", "s", "its", "children", "ries", "vers", "ions", "blocks", "res", "result", "features", "data", "models", "items", "docs", "users", "runs", "collection", "rows"], "it": ["or", "entry", "si", " It", "ip", "not", "pit", "and", "you", "op", "ait", "IT", "rit", "itted", "ci", "ic", "iti", "edit", "list", "slice", "ITS", "the", "in", "ins", "ort", "ited", "lit", "mit", "p", "l", "init", "its", "ati", "iter", "ite", "i", "split", "stat", "v", "It", "r", "t", "id", "sit", "info", "which"], "rSrc": [" rDsrc", "rAsrc", "RIsrc", " rDsource", "RSrc", "rEsource", "rDsource", "RIsource", " rSRC", " rSsrc", "rDssrc", " rEsrc", "rPsRC", "rAsRC", " rDssrc", "rEssrc", " rEsRC", "rPsource", "rAssrc", "rSrec", "RSource", "rPssrc", "rIsrc", "RSRC", "rDsRC", "RIsrec", "rDsrc", " rDsRC", "rIsrec", "rEsrc", " rEsource", " rEssrc", "rEsRC", "rPsrc", "rAsource", "RIsRC", "rIsource", " rSource", "rSource", "rSRC", "RSrec", "rAsrec", "rIsRC", "rSsrc"], "rSrcIn": ["rAsrcin", "rSsrcOut", "rSvcIN", "rCrcIn", "rSourcein", "rSRCIns", "rCRCIn", "rCsrcIn", "rCsrcIN", "rSrcOut", "rCrcIns", "rSRCOut", "rSourceIn", "rAsrcOut", "rSrcIN", "rSRCin", "rSvcOut", "rSourceOut", "rCrcIN", "rAsRCOut", "rSsrcIN", "rSvcIns", "rCrcOut", "rSvcin", "rCRCIns", "rSrcin", "rAsrcIn", "rCrcin", "rSRCIn", "rSrcIns", "rSourceIns", "rAsRCin", "rCsrcin", "rCsrcOut", "rSsrcIn", "rAsRCIn", "rSRCIN", "rSvcIn", "rSsrcin", "rCRCOut"], "actualOut": ["operatorOut", "assertOut", "publicIn", " actualIn", " actualOUT", "eventout", "publicOut", "eventOut", " actualWin", "actualBridge", "operatorIn", "realOut", " ActualOut", "actualout", " ActualOUT", "nexpectedout", "illegalOUT", " ActualBridge", "assertOUT", "actualWin", "operatorOUT", "realIn", "assertBridge", "assertIn", "actualIn", " actualOutput", "publicOutput", "illegalOut", "illegalOutput", "realout", "nexpectedWin", " actualout", "nexpectedOut", "actualOutput", "realWin", " ActualIn", "publicOUT", "nexpectedIn", " actualBridge", "actualOUT", "eventOUT", "eventIn", "illegalIn", "operatorout"]}}
{"id1": "21979717", "id2": "9738825", "code1": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void load(URL url) throws IOException {\n        ResourceLocator locator = null;\n        try {\n            locator = new RelativeResourceLocator(url);\n        } catch (URISyntaxException use) {\n            throw new IllegalArgumentException(\"Bad URL: \" + use);\n        }\n        ResourceLocatorTool.addResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n        InputStream stream = null;\n        try {\n            stream = url.openStream();\n            if (stream == null) {\n                throw new IOException(\"Failed to load materials file '\" + url + \"'\");\n            }\n            logger.fine(\"Loading materials from '\" + url + \"'...\");\n            load(stream);\n        } finally {\n            if (stream != null) stream.close();\n            ResourceLocatorTool.removeResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n            locator = null;\n        }\n    }\n", "label": 0, "substitutes": {"upload": ["paste", "run", "accept", "execute", "request", "select", "open", "add", "process", "post", "download", " Upload", "archive", "up", "init", " transfer", "load", "Upload", "start", "transfer", "save", "submit", " download", "Submit", " submit", "create"], "fileResult": ["fileRank", " fileResults", "filesresult", "fileresult", " fileresult", "fpRes", " fileRes", "FileRes", "downloadRank", "fpResults", "downloadResults", "FileRank", "downloadResult", "fpResult", "fileRes", "filesRes", "FileResult", "fpRank", "Fileresult", "downloadRes", "FileResults", "filesResults", "fileResults", "filesResult"], "in": ["In", "again", "ini", "c", "cache", "IN", "cin", "inner", "bin", "input", "pin", "ins", "on", "min", "conn", "inn", "into", "p", "kin", "up", "isin", "init", "win", "rin", "lin", "gin", "f", "inside", "i", "image", "socket", "login", "arin", "data", "vin", "inc", "conf", "info", "source", "tin", "file"], "url": ["pull", "ob", "c", "channel", "host", "http", "pl", "www", "URL", "log", "path", "ur", "api", "gl", "Url", "impl", "conn", "address", "bel", "cl", "l", "connection", "ls", "server", "coll", "sl", "f", "ul", "image", "socket", "ssl", "fl", "b", "web", "uri", "client", "org", "file"], "con": ["fa", "rou", "ch", "ctrl", "pc", "run", "ver", "fc", "cm", "c", "ca", "request", "http", "cons", "Conn", "fun", "func", "conv", "log", "can", "open", "co", "sync", "pin", "cf", "client", "ran", "conn", "on", "min", "cl", "connection", "part", "cn", "rc", "cp", "ocon", "exec", "cur", "syn", "bc", "non", "per", "CON", "Con", "uc", "close", "socket", "remote", "login", "ssl", "plain", "gen", "en", "conf", "ec", "sub", " conn", "pen", "connect", "re", "un"], "out": ["resource", "ch", "external", "line", "again", "at", "c", "cache", "o", "ex", "bin", "Out", "input", "copy", "as", "outer", "io", "can", "outs", "this", "on", "conn", "object", "err", "connection", "base", "win", "server", "pool", "image", "socket", "v", "login", "ssl", "output", "obj", "OUT", "b", "conf", "inc", "parent", "client", "file"], "in2": ["in02", "In1", "out2", "err1", "input4", "inTwo", "InTwo", " intwo", "out1", "intwo", "errTwo", "err2", "in1", "IN2", " in02", " in4", "in4", "IN4", "In4", "inputTwo", "In2", "input02", "INTwo", "IN02", " inTwo", "input2", "outtwo", "outTwo", " in1", "errtwo", "out4"], "buf": ["font", "done", "bh", "vec", "cat", "utf", "cas", "cv", "bin", "fd", "bd", "box", "la", "cf", "seq", "batch", "br", "fab", "bag", "ha", "ff", "lb", "base", "rc", "bc", "Buffer", "block", "pool", "av", "home", "uf", "cap", "uc", "bytes", "cb", "data", "feat", "Buff", "fb", "b", "buff", "ba", "bf", "buffer", "text", "rb", "db", "dec"], "bytesRead": ["tesRun", "BytesRead", " bytesWritten", "bytesWritten", " bytesRun", " bytesLength", "BytesWrite", "bytesLength", "bytesWrite", "blocksWrite", "blocksread", "rowsread", "linesRun", "byteWrite", "bytesLoad", "tesWrite", "tesRead", "BytesLoad", "bytesread", " bytesUse", "bytesRun", "byteRead", "blocksRead", "bytesUse", "blocksUse", "BytesLength", " bytesLoad", "rowsUse", "rowsRead", "linesWrite", "linesRead", "linesWritten", " bytesread", "rowsWrite", "byteLength", "tesWritten", " bytesWrite", "byteLoad"]}}
{"id1": "14038176", "id2": "19109981", "code1": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "code2": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fetchUrl": ["forkLocation", "fprocessLink", "fprocessContent", "porkLocation", "fdownloadUrl", "fprocessLocation", "forkContent", "fdownloadLink", "porkContent", "fetchLocation", "forkUrl", "petchLink", "forkLink", "fetchContent", "petchLocation", "fetchLink", "fdownloadContent", "petchUrl", "porkLink", "porkUrl", "petchContent", "fprocessUrl", "fdownloadLocation"], "urlString": ["httpStr", "urlStr", " urlName", "URLStr", "URLString", " urlstring", "URLService", " urlStream", "resourceStream", "urlService", " urlStr", "httpString", "urlStream", "httpName", "resourceService", "resourceStr", "resourceString", " urlService", "urlstring", "resourcestring", "URLStream", "httpstring", "resourceName", "urlName"], "url": ["resource", "string", "blog", "http", "service", "URL", "log", "ur", "feed", "Url", "user", "object", "bel", "build", "browser", "l", "connection", "base", "server", "loader", "sl", "f", "image", "ssl", "bb", "r", "b", "plugin", "uri", "stream", "buffer", "source", "org", "file"], "reader": ["resource", "or", "row", "reading", "upper", "http", "oder", "ler", "input", "layer", "io", "feed", "driver", "in", "ri", "er", "cher", "handler", "err", "bird", "rc", "server", "loader", "read", "Reader", "per", "iter", "e", "rer", "i", "worker", "editor", "writer", "result", "bb", "rr", "r", "rx", "parser", "rar", "buffer", "stream", "uri", "source"], "line": ["inline", "entry", "row", "pass", "string", "word", "LINE", "str", "comment", "character", "le", "Line", "response", "log", "feed", "char", "number", "key", "column", "content", "object", "letter", "header", "cl", "l", "part", "base", "lin", "cell", "sl", "block", "link", "iter", "e", "code", "len", "page", "result", "next", "error", "data", "raw", "style", "id", "message", "lf", "buffer", "source", "text", "body", "sel", "name", "job", "file", "lc"], "builder": ["entry", "row", "string", "upper", "board", "oder", "response", "layer", "api", "feed", "builders", "this", "driver", "database", "object", "letter", "creator", "keeper", "address", "build", "db", "base", "array", "sb", "iter", "building", "holder", "wrapper", "bean", "Builder", "editor", "writer", "to", "result", "runner", "bb", "r", "b", "null", "parser", "message", "info", "buffer", "uri", "web", "block", "core"]}}
{"id1": "19944975", "id2": "15797402", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["writeSection", "writeReport", " writeSection", "saveConfiguration", "saveReport", "saveConfig", "WriteConfiguration", "writeConfig", "WriteReport", "WriteSection", " writeConfig", "WriteConfig", "saveSection", " writeReport"], "out": ["resource", "temp", "inas", "external", "window", "line", "again", "at", "project", "string", "c", "m", "IN", "o", "ex", "exp", "xml", "inner", "scope", "Out", "report", "path", "io", "outs", "list", "key", "sync", "this", "object", "conn", "user", "err", "connection", "w", "base", "init", "prefix", "exec", "server", "config", "pool", "dump", "password", "filename", "lib", "writer", "res", "plain", "ext", "output", "reader", "write", "obj", "OUT", "flush", "parent", "client", "name", "file"], "url": ["resource", "ob", "string", "channel", "xml", "http", "service", "URL", "path", "ll", "io", "open", "feed", "api", "Url", "object", "conn", "address", "rel", "l", "connection", "base", "server", "location", "config", "sl", "f", "image", "page", "ssl", "data", "r", "b", "web", "uri", "stream", "source", "org", "file"], "in": ["resource", "In", "inas", "again", "serv", "n", "c", "ini", "IN", "cin", "xml", "is", "din", "inner", "bin", "input", "copy", "as", "pin", "cms", "ins", "ac", "conn", "min", "inn", "err", "kin", "isin", "s", "rin", "win", "lin", "gin", "f", "inside", "i", "nin", "a", "socket", "login", "ssl", "reader", "data", "r", "b", "inc", "id", "source", "stream", "file"]}}
{"id1": "6966398", "id2": "9109613", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"reader": ["resource", "df", "or", "row", "reads", "ry", "k", "instance", "context", "o", "reading", "rake", "oder", "ler", "raf", "input", "cer", "manager", "io", "ner", "feed", "driver", "cms", "ri", "client", "pp", "keeper", "er", "handler", "book", "p", "connection", "rc", "pe", "server", "load", "dr", "config", "loader", "read", "Reader", "iter", "per", "rw", "her", "writer", "se", "rr", "r", "parser", "rar", "source", "stream", "buffer", "builder", "file"], "ks": ["ics", "acts", "akes", "reads", "kes", "hs", "KS", "ms", "books", "bs", "k", "opens", "ko", "checks", "gets", "orks", "ctx", "co", "ke", "powers", "acs", "fs", "qs", "ki", "ans", "ls", "inks", "acks", "cks", "vs", "ops", "ches", "keys", "icks", "cs", "ns", "ds", "ku", "CS", "kb", "ges", "ips", "sk", "se", "ps", "DS", "es", "rs", "works", "ck", "kies", "ss", "rows"], "key": ["Key", "seed", "k", "c", "cache", "pg", "ca", "secret", "ee", "service", "state", "io", "co", "char", "pair", "ke", "ce", "ring", "trust", "user", "p", "base", "ki", "court", "pe", "server", "keys", "read", "code", "value", "transfer", "ssl", "type", "point", "sign", "lock", "client", "file"], "chain": ["wrap", "root", "container", "c", "cache", "chains", "table", "wheel", "secret", "circle", "family", "path", "sequence", "box", "network", "list", "none", "slice", "pair", "object", "store", "cr", "rule", "mc", "scale", "base", "coll", "Chain", "config", "enc", "code", "set", "image", "range", "stack", "lock", "crypt", "block", "collection", "file"], "os": ["rss", "ms", "ol", "ios", "ob", "osi", "oid", "op", "o", "opens", "is", " o", "oss", "options", "io", "outs", "aos", "object", "bos", " bos", "p", "fs", "s", "pos", "los", "iso", "ops", "cos", "ot", "Os", "ds", "oses", "ros", "res", "ou", "ps", "es", "rs", "OS"], "stamper": ["starmple", "spampe", "function", " nostameple", "g", "spamper", " nostamler", "streampe", "stammper", "stAMper", "spammer", "path", "spAMpe", "stAMmer", "stampper", "stammple", "this", " nostamepper", "starmper", "stammpe", "starmpper", " nostamper", " nostameper", "stammmer", "s", "stAMpe", "stampe", "streammer", "stameple", "streamper", "spamler", "stamler", "spAMler", "stameler", "_", "stample", "starmler", "stammler", "stammer", "stammpper", "stamepper", "stAMler", "stameper", "data", " nostample", "streamler", " nostameler", " nostampper", "spAMper", "spAMmer"], "appearance": ["ppearance", "attfacing", "installear", "appasion", " appears", "ppearing", "suppearing", "byearance", "feedearance", "feedointment", "formismo", "atteared", "formearing", "appfacing", "askence", "appence", " appfacing", "appearing", "suppearance", "appismo", "ppaser", "signearing", "appointment", "attence", "feedfacing", "suppfacing", "byismo", "askeared", "feedear", " appeared", "Appearance", "signfacing", "ppear", "signear", "byearing", "suppasion", "signearance", "askearance", "installearing", "Appears", "formaser", " applier", "appears", "signointment", "askfacing", "formear", "byear", "installearance", "appear", "ppasion", "signears", "signlier", "attearance", "suppointment", "applier", "Appearing", " appence", "appaser", " appear", " appearing", " appaser", "formearance", " appismo", "installasion", "Applier", "suppear", "appeared"]}}
{"id1": "397240", "id2": "8625346", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "18504192", "id2": "3187685", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "in": ["In", "or", "again", "at", "ini", "c", "IN", "m", "d", "inner", "bin", "input", "old", "copy", "io", "ins", "ac", "min", "inn", "part", "base", "url", "index", "i", "image", "login", "reader", "diff", "data", "b", "inc", "id", "info", "parent", "buffer", "src", "name", "file"], "out": ["temp", "external", "line", "again", "n", "c", "cache", "string", "o", "ex", "call", "Out", "copy", "io", "outs", "dest", "conn", "object", "p", "err", "part", "w", "base", "connection", "prefix", "exec", "password", "writer", "output", "data", "obj", "OUT", "target", "b", "point", "inc", "client", "name", "file"], "source": ["slave", "use", "project", "channel", "Source", "view", "proxy", "service", "scope", "input", "self", "ource", "copy", "from", "slice", "sync", "dest", "unit", "ie", "connection", "storage", "clone", "server", "component", "get", "size", "settings", "sl", "iter", "i", "SOURCE", "start", "sin", "writer", "ssl", "se", "reader", "secure", "ources", "target", "null", "parent", "stream", "client", "src", "core", "origin"], "destination": ["testinated", "declification", "destinations", "testinator", "declination", " destinator", " destining", "declinator", "Destinations", "destinator", "contining", "Destinator", "dependification", "Destination", "destinated", "destification", "Destinated", "destining", "testination", "dependination", "dependinated", "contination", " destinated", "Destification", "continated", "testinations", "Destining", "continator", "dependinator", " destinations", "declinated"]}}
{"id1": "8973505", "id2": "20306677", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "label": 0, "substitutes": {"writeFileType": ["createFiletype", "writeFILETypes", "createFilesHeader", "writePagetype", "writeFileHeader", "createFilesTypes", "writeFileTypes", "writePageHeader", "writeFilestype", "createFileType", "createFileTypes", "writeFILEHeader", "writeFILEType", "createFileHeader", "writeFilesTypes", "createFilestype", "writeFILEtype", "writeFiletype", "writeFilesHeader", "writeFilesType", "writePageType", "createFilesType", "writePageTypes"], "uriFile": ["riFile", "urifile", "uiUrl", "uriFiles", "URIFiles", "uifile", "riFiles", "riFilename", "uiFiles", "URIfile", "URIFilename", "uriUrl", "filenameFile", "URIFile", "filenameFiles", "filenamefile", "filenameFilename", "riUrl", "uiFile", "rifile", "URIUrl", "uriFilename"], "outputfile": ["Outputfull", "inputfilename", "outputfull", "inputFile", "inputdir", "outputdir", "Outputdir", "resourcefilename", "unitfiles", "outputstring", "outputFile", "OutputFile", "unitstring", "Outputfile", "inputfiles", " outputdir", " outputfull", "inputstring", "inputfile", " outputFile", "unitfile", "resourcefile", "outputfilename", "outputfiles", "resourcefiles", "unitfilename", "resourcestring", "inputfull"], "num": ["span", "nb", "amount", "multi", "n", "zero", "initial", "col", "limit", "mult", "master", "sum", "con", "number", "NUM", "coord", "umi", "length", "no", "count", "unit", "Num", "batch", "index", "len", "split", "term", "nam", "inc", "offset", "nu", "dim", "loop", "name", "common"], "writer": ["we", "wt", "function", "manager", "Writer", "engine", "book", "w", "out", "socket", "writing", "write", "wl", "entry", "external", "ler", "walker", "outer", "report", "io", "feed", "header", "wire", "element", "office", "per", "editor", "page", "output", "data", "written", "null", "message", "master", "wb", "later", "root", "writ", "xml", "ee", "driver", "creator", "er", "document", "part", "wan", "ws", "index", "rw", "worker", "journal", "author", "type", "r", "lock", "width", "temp", "riter", "window", "writers", "method", "inner", "service", "layer", "wave", "wa", "key", "object", "handler", "unit", "server", "loader", "e", "session", "wrapper", "format", "widget", "wr", "style", "buffer", "source", "builder"], "uri": ["resource", "route", "http", "winner", "database", "umi", "address", "prefix", "location", "eni", "gi", "collection", "file", "username", "href", "uid", "sequence", "nor", "verb", "URI", "connection", " URI", "element", "link", "ori", "filename", "iri", "direction", "mi", "term", "picture", "message", "course", "folder", "attribute", "multi", "oid", "pi", "node", "di", "document", "query", "component", "cli", "doi", "li", "range", "id", "binary", "uni", "origin", "reference", "wiki", "token", "qi", "string", "ilo", "context", "ui", "ri", "theme", "unit", "handler", "base", "du", "i", "hub", "feature", "remote", "nil", "directory", "plugin", "metadata", "source"], "counter": ["entry", "computer", "ver", "current", "instance", "step", "ter", "vector", "inter", "pointer", "expression", "currency", "comment", "inner", "condition", "master", "continue", "trace", "time", "cpu", "outer", "ner", "sequence", "number", "enter", "second", "repeat", "nr", "Counter", "creator", "keeper", "handler", "count", "book", "batch", "cookie", "hello", "coll", "server", "clock", "loader", "name", "index", "processor", "iter", "controller", "i", "worker", "record", "page", "result", "runner", "meter", "parser", "timer", "loop", "info", "parent", "offset", "collection", "race", "keep", "lc", "reference"], "reader": ["row", "riter", "ger", "ir", "reading", "upper", "oder", "ruby", "inner", "ler", "layer", "io", "ner", "feed", "driver", "in", "ri", "keeper", "er", "handler", "lr", "bird", "l", "loader", "read", "Reader", "rer", "per", "iter", "e", "worker", "editor", "finder", "rr", "r", "rx", "parser", "rar", "stream", "buffer"], "url": ["resource", "string", "channel", "blog", "http", "www", "URL", "path", "io", "feed", "Url", "ri", "client", "user", "download", "address", "browser", "l", "connection", "base", "ls", "server", "config", "sl", "link", "li", "image", "page", "ssl", "plugin", "id", "web", "stream", "text", "source", "file"], "myConnection": ["Myconnection", "someConn", " myconnection", "someConnection", "myconnection", "myConnector", " myConn", "myConn", "yourconnection", "MyConnect", " myConnect", "MyConnection", "yourConnection", "MyConnector", " myConnector", "MyConn", "yourConn", "someReader", "myConnect", "yourConnector", "MyReader", "someConnect"], "myReader": ["MyParser", " myRead", "MyWriter", "myParser", "MyReader", "yourWriter", "MyRead", "myRead", "myWriter", "yourParser", " myWriter", " myParser", "yourRead", "yourReader"], "line": ["inline", "look", "entry", "row", "pass", "day", "use", "string", "note", "lines", "word", "LINE", "comment", "le", "Line", "response", "log", "feed", "key", "cl", "ri", "user", "no", "letter", "header", "frame", "rule", "liner", "part", "base", "l", "lin", "cell", "pe", "element", "du", "non", "link", "code", "el", "page", "range", "error", "data", "parse", "style", "point", "id", "message", "lf", "source", "text", "block", "column", "name", "file", "lc", "end"], "linecount": ["pageindex", "rowcache", "letterlength", " linelength", "rowlength", "rowlen", "rowcount", " linecache", "linelength", "Linecount", "linenumber", "LineCount", "linesize", " linenumber", "linecache", "Linesize", "linelen", "letterlen", "Linecache", "lettercount", " lineindex", "lineCount", "pagecount", " lineCount", "pagenumber", " linelen", "Linenumber", "Lineindex", "lineindex", " linesize", "rowsize", "lettersize", "pageCount"], "hasOWL": ["hasOWl", "hasOWLA", "hasEWLL", " hasEWLM", "HasEWLA", " hasOWLA", "hasOULA", "HasOWLM", "hasODL", "hasBYLL", "hasEFLM", " hasOWLL", "hasEFl", "hasOUL", "hasBYl", "HasOWLL", "hasODLL", "hasODLA", "hasOWSL", " hasOWLM", "HasOWLA", "hasOULL", " hasEWDL", "hasEFLA", "hasEWLA", "hasOWLL", "hasEWL", "hasOWSl", "HasEWL", "hasODLM", " hasEWLA", "hasEWl", "hasOULM", "hasBYDL", "hasODl", " hasOWl", "HasEWLM", " hasEWL", "hasOWDL", "HasOWL", "hasBYL", "hasOWLM", " hasEWLL", "hasOWSLL", "HasEWLL", "hasEWLM", "hasOWSDL", "hasEWDL", " hasEWl", "hasEFL", " hasOWDL"], "hasRDFS": ["hasXDPE", "hasRNFU", "hasCDFE", "hasRdfS", "hasRDFs", "hasGRUFS", "hasRNFs", "hasXDFE", "hasCDFs", "hasRDFAST", "hasRTFE", "hasRdfE", "hasRdfs", "hasGRDFSU", "hasRDPE", "hasGRUFs", "hasRDFU", "hasRDPs", "hasXDFS", "hasRFES", "hasCDPs", "hasRDPSU", "hasCDPE", "hasXDFs", "hasRTFES", "hasRDFE", "hasGRDFAST", "hasGRUFSU", "hasXDPU", "hasRUFs", "hasXDPs", "hasRFE", "hasCDPES", "hasRUFAST", "hasCDFS", "hasRNFS", "hasRUFSU", "hasRDPS", "hasRdfU", "hasRTFS", "hasGRDFS", "hasRNFE", "hasRFSU", "hasRDPES", "hasCDFES", "hasRFS", "hasRFs", "hasGRDFs", "hasRDFSU", "hasRDPAST", "hasRDPU", "hasRFAST", "hasXDPS", "hasRTFs", "hasCDPS", "hasRDFES", "hasXDFU", "hasRUFS", "hasGRUFAST"], "hasRDF": ["hasUOW", "hasUDP", "hasMRDEF", "hasSRDP", " hasRRUF", "hasRMF", "hasNRMF", "yesROW", "hasSRDF", "hasRUF", "hasNRUF", "hasRRDP", "hasDDP", "hasMRDP", "hasRRDEF", "hasURMF", "HasRRDP", "hasUMF", "HasRDP", "hasRRdf", "hasROW", "hasUDF", "yesDMF", "hasNRFD", " hasRMF", "HasRRDF", "hasRdf", " hasRUF", "HasRDEF", "yesDOW", " hasRFD", "hasURDF", "hasSRdf", "hasRRUF", "yesDDF", "hasSRDEF", "hasURUF", "hasMRdf", "hasMRDF", " hasRRFD", "hasRRDF", "yesRDF", "hasURFD", "yesRMF", "yesRDP", "HasRRDEF", "HasRdf", " hasRRMF", " hasRRDF", "hasRFD", "hasDMF", "HasRDF", "hasRDEF", "HasRRdf", "hasDOW", "hasDDF", "hasRDP", "hasRRFD", "hasRRMF", "hasNRDF", "yesDDP"]}}
{"id1": "11477906", "id2": "755203", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["getDefaultParameters", "loadGlobalsettings", "loadGlobalParameters", "loaddefaultConfiguration", "loaddefaultParameters", "loadApplicationSettings", "getdefaultConfiguration", "getdefaultParameters", "getdefaultsettings", "loadDefaultConfiguration", "loadDefaultsettings", "loadApplicationParameters", "loaddefaultsettings", "loaddefaultSettings", "loadDefaultParameters", "getDefaultSettings", "loadApplicationsettings", "getdefaultSettings", "getDefaultsettings", "loadGlobalSettings", "loadGlobalConfiguration", "loadApplicationConfiguration", "getDefaultConfiguration"], "configFileName": ["configPlaceLocation", "configFILELocation", "configFileType", "configFilenameLocation", "configFullLocation", "fileFILEType", "fileFILETime", "configFILETime", "configFileUrl", "configFilesName", "fileFILELocation", "ConfigModuleUrl", "ConfigFileString", "fileFileType", "configFileLocation", "configModuleUrl", "configFilesType", "ConfigModuleLocation", "configModuleString", "fileFileName", "configModuleName", "fileFileTime", "configFullUrl", "configFilenameName", "ConfigFileLocation", "configFullName", "configPlaceName", "configFileTime", "fileFileLocation", "configPlaceString", "ConfigFileName", "configFilesTime", "configFilesLocation", "configPlaceUrl", "configFileString", "configModuleLocation", "configFullString", "ConfigModuleString", "configFilenameType", "ConfigModuleName", "configFILEType", "ConfigFileUrl", "fileFILEName", "configFILEName", "configFilenameTime"], "in": ["resource", "In", "pull", "pass", "pc", "plus", "again", "n", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "as", "log", "con", "this", "pin", "ins", "conn", "inn", "err", "it", "up", "init", "base", "url", "work", "config", "read", "f", "inside", "i", "nin", "a", "socket", "login", "ssl", "reader", "diff", "data", "r", "inc", "id", "source", "stream"], "out": ["timeout", "able", "again", "and", "string", "instance", "c", "o", "ex", "exp", "view", "d", "version", "bin", "Out", "copy", "log", "io", "outs", "this", "sync", "conn", "object", "user", "err", "it", "up", "default", "connection", "net", "s", "all", "prefix", "exec", "server", " back", "config", "f", "off", "set", " file", "password", "image", "lib", "socket", "writer", "to", "ext", "file", "output", "data", "ou", "write", "obj", "OUT", "point", "null", " output", "t", "inc", "error", "parent", "back", "client", "name", "one"]}}
{"id1": "21488868", "id2": "4593012", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFiletoString", "encodeFile2File", "encodeString2File", "encodeFiletoStream", "encodeFiletoFile", "encodeStringToString", "encodeFileToString", "encodeFileToStream", "encodeStringToFiles", "encodeStringToFile", "encodeFile2Files", "encodeString2String", "encodeFileFromFiles", "encodeFileFromString", "encodeStringToStream", "encodeFileFromStream", "encodeString2Stream", "encodeString2Files", "encodeFileToFiles", "encodeFile2String", "encodeFile2Stream", "encodeFiletoFiles", "encodeFileFromFile"], "infile": [" infp", "inputfilename", "infp", "inputFile", "outfiles", " infiles", "Infilename", "inputfp", "inputfiles", "outfilename", "Infile", "outfp", " infilename", "InFile", "inFile", "inputfile", "Infiles", "outFile", "infiles", "infilename"], "outfile": [" outname", "OutFile", "outfolder", "infp", "newFile", "Outname", "newname", "outname", " outFile", "newfolder", "outfilename", "outfp", " outfilename", " outfolder", "Outfile", "outputfp", "Outfolder", "newfile", "infolder", "outputfolder", "outFile", "outputfile", "outputfilename", " outfp", "infilename"], "in": ["In", "inas", "pass", "again", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "ic", "as", "con", "pin", "ins", "ac", "min", "conn", "inn", "into", "err", "isin", "init", "win", "s", "base", "rin", "gin", "thin", "inside", "i", "nin", "a", "image", "socket", "sin", "login", "reader", "data", "vin", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "In", "or", "exit", "again", "line", "cache", "o", "ex", "inner", "bin", "Out", "copy", "outer", "io", "outs", "co", "post", "sync", "on", "conn", "no", "err", "up", "net", "base", "exec", "work", "name", "session", "off", "home", "image", "lib", "socket", "to", "writer", "output", "error", "ou", "write", "obj", "OUT", "point", "job", "inc", "parent", "source", "client", "one", "file"], "buffer": ["seed", "cache", "uffer", "limit", "padding", "input", "layer", "wave", "feed", "buf", "slice", "queue", "length", "address", "count", "batch", "base", "server", "url", "size", "Buffer", "iter", "len", "value", "split", "bytes", "transfer", "result", "border", "bb", "reader", "data", "write", "type", "raw", "null", "b", "fb", "buff", "flush", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", "tell", " Read", "use", "ip", " skip", "send", "n", " write", "current", "reading", "fill", "limit", "select", "input", "copy", "READ", "lex", "io", "feed", "add", "slice", "sync", "length", " count", "count", "seek", "play", "Read", "ad", "exec", "find", "get", "load", "x", "wait", "size", "work", "f", "iter", "len", "i", "allow", "ind", "_", "start", "ride", "close", "connect", "check", "reader", " copy", "parse", "write", "next", "se", "raw", "inc", "id", "sleep", "end"], "success": ["rolled", "done", "pass", "status", "again", "respons", "initial", "method", "results", "failed", "comment", "winner", " Success", "continue", "response", "func", "fast", "right", "path", "open", "Success", "modified", "ceed", "primary", "first", "warning", "construct", "content", "ccess", "growth", "roll", "good", "valid", "successful", "flash", " successful", "default", "danger", "model", "fail", " succeed", "complete", " succ", "value", "rolling", "result", "better", "true", "error", "data", "follow", "xx", "null", "successfully", "message", "cess"]}}
{"id1": "8135072", "id2": "23370621", "code1": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"setImg": ["setImageg", "getImagegs", "setImvg", "getImgs", "setImgm", "setIMvg", "getImagevg", "setAmgs", "setImagevg", "getImageg", "setImagegs", "setImgs", "setIMgm", "getImvg", "setImagegm", "setIMg", "getImg", "setAmg", "setIMgs", "setAmvg", "getImgm", "setAmgm", "getImagegm"], "jFileChooser1": ["jFileChoosen1", "jFileChooseOne", "jFileChooserOne", "jFileChoouter01", "jFileChoickerOne", "jFileClose01", "jFileChoitcher1", "jFileChoose3", "jFileChooser01", "jFileChoitcherone", "jFileCloseL", "jFileChoosingOne", "jFileCloserOne", "jFileChoosen3", "jFileChoose2", "jFileChoosen2", "jFileChooser2", "jFileChoiser2", "jFileChooserL", "jFileChoosing2", "jFileChoosing3", "jFileChoiser3", "jFileChoose1", "jFileChoicker3", "jFileCloser1", "jFileChoitcher3", "jFileChoiser1", "jFileChoickerL", "jFileCloseOne", "jFileChoosingL", "jFileChoiserOne", "jFileChooseL", "jFileCloser01", "jFileChooserone", "jFileChoosenone", "jFileChoosing1", "jFileClose3", "jFileCloser2", "jFileChoitcher2", "jFileChooser3", "jFileChoouter3", "jFileCloser3", "jFileChoose01", "jFileCloserL", "jFileChoouter2", "jFileClose2", "jFileChoouter1", "jFileChoosen01", "jFileClose1", "jFileChoicker1", "jFileChooseone"], "separator": ["separner", "escapigator", "separated", "separators", " separar", "perated", "decator", "variator", "locating", "generate", "separigator", "separinator", "separating", "terminate", "seator", "variate", "locinator", "decigator", " separate", "separate", " separating", "perate", "separoder", " separner", "seinator", "locate", "variated", " separation", "terminator", " separated", " separators", "seate", "perar", "variation", " separinator", "generation", "seoder", "perner", "location", "escapate", "locator", " separigator", "peration", "perator", "generating", "separation", " separoder", "decate", "decators", "locoder", "escapator", "generator", "escapators", "terminner", "terminar", "separar"], "dirImg": ["dirSegs", "dirIMvg", "homeIMg", "dirImgb", "directoryImagesg", "dirSevg", "dirImog", "dirUrgs", "dirIMgs", "dirAmg", "homeIMm", "dirImimg", "dirAmog", "dirUrgd", "folderImvg", "dirImgd", "dirIMgd", "directoryImgs", "directoryImg", "folderImog", "dirSeg", "dirAmvg", "dirImagegs", "dirSeog", "homeImvg", "dirAnimm", "dirAmgs", "homeImgd", " dirImimg", "dirImgs", "directoryImagegs", "dirUrg", "homeIMgd", "directoryImagegb", "directoryImageg", "homeImg", "dirImagesg", "homeImm", "dirimgb", "dirUrimg", "dirAnimvg", "dirImvg", "dirimsg", "folderImgs", "dirIMsg", "dirIMg", "directoryImsg", "folderImg", "dirAnimgd", "dirImagegb", "dirImm", "dirImageg", "dirIMm", "homeIMvg", " dirImgs", "dirImsg", "directoryImgb", "dirIMgb", " dirImgd", "dirIMimg", "dirimgs", "dirAnimg", "dirimg"], "index": ["action", "section", "line", "position", "string", "condition", "Index", "path", "match", "key", "number", "slice", "num", "length", "active", "address", "loc", "weight", "default", "part", "pos", "x", "size", "field", "len", "value", "i", "ind", "axis", "page", "level", "diff", "type", "point", "inc", "id", "offset", "name", "end"], "imgName": ["imgType", "imagePart", " imgPart", "ngPart", "imageType", " imgPath", " imgname", "ngName", "imgname", "iconName", "ngPath", "imageName", "imgPart", "iconPath", " imgType", "imagename", "iconType", "imgPath", "ngname", "imagePath", "iconname"], "newPath": ["NewUrl", "Newpath", "newpath", " newpath", "newFile", "workingFile", "nextpath", "oldpath", "oldPath", " newName", "workingPath", "newName", "NewFile", "newUrl", "nextFile", " newUrl", "nextUrl", "NewName", "nextPath", "NewPath", "workingName", "oldFile", "newLocation", "NewLocation", "nextLocation", " newLocation", "workingpath", " newFile", "oldLocation"], "inputFile": [" inputFolder", "inDir", " inputDir", "inPath", " inputPage", "inputDirectory", " inputStream", "InputDirectory", "inputStream", "viewFile", "outputPage", "inputFiles", " inputPath", "viewPath", "InputFolder", "InputPath", "outputPath", " inputFiles", "inputFolder", " inputDirectory", "inStream", "InputFile", "inputPath", "InputFiles", "viewDirectory", "InputPage", "inputDir", "inFile", "inputPage", "outputFiles", "viewFolder", "InputStream", "InputDir"], "outputFile": ["targetFile", " outputfile", "targetFolder", "inputDirectory", "targetPath", "inputStream", "OutputFile", " outputFolder", "inputFiles", "writeFile", "outputPath", " outputFiles", "outputFolder", " outputDirectory", "outputStream", "OutputDirectory", "inputFolder", "OutputFiles", "targetFiles", "outputDirectory", "writeDir", "inputPath", " outputPath", " outputDir", "outputDir", "inputDir", "inputfile", "OutputPath", " outputStream", "writeStream", "outputfile", "outputFiles", "writefile"], "in": ["fa", "In", "plus", "again", "n", "ini", "IN", "cin", "o", "ex", "is", "din", "inner", "bin", "input", "as", "io", "pin", "ins", "conn", "inn", "into", "err", "up", "l", "isin", "init", "win", "part", "lin", "connection", "f", "inside", "i", "nin", "a", "h", "sin", "socket", "login", "reader", "diff", "r", "inc", "id", "source", "lock"], "out": ["plus", "line", "again", "cache", "IN", "o", "ex", "inner", "bin", "Out", "copy", "outer", "down", "io", "outs", "co", "sync", "ins", "conn", "err", "up", "part", "net", "exec", "other", "off", "i", "lib", "socket", "to", "writer", "plain", "output", "error", "OUT", "point", "inc", "client", "name", "file"], "c": ["dc", "ch", "pc", "cm", "k", "n", "m", "col", "o", "pointer", "d", "character", "abc", "ci", "ic", "xc", "sc", "ct", "cu", "ac", "ce", "C", "p", "cent", "cc", "cl", "l", "cr", "rc", "cp", "x", "bc", "f", "enc", "e", "code", "i", "arc", "uc", "v", "r", "b", "t", "cy", "nc", "ec", "esc", "lc", "dec"], "bckImg": ["bckPf", "bckIngl", "bckImgl", "bckImgs", "bccImgs", "bckimgl", "bckPg", "bccPgs", "bccPf", "bccPg", "bckPgs", "bccImg", "bckimg", "bckPgl", "bckIng", "bckImf", "bckIngs", "bckInf", "bccPgl", "bccImgl", "bccImf", "bckimf", "bckimgs"]}}
{"id1": "8000624", "id2": "7499186", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": ["copyFile", " copyTo", " transferFrom", " transferTo", "copyto", "CopyFrom", "Copyto", " copyFrom", " transferFile", " copyFile", " copyto", "copyTo", " transferto", "CopyFile", "copyFrom"], "dest": ["folder", "txt", "temp", "done", "class", "exit", "rest", "opt", "table", "dist", "bin", "destroy", "transform", " Dest", "path", "desc", "die", "object", "content", "sup", "comb", "w", "orig", "tmp", "delete", "flat", "filename", "Dest", "img", "output", "test", "data", "write", "them", "obj", "target", " destination", "source", "wb", "cont", "src", "name", "later", "file"], "in": ["fa", "In", "pull", "pass", "plus", "issue", "again", "n", "ini", "IN", "m", "cin", "inner", "din", "bin", "input", "as", "con", "wave", "pin", "ins", "ac", "conn", "inn", "kin", "up", "l", "connection", "init", "win", "s", "rin", "lin", "isin", "x", "gin", "thin", "f", "inside", "i", "nin", "image", "lib", "h", "sin", "login", "reader", "ax", "ln", "vin", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "temp", "or", "plus", "external", "not", "again", "outside", "n", "cache", "o", "ex", "call", "inner", "bin", "Out", "copy", "outer", "io", "outs", "this", "sync", "pin", "conn", "no", "user", "object", "our", "err", "up", "app", "part", "w", "net", "exec", "url", "x", "other", "off", "i", "nin", "image", "lib", "socket", "writer", "ext", "file", "output", "data", "ou", "OUT", "vert", "b", "target", "inc", "client", "name", "one"], "c": ["dc", "ch", "pc", "fc", "u", "cm", "n", "m", "col", "o", "ca", "pointer", "d", "comment", "abc", "ci", "ic", "xc", "sc", "char", "ct", "cf", "cu", "ac", "ce", "content", "C", "oc", "p", "cr", "cl", "cc", "l", "rc", "exc", "x", "config", "bc", "f", "enc", "e", "code", "i", "arc", "uc", "cb", "v", "r", "t", "cy", "ec", "esc", "buffer", "lc"]}}
{"id1": "17202158", "id2": "4468255", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"readZoneIDs": ["readLocationIDs", "readzoneIDS", "readZoneIDS", "readzoneID", "readZoneNames", "loadzoneNames", "readLocationNames", "readCodeIDS", "loadZoneID", "readLocationIDS", "readzoneNames", "readCodeNames", "loadZoneNames", "readzoneIDs", "readLocationID", "readCodeIDs", "loadZoneIDS", "readCodeID", "loadzoneIDs", "loadzoneID", "loadZoneIDs", "readZoneID", "loadzoneIDS"], "zoneFileName": ["ZoneFilename", "zoneFilesPath", "zonefilename", "zoneFilesUrl", "zoneFilesname", "zoneClassUrl", "zoneLineUrl", "zoneLinePath", "Zonefilename", "zoneClassName", " zoneFilePath", "zoneFilename", "zoneDirPath", "zoneDirUrl", "ZonefilePath", "ZoneFileName", "zoneFilesName", "zoneFileUrl", "zoneClassPath", "zoneClassname", "zoneFullUrl", " zoneDirPath", "zoneDirName", "zoneLineName", "zonefileName", " zoneFileUrl", "zoneFullPath", "ZoneFileUrl", "ZonefileName", "zoneFilePath", " zoneDirUrl", " zoneDirName", "zoneFullName", "ZoneFilePath", "zoneFullname", "ZonefileUrl", "zonefileUrl", "zonefilePath"], "zoneids": ["Zoneid", " zonefiles", "poids", " zonelines", "sizeids", "typeips", "zoneints", "sizeid", "typeid", "poIDs", "zoneips", "zonelines", "pofiles", "zipid", "zipids", "typeints", "Zoneids", "poid", "zonefiles", " zoneid", "zoneIDs", "sizeips", "zipIDs", "polines", "Zonefiles", "sizeints", "typeids", " zoneips", " zoneints", " zoneIDs", "zoneid", "ZoneIDs", "ziplines"], "url": ["resource", "class", "string", "channel", "http", "service", "URL", "path", "ur", "api", "feed", "io", "this", "Url", "client", "user", "address", "bel", "l", "connection", "base", "server", "location", "loader", "sl", "f", "hub", "page", "ssl", "reader", "data", "ball", "r", "b", "job", "uri", "stream", "source", "buffer", "re", "name", "file"], "lnr": ["slr", "lenw", "lenp", "linp", "lnp", "rlr", "linr", "lnn", "lnw", "nlp", "linn", "nlw", "rln", "linrb", "nlb", "linb", "lenr", "lenb", "linw", "rlrb", "nlr", "rlb", "sln", "lnrb", "slb", "slrb", "lnb"], "line": ["inline", "look", "entry", "row", "string", "c", "lines", "col", "LINE", "word", "str", "comment", "le", "Line", "response", "ge", "log", "key", "char", "number", "jo", "no", "letter", "header", "unit", "cl", "l", "rule", "part", "base", "lin", "cell", "sl", "link", "code", "nl", "el", "page", "ne", "data", "parse", "id", "message", "lf", "sel", "block", "column", "name", "file", "lc"]}}
{"id1": "5989666", "id2": "823074", "code1": "    private String postXml(String url, String soapAction, String xml) {\n        try {\n            URLConnection conn = new URL(url).openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection hConn = (HttpURLConnection) conn;\n                hConn.setRequestMethod(\"POST\");\n            }\n            conn.setConnectTimeout(this.connectionTimeout);\n            conn.setReadTimeout(this.connectionTimeout);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/soap+xml, text/*\");\n            if (soapAction != null) {\n                conn.setRequestProperty(\"SOAPAction\", soapAction);\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(xml);\n            out.close();\n            BufferedReader resp = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder buf = new StringBuilder();\n            String str;\n            while ((str = resp.readLine()) != null) {\n                buf.append(str);\n            }\n            return buf.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"postXml": ["postXML", "postXtml", "POSTWorktml", "POSTWorkxml", "postWorkml", "postWorkML", "postWorktml", "postPhml", "postPhML", "POSTXml", "postXPml", "postXPtml", "postXPML", "postXxml", "POSTWorkML", "POSTXtml", "postWorkxml", "POSTWorkml", "postPhtml", "POSTXML", "POSTXxml", "postXPxml", "postPhxml"], "url": ["resource", "pull", "string", "blog", "host", "href", "http", "www", "URL", "path", "ll", "feed", "https", "Url", "email", "download", "address", "loc", "l", "connection", "base", "ls", "server", "location", "config", "sl", "f", "link", "image", "remote", "html", "ssl", "page", "jar", "web", "uri", "source", "file"], "soapAction": ["soipAction", "somaOperation", "soAPAction", "soopAction", "soipName", "coapOperation", "coapResource", "coAPaction", "soapName", "soapsType", "soapsRequest", "soAPaction", "soapRequest", "soopResource", "coAPOperation", "soipType", "coapType", "coAPType", "coAPRequest", "somaResource", "coapaction", "soipRequest", "coAPName", "soAPType", "somaAction", "soapsaction", "somaaction", "soAPRequest", "soAPResource", "soAPName", "coapName", "soapaction", "soapOperation", "coAPAction", "soAPOperation", "coAPResource", "soipaction", "soopOperation", "soopaction", "coapRequest", "soapsAction", "coapAction", "soapsName", "soapType", "soapResource"], "xml": ["resource", "txt", "application", "ml", "wt", "description", "zip", "string", "context", "request", "www", "input", "response", "path", "json", "email", "doc", "content", "address", "xxx", "document", "element", "model", "event", "config", "php", "html", "page", "output", "data", "apache", "message", "stream", "text", "file"], "conn": ["dc", "ch", "pc", "cat", "cm", "n", "c", "Connection", "act", "pg", "ca", "col", "oa", "Conn", "ann", "apt", "oss", "conv", "ci", "dn", "ctx", "con", "open", "co", "rt", "sync", "ct", "cf", "auth", "client", "ac", "fn", "loc", "ad", "err", "cc", "adj", "connection", "init", "mc", "cn", "cp", "cmd", "exec", "server", "reg", "coll", "contract", "cs", "enc", "cli", "h", "uc", "cb", "close", "socket", "ssl", "nt", "att", "obj", "comm", "en", "conf", "nc", "ec", "lock", "connect", "org", "db", "lc"], "hConn": ["hDb", "hanConnect", "hConnect", "Hconn", "HDb", "hanConn", " hDb", "HConnect", "cconn", "hconn", "HConnection", "cConnection", "hanconn", " hConnect", "hConnection", "HConn", " hConnection", "cConnect", " hconn", "cConn", "hanDb"], "out": ["temp", "ch", "again", "serv", "full", "n", "o", "exp", "inner", "bin", "Out", "response", "conv", "outer", "log", "con", "io", "outs", "co", "sync", "in", "user", "fn", "err", "connection", "net", "w", "ng", "cmd", "off", "her", "socket", "writer", "plain", "ext", "ssl", "output", "gen", "OUT", "inc", "stream", "client", "file", "extra"], "resp": ["Response", "rss", "rep", "cmp", "serv", "respond", "rec", "rh", "reply", "exp", "response", "report", "prev", "api", "onse", "in", "rel", "err", "pos", "rex", "comp", "Resp", "res", "repl", "result", "reader", "data", "rr", "req", "r", "obj", "rev", "job", "stream", "client", "body", "re", "fr", "ref"], "buf": ["bh", "bu", "nb", "aux", " buffer", "ob", "bub", "cv", "bin", "raf", "conv", "ctx", "abs", "pad", "cf", "fam", "bp", "err", "br", "bag", "ff", "rc", "tmp", "builder", "cur", "bc", "sb", "Buffer", "pkg", "af", "uf", "cap", "bo", "uc", "cb", "fp", "bb", "img", "Buff", "b", "fb", "buff", "ba", "bf", "lf", "buffer", "wb", "rb", "db"], "str": ["stri", "line", "kr", "string", "c", "pr", "exp", "spec", "ner", "char", "key", "sr", "sol", "STR", "tr", "er", "err", "br", "cr", "cl", "l", "coll", "arr", "sp", "dr", "sl", "f", "iter", "enc", "e", "i", "wr", "st", "data", "obj", "rr", "r", "rev", "Str", "text", "name", "fr", "lc"]}}
{"id1": "3024992", "id2": "20924119", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter_nulls", "testCopy_readerToWriter_writers", "testCopy_readerToWriter_stds", "testCopy_readerToWriter_std_", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_Nulls", "testCopy_readerToWriter_stdIn", "testCopy_readerToWriter2Nullin", "testCopy_readerToWriter2null_", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter_stdin", "testCopy_readerToWriter2nulls", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter2nullIn", "testCopy_readerToWriter_writerin", "testCopy_readerToWriter_writerIn", "testCopy_readerToWriter_Nullin", "testCopy_readerToWriter2Nulls", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter_null_", "testCopy_readerToWriter_writer_"], "baout": ["BAOUT", "baOut", "baash", "Baouts", "baouts", "Baout", "BAash", " baouts", "BaOUT", "baOUT", " bain", "BAOut", "aeouter", "Baash", " baOut", "bonout", "BAout", "BAio", "BaOut", "bain", "aeout", "BAin", "aeOut", "Baouter", "aeOUT", "bonash", "BAouts", "bonio", "baio", "bonin", "Bain", "Baio", "BAouter", "baouter"], "out": ["class", "line", "Out", "copy", "outer", "io", "Writer", "outs", "in", "er", "err", "s", "array", "test", "output", "reader", "write", "OUT", "r", "null", "buffer", "able", "file", "Output", "flow"], "writer": ["temp", "riter", "entry", "class", "writ", "writers", "player", "pointer", "wer", "ee", "copy", "outer", "Writer", "io", "wa", "driver", "in", "letter", "er", "unit", "RW", "w", "work", "x", "rw", "her", "worker", "reader", "output", "data", "write", "writing", "null", "r", "buffer", "source", "builder", "file"]}}
{"id1": "1798720", "id2": "9846843", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"save": ["stage", "transform", "copy", "report", "move", "open", "process", "archive", "build", "store", "Save", "release", "saving", "setup", "install", "upload", "clone", "load", "dump", "transfer", "apply", "change", "data", "make", "pack", "update", "create"], "packageName": [" packagePart", " packageNames", "moduleName", "PackageNames", "directoryPart", "directoryDir", " packageInfo", "directoryname", " packagename", "PackageInfo", "directoryPath", "pluginName", "directoryInfo", "packagename", "PackagePath", "sourcename", " packagePath", "modulePath", "sourcePath", "packagePath", "PackageName", "pluginPath", "packageInfo", "pluginDir", "sourceDir", "packageNames", "moduleInfo", "pluginPart", "sourceName", "directoryName", "directoryNames", "moduleDir", "PackageDir", "packagePart"], "fileContents": ["FileParts", "getContents", " fileContent", "ileSources", "FileSources", " fileParts", "imageContents", " fileSources", "fileSources", "FileNames", "getContent", "ileTextures", "FileContent", "imageHours", "getParts", "fileTextures", "ileNames", "fileParts", "imageParts", " fileTextures", "fileContent", "ileContents", "getNames", " fileHours", "fileHours", "FileTextures", "imageNames", "FileContents", "FileHours"], "fileNames": ["pageTypes", "fName", "fullName", "fileName", "viewTypes", "logNames", "fullContents", "pagenames", " fileName", "fTypes", "FileNames", "fNames", "fullTypes", "logContents", "logTypes", "playName", " fileNumbers", "viewNames", "pageNames", "fileTypes", "playNames", "fNumbers", "fileNumbers", "FileName", "playContents", "FileTypes", "logName", " fileTypes", "FileNumbers", "FileContents", " filenames", "fullNames", "filenames", "viewnames"], "dirBase": ["folderDir", "moduleKit", "moduleBase", "packageRoot", "DirKit", " dirPath", "dirKit", "DirPath", "dirRoot", "Dirbase", "directoryDir", "moduleDir", "directoryBased", " dirbase", "dirDir", "directoryBase", "modulebase", "directoryKit", "folderBase", "packagebase", "packageBase", "folderBased", " dirRoot", "packagePath", "dirBased", "folderbase", "directorybase", "DirDir", "DirBase", "dirPath", "DirRoot", "moduleBased", "dirbase"], "packageDir": ["directoryFile", "folderDir", "moduleBase", "moduleLib", "parentFile", "packageFile", " packageFolder", "packageFolder", " packageDirectory", "packageLib", "PackageFile", "directoryDir", "directoryPath", "moduleDir", "PackagePath", "directoryUrl", " packageUrl", "folderBase", "parentDir", "PackageDirectory", "packageDirectory", " packagePath", "modulePath", "packageBase", "packagePath", "packageUrl", " packageLib", "parentUrl", "folderPath", "folderLib", " packageFile", "parentFolder", "directoryFolder", "directoryDirectory", " packageBase", "PackageDir"], "created": ["raised", "icated", "founded", "creation", "Created", "added", "worked", "failed", "edited", "called", "path", "produced", "activated", "paid", "authorized", "ed", "creator", "were", " Created", "successful", "aaaa", "updated", "established", "left", "formed", "confirmed", "existent", "released", "used", "result", "made", "true", "found", "null", "needed", "controlled", "required", "owned", "generated", " existed", "create", "loaded"], "currentPath": [" currentPage", "newpath", " currentLocation", "CurrentDirectory", "CurrentPath", "currentDirectory", "currentPage", "CurrentLocation", "currentlyPage", "currentlyDirectory", " currentDirectory", "CurrentRoot", "currentpath", "currentRoot", " currentRoot", "currentlypath", "currentLocation", "newPath", "currentlyPath", "newLocation", "newRoot", "CurrentPage", "Currentpath", " currentpath"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "ini", "ii", "k", "n", "pi", "c", "y", "current", "d", "inner", "ci", "di", "io", "z", "key", "slice", "ji", "ui", "ri", "me", "bi", "ie", "it", "p", "part", "phi", "init", "s", "j", "I", "fi", "x", "eni", "index", "f", "e", "isi", "oi", "li", "ori", "start", "h", "gi", "v", "ti", "mi", "ai", "yi", "b", "xi", "zi", "id", "info", "uri", "ix", "mu", "name"], "file": ["File", "folder", "resource", "entry", "fe", "or", "il", "full", "http", "le", "path", "log", "io", "feed", "files", "place", "child", "dir", "letter", "unit", "book", "play", "up", "l", "rule", "base", "s", "pe", "out", "work", "f", "per", "ul", "filename", "fp", "data", "b", "source", "uri", "ile", "name"], "fos": ["ufob", "flosh", "ufo", "flos", "cfo", " fops", "fo", "voes", "fosh", "Fou", "fios", "ufos", "fops", "Fops", " fios", " fo", "cfob", "fou", "foes", "flou", "vos", "ofou", "flis", "Fis", "ofos", " fob", " fis", "Fos", "ofops", " fosh", "fis", "Fios", "vops", "Fosh", "vios", "Foes", "fob", " foes", "cfoes", "ofosh", "cfos", "flops", "ufoes"], "fileSrc": ["fileAsrc", " fileDrc", "FileSrec", "FileSource", " fileDRC", "fileDRC", " fileSrs", "FileSrc", "FileDrec", "fileNrs", "fileSrec", "fileNrc", "fileDource", "fileAssrc", "FileDRC", "fileDsrc", "fileDrc", " fileDrs", "fileAsRC", " fileSsrc", "fileAsource", "fileSource", "FileDrc", "FileDource", "fileAsrec", " fileSRC", "FileSRC", "fileDrec", "fileSRC", "fileNsrc", "fileDrs", "fileSsrc", " fileDsrc", "fileSrs", "fileAsrs", "fileNRC"], "fileDst": ["fileDaysrc", "fileFsc", "fileDST", "FileSrc", "fileDaysc", "fileFst", "FileDsc", "FileFsc", "fileSST", "fileDayst", "fileNrc", "fileFrc", "FileFst", "FileSsrc", "FileDsrc", "FileFST", "FileFrc", "FileSst", "fileSst", "fileDayrc", "fileDsrc", "fileNsc", "fileDrc", "FileDrc", "fileFST", "fileEnrc", "fileSsc", "FileSsc", "fileNsrc", "fileEnST", "fileSsrc", "FileDst", "fileDsc", "fileEnst", "FileDST", "fileEnsc", "fileNst"], "reader": ["or", "row", "entry", "ry", "reading", "oder", "inner", "ler", "right", "layer", "report", "io", "ner", "driver", "ri", "keeper", "handler", "er", "book", "audio", "ro", "rc", "server", "loader", "read", "Reader", "rer", "iter", "e", "per", "director", "worker", "editor", "author", "data", "rr", "r", "parser", "rar", "buffer", "stream", "rx", "re", "builder"], "writer": ["entry", "riter", "writ", "words", "war", "ger", "writers", "player", "later", "o", "word", "inner", "ler", "with", "walker", "outer", "Writer", "wa", "key", "sheet", "driver", "maker", "er", "book", "handler", "wire", "w", "document", "connection", "out", "element", "server", "width", "work", "loader", "ws", "office", "per", "e", "rw", "wrapper", "value", "worker", "editor", "widget", "wr", "socket", "output", "writing", "write", "data", "author", "written", "r", "parser", "message", "buffer", "master", "builder"], "line": ["item", "look", "inline", "entry", "row", "pass", "string", "lines", "word", "LINE", "str", "comment", "character", "le", "Line", "response", "ge", "log", "feed", "key", "jo", "char", "stroke", "sync", "object", "letter", "header", "unit", "cr", "l", "part", "rule", "connection", "lin", "cell", "model", "url", "definition", "link", "code", "cle", "page", "error", "data", "write", "type", "style", "id", "message", "lf", "source", "buffer", "text", "block", "column", "name", "job", "lc", "end"]}}
{"id1": "16572931", "id2": "2198730", "code1": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "code2": "    public void importCSV(InputStream csvfile) throws Exception {\n        try {\n            String[] qmarks = new String[columns.length];\n            for (int i = 0; i < qmarks.length; i++) {\n                qmarks[i] = \"?\";\n            }\n            if (cleartable) {\n                String delsql = \"delete from \" + table;\n                Statement delstm = conn.createStatement();\n                delstm.executeUpdate(delsql);\n            }\n            String sql = \"insert into \" + table + \" (\" + StringUtils.join(columns, \", \") + \") values (\" + StringUtils.join(qmarks, \", \") + \")\";\n            log.debug(\"SQL: \" + sql);\n            PreparedStatement stm = conn.prepareStatement(sql);\n            int datatypes[] = new int[columns.length];\n            for (int i = 0; i < columns.length; i++) {\n                Table tbl = project.getTableByName(table);\n                if (tbl == null) throw new OntopiaRuntimeException(\"Unknown table: \" + table);\n                Column col = tbl.getColumnByName(columns[i]);\n                if (col == null) throw new OntopiaRuntimeException(\"Unknown table column: \" + columns[i]);\n                if (col.getType() == null) throw new OntopiaRuntimeException(\"Column type is null: \" + col.getType());\n                DataType datatype = project.getDataTypeByName(col.getType(), \"generic\");\n                if (datatype == null) throw new OntopiaRuntimeException(\"Unknown column type: \" + col.getType());\n                String dtype = datatype.getType();\n                if (\"varchar\".equals(dtype)) datatypes[i] = Types.VARCHAR; else if (\"integer\".equals(dtype)) datatypes[i] = Types.INTEGER; else throw new OntopiaRuntimeException(\"Unknown datatype: \" + dtype);\n            }\n            LineNumberReader reader = new LineNumberReader(new InputStreamReader(csvfile));\n            for (int i = 0; i < ignorelines; i++) {\n                String line = reader.readLine();\n                if (line == null) break;\n            }\n            log.debug(\"[\" + StringUtils.join(columns, \", \") + \"]\");\n            int lineno = 0;\n            while (true) {\n                lineno++;\n                String line = reader.readLine();\n                if (line == null) break;\n                try {\n                    String[] cols = StringUtils.split(line, separator);\n                    if (cols.length > columns.length && !ignorecolumns) log.debug(\"Ignoring columns: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    log.debug(\"CVALUES: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    String dmesg = \"(\";\n                    for (int i = 0; i < columns.length; i++) {\n                        String col = cols[i];\n                        if (stripquotes) {\n                            int len = col.length();\n                            if (len > 1 && ((col.charAt(0) == '\"' && col.charAt(len - 1) == '\"') || (col.charAt(0) == '\\'' && col.charAt(len - 1) == '\\''))) col = col.substring(1, len - 1);\n                        }\n                        if (col != null && col.equals(\"\")) col = null;\n                        dmesg = dmesg + col;\n                        if (i < columns.length - 1) dmesg = dmesg + \", \";\n                        stm.setObject(i + 1, col, datatypes[i]);\n                    }\n                    dmesg = dmesg + \")\";\n                    log.debug(dmesg);\n                    stm.execute();\n                } catch (Exception e) {\n                    conn.rollback();\n                    throw new OntopiaRuntimeException(\"Cannot read line \" + lineno + \": '\" + line + \"'\", e);\n                }\n            }\n            conn.commit();\n        } finally {\n            if (conn != null) conn.close();\n        }\n    }\n", "label": 0, "substitutes": {"unJar": ["copyjar", "addTar", "putTar", "putServer", "addjar", "updateServer", "addServer", "copyJava", "putjar", "copyServer", "putJava", "copyTar", "updatejar", "addJava", "updateTar", "updateJava"], "jarPath": ["erbName", "JarDir", "jarFile", "javaName", "browserName", "erbPo", "relEntry", "jarUrl", "garpath", "javaEntry", " jarpath", "erbPath", "javaDir", "garPath", " jarPo", " jarFile", "browserPath", "browserEntry", "JarEntry", "browserpath", "relFile", " jarName", "JarName", " jarDir", "javaUrl", " jarUrl", "jarpath", "jarDir", " jarLog", "jarName", "JarFile", "javaFile", "garEntry", "jarPo", "erbEntry", "JarPath", "javapath", "javaLog", "JarUrl", "javaPo", "garLog", "javaPath", "jarLog", "relDir", "Jarpath"], "jarEntry": ["zipDir", "irName", "zipUrl", "cookDir", "aliasEnt", "irEntry", "javaentry", "zipEntry", "javaName", "jarentry", "JarInfo", "jarUrl", "javaEntry", "javaEnt", "dropentry", "jarJar", "xmlLog", "javaDir", "irJar", "dropEntry", "cookEntry", " jarentry", "aliasEntry", "irentry", "dropInfo", "cookEnt", "xmlPath", " jarInfo", "JarEntry", " jarName", " jarDir", "javaUrl", "dropPath", " jarJar", " jarUrl", "jarDir", "xmlInfo", " jarLog", "jarName", "cookPath", "Jarentry", "javaJar", "jarInfo", "javaInfo", "JarPath", "aliasName", "javaLog", "xmlEntry", "aliasInfo", "zipName", "jarEnt", " jarEnt", "jarLog", "javaPath"], "path": ["resource", "route", "right", "log", "wd", "mode", "dir", "address", "p", "out", "prefix", "url", "location", "image", "next", "mount", "po", "parent", "uri", "text", "file", "entry", "cat", "clean", "request", "str", "ion", "patch", "this", "dest", "loc", "ph", "model", "code", "data", "cel", "end", "folder", "root", "not", "project", "th", "host", "step", "sync", "skip", "zone", "content", "archive", "default", "part", "work", "left", "ath", "home", "type", "PATH", "id", "pattern", "lock", "binary", "src", "name", "temp", "pass", "zip", "string", "Path", "context", "inner", "key", "conn", "it", "base", "config", "test", "directory", "prop", "source", "core"], "relPath": [" relUrl", "Relpath", "RelType", "relativepath", " relEntry", "relEntry", "relpath", "revPath", "relName", "revpath", "RelPath", "revType", "RelUrl", " relpath", "relativePath", "revEntry", "relUrl", " relType", "relativeName", "RelEntry", "RelName", " relName", "relativeUrl", "relType"], "jar": ["folder", "entry", "war", "gap", "zip", "py", "xml", "le", "ler", "java", "open", "z", "jo", "tar", "zone", "cook", "keeper", "dir", "archive", "er", "browser", "bag", "base", "Jar", "j", "drop", "ar", "url", "cur", "dr", "gar", "sl", " Jar", "bar", "tab", "pkg", "her", "ja", "lib", "gi", "ball", "module", "pack", "b", "job", "plugin", "car", "binary", "rar", "file", "fire"], "ze": ["entry", "zed", "ipe", "je", "zes", "za", "zip", "zen", "oe", "zin", "ine", "te", "pse", "le", "ge", "be", "sle", "z", "ke", "ce", "ie", "pe", "zee", "kee", "zy", "zie", "sl", " je", "e", "ele", "aze", "ja", "ZE", "zer", "se", "zi", "de", "zzy"], "bin": ["resource", "brain", "bot", "zip", "cin", "proxy", "inner", "abi", "log", "pin", "bit", "in", "abin", "boot", "bi", "cookie", "kin", "bian", "bon", "base", "win", "isin", "init", "ban", "bas", "len", "jin", "lib", "sin", "gi", "bis", "bb", "gen", "login", "data", "plugin", "b", "pack", "spin", "web", "bed", "binary", "lock", "file"]}}
{"id1": "16232202", "id2": "19467540", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "code2": "    @Override\n    public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) {\n        Connection conexion = null;\n        PreparedStatement select = null;\n        PreparedStatement update = null;\n        ResultSet rs = null;\n        boolean exito = false;\n        try {\n            conexion = pool.getConnection();\n            conexion.setAutoCommit(false);\n            select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\");\n            update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\");\n            String codigoProd;\n            int filasAfectadas = 0;\n            Iterator<String> iterador = carro.keySet().iterator();\n            while (iterador.hasNext()) {\n                codigoProd = iterador.next();\n                select.setString(1, codigoProd);\n                rs = select.executeQuery();\n                if (rs.next() == false) {\n                    Tools.anadirMensaje(request, \"No existe el producto con codigo: \" + codigoProd + \"(producto eliminado de la cesta)\");\n                    iterador.remove();\n                    conexion.rollback();\n                } else {\n                    Producto prod = new Producto(rs.getString(\"Codigo\"), rs.getString(\"Nombre\"), rs.getDouble(\"Precio\"), rs.getInt(\"Stock\"), rs.getString(\"Descripcion\"), rs.getString(\"Detalles\"));\n                    select.clearParameters();\n                    if (carro.get(codigoProd) > prod.getStock()) {\n                        Tools.anadirMensaje(request, \"No hay unidades suficientes de: \" + prod.getNombre() + \"(producto eliminado de la cesta)\");\n                        iterador.remove();\n                        conexion.rollback();\n                    } else {\n                        update.setInt(1, prod.getStock() - carro.get(codigoProd));\n                        update.setString(2, codigoProd);\n                        filasAfectadas = update.executeUpdate();\n                        if (filasAfectadas != 1) {\n                            Tools.anadirMensaje(request, \"Ocurrio un error en el catalogo\");\n                            conexion.rollback();\n                        }\n                        update.clearParameters();\n                        listado.put(prod, carro.get(codigoProd));\n                    }\n                }\n            }\n            conexion.commit();\n            exito = true;\n        } catch (SQLException ex) {\n            logger.log(Level.SEVERE, \"Error actualizando unidades de productos en compra\", ex);\n            try {\n                conexion.rollback();\n            } catch (SQLException ex1) {\n                logger.log(Level.SEVERE, \"Error haciendo rolback de la transacci\u00f3n que ha dado error en la actualizaci\u00f3n de unidades por compra\", ex1);\n            }\n        } finally {\n            cerrarConexionYStatement(conexion, select, update);\n            cerrarResultSet(rs);\n        }\n        return exito;\n    }\n", "label": 0, "substitutes": {"doPost": [" doSend", "didSend", "doingSend", "doPOST", "didPut", " doPOST", " doPut", "didPOST", "doSend", "doPut", "doingPOST", "didPost", "doingPost", "doingPut"], "request": ["resource", "application", "row", "route", "subject", "use", "external", "project", "join", "instance", "current", "initial", "context", "register", "method", "view", "Request", "xml", "you", "select", "condition", "state", "input", "self", "report", "list", "queue", "post", "enter", "user", "child", "object", "er", "store", "order", "hello", "rate", "event", "upload", "server", "query", "url", "load", "get", "complete", "session", "e", "q", "image", "remote", "result", "page", "next", "reader", "save", "data", "type", "submit", "parse", "req", "QUEST", "press", "error", "message", "web", "info", "parent", "client", "re", "create", "rf"], "response": ["Response", "resource", "application", "status", "we", "subject", "exit", "serv", "respond", "site", "environment", "reply", "http", "view", "forward", "service", "report", "api", "feed", "onse", "wa", "tree", "object", "resp", "document", "ception", "model", "server", "shell", "query", " Response", "complete", "index", "pool", "session", "su", "e", "image", "writer", "res", "result", "page", "next", "output", "ae", "error", "esi", "en", "de", "message", "parent", "web", "uri", "body", "re", "fire"], "cu": ["VC", "eu", "uu", "usa", "uci", "u", "c", "cul", "ru", "ca", "cin", "Cu", "asu", "cus", "agu", "cca", "ci", "xc", "U", "ue", "cci", "co", "ui", "cf", "aca", "ce", "ac", "cum", "ucc", "CI", "loc", "gu", "cc", "mc", "vc", "rc", "UC", "coll", "cur", "chu", "du", "cli", "su", "CU", "ul", "ku", "uc", "hu", "ou", "tu", "cy", "nu", "uni", "CA", "lu", "tc", "lc"], "ud": ["eu", "df", "us", "uu", "usa", "pd", "u", "ug", "od", "stri", "ub", "ru", "UD", "asu", "um", "cus", "uds", "utils", "uid", "da", "ci", "wik", "uda", "au", "ur", "ue", "util", "ui", "uv", "auth", "user", "ada", "bug", "ad", "gu", "dd", "gb", "usc", "rc", "storage", "upload", "chu", "uli", "du", "usr", "ut", "cli", "su", "li", "uf", "ku", "pub", "uc", "udi", "ou", "tu", "vd", "uri", "ck", "lu", "db"], "returnTo": ["replyto", "outputFrom", "accessFrom", "replyTo", "exitFrom", "accessTo", "returnto", "backto", "exitTo", "returnFrom", "accessTO", "Returnto", "ReturnTo", "backTo", "backTO", "replyTO", "accessto", "exitto", "ReturnFrom", "returnTO", "outputto", "replyFrom", "outputTO", "backFrom", "outputTo", "ReturnTO", "exitTO"], "password": ["token", "username", "sword", "mac", "string", "pg", "word", "secret", "sha", "sum", "Password", "wallet", "PASS", "params", "patch", "key", "auth", "pad", "email", "wd", "user", "address", "ass", "pa", "phrase", "confirmed", "code", "login", "diff", "data", "null", "account", "message", "crypt", "mask", "name", "encrypted", "padding"], "md": ["dc", "df", "mb", "mg", "mp", "ms", "od", "mand", "rm", "mac", "m", "pg", "sm", " MD", "d", "sha", "MD", "bd", "meta", "wd", "hd", "dd", "mc", "cd", "cmd", "mn", "ma", "mag", "f", "am", "dm", " Md", "amd", "diff", "dig", "managed", "rpm", "mm", "vd", "mad", "mt", "db", "mo"], "hash": ["row", "hed", "sh", "mac", "cache", "Hash", "rh", "secret", "total", "sha", "sum", "hex", "key", "number", "char", "auth", "user", "no", "kh", "ass", "base", "tag", "url", "ash", "array", "confirmed", "code", "her", "h", "dot", "diff", "dig", "raw", "block", "version", "db", "ref"], "pass": [" auth", "row", "ask", " passed", "act", "string", "mac", "push", " Pass", "secret", "sum", "PASS", " login", "key", " def", "auth", " mac", "mess", "wd", "user", " secret", "conn", "def", "ass", "pos", "fail", "pa", "phrase", " mess", "sl", "strip", "login", "gen", "diff", "r", "az", "id", "sign", "Pass", "conf", "text", "db", "ss", "ref"], "vis": ["dc", "travel", "status", "class", "keep", "acc", "cross", "ip", "nic", "act", "VIS", "c", "host", "qa", "virt", "access", "ex", "exp", "secret", "view", "see", "state", "visible", "na", "shape", "wa", "skip", "design", "lit", "mit", "gu", "lab", "nat", "rib", "spot", "coll", "miss", "nav", "circ", "fac", "su", "Vis", "vest", "ravis", "stat", "tri", "mis", "att", "type", "vid", "style", "vert", "press", "feat", "id", "sign", "name", "san", "ref"]}}
{"id1": "18433984", "id2": "812803", "code1": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"doUpload": ["runSave", " doSave", "doSave", " doupload", "DoUpload", "runUpload", "runDownload", "DoDownload", "Doupload", "doDownload", "DoSave", " doDownload", "runupload", "doupload"], "request": ["resource", "application", "subject", "use", "current", "view", "http", "state", "match", "url", "q", "image", "transfer", "parent", " Request", "version", "file", "join", "report", "user", "header", "command", "connection", "model", "quest", "page", "data", "require", "req", "message", "stream", "re", "art", "instance", "xml", "Request", "operation", "queue", "content", "er", "frame", "document", "hello", "upload", "query", "get", "complete", "worker", "type", "submit", "raw", "QUEST", "r", "client", "temp", "requ", "accept", "string", "initial", "context", "method", "condition", "input", "path", "param", "json", "object", "child", "event", "server", "config", "session", "head", "result", "ware", "info", "buffer", "create"], "response": ["Response", "resource", "application", "status", "reply", "xml", "view", "report", "onse", "json", "content", "resp", "connection", "document", "model", "server", " Response", "Resp", "image", "result", "page", "output", "message", "stream", "client", "re"], "reqSession": ["requConn", " reqCh", "refSession", "clientSocket", "reqSocket", " reqession", " reqSocket", "qSession", "requClient", " reqSecret", "qConn", "reqConn", "reqession", "tempCh", " reqLog", "reqCh", "clientsession", "clientCh", "qClient", "requsession", "reqsession", "tempSession", "refSecret", "refession", "rbClient", " reqsession", "refLog", "reqSecret", "rbSession", "reqClient", "qsession", "rbession", "rbsession", "clientSession", "reqLog", "tempSocket", "tempsession", "requSession", "rbSecret", "rbConn", "rbLog"], "uploadFiles": ["Uploadfiles", "uploadResources", "UploadFiles", " uploadfiles", "UploadResources", "transferFile", "uploadFile", " uploadFile", "transferfiles", "transferFiles", "transferResources", "UploadFile", " uploadResources", "uploadfiles"], "tempDirName": ["tempVerName", "cacheDIRPart", "tempDirKey", "tempFolderKey", "tempFoldername", " tempDirname", "tempFileKey", "tempAreaName", "cacheDIRname", " tempFileInfo", "tempDirInfo", "tempDirectoryInfo", " tempFolderCode", "tempAreaSize", " tempFilename", "tempDirectoryname", "cacheDirPart", "cacheDirName", "TempDirectoryKey", "tempFileName", "tempFolderName", "tempAreaname", "tempDIRPart", "tempDirectoryPath", "tempDirDesc", "tempFilename", "tempDirectoryName", "tempDirPart", "tempFolderCode", "tempDirCode", " tempDirCode", " tempDirInfo", "cacheDirname", "TempDirectoryName", "TempDirectoryCode", "tempFileCode", "tempDirectoryKey", "tempFolderDesc", "tempFilePath", "tempAreaInfo", "TempDirCode", "tempDirPath", " tempDirDesc", "TempDirName", "cacheDIRName", "tempVerCode", " tempFileName", "tempDirectoryDesc", "TempDirPath", "tempDirectoryPart", "tempVername", "tempDirSize", " tempFileSize", "tempDirectorySize", "tempDirHome", " tempFolderName", " tempFoldername", "tempFileInfo", "tempDIRName", "tempFileSize", "tempVerDesc", "TempDirectoryPath", " tempDirSize", " tempFolderDesc", "cacheDirHome", "tempDirectoryCode", "tempDIRHome", "tempDirname", "tempFolderPart", "TempDirKey", "tempDirectoryHome", "tempFolderHome", "tempDIRname", "cacheDIRHome", "tempFolderPath"], "tempUploadDir": ["tempUploadDb", " tempDownloadArea", "tempCapturedir", "tempUploadPath", "tempImageDir", "temuploadDir", "tempDownloadArea", "tempUploadJar", "tempInputPath", " tempDownloadDb", "tempuploadInfo", " tempDownloaddir", "testBuildD", "TempDownloadDb", "tempTempdir", "tempBuildJar", "testBuilddir", "temUploadInfo", "tempDownloadFolder", "tempRootDb", " tempDownloadFile", "tempDownloadJar", "tempUploaddir", "tempDownloadD", "testUploadFolder", "tempWorkDir", "tempRootDirectory", "testBuildJar", "temUploadDir", "tempUploadFolder", "testAttachUrl", "tempTempFolder", "tempDownJar", "tempDownloadDb", " tempUploadFile", "tempCaptureD", "tempBuilddir", "tempWorkFile", "tempInputFolder", "tempImageDirectory", "tempUploadInfo", "tempStreamArea", "TempUploadDb", "tempDownloadFile", "tempUploadArea", "testUploadJar", "tempStreamDirectory", "tempInputDir", "tempStreamDir", "tempRootFolder", "tempBuildDir", "tempuploadFolder", "tempFileDirectory", "tempImageFolder", "testAttachFolder", "testUploadDir", "tempInputInfo", " tempStreamJar", "tempAttachDir", "tempDownloaddir", "tempDownloadUrl", "TempDownloadDirectory", " tempStreamDir", "tempDownloadManager", "tempStreamDb", "tempAttachdir", "tempDownDir", "tempBuildD", "temUploadFolder", "tempDownloadInfo", "temuploadFolder", "TempDownloadDir", "tempDownDirectory", " tempUploadJar", "tempuploadPath", "tempImagedir", "tempAttachFolder", "tempAttachUrl", "testBuildDir", " tempUploaddir", "tempStreamFolder", "tempUploadUrl", "tempTempDirectory", "TempUploadDirectory", "tempCaptureDir", "tempFileFile", " tempUploadFolder", "tempCaptureJar", " tempDownloadDir", " tempUploadArea", " tempUploadDirectory", "TempUploadDir", "tempUploadManager", "tempRootDir", " tempUploadManager", "tempDownloadPath", "tempImageManager", "temuploadPath", " tempStreamDirectory", "testUploadD", "tempWorkDirectory", "tempWorkFolder", "tempDownloadDirectory", " tempStreamFolder", "testAttachdir", "temUploadPath", " tempDownloadDirectory", "testUploaddir", "tempTempDir", "temuploadInfo", "TempDownloadFolder", "tempFileFolder", "tempUploadD", "tempTempManager", "tempUploadDirectory", "TempUploadFolder", "tempDownFolder", "tempImageArea", " tempUploadDb", "testUploadUrl", "testAttachDir", " tempDownloadFolder", "tempFileDir", "tempUploadFile", "tempuploadDir", "tempTempDb", "tempStreamJar", " tempDownloadManager", "tempDownloadDir"], "attachmentDir": ["AttachmentFile", "AttachedDir", "AttmentDir", "attachedObj", "attachmentDirectory", "attentionDb", "attmentDir", "attachedFile", "AttachedObj", "assachedDb", "attributionDir", "attachedDet", "attachmentDet", "assachedDet", "assachmentDb", "AttachmentFolder", "attentionDirectory", "AttachedFile", "attachmentObj", "assachmentFile", "attachedDirectory", "attporaryDir", "attmentFolder", "AttmentDirectory", "attentionDir", "attentionFile", "AttachmentMin", "attentionFolder", "attributionDb", "AttachmentObj", "attentionObj", "AttmentMin", "AttachmentDirectory", "attachDb", "attributionFile", "attmentObj", "attachDir", "attmentDirectory", "AttmentFolder", "attmentFile", "attachmentDb", "attachDirectory", "AttachmentDir", "attachmentFile", "attachmentFolder", "attmentMin", "assachmentDet", "attachedDb", "attachedDir", "attentionMin", "AttachedDirectory", "attporaryDb", "attachmentMin", "assachmentDirectory", "assachmentDir", "assachedDirectory", "attributionDet", "attporaryFile", "attachFile", "attporaryDet", "assachedDir", "assachedFile"], "paramMap": [" parammap", " paramList", "ParamClear", "ParameterMap", "Parammap", "paramClear", " paramZone", " paramArray", "argMap", "paramCache", "ParamMap", "argArray", " paramBlock", "ParameterCache", " paramClear", "mediaArray", " parameterList", "parammap", "paramList", "argClear", "argBlock", "mediaList", "ParamList", "paramArray", " parameterMap", "paramBlock", "ParameterList", "ParamBlock", "mediaMap", "mediamap", "ParameterZone", "ParamArray", "paramZone", " parameterZone", " parameterCache", "argList", " paramCache"]}}
{"id1": "23035537", "id2": "13565787", "code1": "    public boolean getContent(String userId, String latestMsgId) {\n        try {\n            String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId;\n            URL url = new URL(targetUrl);\n            InputStream in = url.openStream();\n            ArrayList<MessageObj> list;\n            if (in != null) {\n                MessageListDOMParser parser = new MessageListDOMParser();\n                list = (ArrayList<MessageObj>) parser.parseXML(in);\n                TransactionDAO dao = new TransactionDAO();\n                dao.insert(list);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "label": 0, "substitutes": {"getContent": ["postContents", "createContents", "postContent", "postcontent", "postBody", "getcontent", "getBody", "getContents", "readContents", "readBody", "createContent", "readContent", "createBody", "createcontent", "readcontent"], "userId": ["messageID", " userOr", "userName", " userPath", "UserOr", " userID", "UserPath", "USERId", "messageId", "messageName", "userOr", "UserID", "UserId", "UserName", "userPath", "USEROr", "userID", "USERPath", " userName", "USERName"], "latestMsgId": [" latestmsgID", "lastMessageID", "lastMsgId", " latestmsgId", "lastMsgid", " latestMsgid", " latestmsgTime", " latestMsgID", "latestChanID", "latestUserId", "latestmsgID", "latestChanid", "latestmsgid", "lastMsgID", "lastMessageId", " latestmsgid", "latestChanId", "latestmsgTime", "latestMessageid", "latestMessageID", "latestmsgId", "latestMessageId", "lastMessageid", "latestUserid", "latestMsgID", "latestChanTime", "latestUserID", "latestMsgid", "latestMsgTime", " latestMsgTime", "latestMessageTime"], "targetUrl": ["targetUr", "targeturl", "sourceurl", " targetUr", "TargetUrl", "sourcePage", " targetPage", " targeturl", "targetURL", "Targeturl", "sourceUrl", " targetURL", "TargetPage", "sourceURL", "targetPage", "TargetURL", "sourceUr", "TargetUr"], "url": ["resource", "window", "string", "channel", "host", "http", "www", "URL", "path", "api", "feed", "Url", "client", "download", "user", "address", "browser", "l", "connection", "base", "server", "location", "sl", "f", "link", "i", "image", "page", "ssl", "data", "r", "b", "id", "uri", "stream", "source", "file"], "in": ["resource", "In", "pass", "inas", "again", "serv", "ini", "string", "IN", "m", "xml", "is", "din", "inner", "bin", "input", "as", "wave", "ins", "inn", "err", "kin", "isin", "s", "out", "query", "load", "gin", "get", "i", "nin", "a", "image", "record", "socket", "login", "arin", "reader", "data", "ax", "raw", "r", "b", "inc", "source", "stream", "file"], "list": ["item", "entry", "group", "live", "section", "string", "join", "table", "view", "xml", "language", "sequence", "listed", "queue", "tree", "la", "json", "batch", "LIST", "dict", "cl", "l", "document", "all", "chain", "coll", "server", "array", "pool", "cli", "detail", "lp", "li", "set", "i", "tx", "record", "result", "test", "data", "parse", "id", "info", "lists", "parent", "collection", "lc"], "parser": ["rss", "class", "player", "jack", "xml", "http", "language", "ler", "paragraph", "layer", "api", "util", "json", "handler", "er", "command", "p", "document", "Parser", "system", "loader", "php", "per", "processor", "lp", "director", "worker", "a", "arser", "writer", "reader", "parse", "data", "plugin", "info", "parent", "collection", "builder"], "dao": [" dala", "idao", "dataos", "adaos", "idosa", "dosa", "Dao", "datala", "Daba", "idaos", "dala", "daba", "adao", "Dosa", "adosa", "daos", "idaba", " daba", "datosa", "datao", "adala", " dosa", "Daos", " daos"]}}
{"id1": "5808579", "id2": "19322910", "code1": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "code2": "    @Test\n    public void test_blueprintTypeByTypeID() throws Exception {\n        URL url = new URL(baseUrl + \"/blueprintTypeByTypeID/20188\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"{\\\"blueprintTypeID\\\":20188,\\\"blueprintTypeName\\\":\\\"Obelisk Blueprint\\\",\\\"productTypeID\\\":20187,\\\"productTypeName\\\":\\\"Obelisk\\\",\\\"productCategoryID\\\":6,\\\"techLevel\\\":1,\\\"productionTime\\\":1280000,\\\"researchProductivityTime\\\":7680000,\\\"researchMaterialTime\\\":5120000,\\\"researchCopyTime\\\":2560000,\\\"researchTechTime\\\":500000,\\\"productivityModifier\\\":256000,\\\"wasteFactor\\\":10,\\\"maxProductionLimit\\\":1,\\\"productVolume\\\":\\\"17550000\\\",\\\"productPortionSize\\\":1,\\\"dumpVersion\\\":\\\"cru16\\\"}\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n        connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/xml\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?><invBlueprintTypeDto><blueprintTypeID>20188</blueprintTypeID><blueprintTypeName>Obelisk Blueprint</blueprintTypeName><dumpVersion>cru16</dumpVersion><maxProductionLimit>1</maxProductionLimit><productCategoryID>6</productCategoryID><productPortionSize>1</productPortionSize><productTypeID>20187</productTypeID><productTypeName>Obelisk</productTypeName><productVolume>17550000</productVolume><productionTime>1280000</productionTime><productivityModifier>256000</productivityModifier><researchCopyTime>2560000</researchCopyTime><researchMaterialTime>5120000</researchMaterialTime><researchProductivityTime>7680000</researchProductivityTime><researchTechTime>500000</researchTechTime><techLevel>1</techLevel><wasteFactor>10</wasteFactor></invBlueprintTypeDto>\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/xml; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["encurepassword", "decryptPass", "encipherPass", "enccryptpassword", "decipherPassword", "decryptPassword", "encurePassword", "encryptPass", "encryptpassword", "enccryptPassword", "encipherPassword", "enccryptPass", "decipherpassword", "decryptpassword", "decipherPass", "encipherpassword", "encurePass"], "loginName": ["LoginPassword", "loginString", "usernameString", "loginKey", " loginKey", "LoginKey", "loginPassword", "siteKey", "LoginName", "LoginCode", "LoginString", "siteCode", " loginPassword", "sitePassword", "siteName", "usernameName", "loginCode", "usernameCode", "usernameKey", " loginString", " loginCode"], "password": ["pass", "paste", "attribute", "words", "username", "token", "seed", "sword", "project", "description", "again", "string", "cache", "word", "secret", "Password", "PASS", "wallet", "api", "empty", "key", " passwords", "auth", "database", "pad", "wd", "address", "command", "p", "default", "out", "pa", "phrase", "prefix", "security", "work", "definition", "enc", "python", "code", "value", "a", "error", "picture", "account", "pattern", "Pass", "text", "name", "encrypted", "padding"], "md5": ["MD2", " md65", "MD5", "MD6", "sha4", " MD65", " mddown", "cmd53", " md53", " md6", "mddown", "md2", "cmd2", "MDdown", "md53", " md4", "md4", " MD53", " md2", " MD5", "cmd6", "md6", "sha2", " MDdown", " MD4", "cmd4", "md65", "md512", "cmd512", "MD4", "sha6", " md512", " MD2", "MD512", " MD512", "sha5", "cmd65", "cmd5"], "ba": ["fa", "asha", "ka", "bu", "ava", "bat", "ca", "abc", "bin", "na", "abi", "da", "Ba", "aa", "wa", "sa", "buf", "la", "bi", "ada", "ra", "BA", "alpha", "ha", "base", "ta", "pa", " ca", "ia", "bc", "aka", "a", "bo", "aba", "ae", "b", "ABC", "ab", "va"]}}
{"id1": "16466743", "id2": "596993", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    private String makeLoginRequest(URL url) throws IOException {\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setDoInput(true);\n        urlConnection.setDoOutput(true);\n        urlConnection.setUseCaches(false);\n        urlConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        StringBuilder content = new StringBuilder();\n        content.append(\"Email=\").append(URLEncoder.encode(EMAIL, \"UTF-8\"));\n        content.append(\"&Passwd=\").append(URLEncoder.encode(PASSWORD, \"UTF-8\"));\n        content.append(\"&service=\").append(URLEncoder.encode(SERVICE, \"UTF-8\"));\n        content.append(\"&source=\").append(URLEncoder.encode(\"Google Base data API\", \"UTF-8\"));\n        OutputStream outputStream = urlConnection.getOutputStream();\n        outputStream.write(content.toString().getBytes(\"UTF-8\"));\n        outputStream.close();\n        int responseCode = urlConnection.getResponseCode();\n        InputStream inputStream;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            inputStream = urlConnection.getInputStream();\n        } else {\n            inputStream = urlConnection.getErrorStream();\n        }\n        return toString(inputStream);\n    }\n", "label": 0, "substitutes": {"getmd5": ["getmn512", " getMD6", " getMD12", "getmd6", "getmetadata5", "getMD512", "getmn5", "getMD12", " getMD512", "getMD6", " getMD5", "getmn6", "getmd12", "getmetadata512", " getmd6", "getMD5", "getmn12", " getmd12", "getmd512", " getmd512", "getmetadata6", "getmetadata12"], "password": ["pass", "attribute", "token", "username", "words", "sword", "string", "word", "secret", "input", "Password", "PASS", "path", "key", "number", " passwords", "auth", "pad", "email", "wd", "address", "p", " Password", "prefix", "phrase", "config", "array", "f", "hash", "login", "data", "account", "message", "pattern", "buffer", "crypt", "text", "name", "encrypted", "padding"], "pwHash": ["pwtHash", "qwDig", "PWHash", "PWSum", "pwMac", "qxDig", "qwSum", "pwhMac", "pwaSum", "pxDig", "pwhBlock", "pWBlock", "pwDig", "qwMac", " pwahash", "pWSum", " pwaHash", "PWMac", "PwMac", "qxHash", "pxMac", "pxHash", "qxSum", "pwdSum", "pwaMac", "pwaHash", "pxSum", "pWHash", "pwaDig", "PwBlock", "pwtBlock", "pweHash", "pwdDig", "qwHash", "pwahash", "pweSum", "pwhSum", " pwSum", "PwHash", "pwdMac", "pwtSum", "pwdHash", "pwSum", "pwdhash", "pWMac", "pwhash", " pwhash", "pwBlock", " pwDig", "PWBlock", "pwhHash", "qxMac", "pweDig", " pwaSum", "pwehash", "pwtMac", "PwSum", " pwaDig"], "md": ["dc", "mb", "mg", "mp", "pd", "ms", "pm", "mage", "od", "mand", "cm", "mac", "Cmd", "m", "rm", "sm", " MD", "um", "d", "sha", "hm", "MD", "bd", "meta", "ad", "M", "dd", "ld", "mc", "cd", "mod", "cmd", "ma", "mag", "am", "dm", "hash", "nm", "amd", "mi", "kg", "dig", "mm", "metadata", "mt", "me", "mu", "bm", "db", "mo"], "b": ["ib", "mb", "nb", "u", "bs", "B", "ob", "d", "bin", "be", "bd", "buf", "emb", "bi", "orb", "eb", "p", "batch", "br", "lb", "l", "gb", "reb", "base", "sb", "f", "e", "a", "bytes", "cb", "bis", "bb", "r", "fb", "buff", "ba", "bf", "binary", "buffer", "wb", "ab", "rb", "db"], "i": ["si", "chi", "qi", "ip", "u", "multi", "n", "ii", "c", "pi", "o", "d", "abi", "ci", "di", "io", "z", "slice", "ji", "ui", "vi", "ri", "bi", "mu", "p", "it", "l", "phi", "s", "base", "j", "I", "x", "index", "f", "e", "oi", "li", "a", "start", "h", "ni", "v", "gi", "ti", "data", "ai", "r", "xi", "zi", "id", "info", "uri", "block"]}}
{"id1": "14794404", "id2": "5148212", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["encryptSecret", "EncipherPassword", "EncryptPassword", "encryptString", "encryptedpassword", "EncipherSecret", "Encryptpassword", "encipherSecret", "EncipherString", "encressString", "encryptpassword", "encressPassword", "encipherPassword", "Encipherpassword", "encressSecret", "encipherString", "encresspassword", "EncryptSecret", "EncryptString", "encipherpassword", "encryptedSecret", "encryptedString"], "password": ["resource", "pass", "attribute", "token", "username", "words", "sword", "description", "string", "cache", "channel", "word", "secret", "input", "Password", "PASS", "path", "params", " passwords", "database", "email", "wd", "content", "object", "address", "p", "connection", "device", "prefix", "phrase", "definition", "array", "enc", "data", "message", "pattern", "buffer", "crypt", "text", "name", "padding"], "encryptedPassword": [" encryptedpassword", "ryptedpassword", "lockedPassword", "encryptedpassword", "protectedpassword", "protectedPass", "encryptedCode", "ryptedPass", " encryptedCode", "protectedCode", "ryptedPassword", "ryptedString", " encryptedPass", "lockedPass", "encryptedPass", "lockedpassword", " encryptedString", "ryptedCode", "protectedString", "encryptedString", "protectedPassword", "lockedString"], "md5": ["MD2", "MD5", "MD6", " MD3", " mddown", " md6", "mddown", "md2", " md3", "MDdown", "dig45", "dig4", " md4", "md4", "dig5", " md2", " MD5", "dig3", "md6", "amd6", "amd4", "MD45", "md512", "MD4", " MD2", " md512", "MD512", "amd2", "md45", "md3", "dig2", " MD512", "MD3", "amd5", "digdown", " md45"], "digest": ["mdment", "mdash", "encment", "Digace", "mdest", " digher", " digests", "Digester", "mdested", "Digested", "signest", "digested", "digester", "digace", "digenge", " digester", "Digenge", "Digher", "signester", "digment", "mdests", "mdace", " digash", "signests", " digenge", "signested", " digace", "Digests", "mdenge", "mdester", "digests", "mdher", "Digest", "encester", "digash", " digment", "digher", "encash", "encest"], "i": ["hi", "si", "qi", "ip", "u", "multi", "k", "ii", "c", "pi", "o", "d", "ci", "di", "io", "ui", "length", "ri", "bi", "ie", "p", "it", "l", "phi", "s", "j", "I", "x", "index", "f", "e", "oi", "li", "h", "v", "gi", "ti", "ai", "r", "b", "zi", "t", "id", "xi", "uri", "ix"], "hex": ["temp", "ctr", "ip", "nexus", "zip", "string", "utf", "rh", "ex", "exp", "ix", "shift", "str", "pixel", "bin", "stick", "di", "bits", "char", "none", "bit", "slice", "num", "length", "coord", "letter", "lit", "alpha", "oct", "prefix", "pex", "mix", "enc", "comp", "serial", "rex", "sex", "hash", "check", "closure", "ext", "data", "digit", "null", "pack", "buff", "id", "pattern", "sign", "binary", "text"]}}
{"id1": "22410173", "id2": "18238468", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "source": ["resource", "route", "use", "site", "Source", "inner", "input", "copy", "ource", "path", "down", "from", "slice", "ins", "unit", "ie", "up", "connection", "base", "url", "size", "iter", "SOURCE", "start", "internal", "sin", "image", "reader", "ources", "target", "id", "parent", "stream", "src", "name", "file"], "dest": ["folder", "temp", "done", "exit", "project", "dist", "bin", "destroy", "desc", "down", "path", "die", "this", "comb", "connection", "orig", "tmp", "delete", "thin", "flat", "home", "Dest", "transfer", "img", "output", "test", "true", "target", " destination", "de", "wb", "src", "name", "later", "file"], "in": ["resource", "In", "pull", "again", "n", "c", "ini", "IN", "m", "cin", "inner", "din", "bin", "src", "input", "as", "con", "this", "pin", "ins", "min", "conn", "inn", "ie", "err", "up", "init", "win", "s", "url", "work", "gin", "f", "inside", "i", "by", "nin", "a", "image", "socket", "start", "file", "login", "reader", "data", "r", "b", "plugin", "inc", "id", "info", "lock", "client", "re", "name"], "out": ["timeout", "temp", "not", "at", "again", "cat", "n", "c", "channel", "o", "option", "call", "ex", "exp", "inner", "bin", "with", "Out", "self", "log", "outer", "io", "outs", "this", "sync", "conn", "no", "our", "err", "up", "connection", "init", "net", "w", "exec", "url", "index", "pool", "off", "password", "i", "lib", "socket", "plain", "writer", "to", "ext", "img", "output", "ou", "write", "data", "obj", "OUT", "vert", "inc", "id", "parent", "client", "name", "file", "extra"]}}
{"id1": "6988216", "id2": "18891988", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" runClientFilter", "runRawQuery", "runRawConnect", " runSimpleFilter", " runBasicQuery", " runSimpleQuery", "runRawSearch", " runClientQuery", " runClientConnect", " runBasicFilter", "runSimpleQuery", " runSimpleSearch", " runRawFilter", "runSimpleConnect", " runSimpleConnect", " runBasicSearch", " runRawConnect", "runSimpleFilter", "runSimpleSearch", "runRawFilter", " runRawSearch", " runClientSearch", " runBasicConnect", " runRawQuery"], "dummySource": ["dandySource", "dellyContent", "dumbConfig", "dellyService", "puddyType", "dandyClient", "daddyContent", "dundleSource", " dumbSource", "dandySourceFile", "duddyService", "puddyService", "pummyType", "dummyOrigin", "pummyClient", "dumbOrigin", "dummySourceFile", "puddySite", "dumbContent", "duddyType", "daddyClient", "dummyType", "dummySite", "duddySource", "puddyContent", " dummyOrigin", "pummySourceFile", "dummyConfig", "dumbSource", "daddyService", "daddySourceFile", "duddySourceFile", "pummyContent", " dumbContent", "duddyClient", "dummyClient", "duddySite", "dundleOrigin", "puddySource", "dellySource", "daddySite", "daddyType", "duddyConfig", "puddySourceFile", "pummySource", "dundleContent", " dumbConfig", "duddyOrigin", " dumbOrigin", "pummySite", "dundleConfig", "duddyContent", " dummyConfig", "puddyClient", "dummyService", "pummyService", "dandySite", "daddySource", "dellyType"], "os": ["or", "ks", "us", "ms", "ol", "ios", "bs", "osi", "ens", "css", "mos", "op", "o", "dos", "oa", "is", "oss", "as", "io", "sys", "aos", "object", "bos", "conn", "acs", "oc", "om", "oos", "fs", "ose", "obs", "s", "nos", "pos", "out", "oS", "los", "iso", "vs", "ls", "ops", "cos", "Os", "i", "ds", "ox", "ori", "oses", "ros", "ns", "ok", "ols", "ows", "ou", "ps", "uns", "es", "OS", "ss"], "dummyContent": ["dummyReader", "dummyContents", "duckyBody", "DummySource", "dellyContent", " dellyOutput", "dumpingContents", "dumperOutput", "dumpingcontent", "DuckyContent", "DummyBody", " dummyOutput", "duckyReader", " dellyContent", "duddySource", "dellyContents", "dumperReader", " dummyContents", "dumpercontent", "DuckyBody", "dumperSource", "duddyReader", "dumperBody", "duckySource", "duckyContent", "dummycontent", "dummyOutput", "DummyContent", "dumpingOutput", "duddyBody", "dellycontent", " dellycontent", " dellyContents", "dumpingContent", "DuckySource", "dummyBody", "dellyOutput", "dumperContent", "duddyContent", "DummyReader", "DuckyReader", "dumperContents", " dummycontent"], "source": ["resource", "slave", "class", "use", "seed", "string", "resources", "host", "cache", "channel", "Source", "proxy", "service", "scope", "node", "ource", "search", " sources", "sc", "text", "sync", "client", "object", "unit", "connection", "s", " Source", "storage", "element", "url", "sn", "cos", "config", "size", "sl", "e", "i", "SOURCE", "sin", "result", "reader", "secure", "ser", "ources", "target", "info", "stream", "uri", "parent", "src", "site", "core"], "content": ["resource", "body", "media", "description", "clean", "css", "host", "current", "xml", "expression", "title", "version", "cover", "comment", "service", "response", "transform", "input", "report", "news", "feed", "match", "sol", "cms", "child", "music", "address", "header", "document", "model", "server", "Content", "url", "load", "cos", "config", "size", "children", "code", "value", "image", "html", "result", "output", "data", "target", "comments", "message", "update", "text", "cont", "activity"], "qResult": ["iqresult", "qResults", "queryResults", " qResults", "rRes", "qResponse", "kReturn", "queryFilter", "iqResponse", "kResult", " qresult", "QReturn", "rResult", "queryResult", "QFilter", "qRes", "qReturn", "kResults", "QResults", "queryresult", " qResponse", "qFilter", "kFilter", "qSource", "iqResult", "queryReturn", "rresult", "iqResults", "querySource", "kresult", "kSource", "kRes", "rSource", "queryRes", "queryResponse", "QResult", "qresult"], "results": ["reports", "pages", "resources", "lines", "values", "errors", "ids", "response", "objects", "versions", "details", "shows", "files", "events", "ins", "Results", "groups", "members", "RESULTS", "successful", "tests", "qs", "s", "its", "children", "ries", "vers", "ions", "blocks", "res", "result", "features", "data", "models", "items", "docs", "users", "runs", "collection", "rows"], "it": ["or", "entry", "si", " It", "ip", "not", "pit", "and", "you", "op", "ait", "IT", "rit", "itted", "ci", "ic", "iti", "edit", "list", "slice", "ITS", "the", "in", "ins", "ort", "ited", "lit", "mit", "p", "l", "init", "its", "ati", "iter", "ite", "i", "split", "stat", "v", "It", "r", "t", "id", "sit", "info", "which"], "rSrc": [" rDsrc", "rAsrc", "RIsrc", " rDsource", "RSrc", "rEsource", "rDsource", "RIsource", " rSRC", " rSsrc", "rDssrc", " rEsrc", "rPsRC", "rAsRC", " rDssrc", "rEssrc", " rEsRC", "rPsource", "rAssrc", "rSrec", "RSource", "rPssrc", "rIsrc", "RSRC", "rDsRC", "RIsrec", "rDsrc", " rDsRC", "rIsrec", "rEsrc", " rEsource", " rEssrc", "rEsRC", "rPsrc", "rAsource", "RIsRC", "rIsource", " rSource", "rSource", "rSRC", "RSrec", "rAsrec", "rIsRC", "rSsrc"], "rSrcIn": ["rAsrcin", "rSsrcOut", "rSvcIN", "rCrcIn", "rSourcein", "rSRCIns", "rCRCIn", "rCsrcIn", "rCsrcIN", "rSrcOut", "rCrcIns", "rSRCOut", "rSourceIn", "rAsrcOut", "rSrcIN", "rSRCin", "rSvcOut", "rSourceOut", "rCrcIN", "rAsRCOut", "rSsrcIN", "rSvcIns", "rCrcOut", "rSvcin", "rCRCIns", "rSrcin", "rAsrcIn", "rCrcin", "rSRCIn", "rSrcIns", "rSourceIns", "rAsRCin", "rCsrcin", "rCsrcOut", "rSsrcIn", "rAsRCIn", "rSRCIN", "rSvcIn", "rSsrcin", "rCRCOut"], "actualOut": ["operatorOut", "assertOut", "publicIn", " actualIn", " actualOUT", "eventout", "publicOut", "eventOut", " actualWin", "actualBridge", "operatorIn", "realOut", " ActualOut", "actualout", " ActualOUT", "nexpectedout", "illegalOUT", " ActualBridge", "assertOUT", "actualWin", "operatorOUT", "realIn", "assertBridge", "assertIn", "actualIn", " actualOutput", "publicOutput", "illegalOut", "illegalOutput", "realout", "nexpectedWin", " actualout", "nexpectedOut", "actualOutput", "realWin", " ActualIn", "publicOUT", "nexpectedIn", " actualBridge", "actualOUT", "eventOUT", "eventIn", "illegalIn", "operatorout"]}}
{"id1": "6009527", "id2": "12055086", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadAssments", "doFinishLoadInstortion", "doFinishLoadInstachment", "doFinishloadAttments", "doFinishLoadAttment", "doFinishLoadInstment", "doFinishloadAttment", "doFinishLoadAssment", "doFinishloadAttachment", "doFinishLoadAttachments", "doFinishLoadAttachortion", "doFinishloadAttachachment", "doFinishLoadAttments", "doFinishLoadInstments", "doFinishloadAttachments", "doFinishLoadAttortion", "doFinishloadAttortion", "doFinishLoadAttachachment", "doFinishloadAttachortion", "doFinishLoadAssachment", "doFinishLoadAssortion"], "attachmentId": ["attentionInfo", "attimageID", "attimageInfo", "attachmentID", "adachmentId", "adociationPath", "attachmentid", "attachmentPath", "adociationInfo", "attentionid", "attplementationId", "attplementationID", "AttachmentId", "attimagePath", "ttociationid", "ttociationId", "Attachmentid", "ttachmentID", "attlementID", "attociationid", "AttachmentID", "attociationId", "adachmentInfo", "attociationInfo", "attentionID", "attlementId", "attentionPath", "AttachmentType", "attentionId", "attociationID", "ttociationID", "ttachmentId", "adachmentPath", "attlementType", "attlementid", "attimageId", "attachmentInfo", "ttachmentid", "adachmentID", "attachmentType", "attociationPath", "adociationID", "adociationId", "attentionType", "attplementationid"], "attachment": ["attment", "attachruction", "adment", "appachment", "appment", "attruction", "attention", "attachached", " attention", "attachachment", "assention", "instment", "attached", "assached", " adaptociation", " attment", "association", "attociation", " adaptachment", "appruction", "adached", "attachention", "assachment", "instachment", "assment", "adention", " attociation", " adaptention", "instention", " adaptment", "appention", "adachment", "instruction"], "attachmentUri": ["attmentIri", "attachmentUris", "attachmentCuURI", "attachedAti", "attachmentEri", "attachmentSuris", "attachmentIuri", "attachedURI", "attachmentSuri", "attachmentSuti", "attachmentSuuri", "attachmentIURI", "attachedUti", "attachmentSuRI", "attachedAuri", "attachmentAri", "attachmentEuri", "attachmentUti", "attachedUri", "attachmentIris", "attmentUURI", "attachmentSuURI", "attmentUri", "attachmentERI", "attachedARI", "attachmentUuri", "attachedUuri", "attachmentCuuri", "attachedAri", "attachmentAuri", "attachmentEti", "attachmentAti", "attachmentCuri", "attachmentIri", "attachmentUURI", "attmentIURI", "attachmentCuris", "attmentIuri", "attmentUuri", "attmentIris", "attachmentURI", "attachmentARI", "attmentUris"], "contentUri": ["contentUsris", "contentIi", "contentURuri", "contentUuri", " contentSudi", " contentSuRI", " contentURI", "contentSuRI", "resourceIri", "contentSuri", "resourceURI", "contentIri", "resourceUris", "contentCRI", "contentFileris", "contentURi", "resourceUri", "contentURI", "contentURris", "resourceIuri", "resourceIRI", "contentUsdi", "contentUdi", "contentCuri", "contentUsRI", "resourceUi", " contentUris", "contentUi", "contentCi", "resourceIi", " contentUdi", " contentSuri", "contentUsuri", "contentCris", "resourceUuri", "contentCdi", "resourceIris", "contentCri", "contentFileri", "contentSudi", "contentFileRI", "contentUsri", "contentFileuri", "contentIuri", "contentIRI", "contentUris", "contentSuris", "contentIris", " contentSuris", "contentURri"], "file": ["File", "folder", "resource", "able", "local", "ger", "use", "stream", "line", "entity", "zip", "cache", "view", "le", "input", "copy", "path", "log", "io", "via", "this", "files", "object", "child", "letter", "content", "unit", "book", "single", "handler", "up", "create", "connection", "base", "pe", "model", "upload", "url", "get", "work", "load", "f", "FILE", "filename", "image", "auto", "socket", "to", "fp", "output", "reader", "data", "picture", "b", "source", "uri", "binary", "buffer", "name"], "in": ["In", "pull", "or", "again", "ini", "c", "IN", "m", "o", "din", "inner", "bin", "input", "copy", "as", "con", "io", "this", "pin", "sync", "ins", "ac", "conn", "inn", "err", "up", "connection", "init", "s", "win", "url", "gin", "f", "cli", "e", "i", "nin", "a", "image", "socket", "login", "reader", "data", "r", "b", "inc", "id", "source", "binary"], "out": ["resource", "In", "line", "again", "cache", "IN", "o", "ex", "view", "inner", "bin", "Out", "copy", "log", "outer", "io", "outs", "this", "sync", "on", "conn", "err", "up", "connection", "net", "s", "base", "init", "exec", "cli", "i", "by", "nin", "image", "socket", "to", "writer", "page", "ext", "output", "data", "OUT", "null", "b", "inc", "source", "lock", "client", "one"], "intent": ["action", "entry", "advert", "vent", "acc", "entity", "effect", "act", "context", "request", "xml", "language", "ents", "concept", "response", "ani", "ctx", "inst", "contact", "this", "activate", " Intent", "content", "object", "it", "intention", "animate", "document", "init", "agent", "element", "spirit", "event", "ant", "anc", "enc", "impact", "category", "eng", "anim", "ink", "feature", "Activity", "term", "feat", "ent", "activation", "text", "activity", "focus", "android"]}}
{"id1": "7809093", "id2": "23246123", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "label": 1, "substitutes": {"getContent": [" getEntity", "getData", "setData", "responseOutput", "GetData", "getOutput", "requestEntity", "requestBody", "responseContent", "GetBody", "getBody", " getBody", "requestOutput", "GetEntity", "setBody", "setEntity", "responseEntity", "responseBody", "setContent", "GetContent", "requestContent", " getData", "getEntity", "GetOutput"], "request": ["resource", "application", "route", "position", "string", "instance", "current", "method", "http", "Request", "xml", "input", "path", "report", "operation", "queue", "object", "user", "address", "handler", "connection", "server", "query", "url", "e", "q", "result", "data", "type", "req", "r", "QUEST", "message", "uri", "name", "reference"], "sb": ["ib", "usb", "bh", "nb", "bs", "pb", "sf", "bm", "bt", "abi", "bg", "bd", "sa", "obb", "bsp", "bp", "SB", "eb", "sup", "abb", "vm", "lab", "lb", "xb", "gb", "ls", "amb", "bc", "su", "lp", "zb", "BB", "fp", "cb", "bb", "sk", "sg", "bj", "b", "bf", "fb", "buffer", "binary", "wb", "ab", "src", "rb", "db"], "client": ["resource", "application", "container", "project", "c", "cache", "host", "current", "context", "channel", "call", "http", "proxy", "service", "con", "api", "contact", "util", "https", "force", "queue", "ce", "conn", "handler", "p", "bird", "cl", "connection", "app", "default", "net", "server", "url", "config", "per", "cli", "session", "connect", "remote", "ssl", "output", "plugin", "apache", "web", "uri", "Client", "console", "builder", "tc"], "httpParams": ["httpPoeters", "HTTPPoeters", "httpPARcs", "HTTPPARams", "httpParamas", "HTTPParparams", "httpParam", "httpPrams", "HTTPParamer", "httpPARums", "httpArums", "httpPrparams", "httpArcs", "HttpParam", "HTTPPoams", "httpParamer", "httpPareters", "HTTPPARcs", "HttpParams", "httpPreters", "httpPerparams", "httpPams", "httpPparams", "HTTPParums", "httpParparams", "httpPARparams", "HTTPParam", "httpPeram", "httpPoparams", "httpPoams", "HTTPPARums", "httpParcs", "HTTPPareters", "HTTPParcs", "httpPARam", "HTTPParams", "HTTPPARam", "httpPeters", "httpParums", "HTTPPoamer", "httpPerams", "HttpParparams", "httpPeramas", "httpPARamas", "HTTPPoparams", "HttpParamas", "httpArams", "httpAram", "httpPARams", "httpPoamer", "httpPramer", "httpPamer"], "response": ["Response", "resource", "application", "status", "respond", "reply", "http", "results", "view", "report", "api", "feed", "onse", "json", "relation", "object", "successful", "resp", "connection", "document", "model", "server", "success", "received", "result", "page", "output", "error", "data", "message", "body", "collection"], "entity": ["resource", "entry", "application", "media", "instance", "channel", "environment", "em", "xml", "http", "node", "api", "Entity", "json", "ce", "content", "object", "conn", "creator", "translation", "address", "connection", "document", "agent", "pe", "element", "model", "event", "server", "coll", "component", "article", "company", "e", "writer", "result", "output", "data", "type", "ent", "source", "body", "collection", "file", "person"], "reader": ["row", "ry", "reading", "oder", "inner", "ler", "input", "io", "ner", "feed", "driver", "in", "ri", "er", "handler", "iterator", "bird", "server", "loader", "read", "Reader", "rer", "per", "iter", "i", "worker", "editor", "writer", "ser", "rr", "r", "rx", "parser", "rar", "buffer", "stream", "source"], "line": ["inline", "entry", "row", "pass", "ip", "string", "lines", "word", "LINE", "str", "character", "comment", "le", "Line", "ge", "layer", "feed", "key", "char", "sync", "content", "no", "user", "header", "unit", "cl", "l", "base", "lin", "cell", "model", "url", "definition", "non", "sl", "iter", "link", "code", "len", "li", "el", "val", "page", "data", "r", "id", "message", "lf", "source", "job", "sel", "block", "name", "lc", "end"]}}
{"id1": "21224967", "id2": "13499897", "code1": "    public boolean crear() {\n        int result = 0;\n        String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatement(elJugador);\n            result = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (result > 0);\n    }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 0, "substitutes": {"crear": [" Crear", "generas", "genera", " crea", " creas", "Creas", "generare", " Crea", " Creas", "generar", "Crea", "Creare", " Creare", "Crear", " creare"], "result": ["df", "entry", "status", "function", "Result", "results", "limit", "comment", "currency", "response", "match", "number", "die", "force", "length", "user", "ret", "count", "err", "valid", "grade", "up", "default", "order", "rate", "out", "event", "score", "date", "mark", "value", "success", "feature", "record", "res", "counter", "diff", "error", "type", "cash", "ure", "found", "page", "sign", "message", "ver", "db"], "sql": ["action", "seed", "serv", "zip", "join", "string", "pg", "statement", " SQL", "select", "script", "comment", "dl", "log", "params", "sync", "database", "printf", "conn", "fn", "up", "base", "setup", "install", "cmd", "exec", "query", "url", "where", "sl", "session", "q", "plan", "fp", "repl", "ssl", "ql", "job", "update", "SQL", "db", "sq"], "connection": ["application", "section", "container", "function", "position", "c", "Connection", "cache", "environment", "context", "statement", "union", "table", "pg", "proxy", "condition", "ion", "log", "con", "manager", "ctx", "engine", "BC", "driver", "database", "relation", "conn", "loc", "which", "Exception", "p", "document", "cond", "event", "communication", "server", "query", "system", "config", "bc", "index", "session", "graph", "connect", "socket", "writer", "error", "connected", "lock", "client", "collection", "db", "tc"], "ps": ["ups", "hs", "ks", "pc", "cop", "pd", "pps", "bs", "pr", "pg", "pse", "eps", "proxy", "gs", "params", "pt", "Ps", "os", "ins", "ppa", "changes", "pp", "conn", "pers", "properties", "p", "proc", "qs", "pos", "pe", "cp", "pa", "vs", "query", "ops", "sp", "settings", "cs", "ports", "ns", "ds", "pre", "ips", "posts", "jp", "PS", "po", "gres", "ss"]}}
{"id1": "15241397", "id2": "19335986", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "label": 1, "substitutes": {"doGet": ["handlePut", "handleget", " doGET", "didPut", "doget", "doGET", " doPut", " doget", "doPut", "handleGET", "didGET", "handleGet", "didget", "didGet"], "request": ["resource", "application", "subject", "instance", "initial", "context", "method", "xml", "Request", "http", "input", "report", "queue", "user", "object", "er", "connection", "document", "event", "server", "url", "query", "complete", "received", "image", "result", "reader", "data", "type", "req", "QUEST", "message", "info", "uri", "buffer", "client", "web"], "response": ["Response", "resource", "application", "status", "function", "full", "respond", "host", "site", "reply", "results", "view", "version", "report", "wave", "onse", "queue", "json", "object", "resp", "connection", "document", "generation", "out", "model", "server", "pool", "other", "session", "image", "writer", "result", "page", "next", "output", "error", "data", "esi", "message", "parent", "client", "body", "collection"], "rewrittenQueryString": ["rewrittenRequestService", "rewrittenqueryText", "rewwrittenQueryStr", "rewrittenqueryString", "rewrittenUrlLine", "rewwrittenQueryLine", "rewwrittenRequestArray", "rewrittenQuestionList", "rewrittenqueryService", "rewrittenUrlService", "rewrittenRequestString", "rewrittenUrlString", "rewrittenQueryText", "rewwrittenQueryString", "rewrittenPageArray", "rewwrittenRequestService", "rewrittenQuestionLine", "rewwrittenRequestStr", "rewrittenRequestList", "rewrittenPageList", "rewrittenQuestionText", "rewrittenQueryList", "rewrittenRequestText", "rewwrittenRequestText", "rewrittenQueryArray", "rewrittenQuestionArray", "rewwrittenRequestList", "rewrittenqueryStr", "rewwrittenQueryService", "rewwrittenRequestString", "rewrittenRequestLine", "rewrittenQueryStr", "rewrittenQueryService", "rewwrittenQueryList", "rewrittenPageString", "rewrittenQuestionStr", "rewwrittenRequestLine", "rewrittenRequestStr", "rewrittenPageLine", "rewwrittenQueryArray", "rewrittenRequestArray", "rewrittenqueryLine", "rewrittenQuestionString", "rewrittenQueryLine", "rewrittenUrlText", "rewwrittenQueryText"], "rewrittenUrl": ["rewwrittenJar", "RewwrittenJar", "rewrittenJar", "rewcraftedUrl", "RewrittenURL", "RewrittenServer", "RewwrittenServer", "rewardedLocation", "rewriteServer", "rewwrittenLanguage", "rerittenUrl", "rewrittenLanguage", "rerittenUr", "rewedUrl", "rewrittenLocation", "rewwrittenServer", "rewardedInt", "rewriteText", "rewatchedUrl", "rewatchedServer", "rewwrittenLocation", "RewrittenFile", "rewodedLanguage", "RewwrittenURL", "rewwrittenurl", "RewrittenInt", "Rewwrittenurl", "rewrapedFile", "rewatchedText", "rewriteUrl", "rewrittenUr", "rewmatchedFile", "rewrapedUr", "rewcraftedUr", "rewmatchedurl", "RewrittenUrl", "rerittenFile", "rewrittenURL", "rewrittenFile", "RewwrittenFile", "rewcraftedURL", "RewwrittenText", "RewrittenLocation", "rewilledJar", "rewrittenInt", "rewardedUr", "rewrittenText", "rewedFile", "rewmatchedURL", "rerittenLanguage", "rewatchedURL", "RewwrittenUr", "rewilledInt", "rewcraftedLocation", "RewwrittenUrl", "RewrittenText", "RewwrittenInt", "RewwrittenLocation", "rewilledURL", "RewrittenUr", "rerittenURL", "rewilledUrl", "rewriteURL", "rewodedFile", "Rewrittenurl", "rewwrittenURL", "rewardedLanguage", "rewardedFile", "rewedURL", "rewardedURL", "rewmatchedUrl", "rewardedUrl", "rewodedURL", "rewodedUrl", "rewedurl", "rewwrittenInt", "rewwrittenText", "rewrittenServer", "rewwrittenUrl", "rewardedJar", "rewwrittenFile", "rewrittenurl", "RewrittenJar", "rewrapedURL", "rewrapedUrl", "rewwrittenUr", "rewedUr"], "httpURLConnection": ["httpGEConnection", "apacheGEconnection", "apacheURLConnection", "httpurlConnect", "httpStreamconnection", "httpURIConnect", "apacheGEConnect", " httpStreamSession", "httpELConn", "httpURConn", "webURLConn", "httpSSLClient", " httpURLSession", " httpURLCurrent", "webURLClient", "httpGEFlow", "httpSSLConn", "apacheGEConnection", " httpURConn", "HttpURLService", "apacheURLconnection", "webSSLClient", "httpUrlConnect", " httpStreamconnection", "httpURconnection", "httpURLService", "httpurlCode", "httpUrlconnection", " httpURLConnect", "httpChannelConnection", "httpWebConnection", "httpSSLContext", "httpWebConnect", "httpURLSession", "webURLContext", "httpChannelService", "httpWebConn", "httpURLClient", "httpurlCurrent", "httpURIFlow", "httpUrlCode", "httpurlconnection", "httpCLCode", "httpUrlClient", " httpStreamConnection", " httpURLCode", "HttpChannelService", "httpUrlContext", "httpCLConnection", "httpURIClient", " httpURConnect", "httpChannelConnect", "httpGEConnect", "httpURConnect", "httpURLFlow", "httpPathCurrent", "httpURLconnection", "HttpURLConnection", "httpELConnection", "apacheGEFlow", " httpUrlConn", " httpURLConn", "HttpURLConnect", "httpPathconnection", " httpURConnection", " httpURLconnection", "httpELConnect", "HttpChannelConnect", "httpStreamConnection", "HttpURLconnection", "httpurlConnection", "httpurlFlow", "httpurlSession", "httpPathConnection", "apacheURLConnect", "httpChannelconnection", "httpURLContext", "httpURConnection", "httpUrlConn", "httpURLCurrent", "HttpChannelConnection", "httpGEconnection", "httpURIconnection", "httpPathSession", "httpUrlService", "httpURService", "httpCLConn", "httpURLConnect", "httpURIConnection", "httpStreamCurrent", "httpSSLConnection", "webSSLContext", "httpStreamSession", "httpURLConn", "httpUrlConnection", "httpURLCode", "HttpChannelconnection", "webURLConnection", "apacheURLFlow", "webSSLConnection", "httpURIConn", " httpUrlCode", " httpUrlConnection", "webSSLConn", " httpStreamCurrent", "httpurlConn", "httpURIContext"], "header": ["item", "entry", "group", "attribute", "token", "section", "line", "function", "player", "string", "channel", "ter", "character", "cover", "headers", "comment", "layer", "outer", "after", "match", "key", "list", "queue", "driver", "pair", "second", "bridge", "er", "handler", "default", "rule", "document", "part", "Header", "event", "consumer", "server", "component", "dr", "definition", "index", "iter", "date", "field", "director", "head", "feature", "her", "hash", "writer", "filter", "result", "next", "member", "author", "data", "error", "metadata", "message", "info", "buffer", "back", "master", "block", "column", "version", "reference"], "value": ["item", "property", "entry", "attribute", "media", "function", "description", "string", "current", "option", "values", "expression", "version", "comment", "language", "label", "key", "json", "content", "object", "letter", "child", "valid", "default", "document", "hello", "element", "model", "server", "variable", "get", "office", "now", "field", "V", "Value", "set", "password", "format", "val", "v", "gi", "VALUE", "data", "type", "sv", "message", "info", "parent", "text", "name", "end"], "inputStream": ["outputSteam", "outputChannel", "resourceSteam", "pullSteam", "inputChannel", "outputStreamer", "InputChannel", "pullStreamer", "resourceChannel", "inputstream", "pullStream", "inputStreamer", "InputSteam", "resourceStream", "Inputstream", "pullstream", "resourcestream", "InputStreamer", "InputStream", "outputstream", "inputSteam"], "outputStream": ["responseSteam", "Outputstream", "outputSteam", "OutputStream", "outputChannel", "responseFile", "responseStream", "externalstream", " outputChannel", "outputStreamer", "outputFile", "OutputFile", " outputSteam", "inputstream", "OutputStreamer", "inputStreamer", "externalStream", "OutputSteam", "externalSteam", " outputFile", "externalStreamer", "responseChannel", "OutputChannel", "outputstream", "inputSteam"]}}
{"id1": "22552318", "id2": "19251426", "code1": "    private synchronized void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().matches(ERR_MISSING_TABLE)) {\n                e.printStackTrace(System.out);\n                throw new IOException(\"Error on initial data store read\");\n            }\n            String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                }\n                e2.printStackTrace(new PrintWriter(System.out));\n                throw new IOException(\"Error initializing data store\");\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        e4.printStackTrace(System.out);\n                        throw new IOException(\"Unable to cleanup data store resources\");\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                    throw new IOException(\"Unable to reset data store auto commit\");\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 0, "substitutes": {"loadDDL": ["loadDSLE", "loadDDLM", "loadingDDDL", "loadDSL", "loadDSDL", "loadCDDL", "loadDSLM", "loadCDLM", "loadDBL", "loadCDLE", "loadCDL", "loadDDLE", "loadDBLE", "loadingDSLE", "loadDBDL", "loadDBLM", "loadingDDL", "loadingDDLM", "loadingDDLE", "loadingDSDL", "loadingDSLM", "loadDDDL", "loadingDSL"], "stmt": ["stmd", "stm", "stsMT", "ostmp", "strmt", "shMT", " stpt", " stdb", "stpt", "stmp", "Stmt", "ostm", "shpr", "stpr", "stsmt", " sttr", "strnt", "estm", "ostmt", "Sttr", "Stmd", " stmn", "shdb", " stmit", "stnt", "StMT", "estmp", "Stnt", " stnt", " stMT", "strmn", "Stmn", "Stmit", "strtr", "Stdb", "estmn", "stmit", "ostmn", " stmp", "stMT", " stmd", "Stpt", "Stm", "ostMT", "Stpr", "stmn", "ostpt", "stsmd", " stpr", " stm", "sttr", "stdb", "shmt", "estmt", "stsmit"], "qry": ["qy", "quty", "dqries", "qri", "qrys", "qries", "qurys", "qty", "dqrys", "quries", "dqry", "requty", "dqri", " qy", "quy", " qty", "quri", "requy", "requry", " qrys", " qri", "qury", "requrys", " qries"], "q": ["n", "c", "k", "qa", "request", "select", "d", "str", " query", "qu", "ue", " msg", "queue", "qq", "iq", "Q", "p", "w", "qs", "qt", "rc", "query", "work", " req", "f", "quest", "e", "i", "h", "v", "dq", "req", "r", "b", "ql", "t", "id", "sq", "eq"]}}
{"id1": "771802", "id2": "21979717", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"createOutputStream": [" createOutputSteam", " createIOStream", " createInputSteam", " createByteFile", " createOutputFile", " createByteSteam", " createInputReader", " createIOSteam", " createByteReader", " createOutputReader", "createInputFile", " createInputFile", "createInputStream", " createIOFile", " createInputStream", "createOutputFile", "createInputSteam", " createByteStream", "createOutputReader", " createIOReader", "createOutputSteam", "createInputReader"], "inFile": ["outfile", "sourceFiles", "inputFile", "insfile", "sourcefile", "insFiles", "outFiles", "incStream", "inputStream", "infile", "inputFiles", "inStream", "sourceFile", "outStream", "insFile", "insStream", "incFiles", "inFiles", "inputfile", "incFile", "sourceStream", "incfile"], "outFile": ["outfile", "targetFile", "inDir", "workDir", "outDirectory", "workingFile", "inputFile", "outDir", "infile", "workingDirectory", " outDirectory", "workingfile", "workfile", "workTime", "workFile", "inTime", "outStream", "inputDir", "inputfile", "outTime", "inputTime", " outfile", "workingStream", " outStream", "targetfile", "targetDirectory", "targetStream"], "k_blockSize": ["k_byteLen", "k_blocksLength", "k_lineSize", "k_lockSize", "k_bitInfo", "k_blockCount", "k_blocksSize", "k_lockLen", "k_lockLength", "k_blockLength", "k_byteLength", "k_byteInfo", "k_lineCount", "k_blocksLen", "k_BlockCode", "k_byteCount", "k_BlockCount", "k_bitSize", "k_byteCode", "k_lineInfo", "k_lockCode", "k_byteSize", "k_blockCode", "k_blocksCount", "k_BlockSize", "k_BlockLength", "k_lockCount", "k_blockLen", "k_blockInfo", "k_bitCount"], "byteCount": ["blockSize", "byteSize", " byteSize", " byteLength", "byteLen", "blockCount", " bytecount", "Bytecount", "byteSum", "characterSize", "ByteLength", "flushcount", "blockLength", "flushLength", "ByteCount", "characterCount", "flushSize", "characterLen", " byteSum", "flushCount", "ByteSize", "ByteLen", "ByteSum", "characterLength", "byteLength", " byteLen", "blockSum", "bytecount"], "buf": ["background", "brace", "bh", "vec", "alloc", "cas", "append", "cv", "fd", "ctx", "feed", "queue", "la", "seq", "ucc", "loc", "batch", "bag", "base", "rc", "cmd", "tmp", "exc", "config", "Buffer", "len", "uf", "cap", "bytes", "cb", "border", "result", "img", "data", "feat", "Buff", "b", "fb", "buff", "flush", "bf", "buffer", "font", "src", "rb"], "ofp": ["OFnp", "Ofc", "Ofl", "Oft", "afl", "fort", "OFtp", "OFc", "afnp", "ofl", "forp", "afp", "Ofp", "Oftp", "afc", "ofnp", "Ofnp", "fortp", "ofc", "oft", "forc", "OFp", "OFl", "OFt", "oftp"], "zos": ["ses", "osi", "z", "iffs", "obb", "zig", "tz", "liquid", "obs", "webkit", "oda", "zyk", "gz", "zb", "soon", "zh", "zon", "nz", "robe", "js", "bs", "css", "zin", "cfg", "fits", "zn", "utils", "lol", "dylib", "zy", "oses", "zer", "zik", "rons", "zes", "za", "zona", "inos", "enos", "abi", "os", "outs", "packs", "iframe", "ZA", "oS", "los", "ls", "zx", "ops", "jas", "cos", "zar", "ws", "ZI", "zi", "lins", "forge", "owicz", "budget", "zers", "ozo", "ossus", "zen", "zip", "rez", "bitcoin", "bos", "zag", "nox", "bes", "uz", "zo", "ros", "hz", "ogl", "kos", "zl", "core", "modules"], "osw": ["osx", "isd", "eshell", "bswo", "bsws", "isnow", "eswd", "bws", "lsw", "ossd", "bx", "osssw", "esfw", "osd", "osswd", " osww", " osow", "esnow", "oswo", " osfw", "ishell", "isw", "esww", "osshell", "lsws", "esy", "isy", "ossy", "esow", "ossww", "esd", "oswd", "iswd", "ossow", "bwo", "bsx", "osfw", "ossnow", "ossfw", "oshell", "osww", "esw", "ossw", "osws", "osy", "osnow", "issw", "lsx", "essw", "lswo", "bsw", "osow"], "bw": ["bbew", "bz", "bbz", "ebW", "ebwe", "abwd", "owa", "lbwh", "lwa", "bws", "bwe", "lsw", "Bws", " bws", "lx", "ow", " bwa", "bx", "lbx", " bz", "fx", "bbws", "bwd", "fwh", "bbw", "bwa", "bbaw", "Bew", "lbsw", "Bw", "lw", "fbwd", " baw", "abwe", "owu", "oaw", "fw", " bew", "lbz", "bwu", "ebw", "bbwa", "ebwd", "bbwu", "abw", "lbwa", "lbws", "bwh", "Bwa", "lbw", "bew", "bbwh", " bwu", "bW", "fbw", "fbW", "baw", "fwa", "lbr", "fsw", "fbwe", "abW", " bwh", "fr", "bsw"], "zot": ["Ziot", "aziot", "Zot", "zori", "jot", "azit", "zerita", " zor", "zor", "jos", "jori", "zerit", "zeros", "zerott", "azor", "Zit", "zita", "jit", "ziot", "Zor", " ziot", "Zita", "azot", "Zott", "zerori", "zott", "zerot", "azita", " zori", "azott"], "ifp": [" ifc", "Ifc", "Ifi", "ifl", "ifb", "ifi", "ifc", " iff", "IFf", "IFp", " ifi", "ipl", "IFc", " ifb", "Iff", "IFb", "ipp", " ifl", "iff", "Ifp", "ipb", "IFi", "ipc", "IFl"], "zis": ["zits", "ziss", " zais", "zeip", "zais", "zip", "zeiss", "xIS", "zib", "jis", "zenis", "Ziss", "zipits", "zipis", " zits", " zisi", "zenIS", "zipip", "Zip", "jit", "xib", "zenais", "xisi", "xis", "xais", "xits", "Zits", "jisi", " zIS", "Zis", " zib", "zenib", "zeis", "zisi", "jits", "zipiss", "xit", "zIS", "zeits"], "isr": ["irr", "ISr", " issr", "ISrc", "ISsr", "irrb", "irpr", "isrb", "rispr", "irrc", "ispr", "risrc", "ISrb", "isrs", "isscr", "ISrs", "IScr", "risr", "ISpr", " isrs", "issrs", "isssr", "risrb", " iscr", "iscr", "issr", "isrc"], "br": ["Br", "ch", "ctr", "bh", "HR", "kr", "ob", "obl", "ocr", "str", " fr", "shr", "ber", "obi", "yr", "sr", "bro", "BR", "div", "bsp", "tr", "gr", " BR", "bp", "cro", "mr", "lr", "browser", "bl", "ibl", "err", "rib", " dr", "ibr", "arr", "sp", " Br", "bc", "bar", "img", "hr", "r", "b", "rs", "body", "rb", "fr"], "zit": [" zic", "zits", "zic", "jic", "zeitter", "zipith", "zipIT", "zip", " zip", "jita", "zenits", "jIT", "zeit", "zipit", "zeIT", "zenit", "zipits", " zits", "zIT", "ji", "zipip", "jite", "zita", "jit", " zith", "xic", "zeith", "zitter", "xith", "zith", "jith", "zenitter", "jip", " zite", "zenith", "zipita", "jits", "zite", "zi", "zipite", "xi", "xit", "zeita", "zipitter", " zi", "zeits"]}}
{"id1": "22855019", "id2": "22411381", "code1": "    public static MessageService getMessageService(String fileId) {\n        MessageService ms = null;\n        if (serviceCache == null) init();\n        if (serviceCache.containsKey(fileId)) return serviceCache.get(fileId);\n        Properties p = new Properties();\n        try {\n            URL url = I18nPlugin.getFileURL(fileId);\n            p.load(url.openStream());\n            ms = new MessageService(p);\n        } catch (Exception e) {\n            ms = new MessageService();\n        }\n        serviceCache.put(fileId, ms);\n        return ms;\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"getMessageService": ["getMediaServices", "getMailServ", "getmessageFactory", "newMessageServ", "newmessageServices", "getMediaFactory", "getMailService", "getMailFactory", "newmessageFactory", "newMessageServices", "newmessageServ", "getMediaService", "getMessageServices", "newmessageService", "newMessageService", "newMessageFactory", "getMessageFactory", "getMediaServ", "getmessageServ", "getMessageServ", "getmessageServices", "getMailServices", "getmessageService"], "fileId": ["filePart", "fileInit", "Fileid", "logId", " fileid", "messageid", "fileType", "FILEPart", "fileContext", "moduleid", "ileData", "fileKey", "ileId", " fileKey", "FileId", " fileInit", "FILEType", "fileString", "urlId", "moduleDef", "messageId", "logid", "FILEid", "connectionid", "moduleId", " fileContext", "FILEInit", "fileID", "fileid", " fileType", "FILEId", "messageDef", "connectionID", "fileEnd", "connectionId", "logContext", "FileString", "urlType", "fileDef", " fileDef", " fileData", "ilePart", "urlInit", "ileEnd", "FILEData", "fileData", " filePart", " fileEnd", "FILEEnd", "FILEContext", " fileString", "connectionString", "logPart", " fileID", "FileID", "urlKey", "FILEKey"], "ms": ["hs", "ics", "ks", "js", "us", "Ms", "pm", "cm", "g", "bs", "ys", "m", "mos", "ims", "is", "service", "gs", "manager", "ems", "cms", "xs", "fs", "mc", "s", "qs", "ams", "ls", "vs", "sp", "cs", "ws", "ports", "mo", "services", "ma", "e", "ns", "ds", "MS", "ips", "ts", "mi", "models", "ils", "md", "PS", "mm", "ps", "es", "rs", "me", "bm", "ss", "mes"], "p": ["ap", "pc", "ip", "pm", "u", "c", "cache", "m", "pi", "py", "pr", "op", "pb", "api", "np", "properties", "pp", "bp", "tp", "wp", "l", "pe", "cp", "j", "sp", "per", "f", "e", "lp", "i", "pre", "fp", "P", "data", "jp", "plugin", "ps", "po", "t", "parser", "r", "info", "pro", "vp"], "url": ["resource", "entry", "u", "zip", "string", "c", "m", "channel", "http", "service", "URL", "path", "ur", "api", "feed", "open", "key", "Url", "user", "bel", "browser", "l", "connection", "base", "server", "config", "sl", "f", "e", "i", "image", "page", "ssl", "data", "fl", "plugin", "b", "id", "web", "uri", "stream", "source", "org", "file"]}}
{"id1": "10728243", "id2": "6756635", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"scramble411": ["scramble5", "screamprint41", "screamble411", "screamble41", "scramcy41", "scrambe5", "scrambe411", "scramble41", "screamble5", "scramcy411", "scramble123", "scramprint5", "screamprint5", "screamprint411", "scramprint411", "scramprint41", "screamprint123", "scramcy5", "scrambe123", "scramprint123", "scramcy123", "screamble123", "scrambe41"], "password": ["pass", "attribute", "token", "username", "words", "sword", "project", "string", "mac", "channel", "word", "sudo", "secret", "input", "Password", "sum", "wallet", "PASS", "path", "key", "number", "auth", "pad", "email", "wd", "user", "address", "dh", "phrase", "prefix", "security", "config", "filename", "hash", "account", "crypt", "name", "padding"], "seed": ["pass", "token", "username", "shadow", "eed", "zip", "string", "sudo", "volume", "secret", "state", "prime", "sum", "key", "slice", "driver", "pad", "finger", "pair", "length", "random", "address", "mode", "template", "alias", "device", "prefix", "phrase", "size", "machine", "Salt", "hash", "id", "pattern", "offset", "source", "crypt", "text", "name", "padding"], "md": ["dc", "df", "mb", "mg", "mp", "pd", "ms", "pm", "od", "mand", "rm", "mac", "Cmd", "m", "cm", "mem", "sm", " MD", "km", "d", "sha", "hm", "di", "MD", "bd", "meta", "doc", "wd", "ht", "mode", "hd", "ad", "om", "dd", "ld", "mc", "part", "cd", "cmd", "dh", "mn", "addr", "mag", "ma", "nd", "pkg", "am", "ds", "ind", "gd", "dm", " Md", "amd", "mi", "nm", "kg", "dig", "diff", "mm", "metadata", "vd", "po", "mad", "mt", "grad", "mid", "bm", "mo"], "passwordHashStage1": ["passwordHashstage0", "passwordHashStep2", "passwordHashstage4", "passwordHashPhase0", "passwordSumPhase0", "passwordHashstage2", "passwordHashStage3", "passwordHashstage3", "passwordSumPhase3", "passwordHashStage0", "passwordSumStageOne", "passwordHashStep1", "passwordSumPhase2", "passwordHashPhase4", "passwordHashStage4", "passwordHashPhase1", "passwordHashStageOne", "passwordSumStage3", "passwordSumStage2", "passwordSumPhaseOne", "passwordSumStage0", "passwordHashPhase3", "passwordSumStage4", "passwordHashPhase2", "passwordHashStep3", "passwordSumPhase1", "passwordSumPhase4", "passwordSumStage1", "passwordHashstage1", "passwordHashstageOne", "passwordHashPhaseOne"], "passwordHashStage2": ["passwordHashStep8", "passwordHashPhase8", "passwordHashStep2", "passwordHashstage4", "passwordBlockStage4", "passwordHashstage2", "passwordHashStep1", "passwordSumPhase2", "passwordHashPhase4", "passwordBlockstage4", "passwordHashStage4", "passwordSumStageTwo", "passwordHashPhaseTwo", "passwordBlockStage2", "passwordHashPhase1", "passwordSumPhase02", "passwordHashPhase02", "passwordBlockStage1", "passwordSumStage2", "passwordBlockstage8", "passwordHashstage8", "passwordHashStage8", "passwordBlockStage8", "passwordHashPhase2", "passwordSumPhase1", "passwordHashStageTwo", "passwordHashstageTwo", "passwordBlockstage1", "passwordSumPhaseTwo", "passwordSumStage1", "passwordBlockstage2", "passwordHashstage1", "passwordHashStage02", "passwordHashstage02", "passwordSumStage02", "passwordHashStep4"], "toBeXord": ["toBeYors", "tobeXords", "tobeXor", "toBeCrossord", "toBeZors", "tobeYor", "tobeCrossor", "toBeWorkor", "toBeXords", "tobeYorder", "toBEXord", "tobeCrossords", "toBeCrossor", "toBEXor", "toBeWorkorder", "toBEYORD", "toBEYords", "toBeXORD", "tobeXord", "toBeCrossors", "toBeZORD", "toBEXORD", "tobeCrossord", "toBEYord", "toBeYor", "toBeYORD", "tobeXorder", "toBeWorkord", "tobeCrossors", "toBeWorkords", "toBeYords", "tobeYord", "tobeYors", "toBeZorder", "toBeWorkORD", "toBeZord", "toBeYord", "toBEXords", "toBeZords", "toBeWorkors", "toBeCrossORD", "toBeXorder", "toBEYor", "toBeYorder", "toBeZor", "toBeCrossords", "tobeXors", "toBeXor", "toBeXors"], "numToXor": ["numToxor", "numtoXorer", "num2AbsOr", "numToxOR", "numtoXor", "numToCrossOR", "numToAbsOr", "numToAbsorer", "num2XOR", "numToxorer", "numToWorkorer", "numToWorkors", "num2Absorer", "numtoxorer", "numToXOr", "numtoxOR", "numToWorkor", "num2AbsOR", "numToWorkOR", "numToAbsOR", "num2XOr", "num2Xor", "numToAnyor", "numToAnyorer", "numToCrossor", "numToCrossorer", "numtoXors", "num2Absor", "num2Xorer", "numToXors", "numToCrossOr", "numToXorer", "numtoXOR", "numToAnyOR", "numToXOR", "numToCrossors", "numToAbsor", "numtoxor", "numToAnyOr", "numtoxors", "numToxors"], "i": ["hi", "si", "qi", "chi", "ip", "u", "multi", "k", "ii", "c", "m", "pi", "n", "o", "y", "d", "abi", "ci", "di", "io", "z", "key", "slice", "ui", "in", "ri", "bi", "p", "it", "l", "part", "j", "I", "x", "index", "f", "e", "oi", "li", "off", "a", "h", "v", "gi", "ti", "ai", "r", "b", "xi", "t", "id", "info", "uri", "ix"]}}
{"id1": "149935", "id2": "15768167", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "subverting", "unverted", "Conversion", "converted", "CONverted", "unception", "CONverting", "conversion", " deconverting", "Convert", " deconvert", "conception", " deconverted", "subversion", "oconverted", "Conception", "subverted", "CONception", "oconvert", "oconversion", "subvert", "unvert", "CONversion", "CONvert", "converting", " deconversion", "unversion", "Converted", "oconverting"], "src": ["resource", "scene", "stage", "sth", "username", "cmp", "SourceFile", "string", "href", "Source", "spec", "cpp", "dist", "input", "ource", "path", "inst", "ctx", "sc", "buf", "slice", "sys", "attr", "rl", "download", "impl", "fn", "loc", "proc", "video", "gb", "s", "rc", "storage", "upload", "tmp", "url", "component", "load", "sn", "config", "sb", "code", "gz", "filename", "sin", "Dest", "fp", "cb", "ssl", "img", "reader", "st", "RC", "supp", "secure", "obj", "req", "feat", "rb", "prot", "back", "source", "stream", "uri", "sel", "name", "sit", "file", "ref"], "dest": ["dc", "txt", "temp", "class", " dst", "dat", "dist", "bin", "path", "di", "disk", "dir", "fn", "orig", "tmp", "home", "lib", "Dest", "std", "img", "test", "obj", "target", "null", " destination", "source", "cont"], "in": ["In", "inas", "pass", "ini", "n", "IN", "ex", "is", "d", "din", "bin", "input", "as", "io", "pin", "ins", "doc", "inn", "err", "up", "isin", "win", "f", "i", "a", "inf", "val", "login", "reader", "data", "r", "ps", "t", "inc", "source", "stream", "file"], "p": ["pc", "cop", "pd", "pm", "g", "c", "pr", "pi", "op", "py", "pb", "pg", "o", "m", "d", "np", "pp", "bp", "tp", "wp", "l", "part", "s", "pe", "cp", "pa", "j", "sp", "per", "f", "e", "lp", "i", "pre", "h", "fp", "v", "P", "jp", "r", "po", "ps", "t", "parser", "b"], "ds": ["dc", "hs", "words", "dl", "gs", "da", "obs", "s", "icks", "ges", "dm", "ts", "sts", "db", "df", "js", "pd", "bs", "ys", "dat", "lines", "dos", "d", "utils", "ads", "styles", " props", " sd", "amps", "ld", "ans", "Ds", "lp", "ns", "data", "posts", "parts", "docs", "ps", "DS", "ss", "dp", "scripts", "uds", "di", "os", "sync", "sys", "ins", "xs", "tests", "dds", "ls", "dt", "cs", "des", "nas", " DS", "ups", "ks", "eps", "dist", "cons", "ays", "tools", "ants", "groups", "plugins", "dd", "qs", "vs", "services", "dates", "ths", "els", "gd", "ded", "vals", "points", "ils", " ps", "ipes", "rs", "models"], "format": ["struct", "class", "function", "at", "act", "string", "host", "table", "spec", "version", "language", "atter", "path", "fd", "api", "magic", "letter", "unit", "handler", "fn", "frame", "nat", "scale", "tag", "part", "layout", "Format", "model", "prefix", "ant", "url", "config", "f", "sche", "filename", "record", "fp", "filter", "data", "type", "feat", "style", "plugin", "t", "parser", "pattern", "source", "form", "name", "file", "template"], "hasPixelData": ["showsPixeldata", "haspixeldata", "showsPixelDATA", "hasByteDATA", "hasPixeldata", "hasPixelDATA", "showsPixelStyle", " hasPixelSize", " hasPixeldata", "showsBytedata", "showsByteStyle", "haspixelSize", "showsPixelData", "hasByteData", "hasByteStyle", "hasBytedata", "haspixelData", "hasPixelStyle", "showsByteData", "hasPicturedata", "hasByteSize", "hasPictureSize", "hasPixelSize", "hasPictureData", "showsByteDATA"], "inflate": ["inFlated", "inadequating", "infloace", "insflode", "InFlate", "infolATE", "inadequode", "insvenATE", "inFlate", "insflating", "InFlace", "insflATE", "inffated", "inflation", "invenate", "inflace", "infolode", "inFlation", "infloate", "insvenate", "invenATE", "infloated", "inffation", "invenating", "InFlated", "insvenating", "insflate", "inflATE", "inflating", "Inflace", "infface", "inFlace", "infolate", "Inflated", "inffate", "Inflate", "inadequate", "insvenode", "inflated", "infolating", "infloation", "inflode", "invenode", "Inflation", "InFlation", "inadequATE"], "pxlen": ["fxdata", "pnglen", "pxlin", "mxln", "axlon", "pxcount", "fxln", "pglen", "txln", "pcln", "ppl", "pxlon", "txlin", "camlen", "fxl", "pgden", "pngsize", "axlin", "mxlen", "camln", "fxden", "xplength", "ppLen", "mxdata", "pxLen", "pxdata", "pclen", "pclin", "axln", "pxln", "axlen", "txlen", "pngcount", "campos", "mxpos", "fxLen", "xpsize", "xpcount", "pxsize", "pgl", "pxpos", "ppden", "pgLen", "fxpos", "pxlength", "fxlen", "mxlength", "mxcount", "xplen", "mxsize", "camdata", "pxden", "pclon", "pplen", "pxl", "pnglength", "txlon"], "out": ["group", "line", "again", "cache", "step", "inter", "state", "Out", "copy", "log", "io", "outs", "list", "co", "post", "sys", "pad", "user", "conn", "store", "err", "up", "server", "query", "work", "cli", "session", "dump", "lib", "v", "page", "output", "gen", "error", "obj", "OUT", "point", "parent", "lock", "re"]}}
{"id1": "18011804", "id2": "5723876", "code1": "    public FileChooserTestFrame() throws HeadlessException, MalformedURLException {\n        super();\n        addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent aEvent) {\n                System.exit(0);\n            }\n        });\n        Dimension dim = getToolkit().getScreenSize();\n        Rectangle abounds = getBounds();\n        setLocation((dim.width - abounds.width) / 2, (dim.height - abounds.height) / 2);\n        setVisible(true);\n        URL url = new URL(\"ftp://cendantstp/\");\n        char[] password = \"spnr\".toCharArray();\n        PasswordAuthentication passwordAuthentication = new PasswordAuthentication(\"spnr\", password);\n        FTPRemoteFileSystemView remoteFileSystemView = new FTPRemoteFileSystemView(url, passwordAuthentication);\n        JFileChooser fileChooser = new InsightRemoteFileChooser(remoteFileSystemView);\n        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);\n        fileChooser.setMultiSelectionEnabled(true);\n        File[] selectedFiles = null;\n        if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {\n            selectedFiles = fileChooser.getSelectedFiles();\n            for (int i = 0; i < selectedFiles.length; i++) {\n                if (selectedFiles[i] instanceof FTPFileFile) {\n                    FTPFileFile ftpFile = (FTPFileFile) selectedFiles[i];\n                    logger.fine(ftpFile.getName());\n                    logger.fine(ftpFile.getPath());\n                } else {\n                    logger.fine(selectedFiles[i].toString());\n                    logger.fine(selectedFiles[i].getAbsolutePath());\n                }\n            }\n        }\n        remoteFileSystemView.disconnect();\n        try {\n            if (null != selectedFiles) {\n                FTPClient ftpClient = new FTPClient();\n                InetAddress inetAddress = InetAddress.getByName(url.getHost());\n                ftpClient.connect(inetAddress);\n                if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {\n                    throw new FTPBrowseException(ftpClient.getReplyString());\n                }\n                if (null != passwordAuthentication) {\n                    ftpClient.login(passwordAuthentication.getUserName(), new StringBuffer().append(passwordAuthentication.getPassword()).toString());\n                }\n                for (int i = 0; i < selectedFiles.length; i++) {\n                    FTPFileFile file = (FTPFileFile) selectedFiles[i];\n                    logger.fine(file.getPath());\n                    FileOutputStream fos = new FileOutputStream(new File(\"d:/junk/ftp/test.txt\"));\n                    logger.fine(\"\" + ftpClient.retrieveFile(file.getPath().replaceAll(\"\\\\\\\\\", \"/\"), fos));\n                    fos.close();\n                }\n            }\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.exit(0);\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"HeadlessException": ["HeadfulException", "Headfulception", "headfulException", "HeadLessException", "headfulception", "Headingception", "headlessException", "HeadingException", "headlessception", "HeadLessception", "Headlessception"], "MalformedURLException": ["MalformedURLEncException", "MalformedURLExceptions", "MalformedURLEncceptions", "MalformedURLErException", "MalformedURLEncception", "MalformedURLErception", "MalformedURLExException", "MalformedURLExpception", "MalformedURLArrupt", "MalformedURLArception", "MalformedURLArException", "MalformedURLErceptions", "MalformedURLArceptions", "MalformedURLAxrupt", "MalformedURLAxException", "MalformedURLExprupt", "MalformedURLExpceptions", "MalformedURLExrupt", "MalformedURLExpException", "MalformedURLAxceptions", "MalformedURLEncrupt", "MalformedURLAxception", "MalformedURLErrupt"], "aEvent": [" oName", " keyboardFilter", " oEvent", " oFilter", " keyboardName", " keyboardEvent", " aAdapter", " aFilter", " keyboardAdapter", " videoFilter", " videoName", " oAdapter", " videoAdapter", " aName", " videoEvent"], "dim": ["dc", "Dim", "large", "sam", "project", "cm", "height", "im", "multi", "py", "ims", "dat", "d", "bm", "marg", "shape", "di", "uv", "imm", "coord", "div", " pixels", "loc", "dimension", "grid", "vm", "scale", "rect", "gb", " imm", "dr", "du", "size", "dt", "lat", "detail", "ds", "lim", "center", "dom", "dm", "cam", " cm", "img", "dem", "medium", "mm", " disp", "tm", " img", "db", "width"], "abounds": ["bound", "borders", "Abound", "bbbox", "bbounding", "Aborders", "obounding", "acands", " abound", " aborders", "acounding", "abbox", "abound", "bounding", "acounds", "bbounds", "bounds", "obbox", " abounding", "aborders", "Abounds", "Abands", "abounding", "abands", " abands", "bbox", "Abounding", "bbound", "obounds", "acound", "obound"], "url": ["resource", "username", "string", "channel", "host", "href", "http", "str", "service", "www", "input", "URL", "path", "feed", "gl", "https", "Url", "email", "download", "client", "user", "address", "loc", "browser", "l", "connection", "base", "server", "location", "config", "loader", "sl", "f", "image", "page", "ssl", "data", "fl", "id", "web", "uri", "buffer", "text", "source", "name", "ref"], "password": ["resource", "pass", "attribute", "token", "username", "words", "sword", "description", "channel", "word", "sudo", "secret", "language", "Password", "wallet", "path", "text", "key", " passwords", "auth", "email", "wd", "user", "address", "command", "connection", "prefix", "phrase", "security", "size", "login", "ssl", "data", "account", "pattern", "alias", "name", "padding"], "passwordAuthentication": [" passwordAuthenticating", "PasswordAuthicating", "PasswordAuthenticating", "passwordAuthicator", "PasswordAuthication", "PasswordAuthentection", "passwordAuthentection", " passwordCommunication", "passwordCommunection", "PasswordAuthentication", "passwordAuthication", "passwordAuthection", "passwordAuthenticator", "passwordCommunicating", " passwordCommunicating", "passwordAuthenticating", "PasswordAuthenticator", "passwordAfficator", "PasswordAuthection", "passwordCommunication", " passwordCommunection", "PasswordAuthicator", " passwordAuthentection", "passwordAffection", "passwordAffication", "passwordCommunicator", " passwordAuthenticator", " passwordCommunicator", "passwordAuthicating", "passwordAfficating"], "remoteFileSystemView": ["remoteFileystemView", "remoteFilesystemManager", "remoteFilessystemClient", "remotefileServerClient", "remotefileystemManager", "remoteFilesystemView", "remoteFilesSystemClient", "remoteFilessystemView", "remoteFilesystemview", "remotefileServerManager", "remoteFileSystemview", "remoteFilesystemVIEW", "remoteFilessystemview", "remotefileSystemManager", "remotefileServerView", "remoteFilesSystemView", "remoteFileServerClient", "remoteFileServerManager", "remoteFileServerView", "remotefileystemVIEW", "remoteFileNameManager", "remoteFilesSystemview", "remoteFileSystemClient", "remoteFileystemManager", "remotefileSystemView", "remoteFileystemVIEW", "remotefileystemView", "remotefileSystemVIEW", "remoteFileSystemManager", "remoteFileystemview", "remoteFileNameVIEW", "remoteFileNameView", "remotefileSystemview", "remotefileystemview", "remoteFileSystemVIEW", "remoteFilesystemClient", "remotefileSystemClient", "remoteFileystemClient", "remoteFileNameview"], "fileChooser": ["FileChoose", "fileSeose", "resourceChooser", "fileSeoser", "resourceChosen", "FileChoosen", "fileClosen", "fileChoose", " fileChooses", "resourceChooker", "FileClose", "resourceClose", "fileVoosing", "fileJoose", "resourceChose", "fileClose", "FileClosen", "fileSeoker", "fileComposes", "FileCloser", "FileChoosing", "fileCloser", "resourceChoosen", "fileDeclosen", "fileClosing", "fileClressor", "fileVooser", "resourceCloser", "fileChooker", "resourceChoiser", "fileChosen", "fileChoser", "fileChose", " fileClose", "fileCompressor", "fileChiser", "fileSeosen", "fileJoressor", "fileDecliser", "fileChoiser", " fileChoressor", "resourceCliser", "fileCompose", "fileChoosing", "FileChooker", "fileDecloser", " fileCloses", "fileChoressor", " fileClressor", "FileChooser", " fileChoose", "resourceChoose", "fileDeclose", "resourceChoser", "resourceChoker", "fileVoose", "fileChooses", " fileCloser", "fileCloker", "fileVooker", "fileJooses", "fileChoker", "fileComposer", "fileCloses", "FileClosing", "fileChoosen", "FileCloker", "resourceClosen", "fileJooser", "fileCliser", "fileVoosen"], "selectedFiles": ["registeredImages", "registeredfiles", "selectionTags", "matchedQuestions", "lectedContents", "currentFiles", "registeredBlocks", "selectedOps", "currentfiles", "selectedApplications", "selectedQuestions", "publishedFile", " selectedLS", "selectionFiles", "selectedLS", " selectedfiles", "selectedResources", "currentFile", "selectedBooks", "matchedThings", "testedFiles", "lectedTags", "selectionThings", "lectedApplications", " selectedContents", "publishedfiles", "matchedFiles", " selectedQuestions", "publishedContents", "selectedContents", "publishedFiles", "selectedFile", " selectedFile", "selectionImages", "matchedBooks", "lectedBlocks", "testedApplications", "selectedImages", "lectedBooks", " selectedBlocks", "selectionfiles", "lectedImages", "selectedTags", "registeredFiles", "matchedfiles", "lectedOps", "selectedThings", " selectedOps", "currentResources", " selectedApplications", "selectionLS", "selectedBlocks", "publishedResources", "testedOps", " selectedThings", "selectedfiles", " selectedResources", "lectedFile", " selectedBooks", " selectedImages", " selectedTags", "lectedQuestions", "lectedfiles", "lectedLS", "lectedFiles"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "n", "ii", "c", "k", "pi", "m", "y", "o", "ini", "g", "d", "inner", "ci", "di", "io", "key", "slice", "vi", "ui", "in", "ri", "bi", "count", "ie", "p", "it", "l", "part", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "start", "ni", "h", "v", "gi", "ti", "diff", "type", "ai", "data", "r", "b", "xi", "id", "info", "uri", "iv", "ix"], "ftpFile": ["ntpFile", " ftpFiles", "ftapFile", "nttpImage", "fttpChat", "ftpImage", "ftpMessage", "ptpFiles", "ftfImage", "ftfChat", "fttpFile", " ftapFile", "ntpChat", "ftfFiles", "ftffile", "ftPPart", "fttpFiles", "ftPFile", "ftiImage", "ptpMessage", "ftPMessage", "ftcFolder", "ptpeFiles", "ftpPart", "ftpePart", "ftpFiles", "fttpImage", "nttpFiles", " ftapFolder", "ftPFiles", "ftiFile", " ftapFiles", "nttpFile", "ftfPart", "ptpeFile", "ftcFile", "ftfMessage", "ntpImage", "ptpeMessage", "ftiFiles", "ptpFile", "ftcfile", "ftapFiles", "ftiChat", "ftapFolder", "ftcFiles", "ftfFolder", "ftfFile", "ftpfile", "ftpeFile", " ftpfile", " ftpFolder", "ptpPart", "ftpeFiles", "nttpChat", "ftapfile", "ptpePart", "ftpeMessage", "ftpChat", " ftapfile", "ftpFolder", "ntpFiles"], "ftpClient": ["fttServer", "ctcpClient", "ftpView", "ftapiView", " ftsCan", " ftpclient", "ftsClient", "ftapiclient", "ftpServer", "ftpcClient", "ftpcServer", "ftpiCan", "ftpiclient", " ftsView", "ftpcHost", "ctcpHost", "ftcpHost", "ftsclient", "ftpCan", "ftapiClient", " ftsClient", "ftsView", " ftsclient", "ctpServer", "ftpHost", "ftcpClient", "fttClient", "ftpcCan", "ftsCan", " ftpCan", "ftpiView", "ftapiCan", " ftpView", "ctcpCan", "ftpclient", "ftpiClient", "fttCan", "ftcpServer", "ctpClient", "ftcpCan", "fttHost", "ctpCan", "ctpHost", "ctcpServer"], "inetAddress": ["etHost", "networkHost", "etSocket", "inetZone", "inetHost", "inetLocation", "remotePort", "etLocation", "targetHost", "networkPort", "targetLocation", "remoteSocket", "inetPort", "targetPort", "socketAddress", "networkAddress", "socketSocket", "remoteZone", "inetSocket", "etZone", "etPort", "remoteAddress", "networkLocation", "etAddress", "socketZone", "targetAddress", "socketPort"]}}
{"id1": "4686922", "id2": "2221297", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static String getURLContent(String urlToSearchString) throws IOException {\n        URL url = new URL(urlToSearchString);\n        URLConnection conn = url.openConnection();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) encoding = \"ISO-8859-1\";\n        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        StringBuilder sb = new StringBuilder(16384);\n        try {\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line);\n                sb.append('\\n');\n            }\n        } finally {\n            br.close();\n        }\n        return sb.toString();\n    }\n", "label": 0, "substitutes": {"extractResourceToFile": ["extractResourcesToFile", "extractResourceInfile", "extractResourceAndFile", "extractResourceToResource", "extractResourceInFile", "extractResourceAsResource", "extractResourceToFiles", "extractResourceAsfile", "extractResourceAndResource", "extractResourcesToFiles", "extractResourcesTofile", "extractResourceInResource", "extractResourceAsFiles", "extractResourceTofile", "extractResourceInFiles", "extractResourceAndFiles", "extractResourcesAsFile", "extractResourceAsFile", "extractResourceAndfile", "extractResourcesAsFiles", "extractResourcesAsfile", "extractResourcesAsResource", "extractResourcesToResource"], "resourcePath": ["ResourceUrl", " resourceUrl", "sourceId", " resourcepath", "serviceFolder", "stringFolder", "sourcepath", "resourceId", "sourceUrl", "resourceUrl", "sourcePath", "resourceFolder", "ResourceId", "resourcepath", "stringPath", "servicepath", "servicePath", "Resourcepath", " resourceId", "ResourcePath", "stringpath", " resourceFolder"], "dest": ["folder", "resource", "txt", "temp", "done", "route", "class", "project", "sac", "resources", "dist", "destroy", " Dest", "path", "desc", "die", "content", "sup", "store", "comb", "trans", "default", "tmp", "contract", "config", "flat", "home", "filename", "Dest", "transfer", "result", "img", "output", "data", "target", "prop", " destination", "de", "source", "const", "wb", "src", "later", "file"], "in": ["resource", "In", "pass", "plus", "again", "ini", "c", "n", "IN", "rec", "cin", "is", "din", "inner", "bin", "input", "as", "con", "this", "ins", "conn", "inn", "kin", "up", "connection", "init", "win", "rin", "lin", "isin", "url", "gin", "like", "thin", "f", "inside", "i", "nin", "image", "socket", "sin", "login", "arin", "reader", "r", "b", "inc", "id", "source", "re", "file"], "out": ["temp", "In", "again", "at", "outside", "n", "cache", "o", "ex", "bin", "Out", "copy", "outer", "io", "norm", "outs", "this", "sync", "ins", "co", "conn", "boot", "user", "cookie", "err", "up", "app", "w", "s", "net", "all", "exec", "server", "cos", "f", "i", "off", "a", "image", "lib", "writer", "auto", "socket", "ext", "output", "ax", "obj", "OUT", "null", "b", "inc", "parent", "source", "client", "one", "file"]}}
{"id1": "364438", "id2": "16142024", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "subverting", "unverted", "Conversion", "converted", "CONverted", "unception", "CONverting", "conversion", " deconverting", "Convert", " deconvert", "conception", " deconverted", "subversion", "oconverted", "Conception", "subverted", "CONception", "oconvert", "oconversion", "subvert", "unvert", "CONversion", "CONvert", "converting", " deconversion", "unversion", "Converted", "oconverting"], "src": ["resource", "scene", "stage", "sth", "username", "cmp", "SourceFile", "string", "href", "Source", "spec", "cpp", "dist", "input", "ource", "path", "inst", "ctx", "sc", "buf", "slice", "sys", "attr", "rl", "download", "impl", "fn", "loc", "proc", "video", "gb", "s", "rc", "storage", "upload", "tmp", "url", "component", "load", "sn", "config", "sb", "code", "gz", "filename", "sin", "Dest", "fp", "cb", "ssl", "img", "reader", "st", "RC", "supp", "secure", "obj", "req", "feat", "rb", "prot", "back", "source", "stream", "uri", "sel", "name", "sit", "file", "ref"], "dest": ["dc", "txt", "temp", "class", " dst", "dat", "dist", "bin", "path", "di", "disk", "dir", "fn", "orig", "tmp", "home", "lib", "Dest", "std", "img", "test", "obj", "target", "null", " destination", "source", "cont"], "in": ["In", "inas", "pass", "ini", "n", "IN", "ex", "is", "d", "din", "bin", "input", "as", "io", "pin", "ins", "doc", "inn", "err", "up", "isin", "win", "f", "i", "a", "inf", "val", "login", "reader", "data", "r", "ps", "t", "inc", "source", "stream", "file"], "p": ["pc", "cop", "pd", "pm", "g", "c", "pr", "pi", "op", "py", "pb", "pg", "o", "m", "d", "np", "pp", "bp", "tp", "wp", "l", "part", "s", "pe", "cp", "pa", "j", "sp", "per", "f", "e", "lp", "i", "pre", "h", "fp", "v", "P", "jp", "r", "po", "ps", "t", "parser", "b"], "ds": ["dc", "hs", "words", "dl", "gs", "da", "obs", "s", "icks", "ges", "dm", "ts", "sts", "db", "df", "js", "pd", "bs", "ys", "dat", "lines", "dos", "d", "utils", "ads", "styles", " props", " sd", "amps", "ld", "ans", "Ds", "lp", "ns", "data", "posts", "parts", "docs", "ps", "DS", "ss", "dp", "scripts", "uds", "di", "os", "sync", "sys", "ins", "xs", "tests", "dds", "ls", "dt", "cs", "des", "nas", " DS", "ups", "ks", "eps", "dist", "cons", "ays", "tools", "ants", "groups", "plugins", "dd", "qs", "vs", "services", "dates", "ths", "els", "gd", "ded", "vals", "points", "ils", " ps", "ipes", "rs", "models"], "format": ["struct", "class", "function", "at", "act", "string", "host", "table", "spec", "version", "language", "atter", "path", "fd", "api", "magic", "letter", "unit", "handler", "fn", "frame", "nat", "scale", "tag", "part", "layout", "Format", "model", "prefix", "ant", "url", "config", "f", "sche", "filename", "record", "fp", "filter", "data", "type", "feat", "style", "plugin", "t", "parser", "pattern", "source", "form", "name", "file", "template"], "hasPixelData": ["showsPixeldata", "haspixeldata", "showsPixelDATA", "hasByteDATA", "hasPixeldata", "hasPixelDATA", "showsPixelStyle", " hasPixelSize", " hasPixeldata", "showsBytedata", "showsByteStyle", "haspixelSize", "showsPixelData", "hasByteData", "hasByteStyle", "hasBytedata", "haspixelData", "hasPixelStyle", "showsByteData", "hasPicturedata", "hasByteSize", "hasPictureSize", "hasPixelSize", "hasPictureData", "showsByteDATA"], "inflate": ["inFlated", "inadequating", "infloace", "insflode", "InFlate", "infolATE", "inadequode", "insvenATE", "inFlate", "insflating", "InFlace", "insflATE", "inffated", "inflation", "invenate", "inflace", "infolode", "inFlation", "infloate", "insvenate", "invenATE", "infloated", "inffation", "invenating", "InFlated", "insvenating", "insflate", "inflATE", "inflating", "Inflace", "infface", "inFlace", "infolate", "Inflated", "inffate", "Inflate", "inadequate", "insvenode", "inflated", "infolating", "infloation", "inflode", "invenode", "Inflation", "InFlation", "inadequATE"], "pxlen": ["fxdata", "pnglen", "pxlin", "mxln", "axlon", "pxcount", "fxln", "pglen", "txln", "pcln", "ppl", "pxlon", "txlin", "camlen", "fxl", "pgden", "pngsize", "axlin", "mxlen", "camln", "fxden", "xplength", "ppLen", "mxdata", "pxLen", "pxdata", "pclen", "pclin", "axln", "pxln", "axlen", "txlen", "pngcount", "campos", "mxpos", "fxLen", "xpsize", "xpcount", "pxsize", "pgl", "pxpos", "ppden", "pgLen", "fxpos", "pxlength", "fxlen", "mxlength", "mxcount", "xplen", "mxsize", "camdata", "pxden", "pclon", "pplen", "pxl", "pnglength", "txlon"], "out": ["group", "line", "again", "cache", "step", "inter", "state", "Out", "copy", "log", "io", "outs", "list", "co", "post", "sys", "pad", "user", "conn", "store", "err", "up", "server", "query", "work", "cli", "session", "dump", "lib", "v", "page", "output", "gen", "error", "obj", "OUT", "point", "parent", "lock", "re"]}}
{"id1": "884867", "id2": "18211588", "code1": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"zipname": ["zName", "zroot", "lockno", "fileName", " zipsize", "clipname", " ziproot", " zipfile", "projectcache", "zipno", "projectno", "zipsize", "filefile", "zipcache", "clipName", "lockname", "projectName", "gzname", "fileroot", "gzsize", "zsize", "lockcache", "projectname", "gzfile", " zipName", "lockName", "clipno", "ziproot", "filename", "clipcache", "zipName", "zfile", "gzName", "zipfile", "zname"], "zipout": ["folderout", " zipgen", "zipserver", "clipin", "zserver", " zipserver", "copout", "zin", " zipfile", "zenout", "clipout", "zipcache", " zipoutput", "foldercontainer", "zcache", "zipoutput", "copin", "clipoutput", "zenin", "zout", "folderin", "copname", "zipgen", "copfile", "zcontainer", " zipin", " zipcache", " zipcontainer", "foldername", "zoutput", "clipcache", "zenserver", "zipcontainer", "zipin", "zfile", "zengen", "zgen", "zipfile", "zname"], "out": ["group", "plus", "window", "line", "again", "project", "n", "cache", "word", "o", "ex", "exp", "bin", "Out", "copy", "msg", "log", "outer", "io", "outs", "co", "list", "post", "key", "doc", "user", "conn", "print", "p", "err", "up", "w", "base", "prefix", "exec", "query", "url", "f", "pool", "code", "dump", "pre", "image", "lib", "writer", "dot", "page", "file", "diff", "output", "error", "gen", "term", "obj", "OUT", "point", "b", "write", "flush", "inc", "raw", "parent", "lock", "client", "name"], "buffer": ["resource", "row", "seed", "position", "cache", "channel", "uffer", "limit", "padding", "comment", "input", "layer", "shape", "wave", "feed", "sequence", "buf", "queue", "slice", "number", "header", "batch", "base", "url", "size", "read", "array", "Buffer", "iter", "image", "bytes", "transfer", "result", "border", "bb", "reader", "data", "null", "b", "stack", "buff", "offset", "source", "binary", "block", "file", "reference"], "in": ["In", "pass", "again", "serv", "ini", "c", "IN", "rec", "ex", "is", "inner", "din", "bin", "input", "ic", "as", "con", "pin", "ins", "conn", "inn", "err", "up", "l", "init", "win", "rin", "lin", "url", "gin", "f", "i", "nin", "image", "a", "login", "diff", "reader", "r", "b", "inc", "id", "re", "fr"], "length": ["pull", "row", "class", "section", "line", "position", "ob", "string", "join", "full", "present", "append", "view", "limit", "total", "character", "old", "core", "angle", "shape", "Length", "partial", "sequence", "feed", "key", "number", "force", "tail", "slice", "count", "loc", "build", "ph", "l", "part", "pe", "url", "component", "load", "left", "size", "index", "f", "code", "len", "ok", "range", "last", "level", "type", "ength", "point", "style", "duration", "id", "offset", "lock", "body", "width", "end"]}}
{"id1": "8069594", "id2": "8150996", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"copyFile": [" copiedfile", " copyfile", " copyFiles", "transferFile", " copyFolder", " copiedFile", "copyfile", " copiedFolder", "copyFolder", "transferFiles", "copyFiles", "transferFolder", " copiedFiles", "transferfile"], "in": ["In", "or", "again", "at", "IN", "m", "ex", "inner", "din", "bin", "input", "old", "ic", "as", "io", "this", "pin", "ins", "min", "inn", "err", "it", "up", "part", "base", "win", "exec", "url", "work", "x", "config", "index", "i", "image", "a", "login", "reader", "diff", "data", "null", "inc", "id", "source", "lock", "name", "file"], "out": ["plus", "external", "not", "at", "outside", "line", "n", "c", "again", "o", "ex", "version", "bin", "Out", "old", "about", "outer", "io", "outs", "this", "conn", "object", "user", "p", "err", "up", "base", "all", "exec", "server", "x", "name", "off", "image", "to", "plain", "writer", "ext", "v", "output", "write", "OUT", "target", "b", "null", "vert", "inc", "update", "source", "one", "file"], "inChannel": ["inputContext", "INClient", "outchannel", " inConnection", "inputChannel", "loginChannel", "inputStream", "binChan", "INStream", " inStream", "loginchannel", "InChan", "loginContext", "inchannel", "InConnection", "INConnection", "inStream", "outStream", "binClient", "INChannel", "inChan", "binChannel", "loginStream", "INChan", "inClient", "INchannel", "outChan", " inClient", "inConnection", "inputChan", "inContext", "InStream", "InChannel", " inChan", "inputConnection", "Inchannel", "outContext", "inputchannel", "binStream"], "outChannel": ["outputChannel", "innerStream", " outChan", "OutStream", "outchannel", "OutChannel", "Outchannel", "ochannel", "againStream", "inchannel", "outputStream", "innerChannel", "outputChan", "outputConnection", "inStream", "outStream", " outConnection", "inChan", "againChannel", "oStream", "againConnection", "outChan", "againChan", " outchannel", "OutChan", "inConnection", "againchannel", "outConnection", "inContext", "innerContext", "againContext", " outStream", "oChan", "outContext", "innerChan", "oChannel"]}}
{"id1": "20623709", "id2": "9413074", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    String getLocation(Class clazz) {\n        try {\n            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();\n            String location = url.toString();\n            if (location.startsWith(\"jar\")) {\n                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();\n                location = url.toString();\n            }\n            if (location.startsWith(\"file\")) {\n                java.io.File file = new java.io.File(url.getFile());\n                return file.getAbsolutePath();\n            } else {\n                return url.toString();\n            }\n        } catch (Throwable t) {\n        }\n        return Messages.getMessage(\"happyClientUnknownLocation\");\n    }\n", "label": 0, "substitutes": {"split": ["share", "run", "cmp", "join", "execute", "append", "copy", "Split", "open", "match", "add", "process", "sync", "archive", "build", "part", "init", "exec", "delete", "set", "format", "start", "transfer", "diff", "parse", "update", "sort"], "targetDirectory": ["targetFile", "targetFolder", "destDir", " targetFolder", " targetPath", "masterDatabase", "TargetDir", "TargetDirectory", "outputFile", "currentDirectory", "TargetFolder", "destFile", "targetPath", "masterDirectory", " targetFile", "currentDir", "baseDir", " targetRoot", "basePath", "baseFolder", "TargetDatabase", "outputFolder", "masterPath", "destDirectory", "TargetFile", "outputDirectory", " targetDir", "TargetPath", "baseFile", "currentRoot", "targetRoot", "currentPath", "destFolder", "targetDatabase", "outputDir", "baseDatabase", "TargetRoot", "currentFolder", "masterDir", "targetDir", "baseDirectory"], "prefix": ["folder", "timeout", "resource", "temp", "txt", "root", "username", "string", "cache", "append", "path", "fixed", "patch", "sequence", "number", "queue", "first", " suffix", "unit", "template", "base", "fix", "domain", "config", "index", "pre", "filename", "format", "resolution", "fp", "FIX", "directory", "type", "prot", "offset", "uri", "ix", "pattern", "name", "Pref", "padding"], "maxUnitBases": ["maxUnitChase", "maxUnitChasing", "maxunitAliasing", "maxUnitQuease", "maxUnitAliues", "maxunitBaches", "maxUnitEases", "maxunitBails", "maxunitAliues", "maxUnitAliasing", "maxUnitBues", "maxUnitQueasing", "maxunitBase", "maxUnitPlase", "maxUnitEaches", "maxUnitChases", "maxUnitPlaches", "maxUnitBasing", "maxunitAliails", "maxunitAliases", "maxunitBues", "maxunitBases", "maxUnitAliails", "maxUnitEase", "maxUnitBails", "maxUnitEails", "maxUnitBase", "maxunitAliase", "maxUnitAliases", "maxunitBasing", "maxUnitQueues", "maxUnitBaches", "maxUnitQueases", "maxUnitPlases", "maxUnitAliase", "maxUnitPlails", "maxUnitAliaches", "maxUnitChues", "maxunitAliaches"], "maxUnitEntries": ["maxUnitOrdry", "maxUnitEntryries", "maxUnitOrdrys", "maxUnitEntry", "maxUnitEnties", "maxUnitErry", "maxUnitErrations", "maxUnitErines", "maxLineEntries", "maxUnitCountries", "maxUnitEntrys", "maxUnitEntures", "maxUnitOrdries", "maxLineOrdines", "maxUnitIntresses", "maxUnitCountines", "maxUnitEntrations", "maxUnitCountrations", "maxLineOrdries", "maxUnitEntryrys", "maxunitEntryrys", "maxLineEntry", "maxUnitOrdrations", "maxunitEntries", "maxUnitEntryresses", "maxLineOrdrations", "maxUnitOrdines", "maxUnitAddures", "maxUnitIntrys", "maxLineEntrations", "maxunitEntrys", "maxUnitIntries", "maxunitEntresses", "maxUnitInties", "maxunitEntryresses", "maxUnitAddresses", "maxUnitCountry", "maxUnitEntines", "maxUnitErries", "maxLineOrdry", "maxUnitAddry", "maxUnitAddries", "maxUnitEntryures", "maxunitEnties", "maxunitEntryries", "maxUnitOrdresses", "maxLineEntines", "maxUnitEntresses", "maxUnitEntryies", "maxUnitOrdies", "maxUnitEntryry", "maxunitEntryies"], "fis": ["Fiss", " fisc", "forIs", "vIs", "foriss", "fisc", " fIs", "fIs", " fiss", "fris", "forris", "vis", "forisc", "foris", " fris", "fisa", " fai", "Fis", "forisa", "fai", "forai", "vai", "Fris", "fiss", "visa", "Fisc", " fisa"], "fci": ["vco", "fii", "vci", " foci", "efcos", "Fci", "vcos", "efci", "Fai", "Foci", "hcos", "dci", "efco", "hai", "fcos", "Fii", "dco", "dii", "hci", "Fis", " fai", "Fco", "bai", "fai", "foci", "efai", "hco", "bis", "vai", "doci", "bco", " fii", "bci"], "fos": ["infoes", "fsos", "ifos", "fo", "ifo", "fso", "fios", " fcos", "infos", "fscos", "ifios", "infis", " fios", " fo", "tos", "foes", "fcos", "infoss", "Fis", "ifcos", "fsios", "Fos", "Foss", "toes", "Foes", "tis", "foss", "toss"], "fco": ["fileico", "Fico", "fbo", "hgo", "fileco", "Fci", "lcos", "lco", "lci", " fcos", "Fbo", " fico", "fico", "fgo", "dcos", "hcos", "dro", "dci", "filebo", " fro", "fcos", "dco", "hci", "lgo", "lro", " fgo", "Fco", "hco", "fro", "fileci", " fbo"], "buffer": ["resource", "timeout", "entry", "window", "position", "channel", "cache", "zero", "capacity", "context", "request", "view", "uffer", "expression", "comment", "bin", "pause", "response", "copy", "input", "layer", "texture", "feed", "buf", "queue", "pad", "length", "header", "translation", "batch", "document", "base", "device", "rate", "scale", "server", "size", "loader", "bc", "Buffer", "iter", "bar", "read", "callback", "image", "writer", "border", "transfer", "memory", "result", "reader", "counter", "data", "null", "buff", "flush", "message", "offset", "binary", "info", "block", "source", "reference"], "currentBasesCount": ["currentBaseCount", "currentBasesCounter", "currentChasecount", "currentBasesNum", "currentBaseCounter", "currentChaseCount", "currentChasesNum", "currentBatchesNum", "currentBasingNum", "currentBasingCount", "currentBatchescount", "currentChasescount", "currentBasingcount", "currentChaseNum", "currentBasescount", "currentBatchesCounter", "currentBasingCounter", "currentChasesCounter", "currentBasecount", "currentBatchesCount", "currentBaseNum", "currentChasesCount", "currentChaseCounter"], "currentEntriesCount": ["currentEntriesOffset", "currentEntrasOffset", "currentEntrasCount", "currentEntursLimit", "currentEntriesSize", "currentAdduresSize", "currentAddriesLimit", "currentEntrasSize", "currentEnturesOffset", "currentAddriesOffset", "currentEnturesSize", "currentEntriesLimit", "currentEntrasLimit", "currentAdduresCount", "currentEntursOffset", "currentAdduresOffset", "currentAddriesCount", "currentEntursCount", "currentEnturesCount", "currentAddriesSize", "currentAdduresLimit", "currentEnturesLimit", "currentEntursSize"], "targetCount": ["targetSize", "patternCount", "argetcount", "patterncount", "TargetSize", "TargetSum", "patternSize", "argetSize", "patternSum", "targetcount", "targetSum", "argetSum", "argetCount", "TargetCount", "Targetcount"], "fastaChannel": ["fastasContext", "fastanChannel", "fastanContext", " fastaColumn", "fastasBuffer", "fastAColumn", "fastaColumn", "fastaContext", "fastaContainer", " fastAContext", " fastAContainer", " fastaContext", " fastaContainer", "fastABuffer", "fastasChannel", " fastABuffer", " fastAColumn", "fastanContainer", "fastAContainer", "fastasConnection", "fastAConnection", "fastasColumn", "fastasContainer", "fastaqChannel", "fastaqBuffer", "fastAChannel", " fastAConnection", "fastaConnection", " fastaConnection", " fastAChannel", "fastAContext", "fastaqColumn", "fastanBuffer", "fastaqConnection"], "totalSeqCount": ["totalSeQcount", "totalSeuxcount", "totalSeQNum", "totalSeQCounter", "totalSeQCount", "totalQueQcount", "totalSeqscount", "totalQueQCounter", "totalQueqCount", "totalQueqcount", "totalQueqNum", "totalQueqCounter", "totalSeqcount", "totalSeuxCount", "totalSeqsCounter", "totalSeuxCounter", "totalSeuxNum", "totalSeqNum", "totalSeqsNum", "totalSeqsCount", "totalSeqCounter", "totalQueQCount", "totalQueQNum"], "totalResiduesCount": ["totalResqueuresCount", "totalResiduationNum", "totalResidurescount", "totalResiduingNum", "totalResqueuesNum", "totalResiduescount", "totalResiduesSize", "totalResiduresCount", "totalResiduationcount", "totalResqueuesSize", "totalResqueuresNum", "totalResiduingSize", "totalResqueurescount", "totalResiduationCount", "totalResiduingCount", "totalResiduresSize", "totalResqueuesCount", "totalResqueuresSize", "totalResiduresNum", "totalResiduationSize", "totalResqueuescount", "totalResiduesNum", "totalResiduingcount"], "prevTime": ["prevSize", "PrevFile", "prevValue", " prevValue", " prevFile", "prevFile", "PrevValue", "commitSize", "PrevSize", "commitFile", "commitTime", "PrevTime", " prevSize", "commitValue"], "fastaFileSize": ["fastasFileLength", "fastaBufferSize", "fastaFilesSize", "fastAFileAddress", "fastasFileAddress", "fastasFileName", "fastaHeaderSize", "fastasHeaderLength", "fastaFileName", "fastaBlockSize", "fastaLineLength", "fastaFilesAddress", "fastaBlockLength", "fastaLineCount", "fastaHeaderAddress", "fastaFileCount", "fastaLineAddress", "fastaBlockAddress", "fastaBlockCount", "fastAFileCount", "fastaHeaderLength", "fastasHeaderSize", "fastaPageSize", "fastaBufferAddress", "fastABufferAddress", "fastaFileLength", "fastasFileSize", "fastaFileAddress", "fastaHeaderName", "fastaPageLength", "fastaFilesName", "fastABufferSize", "fastasHeaderName", "fastaLineSize", "fastaFilesLength", "fastABufferCount", "fastaBufferLength", "fastaPageAddress", "fastAFileLength", "fastABufferLength", "fastaBufferCount", "fastAFileSize", "fastasHeaderAddress", "fastaPageName"], "fastaFileReadOffset": ["fastaFileLoadLength", "fastaFileLengthOff", "fastaFilesReadOffset", "fastaDirectoryReadOff", "fastaFilesReadLength", "fastaFileLoadoffset", "fastaFilesWriteOffset", "fastaBufferReadLength", "fastaFileReadAmount", "fastaFilesReadOff", "fastaFileStartOffset", "fastaFileStartOff", "fastaFilereadLength", "fastaFileRunoffset", "fastaDirectoryWriteOffset", "fastaDirectoryWriteEntry", "fastaFileLengthAmount", "fastaFileStartEntry", "fastaFileWriteEntry", "fastaDirectoryWriteOff", "fastaFileRunOffset", "fastaDirectoryReadOffset", "fastaFilesWriteoffset", "fastaFilereadOff", "fastaFileReadoffset", "fastaBufferReadAmount", "fastaFileRunEntry", "fastaBufferWriteOffset", "fastaFileReadEntry", "fastaFileWriteLength", "fastaBufferReadoffset", "fastaDirectoryReadEntry", "fastaFilereadoffset", "fastaFileWriteOff", "fastaFileLengthOffset", "fastaFileWriteAmount", "fastaFileReadLength", "fastaFileRunOff", "fastaFilesReadoffset", "fastaFilesWriteOff", "fastaDirectoryWriteoffset", "fastaFilesWriteLength", "fastaBufferWriteLength", "fastaBufferWriteAmount", "fastaFileWriteOffset", "fastaFileLengthoffset", "fastaFileStartoffset", "fastaBufferWriteoffset", "fastaFileLoadAmount", "fastaFilereadOffset", "fastaBufferReadOffset", "fastaDirectoryReadoffset", "fastaFileLengthLength", "fastaFileReadOff", "fastaFileWriteoffset", "fastaFileLoadOffset"], "partitionStartOffset": ["partitionStopOrder", "partitionStopOffset", "partitionStopOff", "partitionsStartOrder", "partitionEndOrder", "partitionBufferOffset", "partitionStartOrder", "partitionEndOff", "partitionsStartRange", "partitionEndRange", "partitionStartRange", "partitionBufferOff", "partitionStopRange", "partitionsStartOffset", "partitionsEndOrder", "partitionsEndOffset", "partitionsEndOff", "partitionsEndRange", "partitionBufferOrder", "partitionStartOff", "partitionsStartOff", "partitionBufferRange"], "bufferSize": ["queueSize", "BufferSize", " bufferType", "processC", "queueCount", "bufferType", "bufferC", "bufferSIZE", " bufferSIZE", "BufferCount", "BufferSIZE", "processSize", "processSIZE", "BufferC", "bufferCount", " bufferC", " bufferCount", "processType", "BufferType"], "fastaBuffer": ["fastaPtr", "FastaBuffer", "fastaaBuffer", "fastanChannel", "fastasStream", "FastaPtr", "fastAQueue", "fastasBuffer", " fastAQueue", " fastAFile", "fastaContainer", "fastanBuff", " fastaBuff", "fastAPtr", "FastasBuffer", " fastaContainer", "fastasFile", " fastasBuffer", "FastasBuff", "fastanPtr", " fastABuff", " fastasContainer", "fastABuff", "fastaceBuff", "fastasQueue", "fastABuffer", "fastasChannel", "fastanStream", "fastAFile", "FastaBuff", " fastaQueue", "fastaFile", "fastasBuff", "FastasStream", " fastasFile", " fastABuffer", "fastanContainer", "fastasPtr", " fastaFile", "fastanQueue", "fastanFile", "FastaChannel", "fastAContainer", "fastaBuff", "FastasPtr", "fastaaPtr", "fastaQueue", "fastaceChannel", "fastasContainer", "fastaceBuffer", "fastaaBuff", "FastasChannel", "FastaStream", "fastaStream", "fastaaStream", "fastAChannel", " fastAChannel", "fastacePtr", "fastanBuffer", " fastasChannel"], "fastaReadState": ["fastasReaderMode", "fastaFileState", "fastaFileMode", "fastaReaderState", "fastasReaderstate", "fastaReadingstate", "fastasReaderType", "fastasReadMode", "fastaReaderstate", "fastaReadMode", "fastaReadingMode", "fastaReaderType", "fastaFilestate", "fastaReadingState", "fastaReadstate", "fastaFileType", "fastaReadType", "fastasReadType", "fastaReaderMode", "fastasReaderState", "fastasReadstate", "fastaReadingType", "fastasReadState"], "nBytes": [" nFrames", "NParts", "obytes", "nByte", "lenFrames", "NByte", "pBytes", "pParts", "pbytes", "lenFiles", " nByte", "oBytes", " nParts", "Nbytes", "oFiles", "lenbytes", "nParts", "pByte", "numFrames", "lenBytes", "numBytes", "oParts", "NFiles", "numbytes", "nFiles", " nbytes", "nFrames", "NBytes", " nFiles", "numFiles", "nbytes"]}}
{"id1": "17583193", "id2": "7458833", "code1": "    public boolean populateRecord(int[] attrIDs) throws IOException {\n        if (device == null) {\n            throw new RuntimeException(\"This is local device service record\");\n        }\n        if (attrIDs == null) {\n            throw new NullPointerException(\"attrIDs is null\");\n        }\n        if (attrIDs.length == 0) {\n            throw new IllegalArgumentException();\n        }\n        for (int i = 0; i < attrIDs.length; i++) {\n            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {\n                throw new IllegalArgumentException();\n            }\n        }\n        int[] sortIDs = new int[attrIDs.length];\n        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);\n        for (int i = 0; i < sortIDs.length; i++) {\n            for (int j = 0; j < sortIDs.length - i - 1; j++) {\n                if (sortIDs[j] > sortIDs[j + 1]) {\n                    int temp = sortIDs[j];\n                    sortIDs[j] = sortIDs[j + 1];\n                    sortIDs[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < sortIDs.length - 1; i++) {\n            if (sortIDs[i] == sortIDs[i + 1]) {\n                throw new IllegalArgumentException();\n            }\n            DebugLog.debug0x(\"query for \", sortIDs[i]);\n        }\n        DebugLog.debug0x(\"query for \", sortIDs[sortIDs.length - 1]);\n        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"populateRecord": ["populateModel", "popractAll", "populatesAll", "populateAll", "popractInstance", "populateInstance", "poputeModel", "populatesInstance", "extulateModel", "extulateAll", "extractRecord", "popractRecord", "extulateRecord", "poputeRecord", "extractAll", "popractModel", "poputeAll", "extulateInstance", "poputeInstance", "extractModel", "populatesRecord", "extractInstance", "populatesModel"], "attrIDs": ["attrids", "attrIDS", "attID", "addrID", "attIDES", "attIDS", "sortIDS", "addrIDS", "addrENTS", "addrIDs", "attributeIDS", "attributeids", "attIDs", "attrENTS", "tagIDES", "sortIDES", "attrIDES", "attributeID", "tagIDs", "attENTS", "attrID", "attributeENTS", "sortids", "sortID", "attributeIDES", "tagID", "tagIDS", "attids", "attributeIDs"], "i": ["ini", "ii", "g", "m", "ci", "z", "bi", "my", "p", "l", "phi", "eni", "start", "gi", "v", "ai", "yi", "uri", "ij", "iu", "c", "o", "y", "d", "io", "slice", "ji", "length", "ami", "init", "ki", "fi", "x", "ori", "ni", "ti", "mi", "ik", "multi", "n", "pi", "di", "ie", "I", "left", "index", "f", "cli", "oi", "li", "h", "xi", "id", "si", "qi", "ip", "u", "k", "is", "inner", "api", "key", "ui", "in", "ri", "it", "e", "ind", "a", "b", "info", "ix"], "sortIDs": ["filterID", "attrIDS", "useIDES", " sortIDES", "ortids", "searchids", "orderids", "sortIDS", "allIDS", "allIDs", "allIDES", "ortID", "ortIDs", " sortUID", "syncIDES", " sortID", "ortIDS", "altID", "altIDS", "sortFiles", "searchID", "ortUID", "orderIDES", "altIDs", "SortUID", "filterUID", "syncIDS", "attrFiles", "filterIDs", " sortids", "updateIDs", "SortIDS", "updateID", " sortFiles", "sortIDES", "SortIDES", "ortIDES", "searchIDS", "orderIDs", " sortIDS", "useID", "useIDS", "SortID", "SortIDs", "syncIDs", "attrID", " sortADS", "orderFiles", "sortids", "updateIDS", "sortID", "useIDs", "attrUID", "searchIDs", "updateFiles", "sortUID", "orderIDS", "updateIDES", "filterIDS", "sortADS", "searchIDES", "altIDES", "allID", "attrADS", "orderADS", "syncID", "orderID"], "j": ["jet", "fr", "je", "js", "oj", "qi", "section", "u", "k", "ii", "n", "pr", "dj", "y", "o", "d", "ij", "di", "J", "z", "jo", "key", "ji", "ui", "jj", "ie", "p", "br", "uj", "l", "part", "w", "adj", "left", "x", "f", "e", "li", "q", "ja", "h", "v", "next", "last", "bj", "jp", "obj", "b", "xi", "job", "jc", "ix", "aj", "jl"], "temp": ["wrap", "ex", " temporary", "partial", "empty", "key", "modified", "tr", " unused", " test", "ed", " fake", "orig", " Temp", "tmp", "max", "get", "tem", "ash", "non", "fake", "flat", "iter", "holder", " original", " orig", " tmp", "emp", "used", " result", "test", "Temp", "stable", "porary", "alt", "pack", " modified", "needed", " dummy", "tc"]}}
{"id1": "7396682", "id2": "3184073", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["share", "cop", "paste", "cat", "rm", "path", "Copy", "move", "sync", "download", "opy", "archive", "create", "replace", "drop", "cp", "clone", "url", "delete", "load", "get", "link", "dump", " cp", "split", "transfer", "remote", "change", "save", "clip", "write", "update", "source", "file"], "srcFS": ["sourceFB", "srcTS", "rcFC", "sourceTS", "srcFP", "rcFP", "sbfs", "rcfs", "rcFs", "rubyFs", "sbFS", "srcFs", "sourceFS", "rcFS", " srcFs", "sbFP", "srcFB", " srcFP", " srcTS", "sourceFC", "sourcefs", "rcTS", "rubyfs", "srcfs", "sbFs", "rubyFB", " srcfs", "rubyFS", "sourceFs", " srcFB", " srcFC", "srcFC"], "src": ["rss", "resource", "share", "sth", "bh", "username", "stream", "cmp", "project", "SourceFile", "rest", "href", "host", "Source", "view", "spec", "http", "dist", "ource", "path", "inst", "ctx", "sc", "slice", "sr", "attr", "dest", "sys", "sync", "loc", "sup", "gb", "rc", "upload", "url", "sn", "config", "sec", "name", "sb", "sl", "code", "filename", "sin", "inf", "fp", "cb", "RC", "ssl", "st", "img", "secure", "supp", "file", "obj", "feat", "target", "req", "sub", "sit", "source", "uri", "sel", "rb", "core"], "dst": ["cddest", "ddest", "dsc", "idsts", "iddest", "idrest", "cdrc", "Drest", "cdst", "ddST", "ldest", " dsts", "drc", "lsts", " drest", " dsc", "pdst", "dST", "pdsc", "Dst", "pdrc", " dST", "ddrc", "ddsc", "lst", "dsts", "pdST", "Ddest", "ddst", "lST", "cdST", " drc", " ddest", "drest", "Drc", "Dsts", "idst", "DST"], "deleteSource": ["destroySource", "delType", "destroyMode", "destroyOrigin", "delSource", "DeleteTarget", "copySource", " deleteTarget", "copyMode", " deleteType", "copyTarget", "deleteSources", "deleteType", "deleteOrigin", "delMode", "delTarget", "destroyTarget", "DeleteOrigin", "DeleteSource", " deleteMode", "deleteMode", "DeleteMode", "deleteTarget", "copyOrigin", "delSources", "DeleteType", " deleteOrigin", "delOrigin", " deleteSources", "DeleteSources"], "conf": ["ref", "ch", "cor", "cmp", "Conf", "cm", "c", "cfg", "cache", "ca", "context", "comment", " Conf", "conv", "raf", "ci", "ctx", "con", "sc", "param", "cf", "conn", "def", "bug", "cc", "cl", "cr", "cd", "cn", "fi", "config", "cs", "bc", "f", "cli", "confirmed", "uc", "cb", "prop", "info", "const", "client", "lc"], "contents": ["CONTENTS", "contContents", "Contents", "locContents", "Contacts", "latacts", "locains", "latils", "contacts", "Containers", "CONTainers", "CONTains", "contentients", "contENTS", "CONTent", "stENTS", "ContContents", "stacts", "contils", "content", "CONTils", " contENTS", "Contains", " content", "latent", "latents", "CONTacts", "CONTContents", "Content", "Contils", " contients", "contentENTS", "contences", "ContENTS", "locents", "locainers", "CONTents", "contentent", "contients", "stences", "contentents", "Contences", "CONTients", "contains", "CONTences", "stents", "containers"], "i": ["hi", "iu", "si", "qi", "ip", "u", "multi", "n", "ii", "c", "m", "pi", "k", "o", "y", "ini", "d", "inner", "abi", "ci", "di", "io", "key", "slice", "ji", "ui", "ri", "count", "ie", "p", "phi", "init", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "ori", "start", "h", "v", "gi", "ti", "diff", "type", "ai", "data", "b", "xi", "id", "iv", "uri", "ix", "mu", "uni", "name"], "in": ["In", "inas", "pass", "serv", "ini", "c", "IN", "is", "din", "bin", "input", "as", "con", "ins", "doc", "ac", "min", "conn", "inn", "kin", "l", "connection", "part", "win", "rin", "out", "gin", "thin", "f", "nin", "a", "socket", "sin", "login", "data", "ax", "r", "b", "inc", "id", "source", "file"]}}
{"id1": "1180878", "id2": "22993368", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchUrldata", "fetchUrlDATA", "fetchHTTPDATA", "fetchHTTPdata", "fetchUrlData", "frieveURLdata", "frieveUrlData", "frieveUrlDATA", "fetchURLdata", "fetchJSONData", "fetchURLDATA", "fetchJSONDATA", "fetchHTTPData", "fetchJSONdata", "frieveURLData", "frieveUrldata", "frieveURLDATA"], "url": ["resource", "username", "string", "host", "href", "view", "http", "xml", "www", "URL", "path", "ur", "api", "feed", "gl", "Url", "download", "user", "address", "loc", "l", "connection", "base", "ls", "server", "location", "sl", "f", "filename", "image", "el", "page", "html", "ssl", "data", "fl", "uri", "source", "text", "src", "name", "file"], "proxyHost": ["ProxyDomain", "Proxyhost", "ProxyServer", " proxyAddress", "cachehost", "proxyHead", "ProxyAddress", "baseHead", "baseHost", " proxyPath", "serverHost", "proxyAddress", "proxyDomain", "ProxyPort", "serverServer", "serverPath", "proxyServer", "baseDomain", "remoteHead", "serverAddress", "cacheHost", "ProxyHead", "ProxyHost", "remoteHost", "baseAddress", " proxyhost", "cachePort", "remoteDomain", "remoteAddress", "cacheAddress", " proxyServer", "proxyPath", "ProxyPath", "proxyhost"], "proxyPort": [" proxyport", "ProxyServer", " proxyAddress", "ProxyAddress", "proxyport", "proxyAddress", "Proxyport", "httpServer", "ProxyPort", "httpPort", "httpHost", "proxyServer", "cacheHost", "ProxyHost", "cachePort", "cacheport", "cacheAddress", "httpAddress", " proxyServer"], "con": ["ch", "ctrl", "pc", "ca", "http", "ci", "can", "out", "fac", "don", "pub", "socket", "gen", "ai", "fl", "ec", "ver", "fa", "an", "c", "cache", "rec", "cone", "fun", "xc", "pin", "cc", "cl", "connection", "mc", "win", "cn", "cp", "ocon", "cur", "x", "per", "pre", "login", "en", "conf", "sub", "connect", "re", "cm", "n", "act", "go", "conv", "open", "co", "sync", "cf", "ac", "min", "cr", "part", "rc", "ls", "f", "Con", "uc", "fan", "com", "run", "fc", "cas", "cons", "func", "canon", "ran", "conn", "on", "exec", "syn", "bc", "CON", "close", "remote", "change", "inc", "pen", "un", "common"], "is": ["ib", "il", "ics", "or", "js", "us", "si", "isa", "ios", "im", "serv", "bs", "isl", "act", "ir", "was", "state", "iris", "oss", "has", "as", "ci", "api", "can", "ais", "os", "IS", "abs", "cms", "in", "ri", "conn", "are", "does", "ie", "it", "p", "fs", "isin", "s", "Is", "out", "vs", "iss", "iso", "ar", "get", "sp", "ops", "cos", "its", "ws", "cs", "isi", "isc", "i", "ori", "bis", "mis", "lis", "ai", "isu", "ps", "id", "es", "info", "ris"], "u": ["iu", "us", "uci", "c", "ru", "m", "o", "http", "U", "ur", "io", "api", "os", "yu", "ue", "ui", "uv", "cu", "user", "conn", "p", "up", "l", "ut", "f", "fu", "su", "i", "q", "ul", "h", "uc", "hu", "file", "v", "ou", "tu", "b", "uri", "nu", "client", "lu", "un"], "proxy": ["resource", "timeout", "fe", "pc", "cop", "plus", "shadow", "ip", "zip", "c", "cache", "host", "http", "roxy", "pse", "copy", "api", "phone", "force", "pin", "xy", "address", " proxies", "p", "l", "connection", "pe", "pa", "port", "server", "Proxy", "clone", "x", "config", "bean", "pool", "f", "wrapper", " Proxy", "lib", "socket", "remote", "ssl", "type", "web", "XY", "uri", "prot", "client", "create"], "baos": ["abis", "caOS", "aas", "caos", "boas", "paOS", "abos", "bao", "Baros", "bolos", "bais", "baas", "balos", "paos", "baOs", "BAOs", "alos", "pais", "aos", "Bais", "BAis", "calos", "boos", "haOS", "Baos", "baOS", "baros", "caas", "hais", "aOS", "BAos", "haos", "hao", "BAOS", "BAros", "abros", "BaOs", "pao", "boOS", "abOs", "BAo"]}}
{"id1": "255765", "id2": "2521141", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"f": ["fa", "df", "folder", "fe", "ref", "fr", "F", "fc", "function", "of", "g", "c", "n", "m", "sf", "d", "fo", "fun", "fx", "self", "path", "fd", "io", "feed", "this", "cf", "fold", "fn", "p", "fs", "l", "ff", "tf", "s", "w", "j", "x", "fi", "flat", "e", "fm", "filename", "a", "h", "fp", "inf", "v", "fen", "r", "b", "bf", "t", "lf", "form", "name", "file", "rf"], "in": ["fe", "again", "serv", "g", "ini", "m", "cin", "ex", "with", "con", "inn", "p", "l", "isin", "w", "rin", "nin", "image", "socket", "v", "ssl", "gen", "t", "fa", "In", "or", "c", "rec", "d", "str", "bin", "ic", "pin", "connection", "init", "win", "login", "data", "n", "IN", "din", "ins", "ac", "min", "part", "lin", "get", "thin", "reader", "diff", "r", "lock", "pass", "token", "is", "inner", "input", "err", "it", "up", "exec", "gin", "config", "session", "a", "vin", "b", "inc", "source"], "cbuf": ["fbuff", "ebuf", "cfur", "zbuu", "rbull", "cbur", "cfuf", "cbuff", "bbuff", "bcuf", "rbuc", "cbutf", "fbbuf", "cfuff", "fbuc", "bcull", "fbuf", "bbull", "cbuc", "cburs", "cbault", "cfuc", "cbbuf", "cfbuf", "bcul", "rbuu", "rbul", "buf", "cbul", "bburs", "CBuc", "CBuff", "cbull", "bcuc", "CBul", "CBuf", "dbuf", "rbutf", "zbuf", "cbuu", "bcur", "bault", "rburs", "rbux", "ebuff", "ebutf", "zbutf", "rbuf", "zbuff", "cbux", "rbault", "rbbuf", "bbuf", "bcux", "ebuu", "dbuc", "dbur", "bux", "buff", "bcault", "dbuff", "rbuff", "bcurs", "bcuff"], "read": ["each", " Read", "use", "draw", "full", "g", "want", "call", "view", "log", "ak", "count", "build", "valid", "oct", "w", "orig", "ink", "q", "start", "check", "socket", "val", "error", "write", "sleep", "text", "y", "select", "d", "report", "lex", "io", " reading", "feed", "add", "only", "hex", "length", "repeat", "play", "pe", "find", "x", "wait", "iter", "allow", "used", "record", "last", "data", "en", "stream", "connect", "cel", "re", "end", "reads", "send", "know", "old", "open", "sync", "skip", "num", "ed", "seek", "ing", "er", "print", "insert", "rc", "get", "load", "work", "size", "index", "ok", "level", "reader", "type", "parse", "raw", "r", "id", "loop", "name", "ize", "pass", "run", "k", "readable", " write", "reading", "fill", "input", "READ", "key", "bit", " READ", "child", "ack", "Read", "it", "config", "ind", "bind", "un", "close", "ride", "change", "se", "put", "inc", "buffer", "update", "create"], "totRead": ["totoRead", "totaRead", " totBuild", "TottRead", "tottLength", "TottLoad", "dotReader", "towWrite", " totWrite", "totClose", "tetRead", "dottWrite", "totoReading", "dotUse", "tobyUse", "tazonClose", "totLoad", " totalBuild", "TottWrite", "tottedRead", "tochWrite", "toyRead", "tcotRead", "TotaDraw", "tottDraw", "ntottReader", "toyLoad", "totiRead", "totalLink", "tottAccept", "nottWrite", "tottBuild", "dottReader", "tcotClose", "tollWrite", "totReader", "TottConnect", "totaBuild", "tochLoad", "totaDraw", "totoSearch", "ntottLoad", "tntLoad", "TotReading", "totConnect", "tochRead", "totReading", "totiLink", "intotRead", "tobyRead", "intotLoad", "TottGet", "tollReading", " totLink", "nottAccept", "tetLoad", "totSearch", "tollRead", "totingFollow", "tottedGet", "tottFollow", "totoWrite", "TottReader", "tobyLoad", "TottReading", "totaLoad", "tntReader", "tobyFind", "intottLoad", "totBuild", "tetWrite", "TotGet", "TotLoad", "toyWrite", "dottLoad", "totaWrite", "totalWrite", "totalBuild", "totoLength", "totWrite", "notRead", "tottReading", "tottSearch", "octotLength", "totingSearch", "totingGet", "towReading", "TotConnect", "totingRead", "intottClose", "tcotBuild", "TotaRead", "dotReading", "TotSearch", "totLength", "tottedFollow", "totaReading", "tottWrite", "notAccept", "totiWrite", "dottFind", "tottRead", "totUse", "totoLoad", "totaLink", "totoConnect", "tochReader", "tatRead", "intottBuild", "TotWrite", "tetReading", "tottLoad", "totaReader", "totoFind", "tazonLoad", "TotaWrite", "TotRead", "octotoWrite", "tottFind", "totiBuild", "octotReading", "tottClose", "dotLoad", "TotaLoad", "towLength", "tatReader", "ntotWrite", "dottRead", "ntotReader", "totGet", "octotoRead", "towAccept", "octotWrite", "toyDraw", "TotFollow", "tntRead", "tatLoad", "tottGet", "dotRead", "totFind", "totingWrite", "tottReader", "dotWrite", "TottSearch", "totingConnect", "nottRead", "totAccept", "intottRead", "TotDraw", "ntottWrite", "towLoad", "tottUse", "ntotRead", "tottedWrite", "TotReader", "dottUse", "octotoReading", "totDraw", "towRead", "totalRead", " totalRead", "intotClose", "intotBuild", "tazonBuild", "ntottRead", "dotFind", "tatWrite", "dottReading", "tntWrite", "totLink", "totalLoad", "TottFollow", "totoUse", "octotoLength", "octotRead", "tcotLoad", " totalLink", "tazonRead", "notLoad", "ntotLoad", "totalAccept", "tollLoad", "notWrite", " totalWrite", "totFollow", "tottConnect", "nottLoad"], "out": ["In", "plus", "again", "n", "c", "g", "o", "ex", "exp", "d", "bin", "Out", "outer", "io", "outs", "sync", "ac", "conn", "fn", "p", "err", "up", "l", "part", "w", "s", "net", "init", "connection", "exec", "x", "off", "a", "h", "writer", "socket", "v", "ext", "output", "obj", "OUT", "r", "b", "t", "inc", "conf", "parent", "client", "file"], "i": ["hi", "ini", "ii", "g", "m", "current", "ci", "z", "bi", "my", "p", "l", "phi", "eni", "q", "start", "gi", "v", "ai", "yi", "uri", "iu", "c", "y", "o", "d", "ic", "io", "slice", "ji", "length", "init", "fi", "x", "ori", "ni", "ti", "data", "mi", "ik", "one", "chi", "multi", "pi", "abi", "di", "ei", "ie", "j", "I", "index", "oi", "li", "h", "r", "zi", "xi", "id", "name", "si", "qi", "ip", "u", "k", "ix", "is", "input", "api", "key", "ui", "ri", "it", "e", "ind", "b", "info", "buffer", "source", "me"]}}
{"id1": "22368133", "id2": "2910383", "code1": "    public static void testMapSource(MapSource mapSource, EastNorthCoordinate coordinate) {\n        try {\n            System.out.println(\"Testing \" + mapSource.toString());\n            int zoom = mapSource.getMinZoom() + ((mapSource.getMaxZoom() - mapSource.getMinZoom()) / 2);\n            MapSpace mapSpace = mapSource.getMapSpace();\n            int tilex = mapSpace.cLonToX(coordinate.lon, zoom) / mapSpace.getTileSize();\n            int tiley = mapSpace.cLatToY(coordinate.lat, zoom) / mapSpace.getTileSize();\n            url = new URL(mapSource.getTileUrl(zoom, tilex, tiley));\n            System.out.println(\"Sample url: \" + url);\n            c = (HttpURLConnection) url.openConnection();\n            System.out.println(\"Connecting...\");\n            c.connect();\n            System.out.println(\"Connection established - response HTTP \" + c.getResponseCode());\n            if (c.getResponseCode() != 200) return;\n            String contentType = c.getContentType();\n            System.out.print(\"Image format          : \");\n            if (\"image/png\".equals(contentType)) System.out.println(\"png\"); else if (\"image/jpeg\".equals(contentType)) System.out.println(\"jpg\"); else System.out.println(\"unknown\");\n            String eTag = c.getHeaderField(\"ETag\");\n            boolean eTagSupported = (eTag != null);\n            if (eTagSupported) {\n                System.out.println(\"eTag                  : \" + eTag);\n                testIfNoneMatch();\n            } else System.out.println(\"eTag                  : -\");\n            long date = c.getDate();\n            if (date == 0) System.out.println(\"Date time             : -\"); else System.out.println(\"Date time             : \" + new Date(date));\n            long exp = c.getExpiration();\n            if (exp == 0) System.out.println(\"Expiration time       : -\"); else System.out.println(\"Expiration time       : \" + new Date(exp));\n            long modified = c.getLastModified();\n            if (modified == 0) System.out.println(\"Last modified time    : not set\"); else System.out.println(\"Last modified time    : \" + new Date(modified));\n            testIfModified();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"\\n\");\n    }\n", "code2": "    public String downloadAndOpen(JProgressBar bar) {\n        long size = 0;\n        try {\n            size = photo.getSize();\n        } catch (ServiceException ex) {\n            ex.printStackTrace();\n        }\n        try {\n            bar.setMaximum((int) size);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        bar.setValue(0);\n        image = new File(\"TMP/\" + photo.getTitle().getPlainText());\n        try {\n            if (!image.exists()) {\n                image.createNewFile();\n                image.deleteOnExit();\n                URL url = null;\n                BufferedOutputStream fOut = null;\n                try {\n                    url = new URL(photo.getMediaContents().get(0).getUrl());\n                    InputStream html = null;\n                    html = url.openStream();\n                    fOut = new BufferedOutputStream(new FileOutputStream(image));\n                    byte[] buffer = new byte[32 * 1024];\n                    int bytesRead = 0;\n                    int in = 0;\n                    while ((bytesRead = html.read(buffer)) != -1) {\n                        in += bytesRead;\n                        bar.setValue(in);\n                        fOut.write(buffer, 0, bytesRead);\n                    }\n                    html.close();\n                    fOut.close();\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return image.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"testMapSource": ["testmapSources", "testMapService", "testMapSources", "TestMapSource", "testTileSources", "testmapSOURCE", "testmapSource", "TestTileSource", "testMAPSource", "TestMapSources", "testmapService", "testMapSOURCE", "testMAPSources", "TestTileSources", "testMAPSOURCE", "TestMapService", "TestTileSOURCE", "testTileService", "testTileSource", "testTileSOURCE", "testMAPService", "TestTileService", "TestMapSOURCE"], "mapSource": ["asterUnit", "placeStore", "mapStack", " mapTarget", "addressSources", "imageSOURCE", "tileStack", "appSource", "asterSize", "appTarget", "dataTarget", "imageService", "moveSource", "tileSize", "mapClient", "mapSourceFile", "capSourceFile", "toolUnit", "addressSource", "placeSpace", " mapSources", "capSOURCE", "buildSite", "shapeService", "placeSource", "buildSource", "asterSource", "moveSpace", "placeSourceFile", " mapSOURCE", "shapeSources", "toolSpace", "gameSpace", "shapeSource", "imageSourceFile", "mapSize", " mapService", "dataForce", "imageSource", "tileSourceFile", "addressService", "tileUnit", " mapForce", "buildSOURCE", "tileSource", "appSpace", "mapService", "capService", "mapStore", "capSource", "gameSOURCE", "gameSite", "placeStack", "buildSpace", "mapSOURCE", "mapUnit", "dataSpace", " mapStack", "moveStore", "tileSpace", "addressClient", "mapSources", "dataSource", "asterSpace", "tileSOURCE", "tileSite", "placeSize", "mapTarget", " mapClient", "gameSource", "appForce", "mapForce", "mapSite", " mapSourceFile", "shapeClient", "tileStore", "toolSize", "moveSize", "toolSource"], "coordinate": ["addressination", "copoint", " Coordination", "coorditude", "addressordinate", "ordinate", "interinate", "coination", "interitude", "coordination", "tileination", "tileitude", "addressinator", "latitude", "ordpoint", "addressinate", "timinator", "timinate", "coordpoint", "timination", "latinator", " Coordpoint", "tileinate", "latinate", "coordordinate", "latordinate", "latination", " Coordinate", "coordinator", "ordination", "ordordinate", "timordinate", "coinate", "interination", "tileordinate", "interordinate", " Coordordinate"], "zoom": ["zipulu", "zocol", "zeulu", "tzipping", "zeom", "Zoo", "tzone", " zulu", " zoe", "Zoom", "Zow", "lom", "zoo", "tzom", "zipoom", "zom", "tzocol", "zeoe", "zeone", "lipping", "lone", "zone", " zone", "izoom", "zulu", "zoe", "zipping", "izug", "tzoom", " zow", " zug", "zow", "azoor", "azoo", "zipoe", " zom", "azow", " zoor", "izom", "tzug", "zipone", "zoor", "zeoom", "Zoor", "zug", "loom", "izocol", " zoo", " zocol", "azoom", "zeipping"], "mapSpace": ["mapsSource", "appSpace", "planeShape", " mapspace", "mapService", "tileSource", "openspace", "shapeSpace", "bridgespace", "bridgeSize", "viewSource", "mapsSpace", "mapSp", "openSize", "usespace", "shapeService", "surfaceSource", "surfaceSquare", " mapSp", "openSource", "workSpace", "mapSquare", "appSp", "tileService", "mapShape", "planeSource", "appPoint", "mapPoint", "shapeSource", "bridgeSpace", "mapsService", "useSp", " mapShape", "tileSquare", "viewService", "mapSize", " mapService", "appspace", "viewSp", "workspace", "shapeSp", "workSize", "usePoint", "shapeSquare", "workSource", "tileSpace", "mapsShape", "mapspace", "planeSpace", "viewSpace", "surfaceSpace", "planeService", " mapPoint", "surfaceService", "tileSp", "useSpace", "bridgeSource", "openSpace"], "tilex": ["Tiley", "oleex", "yleex", "olez", "yley", " tileex", "Tilex", "oley", " tileX", "yleX", "tileX", "tilez", "tileex", "TileX", "ylex", "Tilez", "olex", "oleX", " tilez"], "tiley": ["antollo", " tlly", "antilly", "Tiley", "Taxy", "zavy", "tlly", "toplly", "tailey", "Tlly", "antiley", "tailly", "antavy", "zilly", "zollo", "tollo", "taavy", "ziley", "topaxy", "topiley", "tavy", "taxy", " taxy", "topiky", "tiky", "taollo", "tilly", " tiky", "Tiky"], "url": ["resource", "ob", "string", "channel", "cache", "http", "str", "service", "www", "URL", "log", "path", "ll", "ur", "api", "feed", "gl", "Url", "rl", "email", "impl", "address", "loc", "lr", "build", "l", "connection", "base", "rc", "ls", "coll", "server", "config", "sl", "ul", "image", "uc", "page", "ssl", "lc", "fl", "id", "web", "uri", "source", "buffer", "fr", "ref"], "c": ["dc", "ch", "ctrl", "pc", "fc", "u", "cm", "g", "k", "m", "cache", "n", "o", "http", "d", "abc", "ci", "ic", "ctx", "con", "sc", "z", "co", "cf", "ct", "cu", "ce", "conn", "content", "C", "p", "cc", "cr", "l", "mc", "connection", "cl", "vc", "out", "j", "cp", "exec", "coll", "config", "cs", "bc", "f", "enc", "e", "code", "i", "uc", "h", "v", "r", "b", "t", "conf", "ec", "client", "tc", "lc"], "contentType": ["fileType", "mediaType", "mediaTime", "resourcetype", "resourceLength", "contType", "ContentLength", "contentLength", "fileLength", " contentTime", " contenttype", "resourceFormat", "mediatype", "resourceType", "mediaLength", "contenttype", "contentTime", "ContentType", "ContentFormat", "filetype", "Contenttype", "contentFormat", " contentFormat", "conttype", "contFormat", "fileFormat", "ContentTime", " contentLength", "contLength"], "eTag": ["jeMat", "sCode", " eMat", "eveMonth", "etag", "eMat", " eMatch", "jeMatch", "eMonth", " eComment", "eMatch", "sComment", " eImage", " eCode", "oTag", " eMonth", " eTags", "oTags", "oMatch", "aeTags", "teCode", "aeImage", "eveMatch", " etag", "eCode", "aeTag", "aeMatch", "teComment", "jeMonth", "sTag", "eveTag", "teTag", "jeTag", "oImage", "eTags", "eveMat", "eImage", "stag", "eComment", "tetag"], "eTagSupported": [" eTagEnabled", " eTagUsed", "eTagUsed", "eCodeSupport", " eMatchEnabled", "eCodeUsed", "eTagSupport", "eTagsSupport", "eCommentSupport", "eCommentUsed", "eCommentEnabled", "eMatchSupported", "eCodeEnabled", "eTagsSupported", "eMatchEnabled", "eCodeSupported", "eTagsEnabled", " eMatchSupported", " eTagSupport", "eMatchSupport", "eTagEnabled", "eCommentSupported", " eMatchSupport", " eMatchUsed", "eMatchUsed"], "date": ["resource", "day", "use", "dose", "full", "dat", "d", "gender", "time", "year", "open", "match", "key", "number", "doc", "user", "atom", "bug", "age", "valid", "create", "grade", "document", "month", "tag", "event", "where", "dt", "complete", "field", "code", "value", "set", "Date", "image", "start", "change", "charge", "data", "type", "write", "style", "module", "id", "message", "sign", "update", "body", "form", "name", "file"], "exp": ["window", "acc", "ip", "fee", "gap", "act", "zip", "op", "ex", "limit", "script", "scope", "desc", "abs", "sc", "text", "Exp", "doc", "active", "div", "lit", "loc", "cookie", "err", "p", "life", "miss", "sp", "price", "max", "sec", "EXP", "enc", "comp", "xp", "lim", "cap", "inf", "expr", "ext", "val", "charge", "hr", "inc", "ix", "ref", "extra"]}}
{"id1": "755203", "id2": "14733078", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "15445861", "id2": "16557837", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "CopyFiles", "copyfile", " copyDirectory", "CopyDirectory", "copyFiles", "transferFiles", "transferDirectory", "copyDirectory", "CopyFile", "transferfile"], "srcFile": ["rcPlace", "rcFiles", "rcPath", " srcStream", "sourceFiles", "rcStream", "srcDir", "destDir", "rcFile", "supFile", "sourcefile", "rcDir", "rcDirectory", "supPath", "srcFiles", " srcDir", "ourcePlace", "rcfile", "srcfile", "ourceFile", " srcPlace", "srcDirectory", " srcfile", "srcTime", "destTime", "destDirectory", "srcStream", "srcPlace", "supStream", "sourceFile", "sourcePath", " srcPath", " srcTime", "sourceDirectory", " srcDirectory", "srcPath", "ourceTime", "ourcePath", "sourceDir", "rcTime", "supfile", " srcFiles"], "destFile": ["targetFile", "destPath", "tempFiles", "endTime", "sourcefile", " destDirectory", "vertFile", "destFilename", "endFilename", "targetPath", "inationFiles", "destfile", "destFiles", "stdFile", " destTime", "DestPath", " destFilename", "Destfile", "tempPath", "DestFile", "inationFile", "targetTime", "destTime", "destDirectory", "targetFilename", "vertFilename", "sourceFile", "inationFilename", " destFiles", "vertFiles", "tempFile", "sourceDirectory", "stdTime", "stdDirectory", "tempfile", "DestFilename", "inationPath", "endPath", "vertPath", "stdfile", "sourceTime", "endFile", "DestFiles", " destPath", " destfile"], "in": ["In", "or", "pull", "again", "serv", "ini", "IN", "m", "cin", "ex", "is", "din", "inner", "bin", "input", "as", "con", "io", "pin", "ins", "ac", "min", "inn", "kin", "up", "isin", "init", "win", "base", "rin", "url", "get", "gin", "read", "f", "inside", "i", "nin", "a", "image", "socket", "h", "login", "reader", "r", "b", "inc", "id", "source"], "out": ["pass", "line", "again", "n", "cache", "o", "exp", "ex", "inner", "bin", "Out", "io", "outs", "sync", "conn", "user", "err", "up", "net", "w", "base", "exec", "work", "gin", "other", "off", "by", "socket", "writer", "to", "ext", "output", "obj", "OUT", "inc", "parent", "client", "one", "file"], "buffer": ["position", "channel", "uffer", "limit", "pause", "input", "layer", "wave", "feed", "slice", "buf", "queue", "length", "address", "header", "batch", "document", "base", "phrase", "server", "url", "variable", "size", "read", "Buffer", "iter", "bytes", "border", "result", "memory", "transfer", "reader", "reference", "data", "null", "b", "buff", "flush", "offset", "binary", "source", "block", "padding"], "no": [" lo", "so", "zero", " NO", "o", "go", "No", "ko", "was", "na", " none", "io", "co", "from", "number", "none", "only", "os", "wa", "num", "maybe", " mo", "nor", "nr", "nos", "eno", "pos", "nothing", "x", " number", "ino", "index", "NO", "size", "i", "off", "auto", "to", "lo", "nt", "error", "data", "type", "po", "yes", "id", "info", "which", "mo"]}}
{"id1": "6304373", "id2": "7118860", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaOrMempl", "uploadOrDeleteMediaOrMemFiles", "uploadOrDeleteMediaOrtempl", "uploadOrDeleteMediaOrtemporary", "uploadOrDeleteMediaOrtemplates", "uploadOrDeleteMediaOrMemporary", "uploadOrDeleteMediaOrTemplateplates", "uploadOrDeleteMediaOrTemFiles", "uploadOrDeleteMediaOrTemplateporary", "uploadOrDeleteMediaOrMemplates", "uploadOrDeleteMediaOrTemplatepl", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrTemporary", "uploadOrDeleteMediaOrtemFiles", "uploadOrDeleteMediaOrTemplateFiles"], "action": ["item", "resource", "status", "section", "function", "effect", "act", "what", "site", "step", "environment", "method", "call", "view", "version", "service", "state", "api", "operation", "ACTION", "active", "flash", "part", "element", "event", "actions", "url", "commit", "now", "name", "Action", "controller", "format", "change", "test", "next", "error", "type", "style", "module", "plugin", "ction", "parent", "lock", "activation", "activity", "flow"], "object": ["resource", "group", "class", "subject", "ject", "not", "project", "function", "full", "string", "instance", "oid", "environment", "host", "o", "request", "current", "service", "node", "self", "edit", "objects", "none", "number", "zone", "email", "mode", "address", "letter", "document", "part", "element", "event", "model", "url", "thread", "system", "now", "office", "article", "image", "auto", "directory", "obj", "target", "module", "parent", "lock", "version"], "numElements": [" numEodes", "numGelements", "numEllem", "numGelem", "numelements", "numEllements", "numelement", "numElem", "numEodes", " numElem", " numelements", " numelement", "numeodes", " numeodes", "numGelement", "numelem", "numEllement", "numElodes", "numGeodes", " numelem"], "req": ["use", "g", "xml", "msg", "report", "log", "ctx", "params", "util", "mr", "gr", "verb", "err", "ro", "resp", "base", "load", "usr", "res", "html", "next", "obj", "r", "module", "conf", "parent", "update", "builder"], "session": ["resource", "temp", "local", "token", "subject", "container", "use", "global", "cache", "instance", "context", "request", "http", "service", "state", "scope", "response", "manager", "ctx", "sa", "shared", "browser", "flash", "ession", "connection", "document", "event", "security", "sp", "ESSION", "system", "thread", "Session", "image", "h", "result", "test", "lock", "client", "site", "person"], "ftp": ["FTc", "FTp", " ftc", "ftc", "FTcp", "ttcp", "ttc", " ftP", "FTP", "ttp", "ftcp", "ttP", "ftP", " ftcp"], "user": ["mail", "group", "pass", "ver", "class", "username", "use", "usa", "project", "full", "string", "current", "view", "comment", "ee", "state", "facebook", "self", "path", "log", "match", "this", "post", "auth", "custom", "creator", "shared", "USER", "er", "bug", "browser", "profile", "rule", "connection", "base", "url", "system", "config", "usr", "per", "other", "e", "admin", "home", "User", "by", "used", "image", "hash", "record", "page", "result", "html", "author", "error", "data", "type", "member", "module", "account", "info", "users", "lock", "client", "parent", "name", "db", "person"], "links": ["pages", "mail", "Link", "lines", "results", "ids", "headers", "log", "Links", "images", "details", "styles", "tree", "email", "linked", "members", "groups", "flash", "base", "actions", "url", "link", "image", "html", "mails", "posts", "menu", "items"], "folders": ["handages", "foldors", "filers", "handries", "filages", "anchages", "anchers", "foldries", "anchries", "anchors", "handors", "handers", "filors", "foldages", "filries"], "folder": ["resource", "project", "zip", "append", "volume", "area", "region", "scope", "layer", "path", "division", "ignore", "slice", "network", "enter", "Folder", "email", "database", "zone", "address", "dir", "archive", "fold", "letter", "sample", "theme", "command", "connection", "device", "document", "element", "layout", "future", "upload", "url", "location", "two", "license", "flat", "home", "filename", "editor", "directory", "level", "menu", "picture", "plugin", "id", "uri", "source"], "server": ["resource", "slave", "status", "token", "username", "seed", "string", "host", "version", "inner", "service", "master", "node", "outer", "manager", "engine", "network", "enter", "database", "email", "address", "connection", "scale", "device", "port", "url", "location", "system", "localhost", "value", "filename", "erver", "peer", "socket", "remote", "page", "ssl", "directory", "ser", "Server", "reader", "type", "account", "source", "uri", "client", "site"], "login": ["resource", "mail", "group", "pass", "status", "username", "string", "blog", "access", "site", "sudo", "secret", "service", "path", "log", "label", "network", "pin", "Login", "auth", "database", "email", "bridge", "cookie", "profile", "connection", "layout", "consumer", "blank", "url", "shell", "config", "machine", "basic", "journal", "filename", "socket", "ssl", "picture", "plugin", "account", "users", "info", "lock", "name", "skin"], "password": ["timeout", "slave", "pass", "token", "username", "sword", "string", "access", "word", "sudo", "volume", "secret", "photo", "language", "Password", "PASS", "manager", "division", " passwords", "auth", "database", "email", "cookie", "ass", "profile", "connection", "device", "phrase", "security", "basic", "strip", "filename", "worker", "directory", "picture", "plugin", "account", "pattern", "alias", "mask", "column", "name", "padding"], "fileTransferFolder": ["mediaTransferServer", "fileTransformFolder", "FileTransferFolder", "FileTransferTheme", "fileUploadPath", "fileTransferTheme", "mediaTransferfolder", "mediaUploadfolder", "mediaTransferFolder", "fileImportDirectory", "fileAccessTheme", "fileImportfolder", "fileUploadTheme", "FileUploadFolder", "FileUploadTheme", "fileImportServer", "fileTransformfolder", "FileUploadfolder", "FileTransferfolder", "fileTransferDirectory", "fileTransferPath", "fileImportFolder", "mediaUploadFolder", "mediaTransferDirectory", "fileTransferfolder", "fileAccessPath", "fileUploadDirectory", "mediaUploadDirectory", "FileUploadPath", "fileAccessfolder", "fileUploadfolder", "fileTransferServer", "mediaUploadServer", "fileUploadFolder", "fileTransformPath", "fileUploadServer", "fileAccessFolder", "FileTransferPath", "fileTransformTheme"], "liveFolder": ["LiveFolder", "livefolder", "PreviewDirectory", "liveLocation", " livefolder", "LiveDirectory", "PreviewFolder", "Previewfolder", " liveDirectory", " liveLocation", "LiveLocation", "liveDirectory", "Livefolder", "PreviewLocation"], "servers": ["Serations", " serations", "servls", " serServer", " serls", "SerServer", "serls", "serations", "servServer", "servations", "Servers", "servvers", "Serls", "serServer"], "message": ["resource", "mail", "application", "status", " messages", "description", "string", "request", "response", "msg", "manager", "log", "path", "details", "mess", "summary", "email", "content", "address", "header", "flash", "document", "element", "url", "array", "Message", "image", "page", "member", "error", "menu", "module", "update", "buffer", "body"]}}
{"id1": "22441244", "id2": "7425022", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"send": ["mail", "execute", "append", "reply", "export", "open", "from", "add", "post", "address", "build", "exec", "get", "delete", "set", "start", "transfer", "sent", "parse", "write", "submit", "Send", "message", "text", "create", "end"], "hsession": ["hession", "hsess", "hsSession", "openssession", "hmSession", "hhort", "hsort", "hessions", "hssession", "hsessions", "opensession", "hesess", "opensessions", "opensess", "hhess", "hessession", "hhSession", "hhsession", "opensort", "HSSession", "opensSession", "hhessions", "hmessions", "hhession", "HSessions", "hmession", "HSession", "HSsession", "hesort", "hesession", "hSession", "hmsession"], "session": ["resource", "mail", "application", "chat", "class", "project", "cache", "host", "context", "proxy", "state", "response", "manager", "ession", "connection", "document", "event", "port", "server", "security", "sl", "Session", "message", "parent", "client", "essions", "site"], "repositoryName": ["repoositoryName", "reposositoryNAME", "reposositoryName", "repositivePath", "reposessionPath", "reposicationFamily", "reposicationName", "repositiveEmail", "repositoryAddress", "repositoryEmail", "repoositoryEmail", "reposositoryPath", "repoitoryPath", "reposessionEmail", "repoositoryPath", "repositiveNAME", "reposessionNAME", "reposessionName", "reposositoryEmail", "reposicationAddress", "reposicleFamily", "repoositoryAddress", "reposositoryFamily", "repoitoryNAME", "reposicleAddress", "reposicleName", "reposositoryAddress", "repositiveName", "repositoryNAME", "reposicationEmail", "repositoryFamily", "repoitoryEmail", "repoitoryFamily", "repoitoryAddress", "repoositoryFamily", "reposicleEmail", "repositoryPath", "repoositoryNAME", "repoitoryName"], "ideIdint": ["IDEidint", "IDEidints", "IDEidn", "ideAuthints", "ideidint", "ideAuthint", "IDEIdout", "ideNameInt", "IDEIdint", "ideNameout", "IDENamenumber", "ideInint", "IDENameint", "ideInints", "ideInfoint", "ideidInt", "ideAuthInt", "ideInfonumber", "ideNameint", "ideInfoout", "ideIdInt", "IDEIdn", "ideIdn", "IDEIdInt", "ideidints", "ideInn", "ideInInt", "ideNamenumber", "ideTimeInt", "IDEIdnumber", "IDEIdints", "IDENameout", "ideTimeint", "ideIdints", "ideTimeout", "ideIdout", "ideIdnumber", "ideidn", "IDENameInt", "ideTimenumber", "ideInfoInt", "ideAuthn", "IDEidInt"], "to": ["mail", "tel", "token", "reply", "title", "with", "response", "options", "about", "contact", "phone", "from", "summary", "address", "TO", "prefix", "location", "To", "settings", "office", "name", "company", "by", "top", "mobile", "target", "po", "account", "message", "sub", "source", "uri", "client", "site", "template"], "cc": ["dc", "c", "ca", "cus", "comment", "cca", "ci", "contact", "sc", "phone", "from", "card", "ct", "cf", "ac", "ce", "address", "CC", "cl", "cr", "rc", "cn", "cs", "company", "code", "password", "uc", "cb", "account", "ec", "nc", "client", "ck", "tc", "lc"], "bcc": ["abcc", "pcc", "fck", "pc", "fc", "fcc", " brc", "abc", "brc", "abck", "bck", "bbcc", "frc", "bce", "bbck", "bbc", "bbrc", " bc", "bc", " bce", "abce", " bck", "pck", "pce"], "subject": ["mail", "ject", "username", "Subject", "description", "host", "method", "reply", "request", "title", "comment", "state", "response", "phone", "object", "content", "header", "prefix", "head", "filename", "format", "author", "message", "sub", "uri", "reason", "template"], "body": ["resource", "foot", "bound", "pass", "media", "line", "function", "description", "zip", "string", "view", "secret", "comment", "inner", "money", "response", "how", "empty", "tree", "summary", "length", "content", "object", "header", "connection", "part", "base", "Body", "normal", "shell", "url", "left", "code", "wrapper", "password", "plain", "html", "data", "pod", "style", "message", "source", "lock", "text", "name", "reason", "template"], "attachments": ["messents", "embedment", "Attachment", "messments", "Attachents", "messment", "embedings", "embedents", "attachents", "Attachings", "attachings", "Attachments", "embedments", "messings"], "isHtml": ["isChive", "isWhhtml", "isHive", "isPhttp", "isHatml", " isWhtml", " isHttp", "isWhive", "isChhtml", "isHaail", " isChail", "isChttp", "isWhtml", "isChail", "isPhail", " isChtml", " isWhive", " isHail", "isHail", " isHhtml", " isHive", " isWhhtml", "isCtml", " isChttp", " isWhail", "isCail", "isPhhtml", "isHttp", "isWhail", "isChtml", "isHattp", "isPhtml", "isHahtml", " isChhtml", "isHhtml", "isCive"], "charset": ["chasetter", "chearsetter", "chearsET", "chARSets", "chaset", "CharsET", "charsets", "chanset", "Charsets", "chanspace", "chARSetting", "chaseting", "chasets", "chearsete", "chaspace", "chashesET", "chasetting", "chearset", "charspace", "chearsetting", "chaseseting", "chashesetter", "chackset", "cheanspace", "chacksetting", "Charsetting", "chARSete", "chARSET", "chacksET", "Charset", "chansetter", "charsetter", "cheansete", "chARSet", "chasesetting", "cheanset", "chansET", "cheansET", "chansete", "chacksete", "chARSeting", "chearspace", "charsET", "chasesET", "chansetting", "charsetting", "Charseting", "chashespace", "charsete", "charseting", "chasET", "cheansetting", "chasheset", "chaseset", "cheansetter"], "headers": ["ers", "names", "status", "classes", " messages", "writers", "lines", "errors", "authors", "options", "params", " cookies", "files", "groups", "properties", "content", "header", " recipients", " emails", "strings", "settings", "types", "mails", "metadata", "comments", "users"], "priority": ["status", "class", " severity", "reply", "secret", "title", "comment", "language", "state", " title", "phone", "queue", "length", "theme", "mode", " recipients", "lang", "prefix", "security", "date", "code", "quote", "level", "author", "comments", "reason", "template"], "email": ["mail", "online", "external", "username", "Email", "line", "fax", "entity", "zip", "note", "oe", "em", "pm", "ilo", "view", "xml", "service", "response", "core", "export", "contact", "lex", "engine", "international", "enter", "object", "address", "letter", "generic", "print", "create", "default", "document", "liner", "base", "business", "element", "install", "model", "event", "server", "url", "office", "article", "e", "password", "el", "auto", "example", "gmail", "html", "result", "ext", "output", "test", "data", "ssl", "en", "account", "message", "info", "update", "text", "name", "template"], "user": ["resource", "role", "token", "use", "username", "ip", "string", "unknown", "character", "uid", "creator", "me", "object", "USER", "er", "profile", "connection", "friend", "model", "consumer", "e", "User", "mobile", "member", "author", "data", "type", "plugin", "account", "id", "users", "info", "people", "client", "name", "person"], "identity": ["Idententity", "Identities", "entityonymous", "ethnicity", "authoronymous", "Identity", "idity", "identITY", "IdentITY", "personifier", "electricity", "entityity", "authorication", "authority", "installity", "authentifier", "entityifier", "authorifier", "idonymous", "installentity", "idifier", "publicity", "identization", "entityization", "ethnicentity", "authentity", "authoriciary", "authorITY", "authentization", "authentication", "ethniciciary", "authentonymous", "authorities", "electricentity", "authentITY", "ethnicication", "IDENTentity", "installonymous", "installITY", "identonymous", "electriconymous", "publiciciary", "ethnicifier", "personITY", "identiciary", "electricITY", "idententity", "identifier", "idication", "publicITY", "publicentity", "idITY", "idization", "ethnicITY", "personity", "personentity", "authorentity", "IDENTity", "identities", "identication", "IDENTities", "IDENTITY"], "_returnPath": [" _returnUrl", "_replyPath", "_addPath", "_returnDirectory", "_replyPart", " _returnPart", "_replyUrl", "_addpath", "_returnType", "_returnUrl", "_relationText", " _backName", "_successId", " _returnTo", "_returnNode", "_responsePath", "_backPart", " _backUrl", "_resultHalf", "_responseType", "_correctPath", "_responsepath", "_resultName", "_correctDirectory", "_displayPath", "_inputPath", "_correctText", "_successText", "_displayPart", "_relationId", "_returnPart", "_inputUrl", "_displayMid", "_returnId", "_backName", "_resultTo", "_backPath", "_backType", "_addType", "_inputMid", "_returnpath", "_returnText", "_relationPath", "_returnTo", "_inputNode", "_successPath", " _backPath", "_successDirectory", "_returnHalf", "_backTo", "_correctId", "_displayUrl", " _returnHalf", " _backPart", "_resultPath", " _returnName", "_returnName", "_replyNode", " _backHalf", "_backHalf", "_backpath", "_returnMid", " _backTo", "_replyMid", "_displayNode", "_backUrl", "_relationDirectory"], "_from": ["_error", "workwho", "placeto", " _with", "blockerror", "_who", "workfrom", "existingto", "existingfor", " _for", "placefor", " _From", "placeowner", " _source", "placefrom", "existingfrom", "blockfrom", " _owner", "existingowner", " _who", "worksource", " _error", "blockto", "_with", "_owner", "_source", "_for", "_From", "blockFrom", "workto"], "_replyTo": [" _replyFrom", " _returnTo", "_reasonTo", "_respondFrom", "_commentTO", " _returnUrl", "_reasonUrl", " _replyUrl", "_addFrom", "_replyAddress", "_closeFrom", "_commentFrom", "_respondPoint", " _returnTO", "_closeTo", "_returnPoint", "_respondAddress", "_reasonFrom", "_addAddress", "_replyUrl", "_returnAddress", "_replyTO", "_closeOf", "_returnUrl", "_returnTo", "_respondUrl", " _returnFrom", " _replyTO", "_respondTo", "_replyOf", "_commentTo", "_addTo", "_respondTO", "_returnFrom", "_reasonTO", "_returnOf", "_replyPoint", "_replyFrom", "_commentOf", "_addPoint", "_returnTO", "_closeTO"], "_to": ["Jto", "Jtarget", " _about", "_target", "Jfrom", " _target", "Jabout", "_about"], "_cc": [" _ce", " _cf", "_cf", "_cd", "_ce", " _cd"], "_bcc": [" _abce", "_abc", " _abcs", "_rbce", "_sbcs", " _abcc", "_sbc", "_sbce", "_abcc", "_rbcc", "_bce", "_abce", "_abcs", " _abc", " _bcs", "_bcs", "_rbc", "_bc", " _bce", "_sbcc", "_rbcs", " _bc"]}}
{"id1": "3309233", "id2": "8330057", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public void getHttpURL() throws Exception {\n        boolean display = true;\n        boolean allHeaders = false;\n        String url = null;\n        url = \"http://localhost/cubigraf2\";\n        url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\";\n        url = \"http://www.uni.pt/img/home-direito.gif\";\n        url = \"http://www.google.com\";\n        URLConnection uc = new URL(url).openConnection();\n        println(\"HEADERS:\");\n        if (allHeaders) {\n            Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator();\n            while (itHeaders.hasNext()) {\n                Map.Entry<String, List<String>> e = itHeaders.next();\n                Iterator<?> itValues = e.getValue().iterator();\n                while (itValues.hasNext()) {\n                    println(e.getKey() + \": \" + itValues.next());\n                }\n            }\n        } else {\n            showObjectProperty(uc, \"getContentEncoding\");\n            showObjectProperty(uc, \"getContentLength\");\n            showObjectProperty(uc, \"getContentType\");\n            showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP);\n        }\n        ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString());\n        if (display) {\n            println(\"BODY:\");\n            ExtendedReader reader = new ExtendedReader(in);\n            for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                println(s);\n            }\n        } else {\n            println(\"(BODY saved to a file)\");\n            String contentType = uc.getContentType();\n            StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\");\n            filename.append(\".\");\n            filename.append(contentType.substring(contentType.indexOf(\"/\") + 1));\n            File file = new File(filename.toString());\n            ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.getAbsolutePath());\n            Streams.copy(in, out);\n            out.close();\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doUsingAsync", " doAsyncConsole", "buildInAsync", " doAsBackground", " doAsyncAsync", "buildUsingStudio", "buildInStudio", " doAsConsole", "buildUsingConsole", " doUsingConsole", " doAsyncStudio", "buildInConsole", "buildUsingBackground", " doAsyncBackground", "buildInBackground", " doAsAsync", " doAsStudio", "buildUsingAsync", " doUsingBackground", " doUsingStudio", " doInConsole", " doInStudio", " doInAsync"], "params": ["reports", "names", "pm", "resources", "py", "lines", "values", "results", "eps", "options", "ctx", "objects", "Param", "details", "files", "json", "properties", "address", "arms", "p", "s", "ams", "pins", "Parameters", "ls", "los", "phrase", "strings", "sp", "config", "settings", "keys", "services", "i", "ds", "types", "Par", "page", "parts", "parse", "type", "posts", "data", "ps", "comments", "source", "par", "mes"], "param": ["temp", "pc", "aram", "pm", "project", "pri", "cm", "mand", "string", "channel", "iam", "pb", "option", " parameter", "km", "comment", "prem", "Parameter", "path", "ctx", "gram", "mor", "Param", "conn", "object", "address", "single", "p", "vm", "default", "proc", "connection", "amp", "part", "ams", "cp", "model", "contract", "ram", "config", "pool", "am", "rem", "arm", "password", "page", "prom", "meter", "null", "mm", "conf", "parent", "camp", "par", "name", "monitor", "lc"], "client": ["resource", "project", "cm", "c", "channel", "host", "request", "http", "proxy", "service", "response", "self", "con", "api", "force", "ce", "conn", "handler", "p", "bird", "cl", "app", "connection", "base", "cp", "server", "url", "help", "config", "cli", "comp", "session", "connect", "google", "ssl", "secure", "plugin", "apache", "Client"], "post": ["entry", "send", "zip", "c", "push", "and", "op", "pb", "request", "POST", "http", "comment", "response", "api", "patch", "feed", "add", "json", "pp", "wp", "p", "dd", "proc", "part", "base", "pos", "install", "upload", "server", "query", "load", "Post", "f", "e", "posted", "set", "head", "pre", "next", "pod", "submit", "put", "hop", "body", "form", "create"], "resp": ["resource", "Response", "status", "rep", "fc", "serv", "respond", "rec", "rh", "request", "reply", "http", "response", " response", "api", "json", "download", "conn", "content", "handler", "rel", "err", "exec", "server", "sp", "par", "enc", "e", "success", "received", "Resp", "res", "page", "error", "obj", "req", "comm", "body", "re", "ref"], "entity": ["resource", "body", "entry", "status", "attribute", "line", "string", "instance", "xml", "response", "node", "json", "object", "content", "conn", "translation", "unit", "connection", "base", "agent", "element", "event", "model", "ity", "coll", "article", "enc", "e", "code", "el", "output", "data", "obj", "ent", "ec", "Entity", "activity", "person"], "result": ["property", "resource", "entry", "row", "status", "line", "Result", "description", "string", "instance", "results", "response", "report", "desc", "match", "details", "place", "json", "object", "content", "address", "ret", "translation", "default", "url", "location", "name", "value", "success", "record", "res", "page", "output", "data", "message", "source", "text"]}}
{"id1": "4389475", "id2": "16142024", "code1": "    @Override\n    public URLConnection openConnection(URL url) throws IOException {\n        if (!url.getProtocol().equals(\"file\")) {\n            String name = url.getFile();\n            File f = new File(cacheFolder, ((name.charAt(0) == '/') ? name.substring(1) : name).replace('/', File.separatorChar));\n            if (!f.exists()) {\n                File f2 = new File(f.getParentFile(), f.getName() + \"-not_found\");\n                if (!f2.exists()) {\n                    try {\n                        f.getParentFile().mkdirs();\n                        downloadFile(url, f);\n                    } catch (IOException e) {\n                        f.delete();\n                        throw e;\n                    }\n                }\n            }\n            return f.toURI().toURL().openConnection();\n        }\n        return super.openConnection(url);\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 0, "substitutes": {"openConnection": ["OpenConnect", "closeConnection", " openConnect", "createChannel", "loadConnection", "loadConnect", "closeConnector", "OpenChannel", " openChannel", "newConn", "loadConnector", "closeConn", " openconnection", "newConnection", "closeChannel", "createConnect", "OpenConnection", "openConn", "newConnector", "createconnection", "openConnector", "openChannel", "createConnection", "closeConnect", "openConnect", "closeconnection", "newConnect", "openconnection", "loadConn"], "url": ["resource", "route", "u", "ob", "c", "cache", "host", "o", "http", "str", "proxy", "URL", "log", "path", "ur", "io", "feed", "gl", "this", "Url", "object", "user", "address", "bel", "loc", "lr", "l", "connection", "base", "server", "location", "config", "loader", "sl", "link", "e", "li", "el", "image", "page", "ssl", "html", "obj", "r", "b", "id", "web", "uri", "source", "org", "file"], "name": ["Name", "names", "resource", "n", "string", "full", "clean", "cache", "word", "o", "d", "named", "self", "core", "path", "search", "key", "no", "original", "l", "default", "w", "base", "part", "prefix", "x", "now", "size", "anc", "e", "i", "filename", "image", "ame", "NAME", "v", "nm", "type", "data", "id", "parent", "info", "uri", "alias", "source", "file"], "f": ["fa", "df", "folder", "fe", "fr", "F", "fc", "function", "of", "front", "g", "c", "n", "m", "full", "u", "o", "sf", "http", "d", "fo", "fx", "fd", "io", "feed", "cf", "fn", "p", "fs", "l", "ff", "tf", "fw", "j", "x", "af", "e", "i", "q", "h", "inf", "fp", "v", "fl", "found", "r", "b", "fb", "t", "lf", "bf", "parent", "info", "form", "file", "rf", "flow"], "f2": ["elf2", "elfsecond", "feed2", " f1", "elftwo", "elf1", " fsecond", "feedsecond", "ftwo", "pz", " fz", "f1", " f0", "Fz", "p1", "F2", "feedtwo", "p0", "p2", "f0", "fsecond", " ftwo", "feed1", "F1", "fz", "F0"]}}
{"id1": "7891509", "id2": "7927042", "code1": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "code2": "    private void loadDynamically(File result, String extraPath) {\n        URL url = null;\n        InputStream is = null;\n        FileOutputStream fos = null;\n        try {\n            url = new URL(homeServerUrl + extraPath);\n            is = url.openStream();\n            fos = new FileOutputStream(result);\n            byte[] buff = new byte[8192];\n            int nbRead;\n            while ((nbRead = is.read(buff)) > 0) fos.write(buff, 0, nbRead);\n        } catch (IOException e) {\n            throw new StellariumException(\"Cannot dynamically load \" + result + \" from \" + url);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"pageAddress": ["urlAddress", "PageAddress", "pageUrl", "PageName", " pageLocation", "urlLocation", "Pageaddress", "siteAddress", "urladdress", "siteUrl", "resourceaddress", "resourceAddress", "resourceUrl", "pageaddress", "pageLocation", " pageUrl", " pageName", "urlUrl", "siteName", "pageName", "PageUrl", "siteLocation", "PageLocation", "resourceLocation"], "url": ["resource", "string", "channel", "host", "http", "service", "URL", "feed", "open", "this", "Url", "client", "object", "user", "address", "browser", "l", "connection", "base", "out", "ls", "element", "server", "loader", "sl", "f", "i", "image", "socket", "page", "ssl", "bb", "reader", "data", "r", "b", "plugin", "web", "uri", "stream", "source", "file"], "in": ["resource", "In", "token", "line", "again", "ini", "c", "IN", "rec", "din", "inner", "bin", "input", "as", "ins", "client", "impl", "min", "conn", "inn", "into", "err", "kin", "l", "isin", "init", "s", "win", "out", "gin", "read", "f", "inside", "i", "nin", "socket", "login", "ssl", "reader", "data", "r", "b", "inc", "id", "buffer", "stream", "source", "file"], "inputLine": ["InputLine", "selectFile", "rawLine", "imageCell", "pageline", "pageUrl", "InputCell", "pageString", "inputFile", "inputContent", " inputL", " inputPage", " inputline", " inputContent", " inputFile", "pageLine", "inputString", "selectPage", "rawFile", " inputString", "inputUrl", "inputL", " inputUrl", "rawString", "selectLine", "imageFile", "imageLine", "imageL", "inputline", "InputFile", " inputCell", "inputPage", "rawPage", "rawUrl", "rawContent", "rawline", "InputL", "selectContent", "inputCell"]}}
{"id1": "16969205", "id2": "17116123", "code1": "    private List<JarFile> webArchives(ServletContext servletContext) throws IOException {\n        List<JarFile> list = new ArrayList<JarFile>();\n        Set<Object> paths = servletContext.getResourcePaths(WEB_LIB_PREFIX);\n        for (Object pathObject : paths) {\n            String path = (String) pathObject;\n            if (!path.endsWith(\".jar\")) {\n                continue;\n            }\n            URL url = servletContext.getResource(path);\n            String jarURLString = \"jar:\" + url.toString() + \"!/\";\n            url = new URL(jarURLString);\n            JarFile jarFile = ((JarURLConnection) url.openConnection()).getJarFile();\n            JarEntry signal = jarFile.getJarEntry(FACES_CONFIG_IMPLICIT);\n            if (signal == null) {\n                if (log().isTraceEnabled()) {\n                    log().trace(\"Skip JAR file \" + path + \" because it has no META-INF/faces-config.xml resource\");\n                }\n                continue;\n            }\n            list.add(jarFile);\n        }\n        return list;\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"webArchives": ["webAdaptives", "webArchivers", "webARCHories", " webAdaptiles", " webArchiles", "webARCHivers", " webArchories", "webAdaptiles", "webArchories", "webARCHives", "webAttories", " webArchivers", "webAttives", "webAdaptories", "webArchiles", "webAttiles", "webARCHiles", " webAdaptivers", "webAdaptivers", " webAdaptives", " webAdaptories", "webAttivers"], "servletContext": ["servetConnection", "servletsPath", "servleChannel", " servleConnection", "servlectionChannel", " servleContext", "servetContext", "servlectionContext", "servleConfig", "servletConnection", " servletConnection", " servleConfig", " servletChannel", " servleChannel", "servletsChannel", "servleConnection", "servletChannel", "servlConnection", "servletConfig", "servletsConnection", " servlePath", "servetConfig", "servletsContext", " servletConfig", "servetPath", " servletPath", "servlConfig", "servlectionConfig", "servlContext", "servletPath", "servleContext", "servlectionPath", "servlePath", "servletsConfig"], "list": ["live", "we", "full", "join", "cache", "map", "table", "ist", "pl", "log", "ll", "bag", "listed", "queue", "tree", "add", "object", "batch", "LIST", "p", "l", "bl", "part", "L", "base", "default", "chain", "all", "cl", "tmp", "server", "load", "left", "config", "array", "pool", "detail", "lp", "li", "set", "i", "val", "filter", "result", "test", "ssl", "obj", "null", "stack", "lists", "loop", "collection", "lc"], "paths": ["pathls", "urles", "Pathes", "pathings", "Pathps", "urlodes", "pathes", "urls", " pathps", "pathodes", " pathes", "methodps", " pathls", "methodes", " pathings", "methodls", "Pathodes", "Paths", "pathps", "urlings", "methods", "Pathings", "Pathls", " pathodes"], "pathObject": ["pathObj", "objectObject", "PathObj", " pathString", "pathString", "objectFolder", "urlObj", "Pathobject", "urlobject", "PathFolder", "PathString", "pathFolder", "pathobject", " pathObj", "objectString", "objectObj", " pathFolder", "urlString", "PathObject", "urlObject", " pathobject"], "path": ["folder", "resource", "txt", "entry", "temp", "root", "route", "full", "string", "th", "host", "step", "Path", "context", "method", "pointer", "xml", "str", "inner", "log", "ctx", "key", "object", "content", "dir", "child", "handler", "loc", "p", "cl", "lang", "part", "rc", "prefix", "location", "left", "config", "work", "loader", "enc", "ath", "image", "type", "data", "obj", "PATH", "point", "id", "pattern", "parent", "uri", "job", "text", "cont", "name", "file", "template"], "url": ["resource", "il", "entry", "pull", "route", "zip", "string", "channel", "host", "blog", "http", "str", "service", "URL", "log", "manager", "ur", "api", "feed", "gl", "Url", "impl", "client", "object", "user", "address", "dir", "loc", "browser", "l", "connection", "base", "server", "location", "coll", "config", "loader", "sl", "f", " URL", "cert", "image", "page", "ssl", "data", "obj", "r", "b", "jar", "null", "job", "uri", "stream", "buffer", "source", "org", "file"], "jarURLString": ["jarFileString", "javaUrlFunction", "jarURSetting", "javaURLInt", "jarPathString", "jarURFunction", "jarURLFunction", "jarPathInt", "javaUrlSetting", "javaURLString", "jarFileArray", "jarUrlSetting", "jarPathArray", "javaUrlString", "jarUrlstring", "javaURLFunction", "jarURstring", "jarUrlArray", "javaUrlArray", "jarFilestring", "jarURString", "javaURLstring", "jarPathstring", "jarURLInt", "javaURLSetting", "jarFileInt", "javaUrlInt", "jarURLSetting", "javaUrlstring", "jarURLstring", "jarURLArray", "jarUrlInt", "jarUrlFunction", "jarUrlString", "javaURLArray"], "jarFile": ["JarJar", " jarEntry", " jarfile", "browserJar", "filefile", "javaEntry", "browserFile", "jarJar", "Jarfile", "jarEntry", "browserEntry", "JarEntry", " jarJar", "jarfile", "fileJar", "JarFile", "javaFile", "javaJar", "fileEntry", "fileFile", "javafile"], "signal": [" SIGNal", "SIGNature", " signaler", "Signual", " signual", " SIGNual", " SIGNaler", "SIGNals", "signaler", "Signal", "signature", "SIGNal", "Signaler", "Signature", " SIGNals", "signual", "Signals", "signals", " signals", " signature", "SIGNaler"]}}
{"id1": "8973505", "id2": "23677142", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "label": 0, "substitutes": {"writeFileType": ["createFiletype", "writeFILETypes", "createFilesHeader", "writePagetype", "writeFileHeader", "createFilesTypes", "writeFileTypes", "writePageHeader", "writeFilestype", "createFileType", "createFileTypes", "writeFILEHeader", "writeFILEType", "createFileHeader", "writeFilesTypes", "createFilestype", "writeFILEtype", "writeFiletype", "writeFilesHeader", "writeFilesType", "writePageType", "createFilesType", "writePageTypes"], "uriFile": ["riFile", "urifile", "uiUrl", "uriFiles", "URIFiles", "uifile", "riFiles", "riFilename", "uiFiles", "URIfile", "URIFilename", "uriUrl", "filenameFile", "URIFile", "filenameFiles", "filenamefile", "filenameFilename", "riUrl", "uiFile", "rifile", "URIUrl", "uriFilename"], "outputfile": ["Outputfull", "inputfilename", "outputfull", "inputFile", "inputdir", "outputdir", "Outputdir", "resourcefilename", "unitfiles", "outputstring", "outputFile", "OutputFile", "unitstring", "Outputfile", "inputfiles", " outputdir", " outputfull", "inputstring", "inputfile", " outputFile", "unitfile", "resourcefile", "outputfilename", "outputfiles", "resourcefiles", "unitfilename", "resourcestring", "inputfull"], "num": ["span", "nb", "amount", "multi", "n", "zero", "initial", "col", "limit", "mult", "master", "sum", "con", "number", "NUM", "coord", "umi", "length", "no", "count", "unit", "Num", "batch", "index", "len", "split", "term", "nam", "inc", "offset", "nu", "dim", "loop", "name", "common"], "writer": ["we", "wt", "function", "manager", "Writer", "engine", "book", "w", "out", "socket", "writing", "write", "wl", "entry", "external", "ler", "walker", "outer", "report", "io", "feed", "header", "wire", "element", "office", "per", "editor", "page", "output", "data", "written", "null", "message", "master", "wb", "later", "root", "writ", "xml", "ee", "driver", "creator", "er", "document", "part", "wan", "ws", "index", "rw", "worker", "journal", "author", "type", "r", "lock", "width", "temp", "riter", "window", "writers", "method", "inner", "service", "layer", "wave", "wa", "key", "object", "handler", "unit", "server", "loader", "e", "session", "wrapper", "format", "widget", "wr", "style", "buffer", "source", "builder"], "uri": ["resource", "route", "http", "winner", "database", "umi", "address", "prefix", "location", "eni", "gi", "collection", "file", "username", "href", "uid", "sequence", "nor", "verb", "URI", "connection", " URI", "element", "link", "ori", "filename", "iri", "direction", "mi", "term", "picture", "message", "course", "folder", "attribute", "multi", "oid", "pi", "node", "di", "document", "query", "component", "cli", "doi", "li", "range", "id", "binary", "uni", "origin", "reference", "wiki", "token", "qi", "string", "ilo", "context", "ui", "ri", "theme", "unit", "handler", "base", "du", "i", "hub", "feature", "remote", "nil", "directory", "plugin", "metadata", "source"], "counter": ["entry", "computer", "ver", "current", "instance", "step", "ter", "vector", "inter", "pointer", "expression", "currency", "comment", "inner", "condition", "master", "continue", "trace", "time", "cpu", "outer", "ner", "sequence", "number", "enter", "second", "repeat", "nr", "Counter", "creator", "keeper", "handler", "count", "book", "batch", "cookie", "hello", "coll", "server", "clock", "loader", "name", "index", "processor", "iter", "controller", "i", "worker", "record", "page", "result", "runner", "meter", "parser", "timer", "loop", "info", "parent", "offset", "collection", "race", "keep", "lc", "reference"], "reader": ["row", "riter", "ger", "ir", "reading", "upper", "oder", "ruby", "inner", "ler", "layer", "io", "ner", "feed", "driver", "in", "ri", "keeper", "er", "handler", "lr", "bird", "l", "loader", "read", "Reader", "rer", "per", "iter", "e", "worker", "editor", "finder", "rr", "r", "rx", "parser", "rar", "stream", "buffer"], "url": ["resource", "string", "channel", "blog", "http", "www", "URL", "path", "io", "feed", "Url", "ri", "client", "user", "download", "address", "browser", "l", "connection", "base", "ls", "server", "config", "sl", "link", "li", "image", "page", "ssl", "plugin", "id", "web", "stream", "text", "source", "file"], "myConnection": ["Myconnection", "someConn", " myconnection", "someConnection", "myconnection", "myConnector", " myConn", "myConn", "yourconnection", "MyConnect", " myConnect", "MyConnection", "yourConnection", "MyConnector", " myConnector", "MyConn", "yourConn", "someReader", "myConnect", "yourConnector", "MyReader", "someConnect"], "myReader": ["MyParser", " myRead", "MyWriter", "myParser", "MyReader", "yourWriter", "MyRead", "myRead", "myWriter", "yourParser", " myWriter", " myParser", "yourRead", "yourReader"], "line": ["inline", "look", "entry", "row", "pass", "day", "use", "string", "note", "lines", "word", "LINE", "comment", "le", "Line", "response", "log", "feed", "key", "cl", "ri", "user", "no", "letter", "header", "frame", "rule", "liner", "part", "base", "l", "lin", "cell", "pe", "element", "du", "non", "link", "code", "el", "page", "range", "error", "data", "parse", "style", "point", "id", "message", "lf", "source", "text", "block", "column", "name", "file", "lc", "end"], "linecount": ["pageindex", "rowcache", "letterlength", " linelength", "rowlength", "rowlen", "rowcount", " linecache", "linelength", "Linecount", "linenumber", "LineCount", "linesize", " linenumber", "linecache", "Linesize", "linelen", "letterlen", "Linecache", "lettercount", " lineindex", "lineCount", "pagecount", " lineCount", "pagenumber", " linelen", "Linenumber", "Lineindex", "lineindex", " linesize", "rowsize", "lettersize", "pageCount"], "hasOWL": ["hasOWl", "hasOWLA", "hasEWLL", " hasEWLM", "HasEWLA", " hasOWLA", "hasOULA", "HasOWLM", "hasODL", "hasBYLL", "hasEFLM", " hasOWLL", "hasEFl", "hasOUL", "hasBYl", "HasOWLL", "hasODLL", "hasODLA", "hasOWSL", " hasOWLM", "HasOWLA", "hasOULL", " hasEWDL", "hasEFLA", "hasEWLA", "hasOWLL", "hasEWL", "hasOWSl", "HasEWL", "hasODLM", " hasEWLA", "hasEWl", "hasOULM", "hasBYDL", "hasODl", " hasOWl", "HasEWLM", " hasEWL", "hasOWDL", "HasOWL", "hasBYL", "hasOWLM", " hasEWLL", "hasOWSLL", "HasEWLL", "hasEWLM", "hasOWSDL", "hasEWDL", " hasEWl", "hasEFL", " hasOWDL"], "hasRDFS": ["hasXDPE", "hasRNFU", "hasCDFE", "hasRdfS", "hasRDFs", "hasGRUFS", "hasRNFs", "hasXDFE", "hasCDFs", "hasRDFAST", "hasRTFE", "hasRdfE", "hasRdfs", "hasGRDFSU", "hasRDPE", "hasGRUFs", "hasRDFU", "hasRDPs", "hasXDFS", "hasRFES", "hasCDPs", "hasRDPSU", "hasCDPE", "hasXDFs", "hasRTFES", "hasRDFE", "hasGRDFAST", "hasGRUFSU", "hasXDPU", "hasRUFs", "hasXDPs", "hasRFE", "hasCDPES", "hasRUFAST", "hasCDFS", "hasRNFS", "hasRUFSU", "hasRDPS", "hasRdfU", "hasRTFS", "hasGRDFS", "hasRNFE", "hasRFSU", "hasRDPES", "hasCDFES", "hasRFS", "hasRFs", "hasGRDFs", "hasRDFSU", "hasRDPAST", "hasRDPU", "hasRFAST", "hasXDPS", "hasRTFs", "hasCDPS", "hasRDFES", "hasXDFU", "hasRUFS", "hasGRUFAST"], "hasRDF": ["hasUOW", "hasUDP", "hasMRDEF", "hasSRDP", " hasRRUF", "hasRMF", "hasNRMF", "yesROW", "hasSRDF", "hasRUF", "hasNRUF", "hasRRDP", "hasDDP", "hasMRDP", "hasRRDEF", "hasURMF", "HasRRDP", "hasUMF", "HasRDP", "hasRRdf", "hasROW", "hasUDF", "yesDMF", "hasNRFD", " hasRMF", "HasRRDF", "hasRdf", " hasRUF", "HasRDEF", "yesDOW", " hasRFD", "hasURDF", "hasSRdf", "hasRRUF", "yesDDF", "hasSRDEF", "hasURUF", "hasMRdf", "hasMRDF", " hasRRFD", "hasRRDF", "yesRDF", "hasURFD", "yesRMF", "yesRDP", "HasRRDEF", "HasRdf", " hasRRMF", " hasRRDF", "hasRFD", "hasDMF", "HasRDF", "hasRDEF", "HasRRdf", "hasDOW", "hasDDF", "hasRDP", "hasRRFD", "hasRRMF", "hasNRDF", "yesDDP"]}}
{"id1": "14877116", "id2": "8135072", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 1, "substitutes": {"cpFile": [" copyfile", " copyFiles", "Copyfile", "cpCode", " cpFiles", "cpfile", " cpCode", " cpfile", "CopyFiles", " copyCode", "CopyCode", " copyFile", "CopyFile", "cpFiles"], "source": ["resource", "scene", "route", "subject", "use", "token", "seed", "project", "zip", "string", "current", "site", "host", "context", "Source", "view", "table", "channel", "service", "scope", "self", "node", "ource", "path", "from", "force", "slice", "this", "dest", "database", "ce", "object", "archive", "unit", "template", "grade", "connection", "base", "document", "element", "server", "url", "component", "config", "iter", "SOURCE", "start", "image", "Target", "remote", "se", "directory", "secure", "ources", "type", "null", "parent", "stream", "client", "name", "file", "reference"], "target": ["folder", "resource", "root", "route", "token", "external", "owner", "project", "global", "current", "host", "site", "table", "proxy", "service", "self", "copy", "transform", "ource", "path", "force", "tail", "sync", "dest", "arget", "database", "download", "client", "object", "content", "origin", "boot", "archive", "alias", "it", "connection", "base", "port", "server", "url", "component", "config", "other", "iter", "director", "home", "top", "format", "Target", "to", "remote", "result", "next", "reference", "nt", "type", "range", "output", "null", "parent", "master", "name", "tor", "file", "template"], "replace": ["inline", "root", "share", "route", "align", "use", "rm", "include", "append", "reply", "fill", "cover", "remove", "copy", "same", "protect", "match", "move", "only", "force", "add", "sync", "place", "compatible", "repeat", "re", "store", "insert", "rel", "flash", "placed", "delete", "complete", "array", "other", "allow", "hide", "split", "repl", "apply", "change", "range", "reset", "follow", "write", "multiple", "update", "stall"], "bufferSize": ["queueSize", "byteSize", "queueCount", " buffersize", "byteLen", "serversize", "bufferLen", "bufferSIZE", " bufferSIZE", "queueLen", "queuesize", " bufferLen", "bytesize", "flushSize", "buffersize", "flushSIZE", "serverSIZE", "bufferCount", "flushLen", "serverLen", " bufferCount", "serverSize", "flushsize", "byteCount"], "src": ["resource", "sh", "zip", "rec", "Source", "ruby", "proxy", "input", "copy", "ource", "ctx", "inst", "sc", "sr", "sys", "dest", "sync", "rt", "in", "archive", "fn", "loc", "flash", "proc", "gb", "reflect", "rc", "tmp", "server", "cur", "url", "bc", "sl", "sb", "gz", "start", "socket", "cb", "result", "RC", "ssl", "secure", "ser", "ources", "obj", "req", "sub", "stream", "sel", "rb", "sq"], "tarn": ["etarn", " tarm", "yern", "taran", "ttron", "tharo", "etreen", "yaran", "tarm", "taro", "thern", " tern", "Tarm", "wtarm", "tron", "ttaron", "Treen", " tron", "yarn", "taron", "ttaro", "etann", "ntaron", " taur", "ttarp", " treen", "taur", "wtern", "tarp", " tann", "ttarn", "Tann", "tann", "ntarn", "Trn", "trn", "tern", "thaur", " trn", "wtaran", "Taran", "Tron", "treen", "Tarn", "tharn", "wtarn", "ttaur", "ttrn", "etaran", "ttarm", "ntann", " taran", "yarm", "ttann", " taron", "ntarp", " tarp", " taro", "ttern"], "tardir": ["tardsdir", "tildiri", "sardir", "Tartir", "Tardiri", "Tardir", "tildart", "tildar", "Tartar", "Tardirs", "sardirt", "tartirt", "tardar", "tarpirt", "tartiri", "tardsar", "sardsar", "tardire", "tartir", "tarddir", "tardsire", "tardsir", "tartart", "sardsir", "sardsirt", "Tartirs", "tarpar", "Tardar", "Tartart", "tarart", "sardire", "sardar", "tarpir", "tardart", "tarpire", "tariri", "tardedpath", "tartire", "tartar", "Tardart", "Tartiri", "tartpath", "tardedirs", "tarar", "tardiri", "tardeddir", "tardpath", "tardedir", "tardsirt", "tardspath", "tardirt", "tarir", "Tartdir", "tartdir", "tardirs", "sardsire", "tildir", "Tartpath", "Tarddir", "tartirs", "tardsirs", "Tardpath"], "n": [" i", "nb", "pn", "u", "nw", "N", "k", "c", "g", "m", "o", "d", "na", "dn", "z", "norm", "none", "number", "nn", "in", "num", "min", "nor", "conn", "fn", "p", "l", "ng", "cn", "j", "mn", "coll", "sn", "x", "e", "ns", "nl", "i", "ni", "rn", "ne", "v", "nt", "en", "nc", "nu", "ln", "un"], "tar": ["temp", "large", "cloud", "war", "cat", "sh", "zip", "ca", "ray", "safe", "raf", "sum", "copy", "shr", "tg", "shape", "tan", "di", "box", "sr", "dest", "skip", "tr", "cro", "archive", "ra", "trans", "flash", "cr", "tf", "tif", "csv", "tmp", "ar", "dr", "cos", "gz", "tc", "transfer", "test", "sv", "pack", "jar", "rar", "car", "buffer", "par", "Tar", "file"], "bytes": ["pages", "reads", "Bytes", "classes", "words", "bs", "bps", "resources", "lines", "ones", "values", "eps", "io", "bits", "outs", "bles", "os", "objects", "files", "boot", "seconds", "tes", "steps", "nets", "pieces", "cells", "out", "vs", "ls", "ops", "keys", "blocks", "frames", "vals", "data", "runs", "items", "ipes", "b", "ps", "es", "les", "rows"], "readn": ["findne", "findlen", "findN", " readlen", "Readn", "writelen", "ReadN", "writeno", "passN", "readne", " readne", "writen", "readl", "passno", " readN", "Readlen", "readlen", "writeN", "readns", "runl", "writens", "runno", "readno", "runlen", "passns", "runn", " readl", "Readl", "runns", "runN", "readN", "writene", "passn", "findn"]}}
{"id1": "9275622", "id2": "4118412", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", " copyFiles", "transferFile", "moveFiles", "movefile", " copyFolder", "moveFolder", "copyfile", "copyFolder", "transferFiles", "copyFiles", "transferFolder", "moveFile", "transferfile"], "_file1": ["_zip1", "_files2", "_mail01", "_resourceOne", "_zipone", "_fileFirst", "_files01", "_File01", "_file01", "_mail1", "_fileOne", "_fFirst", "_f1", "_fileone", "_mail2", "_files0", "_file0", "_File1", "_zipOne", "_File2", "_files1", "_fOne", "_resourceone", "_resourceFirst", "_zipFirst", "_fone", "_resource1", "_File0", "_mail0"], "_file2": [" _file3", "_playsecond", "_files2", "jmodelsecond", "jfile5", "_modelsecond", "_play4", "_file3", "_files4", "_file5", "jmodel5", "_play1", "jfilesecond", " _filesTwo", " _file4", "_model2", "_model1", "_play2", "_filesecond", " _files3", "_playTwo", "_model5", "_File5", "jmodel1", "jmodel2", " _files2", " _fileTwo", "jfile2", "_File1", "_File2", " _files4", "_filesTwo", "_play5", "_fileTwo", "jfile1", "_play3", "_files3", "_Filesecond", "_file4"], "fis": ["lfis", "cfiss", "Fiss", " fais", "cfas", "afis", "infils", "infos", "fils", " fiss", "infiss", "afi", "fris", "Fils", "infis", "fas", "fais", "afais", "afiss", " fi", " fas", "fi", " fris", "Fis", "lfiss", " fils", "cfis", "Fos", "lfais", "cfris", "lfi", "Fris", "fiss", "Fas", "cfos"], "fos": ["Fros", "Foses", "fus", "goses", "infios", "infus", "lOS", "flos", "floes", "fo", "gos", "Foos", " foos", "fios", "infos", "pis", "foos", "loes", "gis", "poes", "faos", " fios", "pOS", "Fus", "fros", " fo", "flOS", "pos", "los", "foes", " fus", "fOS", "feus", "flis", "Fis", "gus", "infoos", "foses", "infaos", "Fos", "feoses", "feis", "Fios", " faos", "infros", "Faos", "lis", "feos", " fros", "Fo", "info"], "canalFuente": ["canalFuze", "canalBuencia", "canalsBuente", "canaledFuje", "canaledBuente", "canalBuze", "canalSuze", "canaledBuestro", "canaledFuestro", "canallFuencia", "canalFuestro", "canalCraento", "canalsFuento", "canalBuje", "canallFuze", "canalsBuence", "canalFUente", "canalKuente", "canalsFuencia", "canalSuente", "canalFUestro", "canalsBuencia", "canalKuze", "canalFuento", "canalFUencia", "canalsFuente", "canalKuencia", "canalFUze", "canaledBuze", "canallFuente", "canalCraencia", "canalFuencia", "canalBuente", "canalKuence", "canallFuence", "canallBuencia", "canalFUence", "canalKuento", "canalBuento", "canalBuence", "canaledFuze", "canalsBuento", "canallBuente", "canalFUje", "canalFuje", "canalCraence", "canaledFuente", "canalSuestro", "canallBuze", "canalFuence", "canalsFuence", "canalCraente", "canallBuence", "canalSuje", "canaledBuje", "canalBuestro"]}}
{"id1": "1485383", "id2": "7044685", "code1": "    private void runGetAppListing() {\n        DataStorage.clearAppListings();\n        GenericUrl url = new GoogleUrl(EnterpriseMarketplaceUrl.generateAppListingUrl() + DataStorage.getVendorProfile().vendorId);\n        AppListingList appListingList;\n        try {\n            HttpRequest request = requestFactory.buildGetRequest(url);\n            request.addParser(jsonHttpParser);\n            request.readTimeout = readTimeout;\n            HttpResponse response = request.execute();\n            appListingList = response.parseAs(AppListingList.class);\n            if (appListingList != null && appListingList.appListings != null) {\n                operationStatus = true;\n                DataStorage.setAppListings(appListingList.appListings);\n            }\n            response.getContent().close();\n        } catch (IOException e) {\n            AppsMarketplacePluginLog.logError(e);\n        }\n    }\n", "code2": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "label": 0, "substitutes": {"runGetAppListing": ["runGetApplicationlistings", "runGetApplicationListling", "runGetApplistling", "runGetApplistings", "runGetAppListings", "runGetApplistInfo", "runGetAppListling", "runGetAppSearchling", "runGetAppSupportInfo", "runGetAppSupporting", "runGetApplicationlisting", "runGetApplicationListings", "runGetAppSupportling", "runGetApplicationListInfo", "runGetAppSearching", "runGetApplisting", "runGetAppSearchings", "runGetAppSearchInfo", "runGetAppListInfo", "runGetApplicationlistling", "runGetApplicationlistInfo", "runGetApplicationListing", "runGetAppSupportings"], "url": ["resource", "route", "string", "channel", "href", "host", "http", "proxy", "service", "URL", "path", "api", "feed", "Url", "json", "download", "address", "build", "l", "connection", "base", "server", "location", "config", "f", "e", "i", "image", "page", "result", "ssl", "data", "b", "uri", "buffer", "client", "source", "re", "builder", "file"], "appListingList": ["appListininglist", "appListingsL", "appListingL", "appListgingList", "appListningEx", "appListningGroup", "appListeningInfo", "appListINGList", "appListitingEx", "appListingsList", "appListdingLayer", "appListitinglist", "appListingsData", "appListdingList", "appListningData", "appListINGL", "appPoolinglist", "appListingLayer", "appListingGroup", "appStingList", "appListingingType", "appListillingType", "appListeningMap", "appListninglist", "applistingEx", "appHoldinginglist", "appListeningList", "appStingLayer", "appListgingInfo", "appHoldingingType", "appLingInfo", "appListningList", "appLeningEx", "appHoldingingList", "appListingsMap", "appStINGEx", "appListgingEx", "appListingingGroup", "applistningData", "applistingList", "appHoldingType", "appListdingEx", "appLeningInfo", "appStingL", "appListitingType", "appPooliningList", "appListingsResult", "appListingEx", "appListingData", "applistingData", "appListitingResult", "appPoolininglist", "appListillingList", "appStingEx", "appStINGList", "appLingEx", "appPooliningGroup", "appLingList", "appStINGLayer", "appListitingLibrary", "appHoldingingLibrary", "appListINGLayer", "appListitingData", "appListiningGroup", "appLingMap", "appStINGL", "appListingType", "appListiningList", "appListningResult", "applistningList", "appListinginglist", "appListingLibrary", "appListingResult", "appListingsLayer", "appListinglist", "appHoldingLibrary", "appListingingList", "appListingsEx", "appPoolingList", "applistningResult", "applistningEx", "applistingResult", "appHoldinglist", "appLeningMap", "appListillingLibrary", "appListillinglist", "appHoldingList", "appListingsInfo", "appListingInfo", "appLeningList", "appListingMap", "appListgingMap", "appListINGEx", "appListeningEx", "appPoolingGroup", "appListingingLibrary", "appListdingL", "appListitingList"], "request": ["resource", "application", "use", "project", "push", "xml", "call", "Request", "method", "http", "service", "condition", "proxy", "input", "report", "have", "queue", "post", "json", "object", "child", "address", "user", "build", "command", "hello", "rate", "server", "query", "get", "complete", "e", "trip", "q", "callback", "writer", "transfer", "result", "page", "next", "remote", "parse", "req", "r", "job", "message", "uri", "buffer", "client", "re", "builder", "create"], "readTimeout": [" readSocket", "readingSocket", "writetimeout", "readingtimeout", "readSocket", "writeTime", "readTime", "writeSocket", "readtimeout", "readAttempt", " readTime", "readertimeout", "writeTimeout", "readingTimeout", "readerTimeout", " readtimeout", "readerTime", "readerAttempt", "readingTime", "readingAttempt", "writeAttempt"], "response": ["Response", "resource", "application", "status", "full", "respond", "site", "reply", "http", "version", "report", "api", "wave", "feed", "onse", "json", "object", "resp", "connection", "generation", "document", "server", "array", "e", "success", "received", "image", "writer", "res", "result", "page", "next", "output", "error", "data", "message", "stream", "client", "body", "re"]}}
{"id1": "335223", "id2": "3430784", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "1508161", "id2": "3767903", "code1": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"conMail": [" sendContact", " submitEmail", " sendEmail", " parseEmail", " parseContent", " sendMail", " submitContact", " parseMail", " uploadContact", " sendContent", " uploadContent", " uploadMail", " submitContent", " parseContact", " submitMail", " uploadEmail"], "mail": ["item", "il", "local", "Mail", " email", "class", "ml", "Email", "multi", "zip", "mand", "m", "request", "call", "xml", "view", "proxy", "service", "log", "open", "match", "key", "post", "email", "content", "object", "letter", "user", "build", "l", "base", "order", "del", "element", "ship", "model", "mass", "server", "load", "mill", "event", "f", "mo", "e", "pkg", "link", "el", "gmail", "html", "ssl", "test", "follow", "data", "mails", "md", "id", "message", "update", "sel", "body", "name", "file"], "client": ["resource", "project", "cache", "host", "request", "method", "http", "call", "service", "self", "con", "api", "contact", "force", "this", "driver", "ce", "conn", "object", "handler", "bird", "app", "connection", "base", "l", "server", "config", "cli", "session", "i", "socket", "ssl", "plugin", "web", "uri", "Client", "et"], "url": ["resource", "route", "string", "channel", "href", "host", "request", "method", "http", "service", "www", "URL", "path", "ur", "feed", "key", "Url", "email", "download", "address", "up", "l", "connection", "base", "server", "config", "sl", "f", "e", "ssl", "data", "id", "web", "uri", "name", "file"], "get": ["resource", "pull", "send", "g", "GET", "call", "invoke", "service", "gets", "api", "open", "post", "json", "Get", "build", "connection", "show", "exec", "find", "load", "query", "server", "read", "like", "cli", "session", "set", "start", "check", "next", "parse", "req", "put", "info", "uri", "update", "body", "create", "end"], "response": ["Response", "resource", "application", "status", "full", "respond", "environment", "reply", "request", "api", "wave", "feed", "onse", "Entity", "json", "object", "re", "resp", "document", "connection", "event", "server", "e", "success", "received", "res", "remote", "result", "page", "output", "error", "data", "message", "body", "collection"], "entity": ["resource", "entry", "application", "instance", "em", "environment", "xml", "comment", "ee", "node", "api", "Entity", "json", "email", "ce", "content", "object", "unit", "om", "document", "connection", "collection", "agent", "element", "pe", "model", "ity", "event", "coll", "server", "article", "e", "el", "image", "page", "result", "output", "error", "data", "ent", "esi", "message", "body", "et", "file", "person"], "doc": ["dc", "resource", "struct", "pc", "line", "map", "m", "Doc", "exp", "xml", "d", "desc", "Document", "content", "div", "dir", "unit", "oc", "dict", "valid", "up", "document", "pos", "coll", "dr", "f", "lib", "html", "page", "data", "docs", "md", "po", "message", "DOC", "uri", "text", "body", "db", "file", "dec"], "msg": ["ug", "ms", "g", "map", "m", "op", "urg", "xml", "title", "str", "comment", "ge", "log", "desc", "char", "mess", "agg", " ms", "content", "loc", "err", "ag", "db", "cmd", "reg", "dr", "pkg", "code", "Msg", "html", " desc", "error", "data", "type", "gen", "md", "req", "comm", "id", "message", "info", "text", "mid", "reason"]}}
{"id1": "9096319", "id2": "20855053", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "label": 0, "substitutes": {"handleNodeRegainedService": ["handleNodeRegainingService", "handleNodeReginedServices", "handleNodeRegainsService", "handleNoderegainsEvent", "handleNodeRegainingEvent", "handleNodeReginedService", "handleNoderegainsService", "handleNodeRegainedEvent", "handleNodeReginedEvent", "handleNodeRegainedServices", "handleNodeRegainsEvent", "handleNoderegainsServices", "handleNoderegainedService", "handleNoderegainedEvent", "handleNodeRegainingServices", "handleNoderegainedServices", "handleNodeRegainsServices"], "eventID": ["issueID", "serviceTime", " eventName", "issueName", " eventid", "serviceId", "updateName", "issueid", "serviceid", "nodeTime", "updateid", "updateID", "serviceName", "eventId", " eventId", "eventid", "updateId", "nodeName", "issueId", "eventName", "nodeId"], "nodeID": [" nodeResult", " nodeName", " nodeRI", "globalid", "globalID", "eventPath", " nodePath", "resourceID", "serviceId", "odeName", "siteid", " nodeKey", "sourceId", "eventResult", "odeID", "sourceID", "objectName", "odeId", "serviceid", "objectid", "resourceKey", "resourceId", "nodeResult", "odeResult", " nodeId", "nodeKey", "nodeid", "eventId", "eventid", "nodePath", "packageId", "objectID", "nodeRI", "packageID", "siteID", "odeRI", "siteName", "nodeName", "siteId", "sourceRI", "eventName", "nodeId", "globalId", "globalPath", "objectId", "eventKey", "packageid", " nodeid"], "ipAddr": ["ipAddrt", " ipApprs", " ipAttr", "ipAder", " ipAddrs", "ipAppvr", "ipAttr", " ipAddress", "ipaddri", " ipAddvr", "ipCher", "IPAddressrs", "IPAddressn", " ipAppvr", "ipadder", "ipaddrs", " ipAttvr", "ipAddresser", "ipAddressn", "ipAddressvr", "ipAddressr", "IPAddr", "ipAddressrs", " ipAdder", " ipAttrs", "ipApprs", "ipOffrs", "ipAddn", "ipaddvr", "ipAdn", "IPAddrs", "IPAddressr", " ipAtter", "IPAddrt", "ipAddressri", "ipAdder", "IPAddressri", "ipChn", "ipOffrt", "ipAddressress", "ipAdr", " ipAppr", "ipAddri", "ipAddressrt", "ipChr", "ipaddress", " ipAttri", "ipAddress", "ipAppr", "ipAddvr", "ipAttvr", "ipAddrs", "ipAtter", "ipChrs", "IPAddn", "ipAttri", " ipAddri", "IPAdder", "ipOffri", "ipOffr", "ipAttrs", "IPAddressrt", "IPAddri", "IPAddresser", "ipAdrs", "ipaddr"], "serviceID": [" serviceX", "skillName", "skillId", "serverId", "featureHandle", " serviceType", "serviceHandle", "skillID", " serviceName", " serviceIDs", "serverName", "featureId", "resourceID", "skillNAME", "serviceId", "featureIP", "eventX", "serviceX", " serviceNAME", "serverX", " serviceHandle", " serviceIP", "resourceId", "ServiceName", "resourceType", "serviceName", "serviceNAME", " serviceId", "serverID", "eventId", "eventIDs", "serviceIDs", "ServiceNAME", "ServiceType", "processName", "featureID", "serviceIP", "eventName", "ServiceIDs", "ServiceIP", "ServiceId", "processID", "ServiceHandle", "serviceType", "processId", "ServiceID"], "eventTime": ["errorTIME", "eventPoint", "EventName", "errorType", " eventPoint", " eventTim", " eventName", "errorTime", "eventType", "processTime", "EventTim", "EventID", "changeType", "eventTim", "errorPoint", "EventTime", "eventTIME", "changeTIME", "processName", "processTim", "eventName", "changeTime", "processID", " eventType", " eventTIME", "changePoint"], "log": ["or", "entry", "ch", "temp", "cat", "full", "c", "blog", "host", "cache", "exp", "call", "http", "tool", "pl", "ge", "path", "lex", "feed", "key", "conn", "bug", "build", "it", "cl", "l", "connection", "w", "tag", "net", "out", "pe", "event", "Log", "port", "model", "get", "thread", "plug", "config", "sec", "url", "contract", "pool", "crit", "stop", "format", "stat", "lo", "level", "type", "gen", "error", "output", "write", "LOG", "debug", "put", "sign", "fail", "info", "og", "lock", "com", "loop", "db"], "dbConn": ["realColl", "databaseconn", "dbConnection", "dbconn", "databaseLoc", "cbConn", "cbConnect", "bbconn", "fbCon", "Dbconn", "databaseConn", " dbCon", "dbCt", " dbLoc", "bbCon", " dbConnect", "fbCt", "DbConnection", "logconn", "DBConnect", "dbLoc", "databaseConnection", "DBConn", "realCon", "DbLoc", "logDb", "DBCon", " dbconn", "logConn", "bbConnect", "realConn", "logConnect", "DbCt", " dbColl", "fbColl", "bbConnection", "DbConn", "dbConnect", " dbCt", "cbconn", "DbDb", "dbColl", "DBconn", "dbCon", "bbConn", "DBConnection", "realCt", "DBCt", "fbConn", "DbConnect", " dbDb", " dbConnection", "dbDb", "cbConnection"], "outageUpdater": ["outageuplaser", "outageuplusher", "outageUpraser", "outageUpdarer", "outageUpfatter", "outageUpdatatter", "outageUdater", "outageUpdrator", "outageChdoder", "outageUnaser", "outageUpdrarer", "outageUpnager", "outageUpdatarer", "outageUpndter", "outageUpdatater", "outageUpratter", "outageupdatter", "outageUptaser", "outageUpnaser", "outageUpndatter", "outageChdroder", "outageUpdatable", "outageUpdatedapper", "outageupdaser", "outageUpmager", "outageUpdroder", "outageUpnoster", "outageUpnater", "outageUppter", "outageUpdrusher", "outageUtdarter", "outageUtdatatter", "outageupdusher", "outageAppdater", "outageUpdatedrATER", "outageUpdator", "outageUpdatedaser", "outageAppnter", "outageUpdatedratable", "outageChdater", "outageUpstater", "outageAppdager", "outageAppnator", "outageUptatable", "outageUpdATER", "outageUnarer", "outageUdaser", "outageUplaser", "outageUppatter", "outageupdater", "outageUdarer", "outageUpnoder", "outageUpdusher", "outageUpnter", "outageUplater", "outageUnater", "outageUpdaser", "outageUpfapper", "outageUpdrater", "outageUplusher", "outageUpdatedraser", "outageUppATER", "outageuplater", "outageUpfaser", "outageChdoster", "outageAppdator", "outageUpdraser", "outageUprater", "outageUpdoder", "outageUplatter", "outageUpdatATER", "outageUpmator", "outageChdator", "outageUpdatedATER", "outageUpdatarter", "outageUpnator", "outageUppaser", "outageUpdatatable", "outageAppnater", "outageUpnarer", "outageUplapper", "outageUpdataser", "outageUtdter", "outageUpparter", "outageUpdsoder", "outageUprusher", "outageUpdapper", "outageUptater", "outageUpndater", "outageAppdter", "outageUpnATER", "outageUpfater", "outageUpdarter", "outageUpmter", "outageChdrater", "outageUnATER", "outageUpdatedatable", "outageUpdratter", "outageUtdater", "outageUpstager", "outageUtdatarter", "outageUpdter", "outageUpdroster", "outageUpdatedater", "outageUpdatedrater", "outageUpndarter", "outageUpstator", "outageChdroster", "outageUpdager", "outageChdrator", "outageUtdatter", "outageUpdatter", "outageUpdrapper", "outageUpdsater", "outageUpmater", "outageUpdatedrapper", "outageUpdsator", "outageUpdsoster", "outageUpdoster", "outageUpdratable", "outageUpdatedrarer", "outageUpdrATER", "outageUdATER", "outageUptarer", "outageUppater", "outageUtdatater", "outageUpdatedarer", "outageUpdatedratter", "outageAppnager", "outageUpdatedatter", "outageuplatter", "outageUpstter"]}}
{"id1": "1508161", "id2": "16142024", "code1": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 0, "substitutes": {"conMail": [" sendContact", " submitEmail", " sendEmail", " parseEmail", " parseContent", " sendMail", " submitContact", " parseMail", " uploadContact", " sendContent", " uploadContent", " uploadMail", " submitContent", " parseContact", " submitMail", " uploadEmail"], "mail": ["item", "il", "local", "Mail", " email", "class", "ml", "Email", "multi", "zip", "mand", "m", "request", "call", "xml", "view", "proxy", "service", "log", "open", "match", "key", "post", "email", "content", "object", "letter", "user", "build", "l", "base", "order", "del", "element", "ship", "model", "mass", "server", "load", "mill", "event", "f", "mo", "e", "pkg", "link", "el", "gmail", "html", "ssl", "test", "follow", "data", "mails", "md", "id", "message", "update", "sel", "body", "name", "file"], "client": ["resource", "project", "cache", "host", "request", "method", "http", "call", "service", "self", "con", "api", "contact", "force", "this", "driver", "ce", "conn", "object", "handler", "bird", "app", "connection", "base", "l", "server", "config", "cli", "session", "i", "socket", "ssl", "plugin", "web", "uri", "Client", "et"], "url": ["resource", "route", "string", "channel", "href", "host", "request", "method", "http", "service", "www", "URL", "path", "ur", "feed", "key", "Url", "email", "download", "address", "up", "l", "connection", "base", "server", "config", "sl", "f", "e", "ssl", "data", "id", "web", "uri", "name", "file"], "get": ["resource", "pull", "send", "g", "GET", "call", "invoke", "service", "gets", "api", "open", "post", "json", "Get", "build", "connection", "show", "exec", "find", "load", "query", "server", "read", "like", "cli", "session", "set", "start", "check", "next", "parse", "req", "put", "info", "uri", "update", "body", "create", "end"], "response": ["Response", "resource", "application", "status", "full", "respond", "environment", "reply", "request", "api", "wave", "feed", "onse", "Entity", "json", "object", "re", "resp", "document", "connection", "event", "server", "e", "success", "received", "res", "remote", "result", "page", "output", "error", "data", "message", "body", "collection"], "entity": ["resource", "entry", "application", "instance", "em", "environment", "xml", "comment", "ee", "node", "api", "Entity", "json", "email", "ce", "content", "object", "unit", "om", "document", "connection", "collection", "agent", "element", "pe", "model", "ity", "event", "coll", "server", "article", "e", "el", "image", "page", "result", "output", "error", "data", "ent", "esi", "message", "body", "et", "file", "person"], "doc": ["dc", "resource", "struct", "pc", "line", "map", "m", "Doc", "exp", "xml", "d", "desc", "Document", "content", "div", "dir", "unit", "oc", "dict", "valid", "up", "document", "pos", "coll", "dr", "f", "lib", "html", "page", "data", "docs", "md", "po", "message", "DOC", "uri", "text", "body", "db", "file", "dec"], "msg": ["ug", "ms", "g", "map", "m", "op", "urg", "xml", "title", "str", "comment", "ge", "log", "desc", "char", "mess", "agg", " ms", "content", "loc", "err", "ag", "db", "cmd", "reg", "dr", "pkg", "code", "Msg", "html", " desc", "error", "data", "type", "gen", "md", "req", "comm", "id", "message", "info", "text", "mid", "reason"]}}
{"id1": "12197169", "id2": "189963", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"read": ["ready", "run", "println", "readable", "reading", "request", "continue", "report", "open", "process", "download", "print", "Read", "init", "replace", "get", "load", "work", "check", "start", "reader", "parse", "write", "loop", "stream", "create", "end"], "in": ["In", "fr", "token", "again", "at", "of", "ini", "c", "n", "IN", "scan", "o", "ex", "is", "din", "inner", "bin", "input", "path", "log", "con", "io", "from", "cms", "ins", "doc", "on", "min", "conn", "inn", "er", "ing", "err", "it", "l", "isin", "connection", "s", "out", "server", "url", "index", "f", "e", "by", "nin", "a", "image", "login", "ssl", "reader", "error", "data", "r", "b", "inc", "id", "info", "buffer", "stream", "source", "file"], "line": ["inline", "entry", "row", "status", "string", "lines", "col", "LINE", "ine", "str", "comment", "le", "Line", "ge", "log", "key", "object", "unit", "frame", "l", "L", "lin", "cell", "url", "sl", "f", "link", "e", "code", "value", "el", "record", "val", "page", "ne", "reader", "se", "data", "parse", "b", "id", "message", "lf", "source", "buffer", "text", "block", "name", "file", "lc", "end"], "i": ["si", "qi", "u", "ip", "n", "ii", "ini", "pi", "o", "is", "abi", "ci", "di", "io", "slice", "ui", "ri", "bi", "ie", "p", "l", "phi", "j", "I", "eni", "x", "fi", "ski", "index", "f", "e", "oi", "li", "ori", "ni", "gi", "ti", "ai", "b", "zi", "xi", "info", "ix", "uni"], "logDatum": ["logDatatum", "exDDam", "logDatata", "logDum", "logDData", "exDDatum", "logDDam", "logdata", "logDsict", "LogData", "logDam", "logDatam", "logDictionary", "LogDatum", "logdict", "logDsatum", "logDatict", "logFam", "logDsum", "logdum", "Logdum", "exDam", "LogDum", "logDatictionary", "LogDict", "exData", "logFatum", "logDict", "logFata", "Logdatum", "exDDictionary", "logData", "logdatum", "logDDatum", "logDDictionary", "logFictionary", "Logdict", "exDictionary", "exDatum", "logDsata", "exDData", "Logdata"]}}
{"id1": "14650352", "id2": "15810440", "code1": "    boolean checkIfUserExists(String username) throws IOException {\n        try {\n            URL url = new URL(WS_URL + \"/user/\" + URLEncoder.encode(username, \"UTF-8\") + \"/profile.xml\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.connect();\n            InputStream is = conn.getInputStream();\n            is.close();\n            return true;\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n    }\n", "code2": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"checkIfUserExists": ["checkIfUserExist", "checkIfUserexists", "checkIfuserexists", "checkIfUserexisting", "checkIfuserexes", "checkIfUserLists", "checkIfUserListing", "checkIfUserContes", "checkIfuserexist", "checkIfUserexes", "checkIfUserLes", "checkIfUserContists", "checkIfuserexisting", "checkIfuserExisting", "checkIfUserexist", "checkIfUserContisting", "checkIfUserList", "checkIfUserExisting", "checkIfUserContist", "checkIfuserExist", "checkIfuserExists", "checkIfuserExes", "checkIfUserExes"], "username": ["role", "token", "uu", "subject", "u", "description", "string", "method", "sudo", "title", "uid", "family", "path", "key", "auth", "database", "email", "user", "address", "me", "USER", "profile", "staff", "nick", "password", "home", "filename", "ame", "mobile", "login", "ername", "directory", "data", "account", "users", "uri", "text", "name"], "url": ["resource", "string", "blog", "host", "channel", "http", "www", "URL", "path", "ll", "log", "ur", "api", "feed", "Url", "impl", "user", "address", "object", "build", "loc", "browser", "l", "connection", "base", "ls", "aur", "server", "sl", "f", "uc", "page", "ssl", "bb", "fl", "b", "web", "uri", "client", "org", "file"], "conn": ["dc", "ch", "n", "c", "Connection", "act", "col", "http", "Conn", "ann", "conv", "ci", "dn", "ctx", "con", "open", "co", "os", "rt", "ct", "cf", "loc", "p", "connection", "cn", "rc", "cp", "ls", "cur", "cos", "cs", "enc", "cli", "ns", "h", "close", "cb", "ssl", "nt", "ai", "conf", "nc", "connect", "org", "lc"], "is": ["us", "ms", "ip", "isa", "serv", "bs", "ios", "ens", "isl", "css", "act", "iris", "has", "as", "abs", "api", "ais", "os", "IS", "ui", "in", "ins", "it", "fs", "err", "app", "Is", "ls", "vs", "iss", "iso", "cos", "its", "isi", "isc", "i", "ori", "bis", "ai", "info", "ris", "ss"]}}
{"id1": "5399593", "id2": "10214218", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"encrypt": ["encryption", "decryption", " encress", " encryption", "decrypt", "decress", "encipher", "escrypt", "escress", "escipher", "decipher", " encipher", "escryption", "encress"], "plaintext": ["singleText", "ainform", "singletext", "forecontent", "singleTEXT", "plaincontent", " plainform", "ainTEXT", "ainText", "foreText", " plainTEXT", "plainform", "plainTEXT", "foretext", "aintext", "raincontent", " plainText", "raintext", "rainTEXT", "foreTEXT", " plaincontent", "singleform", "rainText", "plainText"], "UnsupportedEncodingException": ["UnsupportedCodingEx", "UnsupportedEncryptionError", "UnsupportedEncgorithmEx", "UnsupportedCodedEx", "UnsupportedEncodedException", "UnsupportedEncryptionEx", "UnsupportedEncryptionException", "UnsupportedEncgorithmError", "UnsupportedEncodingEx", "UnsupportedEncodedError", "UnsupportedEncodedEx", "UnsupportedCodingException", "UnsupportedCodedError", "UnsupportedCodingError", "UnsupportedCodedException", "UnsupportedEncodingError", "UnsupportedEncgorithmException"], "md": ["dc", "mb", "mp", "mg", "hed", "ms", "pm", "od", "mage", "mand", "rm", "mac", "map", "m", "Cmd", "mem", " MD", "d", "sha", "hm", "sum", "MD", "bd", "meta", "wd", "hd", "dd", "mc", "cd", "mod", "cmd", "mn", "ma", "mag", "code", "am", "dm", "material", "nm", "amd", "dig", "mm", "metadata", "po", "bf", "message", "mad", "mt", "me", "mu", "db", "mo"], "raw": ["wrap", "row", "full", "clean", "instance", "aws", "initial", "unknown", "sha", "input", "micro", "empty", "hex", "buf", "original", "ack", "shared", "missing", "alpha", "flash", "ng", "rew", "load", "array", "enc", "Raw", "serial", "blocks", "unsigned", "ghost", "null", "sign", "RAW", "message", "buffer", "block", "dec"], "hash": ["hed", "sh", "mac", "cache", "string", "Hash", "rh", "secret", "ruby", "sha", "sum", "abi", "log", "hh", "hex", "key", "auth", "ashes", "header", "kh", "build", "shared", "alpha", "flash", "ha", "base", "url", "math", "ash", "array", "code", "password", "image", "h", "html", "data", "id", "message", "text", "block", "version"]}}
{"id1": "7468819", "id2": "14038176", "code1": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"run": ["resource", "exit", "Run", "execute", "call", "open", "process", "download", "build", "running", "exec", "server", "url", "get", "work", "stop", "start", "check", "close", "login", "test", "runner", "debug", "loop", "update", "info"], "con": ["fa", "ctrl", "pc", "fc", "cm", "act", "c", "cas", "cache", "ca", "http", "cons", "Conn", "cover", "conv", "log", "ctx", "can", "open", "co", "sync", "pin", "cf", "ct", "client", "ran", "conn", "on", "cr", "cl", "connection", "cn", "rc", "cp", "ocon", "exec", "url", "cur", "x", "bc", "non", "per", "CON", "Con", "pre", "connect", "socket", "close", "plain", "login", "en", "conf", "sub", "ver", "rx", "re", "un"], "encodedPassword": ["enccodedPassword", "encoderAccount", "encodedpassword", "enccodedpassword", "enoderPassword", "encryptedpassword", "enccodedSecret", "decodedPassword", "encodedPass", "encoderSecret", "enodedPass", "enodedPassword", "deccodedPass", "decodedSecret", "encapedpassword", "encapedAccount", "encryptedPassword", "deccodedpassword", "enoderpassword", "encoderpassword", "enoderPass", "decodedPass", "encodedAccount", "enoderAccount", "enodedAccount", "encoderPass", "encryptedAccount", "encoderPassword", "encryptedPass", "encryptedSecret", "encapedPass", "encapedPassword", "decodedpassword", "encodedSecret", "deccodedPassword", "deccodedSecret", "enodedpassword", "enccodedPass"], "encoder": ["enode", "Encoded", "Encoder", "decoder", "encode", "enoder", "encoding", "Encoding", "decoding", "enoded", "decoded", "decode", "enoding", "Encode", "encoded"], "is": ["rss", "il", "us", "isa", "serv", "im", "ios", "isl", "act", "ir", "was", "iris", "ci", "as", "has", "can", "ais", "os", "IS", "rt", "in", "ins", "ri", "conn", "are", "inn", "re", "s", "Is", "out", "rc", "ls", "iss", "ar", "url", "get", "its", "isi", "isc", "i", "iri", "res", "bis", "ser", "ai", "isu", "r", "id", "es", "rs", "sel", "stream", "rx", "src", "ris"], "rd": ["rg", "rss", "pd", "rm", "respond", "ru", "rh", "d", "Rs", "dra", "fd", "bd", "rt", "rl", "mr", "RD", "ra", "lr", "dd", "cr", "ld", "rob", "ud", "dr", "ws", "rex", "nd", "rw", "td", "ds", "gd", "rn", "wr", "rod", "reader", "hr", "rr", "r", "rs", "stream", "rx", "rost", "rb", "fr", "xd"], "line": ["inline", "entry", "row", "string", "lines", "LINE", "str", "character", "comment", "Line", "continue", "log", "feed", "key", "content", "object", "letter", "header", "unit", "err", "cl", "l", "part", "lin", "pe", "cell", "url", "link", "code", "len", "i", "strip", "page", "reader", "output", "data", "error", "style", "r", "lf", "message", "buffer", "source", "text", "body", "re", "name", "lc", "end"], "response": ["Response", "resource", "rss", "application", "function", "serv", "description", "respond", "string", "respons", "site", "reply", "request", "secret", "version", "cover", "more", "report", "answer", "wave", "feed", "tree", "json", "second", "content", "object", "header", "audio", "default", "resp", "connection", "model", "server", "array", "value", "success", "image", "page", "memory", "output", "error", "data", "four", "esi", "message", "buffer", "uri", "binary", "body", "collection"], "lastIteraction": [" lastiteraction", "lastInteraction", " last_time", "last_it", "lastinterative", "last_ative", " last_action", "last_action", "lastintertime", " last_ative", "lastInterative", "lastIntertime", " lastiterit", " lastiterative", " last_it", "lastinterit", " lastitertime", "lastinteraction", "lastInterit", "lastiterative", "lastitertime", "lastiterit", "lastiteraction", "last_time"], "result": ["resource", "entry", "row", "pass", "status", "Result", "results", "secret", "answer", "report", "json", "user", "server", "query", "array", "date", "session", "success", "page", "next", "error", "account", "message", "info", "source", "lock"], "e": ["eu", "fe", "or", "je", "u", "n", "c", "g", "m", "oe", "o", "te", "d", "ee", "be", "this", "ke", "er", "eb", "ie", "err", "p", "l", "ception", "s", "ea", "pe", "j", "element", "exc", "x", "f", "E", "ite", "i", "ze", "a", "h", "ne", "ae", "error", "type", "se", "ev", "null", "r", "de", "t", "b", "ec", "esi", "es", "me", "ace"]}}
{"id1": "397240", "id2": "18097962", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "9261777", "id2": "9236363", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"source": ["resource", "token", "use", "seed", "project", "zip", "string", "Source", "request", "view", "spec", "proxy", "inner", "service", "scope", "comment", "input", "options", "ource", "copy", "path", "empty", "slice", "force", "dest", "in", "original", "address", "shared", "single", "unit", "sample", "missing", "rule", "base", "element", "prefix", "url", "query", "config", "size", "name", "index", "flat", "sl", "session", "strip", "SOURCE", "image", "start", "sin", "result", "secure", "se", "data", "parse", "style", "target", "null", "id", "parent", "uri", "text", "info", "src", "site", "file", "sort", "template"], "destination": ["dominated", "desturation", " destinating", " destipping", "destinations", "domination", " destinator", "dependension", "coordinating", "destinating", "destipping", " destension", "homeignment", "Destinations", "destinator", "Destinator", "Destinating", "coordination", "Destination", "homeinated", "databaseuration", "destinated", "Destinated", "homeination", " destignment", "Destinate", "homeinator", "destinate", "distipping", "Destignment", "coordinate", "dependination", "dependipping", "dependinated", "domuration", "databaseinated", " destinated", "dominations", "destignment", "distension", "distinated", "coordinator", " destinate", "distination", "databaseinations", "databaseination", "Desturation", "destension"], "is": ["ib", "ics", "or", "us", "ip", "isa", "ios", "serv", "zip", "bs", "ens", "isl", "ois", "osi", "ir", "ob", "act", "ii", "was", "iris", "oss", "ci", "as", "ic", "api", "abs", "ais", "IS", "io", "ui", "in", "ins", "ri", "are", "ie", "fs", "obs", "init", "s", "Is", "out", "iss", "iso", "ar", "ops", "eni", "cos", "get", "isi", "isc", "sis", "i", "ori", "sin", "close", "mis", "bis", "se", "lis", "ai", "nis", "esi", "id", "es", "info", "src", "ris"], "os": ["or", "ks", "js", "us", "ol", "ios", "so", "bs", "ens", "ob", "osi", "op", "ies", "o", "mos", "dos", "oa", "oss", "as", "oise", "io", "ais", "sys", "aos", "boot", "bos", "oes", "acs", "ose", "fs", "obs", "s", "nos", "pos", "out", "oS", "vs", "ls", "los", "ops", "cos", "ot", "Os", "i", "ds", "ori", "oses", "ros", "socket", "ou", "es", "ends", "OS", "ss", "ow"], "buffer": ["seed", "position", "string", "channel", "uffer", "limit", "padding", "copy", "layer", "wave", "sequence", "feed", "buf", "slice", "queue", "number", "pad", "address", "header", "batch", "base", "server", "url", "size", "read", "Buffer", "iter", "value", "image", "writer", "bytes", "transfer", "page", "border", "result", "reader", "bb", "data", "null", "b", "buff", "flush", "binary", "reference"], "length": ["distance", "row", "section", "line", "of", "position", "ob", "string", "full", "volume", "depth", "limit", "character", "total", "shape", "lower", "Length", "power", "partial", "division", "match", "sequence", "slice", "number", "feed", "key", "ring", "object", "address", "count", "age", "weight", "l", "part", "url", "get", "load", "left", "size", "index", "code", "len", "value", "strip", "split", "start", "quote", "last", "level", "reader", "type", "data", "range", "point", "style", "duration", "id", "offset", "lock", "block", "width", "end"]}}
{"id1": "2022160", "id2": "21824901", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"write": ["pipe", "run", "writ", "cycle", "send", "append", "call", "service", "copy", "export", "lex", "open", "feed", "process", "add", "sync", "Write", "play", "store", "w", "out", "exec", "size", "read", "wrote", "code", "dump", "set", "writer", "close", "next", "output", "writing", "written", "data", "put", "flush", "end", "update", "connect", "create", "kill", "flow"], "byteBuffers": ["ByteBuffers", "connectionBufferers", "bytebuffors", "bytesBuffapers", "bytebuffered", "connectionBuffers", "byteOffters", "bytePackerers", "bytesDefers", "bytebuffers", "byteOrdinals", "byteBuildatters", "byteInfatters", "byteAkizers", "ByteBufferers", "byteIntegeners", "byteChings", "wordBuffatters", " byteOrdiners", "byteAkelines", "wordBufferers", "bytesAkelines", "byteBuffelines", "bytesPackerers", "bytebuffinals", " byteOrdeners", "byteChERS", "ByteBuffERS", "byteBuffors", "byteCornered", "byteBuffinals", "bytesBufferers", "bytebuffelines", "connectionBuffeners", "bytesDefelines", "byteOffers", "byteHeadings", "bytesCornatters", "byteWriters", "byteIntegelines", "bytesDefERS", "byteBuilderers", " byteCompERS", " byteCompares", "byteInferers", " byteBuffinals", " byteOrdinals", "doubleBuffERS", "byteIntegERS", "byteBufferelines", "connectionbufferers", "byteOrdeners", "byteCompERS", "byteBuildERS", "doubleHeadered", "byteWritiners", "bytebuffizers", "ByteOrdERS", "byteOffERS", "byteBuffings", "doubleBuffers", "byteCornares", "bytesBuffors", " byteBuffiners", "byteIntegers", " byteBufferers", "byteWritors", "byteOrdlers", "bytebuffatters", "byteCorners", "byteDefers", "ByteOrderers", "doubleHeadERS", " byteBuffeners", "bytebuffings", "bytesBuffERS", "bytesBuffered", "byteCornERS", "byteCornlers", "byteInfers", "byteBuffatters", "byteBuffered", "byteBufferatters", "byteCompares", "byteBuffizers", "byteOrdiners", "byteBufflers", " byteOrdERS", "bytesPackERS", "byteCornatters", "ByteOrders", "byteAkors", "byteHeadered", "bytesAkers", "byteOrders", "byteBuffERS", "byteHeaders", "bytesBuffers", "byteBufferapers", "byteIntegatters", "bytebuffeners", "doubleBuffings", "doubleBuffered", " byteBuffters", "connectionbuffeners", " byteOffors", "byteAkers", "bytesPackapers", "bytesDefatters", "bytePackERS", "byteCompers", "bytebuffests", "connectionBuffERS", "bytesBuffelines", "byteWritlers", "byteWritizers", "byteWritelines", "doubleHeaders", "ByteOrdresses", "byteOrdapers", "byteDefelines", " byteOffters", " byteOrdlers", "byteBuffeners", "ByteBufflers", "byteBufferers", "bytebufflers", "byteCornests", "wordBuffers", "byteBuffests", "bytesBuffests", " byteBuffares", "connectionbuffERS", " byteBuffERS", "bytePackers", "byteOrdresses", " byteBuffors", "byteOrderers", "byteBuffererers", "doubleHeadings", "bytesAkors", "bytesCorners", "bytesAkizers", "byteChers", " byteOffERS", "ByteBuffresses", " byteBufflers", "byteChered", "byteInteginals", "bytebuffERS", " byteComplers", "byteOrdERS", " byteOrders", "bytesBuffatters", "bytesPackers", "byteBuffapers", "bytebuffresses", "byteBuffares", "bytePackapers", "bytebuffiners", "byteBuffresses", "byteComplers", "bytebuffters", "byteDefERS", "byteBufferERS", "byteInfERS", "byteBuffereners", " byteOffers", "wordBuffERS", " byteCompers", "byteOffors", "byteBuilders", "byteHeadERS", "byteDefatters", "bytesBuffizers", "bytebufferers", "byteWriterers", "byteBuffiners", " byteOrderers", "byteBuffters", "byteBufferlers", "bytesCornests", "bytesCornered", "connectionbuffers"], "m_initialOutBuffer": ["m_initialOutputBuffer", "m_initialOutputChannel", "m_finalOutBuffer", "m_originalOutAddress", "m_initialClientLine", "m_initialSocketLayer", "m_finaloutBuff", "m_initialAuthLine", "m_originalOutBuffer", "m_initialOutputLayer", "m_initialClientBuffer", "m_initialoutCache", "m_finalInBuff", "m_initialNewBuff", "m_finalOutMessage", "m_initialClientBuff", "m_initialInBuffer", "m_initialInBuff", "m_initialSocketHeader", "m_finaloutChannel", "m_finalOutChannel", "m_initialInHeader", "m_finalInBuffer", "m_initialNewFile", "m_initialShortCache", "m_initialInMessage", "m_initialoutChannel", "m_initialOutputBuff", "m_initialShortChannel", "m_finalOutBuff", "m_initialOutAddress", "m_initialNewMessage", "m_finalInChannel", "m_initialoutBuffer", "m_initialInAddress", "m_finalInMessage", "m_initialSocketFile", "m_originaloutBuffer", "m_initialAuthBuffer", "m_initialAuthFile", "m_initialOutLine", "m_InitialOutputFile", "m_initialOutMessage", "m_initialSocketBuffer", "m_initialNewBuffer", "m_initialOutputHeader", "m_InitialOutFile", "m_initialOutputFile", "m_initialInLayer", "m_initialOutFile", "m_InitialOutLayer", "m_finalOutCache", "m_finalInLine", "m_originalOutLine", "m_initialAuthAddress", "m_initialOutputMessage", "m_initialOutCache", "m_initialoutLine", "m_initialShortBuffer", "m_finaloutBuffer", "m_InitialOutputLayer", "m_initialOutHeader", "m_initialClientFile", "m_InitialOutBuffer", "m_finaloutFile", "m_originaloutAddress", "m_originaloutFile", "m_initialShortFile", "m_InitialOutputBuffer", "m_finalOutFile", "m_initialoutAddress", "m_InitialOutHeader", "m_initialInLine", "m_finalInFile", "m_initialInChannel", "m_initialoutBuff", "m_originaloutLine", "m_initialOutChannel", "m_initialoutFile", "m_initialOutLayer", "m_finalOutLine", "m_initialOutBuff", "m_initialInFile", "m_finalInCache", "m_InitialOutputHeader", "m_initialInCache", "m_originalOutFile"], "buffer": ["resource", "view", "engine", "address", "cell", "port", "shell", "url", "pool", "holder", "writer", "transfer", "flush", "console", "file", "timeout", "cache", "uffer", "comment", "feed", "slice", "header", "cur", "iter", "page", "output", "data", "null", "buff", "message", "block", "re", "row", "ker", "channel", "table", "copy", "queue", "bridge", "er", "document", "phrase", "array", "f", "worker", "callback", "reader", "fb", "stack", "binary", "client", "temp", "window", "string", "limit", "input", "response", "layer", "wave", "buf", "FFER", "object", "batch", "base", "event", "server", "config", "loader", "bc", "read", "Buffer", "back", "source", "builder", "template"], "buffers": ["bufors", "buffering", "buffators", "phers", "buffars", "bufaches", "ufors", "ufering", "bufered", "affors", "bufars", "ufers", " bufferers", "phresses", "transformERS", "buffages", " buffages", "affering", "Buffered", "bufages", "phators", " buffators", "transformler", "transformering", "buffors", "bufators", " buffars", "ufaches", "bufler", "bufers", " buffresses", "buffresses", "transformers", "buffERS", "bufferers", "affers", "affaches", " buffler", " buffERS", "Bufferers", "buferers", " buffering", "phages", "Buffers", "bufERS", "Buffars", "buffaches", "bufresses", "buffered", "bufering", " buffered", "buffler"], "result": ["resource", "or", "row", "status", "acc", "use", "function", "Result", "cache", "request", "results", "view", "comment", "inner", "winner", "response", "report", "manager", "search", "match", "sr", "card", "driver", "json", "user", "ret", "er", "err", "valid", "up", "successful", "default", "flash", "grade", "rc", "out", "rate", "event", "future", "consumer", "url", "complete", "cup", "f", "date", "session", "success", "res", "val", "runner", "error", "data", "test", "true", "output", "diff", "r", "message", "info", "ver", "re"], "encrypted": ["body", "entry", "temp", "channel", "cache", " data", "secret", "padding", "inner", "layer", "text", "pad", "flash", "selected", "config", "loader", "image", "internal", "transfer", "reader", "packed", "flush", "interrupted", "binary", "stream", "available", "source", "extra"]}}
{"id1": "189963", "id2": "20568568", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "9996334", "id2": "22411381", "code1": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"generateToken": ["generateSecret", "generationKey", "generatedSecret", "generateKey", "generATEKey", " GenerateSecret", "generateTokens", " GenerateToken", " GenerATEKey", " GenerATEToken", "generationTokens", " GenerATESecret", "generatedTokens", "generationToken", " GenerateKey", "generatedKey", "generATETokens", " GenerateTokens", "generATESecret", "generATEToken", "generatedToken", "generationSecret", " GenerATETokens"], "code": ["token", "codes", "string", "mac", "c", "cache", "str", "script", "state", "input", "Code", "hex", "key", "cod", "content", "address", "header", "ode", "tag", "coded", "prefix", "config", "value", "password", "hash", "next", "output", "data", "id", "message", "info", "source", "buffer", "text", "body", "name"], "md": ["df", "mb", "mp", "mg", "pd", "ms", "pm", "od", "mand", "rm", "mac", "cm", "m", "sm", " MD", "d", "sha", "MD", "bd", "meta", "wd", "hd", "ad", "dd", "mc", "cd", "mod", "cmd", "ma", "mag", "f", "ds", "gd", "ind", "dm", "hash", "editor", "amd", "kg", "dig", "mm", "metadata", "po", "mt", "grad", "mu", "mo"], "bytes": ["Bytes", "classes", "words", "codes", "bs", "zip", "string", "bps", "lines", "values", "bin", "bits", "objects", "bles", "outs", "buf", "files", "groups", "boot", "seconds", "address", "tes", "pieces", "s", "strings", "vs", "blocks", "units", "ips", "output", "data", "parts", "b", "es", "binary", "les", "body"]}}
{"id1": "9081749", "id2": "3756429", "code1": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["encryption", "Encryption", "decryption", "esccrypt", "Encrypt", "deccrypt", "Encipher", "decrypt", "enccrypt", "encipher", "escrypt", "Enccrypt", "decipher", "escryption", "escipher"], "password": ["pass", "root", "mask", "token", "username", "words", "seed", "sword", "project", "description", "string", "cache", "css", "word", "secret", "Password", "PASS", "wallet", "params", "key", "this", " passwords", "auth", "database", "email", "wd", "pad", "user", "address", "crypt", "weight", "command", "prefix", "phrase", "array", "python", "value", "strip", "image", "data", "picture", "null", "account", "pattern", "parser", "buffer", "message", "text", "parent", "name", "encrypted", "padding"], "encryptType": ["encPTtype", "encriptType", "acryptionTyp", "encryptKey", "ecipherKey", "encryptTypes", "ecryptClass", "acryptionTypes", "encryptionTyp", "ecryptKey", "encertKey", "eciphertype", "encryptionTypes", "ecryptType", "encrypttype", "encertClass", "acryptTypes", "encryptionType", "encipherKey", "encruptType", "encruptTypes", "encryptiontype", "acrypttype", "encerttype", "encruptTyp", "acryptiontype", "encertType", "acryptType", "acryptTyp", "encriptTypes", "encryptClass", "encPTClass", "encryptTyp", "encPTKey", "encrupttype", "ecipherType", "acryptionType", "encriptTyp", "ecrypttype", "encripttype", "encipherClass", "ecipherClass", "encipherType", "encPTType", "enciphertype"], "md": ["df", "mb", "mp", "pd", "hed", "pm", "od", "mand", "rm", "mac", "Cmd", "m", "um", " MD", "d", "hm", "di", "MD", "bd", "hd", "dd", "mc", "cd", "mod", "cmd", "dh", "mag", "f", "gd", "dm", "der", "nm", "amd", "rpm", "dig", "mm", "metadata", "vd", "mad", "grad", "mt", "mo"], "hash": ["body", "hed", "sh", "full", "mac", "cache", "Hash", "fill", "str", "sha", "sum", "how", "log", "search", "hex", "key", "char", "bit", "number", "ashes", "header", "kh", "bug", "build", "count", "print", "flash", "ha", "part", "base", "url", "query", "throw", "ash", "array", "index", "code", "len", "value", "her", "image", "check", "dot", "handle", "html", "h", "memory", "diff", "filter", "data", "error", "digit", "style", "id", "message", "hard", "chip", "ver", "block", "version"], "hexString": ["rawArray", "alphString", " hexFile", "alphFile", "hashString", "pixelFile", "squareString", "squareField", "pixelBuffer", "hexLine", "hexstring", "rawFile", "blackstring", "hexFile", "alphLine", "blackLine", "rawString", "hexSet", "pixelstring", "squareSet", "blackFile", " hexstring", "hashFile", "hashstring", "alphstring", "squareArray", " hexSet", "hexField", "zipString", "blackString", " hexLine", " hexBuffer", "hexArray", " hexArray", "hexBuffer", "zipSet", "pixelString", " hexField", "rawstring", "hashArray", "zipArray", "zipField", "rawBuffer"], "i": ["temp", "si", "qi", "ip", "u", "multi", "n", "ii", "c", "ini", "pi", "o", "abi", "ci", "di", "io", "slice", "ji", "ui", "length", "ri", "bi", "count", "ie", "p", "it", "l", "phi", "s", "j", "I", "x", "index", "f", "e", "oi", "li", "off", "start", "h", "v", "gi", "ti", "data", "ai", "r", "b", "xi", "id", "info", "uri", "ix", "end"]}}
{"id1": "771802", "id2": "19810820", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createOutputSteam", " createIOStream", " createInputSteam", " createByteFile", " createOutputFile", " createByteSteam", " createInputReader", " createIOSteam", " createByteReader", " createOutputReader", "createInputFile", " createInputFile", "createInputStream", " createIOFile", " createInputStream", "createOutputFile", "createInputSteam", " createByteStream", "createOutputReader", " createIOReader", "createOutputSteam", "createInputReader"], "inFile": ["outfile", "sourceFiles", "inputFile", "insfile", "sourcefile", "insFiles", "outFiles", "incStream", "inputStream", "infile", "inputFiles", "inStream", "sourceFile", "outStream", "insFile", "insStream", "incFiles", "inFiles", "inputfile", "incFile", "sourceStream", "incfile"], "outFile": ["outfile", "targetFile", "inDir", "workDir", "outDirectory", "workingFile", "inputFile", "outDir", "infile", "workingDirectory", " outDirectory", "workingfile", "workfile", "workTime", "workFile", "inTime", "outStream", "inputDir", "inputfile", "outTime", "inputTime", " outfile", "workingStream", " outStream", "targetfile", "targetDirectory", "targetStream"], "k_blockSize": ["k_byteLen", "k_blocksLength", "k_lineSize", "k_lockSize", "k_bitInfo", "k_blockCount", "k_blocksSize", "k_lockLen", "k_lockLength", "k_blockLength", "k_byteLength", "k_byteInfo", "k_lineCount", "k_blocksLen", "k_BlockCode", "k_byteCount", "k_BlockCount", "k_bitSize", "k_byteCode", "k_lineInfo", "k_lockCode", "k_byteSize", "k_blockCode", "k_blocksCount", "k_BlockSize", "k_BlockLength", "k_lockCount", "k_blockLen", "k_blockInfo", "k_bitCount"], "byteCount": ["blockSize", "byteSize", " byteSize", " byteLength", "byteLen", "blockCount", " bytecount", "Bytecount", "byteSum", "characterSize", "ByteLength", "flushcount", "blockLength", "flushLength", "ByteCount", "characterCount", "flushSize", "characterLen", " byteSum", "flushCount", "ByteSize", "ByteLen", "ByteSum", "characterLength", "byteLength", " byteLen", "blockSum", "bytecount"], "buf": ["background", "brace", "bh", "vec", "alloc", "cas", "append", "cv", "fd", "ctx", "feed", "queue", "la", "seq", "ucc", "loc", "batch", "bag", "base", "rc", "cmd", "tmp", "exc", "config", "Buffer", "len", "uf", "cap", "bytes", "cb", "border", "result", "img", "data", "feat", "Buff", "b", "fb", "buff", "flush", "bf", "buffer", "font", "src", "rb"], "ofp": ["OFnp", "Ofc", "Ofl", "Oft", "afl", "fort", "OFtp", "OFc", "afnp", "ofl", "forp", "afp", "Ofp", "Oftp", "afc", "ofnp", "Ofnp", "fortp", "ofc", "oft", "forc", "OFp", "OFl", "OFt", "oftp"], "zos": ["ses", "osi", "z", "iffs", "obb", "zig", "tz", "liquid", "obs", "webkit", "oda", "zyk", "gz", "zb", "soon", "zh", "zon", "nz", "robe", "js", "bs", "css", "zin", "cfg", "fits", "zn", "utils", "lol", "dylib", "zy", "oses", "zer", "zik", "rons", "zes", "za", "zona", "inos", "enos", "abi", "os", "outs", "packs", "iframe", "ZA", "oS", "los", "ls", "zx", "ops", "jas", "cos", "zar", "ws", "ZI", "zi", "lins", "forge", "owicz", "budget", "zers", "ozo", "ossus", "zen", "zip", "rez", "bitcoin", "bos", "zag", "nox", "bes", "uz", "zo", "ros", "hz", "ogl", "kos", "zl", "core", "modules"], "osw": ["osx", "isd", "eshell", "bswo", "bsws", "isnow", "eswd", "bws", "lsw", "ossd", "bx", "osssw", "esfw", "osd", "osswd", " osww", " osow", "esnow", "oswo", " osfw", "ishell", "isw", "esww", "osshell", "lsws", "esy", "isy", "ossy", "esow", "ossww", "esd", "oswd", "iswd", "ossow", "bwo", "bsx", "osfw", "ossnow", "ossfw", "oshell", "osww", "esw", "ossw", "osws", "osy", "osnow", "issw", "lsx", "essw", "lswo", "bsw", "osow"], "bw": ["bbew", "bz", "bbz", "ebW", "ebwe", "abwd", "owa", "lbwh", "lwa", "bws", "bwe", "lsw", "Bws", " bws", "lx", "ow", " bwa", "bx", "lbx", " bz", "fx", "bbws", "bwd", "fwh", "bbw", "bwa", "bbaw", "Bew", "lbsw", "Bw", "lw", "fbwd", " baw", "abwe", "owu", "oaw", "fw", " bew", "lbz", "bwu", "ebw", "bbwa", "ebwd", "bbwu", "abw", "lbwa", "lbws", "bwh", "Bwa", "lbw", "bew", "bbwh", " bwu", "bW", "fbw", "fbW", "baw", "fwa", "lbr", "fsw", "fbwe", "abW", " bwh", "fr", "bsw"], "zot": ["Ziot", "aziot", "Zot", "zori", "jot", "azit", "zerita", " zor", "zor", "jos", "jori", "zerit", "zeros", "zerott", "azor", "Zit", "zita", "jit", "ziot", "Zor", " ziot", "Zita", "azot", "Zott", "zerori", "zott", "zerot", "azita", " zori", "azott"], "ifp": [" ifc", "Ifc", "Ifi", "ifl", "ifb", "ifi", "ifc", " iff", "IFf", "IFp", " ifi", "ipl", "IFc", " ifb", "Iff", "IFb", "ipp", " ifl", "iff", "Ifp", "ipb", "IFi", "ipc", "IFl"], "zis": ["zits", "ziss", " zais", "zeip", "zais", "zip", "zeiss", "xIS", "zib", "jis", "zenis", "Ziss", "zipits", "zipis", " zits", " zisi", "zenIS", "zipip", "Zip", "jit", "xib", "zenais", "xisi", "xis", "xais", "xits", "Zits", "jisi", " zIS", "Zis", " zib", "zenib", "zeis", "zisi", "jits", "zipiss", "xit", "zIS", "zeits"], "isr": ["irr", "ISr", " issr", "ISrc", "ISsr", "irrb", "irpr", "isrb", "rispr", "irrc", "ispr", "risrc", "ISrb", "isrs", "isscr", "ISrs", "IScr", "risr", "ISpr", " isrs", "issrs", "isssr", "risrb", " iscr", "iscr", "issr", "isrc"], "br": ["Br", "ch", "ctr", "bh", "HR", "kr", "ob", "obl", "ocr", "str", " fr", "shr", "ber", "obi", "yr", "sr", "bro", "BR", "div", "bsp", "tr", "gr", " BR", "bp", "cro", "mr", "lr", "browser", "bl", "ibl", "err", "rib", " dr", "ibr", "arr", "sp", " Br", "bc", "bar", "img", "hr", "r", "b", "rs", "body", "rb", "fr"], "zit": [" zic", "zits", "zic", "jic", "zeitter", "zipith", "zipIT", "zip", " zip", "jita", "zenits", "jIT", "zeit", "zipit", "zeIT", "zenit", "zipits", " zits", "zIT", "ji", "zipip", "jite", "zita", "jit", " zith", "xic", "zeith", "zitter", "xith", "zith", "jith", "zenitter", "jip", " zite", "zenith", "zipita", "jits", "zite", "zi", "zipite", "xi", "xit", "zeita", "zipitter", " zi", "zeits"]}}
{"id1": "15241397", "id2": "3731077", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["handlePut", "handleget", " doGET", "didPut", "doget", "doGET", " doPut", " doget", "doPut", "handleGET", "didGET", "handleGet", "didget", "didGet"], "request": ["resource", "application", "subject", "instance", "initial", "context", "method", "xml", "Request", "http", "input", "report", "queue", "user", "object", "er", "connection", "document", "event", "server", "url", "query", "complete", "received", "image", "result", "reader", "data", "type", "req", "QUEST", "message", "info", "uri", "buffer", "client", "web"], "response": ["Response", "resource", "application", "status", "function", "full", "respond", "host", "site", "reply", "results", "view", "version", "report", "wave", "onse", "queue", "json", "object", "resp", "connection", "document", "generation", "out", "model", "server", "pool", "other", "session", "image", "writer", "result", "page", "next", "output", "error", "data", "esi", "message", "parent", "client", "body", "collection"], "rewrittenQueryString": ["rewrittenRequestService", "rewrittenqueryText", "rewwrittenQueryStr", "rewrittenqueryString", "rewrittenUrlLine", "rewwrittenQueryLine", "rewwrittenRequestArray", "rewrittenQuestionList", "rewrittenqueryService", "rewrittenUrlService", "rewrittenRequestString", "rewrittenUrlString", "rewrittenQueryText", "rewwrittenQueryString", "rewrittenPageArray", "rewwrittenRequestService", "rewrittenQuestionLine", "rewwrittenRequestStr", "rewrittenRequestList", "rewrittenPageList", "rewrittenQuestionText", "rewrittenQueryList", "rewrittenRequestText", "rewwrittenRequestText", "rewrittenQueryArray", "rewrittenQuestionArray", "rewwrittenRequestList", "rewrittenqueryStr", "rewwrittenQueryService", "rewwrittenRequestString", "rewrittenRequestLine", "rewrittenQueryStr", "rewrittenQueryService", "rewwrittenQueryList", "rewrittenPageString", "rewrittenQuestionStr", "rewwrittenRequestLine", "rewrittenRequestStr", "rewrittenPageLine", "rewwrittenQueryArray", "rewrittenRequestArray", "rewrittenqueryLine", "rewrittenQuestionString", "rewrittenQueryLine", "rewrittenUrlText", "rewwrittenQueryText"], "rewrittenUrl": ["rewwrittenJar", "RewwrittenJar", "rewrittenJar", "rewcraftedUrl", "RewrittenURL", "RewrittenServer", "RewwrittenServer", "rewardedLocation", "rewriteServer", "rewwrittenLanguage", "rerittenUrl", "rewrittenLanguage", "rerittenUr", "rewedUrl", "rewrittenLocation", "rewwrittenServer", "rewardedInt", "rewriteText", "rewatchedUrl", "rewatchedServer", "rewwrittenLocation", "RewrittenFile", "rewodedLanguage", "RewwrittenURL", "rewwrittenurl", "RewrittenInt", "Rewwrittenurl", "rewrapedFile", "rewatchedText", "rewriteUrl", "rewrittenUr", "rewmatchedFile", "rewrapedUr", "rewcraftedUr", "rewmatchedurl", "RewrittenUrl", "rerittenFile", "rewrittenURL", "rewrittenFile", "RewwrittenFile", "rewcraftedURL", "RewwrittenText", "RewrittenLocation", "rewilledJar", "rewrittenInt", "rewardedUr", "rewrittenText", "rewedFile", "rewmatchedURL", "rerittenLanguage", "rewatchedURL", "RewwrittenUr", "rewilledInt", "rewcraftedLocation", "RewwrittenUrl", "RewrittenText", "RewwrittenInt", "RewwrittenLocation", "rewilledURL", "RewrittenUr", "rerittenURL", "rewilledUrl", "rewriteURL", "rewodedFile", "Rewrittenurl", "rewwrittenURL", "rewardedLanguage", "rewardedFile", "rewedURL", "rewardedURL", "rewmatchedUrl", "rewardedUrl", "rewodedURL", "rewodedUrl", "rewedurl", "rewwrittenInt", "rewwrittenText", "rewrittenServer", "rewwrittenUrl", "rewardedJar", "rewwrittenFile", "rewrittenurl", "RewrittenJar", "rewrapedURL", "rewrapedUrl", "rewwrittenUr", "rewedUr"], "httpURLConnection": ["httpGEConnection", "apacheGEconnection", "apacheURLConnection", "httpurlConnect", "httpStreamconnection", "httpURIConnect", "apacheGEConnect", " httpStreamSession", "httpELConn", "httpURConn", "webURLConn", "httpSSLClient", " httpURLSession", " httpURLCurrent", "webURLClient", "httpGEFlow", "httpSSLConn", "apacheGEConnection", " httpURConn", "HttpURLService", "apacheURLconnection", "webSSLClient", "httpUrlConnect", " httpStreamconnection", "httpURconnection", "httpURLService", "httpurlCode", "httpUrlconnection", " httpURLConnect", "httpChannelConnection", "httpWebConnection", "httpSSLContext", "httpWebConnect", "httpURLSession", "webURLContext", "httpChannelService", "httpWebConn", "httpURLClient", "httpurlCurrent", "httpURIFlow", "httpUrlCode", "httpurlconnection", "httpCLCode", "httpUrlClient", " httpStreamConnection", " httpURLCode", "HttpChannelService", "httpUrlContext", "httpCLConnection", "httpURIClient", " httpURConnect", "httpChannelConnect", "httpGEConnect", "httpURConnect", "httpURLFlow", "httpPathCurrent", "httpURLconnection", "HttpURLConnection", "httpELConnection", "apacheGEFlow", " httpUrlConn", " httpURLConn", "HttpURLConnect", "httpPathconnection", " httpURConnection", " httpURLconnection", "httpELConnect", "HttpChannelConnect", "httpStreamConnection", "HttpURLconnection", "httpurlConnection", "httpurlFlow", "httpurlSession", "httpPathConnection", "apacheURLConnect", "httpChannelconnection", "httpURLContext", "httpURConnection", "httpUrlConn", "httpURLCurrent", "HttpChannelConnection", "httpGEconnection", "httpURIconnection", "httpPathSession", "httpUrlService", "httpURService", "httpCLConn", "httpURLConnect", "httpURIConnection", "httpStreamCurrent", "httpSSLConnection", "webSSLContext", "httpStreamSession", "httpURLConn", "httpUrlConnection", "httpURLCode", "HttpChannelconnection", "webURLConnection", "apacheURLFlow", "webSSLConnection", "httpURIConn", " httpUrlCode", " httpUrlConnection", "webSSLConn", " httpStreamCurrent", "httpurlConn", "httpURIContext"], "header": ["item", "entry", "group", "attribute", "token", "section", "line", "function", "player", "string", "channel", "ter", "character", "cover", "headers", "comment", "layer", "outer", "after", "match", "key", "list", "queue", "driver", "pair", "second", "bridge", "er", "handler", "default", "rule", "document", "part", "Header", "event", "consumer", "server", "component", "dr", "definition", "index", "iter", "date", "field", "director", "head", "feature", "her", "hash", "writer", "filter", "result", "next", "member", "author", "data", "error", "metadata", "message", "info", "buffer", "back", "master", "block", "column", "version", "reference"], "value": ["item", "property", "entry", "attribute", "media", "function", "description", "string", "current", "option", "values", "expression", "version", "comment", "language", "label", "key", "json", "content", "object", "letter", "child", "valid", "default", "document", "hello", "element", "model", "server", "variable", "get", "office", "now", "field", "V", "Value", "set", "password", "format", "val", "v", "gi", "VALUE", "data", "type", "sv", "message", "info", "parent", "text", "name", "end"], "inputStream": ["outputSteam", "outputChannel", "resourceSteam", "pullSteam", "inputChannel", "outputStreamer", "InputChannel", "pullStreamer", "resourceChannel", "inputstream", "pullStream", "inputStreamer", "InputSteam", "resourceStream", "Inputstream", "pullstream", "resourcestream", "InputStreamer", "InputStream", "outputstream", "inputSteam"], "outputStream": ["responseSteam", "Outputstream", "outputSteam", "OutputStream", "outputChannel", "responseFile", "responseStream", "externalstream", " outputChannel", "outputStreamer", "outputFile", "OutputFile", " outputSteam", "inputstream", "OutputStreamer", "inputStreamer", "externalStream", "OutputSteam", "externalSteam", " outputFile", "externalStreamer", "responseChannel", "OutputChannel", "outputstream", "inputSteam"]}}
{"id1": "22868825", "id2": "8667872", "code1": "    String sendRequest(String[] getVars, String[] postVars, Object[] fileVars, boolean getSessionKey) throws IOException {\n        String uri = wikiBaseURI;\n        if (getVars != null) for (int i = 0; i + 1 < getVars.length; i += 2) uri += (i == 0 ? '?' : '&') + urlEncode(getVars[i]) + '=' + urlEncode(getVars[i + 1]);\n        URL url = new URL(uri);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        if (!getSessionKey) {\n            String cookie = \"\";\n            for (String key : cookies.keySet()) cookie += (cookie.length() == 0 ? \"\" : \"; \") + key + \"=\" + cookies.get(key);\n            conn.setRequestProperty(\"Cookie\", cookie);\n        }\n        if (fileVars != null) {\n            conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            conn.connect();\n            PrintStream ps = new PrintStream(conn.getOutputStream());\n            for (int i = 0; fileVars != null && i + 2 < fileVars.length; i += 3) {\n                ps.print(\"--\" + boundary + \"\\r\\n\");\n                postFile(ps, conn, (String) fileVars[i], (String) fileVars[i + 1], (byte[]) fileVars[i + 2]);\n            }\n            for (int i = 0; postVars != null && i + 1 < postVars.length; i += 2) ps.print(\"--\" + boundary + \"\\r\\n\" + \"Content-Disposition: \" + \"form-data; name=\\\"\" + postVars[i] + \"\\\"\\r\\n\\r\\n\" + postVars[i + 1] + \"\\r\\n\");\n            ps.println(\"--\" + boundary + \"--\");\n            ps.close();\n        } else if (postVars != null) {\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            conn.connect();\n            PrintStream ps = new PrintStream(conn.getOutputStream());\n            for (int i = 0; postVars != null && i + 1 < postVars.length; i += 2) ps.print((i == 0 ? \"\" : \"&\") + urlEncode(postVars[i]) + \"=\" + urlEncode(postVars[i + 1]));\n            ps.close();\n        }\n        int httpCode = conn.getResponseCode();\n        if (httpCode != 200) throw new IOException(\"HTTP code: \" + httpCode);\n        if (getSessionKey) getCookies(conn.getHeaderFields().get(\"Set-Cookie\"));\n        InputStream in = conn.getInputStream();\n        response = \"\";\n        byte[] buffer = new byte[1 << 16];\n        for (; ; ) {\n            int len = in.read(buffer);\n            if (len < 0) break;\n            response += new String(buffer, 0, len);\n        }\n        in.close();\n        return response;\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 0, "substitutes": {"sendRequest": ["createCall", "sendResponse", "dorequest", "doCall", " sendResponse", "createrequest", " sendrequest", "doRequest", "doResponse", "sendrequest", "createRequest", "sendCall", " sendCall", "createResponse"], "getVars": ["postVariarn", "getNars", "queryVar", "getvars", "getVar", "getWARS", "postVARS", "postVar", " getNars", "postVarn", " getVAR", "getCarms", "getVariarn", "getJores", "getJAR", " getNores", "getVArgs", " getPARS", " getVar", "getvards", "getVariarms", "getVards", "getPar", "getvarms", "getCArgs", "getNores", "getWarms", "queryVARS", "getMrs", "postVariar", "postVarms", "getVariards", " getVrs", "postVariarms", "getMars", "getJars", " getPars", "getMAR", "getCar", "getCards", "getJrs", " getVARS", "getVarn", " getVarms", "getPars", "postVariards", "getWar", " getParms", "getParms", " getNAR", "getVariARS", "queryCARS", "queryCar", "getVrs", "getvarn", "queryCars", " getPar", "postVards", "queryVars", "getNrs", "getCARS", "getVAR", "getWars", "postVariars", "queryCArgs", " getNrs", " getVores", "getNAR", "getvARS", "getVores", "getMores", "queryVArgs", "getPARS", "getVARS", "getvar", "postVariARS", "getCars", "getVariar", "getVarms", "getVariars", "getVariArgs"], "postVars": ["POSTCats", "postWams", "postWar", "postVariarms", "PostVars", "postvARS", " postVariarms", "postNar", "PostVar", "POSTVars", "postCars", "postLars", "POSTCars", "PostVams", "PostMars", "postWats", "postNARS", "PostVARS", "postVams", "postVards", "postMarms", "PostMams", "postMar", "postCar", "postMars", "postvats", " postVariats", " postVariARS", " postVariar", "postVARS", "postVariars", " postVariars", " postVats", "postVar", "postNars", "postWARS", "postCats", "postWards", "postNats", " postVarms", "postMams", "postVariams", "POSTVats", "postCards", "POSTVards", "POSTVar", "postvar", "postMARS", "POSTCards", "postVariats", "postvarms", "postVariar", "postLar", "postLards", "postVariARS", " postVar", "PostMARS", "postVats", "PostMar", "POSTCar", "postWars", "postVarms", " postVARS", "postLats", "postvars"], "fileVars": ["fileVels", "fileVard", "fileFARS", "fileVariares", "postVels", "fileVariar", "filevarms", "formVarms", "fileQuars", "postVarients", "filePars", "fileFars", "fileVariels", "fileVARS", "postVARS", "fileHar", "fileNars", "fileCals", "postVar", "fileHard", "fileQuARS", "filevar", "postVents", "filevars", "fileDars", "filevarts", "fileParms", "fileVariars", "fileFar", "postNar", "fileDar", "fileVarients", "fileVar", "fileHARS", "filePys", "fileNard", "postVarts", "fileVariarms", "fileCents", "fileQuarts", " fileVarms", "formVARS", "formQuARS", "filePar", "formQuarts", "fileKar", "postVariar", "postVard", "fileCars", "fileVariard", "fileNar", "fileQuents", "postVariarts", "fileDarts", "fileKars", "fileVarms", "fileVents", "postVariels", "fileQuals", "filevARS", "postVarials", "fileFels", "fileVals", " fileVar", " fileVys", "fileNARS", "fileVarials", "fileVariys", " fileKar", "formVarts", "fileCARS", "fileVys", "fileVarts", "postVares", "fileQuarms", "formVars", "fileKarms", "postNard", "fileNarts", "formQuarms", "postVariares", "fileVariARS", "postNARS", "fileDARS", "filevels", "postVariars", "postNars", "postVals", "fileKys", " fileKys", "fileNares", "fileVares", "fileHars", " fileKarms", "postVariARS", " fileKars", "formQuars", "fileVariarts"], "getSessionKey": [" getSessionName", "getESSIONKey", "getESSIONkey", " getsessionkey", "getSecretkey", "gotsessionKey", "gotsessionName", "gotsessionkey", "getsessionkey", "getSecretName", "getESSIONName", "getsessionKey", "getessionkey", " getsessionKey", "gotSessionkey", "getSecretKey", "getSessionName", "gotSessionKey", "getessionKey", "getsessionName", "getessionName", "gotSessionName", " getsessionName", "getSessionkey", " getSessionkey"], "uri": ["resource", "route", "qi", "username", "ip", "multi", "string", "href", "pi", "http", "ci", "URL", "path", "ur", "api", "post", "ui", "absolute", "database", "ri", "afi", "address", "archive", "URI", "connection", "base", " URI", "storage", "future", "server", "query", "location", "cli", "iri", "remote", "gi", "directory", "direction", "data", "mi", "term", "id", "iv", "text", "uni", "origin"], "i": ["hi", "ini", "ii", "g", "m", "ci", "z", "bi", "my", "count", "p", "l", "phi", "eni", "start", "v", "gi", "ai", "yi", "t", "iu", "c", "y", "o", "d", "io", "slice", "ji", "ami", "init", "fi", "x", "ni", "page", "ti", "mi", "end", "multi", "pi", "di", "num", "ei", "ie", "j", "I", "sp", "index", "f", "cli", "oi", "li", "h", "diff", "type", "xi", "id", "uni", "mu", "si", "qi", "ip", "u", "ix", "is", "inner", "api", "ui", "ri", "it", "err", "base", "e", "b", "info", "source", "me"], "url": ["pull", "fr", "channel", "cache", "host", "http", "www", "URL", "log", "ll", "con", "ur", "io", "path", "Url", "object", "user", "rel", "browser", "l", "connection", "base", "ls", "server", "sl", "f", "session", "li", "page", "ssl", "bb", "fl", "obj", "web", "client", "org", "file", "lc"], "conn": ["dc", "or", "ch", "ctrl", "cat", "cm", "n", "c", "Connection", "g", "act", "ca", "col", "pg", "pr", "http", "oa", "Conn", "ann", "oss", "conv", "ci", "ctx", "con", "io", "open", "co", "rt", "sync", "ct", "client", "impl", "loc", "p", "adj", "cl", "l", "connection", "init", "net", "cn", "out", "rc", "cp", "exec", "coll", "reg", "cur", "config", "enc", "cli", "session", "pub", "h", "socket", "cb", "close", "fp", "ssl", "nt", "obj", "jp", "en", "conf", "nc", "ec", "connect", "org", "db"], "cookie": ["timeout", "txt", "temp", "entry", "token", "cat", "zip", "c", "cache", "string", "clean", "channel", "css", "xml", "secret", "comment", "character", "inner", "copy", "label", " cookies", "co", "char", "card", "cf", "json", "cook", "ce", "content", "child", "header", "rule", "cell", "chain", "nice", "query", "config", "enc", "session", "code", "value", "password", "cb", "gi", "ookie", "data", "type", "pod", "jar", "id", "binary", "text"], "key": ["item", "entry", "ask", "ry", "Key", "fee", "seed", "k", "string", "cache", "mac", "kid", "col", "zip", "exp", "secret", "str", "ee", "path", "co", "char", "KEY", "box", "json", "pair", "ce", "child", "ie", "rule", "part", "cell", "pe", "prefix", "phrase", "query", "x", "keys", "field", "link", "code", "value", "any", "page", "ice", "data", "type", "point", "id", "cy", "hop", "sign", "text", "ace"], "ps": ["pc", "ms", "http", "pse", "pl", "gs", "HTTP", "pp", "p", "fs", "pa", "ts", "po", "ends", "pes", "rows", "bs", "css", "lines", "details", "hes", "this", "pe", "per", "_", "posts", "ss", "mp", "pps", "pg", "gets", "os", "ins", "tests", "ons", "ls", "ops", "sp", "cs", "ws", "ds", "ips", "jp", "ras", "ups", "ks", "pass", "pr", "py", "eps", "pt", "Ps", "Url", "properties", "pers", "qs", "pos", "ports", "aps", "PS", "rs", "pas"], "name": ["Name", "action", "resource", "entry", " header", " compression", "description", "access", " data", "title", "comment", "path", " Name", " body", " extension", "header", "default", " prefix", "part", "prefix", "size", "value", " filename", "data", "id", "block", "form", "file"]}}
{"id1": "7006052", "id2": "8801436", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copySourceFileInfo", " copyFilesFrom", " copyFileFrom", "copySourceFileFile", "copySourceFileFrom", " copyFilesFile", " copyFileFile", "copyfileTo", "copyfileInfo", "copyfileFrom", "copyFilesInfo", "copyFileInfo", "copyFilesFile", "copySourceFileTo", "copyFileFile", " copyFilesTo", "copyFileFrom", " copyFileInfo", "copyfileFile", "copyFilesFrom", "copyFilesTo", " copyFilesInfo"], "src": ["resource", "txt", "js", "string", "href", "old", "path", "sc", "slice", "sync", "archive", "fn", "loc", "sup", "s", "rc", "upload", "url", "config", "sl", "sb", "code", "filename", "image", "sin", "inf", "remote", "img", "data", "b", "sub", "rs", "source", "stream", "uri", "sel", "rb", "file"], "dest": ["folder", "txt", "temp", "done", "route", "project", "opt", "dist", "bin", " Dest", "desc", "die", "dir", "loc", "sup", "comb", "default", "orig", "tmp", "delete", "flat", "des", "home", "filename", "Dest", "result", "img", "output", "test", "data", "secure", "target", "b", " destination", "sub", "source", "const", "wb", "name", "later"], "destFile": ["targetFile", "destF", " destinationF", "destDir", " destinationFiles", " destinationDir", " destF", "destfile", "destFiles", " destinationFile", "Destfile", "DestF", "DestFile", "targetFiles", " destFiles", "DestDir", " destDir", "DestFiles", "targetfile", "targetDir", " destfile"], "in": ["In", "pass", "again", "n", "ini", "IN", "cin", "is", "din", "inner", "bin", "input", "con", "pin", "ins", "impl", "inn", "err", "kin", "trans", "up", "l", "init", "win", "s", "lin", "rin", "url", "gin", "thin", "f", "inside", "i", "nin", "image", "socket", "login", "reader", "diff", "data", "r", "inc", "id", "source", "stream", "ln"], "out": ["again", "n", "cache", "o", "exp", "ex", "inner", "bin", "Out", "copy", "log", "outer", "io", "post", "sync", "this", "ac", "conn", "user", "err", "up", "part", "net", "w", "exec", "work", "cos", "pool", "other", "off", "image", "writer", "plain", "ext", "output", "data", "obj", "OUT", "null", "inc", "parent", "client", "one", "file", "extra"], "buf": ["bh", "vec", "map", "cache", "c", "cas", "cv", "bin", "path", "ctx", "bd", "box", "queue", "pad", "length", "seq", "loc", "batch", "br", "bl", "bag", "ff", "orig", "rc", "tmp", "bc", "Buffer", "pool", "block", "off", "blocks", "uf", "cap", "uc", "bytes", "cb", "v", "result", "data", "raw", "b", "bf", "buff", "fb", "buffer", "rb"], "len": ["line", "n", "c", "fin", "Len", "fd", "num", "length", "no", "min", "count", "ie", "l", "part", "base", "pos", "all", "coll", "url", "size", "f", "iter", "off", "pre", "ind", "cap", "el", "split", "li", "val", "bytes", "lim", "nt", "data", "fl", "en", "id", "lf", "rev", "body", "ln", "lc", "end"]}}
{"id1": "22503685", "id2": "10212189", "code1": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 1, "substitutes": {"readGeoParserResult": ["readGeOParserResult", "readGeOReaderResult", "readGeOParserReport", "readGeOReaderReport", "readGeoParserReport", "readGeoWalkerReport", "readGeoParserResults", "readGeoReaderResults", "readGeoparserResults", "readGeoparserReport", "readGeoParserOutput", "readGeoparserOutput", "readGeoReaderReport", "readGeoWalkerOutput", "readGeOReaderResults", "readGeoReaderOutput", "readGeOParserOutput", "readGeoWalkerResults", "readGeOReaderOutput", "readGeoparserResult", "readGeoReaderResult", "readGeOParserResults", "readGeoWalkerResult"], "recordContent": ["RecordBody", "RecordContents", "resourceFile", "RecordMessage", "recordFile", "resourceContent", " recordBody", "resourceContents", "reportContent", "reportText", "recordBody", "RecordContent", " recordFile", "reportMessage", "RecordFile", "recordMessage", "reportBody", "recordText", " recordContents", " recordMessage", "recordContents", " recordText", "resourceText", "RecordText"], "getGazeteerIds": ["getGazeteersIds", "getGazeteersLoges", "getGazeteerLoges", "getGazeteerIdes", "getGazeteerNeeds", "getGazeteersIdings", "getGazeteerHostings", "getGazeteerConfigs", "getGazeteersIders", "getGazeteerLogers", "getGazeteersIdls", "getGazeteerConfigls", "getGazeteerIdings", "getGazeteersIdes", "getGazeteerTexts", "getGazeteerIdxs", "getGazeteerLogings", "getGazeteerNeedings", "getGazeteersLogers", "getGazeteerTextls", "getGazeteerTextxs", "getGazeteersLogs", "getGazeteerIdls", "getGazeteerLogls", "getGazeteerIders", "getGazeteersLogings", "getGazeteersIdxs", "getGazeteerLogxs", "getGazeteerConfigings", "getGazeteersLogxs", "getGazeteerConfigxs", "getGazeteerHostes", "getGazeteerHosters", "getGazeteersLogls", "getGazeteerNeeders", "getGazeteerTextings", "getGazeteerNeedes", "getGazeteerHosts", "getGazeteerLogs"], "ret": ["rg", "det", "group", "status", "Result", "g", "opt", "mem", "reply", "results", "str", "vet", "fun", "ft", "Return", "ll", "match", "list", "rt", "sys", "dict", "default", "resp", "part", "replace", "rets", "out", "arr", "reg", "get", "usr", "ut", "array", "iter", "gt", "f", "len", "hash", "res", "result", "repl", "ext", "nt", "att", "data", "arg", "obj", "alt", "feat", "bf", "r", "t", "Ret", "info", "RET", "re", "ref"], "retries": ["Retries", "RETried", "RETrying", "retrying", " retry", "retry", "Retrys", "trying", "Retrying", "altrying", "RETrys", " retrying", "altries", "tries", "retrys", "trys", "RETries", "altried", "tried", "Retry", " retrys", "altrys", "retried"], "reqPre": ["refPlan", "refPre", "requestPref", "requestpre", "respPre", "reqpre", " requestPref", "reqPost", " reqpre", " reqPref", "reqPref", "requestPlan", "reqPlan", " requestpre", "refpre", "respPost", " requestPre", "resppre", " requestPost", "refPost", "requestPre", "respPlan", "requestPost", " reqPost"], "outputFormat": ["inputFormat", "reportSettings", "reportType", "outputVersion", "inputSettings", "inputType", "OutputVersion", "outputSettings", "OutputFormat", "OutputSettings", "inputVersion", "reportFormat", "OutputType", "outputType", "reportVersion"], "doc": ["dc", "resource", "df", "project", "m", "Doc", "http", "xml", "str", "response", "msg", "desc", "di", "api", "Document", "div", "bug", "up", "document", "part", "pos", "mc", "event", "coll", "dr", "bc", "f", "date", "e", "home", "feature", "tx", "record", "h", "result", "html", "page", "data", "parse", "docs", "md", "style", "b", "po", "DOC", "info", "git", "text", "body", "db", "file"], "url": ["resource", "entry", "string", "channel", "request", "http", "str", "response", "URL", "path", "api", "Url", "address", "orb", "browser", "l", "document", "connection", "base", "element", "server", "location", "sl", "f", "e", "page", "html", "ssl", "result", "data", "r", "b", "id", "web", "info", "uri", "buffer", "source", "org", "name", "file", "ref"], "reader": ["resource", " readers", "or", "stream", "instance", "http", "oder", "input", "io", "feed", "handler", "er", "rc", " parser", "read", "Reader", "iter", "tx", "writer", "data", "rr", "r", "parser", "info", "uri", "buffer", "file"]}}
{"id1": "19849797", "id2": "22135199", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 1, "substitutes": {"copyFile": ["cloneFile", " copyfile", " copyFiles", "transferFile", "cloneFiles", "copyfile", "cloneSource", "transferFiles", "copyFiles", "clonefile", "copySource", "transferSource", " copySource", "transferfile"], "sourceFile": ["srcDir", " sourcefile", "SourceFile", "SourceUrl", "sourcefile", "destUrl", "ourceDirectory", "destfile", "SourceDir", "SourceDirectory", "srcfile", "SourceFolder", "ourceFile", "ourceUrl", "sourceUrl", "destDirectory", " sourceFolder", "srcFile", "sourceFolder", "Sourcefile", "sourceDirectory", "sourceDir", "ourcefile", "srcFolder", " sourceDir"], "destFile": ["targetFile", "destPath", "resultfile", "sourceFiles", "resultDir", "destDir", "srcDir", " destDirectory", "foreignFiles", "srcFiles", "DestDirectory", "destPoint", "targetPath", "destfile", "foreignFile", "destFiles", "srcfile", "DestPath", "Destfile", "resultLine", "srcDirectory", "resultFile", "DestFile", "targetFiles", "destDirectory", "srcLine", "srcFile", "DestPoint", "sourcePoint", "foreignfile", " destFiles", "destLine", "DestDir", "sourceDir", "targetLine", " destDir", "DestFiles", " destPoint", "targetfile", "foreignPath", "targetDir", " destfile"], "source": ["resource", "scene", "slave", "root", "status", "route", "si", "use", "seed", "channel", "current", "cache", "context", "Source", "table", "view", "inner", "proxy", "service", "scope", "input", "ource", "manager", "api", "from", "slice", "this", "dest", "ce", "object", "unit", "ie", "connection", "storage", "server", "url", "get", "component", "config", "size", "index", "iter", "session", "wrapper", "image", "SOURCE", "start", "sin", "remote", "result", "file", "reader", "output", "secure", "target", "null", "id", "parent", "stream", "client", "uri", "src", "site", "core", "reference"], "destination": ["dominated", "identination", "identinated", "Destruction", "participination", " destinator", "participinate", "domination", "constinator", "construction", " destribution", "generination", " destation", "destribution", "generinated", "Destation", "destinator", "destation", "distruction", " destion", "generinator", "Destinator", "Destination", "destion", "dominator", "destinated", "Destion", "Destinated", "Destinate", "destinate", "constination", "destruction", "participinated", "generruction", "Destribution", " destinated", " destruction", "identinate", "distinated", "identinator", "distination", "distinator", "distion", "domation", "constribution", "participinator"]}}
{"id1": "9872346", "id2": "14794404", "code1": "    public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException {\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\");\n        Document document = null;\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            factory.setCoalescing(true);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDefaultUseCaches(false);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"User-Agent\", \"eXchaNGeR/\" + System.getProperty(\"xngr.version\") + \" (http://xngr.org/)\");\n            connection.connect();\n            InputStream stream = connection.getInputStream();\n            document = factory.newDocumentBuilder().parse(stream);\n            stream.close();\n            connection.disconnect();\n        } catch (SAXException e) {\n            if (e instanceof SAXParseException) {\n                throw (SAXParseException) e;\n            }\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \") [\" + document + \"]\");\n        return document;\n    }\n", "code2": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "label": 0, "substitutes": {"readRemoteDocument": ["readServerdocument", "loadLocalDocument", "loadRemotedocument", "readExternalDocument", "readLocalDocuments", "loadLocaldocument", "readServerDocuments", "readLocaldocument", "readServerDocument", "readLocalDocument", "readRemoteDocuments", "loadRemoteDocuments", "readRemotedocument", "loadLocalDocuments", "loadRemoteDocument", "readExternalDocuments", "readExternaldocument"], "url": ["resource", "entry", "username", "position", "string", "channel", "host", "http", "xml", "version", "service", "www", "URL", "path", "layer", "ll", "ur", "feed", "Url", "email", "rl", "download", "user", "address", "loc", "store", "l", "base", "server", "location", "load", "config", "sl", "f", "link", " URL", "filename", "image", "socket", "remote", "page", "ssl", "uri", "source", "client", "org", "name", "file", "lc"], "validate": ["validated", "Valate", "verated", " validation", "verating", "validating", "Valation", "validation", "Valated", "verate", "veration", " validating", "Valating", " validated"], "document": ["resource", "df", "application", "media", "container", "project", "function", "word", "degree", "view", "xml", "expression", "request", "language", "service", "response", "node", "doc", "database", "design", "Document", "content", "object", "dict", "valid", "video", " documentation", "model", "port", "location", "system", "office", "index", "f", "session", "value", "graph", "image", "record", "material", "result", "page", "output", "data", "ocument", "null", "metadata", "message", "parent", "source", "text", "collection"], "factory": ["fluent", "biller", "efluent", "fade", "fault", " folver", "bixture", "Filler", "fFactory", " filler", "sfluent", "dade", "hiller", "affactory", "sfault", "filler", "bactory", "efixture", "Folver", "pluent", "FFactory", "folver", "infiller", "pault", "dactory", "fsolver", "efactory", "Factory", "affault", "infade", "infactory", "future", "hade", "efiller", "fixture", "sfixture", "bluent", "affixture", "sfactory", "infuture", "fsFactory", " fFactory", "affluent", "diller", "pixture", "pactory", "duture", "hactory", "fsactory", "fsiller", "piller", "huture"], "connection": ["resource", "application", "use", "container", "section", "function", "position", "c", "Connection", "channel", "cache", "context", "current", "union", "http", "proxy", "character", "service", "condition", "response", "con", "io", "open", "driver", "database", "relation", "conn", "user", "creator", "translation", "handler", "default", "out", "communication", "server", "port", "system", "config", "index", "link", "session", "wrapper", "password", "image", "connect", "socket", "writer", "reader", "error", "connected", "info", "uri", "client", "collection", "version", "builder", "common"], "stream": ["resource", "or", "row", "entry", "media", "container", "string", "channel", "context", "view", "response", "input", "transform", "path", "io", "sc", "feed", "cont", "object", "translation", "handler", "trans", "video", "sw", "out", "Stream", "model", "upload", "server", "coll", "load", "system", "loader", "sl", "f", "per", "image", "writer", "result", "v", "reader", "output", "data", "raw", "stack", "source", "client", "body", "form", "version", "file"]}}
{"id1": "9872346", "id2": "21642215", "code1": "    public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException {\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\");\n        Document document = null;\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            factory.setCoalescing(true);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDefaultUseCaches(false);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"User-Agent\", \"eXchaNGeR/\" + System.getProperty(\"xngr.version\") + \" (http://xngr.org/)\");\n            connection.connect();\n            InputStream stream = connection.getInputStream();\n            document = factory.newDocumentBuilder().parse(stream);\n            stream.close();\n            connection.disconnect();\n        } catch (SAXException e) {\n            if (e instanceof SAXParseException) {\n                throw (SAXParseException) e;\n            }\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \") [\" + document + \"]\");\n        return document;\n    }\n", "code2": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"readRemoteDocument": ["readServerdocument", "loadLocalDocument", "loadRemotedocument", "readExternalDocument", "readLocalDocuments", "loadLocaldocument", "readServerDocuments", "readLocaldocument", "readServerDocument", "readLocalDocument", "readRemoteDocuments", "loadRemoteDocuments", "readRemotedocument", "loadLocalDocuments", "loadRemoteDocument", "readExternalDocuments", "readExternaldocument"], "url": ["resource", "entry", "username", "position", "string", "channel", "host", "http", "xml", "version", "service", "www", "URL", "path", "layer", "ll", "ur", "feed", "Url", "email", "rl", "download", "user", "address", "loc", "store", "l", "base", "server", "location", "load", "config", "sl", "f", "link", " URL", "filename", "image", "socket", "remote", "page", "ssl", "uri", "source", "client", "org", "name", "file", "lc"], "validate": ["validated", "Valate", "verated", " validation", "verating", "validating", "Valation", "validation", "Valated", "verate", "veration", " validating", "Valating", " validated"], "document": ["resource", "df", "application", "media", "container", "project", "function", "word", "degree", "view", "xml", "expression", "request", "language", "service", "response", "node", "doc", "database", "design", "Document", "content", "object", "dict", "valid", "video", " documentation", "model", "port", "location", "system", "office", "index", "f", "session", "value", "graph", "image", "record", "material", "result", "page", "output", "data", "ocument", "null", "metadata", "message", "parent", "source", "text", "collection"], "factory": ["fluent", "biller", "efluent", "fade", "fault", " folver", "bixture", "Filler", "fFactory", " filler", "sfluent", "dade", "hiller", "affactory", "sfault", "filler", "bactory", "efixture", "Folver", "pluent", "FFactory", "folver", "infiller", "pault", "dactory", "fsolver", "efactory", "Factory", "affault", "infade", "infactory", "future", "hade", "efiller", "fixture", "sfixture", "bluent", "affixture", "sfactory", "infuture", "fsFactory", " fFactory", "affluent", "diller", "pixture", "pactory", "duture", "hactory", "fsactory", "fsiller", "piller", "huture"], "connection": ["resource", "application", "use", "container", "section", "function", "position", "c", "Connection", "channel", "cache", "context", "current", "union", "http", "proxy", "character", "service", "condition", "response", "con", "io", "open", "driver", "database", "relation", "conn", "user", "creator", "translation", "handler", "default", "out", "communication", "server", "port", "system", "config", "index", "link", "session", "wrapper", "password", "image", "connect", "socket", "writer", "reader", "error", "connected", "info", "uri", "client", "collection", "version", "builder", "common"], "stream": ["resource", "or", "row", "entry", "media", "container", "string", "channel", "context", "view", "response", "input", "transform", "path", "io", "sc", "feed", "cont", "object", "translation", "handler", "trans", "video", "sw", "out", "Stream", "model", "upload", "server", "coll", "load", "system", "loader", "sl", "f", "per", "image", "writer", "result", "v", "reader", "output", "data", "raw", "stack", "source", "client", "body", "form", "version", "file"]}}
{"id1": "18631594", "id2": "3197876", "code1": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "code2": "    public ArrayList<String> showTopLetters() {\n        int[] tempArray = new int[engCountLetters.length];\n        char[] tempArrayLetters = new char[abcEng.length];\n        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();\n        tempArray = engCountLetters.clone();\n        tempArrayLetters = abcEng.clone();\n        int tempCount;\n        char tempLetters;\n        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {\n            for (int i = 0; i < abcEng.length - 1; i++) {\n                if (tempArray[i] > tempArray[i + 1]) {\n                    tempCount = tempArray[i];\n                    tempLetters = tempArrayLetters[i];\n                    tempArray[i] = tempArray[i + 1];\n                    tempArrayLetters[i] = tempArrayLetters[i + 1];\n                    tempArray[i + 1] = tempCount;\n                    tempArrayLetters[i + 1] = tempLetters;\n                }\n            }\n        }\n        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {\n            resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]);\n        }\n        return resultTopFiveLetters;\n    }\n", "label": 0, "substitutes": {"getMD5_Base64": ["getMD5_Meta8", "getMD5_base58", "getMD5_SHA8", "getMD5_Base62", "getMD5_SHA64", "getMD5Bybase64", "getMD5_base8", "getMD5_base64", "getMD5Bybase8", "getMD5ByBase58", "getMD5_Meta58", "getMD5_Meta62", "getMD5_SHA58", "getMD5_base62", "getMD5_Base8", "getMD5_Base58", "getMD5_SHA62", "getMD5ByBase62", "getMD5Bybase62", "getMD5_Meta64", "getMD5Bybase58", "getMD5ByBase8", "getMD5ByBase64"], "input": ["temp", "plus", "accept", "string", "IN", "request", "xml", "str", "empty", "list", "this", "in", "address", "alpha", "document", "base", "s", "out", "prefix", "url", "array", "Input", "inside", "i", "value", "password", "image", "format", "inf", "ssl", "output", "reader", "data", "type", "raw", "addin", "null", "pattern", "source", "buffer", "text", "form", "file"], "msgDigest": ["cmddigex", "cmdDigest", "msgDigener", "msgSignest", "msgCommester", "msgDer", "MsgDested", "msgMDested", "msgMixested", "msgSignend", "msgDigender", "msgCommest", "msgdigest", "msgPullex", "msgPullester", "msgDigEST", "msgDigester", "msgDested", "msgdigester", "msgdigex", "MsgDest", " msgSignest", " msgSignend", "docDigested", "cmddigest", "msgSignEST", " msgDigEST", "msgDiger", "docdigested", "msgdigender", "msgMDender", "msgdigend", "msgDester", "msgDest", "docdigender", "msgMixest", "msgDigend", "docDigest", " msgSignEST", "cmdDigex", "docdigEST", "msgDend", "docdigest", "msgDener", " msgDigend", "msgMDest", "cmddiger", "msgDigex", "cmdDiger", "msgDigested", "docDigEST", "msgdigEST", "MsgDigester", "cmdDigester", "msgSignester", "msgPuller", "cmddigester", "msgPullest", "MsgDester", "msgCommested", "msgDex", "msgdiger", "MsgDigener", "msgMixester", "MsgDigested", " msgSignester", "docDigender", "MsgDener", "msgdigested", "msgMixener", "MsgDigest", " msgDigester", "msgDEST", "msgMDEST", "msgCommener"], "rawData": ["RawCode", "rawText", "RAWCode", "RawString", "packageString", "rawCode", "rawString", " rawText", "packageData", "RawBytes", "packageText", "RAWByte", "rawBytes", " rawBytes", "RawText", " rawByte", "RawData", "RawByte", " rawString", " rawCode", "rawByte", "RAWData", "RAWBytes"], "encoded": ["decoder", "enoded", "engcoded", "encoder", "ecoding", "Encrypted", "decrypted", "ecoded", "engoded", "engoding", "enrypted", "Encoded", "enccoded", "enoder", "encoding", "Encoding", "decoding", "decoded", "engrypted", "enoding", "eccoded", "ecrypted", "Encoder", "Enccoded", "encrypted"], "retValue": ["newValue", "returnValue", "returnString", "returnValues", " retData", "newText", "RetData", "retData", "resultVal", "returnVal", "RetString", "retVal", " retText", "resultString", "newString", " retValues", "resultValue", "retString", "retText", "resultValues", " retString", "RetValue", "newData", "retValues", " retVal", "RetText"]}}
{"id1": "9109613", "id2": "11005804", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"fileCopy": ["FileCopy", " fileTransfer", "fileTransfer", "folderUpload", "folderCopy", "FileUpload", "filecopy", "FileTransfer", "foldercopy", "Filecopy", "fileUpload", " filecopy", "folderTransfer", " fileUpload"], "from_name": ["fromThename", "fromqpath", " from_key", "from_alias", "from_word", "from_space", " from_image", " from_no", " from_alias", "fromFullName", " from_time", " from__alias", "fromTheword", " from_resource", " from_space", "from_path", "fromamename", " from_address", " from_size", "fromTheName", "fromqfilename", "fromametime", "from_size", "fromqName", " from__address", "fromFullalias", "from_Name", " from_filename", "fromFullname", " from__Name", "fromameno", "from_resource", "from__address", "fromFulladdress", "from_key", "from_filename", "from__Name", "from_no", " from_path", "from__alias", "from__name", "fromThespace", " from_Name", "from_address", "from_image", "fromameName", " from_word", "from_time", "fromqname", " from__name"], "to_name": ["tokname", "from_names", "To_Name", "to_file", "tokcommon", "to_path", "to_Name", "tokName", "to_key", "to_common", "To_name", " to_file", " to_key", "from_Name", "To_common", "to_names", "from_path"], "fromFile": ["FromPage", " fromDirectory", "onefile", "ofFile", "FromFolder", "FromFiles", "autoFolder", " fromFolder", "FromLine", " fromFiles", "fromLine", "fromPage", "sourceLibrary", "autoPage", "onePage", "oneFile", "oneDir", " fromFunction", "FromDir", "sourcePage", "connectionFolder", "fromFiles", "FromLibrary", "FromFile", "fromDirectory", "connectionFile", "ofFolder", "connectionPackage", "fromFunction", "autoFile", "toLine", "FromModel", "fromModel", "asFile", "oneModel", " fromDir", "toFactory", "fromfile", "sourceFile", "FromDirectory", " fromFactory", "oneFunction", "sourceDirectory", "fromLibrary", "ofPackage", " fromPackage", "connectionfile", "fromDir", "oneFolder", "offile", "FromFunction", "toFiles", "Fromfile", " fromModel", "asFiles", "fromFolder", " fromLibrary", "toFunction", " fromPage", "tofile", " fromfile", " fromLine", "fromFactory", "fromPackage", "asfile", "asFactory", "autofile"], "toFile": ["targetFactory", "noLibrary", "ofFile", "coFile", "fromPage", "noFile", " toDirectory", "ofDir", "aFile", "ofTable", "TOPlace", "basefile", "fromfile", "targetPage", "TOFile", "coFunction", "ToPlace", "ToFile", "ToDirectory", "toFunction", "targetfile", "aFiles", "ToFunction", "noPage", "toLibrary", "fromFiles", "fromDirectory", "ToSourceFile", "targetPlace", "baseTable", "toFactory", " toFunction", "tempFile", "soLibrary", "ToFiles", "fromDir", "coDirectory", " toPage", "toTable", "ToPage", " toLine", " toTable", "TOPage", "toPlace", " toFactory", "soFile", "toLine", "soPage", "TODir", " tofile", "Tofile", "tempFolder", " toDir", "offile", "tempfile", "toFolder", "tofile", "ToDir", "targetDir", "toDirectory", "tempFactory", " toFolder", " toSourceFile", "nofile", "targetFile", "targetFolder", "fromLine", "baseDir", "toSourceFile", " toFiles", "afile", "ToLibrary", "sofile", "aDir", "cofile", "targetSourceFile", "baseFile", "ToLine", "toDir", "ToFactory", "toFiles", "toPage"], "parent": ["resource", "Parent", "full", "g", "current", "manager", "address", "p", "valid", "rule", "out", "pa", "port", "url", "location", "guard", "pool", "file", "lc", "or", "and", "region", "shape", "patch", "user", "loc", "connection", "pe", "page", "data", "term", "null", "master", "par", "root", "class", "paren", "section", "owner", "col", "exp", "search", "ac", "div", "content", "part", "complete", "home", "any", "type", "id", "large", "client", "name", "line", "ip", "string", "pr", "parents", "option", "path", "api", "pt", "key", "child", "server", "session", "remote", "test", "directory", "point", "inc", "source"], "dir": ["folder", "dc", "or", "group", "root", "dis", "class", "keep", "container", "cat", "rec", "col", "ir", "exp", "dist", "d", "path", "di", "manager", "fd", "die", "attr", "doc", "dev", "wd", "div", "DIR", "def", "loc", "build", "rel", "dict", "mod", "out", "coll", "url", "cur", "dr", "f", "per", "iter", "director", "home", "Dir", "lib", "directory", "r", "inc", "lock", "ver", "block", "dep", "name", "db", "file", "dec"], "from": ["or", "ch", "fr", "wh", "who", "so", "cm", "clean", "c", "channel", "low", "o", "view", "with", "self", "old", "From", "vol", "con", "can", "io", "api", "empty", "add", "this", "flo", "in", "hand", "ce", "conn", "user", "ra", "cr", "connection", "part", "base", "normal", "when", "out", "url", "get", "query", "left", "component", "bean", "per", "link", "e", "without", "by", "auto", "start", "range", "se", "ou", "parse", "module", "po", "de", "source", "stream", "client", "form", "name", "file", "one"], "to": ["or", "plus", "ver", "token", "not", "again", "so", "cache", "op", "pi", "o", "go", "see", "http", "proxy", "with", "copy", "about", "be", "io", "api", "co", "via", "fat", "sync", "flo", "on", "no", "tto", "object", "store", "tom", "connection", "base", "out", "TO", "will", "two", "port", "To", "size", "office", "eto", "su", "by", "top", "auto", "page", "until", "output", "type", "too", "target", "po", "b", "fb", "source", "name", "db", "file", "one"], "buffer": ["resource", "row", "seed", "position", "string", "cache", "channel", "vector", "table", "uffer", "character", "total", "padding", "comment", "layer", "shape", "texture", "feed", "buf", "queue", "number", "length", "address", "header", "batch", "default", "document", "device", "server", "variable", "read", "Buffer", "iter", "value", "bytes", "transfer", "page", "memory", "result", "reader", "border", "data", "null", "buff", "flush", "message", "duration", "binary", "available", "block", "reference"], "bytes_read": ["lines_put", "bytesESSreceived", "bytesESSput", "classesavread", "bytesavavailable", "bytes_available", "bytesavREAD", "bytesavview", "classesavavailable", "lines_read", "bytesavread", "bytes___READ", "bytesayread", "bytes___view", " bytes_load", "lines_received", "bytes_put", "classes_READ", "classes_available", "bytes_READ", " bytes_write", "classes_read", "bytes_write", "bytes_view", " bytes_written", "classes_view", "bytes_load", "bytes_written", "bytes___read", "lines_written", "bytes_received", "bytesaywritten", "bytesESSwritten", "bytes___available", "bytesESSread", "classesavREAD", "bytesayput", "classesavview", "bytesayreceived"]}}
{"id1": "16063533", "id2": "4016687", "code1": "    public static byte[] encrypt(String x) throws Exception {\n        java.security.MessageDigest d = null;\n        d = java.security.MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(x.getBytes());\n        return d.digest();\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        String sFTP = \"ftp.miservidor.com\";\n        String sUser = \"usuario\";\n        String sPassword = \"password\";\n        try {\n            System.out.println(\"Conectandose a \" + sFTP);\n            client.connect(sFTP);\n            boolean login = client.login(sUser, sPassword);\n            if (login) {\n                System.out.println(\"Login correcto\");\n                boolean logout = client.logout();\n                if (logout) {\n                    System.out.println(\"Logout del servidor FTP\");\n                }\n            } else {\n                System.out.println(\"Error en el login.\");\n            }\n            System.out.println(\"Desconectando.\");\n            client.disconnect();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["enrypt", "decrypted", "Encrypt", "deccrypt", "Encipher", "decrypt", "enccrypt", "encipher", "enrypted", "Enccrypt", "decipher", "enipher", "Encrypted", "encrypted"], "x": ["xes", "string", "m", "y", "ex", "xml", "xa", "fx", "xxxxxxxx", "z", "text", "hex", "xy", "xs", "content", "p", "xxx", "xxxx", "s", "X", "f", "rex", "e", "code", "xp", "tx", "v", "data", "xx", "b", "xi", "t", "message", "es", "crypt", "rx"], "d": ["dc", "pd", "od", "u", "and", "m", "o", "da", "fd", "di", "bd", "ed", "ad", "p", "dict", "dd", "ld", "cd", "ade", "dh", "dt", " dd", "dx", "f", "nd", "e", "i", "ds", "gd", "dom", "ded", "dad", " D", "data", "dig", "sd", "md", "b", "de", "t", "id", "D", "rd", "mad", "vd", "db"]}}
{"id1": "18731843", "id2": "19549489", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "label": 1, "substitutes": {"doBody": ["handleFile", " doResponse", "DoResponse", "DoFile", "handleBody", " doFile", "doResponse", " doBytes", "DoBytes", "doBytes", "handleBytes", "DoBody", "handleResponse", "doFile"], "req": ["rss", "resource", "requ", "serv", "respond", "rec", "rh", "request", "spec", "http", "Request", "report", "this", "qq", "download", "conn", "def", "err", "proc", "qt", "query", "reg", "config", "cgi", "comp", "crit", "sem", "q", "res", "reader", "data", "rr", "r", "obj", "jp", "info", "rx", "src", "fr", "ref"], "resp": ["Response", "rep", "inv", "cmp", "serv", "respond", "respons", "cache", "rec", "reply", "request", "response", "report", "api", "download", "ret", "err", "p", "proc", "part", "pos", "exc", "sp", "comp", "pre", "Resp", "res", "cb", "result", "val", "bb", "html", "data", "jp", "rr", "r", "b", "obj", "rev", "job", "prot", "re", "ref"], "bis": ["oris", "usb", "bh", "ses", "ios", "bs", "bps", "ois", "obos", "is", "rots", "bin", "uds", "iris", "abi", "ubis", "obi", "ais", "atis", "os", "bits", "obb", "boot", "bi", "obs", "isin", "bian", "pins", "bes", "los", "iss", "sb", "bas", "bid", "sis", "ori", "alis", "sin", "mis", "bb", "lis", "nis", "b", "tis", "fb", "lins", "binary", "ris", "phis"], "bos": ["bh", "ios", "ois", "bs", "oks", "osi", "oops", "mos", "obos", "bps", "obo", "fits", "bin", "uds", "abi", "ubis", "obi", "bits", "os", "aos", "osa", "obb", "boot", "bi", "oos", "obs", "lol", "opus", "bes", "los", "oS", "ops", "bris", "oros", "zo", "bas", "bott", "oses", "bo", "ros", "zos", "tis", "lins", "antis", "las", "phis", "bones"]}}
{"id1": "23666973", "id2": "5759961", "code1": "    private InputStream openStreamRaw(String filename) {\n        InputStream stream = null;\n        if (filename == null) return null;\n        if (filename.length() == 0) {\n            return null;\n        }\n        try {\n            URL url = new URL(filename);\n            stream = url.openStream();\n            return stream;\n        } catch (MalformedURLException mfue) {\n        } catch (FileNotFoundException fnfe) {\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        ClassLoader cl = getClass().getClassLoader();\n        stream = cl.getResourceAsStream(\"data/\" + filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        stream = cl.getResourceAsStream(filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        return stream;\n    }\n", "code2": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "label": 0, "substitutes": {"openStreamRaw": ["openstreamSource", "openFileAsync", "createSteamRaw", "createSteamAsync", "openstreamRaw", "createStreamSource", "openstreamAsync", "openStreamInternal", "openFileInternal", "openstreamInternal", "openStreamSource", "createStreamRaw", "openSteamInternal", "createSteamInternal", "openSteamSource", "openSteamAsync", "openSteamRaw", "openFileSource", "createStreamAsync", "openFileRaw", "createStreamInternal", "createSteamSource", "openStreamAsync"], "filename": ["resource", "txt", "il", "class", "subject", "username", "fax", "n", "string", "SourceFile", "href", "utf", "lua", "word", "jpg", "sf", "title", "Filename", "actual", "path", "kn", "fd", "fil", "database", "ppa", "length", "download", "sql", "rl", "fn", "sound", "l", "prefix", "ename", "phrase", "location", "license", "size", "loader", "f", "FILE", "undle", "dll", "password", "journal", "fp", "login", "nil", "directory", "data", "acl", "kl", "wl", "uri", "source", "src", "name", "which", "file"], "stream": ["resource", "stage", "full", "current", "rest", "view", "http", "log", "pair", "impl", "valid", "w", "port", "sl", "pool", "image", "socket", "draft", "ssl", "parent", "body", "file", "clean", "continue", "feed", "slice", "length", "steam", "video", "model", "cur", "thread", "value", "output", "null", "message", "iv", "hook", "row", "pull", "live", "class", "channel", "instance", "host", "transform", "open", "sync", "content", "trans", "upload", "coll", "load", "size", "f", "enc", "callback", "uc", "reader", "raw", "stack", "loop", "client", "cont", "temp", "accept", "zip", "string", "context", "method", "input", "response", "path", "download", "object", "child", "sample", "sw", "Stream", "event", "server", "control", "session", "wrapper", "through", "result", "bb", "back", "source", "buffer", "form", "ream", "core"], "url": ["resource", "line", "string", "channel", "http", "www", "URL", "path", "ll", "api", "feed", "Url", "loc", "rel", "l", "base", "server", "plug", "coll", "loader", "sl", "f", "e", "ul", "el", "image", "lib", "page", "ssl", "data", "fl", "b", "id", "web", "source", "uri", "name", "file"], "cl": ["ctrl", " CL", "class", "ml", "sh", "c", "col", "pl", "ll", "con", "ctx", "sc", "gl", "ct", "client", "scl", "loc", "bl", "cc", "l", "cr", "comb", "ocl", "decl", "pe", "ls", "coll", "shell", "loader", "bc", "sl", "cli", "hell", "cle", "el", "lib", "uc", "Cl", "ssl", "fl", "acl", "kl", "ec", "sel", "lock", "CL", "cont", "cel", "lc"], "cn": ["dc", "cdn", "arn", "auc", "nic", "cm", "ain", "act", "n", "uh", "ca", "abc", "cone", "Ns", "dn", "kn", "con", "xc", "ains", "bn", "cf", "ct", "wcs", "conn", "fn", "kin", "cr", "cc", "nat", "mc", "net", "mn", "coll", "sn", "gin", "enc", "ns", "CN", "gn", "hn", "cb", "rn", "ae", "ln", "nam", "cy", "nc", "ec", "jc", "icon", "CA", "core", "lc", "CW"]}}
{"id1": "23199071", "id2": "539195", "code1": "            @Override\n            public InputStream getInputStream() {\n                try {\n                    String url = webBrowserObject.resourcePath;\n                    File file = Utils.getLocalFile(url);\n                    if (file != null) {\n                        url = webBrowserObject.getLocalFileURL(file);\n                    }\n                    url = url.substring(0, url.lastIndexOf('/')) + \"/\" + resource;\n                    return new URL(url).openStream();\n                } catch (Exception e) {\n                }\n                return null;\n            }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"getInputStream": ["newContentstream", "newContentSteam", "getInputChannel", "getReadStream", "getStreamstream", "getContentStream", "getContentSteam", "getContentstream", "getReadChannel", "newInputstream", "getInputSteam", "newContentChannel", "getStreamStream", "newInputChannel", "newInputStream", "getReadSteam", "getStreamSteam", "getStreamChannel", "newInputSteam", "newContentStream", "getInputstream", "getContentChannel", "getReadstream"], "url": ["resource", "pull", "fr", "route", "class", "ob", "full", "string", "resources", "host", "href", "http", "str", "tool", "service", "www", "URL", "path", "ll", "log", "ur", "api", "feed", "gl", "in", "Url", "email", "rl", "download", "user", "address", "dir", "bel", "build", "lr", "rel", "loc", "default", "l", "cl", "base", "rule", "server", "location", "coll", "left", "sl", "f", "link", "i", "q", "ul", "el", "image", "remote", "html", "ssl", "page", "secure", "type", "data", "fl", "r", "null", "jar", "id", "web", "uri", "source", "buffer", "name", "ref"], "file": ["File", "resource", "folder", "fe", "able", "local", "live", "class", "route", "use", "line", "full", "zip", "cache", "http", "money", "path", "log", "feed", "files", "place", "object", "child", "dir", "letter", "unit", "loc", "play", "l", "connection", "rule", "base", "part", "model", "work", "f", "FILE", "e", "image", "lib", "plain", "fp", "page", "data", "b", "id", "job", "info", "uri", "source", "name", "db"]}}
{"id1": "9275622", "id2": "20619879", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", " copyFiles", "transferFile", "moveFiles", "movefile", " copyFolder", "moveFolder", "copyfile", "copyFolder", "transferFiles", "copyFiles", "transferFolder", "moveFile", "transferfile"], "_file1": ["_zip1", "_files2", "_mail01", "_resourceOne", "_zipone", "_fileFirst", "_files01", "_File01", "_file01", "_mail1", "_fileOne", "_fFirst", "_f1", "_fileone", "_mail2", "_files0", "_file0", "_File1", "_zipOne", "_File2", "_files1", "_fOne", "_resourceone", "_resourceFirst", "_zipFirst", "_fone", "_resource1", "_File0", "_mail0"], "_file2": [" _file3", "_playsecond", "_files2", "jmodelsecond", "jfile5", "_modelsecond", "_play4", "_file3", "_files4", "_file5", "jmodel5", "_play1", "jfilesecond", " _filesTwo", " _file4", "_model2", "_model1", "_play2", "_filesecond", " _files3", "_playTwo", "_model5", "_File5", "jmodel1", "jmodel2", " _files2", " _fileTwo", "jfile2", "_File1", "_File2", " _files4", "_filesTwo", "_play5", "_fileTwo", "jfile1", "_play3", "_files3", "_Filesecond", "_file4"], "fis": ["lfis", "cfiss", "Fiss", " fais", "cfas", "afis", "infils", "infos", "fils", " fiss", "infiss", "afi", "fris", "Fils", "infis", "fas", "fais", "afais", "afiss", " fi", " fas", "fi", " fris", "Fis", "lfiss", " fils", "cfis", "Fos", "lfais", "cfris", "lfi", "Fris", "fiss", "Fas", "cfos"], "fos": ["Fros", "Foses", "fus", "goses", "infios", "infus", "lOS", "flos", "floes", "fo", "gos", "Foos", " foos", "fios", "infos", "pis", "foos", "loes", "gis", "poes", "faos", " fios", "pOS", "Fus", "fros", " fo", "flOS", "pos", "los", "foes", " fus", "fOS", "feus", "flis", "Fis", "gus", "infoos", "foses", "infaos", "Fos", "feoses", "feis", "Fios", " faos", "infros", "Faos", "lis", "feos", " fros", "Fo", "info"], "canalFuente": ["canalFuze", "canalBuencia", "canalsBuente", "canaledFuje", "canaledBuente", "canalBuze", "canalSuze", "canaledBuestro", "canaledFuestro", "canallFuencia", "canalFuestro", "canalCraento", "canalsFuento", "canalBuje", "canallFuze", "canalsBuence", "canalFUente", "canalKuente", "canalsFuencia", "canalSuente", "canalFUestro", "canalsBuencia", "canalKuze", "canalFuento", "canalFUencia", "canalsFuente", "canalKuencia", "canalFUze", "canaledBuze", "canallFuente", "canalCraencia", "canalFuencia", "canalBuente", "canalKuence", "canallFuence", "canallBuencia", "canalFUence", "canalKuento", "canalBuento", "canalBuence", "canaledFuze", "canalsBuento", "canallBuente", "canalFUje", "canalFuje", "canalCraence", "canaledFuente", "canalSuestro", "canallBuze", "canalFuence", "canalsFuence", "canalCraente", "canallBuence", "canalSuje", "canaledBuje", "canalBuestro"]}}
{"id1": "189963", "id2": "8588992", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public ActionForward perform(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String status = null;\n        HttpSession session = request.getSession();\n        ReportingBean reportingBean = null;\n        NewConceptBean conceptBean = null;\n        String conceptName = null;\n        String primitive = null;\n        MessageResources errorMessages = MessageResources.getMessageResources(\"com.apelon.apps.dts.treebrowser.resources.error_messages\");\n        LogonUtilities logonUtilities = new LogonUtilities();\n        if (logonUtilities.checkSession(session, status, reportingBean, errorMessages)) {\n            reportingBean = (ReportingBean) session.getAttribute(\"reportingBean\");\n            if ((reportingBean.getMessageHtml().indexOf(\"Classify\")) == -1) {\n                reportingBean.setReportingHtml(\"\");\n            }\n            conceptBean = (NewConceptBean) session.getAttribute(\"newConceptEntity\");\n            conceptName = request.getParameter(\"conceptName\");\n            primitive = request.getParameter(\"primitive\");\n            if (primitive == null) {\n                primitive = \"false\";\n            }\n            conceptBean.setConceptName(conceptName);\n            conceptBean.setPrimitive(primitive);\n            String namespace = conceptBean.getConceptNamespace();\n            if (namespace == null) {\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_3\"));\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n                return (mapping.findForward(status));\n            }\n            String[] roleMods = request.getParameterValues(\"some_or_all\");\n            String[] roleGrps = request.getParameterValues(\"role_group\");\n            Vector roles = conceptBean.getRoles();\n            RoleBean[] roleCons = new RoleBean[roles.size()];\n            roles.copyInto(roleCons);\n            if (roleMods != null && roleGrps != null && roleCons != null) {\n                if (roleCons.length == roleMods.length && roleCons.length == roleGrps.length) {\n                    for (int i = 0; i < roleCons.length; i++) {\n                        roleCons[i].setSomeOrAll(roleMods[i]);\n                        roleCons[i].setRoleGroup(roleGrps[i]);\n                    }\n                }\n            }\n            session.setAttribute(\"newConceptEntity\", conceptBean);\n            NewConceptXMLDisplayBean xmlBean = new NewConceptXMLDisplayBean();\n            xmlBean.setNewConceptXml(conceptBean);\n            String data = BrowserUtilities.encodeUrl(\"conceptXml\") + \"=\" + BrowserUtilities.encodeUrl(xmlBean.getNewConceptXml()) + \"&\" + BrowserUtilities.encodeUrl(\"nameSpace\") + \"=\" + BrowserUtilities.encodeUrl(namespace);\n            XMLPropertyHandler configPh = new XMLPropertyHandler(\"dtsbrowserclassify.xml\");\n            Properties configProps = configPh.getProps();\n            String urlString = configProps.getProperty(\"url\");\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuffer buf = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                buf.append(line);\n            }\n            String resultXml = buf.toString();\n            wr.close();\n            rd.close();\n            ClassifiedConceptBean ccBean = new ClassifiedConceptBean();\n            ClassifyResultParser parser = new ClassifyResultParser(resultXml);\n            ResultBuilder rbuilder = new ResultBuilder();\n            rbuilder.setConceptBean(ccBean);\n            rbuilder.setParser(parser);\n            rbuilder.setNamespace(namespace);\n            try {\n                rbuilder.buildResult();\n                ccBean = rbuilder.getConceptBean();\n                ClassifiedConceptDisplayBean displayBean = new ClassifiedConceptDisplayBean();\n                displayBean.setNewConceptHtml(ccBean);\n                session.setAttribute(\"classifyResult\", ccBean);\n                session.setAttribute(\"classifyDisplayResult\", displayBean);\n                status = \"success\";\n            } catch (Exception e) {\n                Categories.dataServer().error(StackTracePrinter.getStackTrace(e));\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_1\") + e.getMessage());\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n            }\n        }\n        return (mapping.findForward(status));\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "10214218", "id2": "2398448", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private void handleURL() throws JspException, IOException {\n        Map in_map = prepareInputMap();\n        String in_str = JSONTransformer.serialize(in_map);\n        byte[] input = in_str.getBytes(\"UTF-8\");\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        conn.connect();\n        OutputStream os = conn.getOutputStream();\n        os.write(input);\n        os.close();\n        InputStream is = conn.getInputStream();\n        InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n        StringBuffer s_buf = new StringBuffer();\n        char[] tmp_buf = new char[1024];\n        int count;\n        while ((count = reader.read(tmp_buf)) != -1) {\n            if (count == 0) continue;\n            s_buf.append(tmp_buf, 0, count);\n        }\n        reader.close();\n        Map out_map = null;\n        try {\n            out_map = JSONTransformer.parseObject(s_buf.toString());\n        } catch (ParseException e) {\n            returnErrorResult(e.getMessage());\n        }\n        handleResultMap(out_map);\n    }\n", "label": 0, "substitutes": {"encrypt": ["enrypt", " encress", "deccrypt", "enress", "decrypt", "decress", "enccrypt", "encipher", " enccrypt", "decipher", " encipher", "enipher", "encress"], "plaintext": [" plaintxt", "battxt", "plainText", "plainstruct", "maintext", "battext", "mainsource", "batsource", "anytxt", " plainText", "batText", " plainstruct", "plainsource", " plainsource", "plaintxt", "anystruct", "anytext", "mainText", "anyText", "mainstruct", "batstruct"], "md": ["mb", "mg", "mp", "pd", "mage", "pm", "od", "ms", "mand", "cm", "mac", "Cmd", "m", "em", "pg", "sm", " MD", "d", "sha", "hm", "MD", "bd", "key", "meta", "wd", "ad", "dd", "ld", "mc", "mod", "cmd", "dh", "dr", "mag", "ma", "am", "arm", "dm", "nm", "amd", "data", "dig", "kg", "mm", "metadata", "message", "mad", "mt", "mu", "db", "mo"], "raw": ["row", "words", "full", "clean", "instance", "initial", "unknown", "input", "wave", "feed", "hex", "buf", "none", " RAW", "content", "original", "ack", "good", "ng", "rc", "rew", "load", "array", "enc", "Raw", "serial", "wrapper", "image", "bytes", "unsigned", "data", "null", "pack", "RAW", "binary", "buffer", "text", "block", "message", "dec"], "hash": ["hed", "sh", "mac", "cache", "Hash", "rh", "secret", "ruby", "sha", "response", "sum", "abi", "log", " hex", "hex", "key", "ashes", "header", "kh", "alpha", "ha", "base", "url", "ash", "array", "code", "her", "image", "h", "html", "data", "id", "message", "block", "version"]}}
{"id1": "255765", "id2": "20920051", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"f": ["fa", "df", "folder", "fe", "ref", "fr", "F", "fc", "function", "of", "g", "c", "n", "m", "sf", "d", "fo", "fun", "fx", "self", "path", "fd", "io", "feed", "this", "cf", "fold", "fn", "p", "fs", "l", "ff", "tf", "s", "w", "j", "x", "fi", "flat", "e", "fm", "filename", "a", "h", "fp", "inf", "v", "fen", "r", "b", "bf", "t", "lf", "form", "name", "file", "rf"], "in": ["fe", "again", "serv", "g", "ini", "m", "cin", "ex", "with", "con", "inn", "p", "l", "isin", "w", "rin", "nin", "image", "socket", "v", "ssl", "gen", "t", "fa", "In", "or", "c", "rec", "d", "str", "bin", "ic", "pin", "connection", "init", "win", "login", "data", "n", "IN", "din", "ins", "ac", "min", "part", "lin", "get", "thin", "reader", "diff", "r", "lock", "pass", "token", "is", "inner", "input", "err", "it", "up", "exec", "gin", "config", "session", "a", "vin", "b", "inc", "source"], "cbuf": ["fbuff", "ebuf", "cfur", "zbuu", "rbull", "cbur", "cfuf", "cbuff", "bbuff", "bcuf", "rbuc", "cbutf", "fbbuf", "cfuff", "fbuc", "bcull", "fbuf", "bbull", "cbuc", "cburs", "cbault", "cfuc", "cbbuf", "cfbuf", "bcul", "rbuu", "rbul", "buf", "cbul", "bburs", "CBuc", "CBuff", "cbull", "bcuc", "CBul", "CBuf", "dbuf", "rbutf", "zbuf", "cbuu", "bcur", "bault", "rburs", "rbux", "ebuff", "ebutf", "zbutf", "rbuf", "zbuff", "cbux", "rbault", "rbbuf", "bbuf", "bcux", "ebuu", "dbuc", "dbur", "bux", "buff", "bcault", "dbuff", "rbuff", "bcurs", "bcuff"], "read": ["each", " Read", "use", "draw", "full", "g", "want", "call", "view", "log", "ak", "count", "build", "valid", "oct", "w", "orig", "ink", "q", "start", "check", "socket", "val", "error", "write", "sleep", "text", "y", "select", "d", "report", "lex", "io", " reading", "feed", "add", "only", "hex", "length", "repeat", "play", "pe", "find", "x", "wait", "iter", "allow", "used", "record", "last", "data", "en", "stream", "connect", "cel", "re", "end", "reads", "send", "know", "old", "open", "sync", "skip", "num", "ed", "seek", "ing", "er", "print", "insert", "rc", "get", "load", "work", "size", "index", "ok", "level", "reader", "type", "parse", "raw", "r", "id", "loop", "name", "ize", "pass", "run", "k", "readable", " write", "reading", "fill", "input", "READ", "key", "bit", " READ", "child", "ack", "Read", "it", "config", "ind", "bind", "un", "close", "ride", "change", "se", "put", "inc", "buffer", "update", "create"], "totRead": ["totoRead", "totaRead", " totBuild", "TottRead", "tottLength", "TottLoad", "dotReader", "towWrite", " totWrite", "totClose", "tetRead", "dottWrite", "totoReading", "dotUse", "tobyUse", "tazonClose", "totLoad", " totalBuild", "TottWrite", "tottedRead", "tochWrite", "toyRead", "tcotRead", "TotaDraw", "tottDraw", "ntottReader", "toyLoad", "totiRead", "totalLink", "tottAccept", "nottWrite", "tottBuild", "dottReader", "tcotClose", "tollWrite", "totReader", "TottConnect", "totaBuild", "tochLoad", "totaDraw", "totoSearch", "ntottLoad", "tntLoad", "TotReading", "totConnect", "tochRead", "totReading", "totiLink", "intotRead", "tobyRead", "intotLoad", "TottGet", "tollReading", " totLink", "nottAccept", "tetLoad", "totSearch", "tollRead", "totingFollow", "tottedGet", "tottFollow", "totoWrite", "TottReader", "tobyLoad", "TottReading", "totaLoad", "tntReader", "tobyFind", "intottLoad", "totBuild", "tetWrite", "TotGet", "TotLoad", "toyWrite", "dottLoad", "totaWrite", "totalWrite", "totalBuild", "totoLength", "totWrite", "notRead", "tottReading", "tottSearch", "octotLength", "totingSearch", "totingGet", "towReading", "TotConnect", "totingRead", "intottClose", "tcotBuild", "TotaRead", "dotReading", "TotSearch", "totLength", "tottedFollow", "totaReading", "tottWrite", "notAccept", "totiWrite", "dottFind", "tottRead", "totUse", "totoLoad", "totaLink", "totoConnect", "tochReader", "tatRead", "intottBuild", "TotWrite", "tetReading", "tottLoad", "totaReader", "totoFind", "tazonLoad", "TotaWrite", "TotRead", "octotoWrite", "tottFind", "totiBuild", "octotReading", "tottClose", "dotLoad", "TotaLoad", "towLength", "tatReader", "ntotWrite", "dottRead", "ntotReader", "totGet", "octotoRead", "towAccept", "octotWrite", "toyDraw", "TotFollow", "tntRead", "tatLoad", "tottGet", "dotRead", "totFind", "totingWrite", "tottReader", "dotWrite", "TottSearch", "totingConnect", "nottRead", "totAccept", "intottRead", "TotDraw", "ntottWrite", "towLoad", "tottUse", "ntotRead", "tottedWrite", "TotReader", "dottUse", "octotoReading", "totDraw", "towRead", "totalRead", " totalRead", "intotClose", "intotBuild", "tazonBuild", "ntottRead", "dotFind", "tatWrite", "dottReading", "tntWrite", "totLink", "totalLoad", "TottFollow", "totoUse", "octotoLength", "octotRead", "tcotLoad", " totalLink", "tazonRead", "notLoad", "ntotLoad", "totalAccept", "tollLoad", "notWrite", " totalWrite", "totFollow", "tottConnect", "nottLoad"], "out": ["In", "plus", "again", "n", "c", "g", "o", "ex", "exp", "d", "bin", "Out", "outer", "io", "outs", "sync", "ac", "conn", "fn", "p", "err", "up", "l", "part", "w", "s", "net", "init", "connection", "exec", "x", "off", "a", "h", "writer", "socket", "v", "ext", "output", "obj", "OUT", "r", "b", "t", "inc", "conf", "parent", "client", "file"], "i": ["hi", "ini", "ii", "g", "m", "current", "ci", "z", "bi", "my", "p", "l", "phi", "eni", "q", "start", "gi", "v", "ai", "yi", "uri", "iu", "c", "y", "o", "d", "ic", "io", "slice", "ji", "length", "init", "fi", "x", "ori", "ni", "ti", "data", "mi", "ik", "one", "chi", "multi", "pi", "abi", "di", "ei", "ie", "j", "I", "index", "oi", "li", "h", "r", "zi", "xi", "id", "name", "si", "qi", "ip", "u", "k", "ix", "is", "input", "api", "key", "ui", "ri", "it", "e", "ind", "b", "info", "buffer", "source", "me"]}}
{"id1": "17791385", "id2": "20011285", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "src": ["resource", "txt", "http", "dist", "input", "inst", "sc", "dest", "ins", "files", "ipl", "loc", "sup", "s", "rc", "ls", "upload", "url", "config", "sb", "sl", "filename", "image", "sin", "inf", "img", "st", "obj", "b", "back", "source", "stream", "uri", "sit", "rb", "sel", "file"], "dst": ["stst", "dsp", "ddest", "ddfd", "dfd", "stdest", "fdst", "ststs", " dsts", "Dlt", "pdfd", "pdst", "Dst", "fdfd", "ddft", "dsts", "Ddest", "ddsp", "ddst", " dlt", " ddest", "dft", "fdsp", "dlt", "fdft", "pdft", "Dsts", "pdsp", "stlt"], "in": ["In", "pull", "again", "n", "ini", "oin", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "as", "con", "pin", "ins", "impl", "conn", "inn", "err", "kin", "init", "win", "rin", "lin", "url", "gin", "f", "inside", "i", "nin", "h", "sin", "socket", "login", "reader", "data", "r", "inc", "id", "ln", "file"], "out": ["temp", "line", "at", "again", "n", "cache", "o", "ex", "exp", "bin", "Out", "self", "copy", "outer", "io", "outs", "post", "sync", "conn", "err", "up", "part", "net", "w", "s", "exec", "server", "x", "f", "other", "off", "i", "writer", "plain", "ext", "output", "raw", "obj", "OUT", "null", "inc", "parent", "client", "file"], "buf": ["bh", "vec", "cat", "c", "bin", "fd", "ctx", "bd", "queue", "pad", "length", "seq", "count", "loc", "batch", "br", "bl", "bag", "ff", "base", "rc", "cmd", "cur", "bc", "off", "lim", "cap", "uf", "uc", "bytes", "cb", "val", "v", "bb", "data", "fl", "raw", "b", "bf", "buff", "fb", "buffer", "wb", "rb"], "len": ["lt", "line", "n", "c", "fin", "bin", "le", "Len", "ll", "fd", "length", "no", "count", "err", "l", "part", "cl", "base", "pos", "all", "lin", "size", "sl", "f", "i", "li", "ind", "cap", "el", "split", "lim", "val", "nt", "data", "fl", "en", "lf", "rev", "ix", "ln", "name", "lc", "end"]}}
{"id1": "2461169", "id2": "12246545", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void load(String url) throws IOException {\n        this.url = url;\n        int col = url.indexOf(':');\n        if (col > 1 && col < 5) {\n            load(new URL(url).openStream());\n        } else {\n            if (new File(url).exists()) {\n                System.out.println(\"Loading JAD from file : \" + url);\n                FileInputStream fin = new FileInputStream(url);\n                try {\n                    load(fin);\n                } finally {\n                    fin.close();\n                }\n            } else {\n                InputStream in = getClass().getResourceAsStream(url);\n                if (in != null) {\n                    System.out.println(\"Loading JAD from classpath : \" + url);\n                    load(in);\n                } else {\n                    throw new IOException(\"\\\"\" + url + \"\\\" was found in file system or classpath\");\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeStringToFiles", "decodeFileAsFiles", "decodeStringToFile", "decodeFileAsStream", "decodeString2Stream", "decodeFileFromStream", "decodeFileFromFiles", "decodeStringToString", "decodeFile2File", "decodeFileAsString", "decodeFileFromFile", "decodeStringToStream", "decodeFileToString", "decodeString2String", "decodeFile2String", "decodeFile2Files", "decodeFileToStream", "decodeFileToFiles", "decodeFileAsFile", "decodeString2File", "decodeString2Files", "decodeFileFromString", "decodeFile2Stream"], "infile": [" infp", " instream", "minbase", "Inbase", "inputfilename", "infp", "minstream", "outfiles", " infiles", "minFile", "inputfp", "inputfiles", "minfile", "outfilename", "Infile", "inbase", " inbase", "outfp", " infilename", "instream", "InFile", "inFile", "inputfile", " inFile", "Instream", "infiles", "infilename"], "outfile": ["outputpath", "outfolder", " outdatabase", "inputFile", "outputFile", "inputdatabase", " outFile", "outfilename", "inputpath", " outfilename", " outfolder", "outpath", " outpath", "outputdatabase", "inFile", "inputfile", "infolder", "outputfolder", "outFile", "outputfile", "outputfilename", "infilename", "outdatabase"], "in": ["In", "inas", "pass", "again", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "ic", "as", "con", "pin", "ins", "ac", "min", "conn", "inn", "into", "err", "isin", "init", "win", "s", "rin", "lin", "gin", "thin", "inside", "i", "nin", "a", "socket", "sin", "login", "reader", "data", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "In", "or", "pass", "exit", "line", "again", "cache", "channel", "o", "ex", "inner", "bin", "Out", "copy", "outer", "log", "io", "outs", "co", "post", "sync", "conn", "no", "err", "up", "net", "base", "exec", "work", "name", "session", "off", "home", "image", "lib", "socket", "to", "writer", "output", "error", "ou", "write", "obj", "OUT", "point", "job", "inc", "parent", "client", "one", "file"], "buffer": ["seed", "channel", "cache", "uffer", "limit", "padding", "bin", "input", "layer", "wave", "feed", "buf", "queue", "slice", "length", "address", "count", "batch", "base", "server", "url", "size", "Buffer", "iter", "value", "split", "bytes", "transfer", "result", "border", "bb", "reader", "data", "write", "type", "raw", "null", "b", "buff", "flush", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", "tell", " Read", "use", "ip", " skip", "send", "n", " write", "current", "reading", "fill", "limit", "select", "copy", "READ", "lex", "io", "feed", "add", "slice", "sync", "length", " count", "count", "seek", "play", "Read", "ad", "exec", "find", "get", "load", "x", "wait", "size", "work", "f", "iter", "len", "i", "allow", "ind", "_", "start", "ride", "check", "connect", "next", "reader", " copy", "parse", "write", "se", "raw", "r", "inc", "id", "sleep", "end"], "success": ["rolled", "done", "pass", "status", "again", "initial", "method", "results", "failed", "comment", "winner", " Success", "continue", "response", "func", "right", "fast", "path", "open", "Success", "primary", "ceed", "first", "warning", "construct", "content", "ccess", "positive", "growth", "roll", "good", "valid", "successful", "flash", " successful", "default", "danger", "model", "fail", " succeed", "complete", " succ", "value", "rolling", "result", "better", "true", "follow", "data", "error", "xx", "null", "successfully", "message", "cess"]}}
{"id1": "11968328", "id2": "1097147", "code1": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"getMD5": ["getSHA32", " getCD53", " getMD32", "getMD512", " getMC32", "getSHA5", " getSHA5", " getMC53", " getSHA512", " getCD5", " getMD512", " getMC5", " getSHA53", " getMC512", " getMD53", "getMD32", " getCD32", " getCD512", "getMD53", "getSHA53", " getSHA32", "getSHA512"], "_pwd": ["_dpass", "_dWD", "_dwd", "_npass", "_Pwn", "_Ppass", "_swd", "_sWD", "_Pword", "_nwd", "_PWD", "_Pwd", "_spass", "_pwn", "_pWD", "_nwn", "_pword", "_ppass", "_sword", "_dword", "_nWD"], "md": ["df", "mb", "mg", "mp", "pd", "pm", "od", "mand", "rm", "mac", "m", "pg", "sm", " MD", "um", "d", "sha", "MD", "bd", "meta", "wd", "hd", "ad", "dd", "mc", "gb", "cd", "cmd", "dh", "ma", "mag", "pkg", "ind", "dm", "editor", "nm", "amd", "kg", "dig", "mm", "metadata", "po", "bf", "vd", "mad", "mt", "mu", "db", "mo"]}}
{"id1": "19868933", "id2": "22801734", "code1": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"copyFromFileToFileUsingNIO": ["copyFromFileToFileUsingnIO", "copyFromFileToFileWithFileIO", "copyFromFileToFileUsingFileIO", "copyFromFileToFileUsingNio", "copyFromFileToFileWithNIO", "copyFromFileToFileWithFileChannel", "copyFromFileToFileWithFileFile", "copyFromFileToFileWithNFile", "copyFromFileToFileUsingNetChannel", "copyFromFileToFileUsingFileChannel", "copyFromFileToFileUsingNFile", "copyFromFileToFileUsingFileio", "copyFromFileToFileUsingnio", "copyFromFileToFileUsingNetio", "copyFromFileToFileUsingNChannel", "copyFromFileToFileUsingNetIO", "copyFromFileToFileUsingnFile", "copyFromFileToFileUsingnChannel", "copyFromFileToFileUsingFileFile", "copyFromFileToFileWithNChannel", "copyFromFileToFileWithNio", "copyFromFileToFileUsingNetFile", "copyFromFileToFileWithFileio"], "inputFile": [" inputDir", " inputfile", " inputStream", "inputDirectory", "InputDirectory", "inputStream", "imagefile", "imageStream", "outputStream", "imageFile", " inputDirectory", "InputFile", "sourceFile", "sourceDirectory", "inputDir", "inputfile", "sourceDir", "outputfile", "sourceStream", "imageChannel", "InputStream", "InputDir"], "outputFile": ["targetFile", " outputfile", "OutputStream", "inputDirectory", "targetPath", "inputStream", "OutputFile", "Outputfile", "outputPath", " outputFiles", " outputDirectory", "outputStream", "OutputFiles", "targetFiles", "outputDirectory", "inputPath", " outputPath", " outputStream", "outputfile", "outputFiles", "targetfile", "targetDirectory", "targetStream"], "inputChannel": ["outputchannel", "httpChannel", "parentFile", " inputListener", "InputChannel", " inputStream", "httpCh", "outputSocket", "inputStream", "inputSocket", "parentStream", "inputListener", " inputSocket", " inputChan", "inputCh", "outputStream", "InputListener", "outputListener", "outputChan", "Inputchannel", "InputFile", "parentChannel", "InputSocket", " inputchannel", "InputChan", "httpChan", "InputCh", "inputChan", "parentSocket", "outputCh", "parentChan", "httpSocket", "InputStream", "inputchannel"], "outputChannel": ["OutputConnection", "OutputStream", "OutputSocket", "outChannel", " outputChan", "outputSocket", "inputStream", "OutputFile", "OutputChan", "outSocket", "outputStream", "outputChan", "outputConnection", "outStream", " outputSocket", "outChan", " outputStream", "inputChan", " outputConnection", "OutputChannel", "inputConnection"]}}
{"id1": "1798720", "id2": "720361", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        int result = 20;\n        if (args.length == 1) {\n            StringBuffer urlString = new StringBuffer(args[0]);\n            if (urlString.lastIndexOf(\"/\") != urlString.length() - 1) {\n                urlString.append('/');\n            }\n            urlString.append(\"GetConfig.jsp\");\n            URLConnection conn = new URL(urlString.toString()).openConnection();\n            System.out.println(Configuration.readObject(conn.getInputStream()));\n            result = 0;\n        } else {\n            System.err.println(\"usage: GetConfig <URL>\");\n        }\n        System.exit(result);\n    }\n", "label": 0, "substitutes": {"save": ["stage", "transform", "copy", "report", "move", "open", "process", "archive", "build", "store", "Save", "release", "saving", "setup", "install", "upload", "clone", "load", "dump", "transfer", "apply", "change", "data", "make", "pack", "update", "create"], "packageName": [" packagePart", " packageNames", "moduleName", "PackageNames", "directoryPart", "directoryDir", " packageInfo", "directoryname", " packagename", "PackageInfo", "directoryPath", "pluginName", "directoryInfo", "packagename", "PackagePath", "sourcename", " packagePath", "modulePath", "sourcePath", "packagePath", "PackageName", "pluginPath", "packageInfo", "pluginDir", "sourceDir", "packageNames", "moduleInfo", "pluginPart", "sourceName", "directoryName", "directoryNames", "moduleDir", "PackageDir", "packagePart"], "fileContents": ["FileParts", "getContents", " fileContent", "ileSources", "FileSources", " fileParts", "imageContents", " fileSources", "fileSources", "FileNames", "getContent", "ileTextures", "FileContent", "imageHours", "getParts", "fileTextures", "ileNames", "fileParts", "imageParts", " fileTextures", "fileContent", "ileContents", "getNames", " fileHours", "fileHours", "FileTextures", "imageNames", "FileContents", "FileHours"], "fileNames": ["pageTypes", "fName", "fullName", "fileName", "viewTypes", "logNames", "fullContents", "pagenames", " fileName", "fTypes", "FileNames", "fNames", "fullTypes", "logContents", "logTypes", "playName", " fileNumbers", "viewNames", "pageNames", "fileTypes", "playNames", "fNumbers", "fileNumbers", "FileName", "playContents", "FileTypes", "logName", " fileTypes", "FileNumbers", "FileContents", " filenames", "fullNames", "filenames", "viewnames"], "dirBase": ["folderDir", "moduleKit", "moduleBase", "packageRoot", "DirKit", " dirPath", "dirKit", "DirPath", "dirRoot", "Dirbase", "directoryDir", "moduleDir", "directoryBased", " dirbase", "dirDir", "directoryBase", "modulebase", "directoryKit", "folderBase", "packagebase", "packageBase", "folderBased", " dirRoot", "packagePath", "dirBased", "folderbase", "directorybase", "DirDir", "DirBase", "dirPath", "DirRoot", "moduleBased", "dirbase"], "packageDir": ["directoryFile", "folderDir", "moduleBase", "moduleLib", "parentFile", "packageFile", " packageFolder", "packageFolder", " packageDirectory", "packageLib", "PackageFile", "directoryDir", "directoryPath", "moduleDir", "PackagePath", "directoryUrl", " packageUrl", "folderBase", "parentDir", "PackageDirectory", "packageDirectory", " packagePath", "modulePath", "packageBase", "packagePath", "packageUrl", " packageLib", "parentUrl", "folderPath", "folderLib", " packageFile", "parentFolder", "directoryFolder", "directoryDirectory", " packageBase", "PackageDir"], "created": ["raised", "icated", "founded", "creation", "Created", "added", "worked", "failed", "edited", "called", "path", "produced", "activated", "paid", "authorized", "ed", "creator", "were", " Created", "successful", "aaaa", "updated", "established", "left", "formed", "confirmed", "existent", "released", "used", "result", "made", "true", "found", "null", "needed", "controlled", "required", "owned", "generated", " existed", "create", "loaded"], "currentPath": [" currentPage", "newpath", " currentLocation", "CurrentDirectory", "CurrentPath", "currentDirectory", "currentPage", "CurrentLocation", "currentlyPage", "currentlyDirectory", " currentDirectory", "CurrentRoot", "currentpath", "currentRoot", " currentRoot", "currentlypath", "currentLocation", "newPath", "currentlyPath", "newLocation", "newRoot", "CurrentPage", "Currentpath", " currentpath"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "ini", "ii", "k", "n", "pi", "c", "y", "current", "d", "inner", "ci", "di", "io", "z", "key", "slice", "ji", "ui", "ri", "me", "bi", "ie", "it", "p", "part", "phi", "init", "s", "j", "I", "fi", "x", "eni", "index", "f", "e", "isi", "oi", "li", "ori", "start", "h", "gi", "v", "ti", "mi", "ai", "yi", "b", "xi", "zi", "id", "info", "uri", "ix", "mu", "name"], "file": ["File", "folder", "resource", "entry", "fe", "or", "il", "full", "http", "le", "path", "log", "io", "feed", "files", "place", "child", "dir", "letter", "unit", "book", "play", "up", "l", "rule", "base", "s", "pe", "out", "work", "f", "per", "ul", "filename", "fp", "data", "b", "source", "uri", "ile", "name"], "fos": ["ufob", "flosh", "ufo", "flos", "cfo", " fops", "fo", "voes", "fosh", "Fou", "fios", "ufos", "fops", "Fops", " fios", " fo", "cfob", "fou", "foes", "flou", "vos", "ofou", "flis", "Fis", "ofos", " fob", " fis", "Fos", "ofops", " fosh", "fis", "Fios", "vops", "Fosh", "vios", "Foes", "fob", " foes", "cfoes", "ofosh", "cfos", "flops", "ufoes"], "fileSrc": ["fileAsrc", " fileDrc", "FileSrec", "FileSource", " fileDRC", "fileDRC", " fileSrs", "FileSrc", "FileDrec", "fileNrs", "fileSrec", "fileNrc", "fileDource", "fileAssrc", "FileDRC", "fileDsrc", "fileDrc", " fileDrs", "fileAsRC", " fileSsrc", "fileAsource", "fileSource", "FileDrc", "FileDource", "fileAsrec", " fileSRC", "FileSRC", "fileDrec", "fileSRC", "fileNsrc", "fileDrs", "fileSsrc", " fileDsrc", "fileSrs", "fileAsrs", "fileNRC"], "fileDst": ["fileDaysrc", "fileFsc", "fileDST", "FileSrc", "fileDaysc", "fileFst", "FileDsc", "FileFsc", "fileSST", "fileDayst", "fileNrc", "fileFrc", "FileFst", "FileSsrc", "FileDsrc", "FileFST", "FileFrc", "FileSst", "fileSst", "fileDayrc", "fileDsrc", "fileNsc", "fileDrc", "FileDrc", "fileFST", "fileEnrc", "fileSsc", "FileSsc", "fileNsrc", "fileEnST", "fileSsrc", "FileDst", "fileDsc", "fileEnst", "FileDST", "fileEnsc", "fileNst"], "reader": ["or", "row", "entry", "ry", "reading", "oder", "inner", "ler", "right", "layer", "report", "io", "ner", "driver", "ri", "keeper", "handler", "er", "book", "audio", "ro", "rc", "server", "loader", "read", "Reader", "rer", "iter", "e", "per", "director", "worker", "editor", "author", "data", "rr", "r", "parser", "rar", "buffer", "stream", "rx", "re", "builder"], "writer": ["entry", "riter", "writ", "words", "war", "ger", "writers", "player", "later", "o", "word", "inner", "ler", "with", "walker", "outer", "Writer", "wa", "key", "sheet", "driver", "maker", "er", "book", "handler", "wire", "w", "document", "connection", "out", "element", "server", "width", "work", "loader", "ws", "office", "per", "e", "rw", "wrapper", "value", "worker", "editor", "widget", "wr", "socket", "output", "writing", "write", "data", "author", "written", "r", "parser", "message", "buffer", "master", "builder"], "line": ["item", "look", "inline", "entry", "row", "pass", "string", "lines", "word", "LINE", "str", "comment", "character", "le", "Line", "response", "ge", "log", "feed", "key", "jo", "char", "stroke", "sync", "object", "letter", "header", "unit", "cr", "l", "part", "rule", "connection", "lin", "cell", "model", "url", "definition", "link", "code", "cle", "page", "error", "data", "write", "type", "style", "id", "message", "lf", "source", "buffer", "text", "block", "column", "name", "job", "lc", "end"]}}
{"id1": "7872659", "id2": "23273706", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndmovieindexfile", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndMovieindexPath", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndmovieIndexfile", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndMovieIndexPath"], "completePath": [" CompleteHome", "successPath", " completePoint", "completeDir", "completeCh", "correctPoint", "progressLoader", "itepath", "progresspath", "completeFile", "correctRoot", " CompleteFile", "donePath", "execLoader", " completepath", "donepath", "successMusic", " completeCorp", " completeRoot", "CompletePath", "completeLoader", "completepath", "flatPoint", "itePath", "progressVol", "successpath", "correctCorp", "iteCh", " completeDir", "execPath", " completeMusic", "CompleteFile", "execVol", "doneLoader", "completeVol", "completeMusic", "completeRoot", "iteMusic", "execpath", "flatCorp", "completeCorp", "CompleteDir", "correctPath", " CompleteDir", "flatPath", " completeFile", " completeHome", "progressPath", "completePoint", " CompletePath", "flatRoot", "CompleteHome", "doneVol", "successCh", " completeCh", "completeHome"], "masterFile": ["cacheFILE", "masterName", "mastersFILE", "MasterFilename", "configName", "masterFilename", "MasterName", "mastersFile", "MasterFile", "configPath", "configFilename", "MasterPath", "mastersPath", "masterFILE", "masterPath", " masterPath", "cacheFile", "masterFiles", "configFile", "cacheFiles", "MasterFiles", "mastersFiles", " masterFilename", "cachePath", "MasterFILE", " masterName"], "CustRatingFileName": ["CustRateFilenameSize", "CustIndexFileName", "CustIndexFileVersion", "CustRatingLineName", "CustIndexFilesName", "CustRateFilePath", "CustIndexFileType", "CustRatingLineVersion", "CustRateFilenameDesc", "CustRatingClassPath", "CustIndexFilesType", "CustRatingFullDesc", "CustRatingFileType", "CustRatingFullPath", "CustRatingLinePath", "CustRatingLineType", "CustRatingFilenamePath", "CustRatingClassVersion", "CustRateFileSize", "CustRatingFilenameName", "CustRatingFileSize", "CustRatingClassName", "CustRatingFileDesc", "CustRateFilenameName", "CustRatingFilesPath", "CustRatingFilesDesc", "CustRatingFilesType", "CustRatingFilesName", "CustRatingFullSize", "CustRateFileName", "CustRateFileDesc", "CustIndexFilesVersion", "CustRatingClassType", "CustRatingFilesSize", "CustRateFilenamePath", "CustIndexFilePath", "CustRatingFilenameSize", "CustRatingFullName", "CustRatingFileVersion", "CustRatingFilePath", "CustIndexFilesPath", "CustRatingFilesVersion", "CustRatingFilenameDesc"], "MovieIndexFileName": ["MovieEditFUrl", "MovieConfigFileName", "MovieIndexFolderFile", "MovieIndexFName", "MovieIndexFSize", "MovieEditFileName", "MovieConfigFileFile", "MovieIndexClassSize", "MovieConfigFileVersion", "MovieIndexFolderName", "MovieIndexFILEFile", "MovieEditFileUrl", "MovieIndexFUrl", "MovieIndexClassName", "MovieConfigFolderVersion", "MovieEditFSize", "MovieIndexPlaceVersion", "MovieEditFileSize", "MovieIndexPlaceFile", "MovieIndexClassname", "MovieIndexFileFile", "MovieIndexFileVersion", "MovieEditFname", "MovieIndexClassUrl", "MovieIndexFileUrl", "MovieIndexFilesName", "MovieEditFilename", "MovieConfigFileHandle", "MovieIndexFilesname", "MovieConfigFolderName", "MovieIndexFilesUrl", "MovieIndexPlaceName", "MovieConfigFolderFile", "MovieIndexPlaceHandle", "MovieIndexFilename", "MovieIndexFILEHandle", "MovieIndexFname", "MovieIndexFileHandle", "MovieIndexFILEVersion", "MovieIndexFolderHandle", "MovieIndexFolderVersion", "MovieEditFName", "MovieIndexFILEName", "MovieIndexFileSize", "MovieConfigFolderHandle", "MovieIndexFilesSize"], "inFile": ["outfile", "outSourceFile", "incSourceFile", "inputFile", " infile", "outC", "InSourceFile", "inputSourceFile", "inF", " inF", "infile", "incC", "Infile", "InF", "InFile", "inputfile", " inSourceFile", "inSourceFile", "outFile", "inputF", "incFile", "incfile"], "inC": ["inCI", "outCL", " inCL", " inCC", "inputFile", "inputC", "innerCI", "outC", "inB", "InB", " inB", "inF", " inF", "inCC", "innerCC", "InCI", "InF", "innerC", "outF", "InFile", "outCC", "InC", "outFile", "InCC", "inputF", "inputCC", "outCI", "inCL", "outB", "innerFile", "InCL"], "outFile1": ["outPath1", "againCFirst", "outPlace1", "outputfileId", "outF2", "outputfile2", "outputFileId", "outFilesFirst", "outPath2", "outfile1", "outFName", "againFile2", "outFiles3", "outFiles2", "outFId", "againC3", "outPathFirst", "outfile2", "againC1", "outputFileName", "outputfile1", "outPlaceId", "outF1", "outFiles1", "outFileId", "outFileName", "outputFile1", "outC3", "outputfileName", "againC2", "outPlace2", "outPlaceName", "againFile3", "againFile1", "outCFirst", "outfileId", "outFile3", "outFileFirst", "againFileFirst", "outfileName", "outputFile2", "outPath3"], "outC1": ["outF8", "newc81", "outFOne", "againB2", "outCFOne", "outB2", "outF2", "outB8", "outDOne", "newC81", "againB8", "outcFirst", "newcOne", "outD81", "outCOne", "againC8", "outD1", "outB1", "outD8", "newc1", "againC1", "outBOne", "outC81", "outF1", "newC1", "newCFirst", "outD2", "againC2", "outDFirst", "outc81", "againCOne", "newCOne", "outCFFirst", "againB1", "outCFirst", "outCF1", "outC8", "newcFirst", "againBOne", "outc1", "outCF81", "outcOne"], "outFile2": ["againLine2", "outputfileTwo", "outputFile5", "outChannel1", "outfile5", "outFiles4", "outFilesTwo", "outChannel6", "outputfile2", "outLine6", "outLine1", "againFileTwo", "outFiles6", "outDirectory5", "outputfile5", "outDirectoryTwo", "outFiles2", "outDirectory2", "outChannel2", "againFile2", "againLine1", "outFile5", "outfile4", "againFile6", "outfile2", "outFile6", "outfileTwo", "outFiles1", "outChannelTwo", "againLineTwo", "outFiles5", "outputFileTwo", "outFile4", "againFile1", "outputfile4", "outLineTwo", "outFileTwo", "outLine2", "againLine6", "outDirectory4", "outputFile4", "outputFile2"], "outC2": ["OutC4", "OutC1", "againB4", "againB2", "outB2", "outF2", "againCTwo", "outCache4", "againC4", "outC4", "OutCII", "outFileII", "outB1", "outCII", "againC1", "outF1", "outCache1", "outB4", "outFII", "againC2", "outCache2", "outBTwo", "OutFII", "outFile4", "outCTwo", "againB1", "outCacheII", "OutF1", "OutF4", "OutC2", "outFileTwo", "OutF2", "againBTwo", "outF4", "outFTwo"], "fileSize": [" fileAddress", "fileSIZE", " fileLength", "resourceSIZE", " fileMode", "bufferSize", "bufferLength", "fileLength", "imageSIZE", "FileAddress", "resourceSize", "resourceAddress", "FileSIZE", " fileSIZE", "imageSize", "FileSize", "FileMode", "bufferMode", "FileLength", "fileAddress", "fileMode", "imageLength"], "totalNoDataRows": ["totalNoPageRues", "totalNoDataLues", "totalNoPageLrows", "totalNoDataLrows", "totalNoPageLues", "totalNoDataCues", "totalNoDataChrows", "totalNoPageLOWS", "totalNoDataRues", "totalNoPageLows", "totalNoDataChues", "totalNoPageROWS", "totalNoDataCrows", "totalNoDataLows", "totalNoPageRows", "totalNoDataChows", "totalNoDataCows", "totalNoDataChOWS", "totalNoDataRrows", "totalNoDataLOWS", "totalNoDataROWS", "totalNoPageRrows", "totalNoDataCOWS"], "mappedBuffer": ["mappedStream", "mapedBuffer", "machedChannel", "machedbuffer", "MappingChannel", "mapedStream", "MachedURL", "machedBuffer", "mashedChannel", "MappedURL", "mapedURL", "mippedStream", "machedURL", "MappedBuff", "MappingFile", "mppedStream", "MappingBuffer", "mactedbuffer", "mippedBuffer", "mappingBuffer", "MachedStream", "machedStream", "mactedBuffer", "mippedBuff", "machedFile", "Machedbuffer", "mactedBuff", "MachedBuff", "mappedbuffer", "mippedURL", "machedBuff", "mappingChannel", "MappingBuff", "MappedChannel", "mashedFile", "mactedStream", "MappedBuffer", "MappedStream", "MachedBuffer", "mashedBuffer", "mapedFile", "mappingbuffer", "Mappedbuffer", "mappingStream", "mappingFile", "MappedFile", "mappedChannel", "mapedBuff", "mappedFile", "MachedChannel", "mappedURL", "mppedBuff", "mappingBuff", "MachedFile", "mppedBuffer", "mappedBuff", "mashedBuff", "mppedChannel"], "startIndex": ["startindex", "startOffset", "initInfo", "endindex", "endSection", "useindex", "stopIndex", "startingIndex", "startingPosition", "startCode", " startindex", "StartInfo", "useIndex", " startSection", "usePosition", "stopRow", " startCode", " startPoint", " startInfo", "startInfo", "StartIndex", "startSection", "endInfo", "StartPosition", "startingSection", "initIndex", " startRow", "startingPoint", "StartOffset", "endIndex", "endCode", "stopindex", "initOffset", "endPosition", "startPosition", "endPoint", "Startindex", "initindex", "useInfo", "stopCode", "startPoint", " startPosition", "startRow", "endRow", " startOffset"], "count": ["group", "c", "current", "cache", "col", "call", "depth", "limit", "total", "more", "self", "sum", "time", "old", "Count", "number", "key", "force", "add", "first", "list", "length", "child", "weight", "part", "order", "all", "coll", "find", "thread", "max", "size", "index", "pool", "other", "code", "len", "i", "allow", "ind", "start", "close", "counter", "test", "follow", "type", "found", "id", "loop", "name", "keep"], "currentMovie": ["currentlyMusic", " currentMusic", "parentMovie", "currentFilm", "validMovie", "thismovie", "reportedMusic", "currentmovie", "currentPicture", "CurrentFilm", "parentFilm", "CurrentTheme", "CurrentMovie", "reportedFilm", "reportedMovie", "Currentmovie", "thisMovie", "defaultImage", "validFilm", "currentTheme", "reportedPicture", "defaultMovie", "reportedTheme", "validmovie", "currentImage", "defaultFilm", "parentPicture", "reportedImage", "currentMusic", "reportedmovie", "currentlyMovie", "defaultMusic", " currentFilm", " currentPicture", "thisPicture", "currentlyPicture", " currentImage", "thisFilm", "parentmovie", " currentmovie", "validTheme"], "movieName": ["moviename", "camFamily", " movieInfo", " movieId", "filmFamily", "filmname", "movieId", "filmName", "voiceId", "moneyNumber", "voiceInfo", "movieInfo", " movieFamily", "MovieName", "filmNumber", " moviename", "camName", "moneyName", "movieNumber", "movieFamily", "voicename", "camname", "MovieInfo", "voiceName", "MovieNumber", "MovieFamily", "Moviename", "MovieId", "moneyFamily"], "customer": ["ustomor", "ustomers", " customeri", " customER", "mixER", "CustomER", "ustomer", "Customers", "Customer", "customER", "customor", "mixor", " customers", "ustomER", "customers", "mixer", "customeri", "Customor", "ustomeri", "Customeri", "mixers"], "rating": ["resource", "Rating", "setting", "attribute", "ranking", "string", "packing", "reading", "http", "ruby", "comment", "number", "rage", "ring", "ing", "missing", "alpha", "including", "rate", "rc", "url", "score", "rank", "rice", "value", "feature", "rolling", "writer", "RC", "rated", "reader", "range", "type", "data", "writing", "error", "rr", "r", "rates", "id", "info", "radius", "padding"], "outBuf1": ["outBum1", "outFuf1", "outBuf01", "outBbuf11", "outDuff3", "outBummerCloud", "outBiff1", "outDuf3", "outBuff0", "outBaf1", "outKbuffOne", "outBuffn", "outBuff2", "outBbufOne", "outDuffn", "outBuf3", "outCuf1", "outCuf0", "outBummerOne", "outBalth2", "outKbuf1", "outBbuffOne", "outFufOne", "outKuf1", "outBuff1", "outBbuf1", "outBafOne", "outBufOne", "outKbuff1", "outBufn", "outKbuff8", "outKuf2", "outDuf11", "outFuf91", "outBuf8", "outBaf8", "outBbufn", "outFafOne", "outBbuf91", "outBaf3", "outFuf01", "outBaft1", "outBuffCloud", "outBum91", "outBbuff0", "outBuff8", "outBuff3", "outBuff11", "outBbuff1", "outCuff0", "outFaf1", "outFbuf01", "outBafCloud", "outBbuf2", "outKbuf2", "outBum01", "outBbuff8", "outBalth1", "outCuffOne", "outBuf0", "outKbuff3", "outBiff01", "outKufOne", "outFufCloud", "outBummer1", "outKbuf3", "outBiff91", "outBiffOne", "outBuf91", "outFbuf91", "outKuf3", "outFbufOne", "outBumOne", "outBalth3", "outKuf8", "outDuff11", "outBaf0", "outFbuf1", "outDufn", "outCufOne", "outBuf11", "outDuff1", "outBbuff3", "outBaftn", "outBbuf01", "outCuff1", "outBufCloud", "outBaft3", "outBaft11", "outBbuf3", "outDuf1", "outFafCloud", "outBuffOne"], "outBuf2": ["outFbuff2", "outFufB", "outFuf4", "outBuf12", "outBuf200", "outWBuff8", "outWBuff4", "outFbuff1", "outFuf1", "outBuf20", "outBum82", "outFuf20", "outBait4", "outFuf12", "outWBuff2", "outWBuf0", "outBbufTwo", "outBbuffer4", "outFbuffTwo", "outWBuf4", "outBuff0", "outBoff8", "outWBbuff8", "outBbuff4", "outFbuf12", "outFbuff4", "outWBuf8", "outFuf8", "outBuff2", "outBuf4", "outWBbuff2", "outBait200", "outBbuff2", "outWBbuffTwo", "outBbuffTwo", "outFbuff8", "outFbuff82", "outBbuff200", "outBuffTwo", "outBbuf12", "outBait2", "outFuf2", "outBbuff20", "outBufB", "outBuff1", "outBum8", "outBbuf1", "outBufTwo", "outBuf8", "outBbufB", "outFbuff20", "outBbuffer2", "outBbuff0", "outBuff8", "outBait8", "outBbuff1", "outBum20", "outBbuf2", "outBbuff8", "outBuf0", "outBoffTwo", "outBuber82", "outWBuff0", "outFufTwo", "outBuff4", "outWBuf2", "outBum2", "outBoff2", "outFbufB", "outBbuff82", "outBbufferB", "outFuf82", "outBuber8", "outBoff200", "outBuber2", "outBbuffer12", "outBuf82", "outBaitTwo", "outBait0", "outFbuf4", "outFbuf2", "outWBbuff200", "outBbuf4", "outWBuf200", "outWBufTwo", "outBuff12", "outBuffB", "outBuber20"], "endOfIndexFile": ["endOfindexfile", "endOfLinkDir", "endOfindexTime", "endOfindexFolder", "endofIndexDir", "endofLinkFile", "endedfile", "endOfClientTime", "endOfClientFile", "endOfIndexfile", "endOfImageTime", "endOfindexFiles", "endOfIndexFolder", "endofindexFile", "endOfDataFile", "endOfLinkFiles", "End\n", "endOfindexDir", "end\n", "endofIndexFiles", "endOfIndexTime", "endOfindexFile", "endfile", "Endfile", "endOfLinkFile", "endofIndexTime", "endOfLinkfile", " end\n", "endofindexTime", "endofLinkTime", "endOfIndexDir", "endOfImageFiles", "endOfDataTime", "endOfImageFile", "endOfClientFiles", "endOfLinkTime", " endfile", "endofLinkDir", "endofindexFolder", "endofindexFiles", "endofIndexFolder", "endOfImageFolder", "endOfDatafile", "endofLinkFiles", "ended\n", "endOfIndexFiles", "endofIndexFile", "endOfClientDir", "endOfDataDir"]}}
{"id1": "22993368", "id2": "15445861", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeStringToFiles", "decodeFileAsFiles", "decodeStringToFile", "decodeFileAsStream", "decodeString2Stream", "decodeFileFromStream", "decodeFileFromFiles", "decodeStringToString", "decodeFile2File", "decodeFileAsString", "decodeFileFromFile", "decodeStringToStream", "decodeFileToString", "decodeString2String", "decodeFile2String", "decodeFile2Files", "decodeFileToStream", "decodeFileToFiles", "decodeFileAsFile", "decodeString2File", "decodeString2Files", "decodeFileFromString", "decodeFile2Stream"], "infile": [" infp", " instream", "minbase", "Inbase", "inputfilename", "infp", "minstream", "outfiles", " infiles", "minFile", "inputfp", "inputfiles", "minfile", "outfilename", "Infile", "inbase", " inbase", "outfp", " infilename", "instream", "InFile", "inFile", "inputfile", " inFile", "Instream", "infiles", "infilename"], "outfile": ["outputpath", "outfolder", " outdatabase", "inputFile", "outputFile", "inputdatabase", " outFile", "outfilename", "inputpath", " outfilename", " outfolder", "outpath", " outpath", "outputdatabase", "inFile", "inputfile", "infolder", "outputfolder", "outFile", "outputfile", "outputfilename", "infilename", "outdatabase"], "in": ["In", "inas", "pass", "again", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "ic", "as", "con", "pin", "ins", "ac", "min", "conn", "inn", "into", "err", "isin", "init", "win", "s", "rin", "lin", "gin", "thin", "inside", "i", "nin", "a", "socket", "sin", "login", "reader", "data", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "In", "or", "pass", "exit", "line", "again", "cache", "channel", "o", "ex", "inner", "bin", "Out", "copy", "outer", "log", "io", "outs", "co", "post", "sync", "conn", "no", "err", "up", "net", "base", "exec", "work", "name", "session", "off", "home", "image", "lib", "socket", "to", "writer", "output", "error", "ou", "write", "obj", "OUT", "point", "job", "inc", "parent", "client", "one", "file"], "buffer": ["seed", "channel", "cache", "uffer", "limit", "padding", "bin", "input", "layer", "wave", "feed", "buf", "queue", "slice", "length", "address", "count", "batch", "base", "server", "url", "size", "Buffer", "iter", "value", "split", "bytes", "transfer", "result", "border", "bb", "reader", "data", "write", "type", "raw", "null", "b", "buff", "flush", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", "tell", " Read", "use", "ip", " skip", "send", "n", " write", "current", "reading", "fill", "limit", "select", "copy", "READ", "lex", "io", "feed", "add", "slice", "sync", "length", " count", "count", "seek", "play", "Read", "ad", "exec", "find", "get", "load", "x", "wait", "size", "work", "f", "iter", "len", "i", "allow", "ind", "_", "start", "ride", "check", "connect", "next", "reader", " copy", "parse", "write", "se", "raw", "r", "inc", "id", "sleep", "end"], "success": ["rolled", "done", "pass", "status", "again", "initial", "method", "results", "failed", "comment", "winner", " Success", "continue", "response", "func", "right", "fast", "path", "open", "Success", "primary", "ceed", "first", "warning", "construct", "content", "ccess", "positive", "growth", "roll", "good", "valid", "successful", "flash", " successful", "default", "danger", "model", "fail", " succeed", "complete", " succ", "value", "rolling", "result", "better", "true", "follow", "data", "error", "xx", "null", "successfully", "message", "cess"]}}
{"id1": "14473711", "id2": "17558353", "code1": "    public static String str2md5(String str) {\n        try {\n            MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE);\n            alga.update(str.getBytes());\n            byte[] digesta = alga.digest();\n            return byte2hex(digesta);\n        } catch (NoSuchAlgorithmException ex) {\n            return str;\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            URL urlhome = new URL(\"http://www.verussolutions.biz/NGLDashBoard.xml\");\n            URLConnection uc = urlhome.openConnection();\n            InputStreamReader input = new InputStreamReader(uc.getInputStream());\n            BufferedReader in = new BufferedReader(input);\n            String inputLine;\n            String xmlData = \"\";\n            while ((inputLine = in.readLine()) != null) {\n                xmlData += inputLine;\n            }\n            in.close();\n            PrintWriter fw = new PrintWriter(new FileWriter(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            fw.println(xmlData);\n            fw.flush();\n            fw.close();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n        try {\n            Document doc = new SAXBuilder().build(new File(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            String onlinsuppcdat = doc.getRootElement().getChild(\"OnlineSupportInformation\").getText();\n            CDATA cdata = new CDATA(onlinsuppcdat);\n            host.setOnlineInformationHTML(cdata.getText());\n            onlinsuppcdat = doc.getRootElement().getChild(\"News\").getText();\n            cdata = new CDATA(onlinsuppcdat);\n            host.setNewsHTML(cdata.getText());\n            host.fillData();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"str2md5": ["str2dig512", "str_MD5", "str2MDse", "str_md3", "str2md512", "str2MD3", "str_MDse", "str_md5", "str_MD3", "str2mdse", "str2MD512", "str2digse", "str2dig5", "str_md512", "str_MD512", "str2h3", "str2hse", "str2MD5", "str2h512", "str_mdse", "str2h5", "str2md3", "str2dig3"], "str": ["txt", "pass", "kr", "string", "exp", "spec", "inner", "input", "msg", "empty", "char", "hex", "sr", "in", "STR", "tr", "er", "p", "err", "br", "dict", "cr", "s", "strings", "arr", "url", "sp", "dr", "enc", "f", "code", "i", "format", "bytes", "result", "test", "st", "data", "obj", "r", "t", "buffer", "Str", "text", "source", "name", "fr"], "alga": ["alsqa", "ALca", "alqa", " alda", "elda", "ALa", " ala", "Algas", "ALda", "ela", "ALja", "alja", "alsa", "elga", "Alja", " algas", "ALqa", " alca", "alsda", "algas", "ALsa", "alsga", "alda", "ALgas", "ALga", "Alga", " alsa", "alsca", " alqa", "elgas", "ala", " alja", "Alsa", "alca"], "digesta": ["badza", "codza", "badesta", "igera", "digosta", "igosta", "digsta", "igesta", "badosta", "diffsta", "igza", "codesta", "codera", "finsta", "fineste", "badera", "codosta", "finosta", "diffeste", "finesta", "digeste", "diffosta", "codsta", "codeste", "diffesta", "digera", "digza"]}}
{"id1": "16804988", "id2": "13516684", "code1": "    public void init() {\n        String filename = getParameter(\"filename\");\n        if (filename == null) {\n            Error(\"Illegal filename\");\n            return;\n        }\n        Dimension dim = DEFAULT_SIZE;\n        try {\n            int w = Integer.parseInt(getParameter(\"width\"));\n            int h = Integer.parseInt(getParameter(\"height\"));\n            dim = new Dimension(w, h);\n        } catch (Exception e) {\n        }\n        InputStream in;\n        try {\n            File ff = new File(filename);\n            in = new FileInputStream(ff);\n        } catch (Exception ignore) {\n            try {\n                URL url = new URL(filename);\n                in = url.openStream();\n            } catch (Exception e) {\n                Error(\"Graph viewer: Failed to open: \" + filename + \"\\n\" + e);\n                return;\n            }\n        }\n        getContentPane().add(getWindow(in));\n        resize(dim);\n        repaint();\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 0, "substitutes": {"init": ["ize", "Initialized", "draw", "Init", " initialized", "initial", " initialization", "activate", "construct", "build", "it", "setup", "layout", "show", "load", " startup", "config", "image", "start", " Init", "format", "close", "parse", "info", "update", "launch", "create"], "filename": ["folder", "il", "txt", "online", "username", "fax", "n", "string", "SourceFile", "utf", "jpg", "word", "sf", "title", "Filename", "path", "kn", "params", "fd", "fil", "files", "database", "ppa", "length", "download", "content", "fn", "loc", "l", "prefix", "ename", "phrase", "location", "upload", "config", "size", "license", "loader", "f", "doi", "dll", "password", "journal", "fp", "nil", "directory", "ssl", "metadata", "kl", "uri", "binary", "name", "which", "file"], "dim": ["span", "Dim", "sam", "si", "wid", "project", "im", "g", "multi", "cm", "m", "dat", "ims", "py", "spec", "d", " Dim", "dist", "marg", "shape", "di", "param", "slice", "imm", "num", "div", "min", "iframe", "dimension", " reim", "p", "part", "scale", "mod", "width", "dr", "fi", "config", "size", "fac", "thin", "index", "du", "fm", "lim", "gm", "image", "dom", "format", "dm", "val", "ext", "img", "diff", "dem", "mi", "info", "grad", "wm", "grid"], "w": ["wh", "wt", "u", "n", "c", "height", "m", "k", "o", "y", "d", "z", "wa", "ew", "wd", "weight", "p", "l", "s", "fw", "sw", "win", "max", "x", "f", "hw", "e", "rw", "i", "q", "a", "v", "W", "r", "b", "en", "t", "width", "ow"], "h": ["hs", "bh", "sh", "u", "height", "n", "th", "c", "k", "uh", "y", "o", "rh", "d", "oh", "H", "hm", "z", "ih", "ht", "hd", "kh", "p", "ha", "l", "ph", "s", "j", "x", "ah", "f", "e", "q", "v", "hr", "b", "en", "t", "gh"], "in": ["resource", "In", "fe", "fc", "again", "serv", "ini", "n", "IN", "is", "din", "bin", "input", "as", "io", "pin", "ins", "cf", "impl", "ac", "conn", "min", "inn", "err", "kin", "cl", "l", "connection", "win", "out", "gin", "fac", "read", "cgi", "f", "i", "nin", "el", "lib", "socket", "fp", "login", "ssl", "reader", "amin", "data", "ax", "r", "b", "fb", "inc", "id", "source", "stream", "src", "file"], "ff": ["df", "fe", "fff", "fc", "cmp", "library", "sf", "xff", "fx", "aff", "fd", "ctx", "feed", "FF", "buf", "cf", "pp", "ef", "ulp", "ouf", "iff", "ffe", "f", "af", "uf", "fed", "eff", "cb", "fp", "bb", "fl", "fb", "bf", "buff", "lf", "back", "file"], "url": ["resource", "fr", "ob", "zip", "string", "sf", "http", "www", "URL", "path", "ll", "io", "open", "feed", "Url", "download", "l", "connection", "base", "ls", "server", "sl", "f", "e", "image", "fp", "ssl", "fl", "b", "fb", "web", "uri", "stream", "source", "src", "file"]}}
{"id1": "2676365", "id2": "1862616", "code1": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "code2": "    public static String fetch(String reference) throws IOException {\n        URL url = new URL(reference);\n        HttpURLConnection c = (HttpURLConnection) url.openConnection();\n        c.setRequestMethod(\"GET\");\n        c.setDoOutput(true);\n        c.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\");\n        return parseISToString(c.getInputStream());\n    }\n", "label": 0, "substitutes": {"reset": [" shutdown", " Reset", " reconnect", "register", " migrate", "destroy", "activate", "sync", "clear", " checkpoint", "init", "release", "setup", "delete", "commit", " restore", "set", "stop", "start", "close", "disable", "save", " rebuild", "flush", "back", "update", " disconnect", "et"], "currentPilot": ["currentpector", "currentpilot", "currentPortilot", "currentPointiece", " currentPacket", " currentPooter", "currentCPector", "currentpacket", "currentPayilot", "currentPistor", "activePistor", "currentPooter", " currentCPector", "activepilot", " currentCPacket", "currentPiece", "currentPointacket", "currentPacket", "currentPayistor", "currentPayiece", "currentCPilot", "currentCPooter", "currentPector", "currentPointilot", "activePiece", " currentCPilot", "currentPointistor", "activePilot", "currentPortector", "currentPayacket", "activepiece", "currentpiece", "currentPortooter", "currentpistor", " currentCPooter", "currentPortacket", "activePacket", "currentpooter", "activepacket", "activepistor", " currentPector", "currentCPacket"], "psta": ["parsa", "psa", "pesta", " pppa", "pla", "Pda", "peppa", "pesa", " pste", "parasi", " pla", "Pla", "Pasi", "pppa", "Pste", "parsta", " pesta", "pasi", " pasi", "jste", "jsta", "pda", " pda", "Pesta", "Psta", " psa", "pste", "paresta", "Pppa", "jda", "jsa", "Psa", "pela"]}}
{"id1": "10214218", "id2": "7948308", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["enrypt", " encress", "deccrypt", "enress", "decrypt", "decress", "enccrypt", "encipher", " enccrypt", "decipher", " encipher", "enipher", "encress"], "plaintext": [" plaintxt", "battxt", "plainText", "plainstruct", "maintext", "battext", "mainsource", "batsource", "anytxt", " plainText", "batText", " plainstruct", "plainsource", " plainsource", "plaintxt", "anystruct", "anytext", "mainText", "anyText", "mainstruct", "batstruct"], "md": ["mb", "mg", "mp", "pd", "mage", "pm", "od", "ms", "mand", "cm", "mac", "Cmd", "m", "em", "pg", "sm", " MD", "d", "sha", "hm", "MD", "bd", "key", "meta", "wd", "ad", "dd", "ld", "mc", "mod", "cmd", "dh", "dr", "mag", "ma", "am", "arm", "dm", "nm", "amd", "data", "dig", "kg", "mm", "metadata", "message", "mad", "mt", "mu", "db", "mo"], "raw": ["row", "words", "full", "clean", "instance", "initial", "unknown", "input", "wave", "feed", "hex", "buf", "none", " RAW", "content", "original", "ack", "good", "ng", "rc", "rew", "load", "array", "enc", "Raw", "serial", "wrapper", "image", "bytes", "unsigned", "data", "null", "pack", "RAW", "binary", "buffer", "text", "block", "message", "dec"], "hash": ["hed", "sh", "mac", "cache", "Hash", "rh", "secret", "ruby", "sha", "response", "sum", "abi", "log", " hex", "hex", "key", "ashes", "header", "kh", "alpha", "ha", "base", "url", "ash", "array", "code", "her", "image", "h", "html", "data", "id", "message", "block", "version"]}}
{"id1": "7122523", "id2": "17083703", "code1": "    public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        InstanciaDelegate delegate = RegistroManager.recuperarInstancia(request);\n        if (delegate == null) {\n            ActionErrors errors = new ActionErrors();\n            errors.add(null, new ActionError(\"errors.session\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"fail\");\n        }\n        AyudaPantalla ayudaPantalla = delegate.obtenerAyudaPantalla();\n        TraAyudaPantalla traAyudaPantalla = (TraAyudaPantalla) ayudaPantalla.getTraduccion();\n        String urlSonido = traAyudaPantalla.getUrlSonido();\n        if (urlSonido == null) {\n            return null;\n        }\n        URL url = new URL(urlSonido);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.connect();\n        String tipoMime = urlConnection.getContentType();\n        log.debug(\"Tipo Mime: \" + tipoMime);\n        Map audioOptions = new HashMap();\n        if (tipoMime.indexOf(\"audio\") != -1 || tipoMime.indexOf(\"asf\") != -1 || tipoMime.equals(\"unknown/unknown\")) {\n            audioOptions.put(\"id\", \"MediaPlayer\");\n            audioOptions.put(\"codeBase\", \"http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,7,1112\");\n            audioOptions.put(\"classId\", \"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95\");\n            audioOptions.put(\"mimeType\", \"application/x-mplayer2\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/\");\n        } else if (tipoMime.indexOf(\"real\") != -1) {\n            audioOptions.put(\"id\", \"RVOCX\");\n            audioOptions.put(\"codeBase\", \"\");\n            audioOptions.put(\"classId\", \"clsid:CFCDAA03-8BE4-11cf-B84B-0020AFBBCCFA\");\n            audioOptions.put(\"mimeType\", \"audio/x-pn-realaudio-plugin\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"\");\n        }\n        request.setAttribute(\"audioOptions\", audioOptions);\n        log.debug(\"entra success\");\n        return mapping.findForward(\"success\");\n    }\n", "code2": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"execute": ["action", "run", "route", "send", "instance", "method", "call", "forward", "invoke", "func", "transform", "report", "process", "post", "this", "default", "exec", "start", "handle", "apply", "transfer", "result", "next", "data", "submit", "message", "info", "create"], "mapping": ["mmording", "rmapping", " mapper", "Mapped", "mapped", "matching", " mapped", "pailing", "mmailing", "Mapper", "rmapper", "pording", "rmapped", " mailing", "Mappings", "mmapping", "mmatching", "patching", "Mapping", "mailing", " mording", " matching", "mording", "papping", "rmappings", "mappings", " mappings", "mapper"], "form": ["entry", "route", "view", "former", "input", "transform", "path", "Form", "post", "FORM", "object", " forms", "forms", "command", "flow", "app", "model", "upload", "query", "config", "field", "control", "session", "format", "page", "submit", "builder", "template"], "request": ["resource", "application", "route", "subject", "use", "instance", "current", "context", "method", "view", "xml", "Request", "state", "input", "report", "path", "queue", "enter", "object", "user", "handler", "frame", "event", "model", "server", "query", "session", "q", "image", "result", "type", "submit", "req", "QUEST", "ware", "message", "web", "parent", "client", "create"], "response": ["Response", "resource", "application", "status", "reply", "view", "http", "results", "report", "manager", "object", "resp", "model", "server", " Response", " responses", "session", "res", "result", "page", "output", "error", "data", "req", "message", "client"], "delegate": ["relegates", "deplementation", " delic", "DEploy", "declegates", "DElegate", " deleg", "deider", "DEleg", "rolelegate", "reploy", "Deplementation", " deplementation", "deleg", "Delegates", "relegate", "delic", "delegates", " deider", "releg", " delegates", "Delic", "rolelic", "rolelegates", "decleg", "Delegate", "Deleg", "decider", "DElegates", "deploy", "roleplementation", "Deider", "Deploy", "declegate"], "errors": ["reports", "rss", " messages", "maps", "instance", "xml", " problems", "failed", "results", "values", "eps", "ations", "uments", "relations", "params", "ays", "objects", "details", "events", "ins", "members", "plugins", "err", " Errors", "rors", "s", "all", "effects", "ceptions", "ops", "orders", "settings", "array", " responses", " exceptions", "e", "blocks", "ros", "rules", "links", "issues", "ae", "error", "data", "asts", "runs", "items", "null", "comments", "parser", "es", "ages", "rs", "les", "management", "rows"], "ayudaPantalla": ["ayudaPentalla", "ayudaPandla", "ayudaPantla", "ayudaPantsla", "ayudaPatarala", "ayudaPantsella", "ayudaPandala", "ayudaPantala", "ayudaTantala", "ayudaTentilla", "ayudaPandalla", "ayudaPantella", "ayudaPandilla", "ayudaTantalla", "ayudaPatantala", "ayudaPandella", "ayudaParailla", "ayudaTantilla", "ayudaPentilla", "ayudaPentala", "ayudaPantilla", "ayudaTentala", "ayudaPantsala", "ayudaParala", "ayudaPantsilla", "ayudaPatantilla", "ayudaTantella", "ayudaPatantla", "ayudaTentella", "ayudaTentalla", "ayudaParaala", "ayudaPatantalla", "ayudaPataraalla", "ayudaPatarailla", "ayudaPantsalla", "ayudaParaalla", "ayudaPentella", "ayudaPataraala"], "traAyudaPantalla": ["traAyudaVantlla", "traAyudaPlantella", "traAyudaPandala", "traAyudaPantingalla", "traAyudaPlantalla", "traAyudaVantalla", "traAyudaPantingella", "traAyudaPantingala", "traAyudaPlantingilla", "traAyudaVantaya", "traAyudaPartala", "traAyudaPartalla", "traAyudaPandlla", "traAyudaParaaya", "traAyudaPantaya", "traAyudaVandaya", "traAyudaPentalla", "traAyudaVandalla", "traAyudaPantala", "traAyudaPlantilla", "traAyudaParaalla", "traAyudaPentilla", "traAyudaVantala", "traAyudaPartaya", "traAyudaPlantingalla", "traAyudaParalla", "traAyudaPantella", "traAyudaPartlla", "traAyudaPlantingala", "traAyudaVandlla", "traAyudaPantlla", "traAyudaParaala", "traAyudaPlantala", "traAyudaPentala", "traAyudaPantingilla", "traAyudaPlantingella", "traAyudaPentella", "traAyudaPandalla", "traAyudaVandala", "traAyudaPandaya", "traAyudaPandilla", "traAyudaPantilla", "traAyudaPandella"], "urlSonido": ["urlSonigma", "urlTonido", "urlMonidi", "urlSonini", "uriSonigma", "urlSonuli", "uriSonido", "uriSonid", "urlSONido", "UrlSenigo", "urlsonado", "urlBonado", "UrlBonidi", "UrlBonido", "UrlSenini", " urlSonado", "UrlBonida", "UrlSonido", "uriSONigma", "urlMonido", "urlSonri", " urlTonini", "urlsonigo", "urlSonidi", "urlBonuli", "uriSONini", "urlMonuli", "urlTonini", "urlSonado", "urlTonado", "urlBonigo", "urlTonid", "urlSenigo", "urlSONida", "urlsonido", "urlSONid", "urlMonida", "UrlSonidi", "urlsonri", "urlSONidi", "urlBonido", "urlTonigo", "urlTonigma", "uriSonini", "urlTonri", "UrlSenido", "UrlSonida", "uriSONid", "UrlSenri", "UrlSonini", "urlSONigma", "UrlSonuli", "urlSonida", "urlSonigo", "UrlBonuli", "urlSONuli", "urlBonidi", "urlsonid", "uriSONido", "urlBonini", "urlsonigma", "urlSenido", "urlBonida", "UrlSonri", "urlSenri", "UrlSonigo", "urlSonid", "urlsonini", "urlSenini", " urlSonini", "urlSONini", " urlSonigo", " urlTonigo", " urlTonido", " urlTonado"], "url": ["resource", "full", "string", "http", "str", "service", "www", "URL", "path", "log", "ll", "gl", "Url", "json", "download", "impl", "user", "l", "connection", "base", "ls", "server", "location", "system", "config", "sl", "f", "control", "image", "page", "ssl", "fl", "b", "web", "uri", "source", "client"], "urlConnection": ["urlFactory", "URLFactory", "urlConn", "httpConn", "userConnection", "webconnection", "userInfo", "httpConnection", "urlInfo", "webClient", " urlconnection", "eventconnection", "URLClient", "webConnection", "eventConnect", "eventConnector", " urlInfo", "urlconnection", "userconnection", "eventConnection", "httpFactory", "webConn", "webFactory", "webConnector", "UrlConnector", "webConnect", "Urlconnection", "urlClient", "httpClient", "UrlConnection", "UrlConnect", "urlConnect", "URLConn", "UrlInfo", "URLConnection", "urlConnector"], "tipoMime": ["tiposMale", "tiposTorph", " tipoMpe", "tipoMorph", "tipoImime", "tipoPanche", "tiposTike", "tipoPIME", "tipoTime", " tipoTpe", " tiposTime", "tipoKnanche", "tiposText", " tipoMetpe", "tipoImale", "tipoImize", "tipoManche", "tipoText", "tipoMIME", " tipoMIME", "tiposTize", " tiposTile", "tiposMile", " tipoTile", " tipoTIME", "tipoMile", " tipoMetIME", "tiposTale", " tiposMpe", "tiposManche", "tiposTanche", "tipoCext", "tipoCIME", "tipoKnike", "tipoKnIME", "tipoDemime", "tipoTike", "tipoDemale", "tipoNile", "tipoKnime", "tipoPike", "tipoCorph", "tipoMext", "tipoNime", "tipoImIME", "tipoMale", " tiposMile", "tiposMorph", " tipoTime", " tipoSmpe", "tiposTime", "tiposMize", "tiposMike", " tiposMIME", " tipoMetile", " tipoMetime", "tiposTile", "tipoCile", " tipoSmIME", "tipoMike", "tiposMIME", " tipoMile", "tipoDemIME", " tipoSmime", "tipoTale", "tipoDemize", "tipoTorph", "tiposMime", "tipoPime", " tiposTpe", "tiposMext", " tiposMime", "tipoTile", "tipoNIME", "tipoTize", "tipoMize", "tipoTIME", " tipoSmile", "tipoTanche", "tipoNext", " tiposTIME", "tiposTIME", "tipoCime"], "audioOptions": ["audioSettings", "videoStream", "mediaSettings", " audioColor", "musicParts", "archiveOptions", "audioColor", "oggContents", "oggOptions", "mediaGames", "AudioSettings", "audioParts", "soundOptions", " audioOption", "musicOptions", "audioGames", "mediaVideo", " audioParts", "musicStream", "audioContents", "videoOptions", "mediaParts", "soundContents", "audioOption", "audioStyle", "mediaStyle", "archiveColor", "mediaOptions", "soundOption", "videoGames", " audioSettings", "soundoptions", "videoVideo", " audioStream", "musicSettings", "AudioStyle", " audioVideo", "videooptions", "AudioStream", "audioVideo", "AudioColor", "audioRules", "oggRules", "archiveStream", "AudioGames", "AudioOptions", " audioStyle", " audiooptions", "soundRules", "audioStream", "videoParts", "oggOption", "archiveStyle", " audioRules", " audioContents", " audioGames", "soundSettings", "videoSettings", "audiooptions"]}}
{"id1": "17901739", "id2": "6299111", "code1": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public static String retrieveQ(String urlToRetrieve) throws MalformedURLException, IOException {\n        URL url = new URL(urlToRetrieve);\n        URLConnection uc = url.openConnection();\n        InputStream is = uc.getInputStream();\n        BufferedReader in = new BufferedReader(new InputStreamReader(is));\n        StringBuilder output = new StringBuilder(16384);\n        String str;\n        boolean first = true;\n        while ((str = in.readLine()) != null) {\n            if (!first) output.append(\"\\n\");\n            first = false;\n            output.append(str);\n        }\n        in.close();\n        System.err.println(((HttpURLConnection) uc).getResponseMessage());\n        return output.toString();\n    }\n", "label": 1, "substitutes": {"setMembers": ["SetMethods", "setMethods", "setMember", " setMember", "SetMember", " setJoin", "parseMembers", "parseMember", "SetJoin", "setJoin", "parseJoin", " setMethods", "SetMembers", "parseMethods"], "url": ["resource", "entry", "string", "channel", "blog", "http", "service", "www", "URL", "path", "io", "feed", "queue", "Url", "email", "client", "user", "address", "l", "connection", "base", "server", "location", "loader", "sl", "article", "hub", "image", "socket", "ssl", "data", "uri", "source", "org", "file"], "reader": ["resource", "entry", "row", "reading", "table", "http", "inner", "ler", "input", "report", "io", "ner", "feed", "driver", "keeper", "handler", "er", "iterator", "err", "bird", "l", "rc", "server", "loader", "read", "Reader", "rer", "iter", "per", "e", "f", "i", "worker", "editor", "writer", "rr", "r", "parser", "rar", "stream", "builder", "file"], "buffer": ["resource", "stage", "http", "padding", "address", "game", "image", "writer", "transfer", "flush", "uri", "text", "fr", "file", "seed", "player", "cache", "request", "uffer", "str", "expression", "comment", "bin", "feed", "sequence", "length", "header", "video", "iter", "code", "password", "filename", "button", "border", "page", "output", "data", "null", "buff", "message", "background", "row", "paste", "queue", "sync", "flash", "document", "phrase", "bar", "counter", "parse", "fb", "binary", "rb", "window", "line", "string", "pause", "response", "input", "layer", "texture", "wave", "buf", "FFER", "batch", "base", "server", "loader", "read", "Buffer", "received", "bytes", "result", "bb", "b", "info", "source", "template"], "pattern": ["df", "group", "Pattern", " Pattern", "function", "position", "string", "cache", "expression", "script", "str", "condition", "atter", "layer", "path", "log", "match", "feed", "patch", "slice", "number", "object", "child", "letter", "handler", "cher", "command", "print", "rule", "app", "part", "document", "model", "event", "system", "config", "array", "serial", "password", "graph", "image", "regular", "format", "counter", "filter", "type", "parser", "re", "builder", "file", "template"], "matcher": ["mather", "reches", "matchacher", "mancher", " matner", "Matger", "matchches", "matner", "matatter", "compcher", "matpattern", "motcher", "match", " mather", "compched", "linpattern", "matchpattern", "compter", "matches", " matpattern", "attcher", "statler", "compches", "motner", "mircher", "recher", "mitch", "pather", "mirpattern", "patter", "matchched", "manher", "mither", "matching", "ratacher", "patner", "compner", "ratching", "Mather", "matchach", "harler", "attger", "patch", "matger", "manner", "matched", "matchner", " matchers", "Matching", "reach", "matach", "statcher", "ratcher", "captcher", "Matacher", "ratger", "mirter", "matchher", "captatter", "harner", "matchcher", "captpattern", "matacher", "statpattern", " matacher", "statner", "Matner", "Matcher", "Matter", "matchler", "mitchers", "motter", "patpattern", "lincher", "linter", "linatter", " match", "mirher", "motpattern", "Matpattern", "harpattern", "patatcher", "matchatcher", " matler", " matter", "compach", "reched", "manacher", "compatcher", "matler", "patchers", "captter", "attching", "matter", "matchers", "matatcher", "harcher", "attacher", " matatter", "matchter", "mitcher", "patcher"], "erg": ["rg", "ers", "gg", "orter", "gra", "berg", "igor", "ger", "usa", "orters", "ung", "ocr", "gy", "urg", "irc", "agog", "region", "yang", "rog", "aug", "org", "magic", "east", "agg", "gas", "progress", "alg", "gr", "eric", "ero", "er", "ag", "porter", "eur", "justice", "uster", "aga", "ERG", "ga", "dr", "game", "eng", "ord", "clus", "ard", "jing", "eri", "gd", "arc", "worker", "oga", "anger", "der", "gae", "ider", "era", "sg", "feat", "forge", "git", "ager", "og", "gru", "ig", "rator", "ander"], "start": ["plus", "rest", "current", "state", "cost", "match", "none", "address", "count", "grade", "like", "space", "check", "stat", "End", "seed", "shift", "pend", "bin", "sum", "add", "pad", "boot", "pick", "init", "find", "off", "stop", "last", "middle", "starting", "something", "offset", "grad", "art", "sort", "end", "ish", "started", "send", "step", "old", "open", "sol", "fit", "begin", "first", "min", "ad", "ie", "part", "scale", "max", "work", "load", "get", "size", "index", "set", "diff", "st", "type", "id", "mid", "name", "run", "speed", "Start", "position", "fill", "inner", "need", "in", "unit", "it", "base", "pos", "show", "read", "head", "ind", "close", "se", "style", "info", "source"], "von": ["onna", "vor", "john", "olson", "mun", "aven", "andon", "wen", "fin", "fun", "bin", "byn", "una", "endor", "dn", "di", "kn", "fat", "hon", "nn", "won", "bn", "tun", "flo", "jen", "melon", "fn", "anon", "bon", "vu", "evin", "lin", "eni", "han", "non", "su", "len", "don", "endon", "hn", "fen", "jan", "vin", "ou", "mon", "vid", "oni", "tu", "ln", "feat", "zon", "lon", "tin", "ver", "uber", "ten", "lu"], "bis": ["ois", "bps", "nexus", "cin", "fat", "bits", "bi", "obs", "bian", "isin", "onis", "prefix", "eni", "idis", "uno", "bas", "isi", "sis", "val", "udi", "bus", "ios", "bs", "bin", "oss", "bles", "boot", "ori", "ni", "buff", "ris", "phis", "oris", "us", "pi", "cus", "bett", "abi", "di", "os", "outs", "lin", "ls", "los", "cos", "bid", "su", "des", "li", "cedes", "oni", "nas", "zi", "fb", "lins", "bat", "is", "ui", "lus", "ri", "bos", "base", "pos", "pins", "BUS", "vs", "bes", "len", "offs", "uss", "vals", "bb", "vin", "vid", "ours"], "m_strComponents": ["m_strCompenses", "m_strComponentales", "m_strCommenses", "m_strRepales", "m_arrCommonents", "m_strComports", "m_strReports", "m_arrCommonent", "m_arrCompenses", "m_intReponents", "m_strExponent", "m_strExports", "m_strCompales", "m_strReponents", "m_arrCommenses", "m_strCommonents", "m_strComponentonent", "m_strComponentenses", "m_arrCommales", "m_intReports", "m_strExpales", "m_strRepenses", "m_arrComponents", "m_strExpenses", "m_intComponents", "m_strComponent", "m_strCommales", "m_strCommorts", "m_intRepales", "m_intRepenses", "m_intCompales", "m_arrCompales", "m_strComponentonents", "m_intComports", "m_intCompenses", "m_strCommonent", "m_strExponents", "m_arrComponent"], "m_strPriorities": ["m_strPrioritives", "m_strActivitions", "m_intPriorities", "m_strComparities", "m_intPrioritions", "m_intPrefitives", "m_strPriorries", "m_strActivities", "m_StrPriorities", "m_strPriorifiers", "m_strMonities", "m_strPositions", "m_strComparity", "m_intPriorries", "m_intPrefitions", "m_StrPosities", "m_strMonitives", "m_strPosifiers", "m_StrPriorifiers", "m_strPrefries", "m_strPrefitions", "m_strPriority", "m_strPrefities", "m_strQualities", "m_StrPosity", "m_strActivitives", "m_intPrioritives", "m_StrPriority", "m_strPosities", "m_StrPositions", "m_StrPosifiers", "m_strQualifiers", "m_strPosity", "m_strQuality", "m_strPrioritions", "m_strMonitions", "m_StrPrioritions", "m_intPrefries", "m_strQualitions", "m_intPrefities", "m_strMonries", "m_strActivries", "m_strComparifiers", "m_strComparitions", "m_strPrefitives"]}}
{"id1": "18238468", "id2": "19868933", "code1": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"testLoadSource": ["TestloadSource", "testloadSources", "testloadSource", "TestLoadSource", "TestloadSourceFile", "testReadSources", "testloadSourceFile", "testReadSourceFile", "testLoadSourceFile", "testAddSourceFile", "testAddFormat", "testAddSource", "TestloadFormat", "TestLoadSourceFile", "testLoadSources", "TestLoadSources", "testloadFormat", "testReadSource", "testLoadFormat", "TestloadSources", "testAddSources", "testReadFormat", "TestLoadFormat"], "metadata": ["df", "attribute", "media", "pdf", "map", "m", "xml", "manager", "ctx", "params", "np", "sheet", "this", "meta", "database", "summary", "json", "properties", "content", "music", "header", "my", "generic", "iterator", "sample", "default", "ami", "document", "tmp", "definition", "loader", "journal", "adata", "auto", "filename", "material", "reader", "data", "md", "module", "tt", "message", "info", "parser", "stream", "artist", "source", "collection", "general", "mo", "template"], "inputStream": ["outputForm", "outputSteam", "InputForm", "rawStream", " inputSteam", "outputWriter", "inputFile", "inputWriter", "rawSteam", "inputSource", " inputFile", "outputStreamer", "outputFile", " inputForm", "inputstream", "inputForm", "streamStreamer", "rawStreamer", "InputWriter", " inputstream", "InputSource", "rawstream", "outputStream", "streamstream", "inputStreamer", "InputSteam", "InputFile", "Inputstream", "streamStream", "outputSource", " inputSource", "streamSteam", " inputWriter", "InputStream", "outputstream", "inputSteam"], "writer": ["temp", "riter", "usher", "writ", "words", "external", "writers", "string", "cache", "word", "pointer", "inner", "ler", "winner", "master", "walker", "Writer", "key", "WR", "driver", "creator", "keeper", "handler", "RW", "document", "w", "out", "settings", "per", "code", "rw", "wrapper", "director", "worker", "her", "editor", "format", "widget", "wr", "reader", "output", "writing", "write", "data", "written", "author", "r", "null", "ana", "buffer", "text", "builder"], "contents": ["constent", "CONTENTS", "Contents", "Contacts", "contacts", "contENTS", "constented", "contentacts", "CONTent", "CONTented", "content", "CONTacts", "Content", "contences", "Contented", "ContENTS", "contentences", "CONTents", "contentent", "contentents", "Contences", "constents", "constENTS", "contented", "CONTences"]}}
{"id1": "3053403", "id2": "12869602", "code1": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "code2": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"fc": ["dc", "fa", "il", "fe", "df", "ref", "pc", "central", "full", "c", "fact", "col", "exp", "sf", "irc", "dl", "pl", "fx", "raf", "fd", "con", "io", "sc", "xc", "feed", "co", "fat", "ll", "flo", "cf", "ct", "ac", "conn", "wk", "fn", "loc", "fs", "cc", "cl", "ff", "mc", "fw", "win", "rc", "vc", "exec", "fi", "circ", "cs", "bc", "f", "enc", "af", "fm", "hub", "xf", "uc", "fp", "cb", "fen", "lc", "hl", "fl", "fb", "bf", "lf", "nc", "ec", "inc", "roc", "rx", "console", "FC", " FC"], "buff": ["txt", "fe", "mb", "grab", "bu", "pl", "uff", "np", "obb", "pp", "build", "xb", "p", "bag", "cell", "bas", "comp", "Buff", "bed", "text", "gg", "gap", "pb", "fo", "fx", "feed", "bd", "cod", "hand", "agg", "boot", "bug", "loc", "bet", "fab", "bl", "ph", "lab", "gb", "cp", "now", "tab", "both", "feat", "null", "bf", "front", "utf", "aff", "bg", "ctx", "FF", "cf", "comb", "load", "sb", "f", "home", "uf", "callback", "fb", "prof", "loop", "font", "bm", "rb", "ref", "bh", "butt", "ob", "cast", "box", "buf", "fam", "eb", "abb", "ff", "app", "fw", "config", "bc", "ind", "bo", "cb", "bb", "img", "b", "back", "buffer", "info", "form"], "encoding": ["encryption", "decoder", " encording", "encoder", "decording", "ecoding", "enaging", "Encryption", " encoder", "encording", "Encasing", " encaging", " encryption", "ecoded", "decasing", "encoded", "Encoded", "enoder", "Encording", "Encoding", "decoding", " encasing", "decoded", "Encaging", "encaging", "enoding", "Encoder", "encasing", "decryption", "ecoder", "ecryption", "enryption"]}}
{"id1": "3046085", "id2": "16825994", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"s": ["S", "ses", "n", "string", "g", "m", "str", "is", "sets", "gs", "path", "south", "params", "in", "content", "sound", "sample", "p", "w", "strings", "sb", "f", "services", "e", "i", "ns", "a", "speech", "v", "joined", "data", "parts", "r", "b", "t", "es", "source", "text", "name", "ss"], "tokenizer": [" tokenizable", "tokenzer", "widgetizable", "tokener", " tokenner", " tokenize", " tokenization", "optiminer", "initializable", "tokeniser", "generizer", " tokenizers", "Tokenister", "okenizers", "widgetizer", " tokeniser", "statiter", "generiser", "Tokeniner", "okeniner", "tokenener", "generize", "toolize", "Tokener", "okenizer", "tokenner", "Tokenize", "tokenization", " tokenator", "tokenize", "initialization", "tunzer", "logizable", "okeniser", "tokenized", "tokenizers", "statator", "normalize", " tokenized", "finizable", "tokenator", "okenzer", "normalizer", "okenener", "okener", "okenator", "toolizable", "finize", "initializer", " tokener", "initialiner", "finer", "finizer", "logizer", "optimiser", "okeniter", "tunizer", " tokenzer", "Tokenizers", "Tokenener", "widgetiser", "initialiser", "Tokenizer", " tokenister", "generized", "tuner", " tokeniter", "tokenizable", "tokenister", " tokenener", "Tokenizable", "Tokenized", "tokeniter", "tooliner", "optimizer", "okenization", "okenner", "tokeniner", "toolizer", "statizers", "tunner", "initialize", "normaliner", "logize", "okenize", "loginer", "Tokeniser", "okenizable", "normalizable", "widgetiner", "statizer", "optimizable", "okenister"], "title": ["resource", "Title", "media", "username", "team", "owner", "description", "bot", "string", "layer", "label", "meta", "summary", "music", "theme", "genre", "profile", "audio", "tag", "prefix", "url", "license", "company", "filename", "format", "editor", "author", "type", "song", "data", "metadata", "source", "text", "name", "art", "album"], "artist": ["track", "voice", "media", "username", "player", "piece", "photo", "cover", "winner", "master", "layer", "patch", "music", "theme", "creator", "archive", "alias", "audio", "Artist", "genre", "video", "tag", "prefix", " artists", "episode", "season", "filename", "image", "author", "song", "target", "metadata", "source", "chart", "art", "album"], "location": ["media", "position", "description", "gallery", "photo", "motion", "area", "region", "language", "time", "layer", "path", "length", "content", "theme", "address", "loc", "audio", "lang", "tag", "layout", "Location", "url", "image", "mobile", "level", "message", "album"], "rating": ["tracking", "scoring", "training", "live", "ranking", "rising", "media", "boarding", "description", "breaking", "repeat", "random", "weight", "alpha", "genre", "audio", "rate", "score", "rank", "sharing", "playing", "game", "season", "resolution", "style", "fps", "album", "padding"], "overplay": ["offload", "offlay", "offledge", "overload", "reledge", "offplay", "overledge", "reload", "overlay", "replay", "opplay", "relay", "opledge", "oplay", "opload"], "temp": ["track", "txt", "stage", "media", "string", "cache", "current", "str", " temporary", "path", "partial", "sequence", "pt", "list", "empty", "content", "music", "original", "unit", "loc", "part", "tag", "base", "layout", "prefix", "tmp", "fake", "flat", " tmp", "emp", "format", "test", "Temp", "data", "type", "stable", "testing", "style", "message", "source", "font", "body", "name", "tc", "template"], "tags": ["reports", "names", "packages", "words", "stats", "bugs", "resources", "videos", "bots", "authors", "ids", "terms", "relations", "images", "styles", "files", "events", "notes", "properties", "plugins", "tests", "strings", "fields", "dates", "stars", "tracks", "thumbnails", "types", "phones", "features", "archives", "Tags", "comments", "users", "products", "sections", "assets", "modules"], "bytes": ["pages", "Bytes", "words", "fee", "codes", "bps", "lines", "videos", "values", "errors", "gets", "params", "bits", "outs", "objects", "letters", "articles", "files", "notes", "seconds", "tes", "pieces", "strings", "balls", "size", "keys", "blocks", "units", "ips", "parts", "data", "comments", "es", "les", "body"], "hasher": ["hahers", "haveher", "hanhr", " haser", "hasumper", "hashest", "hanest", "haest", "havehr", "hashher", "haveest", "Hasest", "hashumper", " hashers", "haveer", "hadher", "hashed", "hanher", "hashandler", "hashhandler", "Hashers", " hashed", " hashr", "hashr", "haner", "hadest", "hashers", "haer", "havehandler", "haser", "haher", "Hashed", "hadumper", "hadhandler", "Haser", "hahed", " hasest", "haveumper", "hasest", "Hasher"]}}
{"id1": "3584508", "id2": "3401153", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    private String getHTML(String pageURL, String encoding, String dirPath) throws IOException {\n        StringBuilder pageHTML = new StringBuilder();\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(pageURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"MSIE 7.0\");\n            connection.connect();\n            BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), encoding));\n            String line = null;\n            while ((line = br.readLine()) != null) {\n                pageHTML.append(line);\n                pageHTML.append(\"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            connection.disconnect();\n        }\n        if (dirPath != null) {\n            File file = new File(dirPath);\n            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file));\n            bufferedWriter.write(pageHTML.toString());\n            bufferedWriter.close();\n        }\n        return pageHTML.toString();\n    }\n", "label": 0, "substitutes": {"copyResource": ["copyFile", "copyresource", "transferFile", "transferUrl", " downloadresource", "copyUrl", " downloadResource", " copyUrl", " copyresource", " downloadFile", " downloadUrl", "transferresource", " copyFile", "transferResource"], "url": ["resource", "string", "host", "http", "xml", "www", "ource", "URL", "path", "feed", "Url", "download", "object", "address", "re", "bel", "loc", "lr", "l", "connection", "base", "ls", "server", "loader", "sl", "f", "image", "remote", "page", "ssl", "data", "r", "id", "web", "source", "stream", "uri", "src", "name", "file", "ref"], "input": ["resource", "temp", "pull", "plus", "accept", "act", "cache", "current", "instance", "qa", "context", "request", "http", "xml", "inner", "bin", "api", "open", "feed", "this", "in", "active", "client", "progress", "ack", "address", "audio", "l", "connection", "base", "out", "element", "exec", "upload", "get", "load", "config", "index", "f", "Input", "but", "session", "i", "image", "socket", "inf", "file", "ssl", "bb", "reader", "data", "parse", "error", "inc", "source", "stream", "binary", "buffer", "form"], "output": ["resource", "application", "external", "cache", "current", "environment", "production", "response", "copy", "layer", "log", "outer", "queue", "operation", "network", "object", "address", "unit", "default", "connection", "document", "out", "config", "other", "control", "image", "socket", "writer", "result", "data", "write", "ou", "put", "target", "web", "source", "stream", "binary", "buffer", "console", "file", "Output", "flow"], "b": ["mb", "nb", "line", "bs", "B", "k", "ob", "m", "c", "pb", "n", "d", "bin", "be", "abs", "buf", "bit", "bi", "batch", "p", "br", "lb", "l", "base", "x", "bc", "sb", "f", "bar", "e", "i", "a", "h", "cb", "v", "bb", "r", "bf", "fb", "buffer", "binary", "ab", "rb", "db", "file"]}}
{"id1": "4417943", "id2": "8024375", "code1": "    public void test() {\n        try {\n            String query = \"* <http://xmlns.com/foaf/0.1/workplaceHomepage> <http://www.deri.ie/>\" + \"* <http://xmlns.com/foaf/0.1/knows> *\";\n            String url = \"http://sindice.com/api/v2/search?qt=advanced&q=\" + URLEncoder.encode(query, \"utf-8\") + \"&qt=advanced\";\n            URL urlObj = new URL(url);\n            URLConnection con = urlObj.openConnection();\n            if (con != null) {\n                Model model = ModelFactory.createDefaultModel();\n                model.read(con.getInputStream(), null);\n            }\n            System.out.println(url);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"test": [" tests", "run", "scan", "stats", "est", "report", " testing", "build", "app", "tests", "show", "server", "load", "work", "index", "evaluate", "Test", "train", " Test", "example", "check", "start", "parse", "testing", "debug", "loop"], "query": ["timeout", "media", "scan", "qa", "cache", "gallery", "request", "Query", "depth", "expression", "comment", "series", "report", "answer", "qu", "search", "json", "sql", "random", "qs", "qt", "index", "quest", "q", "filter", "range", "dq", "type", "question", "term", "uri", "source", "body", "re", "sq", "sort"], "url": ["resource", "route", "string", "host", "href", "request", "http", "xml", "proxy", "service", "www", "URL", "path", "ur", "api", "search", "Url", "download", "address", "loc", "l", "connection", "base", "server", "location", "config", "sl", "f", "link", "q", "page", "ssl", "html", "error", "data", "id", "web", "uri", "source", "buffer", "name", "db", "file"], "urlObj": [" urlObject", "resourceLib", "fileLib", "fileobj", "UrlLib", "resourceObject", "UrlObj", "Urlobj", " urlLib", "fileObj", "urlobj", " urlobj", "httpOb", "resourceOb", "httpLib", "urlLib", "resourceObj", "httpObject", " urlOb", "fileOb", "UrlOb", "httpObj", "urlOb", "urlObject"], "con": ["fa", "soc", "pc", "fc", "c", "Connection", " rc", "ca", "cons", "Conn", "fun", "aff", "conv", "xc", " CON", "open", "fat", "co", "sync", "Connect", "cf", "ct", "ran", "conn", "cl", "connection", " Con", "cn", "out", "rc", "ocon", "exec", "cp", "cur", "syn", "bc", "f", "CON", "Con", "connect", "uc", "close", "obj", "conf", "sub", " conn", "com", "un", "lc"], "model": ["resource", "class", "cm", "zip", "instance", "m", "view", "xml", "proxy", "response", "copy", "path", "api", "json", "object", "content", "app", "connection", "base", "server", "config", "code", "image", "page", "reader", "data", "type", "obj", "null", "module", "Model", "conf", "info", "source", "client", "file", "models"]}}
{"id1": "17296916", "id2": "12085127", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    public final void navigate(final URL url) {\n        try {\n            EncogLogging.log(EncogLogging.LEVEL_INFO, \"Navigating to page:\" + url);\n            final URLConnection connection = url.openConnection();\n            final InputStream is = connection.getInputStream();\n            navigate(url, is);\n            is.close();\n        } catch (final IOException e) {\n            EncogLogging.log(EncogLogging.LEVEL_ERROR, e);\n            throw new BrowseError(e);\n        }\n    }\n", "label": 0, "substitutes": {"logging": ["Loging", "Logting", "bloging", " logger", " logting", "logting", "blogting", "loging", " loging", "logger", "blogging", "blogger", "Logging", "Logger"], "wrap": ["pipe", "or", "run", "we", "war", "use", "nw", "cache", "word", "cover", "self", "transform", "api", "wa", "process", "util", "force", "box", "div", "rap", "handler", "build", "ad", "wp", "p", "flash", "frame", "bag", "wire", "sw", "w", "init", "default", "get", "work", "now", "wra", "ws", "f", "wrapper", " Wrap", "image", "h", "widget", "format", "handle", "parse", "b", " wrapped", "message", "web", "lock", "stream", "wb", "binary", "create", "ow"], "buffer": ["nb", "ob", "player", "cache", "pb", "reply", "board", "table", "uffer", "view", "comment", "cover", "bin", "pause", "surface", "response", "copy", "msg", "log", "layer", "report", "manager", "feed", "buf", "queue", " receive", "bridge", "header", "print", "batch", "flash", "frame", "document", "base", "server", "shell", "url", " buffers", "loader", "bc", "BU", "Buffer", "iter", "bar", "wrapper", "code", "uf", "image", "writer", "cb", "transfer", "result", "bb", "reader", "reference", "null", "fb", "b", "buff", "message", "binary", "source", " buf", "bm", "builder", "ref", "template"], "encoding": ["encryption", "decoder", "enoded", "cet", "encoder", "packet", "ecoding", "enode", "Encryption", "ecoded", "packoding", "coder", "encoded", "Encoded", "encode", "coded", "enoder", "Encoding", "coding", "unicoded", "unicoding", "unicode", "decoding", "decoded", "packoded", "decode", "enoding", "Encoder", "decryption", "unicoder", "ecoder", "encet", "ecryption", "Encet", "packoder"], "getEncoding": ["getencoder", "getEnasing", " getEncocol", " getEncasing", "getEnocol", "getEnoding", " getEnocol", " getEncoder", "getEncoder", "getCoding", "getCoded", "getencoding", " getEncoded", "getEncoded", " getEnasing", "getEncocol", "getencoded", "getCasing", "getEnoded", "getEnoder", " getEnoder", "getCocol", "getEncasing", " getEnoded", "getCoder", "getencocol", " getEnoding", "getencasing"], "headers": ["ers", "names", "ings", "writers", "host", "lines", "values", "http", "str", "ppers", "ids", "heads", "options", "caps", "relations", "params", "objects", "bits", "details", "files", "ints", "groups", "properties", "content", "plugins", "header", "dict", "breaks", "s", "fields", "strings", "keys", "settings", "ports", "wrapper", "head", "frames", "blocks", "types", "h", "features", "vals", "links", "parts", "ters", "workers", "rs", "body", "padding"], "is": ["or", "js", "us", "ms", "isa", "ses", "ios", "bs", "ois", "isl", "isol", "so", "http", "was", "iris", "oss", "has", "as", "io", "api", "abs", "os", "IS", "ais", "ui", "cms", "in", "ins", "aos", "are", "\u00eds", "fs", "obs", "s", "Is", "out", "iso", "iss", "ops", "its", "ws", "bas", "isi", "sis", "i", "ori", "mis", "bis", "lis", "nis", "tis", "las", "es", "ists", "ris"], "bos": ["beans", "bh", "shadow", "ses", "ios", "bs", "oks", "so", "ois", "ob", "mos", "obos", "osi", "oops", "bot", "ko", "fits", "obo", "bots", "bin", "uds", "abi", "ubis", "obi", "bits", "os", "outs", "cms", "flo", "aos", "osa", "bi", "oes", "ubs", "oos", "fs", "obs", "base", "pins", "opus", "bes", "los", "ops", "cos", "bc", "ws", "zo", "bas", "home", "bott", "ros", "bo", "oses", "bis", "mis", "zos", "tis", "las", "lins", "mobi", "org", "bones"], "e": ["fe", "je", "c", "oe", "o", "d", "ee", "be", "ale", "ke", "ce", "er", "ie", "err", "p", "l", "ception", "ea", "pe", "exc", "x", "f", "E", "ite", "i", "ze", "a", "ae", "error", "type", "se", "ev", "esi", "de", "ec", "me", "re", "one", "ise"]}}
{"id1": "6613944", "id2": "3631989", "code1": "    public static String installOvalDefinitions(final String xml_location) {\n        InputStream in_stream = null;\n        try {\n            URL url = _toURL(xml_location);\n            if (url == null) {\n                in_stream = new FileInputStream(xml_location);\n            } else {\n                in_stream = url.openStream();\n            }\n        } catch (IOException ex) {\n            throw new OvalException(ex);\n        }\n        Class<OvalDefinitions> type = OvalDefinitions.class;\n        OvalDefinitions object = _unmarshalObject(type, in_stream);\n        String pid = _getDatastore().save(type, object);\n        return pid;\n    }\n", "code2": "    public void run() {\n        URL url;\n        try {\n            url = new URL(\"http://localhost:8080/glowaxes/dailytrend.jsp\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((str = in.readLine()) != null) {\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"installOvalDefinitions": [" saveOvalRefaults", " saveOvaldefines", " saveOvalFplates", " saveOvalRefines", " saveOvalDefplates", " saveOvalRefplates", " saveOptDefinitions", " saveOvaldefplates", " saveOptDefines", " saveOptDefaults", " saveOvaldefaults", " saveOvalDefaults", " saveOvalRefinitions", " saveOptdefines", " saveOvalDefines", " saveOvalFines", " saveOptDefplates", " saveOptdefinitions", " saveOvalFinitions", " saveOptdefaults", " saveOvaldefinitions", " saveOptdefplates", " saveOvalFaults", " saveOvalDefinitions"], "xml_location": [" xml_path", " xml_area", "http_location", "xml_area", "xml_directory", "xml67loc", "xmlFilelocation", "xmlFilefilename", " xml_type", "xmlFilearea", "xml67path", "xml67location", "xml_filename", "http_loc", " xml_loc", "xml_path", "xml_type", " xml_filename", "xmlFileLocation", "xml_loc", " xml_Location", "xml67type", "http_directory", "xml_Location"], "in_stream": ["inc_cont", "in_channel", "thin67channel", " in_stack", "in67clean", "in67struct", "inc_stream", "in_cont", " in_url", "in_clean", "thin67stream", "in_stack", " in_trans", "thin_stream", "in_trans", "in_sw", "in_ream", "in67channel", "inc_clean", "inc_ream", " in_form", "in67sw", "thin_sw", "in67cont", "in67stream", "thin67struct", "in_form", "thin_struct", "thin_channel", "in67ream", "in_struct", "thin67sw", "in_url"], "url": ["resource", "stream", "ob", "string", "blog", "host", "http", "xml", "str", "www", "URL", "path", "ll", "log", "api", "open", "feed", "Url", "impl", "address", "bel", "bug", "loc", "browser", "l", "connection", "base", "ls", "coll", "location", "server", "sl", "f", "image", "socket", "html", "ssl", "bb", "page", "data", "fl", "obj", "b", "web", "source", "uri", "org", "file", "ref"], "type": ["group", "class", "function", "kind", "instance", "py", "o", "method", "http", "xml", "tool", "copy", "path", "platform", "key", "address", "single", "unit", "handler", "p", "part", "base", "tag", "pe", "element", "model", "port", "like", "category", "python", "link", "TYPE", "types", "format", "pod", "file", "Type", "product", "obj", "style", "module", "plugin", "null", "ype", "parser", "t", "info", "id", "parent", "collection", "name", "core", "ref"], "object": [" error", "class", "function", "project", "string", "instance", "oid", " obj", "o", "pointer", "version", "node", "objects", "os", "number", " python", "address", " structure", "document", "base", "part", "element", "model", "config", "array", "value", "result", "nt", "data", "product", "obj", "target", "id", "info", "parent", "name"], "pid": ["ping", "root", "pc", "pd", "sid", "oid", "pb", "pointer", "pse", "proxy", "ids", "bin", "uid", "abi", "pac", "pin", "pp", "pak", " tid", "p", "proc", "phi", "pos", "pins", "pa", "port", "phrase", "processor", "pkg", "lp", " pin", "iana", "product", "vid", " PID", "plugin", "ps", "jp", "pty", "id", "parent"]}}
{"id1": "7122523", "id2": "23666867", "code1": "    public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        InstanciaDelegate delegate = RegistroManager.recuperarInstancia(request);\n        if (delegate == null) {\n            ActionErrors errors = new ActionErrors();\n            errors.add(null, new ActionError(\"errors.session\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"fail\");\n        }\n        AyudaPantalla ayudaPantalla = delegate.obtenerAyudaPantalla();\n        TraAyudaPantalla traAyudaPantalla = (TraAyudaPantalla) ayudaPantalla.getTraduccion();\n        String urlSonido = traAyudaPantalla.getUrlSonido();\n        if (urlSonido == null) {\n            return null;\n        }\n        URL url = new URL(urlSonido);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.connect();\n        String tipoMime = urlConnection.getContentType();\n        log.debug(\"Tipo Mime: \" + tipoMime);\n        Map audioOptions = new HashMap();\n        if (tipoMime.indexOf(\"audio\") != -1 || tipoMime.indexOf(\"asf\") != -1 || tipoMime.equals(\"unknown/unknown\")) {\n            audioOptions.put(\"id\", \"MediaPlayer\");\n            audioOptions.put(\"codeBase\", \"http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,7,1112\");\n            audioOptions.put(\"classId\", \"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95\");\n            audioOptions.put(\"mimeType\", \"application/x-mplayer2\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/\");\n        } else if (tipoMime.indexOf(\"real\") != -1) {\n            audioOptions.put(\"id\", \"RVOCX\");\n            audioOptions.put(\"codeBase\", \"\");\n            audioOptions.put(\"classId\", \"clsid:CFCDAA03-8BE4-11cf-B84B-0020AFBBCCFA\");\n            audioOptions.put(\"mimeType\", \"audio/x-pn-realaudio-plugin\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"\");\n        }\n        request.setAttribute(\"audioOptions\", audioOptions);\n        log.debug(\"entra success\");\n        return mapping.findForward(\"success\");\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 0, "substitutes": {"execute": ["action", "run", "route", "send", "instance", "method", "call", "forward", "invoke", "func", "transform", "report", "process", "post", "this", "default", "exec", "start", "handle", "apply", "transfer", "result", "next", "data", "submit", "message", "info", "create"], "mapping": ["mmording", "rmapping", " mapper", "Mapped", "mapped", "matching", " mapped", "pailing", "mmailing", "Mapper", "rmapper", "pording", "rmapped", " mailing", "Mappings", "mmapping", "mmatching", "patching", "Mapping", "mailing", " mording", " matching", "mording", "papping", "rmappings", "mappings", " mappings", "mapper"], "form": ["entry", "route", "view", "former", "input", "transform", "path", "Form", "post", "FORM", "object", " forms", "forms", "command", "flow", "app", "model", "upload", "query", "config", "field", "control", "session", "format", "page", "submit", "builder", "template"], "request": ["resource", "application", "route", "subject", "use", "instance", "current", "context", "method", "view", "xml", "Request", "state", "input", "report", "path", "queue", "enter", "object", "user", "handler", "frame", "event", "model", "server", "query", "session", "q", "image", "result", "type", "submit", "req", "QUEST", "ware", "message", "web", "parent", "client", "create"], "response": ["Response", "resource", "application", "status", "reply", "view", "http", "results", "report", "manager", "object", "resp", "model", "server", " Response", " responses", "session", "res", "result", "page", "output", "error", "data", "req", "message", "client"], "delegate": ["relegates", "deplementation", " delic", "DEploy", "declegates", "DElegate", " deleg", "deider", "DEleg", "rolelegate", "reploy", "Deplementation", " deplementation", "deleg", "Delegates", "relegate", "delic", "delegates", " deider", "releg", " delegates", "Delic", "rolelic", "rolelegates", "decleg", "Delegate", "Deleg", "decider", "DElegates", "deploy", "roleplementation", "Deider", "Deploy", "declegate"], "errors": ["reports", "rss", " messages", "maps", "instance", "xml", " problems", "failed", "results", "values", "eps", "ations", "uments", "relations", "params", "ays", "objects", "details", "events", "ins", "members", "plugins", "err", " Errors", "rors", "s", "all", "effects", "ceptions", "ops", "orders", "settings", "array", " responses", " exceptions", "e", "blocks", "ros", "rules", "links", "issues", "ae", "error", "data", "asts", "runs", "items", "null", "comments", "parser", "es", "ages", "rs", "les", "management", "rows"], "ayudaPantalla": ["ayudaPentalla", "ayudaPandla", "ayudaPantla", "ayudaPantsla", "ayudaPatarala", "ayudaPantsella", "ayudaPandala", "ayudaPantala", "ayudaTantala", "ayudaTentilla", "ayudaPandalla", "ayudaPantella", "ayudaPandilla", "ayudaTantalla", "ayudaPatantala", "ayudaPandella", "ayudaParailla", "ayudaTantilla", "ayudaPentilla", "ayudaPentala", "ayudaPantilla", "ayudaTentala", "ayudaPantsala", "ayudaParala", "ayudaPantsilla", "ayudaPatantilla", "ayudaTantella", "ayudaPatantla", "ayudaTentella", "ayudaTentalla", "ayudaParaala", "ayudaPatantalla", "ayudaPataraalla", "ayudaPatarailla", "ayudaPantsalla", "ayudaParaalla", "ayudaPentella", "ayudaPataraala"], "traAyudaPantalla": ["traAyudaVantlla", "traAyudaPlantella", "traAyudaPandala", "traAyudaPantingalla", "traAyudaPlantalla", "traAyudaVantalla", "traAyudaPantingella", "traAyudaPantingala", "traAyudaPlantingilla", "traAyudaVantaya", "traAyudaPartala", "traAyudaPartalla", "traAyudaPandlla", "traAyudaParaaya", "traAyudaPantaya", "traAyudaVandaya", "traAyudaPentalla", "traAyudaVandalla", "traAyudaPantala", "traAyudaPlantilla", "traAyudaParaalla", "traAyudaPentilla", "traAyudaVantala", "traAyudaPartaya", "traAyudaPlantingalla", "traAyudaParalla", "traAyudaPantella", "traAyudaPartlla", "traAyudaPlantingala", "traAyudaVandlla", "traAyudaPantlla", "traAyudaParaala", "traAyudaPlantala", "traAyudaPentala", "traAyudaPantingilla", "traAyudaPlantingella", "traAyudaPentella", "traAyudaPandalla", "traAyudaVandala", "traAyudaPandaya", "traAyudaPandilla", "traAyudaPantilla", "traAyudaPandella"], "urlSonido": ["urlSonigma", "urlTonido", "urlMonidi", "urlSonini", "uriSonigma", "urlSonuli", "uriSonido", "uriSonid", "urlSONido", "UrlSenigo", "urlsonado", "urlBonado", "UrlBonidi", "UrlBonido", "UrlSenini", " urlSonado", "UrlBonida", "UrlSonido", "uriSONigma", "urlMonido", "urlSonri", " urlTonini", "urlsonigo", "urlSonidi", "urlBonuli", "uriSONini", "urlMonuli", "urlTonini", "urlSonado", "urlTonado", "urlBonigo", "urlTonid", "urlSenigo", "urlSONida", "urlsonido", "urlSONid", "urlMonida", "UrlSonidi", "urlsonri", "urlSONidi", "urlBonido", "urlTonigo", "urlTonigma", "uriSonini", "urlTonri", "UrlSenido", "UrlSonida", "uriSONid", "UrlSenri", "UrlSonini", "urlSONigma", "UrlSonuli", "urlSonida", "urlSonigo", "UrlBonuli", "urlSONuli", "urlBonidi", "urlsonid", "uriSONido", "urlBonini", "urlsonigma", "urlSenido", "urlBonida", "UrlSonri", "urlSenri", "UrlSonigo", "urlSonid", "urlsonini", "urlSenini", " urlSonini", "urlSONini", " urlSonigo", " urlTonigo", " urlTonido", " urlTonado"], "url": ["resource", "full", "string", "http", "str", "service", "www", "URL", "path", "log", "ll", "gl", "Url", "json", "download", "impl", "user", "l", "connection", "base", "ls", "server", "location", "system", "config", "sl", "f", "control", "image", "page", "ssl", "fl", "b", "web", "uri", "source", "client"], "urlConnection": ["urlFactory", "URLFactory", "urlConn", "httpConn", "userConnection", "webconnection", "userInfo", "httpConnection", "urlInfo", "webClient", " urlconnection", "eventconnection", "URLClient", "webConnection", "eventConnect", "eventConnector", " urlInfo", "urlconnection", "userconnection", "eventConnection", "httpFactory", "webConn", "webFactory", "webConnector", "UrlConnector", "webConnect", "Urlconnection", "urlClient", "httpClient", "UrlConnection", "UrlConnect", "urlConnect", "URLConn", "UrlInfo", "URLConnection", "urlConnector"], "tipoMime": ["tiposMale", "tiposTorph", " tipoMpe", "tipoMorph", "tipoImime", "tipoPanche", "tiposTike", "tipoPIME", "tipoTime", " tipoTpe", " tiposTime", "tipoKnanche", "tiposText", " tipoMetpe", "tipoImale", "tipoImize", "tipoManche", "tipoText", "tipoMIME", " tipoMIME", "tiposTize", " tiposTile", "tiposMile", " tipoTile", " tipoTIME", "tipoMile", " tipoMetIME", "tiposTale", " tiposMpe", "tiposManche", "tiposTanche", "tipoCext", "tipoCIME", "tipoKnike", "tipoKnIME", "tipoDemime", "tipoTike", "tipoDemale", "tipoNile", "tipoKnime", "tipoPike", "tipoCorph", "tipoMext", "tipoNime", "tipoImIME", "tipoMale", " tiposMile", "tiposMorph", " tipoTime", " tipoSmpe", "tiposTime", "tiposMize", "tiposMike", " tiposMIME", " tipoMetile", " tipoMetime", "tiposTile", "tipoCile", " tipoSmIME", "tipoMike", "tiposMIME", " tipoMile", "tipoDemIME", " tipoSmime", "tipoTale", "tipoDemize", "tipoTorph", "tiposMime", "tipoPime", " tiposTpe", "tiposMext", " tiposMime", "tipoTile", "tipoNIME", "tipoTize", "tipoMize", "tipoTIME", " tipoSmile", "tipoTanche", "tipoNext", " tiposTIME", "tiposTIME", "tipoCime"], "audioOptions": ["audioSettings", "videoStream", "mediaSettings", " audioColor", "musicParts", "archiveOptions", "audioColor", "oggContents", "oggOptions", "mediaGames", "AudioSettings", "audioParts", "soundOptions", " audioOption", "musicOptions", "audioGames", "mediaVideo", " audioParts", "musicStream", "audioContents", "videoOptions", "mediaParts", "soundContents", "audioOption", "audioStyle", "mediaStyle", "archiveColor", "mediaOptions", "soundOption", "videoGames", " audioSettings", "soundoptions", "videoVideo", " audioStream", "musicSettings", "AudioStyle", " audioVideo", "videooptions", "AudioStream", "audioVideo", "AudioColor", "audioRules", "oggRules", "archiveStream", "AudioGames", "AudioOptions", " audioStyle", " audiooptions", "soundRules", "audioStream", "videoParts", "oggOption", "archiveStyle", " audioRules", " audioContents", " audioGames", "soundSettings", "videoSettings", "audiooptions"]}}
{"id1": "21308543", "id2": "19251426", "code1": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copiedContent", " copyFiles", " copyContent", "transferFile", "transferStream", "copyContent", " copiedStream", " copiedFile", "transferContent", "transferFiles", "copyFiles", " copyStream", " copiedFiles", "copyStream"], "src": ["resource", "scene", "js", "media", "project", "string", "href", "http", "ruby", "input", "ource", "path", "inst", "sc", "slice", "this", "attr", "dest", "download", "loc", "rc", "ls", "upload", "server", "url", "sci", "code", "filename", "image", "sin", "inf", "remote", "img", "feat", "rs", "source", "stream", "uri", "sit", "rb", "sel", "core"], "target": ["resource", "temp", "large", "external", "project", "effect", "master", "path", "fat", "dest", "arget", "compatible", "object", "content", "loc", "it", "rel", "goal", "base", "out", "port", "url", "director", "eth", "tx", "top", "Target", "remote", "writer", "to", "nt", "output", "next", "type", "arg", "secure", "result", "prot", "parent", "source", "text", "name", "reference"], "ic": ["ib", "icc", "ics", "pc", "fc", "ip", "nic", "c", "pic", "irc", "cin", "ick", "aci", "IC", "ci", "xc", "io", "cci", "mic", "ct", "ac", "loc", "it", "ico", "cc", "cl", "mc", "vc", "rc", "aic", "exec", "bc", "enc", "sci", "isc", "i", "iac", "ici", "cit", "ai", "acl", "inc", "ec", "ix", "ik", "lc", "voc"], "oc": ["soc", "pc", "fc", "nic", "alloc", "c", "ocr", "pic", "irc", "o", "abc", "ci", "xc", "io", "sc", "co", "mic", "oci", "ac", "AC", "acs", "loc", "oca", "cc", "mc", "vc", "rc", "exec", "OC", "ocol", "cs", "bc", "anc", "enc", "other", "isc", "aco", "arc", "uc", "bb", "output", "ec", "iv", "roc", "toc", "ace", "org", "voc"]}}
{"id1": "442381", "id2": "7122523", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        InstanciaDelegate delegate = RegistroManager.recuperarInstancia(request);\n        if (delegate == null) {\n            ActionErrors errors = new ActionErrors();\n            errors.add(null, new ActionError(\"errors.session\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"fail\");\n        }\n        AyudaPantalla ayudaPantalla = delegate.obtenerAyudaPantalla();\n        TraAyudaPantalla traAyudaPantalla = (TraAyudaPantalla) ayudaPantalla.getTraduccion();\n        String urlSonido = traAyudaPantalla.getUrlSonido();\n        if (urlSonido == null) {\n            return null;\n        }\n        URL url = new URL(urlSonido);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.connect();\n        String tipoMime = urlConnection.getContentType();\n        log.debug(\"Tipo Mime: \" + tipoMime);\n        Map audioOptions = new HashMap();\n        if (tipoMime.indexOf(\"audio\") != -1 || tipoMime.indexOf(\"asf\") != -1 || tipoMime.equals(\"unknown/unknown\")) {\n            audioOptions.put(\"id\", \"MediaPlayer\");\n            audioOptions.put(\"codeBase\", \"http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,7,1112\");\n            audioOptions.put(\"classId\", \"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95\");\n            audioOptions.put(\"mimeType\", \"application/x-mplayer2\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/\");\n        } else if (tipoMime.indexOf(\"real\") != -1) {\n            audioOptions.put(\"id\", \"RVOCX\");\n            audioOptions.put(\"codeBase\", \"\");\n            audioOptions.put(\"classId\", \"clsid:CFCDAA03-8BE4-11cf-B84B-0020AFBBCCFA\");\n            audioOptions.put(\"mimeType\", \"audio/x-pn-realaudio-plugin\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"\");\n        }\n        request.setAttribute(\"audioOptions\", audioOptions);\n        log.debug(\"entra success\");\n        return mapping.findForward(\"success\");\n    }\n", "label": 0, "substitutes": {"doVersionCheck": [" doReleasecheck", "doversionTest", " doVersionWork", " doBuildcheck", "doBuildCheck", "doVERSIONTest", " doBuildCheck", " doVersioncheck", " doReleaseTest", "doVERSIONWork", "doVersionWork", "doBuildTest", "doReleaseWork", "doversioncheck", "doBuildcheck", "doVERSIONcheck", "doVersioncheck", " doReleaseCheck", "doVERSIONCheck", " doBuildWork", "doVersionTest", "doReleasecheck", " doBuildTest", " doVersionTest", "doversionCheck", "doReleaseCheck", "doBuildWork", "doReleaseTest"], "view": ["row", "window", "accept", "use", "full", "View", "cache", "see", "gui", "http", "request", "comment", "input", "self", "screen", "can", "edit", "display", "box", "VIEW", "this", "ui", "client", "div", "object", "gu", "l", "app", "vis", "show", "out", "layout", "model", "port", "server", "event", "cell", "config", "block", "e", "session", "q", "el", "image", "widget", "page", "v", "change", "reader", "html", "style", "buffer", "update", "lock", "body", "form", "sel", "views"], "url": ["resource", "stream", "ob", "zip", "string", "channel", "blog", "host", "http", "service", "input", "URL", "log", "ll", "path", "open", "Url", "client", "user", "address", "bel", "build", "browser", "l", "connection", "base", "server", "loader", "sl", "f", "hub", "image", "lib", "socket", "ssl", "bb", "web", "uri", "buffer", "source", "file"], "in": ["resource", "In", "n", "ini", "IN", "cin", "is", "din", "inner", "input", "as", "con", "ins", "ac", "inn", "isin", "init", "win", "s", "lin", "out", "rin", "gin", "i", "nin", "socket", "sin", "login", "bis", "reader", "data", "b", "inc", "binary", "stream", "source", "buffer", "file"], "bin": ["inline", "run", "nb", "oin", "bot", "IN", "cin", "ruby", "fin", "din", "inner", "input", "abi", "log", "con", "pin", "bn", "inn", "bi", "browser", "kin", "part", "init", "win", "lin", "out", "gin", "loader", "lib", "socket", "sin", "record", "border", "bb", "reader", "data", "spin", "b", "binary", "buffer", "lock", "body", "ln", "file"], "line": ["inline", "look", "band", "entry", "row", "pass", "day", "ip", "string", "site", "lines", "word", "LINE", "ine", "str", "comment", "le", "Line", "ge", "layer", "log", "key", "no", "object", "letter", "unit", "valid", "cl", "l", "part", "up", "base", "rule", "lin", "cell", "pe", "model", "load", "definition", "non", "link", "e", "code", "i", "home", "nl", "el", "split", "lo", "page", "data", "parse", "style", "b", "lf", "message", "job", "source", "id", "text", "block", "name", "file", "lc", "end"], "develBuild": ["dellRelease", "deployRun", "DEVELbuild", "deployBuilder", "DEvelBuild", "devenBuilt", "deelBuild", "desvenBuilt", "deelBuilder", "develBuilder", "desvelBuild", "dellRun", "DEVELBuild", "devenbuild", "deVELBuild", "desvelbuild", "dellBuilder", "deploybuild", "devenRelease", "desvelRun", "DEVELBuilt", "devenBuilder", "dewardBuilt", "deviousBuilt", "desvelRelease", "deviousbuild", "deviousBuild", "DEvelbuild", "deVELRun", "deVELBuilder", "develbuild", "devenBuild", "desvenBuild", "DEVELBuilder", "DEvelBuilder", "dewardBuild", "develRelease", "develRun", "dewardbuild", "develBuilt", "deVELbuild", "desvenBuilder", "deployBuilt", "desvenRun", "dellBuild", "deelRelease", "deVELBuilt", "desvelBuilder", "desvelBuilt", "deelRun", "desvenbuild", "desvenRelease", "devenRun", "DEvelBuilt", "deployBuild", "dewardBuilder"], "stableBuild": ["prettyBuilder", "stableBuilder", "stablebuild", "baseVersion", " stableVersion", "compatibleBuilder", "staticbuild", "basebuild", "latestBuild", "validBuild", "stableVersion", "compatiblebuild", "latestbuild", "baseBuilder", "securebuild", "baseBuild", "prettyVersion", "prettybuild", "validBuilder", "staticBuilder", "secureBuilder", "compatibleBuild", "staticBuild", "validbuild", " stablebuild", "prettyBuild", " stableBuilder", "secureBuild", "latestBuilder"]}}
{"id1": "4686922", "id2": "10795866", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourcesToFile", "extractResourceInfile", "extractResourceAndFile", "extractResourceToResource", "extractResourceInFile", "extractResourceAsResource", "extractResourceToFiles", "extractResourceAsfile", "extractResourceAndResource", "extractResourcesToFiles", "extractResourcesTofile", "extractResourceInResource", "extractResourceAsFiles", "extractResourceTofile", "extractResourceInFiles", "extractResourceAndFiles", "extractResourcesAsFile", "extractResourceAsFile", "extractResourceAndfile", "extractResourcesAsFiles", "extractResourcesAsfile", "extractResourcesAsResource", "extractResourcesToResource"], "resourcePath": ["ResourceUrl", " resourceUrl", "sourceId", " resourcepath", "serviceFolder", "stringFolder", "sourcepath", "resourceId", "sourceUrl", "resourceUrl", "sourcePath", "resourceFolder", "ResourceId", "resourcepath", "stringPath", "servicepath", "servicePath", "Resourcepath", " resourceId", "ResourcePath", "stringpath", " resourceFolder"], "dest": ["folder", "resource", "txt", "temp", "done", "route", "class", "project", "sac", "resources", "dist", "destroy", " Dest", "path", "desc", "die", "content", "sup", "store", "comb", "trans", "default", "tmp", "contract", "config", "flat", "home", "filename", "Dest", "transfer", "result", "img", "output", "data", "target", "prop", " destination", "de", "source", "const", "wb", "src", "later", "file"], "in": ["resource", "In", "pass", "plus", "again", "ini", "c", "n", "IN", "rec", "cin", "is", "din", "inner", "bin", "input", "as", "con", "this", "ins", "conn", "inn", "kin", "up", "connection", "init", "win", "rin", "lin", "isin", "url", "gin", "like", "thin", "f", "inside", "i", "nin", "image", "socket", "sin", "login", "arin", "reader", "r", "b", "inc", "id", "source", "re", "file"], "out": ["temp", "In", "again", "at", "outside", "n", "cache", "o", "ex", "bin", "Out", "copy", "outer", "io", "norm", "outs", "this", "sync", "ins", "co", "conn", "boot", "user", "cookie", "err", "up", "app", "w", "s", "net", "all", "exec", "server", "cos", "f", "i", "off", "a", "image", "lib", "writer", "auto", "socket", "ext", "output", "ax", "obj", "OUT", "null", "b", "inc", "parent", "source", "client", "one", "file"]}}
{"id1": "8087001", "id2": "21555906", "code1": "    public static String generateStackHashKey() {\n        Exception e = null;\n        try {\n            throw new Exception();\n        } catch (Exception ex) {\n            e = ex;\n        }\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(getStackTrace(e).getBytes());\n            byte[] hash = digest.digest();\n            String rtn = Base64.encode(new String(hash));\n            if (keys.contains(rtn)) {\n                return generatedIterStackHashKey(rtn);\n            }\n            keys.add(rtn);\n            return rtn;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"generateStackHashKey": ["generateStackHeaderString", "generatestackhashKey", "generatestackHashKey", "generateStackhashKey", "generatestackhashKeys", "generateStackHeaderKeys", "generateStackhashKeys", "generatestackHashKeys", "generatestackhashkey", "generatestackHashString", "generateStackHashKeys", "generateStackHeaderKey", "generateStackhashkey", "generatestackhashString", "generateStackHashkey", "generateStackHashString", "generatestackHashkey", "generateStackHeaderkey", "generateStackhashString"], "e": ["body", "fe", "n", "c", "est", "oe", "m", "o", "ex", "d", "ee", "this", "enter", "ed", "er", "ie", "err", "Exception", "p", "ef", "ception", "ea", "pe", "element", "event", "exec", "exc", "x", "he", "f", "E", "ele", "ze", "el", "a", "h", "ae", "error", "se", "ev", "r", "b", "en", "t", "esi", "ec", "es", "me", "ace", "et"], "digest": ["Signester", "digator", "logest", "Digator", " Digester", "digusher", " diger", "mdest", " digator", " digher", "mdate", "Digester", " digusher", "Signate", "mdested", "Digested", "digate", "digge", "digested", "Digge", "digester", " Digator", "decest", "Digusher", "digenge", " digester", "mdature", " digested", "Digher", "mdusher", "logester", "Diger", " Digested", " Digest", "diger", "mder", "Signature", " digenge", "decate", " digge", "logge", "digature", "mdenge", "mdester", "Digest", "decature", "Signest", "logher", "decester", "digher", "Digenge"], "hash": ["bh", "hed", "sh", "string", "history", "mac", "Hash", "rh", "total", "sha", "sum", "key", "hex", "ashes", "header", "kh", "build", "ha", "ph", "base", "ash", "array", "f", "code", "value", "her", "image", "h", "dot", "result", "v", "data", "dig", "b", "message", "text", "body"], "rtn": ["txc", "retb", "RTns", "latN", "vrns", "rtnin", "RTnin", "RTnn", "rtns", "gtn", "ntn", "ortN", "ntN", "RTne", "ortne", "RTc", "RTb", "ortnn", "rdn", "gtb", "retns", "ntb", "ntc", "vrN", "rdN", "vrn", "ntnin", "rtnn", "ntpn", "retN", "rtpn", "latns", "RTN", "RTn", "rtc", "txn", "rtb", "latn", "rtne", "vrnn", "rtN", "gtpn", "retn", "rdns", "vrne", "RTpn", "latne", "ortn", "txN", "gtN", "txnin", "rdb"]}}
{"id1": "6988216", "id2": "20011285", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" runClientFilter", "runRawQuery", "runRawConnect", " runSimpleFilter", " runBasicQuery", " runSimpleQuery", "runRawSearch", " runClientQuery", " runClientConnect", " runBasicFilter", "runSimpleQuery", " runSimpleSearch", " runRawFilter", "runSimpleConnect", " runSimpleConnect", " runBasicSearch", " runRawConnect", "runSimpleFilter", "runSimpleSearch", "runRawFilter", " runRawSearch", " runClientSearch", " runBasicConnect", " runRawQuery"], "dummySource": ["dandySource", "dellyContent", "dumbConfig", "dellyService", "puddyType", "dandyClient", "daddyContent", "dundleSource", " dumbSource", "dandySourceFile", "duddyService", "puddyService", "pummyType", "dummyOrigin", "pummyClient", "dumbOrigin", "dummySourceFile", "puddySite", "dumbContent", "duddyType", "daddyClient", "dummyType", "dummySite", "duddySource", "puddyContent", " dummyOrigin", "pummySourceFile", "dummyConfig", "dumbSource", "daddyService", "daddySourceFile", "duddySourceFile", "pummyContent", " dumbContent", "duddyClient", "dummyClient", "duddySite", "dundleOrigin", "puddySource", "dellySource", "daddySite", "daddyType", "duddyConfig", "puddySourceFile", "pummySource", "dundleContent", " dumbConfig", "duddyOrigin", " dumbOrigin", "pummySite", "dundleConfig", "duddyContent", " dummyConfig", "puddyClient", "dummyService", "pummyService", "dandySite", "daddySource", "dellyType"], "os": ["or", "ks", "us", "ms", "ol", "ios", "bs", "osi", "ens", "css", "mos", "op", "o", "dos", "oa", "is", "oss", "as", "io", "sys", "aos", "object", "bos", "conn", "acs", "oc", "om", "oos", "fs", "ose", "obs", "s", "nos", "pos", "out", "oS", "los", "iso", "vs", "ls", "ops", "cos", "Os", "i", "ds", "ox", "ori", "oses", "ros", "ns", "ok", "ols", "ows", "ou", "ps", "uns", "es", "OS", "ss"], "dummyContent": ["dummyReader", "dummyContents", "duckyBody", "DummySource", "dellyContent", " dellyOutput", "dumpingContents", "dumperOutput", "dumpingcontent", "DuckyContent", "DummyBody", " dummyOutput", "duckyReader", " dellyContent", "duddySource", "dellyContents", "dumperReader", " dummyContents", "dumpercontent", "DuckyBody", "dumperSource", "duddyReader", "dumperBody", "duckySource", "duckyContent", "dummycontent", "dummyOutput", "DummyContent", "dumpingOutput", "duddyBody", "dellycontent", " dellycontent", " dellyContents", "dumpingContent", "DuckySource", "dummyBody", "dellyOutput", "dumperContent", "duddyContent", "DummyReader", "DuckyReader", "dumperContents", " dummycontent"], "source": ["resource", "slave", "class", "use", "seed", "string", "resources", "host", "cache", "channel", "Source", "proxy", "service", "scope", "node", "ource", "search", " sources", "sc", "text", "sync", "client", "object", "unit", "connection", "s", " Source", "storage", "element", "url", "sn", "cos", "config", "size", "sl", "e", "i", "SOURCE", "sin", "result", "reader", "secure", "ser", "ources", "target", "info", "stream", "uri", "parent", "src", "site", "core"], "content": ["resource", "body", "media", "description", "clean", "css", "host", "current", "xml", "expression", "title", "version", "cover", "comment", "service", "response", "transform", "input", "report", "news", "feed", "match", "sol", "cms", "child", "music", "address", "header", "document", "model", "server", "Content", "url", "load", "cos", "config", "size", "children", "code", "value", "image", "html", "result", "output", "data", "target", "comments", "message", "update", "text", "cont", "activity"], "qResult": ["iqresult", "qResults", "queryResults", " qResults", "rRes", "qResponse", "kReturn", "queryFilter", "iqResponse", "kResult", " qresult", "QReturn", "rResult", "queryResult", "QFilter", "qRes", "qReturn", "kResults", "QResults", "queryresult", " qResponse", "qFilter", "kFilter", "qSource", "iqResult", "queryReturn", "rresult", "iqResults", "querySource", "kresult", "kSource", "kRes", "rSource", "queryRes", "queryResponse", "QResult", "qresult"], "results": ["reports", "pages", "resources", "lines", "values", "errors", "ids", "response", "objects", "versions", "details", "shows", "files", "events", "ins", "Results", "groups", "members", "RESULTS", "successful", "tests", "qs", "s", "its", "children", "ries", "vers", "ions", "blocks", "res", "result", "features", "data", "models", "items", "docs", "users", "runs", "collection", "rows"], "it": ["or", "entry", "si", " It", "ip", "not", "pit", "and", "you", "op", "ait", "IT", "rit", "itted", "ci", "ic", "iti", "edit", "list", "slice", "ITS", "the", "in", "ins", "ort", "ited", "lit", "mit", "p", "l", "init", "its", "ati", "iter", "ite", "i", "split", "stat", "v", "It", "r", "t", "id", "sit", "info", "which"], "rSrc": [" rDsrc", "rAsrc", "RIsrc", " rDsource", "RSrc", "rEsource", "rDsource", "RIsource", " rSRC", " rSsrc", "rDssrc", " rEsrc", "rPsRC", "rAsRC", " rDssrc", "rEssrc", " rEsRC", "rPsource", "rAssrc", "rSrec", "RSource", "rPssrc", "rIsrc", "RSRC", "rDsRC", "RIsrec", "rDsrc", " rDsRC", "rIsrec", "rEsrc", " rEsource", " rEssrc", "rEsRC", "rPsrc", "rAsource", "RIsRC", "rIsource", " rSource", "rSource", "rSRC", "RSrec", "rAsrec", "rIsRC", "rSsrc"], "rSrcIn": ["rAsrcin", "rSsrcOut", "rSvcIN", "rCrcIn", "rSourcein", "rSRCIns", "rCRCIn", "rCsrcIn", "rCsrcIN", "rSrcOut", "rCrcIns", "rSRCOut", "rSourceIn", "rAsrcOut", "rSrcIN", "rSRCin", "rSvcOut", "rSourceOut", "rCrcIN", "rAsRCOut", "rSsrcIN", "rSvcIns", "rCrcOut", "rSvcin", "rCRCIns", "rSrcin", "rAsrcIn", "rCrcin", "rSRCIn", "rSrcIns", "rSourceIns", "rAsRCin", "rCsrcin", "rCsrcOut", "rSsrcIn", "rAsRCIn", "rSRCIN", "rSvcIn", "rSsrcin", "rCRCOut"], "actualOut": ["operatorOut", "assertOut", "publicIn", " actualIn", " actualOUT", "eventout", "publicOut", "eventOut", " actualWin", "actualBridge", "operatorIn", "realOut", " ActualOut", "actualout", " ActualOUT", "nexpectedout", "illegalOUT", " ActualBridge", "assertOUT", "actualWin", "operatorOUT", "realIn", "assertBridge", "assertIn", "actualIn", " actualOutput", "publicOutput", "illegalOut", "illegalOutput", "realout", "nexpectedWin", " actualout", "nexpectedOut", "actualOutput", "realWin", " ActualIn", "publicOUT", "nexpectedIn", " actualBridge", "actualOUT", "eventOUT", "eventIn", "illegalIn", "operatorout"]}}
{"id1": "14567939", "id2": "22625683", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public static Model downloadModel(String url) {\n        Model model = ModelFactory.createDefaultModel();\n        try {\n            URLConnection connection = new URL(url).openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestProperty(\"Accept\", \"application/rdf+xml, */*;q=.1\");\n                httpConnection.setRequestProperty(\"Accept-Language\", \"en\");\n            }\n            InputStream in = connection.getInputStream();\n            model.read(in, url);\n            in.close();\n            return model;\n        } catch (MalformedURLException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"baseHash": [" generateHash", "basehash", " generateSecret", " chainhash", "BaseFile", "Basehash", "baseFile", "BaseHash", " chainHash", "baseSecret", " generatehash", " chainFile", " chainSecret", " generateFile", "BaseSecret"], "name": ["Name", "names", "resource", "class", "n", "string", "host", "word", "secret", "named", "path", "key", "user", "object", "address", "create", "part", "base", "normal", "hello", "prefix", "definition", "image", "ame", "NAME", "hash", "member", "type", "data", "style", "account", "id", "parent", "alias", "file"], "password": ["pass", "attribute", "paste", "token", "username", "words", "seed", "sword", "string", "word", "secret", "priv", "input", "Password", "PASS", "wallet", "path", "key", "stroke", "auth", "wd", "profile", "device", "prefix", "phrase", "security", "code", "value", "hash", "diff", "data", "account", "pattern", "source", "crypt", "text", "padding"], "digest": ["modest", "Digr", "decEST", "digusher", " diger", "mdest", "decr", "Digester", " digusher", "signest", "Digested", "digr", " digger", "digested", "digester", "decest", "signer", "Digusher", "modester", "modested", "DigEST", " digester", "signusher", " digested", "moder", "signester", "digEST", "Diger", "diger", "Digger", "digger", "mdester", "Digest", "mdr", "mdEST", "decester", "signger"]}}
{"id1": "1169642", "id2": "20267500", "code1": "    @Override\n    public void run() {\n        String key = getKey();\n        synchronized (this.lauchedHTTPRequests) {\n            if (this.lauchedHTTPRequests.contains(key)) return;\n            this.lauchedHTTPRequests.add(key);\n        }\n        String st = this.dataSource.getTileURL(this.x, this.y, this.z);\n        URL url;\n        try {\n            url = new URL(st);\n        } catch (MalformedURLException e1) {\n            logger.warning(\"Error in URL: \" + st);\n            return;\n        }\n        String geoJSON = \"\";\n        try {\n            InputStream is;\n            if (\"file\".equals(url.getProtocol())) is = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) is = url.openStream(); else {\n                logger.warning(\"Impossible to load settings from \" + url + \". Unsupported protocol \" + url.getProtocol());\n                return;\n            }\n            BufferedReader in = new BufferedReader(new InputStreamReader(is));\n            String line;\n            while ((line = in.readLine()) != null) geoJSON += line;\n            in.close();\n        } catch (FileNotFoundException e) {\n            return;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n        VectorTile tile = new VectorTile(geoJSON, x, y, z);\n        Geometry[] geoms = new Geometry[tile.getPieces().size()];\n        int i = 0;\n        for (MfGeo geo : tile.getPieces()) {\n            if (geo.getGeoType() == GeoType.GEOMETRY) {\n                geoms[i++] = ((MfGeometry) geo).getInternalGeometry();\n            } else if (geo.getGeoType() == GeoType.FEATURE) {\n                MfFeature mf = (MfFeature) geo;\n                geoms[i++] = mf.getMfGeometry().getInternalGeometry();\n            }\n        }\n        GeometryCollection gc = new GeometryFactory().createGeometryCollection(geoms);\n        this.dataSource.getDataLoader().add(new OpenCartoFeature(this.dataSource.getLayer(), new Rep(gc), this.z));\n        this.dataSource.getLayer().getDisplayCacheLoader().coin();\n        synchronized (this.lauchedHTTPRequests) {\n            this.lauchedHTTPRequests.remove(key);\n        }\n    }\n", "code2": "    public static AudioInputStream getWavFromURL(String urlstr) {\n        URL url;\n        AudioInputStream ais = null;\n        try {\n            url = new URL(urlstr);\n            URLConnection c = url.openConnection();\n            c.connect();\n            InputStream stream = c.getInputStream();\n            ais = new AudioInputStream(stream, playFormat, AudioSystem.NOT_SPECIFIED);\n            LOG.debug(\"[getWavFromURL]Getting audio from URL: {0}\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return ais;\n    }\n", "label": 0, "substitutes": {"run": [" work", "Run", "execute", "register", "request", "call", " evaluate", " solve", "func", "process", "download", "build", "running", "init", " runs", "exec", "get", "work", "load", "start", "apply", " deploy", "submit", "loop", "update", "sleep"], "key": ["temp", "ry", "use", "Key", "fee", "k", "string", "cache", "y", "request", "secret", "service", "ee", "self", "KEY", "this", "pair", "ke", "ce", "wk", "client", "my", "ie", "play", "rule", "connection", "base", "pe", "prefix", "work", "x", "keys", "link", "code", "e", "cert", "q", "value", "check", "lease", "v", "change", "type", "req", "id", "cy", "parent", "source", "lock", "kid", "ace", "sign", "name"], "st": ["struct", "fe", "fr", "sth", "stri", "u", "est", "string", "rest", "ost", "d", "str", "ist", "pl", "www", "ft", "ST", "inst", "ur", "sc", "pt", "sr", "ste", "bl", "ld", "l", "s", "pe", "sn", "sp", "contract", "ast", "sl", "sb", "sta", "ut", "nd", "start", "St", "std", "se", "sts", "sv", "sd", "tt", "rd", "stream", "ss"], "url": ["resource", "il", "pull", "fr", "use", "stream", "ob", "string", "blog", "host", "href", "request", "http", "tool", "service", "www", "URL", "path", "ll", "log", "ur", "api", "feed", "gl", "layer", "Url", "rl", "impl", "download", "object", "user", "address", "email", "bel", "bug", "loc", "lr", "rel", "build", "l", "connection", "rule", "base", "ls", "event", "server", "config", "sl", "f", "link", "iter", "e", "li", "ul", "el", "image", "page", "ssl", "bb", "secure", "fl", "null", "id", "web", "uri", "source", "buffer", "file"], "geoJSON": ["geometryPackage", " geoURL", "geoPackage", " geometryJ", "cheoString", "gameometryZip", "geyoURL", "geoURL", "gepoJ", "gepoURL", "geyoJSON", "gameoURL", "geographicJSON", "geoJ", " geometryJSON", "cheoURL", "geoZip", " geometryURL", "geographicURL", "gameoJSON", "gameometryJSON", "gameometryString", "geoString", "geographicPackage", "gameoString", "geometryJSON", "geographicString", "cheographicString", "cheoPackage", "cheographicJSON", "geometryString", "geyoInfo", "geometryZip", "gameometryURL", " geoInfo", "geoaZip", " geoJ", "gameoZip", "geoInfo", "geometryJ", "geometryURL", "cheographicURL", "gepoJSON", "geographicZip", "geoaURL", "geoaString", "cheographicPackage", "gepoInfo", "geyoJ", "geoaPackage", "geometryInfo", "geoaJSON", "cheoJSON", " geometryInfo"], "is": ["ib", "il", "or", "us", "ip", "isa", "ios", "im", "serv", "isl", "ir", "iz", "has", "as", "api", "ais", "abs", "os", "IS", "ui", "ins", "ri", "ie", "it", "p", "l", "s", "Is", "out", "iss", "ar", "get", "iso", "x", "its", "index", "isi", "isc", "bis", "mis", "lis", "ai", "r", "id", "iv", "uri", "stream", "info", "ris"], "in": ["correct", "In", "again", "serv", "ini", "IN", "reading", "loading", "ex", "din", "inner", "bin", "with", "input", "ic", "as", "io", "open", "from", "pin", "ins", "download", "on", "getting", "ri", "inn", "min", "p", "it", "kin", " In", "l", "isin", "init", "s", "rin", "lin", "out", "trans", "ar", "get", "load", "x", "read", "err", "adding", "f", "working", "e", "per", "iter", "by", "nin", "finding", "el", "h", "arin", "login", "reader", "data", "parse", "r", "b", "inc", "update", "stream", "create"], "line": ["inline", "look", "entry", "row", "pass", "zip", "string", "lines", "LINE", "ine", "str", "character", "le", "Line", "ge", "log", "char", "number", "pin", "object", "no", "me", "letter", "cr", "frame", "l", "part", "profile", "cl", "up", "lin", "pe", "cell", "sl", "link", "e", "code", "li", "el", "record", "val", "lo", "page", "ne", "data", "parse", "style", "r", "id", "lf", "source", "text", "block", "name", "file", "lc", "end"], "tile": ["fe", "pie", "class", "project", "stone", "map", "ilo", "te", "fill", "pixel", "fo", "tool", "cover", "surface", "ge", "layer", "shape", "texture", "match", "crop", "fit", "cf", "zone", "xy", "coord", "league", "square", "face", "grid", "profile", "scale", "tle", "pe", "model", "future", "server", "game", "size", "f", "flat", "lat", "e", "figure", "feature", "image", "Tile", "lore", "type", "pole", "t", "info", "plane", "artist", "collection", "file", "edge"], "geoms": ["teoms", "nelas", " geomes", "geodes", "GElements", "neometry", " geometry", "geometry", "geomes", "Geomes", "gelas", "GEometry", "Geodes", "neomes", "teodes", "nelements", "neoms", " geodes", "neodes", "Geoms", "eoms", "telements", "teometry", "Gelas", "gelements", "Geometry", "elas", "GEodes", "eometry", "eomes", "GEoms"], "i": ["hi", "si", "qi", "u", "multi", "n", "ii", "c", "pi", "o", "y", "shift", "limit", "d", "inner", "ci", "di", "io", "z", "slice", "ui", "ri", "bi", "p", "init", "phi", "j", "I", "fi", "x", "eni", "index", "f", "e", "li", "gi", "mini", "ti", "ai", "zi", "xi", "b", "id", "info", "uri"], "geo": ["teom", "gespo", "geso", "gateographic", "gesom", "sebo", "neometry", " geometry", "zeo", "geometry", "gepo", "zeou", "seom", "gaographic", "neou", "teoco", " toppo", "aleou", "gateometry", "GEometry", "geou", "Geom", " gepo", "GEo", "Geolo", " geon", "Geoco", "geom", " geom", "Geographic", "teometry", "geson", "GEou", " geou", "gebo", "teo", "gateolo", "zeometry", "geon", "geographic", "gaolo", " topon", "geolo", "seo", "gao", "Geometry", "aleo", "seoco", "alebo", "GEbo", "neo", "seometry", " topo", "gaometry", "aleometry", "nepo", "geoco", "zepo", " topom", "gateo", "Geo", "seou"], "mf": ["Mcf", "pc", "Mf", "mfa", "pfs", "Mfa", "imf", "mcf", "mfi", "rfs", "mfs", "imcf", " mfa", "Mfi", " mfi", "mc", "rc", "ptf", "smfs", " mcf", "mtf", "smtf", "rtf", "smf", "smc", "pf", "imfa", "imfi", "rf"], "gc": ["gg", "pc", " rc", "gp", "GB", "gs", "xc", "co", "ct", "gr", " ic", "GC", "cc", "cl", "gb", "ls", "ga", " bc", "cs", "bc", "gt", "gd", "vg", "gi", " GC", " dc", " ac", "collection", " cc"]}}
{"id1": "16804988", "id2": "20939940", "code1": "    public void init() {\n        String filename = getParameter(\"filename\");\n        if (filename == null) {\n            Error(\"Illegal filename\");\n            return;\n        }\n        Dimension dim = DEFAULT_SIZE;\n        try {\n            int w = Integer.parseInt(getParameter(\"width\"));\n            int h = Integer.parseInt(getParameter(\"height\"));\n            dim = new Dimension(w, h);\n        } catch (Exception e) {\n        }\n        InputStream in;\n        try {\n            File ff = new File(filename);\n            in = new FileInputStream(ff);\n        } catch (Exception ignore) {\n            try {\n                URL url = new URL(filename);\n                in = url.openStream();\n            } catch (Exception e) {\n                Error(\"Graph viewer: Failed to open: \" + filename + \"\\n\" + e);\n                return;\n            }\n        }\n        getContentPane().add(getWindow(in));\n        resize(dim);\n        repaint();\n    }\n", "code2": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "label": 0, "substitutes": {"init": ["ize", "Initialized", "draw", "Init", " initialized", "initial", " initialization", "activate", "construct", "build", "it", "setup", "layout", "show", "load", " startup", "config", "image", "start", " Init", "format", "close", "parse", "info", "update", "launch", "create"], "filename": ["folder", "il", "txt", "online", "username", "fax", "n", "string", "SourceFile", "utf", "jpg", "word", "sf", "title", "Filename", "path", "kn", "params", "fd", "fil", "files", "database", "ppa", "length", "download", "content", "fn", "loc", "l", "prefix", "ename", "phrase", "location", "upload", "config", "size", "license", "loader", "f", "doi", "dll", "password", "journal", "fp", "nil", "directory", "ssl", "metadata", "kl", "uri", "binary", "name", "which", "file"], "dim": ["span", "Dim", "sam", "si", "wid", "project", "im", "g", "multi", "cm", "m", "dat", "ims", "py", "spec", "d", " Dim", "dist", "marg", "shape", "di", "param", "slice", "imm", "num", "div", "min", "iframe", "dimension", " reim", "p", "part", "scale", "mod", "width", "dr", "fi", "config", "size", "fac", "thin", "index", "du", "fm", "lim", "gm", "image", "dom", "format", "dm", "val", "ext", "img", "diff", "dem", "mi", "info", "grad", "wm", "grid"], "w": ["wh", "wt", "u", "n", "c", "height", "m", "k", "o", "y", "d", "z", "wa", "ew", "wd", "weight", "p", "l", "s", "fw", "sw", "win", "max", "x", "f", "hw", "e", "rw", "i", "q", "a", "v", "W", "r", "b", "en", "t", "width", "ow"], "h": ["hs", "bh", "sh", "u", "height", "n", "th", "c", "k", "uh", "y", "o", "rh", "d", "oh", "H", "hm", "z", "ih", "ht", "hd", "kh", "p", "ha", "l", "ph", "s", "j", "x", "ah", "f", "e", "q", "v", "hr", "b", "en", "t", "gh"], "in": ["resource", "In", "fe", "fc", "again", "serv", "ini", "n", "IN", "is", "din", "bin", "input", "as", "io", "pin", "ins", "cf", "impl", "ac", "conn", "min", "inn", "err", "kin", "cl", "l", "connection", "win", "out", "gin", "fac", "read", "cgi", "f", "i", "nin", "el", "lib", "socket", "fp", "login", "ssl", "reader", "amin", "data", "ax", "r", "b", "fb", "inc", "id", "source", "stream", "src", "file"], "ff": ["df", "fe", "fff", "fc", "cmp", "library", "sf", "xff", "fx", "aff", "fd", "ctx", "feed", "FF", "buf", "cf", "pp", "ef", "ulp", "ouf", "iff", "ffe", "f", "af", "uf", "fed", "eff", "cb", "fp", "bb", "fl", "fb", "bf", "buff", "lf", "back", "file"], "url": ["resource", "fr", "ob", "zip", "string", "sf", "http", "www", "URL", "path", "ll", "io", "open", "feed", "Url", "download", "l", "connection", "base", "ls", "server", "sl", "f", "e", "image", "fp", "ssl", "fl", "b", "fb", "web", "uri", "stream", "source", "src", "file"]}}
{"id1": "22536033", "id2": "7911686", "code1": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"setPayload": ["setMessageContent", "setRawload", "setWorkLoad", "setRawloads", "parsePayload", "setPayLoad", "parsePayloads", "setShipContent", "setRawLoad", "setPayloads", "setShipload", " setPayloads", "setMessageloads", "parseShiploads", "setWorkContent", "setPayContent", "setShiploads", "setWorkload", "parsePayContent", "parseShipLoad", "parsePayLoad", "setRawContent", "parseShipload", " setPayLoad", "parseShipContent", "setWorkloads", "setShipLoad", " setPayContent", "setMessageLoad", "setMessageload"], "fos": [" fics", "cfics", "Foc", "bos", "fics", "cfoc", "bics", "boc", "Fis", "cfis", "Fos", "bis", "Fics", "cfos"], "fis": ["fib", "fIS", "eic", " fics", "eoc", "eis", "eIS", "Foc", "fics", "forib", "Fic", "FIS", "foris", " fIS", " fib", "Fis", "foric", "Fib", "Fics", "forics"], "fic": ["fci", " fics", " fac", "cfics", "ufik", "cfirc", "Fci", " firc", "Firc", "firc", "elfics", "Foc", "ufos", "fics", "fik", "Fic", "cfoc", "fac", "elfik", "elfic", "cfic", "Fac", "elfci", " fik", "ufoc", "infci", "Fos", "infik", "infics", "Fics", "ufic", "Fik", "cfac", "infic"], "foc": ["infac", "Focol", "focol", "Foca", "troc", " fac", " fisc", "infocol", "Froc", "focon", "infos", " focon", "fisc", "Foc", " froc", " focol", "tic", "Fic", " foca", "fac", "toca", "infocon", "Fac", "infoc", "Fos", "froc", "infisc", "foca", "Focon", "toc", "infic", "Fisc"], "Index": ["Dim", " index", "Found", "Key", "Number", "Link", "Start", "Depth", "Connection", "Position", "Address", "Path", "Loop", "Entry", "Level", "Code", "Weight", "Len", "Length", "Stage", "Count", "Array", "ID", "Width", "Exp", "Pull", "Version", "Offset", "Url", "Counter", "Order", "Num", "Insert", "First", "Header", "Body", "Location", "Loc", "I", "X", "Mass", "Interest", "x", "Content", "index", "Page", "Input", "Value", "Instance", "Section", "Element", "Flag", "Size", "Rank", "Inf", "Client", "Label", "Row", "Pos"]}}
{"id1": "10281203", "id2": "20685385", "code1": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    private Long getNextPkValueForEntityIncreaseBy(String entityName, int count, int increasePkBy) {\n        if (increasePkBy < 1) increasePkBy = 1;\n        String where = \"where eoentity_name = '\" + entityName + \"'\";\n        if (false) {\n            EOEditingContext ec = ERXEC.newEditingContext();\n            ec.lock();\n            try {\n                EODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed((EOObjectStoreCoordinator) ec.rootObjectStore(), entityName);\n                dbc.lock();\n                try {\n                    EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n                    EOAdaptorChannel channel = (EOAdaptorChannel) dbc.adaptorContext().channels().lastObject();\n                    NSArray result = channel.primaryKeysForNewRowsWithEntity(increasePkBy, entity);\n                    return (Long) ((NSDictionary) result.lastObject()).allValues().lastObject();\n                } finally {\n                    dbc.unlock();\n                }\n            } finally {\n                ec.unlock();\n            }\n        } else {\n            ERXJDBCConnectionBroker broker = ERXJDBCConnectionBroker.connectionBrokerForEntityNamed(entityName);\n            Connection con = broker.getConnection();\n            try {\n                try {\n                    con.setAutoCommit(false);\n                    con.setReadOnly(false);\n                } catch (SQLException e) {\n                    log.error(e, e);\n                }\n                for (int tries = 0; tries < count; tries++) {\n                    try {\n                        ResultSet resultSet = con.createStatement().executeQuery(\"select pk_value from pk_table \" + where);\n                        con.commit();\n                        boolean hasNext = resultSet.next();\n                        long pk = 1;\n                        if (hasNext) {\n                            pk = resultSet.getLong(\"pk_value\");\n                            con.createStatement().executeUpdate(\"update pk_table set pk_value = \" + (pk + increasePkBy) + \" \" + where);\n                        } else {\n                            pk = maxIdFromTable(entityName);\n                            con.createStatement().executeUpdate(\"insert into pk_table (eoentity_name, pk_value) values ('\" + entityName + \"', \" + (pk + increasePkBy) + \")\");\n                        }\n                        con.commit();\n                        return new Long(pk);\n                    } catch (SQLException ex) {\n                        String s = ex.getMessage().toLowerCase();\n                        boolean creationError = (s.indexOf(\"error code 116\") != -1);\n                        creationError |= (s.indexOf(\"pk_table\") != -1 && s.indexOf(\"does not exist\") != -1);\n                        creationError |= s.indexOf(\"ora-00942\") != -1;\n                        if (creationError) {\n                            try {\n                                con.rollback();\n                                log.info(\"creating pk table\");\n                                con.createStatement().executeUpdate(\"create table pk_table (eoentity_name varchar(100) not null, pk_value integer)\");\n                                con.createStatement().executeUpdate(\"alter table pk_table add primary key (eoentity_name)\");\n                                con.commit();\n                            } catch (SQLException ee) {\n                                throw new NSForwardException(ee, \"could not create pk table\");\n                            }\n                        } else {\n                            throw new NSForwardException(ex, \"Error fetching PK\");\n                        }\n                    }\n                }\n            } finally {\n                broker.freeConnection(con);\n            }\n        }\n        throw new IllegalStateException(\"Couldn't get PK\");\n    }\n", "label": 1, "substitutes": {"makeRead": [" makeREAD", " executeWrite", "doREAD", "doRead", " makeWrite", " manageSet", " executeSet", "doWrite", " manageWrite", " executeREAD", " executeRead", "doSet", " makeSet", " manageRead", " manageREAD"], "user": ["row", "use", "username", "owner", "blog", "string", "host", "site", "word", "comment", "pid", "uid", "log", "post", "custom", "creator", "bug", "USER", "month", "install", "nick", "server", "url", "usr", "date", "field", "admin", "password", "User", "home", "record", "author", "write", "pod", "human", "job", "users", "alias", "name"], "databaseID": ["databaseIDS", "connectionIDs", " databaseName", "connectionName", "dbName", " databaseIDs", "collectionId", "DatabaseName", "collectionName", " databaseIDS", "collectionID", "connectionID", "DatabaseID", "databaseName", "collectionIDS", "DatabaseIDS", "dbIDs", "DatabaseId", " databaseId", "dbID", "databaseIDs", "databaseId"], "time": ["timeout", "etime", "ip", "times", "string", "host", "table", "comment", "money", "delay", "year", "key", "post", "length", "Time", "mode", "tz", "month", "rate", "port", "clock", "size", "read", "date", "TIME", "value", "set", "home", "start", "tim", "counter", "ime", "type", "duration", "id", "timer", "sleep", "name", "end"], "query": ["function", "scan", "string", "join", "execute", "request", "call", "Query", "select", "script", "comment", "condition", "report", "answer", "params", "search", "post", "database", "json", "sql", "conn", "command", "rule", "connection", "cmd", "work", "commit", "code", "q", "result", "error", "question", "ql", "eries", "message", "general", "update", "uri", "name", "sq"], "statement": ["slave", "status", "si", "media", "study", "section", "function", "use", "join", "note", "instance", "execute", "volume", "table", "expression", "str", "comment", "script", "language", "state", "condition", "response", "inst", "di", "jo", "database", "relation", "sql", "conn", "unit", "command", "rule", "connection", "document", "s", "part", "agent", "storage", "server", "commit", "ma", "session", "usage", "i", "password", "start", "stat", "result", "joined", "st", "Statement", "style", "parser", "message", "general", "mt", "alias", "db"], "count": ["c", "cache", "table", "depth", "limit", "total", "state", "sum", "Count", "key", "force", "number", "list", "process", "length", "child", "age", "err", "batch", "part", "base", "cond", "expected", "find", "get", "size", "index", "code", "i", "set", "by", "start", "handle", "diff", "error", "type", "found", "id", "inc", "offset"]}}
{"id1": "15737836", "id2": "23531898", "code1": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 1, "substitutes": {"delete": [" destroy", " create", "Delete", "execute", "select", "remove", "destroy", " update", "process", "sync", "sql", " Delete", "clear", "del", "replace", "drop", "release", "exec", "get", "where", "close", "save", "write", "de", "id", "update", "connect", "create"], "site": ["item", "status", "class", "si", "section", "line", "project", " Site", "blog", "cache", "environment", "note", "sites", "xml", "node", "network", "sync", "database", "zone", "sql", "object", "conn", "Site", "theme", "unit", "isite", "sample", "profile", "base", "domain", "model", "install", "server", "location", "config", "license", "ite", "session", "space", "set", "image", "remote", "page", "result", "se", "data", "type", "null", "target", "module", "plugin", "course", "sit", "source", "name", "db", "edge"], "dbo": ["idebo", "gBo", "jBo", "gbo", "idbo", "Dbl", "drbi", "rdbo", "idebl", "pbo", "fBo", "pba", "dbi", "dba", "fbo", "DBO", "dho", "dbos", " dBo", "jba", "jbo", "DBo", "rdBo", "Dbo", "pBO", " dbc", "dBo", "pBo", "Dho", " dBO", "dbl", "Dbos", "idho", "fba", "rdbc", "drBo", "jBO", "dbc", "rdbi", " dbi", "ideho", "drbo", "fBO", "Dba", "gbos", "idbl", "ideBo", " dbos", "drbc", "idBo", "dBO", "gBO", " dba"], "connection": ["resource", "application", "subject", "section", "container", "use", "library", "function", "position", "c", "Connection", "cache", "environment", "context", "statement", "union", "table", "management", "instance", "channel", "character", "condition", "response", "node", "ion", "ci", "con", "ctx", "manager", "engine", "log", "io", "driver", "database", "relation", "client", "sql", "conn", "creator", "translation", "unit", "loc", "handler", "document", "communication", "builder", "server", "component", "query", "config", "bc", "index", "pool", "machine", "session", "graph", "image", "ongo", "result", "directory", "connected", "lock", "connect", "collection", "db", "reference"], "preparedStatement": ["preparedDatabase", "preppedString", "previsedQuery", "preparedHeader", "PrearedParent", "preppedStatement", "preculatedStatement", "previsedStat", "PrearedString", "preparedQuery", "previousStatement", "prearedComment", "prefixedQuery", "previousConnection", "preparedString", "previousDocument", "prearedStat", "prequalifiedstatement", "eparedstatement", "preplacedStatement", "preparedScope", "pseparedStatement", "pseparedQuery", "preplacedStat", "prelyingComment", "preutedOperation", "PreparedQuery", "preamedParent", "prearedTransaction", "preplacedComment", "proparableStat", "calyingComment", "caparedComment", "prearedString", "prefixedHeader", "eculatedTransaction", "partvisedComment", "partparedStat", "PrearedComment", "proparedInstance", "preparedstatement", "PrearedOperation", "pseparedScope", "prefixedStatement", "PreparedConnection", "prefixedComment", "proparedstatement", "preferredComment", "prearedQuery", "prearedScope", "prearedInstance", "PreparedTransaction", "proparablestatement", "previousTransaction", "preachedString", "psefixedStatement", "PreparedHeader", "preparedParent", "eculatedConfiguration", "partvisedStat", "eculatedstatement", "preferredString", "preformedstatement", "PreppedConnection", "preachedStatement", "preciseStatement", "proparableStatement", "preformedDatabase", "PreparedDocument", "proparedStatement", "preparedOperation", "preplacedQuery", "PreppedTransaction", "preparablestatement", "preppedQuery", "prearedStatement", "eculatedStatement", "prefixedOperation", "previsedComment", "preculatedTransaction", "previousstatement", "prepperTransaction", "prearedService", "partparedQuery", "partparedStatement", "PrearedDatabase", "PrearedStatement", "eparedConfiguration", "preparableInstance", "preparedConnection", "PrearedQuery", "prelyingStatement", "preciseString", "caparedStatement", "proparableInstance", "PrearedHeader", "calyingstatement", "PreparedStat", "preparedConfiguration", "preutedStatement", "PreppedStatement", "PreppedDocument", "preparedStat", "calyingTransaction", "preppedDocument", "prepperConnection", "preparedInstance", "PreparedDatabase", "preamedStat", "prequalifiedStatement", "preferredStatement", "PreparedParent", "proparedStat", "preparedTransaction", "preamedStatement", "previsedStatement", "PreparedService", "preciseStat", "caparedTransaction", "prehedScope", "caparedstatement", "pseparedComment", "prehedQuery", "preutedQuery", "partvisedStatement", "prehedStatement", "preparableStat", "prearedOperation", "eparedStatement", "preparableStatement", "preformedConfiguration", "prefixedScope", "partparedComment", "prearedHeader", "calyingStatement", "prearedDatabase", "prequalifiedInstance", "prearedParent", "prelyingTransaction", "preculatedstatement", "psefixedComment", "prearedstatement", "eparedTransaction", "psefixedQuery", "PrearedStat", "prelyingstatement", "prepperDocument", "preformedString", "previousComment", "preppedTransaction", "preamedString", "prequalifiedStat", "preculatedConfiguration", "PreparedString", "preformedService", "preciseParent", "prepperStatement", "preppedComment", "preachedService", "PreparedStatement", "preformedStatement", "preparedComment", "preformedTransaction", "preachedDatabase", "partvisedQuery", "PreparedComment", "prearedConfiguration", "preppedConnection", "psefixedScope", "PreparedOperation", "preutedHeader", "prehedComment", "preparedDocument", "preparedService", "PrearedService", "preferredQuery"], "resultSet": ["rowSet", "resultGet", "responseLine", "ResultList", "resultsLine", "responseSource", "resultsList", "ResultLine", "resultsSet", "resultLine", "responseList", "responseSet", "resultList", "rowGet", " resultGet", "ResultSize", "rowSize", " resultSize", "resultSource", " resultList", "rowSource", "resultSize", "resultsSource", " resultSource", "ResultSource", " resultLine", "ResultGet", "ResultSet"], "chkSql": ["chkPsql", "chkSsql", "chksSsql", "chkRsql", "chkAssql", "chkSQL", "chksAsql", "chKSsl", "chksAssql", "chkOsq", "chkRsq", "chksSq", "chkAsQL", "chkRssl", "chkPssl", "chkPresq", "chkRssql", "chkPresQL", "chkPssql", "chkSsl", "chksSQL", "chkPresql", "chksAsq", "chksAsQL", "chksSql", "chKSql", "chKRssql", "chkOssl", "chkPsq", "chKRsql", "chkAsql", "chkSq", "chKSq", "chkOsql", "chKRsq", "chKSsql", "chkOssql", "chkAsq", "chKRssl", "chkPressql", "chkOsQL"], "selfDefinePath": ["selfDefenLocation", "selfDefinesUrl", "selfDeclinedpath", "selfDefineLocation", "selfDefinespath", "selfDefinedLocation", "selfDeclinedKey", "selfDefinepath", "selfDefiningPath", "selfDefinedUrl", "selfDeclinedPath", "selfDeclinedUrl", "selfDefineKey", "selfDeclineKey", "selfDefinedName", "selfDefinesKey", "selfDefinedPath", "selfDefiningpath", "selfDefiningUrl", "selfDefinedKey", "selfDefinedpath", "selfDefineUrl", "selfDefenPath", "selfDefiningKey", "selfDefenpath", "selfDefinesLocation", "selfDeclineUrl", "selfDefinesPath", "selfDefinesName", "selfDeclinepath", "selfDeclinePath", "selfDefineName", "selfDefenName"], "sqlStr": ["querystr", "queryStr", "SQLWr", "qlString", "SQLBr", "qlBr", " sqlText", " sqlWr", " sqlDec", "SQLText", "queryDec", " sqlstr", "sqlDec", "sqlString", "SQLStr", "sqlBr", "sqlText", " sqlBr", "sqlstr", "queryText", "qlStr", "SQLString", "SQLstr", " sqlString", "qlWr", "sqlWr", "SQLDec"]}}
{"id1": "324679", "id2": "17029388", "code1": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "code2": "    public static InputStream getConfigIs(String path, String name) throws ProgrammerException, DesignerException, UserException {\n        InputStream is = null;\n        try {\n            URL url = getConfigResource(new MonadUri(path).append(name));\n            if (url != null) {\n                is = url.openStream();\n            }\n        } catch (IOException e) {\n            throw new ProgrammerException(e);\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"import_hints": ["import2shint", "import2hint", "import_vints", "import_pint", "import_shint", "import_pins", "import2shits", "import_shints", "import2shints", "import2hins", "import2hits", "import_vint", "import_vits", "import_hins", "import_pints", "import_hint", "import2shins", "import_shits", "import_shins", "import_vins", "import_pits", "import2hints", "import_hits"], "filename": ["File", "il", "txt", "username", "SourceFile", "string", "href", "utf", "sf", "title", "Filename", "path", "kn", "params", "fil", "sheet", "files", "json", "database", "length", "download", "rl", "fn", "that", "document", "prefix", "phrase", "location", "f", "FILE", "dll", "figure", "fp", "login", "nil", "directory", "metadata", "kl", "wl", "uri", "source", "name", "which", "file"], "pieceId": [" pieceid", "quoteID", "pieceName", "pieceid", "pieceCount", "caseid", "ieceID", "caseId", "quoteName", "pageid", "caseName", "blockId", "pieID", "pocketId", "componentId", "pieid", "towerid", "componentType", "blockid", "towerId", "towerID", "pageId", "caseID", "blockID", "pieceType", "pocketid", "componentID", " pieceType", "componentid", " pieceCount", "pieceID", "pocketID", "ieceid", "ieceCount", "pieId", "towerName", "pageID", "quoteid", "pageType", "blockName", "quoteId", "componentCount", " pieceName", "ieceId", " pieceID"], "i": ["iu", "hi", "si", "qi", "chi", "line", "ip", "u", "multi", "ini", "ii", "c", "pi", "is", "ci", "di", "io", "key", "slice", "ui", "ji", "ri", "bi", "loc", "ie", "p", "it", "l", "phi", "j", "I", "eni", "x", "fi", "index", "f", "oi", "li", "ori", "start", "ni", "gi", "ti", "mi", "ai", "zi", "xi", "id", "info", "uri", "uni", "end"], "col": ["foot", "ch", "cor", "group", "fc", "section", "cat", "c", "channel", "view", "separ", "pixel", "Col", "character", "core", "year", "con", "co", "flo", "ct", "num", "length", "count", "loc", "cl", "month", "win", "COL", "cell", "collection", "pos", "coll", "width", "cur", "x", "left", "index", "field", "cal", "cel", "inc", "cy", "offset", "city", "block", "column", "keep", "lc"], "row": ["group", "ry", "line", "grow", "height", "position", "step", "hour", "view", "wheel", "right", "year", "ner", "key", "slice", "stroke", "num", "length", "our", "tr", "roll", "loc", "rel", "ro", "month", "order", "w", "cell", "rc", "pos", "coll", "cur", "x", "index", "page", "range", "rr", "r", "offset", "round", "block", "column", "Row", "ow", "rows"], "rotation": ["orientation", " rototation", "colating", "colation", "Rototation", "polate", "rotating", "polation", "coloration", " rotate", "poloration", "rotoration", "relation", "orientotation", "polotation", "Rotate", " rotion", "colate", "rotion", "orientate", " rotating", " rotoration", "polion", "Rotoration", "Rotion", "Rotation", "Rotating", "rotate", "rototation", "orientoration", "relating", "relate", "polating", "reloration"], "number": ["resource", "span", "section", "line", "Number", "amount", "position", "n", "string", "zero", "note", "step", "version", "total", "area", "language", "layer", "outer", "shape", "year", "maximum", "phone", "ner", "none", "nn", "network", "division", "key", "num", "length", "no", "object", "letter", "unit", "book", "part", "umber", "work", "x", "size", "non", "other", "code", "numbered", "resolution", "counter", "page", "change", "type", "null", "message", "source", "name", "width", "reference"], "temppiece": ["temppeawn", "temspiece", "memppedrice", "typpaint", "timphrice", "templiece", "timppiece", "typtacket", "templart", "temprice", "templaint", "temptaint", "temphell", "temspacket", "temppruit", "temppedawn", "memppedoint", "memppediece", "typpiece", "typtence", "temppedrice", "typtaint", "timppart", "temppedell", "temspaint", "tempplruit", "tempiece", "templrice", " temppore", "tempppruit", "tempopiece", " tempore", "typtiece", " tempppiece", "timphart", "typpacket", "tempoiece", "temppell", "timppoint", "temppedruit", "temppacket", "tempppiece", "timpprice", "memppiece", "memppedell", "templruit", "templore", "tempoore", "temphrice", "temppart", "temporice", "tempooint", "temppliece", "temptence", "tempplrice", "timphiece", "memppell", "temppaint", "temppence", "tempperice", " tempiece", "tempore", " tempprice", "templence", "tempperuit", "templell", "temppprice", "temppediece", "temppawn", "temppore", "tempplawn", "memppoint", "templacket", "templawn", "tempppawn", "temppeiece", "temphiece", "temptiece", "timphoint", "mempprice", "temphart", "temppedoint", "temphoint", "temptacket", "typpence", "temppoint", "tempoart", "tempprice", "temspence", "templpiece", " temprice", "temploint"], "lineread": ["rowwrite", "linewrite", "rowreader", "leload", "linwrite", "leRead", "linbreak", "fileread", "LINEreader", " linebreak", "linedata", "blockread", "lineRead", "Lineread", "linload", "rowload", " lineRead", "lineload", "rowbreak", "linRead", "lindata", "filereader", " linedata", "rowkey", "linereader", "blockwrite", "linreader", "leread", " linewrite", "linekey", "Linedata", "Linebreak", "rowread", "blockreader", "blockbreak", "Linereader", "linkey", " lineload", "LINEread", " linereader", "Linewrite", "filebreak", "blockload", "linread", "LINERead", "linebreak", "filekey", "ledata"], "tok": ["toker", "utunk", "otak", "itorp", "toko", "ttoke", "toolract", "otoken", "untoker", "Tock", "tunk", "utang", "untang", "utorp", "atik", "ttore", "Toca", "taken", "otok", "ttoca", " taken", "theore", "protok", "ttock", "etoko", "untoken", "torp", "ttoks", "tik", "Tak", "toll", "ttok", "Toks", "utoker", " tik", "ttak", "antok", "itoker", "itunk", " toko", "took", "tract", "ataken", "protoke", " toks", "ttik", "utoken", "itook", "theaken", "toks", "otook", "Tok", "utok", "utook", "Token", "toolok", "tooloke", "theok", "tore", "otorp", "antract", "artoll", "artoke", "itang", "tang", "untok", "theoke", "toololl", "etract", "ttaken", "artract", "toca", "ttoko", "artok", "protore", "atok", "tak", " tak", " tract", " tock", "etaken", "antoll", "token", "antoke", "itoken", "etok", "itok", "otoca", "ttract", "atoks", "ttoken", "toke", "protaken", "otunk", "tock"], "entree": ["entode", "entrie", "ntree", "nttree", "etreen", "entrue", "settrue", "artee", "Entree", "antrue", "Enttree", "artree", "ntreen", "entrain", " entrain", "settrees", "antode", "entreen", "antree", "etee", "artrie", "etrie", " entrie", "artreen", "ntrain", "enttree", "entrees", "entlock", "ntrie", "antrees", "ettree", "etrain", "Entrain", "Entrees", "entee", "Entode", "Entrie", "Entlock", "ntlock", " entlock", "settree", "ntee", "Entrue", "settode", "etree", "Entee"], "byurl": ["orurl", "viaURL", "Bystr", "byfile", "Byfile", "ByURL", "Byurl", "orfile", "byURL", " byURL", "orURL", "viaurl", "viastr", "bystr", " bystr", "orstr", " byfile", "viafile"], "url": ["resource", "pull", "fr", "stream", "ob", "string", "blog", "http", "www", "URL", "log", "ll", "ur", "open", "feed", "gl", "key", "Url", "user", "bel", "browser", "l", "connection", "base", "ls", "server", "plug", "loader", "sl", "f", "link", "hub", "ul", "image", "page", "ssl", "id", "web", "uri", "source", "update", "file"], "in": ["resource", "In", "fr", "fc", "serv", "n", "c", "ini", "IN", "is", "din", "inner", "bin", "input", "as", "con", "ins", "ac", "inn", "err", "part", "win", "out", "ar", "gin", "f", "a", "image", "socket", "login", "reader", "data", "r", "b", "inc", "source", "stream", "client", "body", "file"]}}
{"id1": "6966398", "id2": "6009527", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"reader": ["resource", "df", "or", "row", "reads", "ry", "k", "instance", "context", "o", "reading", "rake", "oder", "ler", "raf", "input", "cer", "manager", "io", "ner", "feed", "driver", "cms", "ri", "client", "pp", "keeper", "er", "handler", "book", "p", "connection", "rc", "pe", "server", "load", "dr", "config", "loader", "read", "Reader", "iter", "per", "rw", "her", "writer", "se", "rr", "r", "parser", "rar", "source", "stream", "buffer", "builder", "file"], "ks": ["ics", "acts", "akes", "reads", "kes", "hs", "KS", "ms", "books", "bs", "k", "opens", "ko", "checks", "gets", "orks", "ctx", "co", "ke", "powers", "acs", "fs", "qs", "ki", "ans", "ls", "inks", "acks", "cks", "vs", "ops", "ches", "keys", "icks", "cs", "ns", "ds", "ku", "CS", "kb", "ges", "ips", "sk", "se", "ps", "DS", "es", "rs", "works", "ck", "kies", "ss", "rows"], "key": ["Key", "seed", "k", "c", "cache", "pg", "ca", "secret", "ee", "service", "state", "io", "co", "char", "pair", "ke", "ce", "ring", "trust", "user", "p", "base", "ki", "court", "pe", "server", "keys", "read", "code", "value", "transfer", "ssl", "type", "point", "sign", "lock", "client", "file"], "chain": ["wrap", "root", "container", "c", "cache", "chains", "table", "wheel", "secret", "circle", "family", "path", "sequence", "box", "network", "list", "none", "slice", "pair", "object", "store", "cr", "rule", "mc", "scale", "base", "coll", "Chain", "config", "enc", "code", "set", "image", "range", "stack", "lock", "crypt", "block", "collection", "file"], "os": ["rss", "ms", "ol", "ios", "ob", "osi", "oid", "op", "o", "opens", "is", " o", "oss", "options", "io", "outs", "aos", "object", "bos", " bos", "p", "fs", "s", "pos", "los", "iso", "ops", "cos", "ot", "Os", "ds", "oses", "ros", "res", "ou", "ps", "es", "rs", "OS"], "stamper": ["starmple", "spampe", "function", " nostameple", "g", "spamper", " nostamler", "streampe", "stammper", "stAMper", "spammer", "path", "spAMpe", "stAMmer", "stampper", "stammple", "this", " nostamepper", "starmper", "stammpe", "starmpper", " nostamper", " nostameper", "stammmer", "s", "stAMpe", "stampe", "streammer", "stameple", "streamper", "spamler", "stamler", "spAMler", "stameler", "_", "stample", "starmler", "stammler", "stammer", "stammpper", "stamepper", "stAMler", "stameper", "data", " nostample", "streamler", " nostameler", " nostampper", "spAMper", "spAMmer"], "appearance": ["ppearance", "attfacing", "installear", "appasion", " appears", "ppearing", "suppearing", "byearance", "feedearance", "feedointment", "formismo", "atteared", "formearing", "appfacing", "askence", "appence", " appfacing", "appearing", "suppearance", "appismo", "ppaser", "signearing", "appointment", "attence", "feedfacing", "suppfacing", "byismo", "askeared", "feedear", " appeared", "Appearance", "signfacing", "ppear", "signear", "byearing", "suppasion", "signearance", "askearance", "installearing", "Appears", "formaser", " applier", "appears", "signointment", "askfacing", "formear", "byear", "installearance", "appear", "ppasion", "signears", "signlier", "attearance", "suppointment", "applier", "Appearing", " appence", "appaser", " appear", " appearing", " appaser", "formearance", " appismo", "installasion", "Applier", "suppear", "appeared"]}}
{"id1": "300397", "id2": "1188100", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "1357662", "id2": "9347451", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copyChannelFile", " copyfileTO", " copyFileFile", "copyChannelFrom", "copyfileTo", "copyFileTO", " copyFileTO", " copyfileFrom", "copyfileTO", "copyfileFrom", "copyFilesFile", "copyChannelTo", "copyFilesTO", "copyFileFile", "copyFileFrom", "copyChannelTO", " copyfileTo", "copyfileFile", "copyFilesFrom", " copyfileFile", "copyFilesTo", " copyFileFrom"], "destination": ["destinations", " Destination", "distined", " destinator", "configinations", " destribution", "distinations", "destribution", "sourceinations", "Destinations", "destinator", "Destined", "destined", "separinator", " Destribution", "distruction", "configinated", " destined", "Destinator", "Destination", "targetruction", "destinated", "sourceinated", "destinate", "distinate", "targetinations", "targetinate", " Destinator", "destruction", "separination", "separinations", "Destribution", "sourceination", " destruction", "configination", "configinator", "sourceinator", "separinated", " destinate", "distination", "distinator", " destinations", "targetination"], "srcChannel": ["srcChan", "srcConnection", "srcchannel", "sourceContext", "destchannel", "destConnection", "rcContext", "rcChan", "destChan", "srcContext", " srcContext", " srcConnection", " srcChan", "sourcechannel", " srcchannel", "rcchannel", "rcChannel", "sourceChannel", "rcConnection", "sourceChan", "sourceConnection"], "destChannel": ["srcChan", "restChan", "srcConnection", "srcchannel", " destchannel", "descButton", "srcButton", "DestChan", "destchannel", " destChan", "destConnection", " destConnection", "restchannel", "DestConnection", "destChan", "sourcechannel", " destButton", "descchannel", "restChannel", "Destchannel", "sourceChannel", "destButton", "DestChannel", "descChannel", "sourceChan", "sourceConnection"]}}
{"id1": "841724", "id2": "9450274", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void seeURLConnection() throws Exception {\n        URL url = new URL(\"http://wantmeet.iptime.org\");\n        URLConnection uc = url.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n        String s = null;\n        StringBuffer sb = new StringBuffer();\n        while ((s = br.readLine()) != null) {\n            sb.append(s);\n        }\n        br.close();\n        log.debug(\"sb=[\" + sb.toString() + \"]\");\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "16466743", "id2": "6987642", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getmd5": ["getmn512", " getMD6", " getMD12", "getmd6", "getmetadata5", "getMD512", "getmn5", "getMD12", " getMD512", "getMD6", " getMD5", "getmn6", "getmd12", "getmetadata512", " getmd6", "getMD5", "getmn12", " getmd12", "getmd512", " getmd512", "getmetadata6", "getmetadata12"], "password": ["pass", "attribute", "token", "username", "words", "sword", "string", "word", "secret", "input", "Password", "PASS", "path", "key", "number", " passwords", "auth", "pad", "email", "wd", "address", "p", " Password", "prefix", "phrase", "config", "array", "f", "hash", "login", "data", "account", "message", "pattern", "buffer", "crypt", "text", "name", "encrypted", "padding"], "pwHash": ["pwtHash", "qwDig", "PWHash", "PWSum", "pwMac", "qxDig", "qwSum", "pwhMac", "pwaSum", "pxDig", "pwhBlock", "pWBlock", "pwDig", "qwMac", " pwahash", "pWSum", " pwaHash", "PWMac", "PwMac", "qxHash", "pxMac", "pxHash", "qxSum", "pwdSum", "pwaMac", "pwaHash", "pxSum", "pWHash", "pwaDig", "PwBlock", "pwtBlock", "pweHash", "pwdDig", "qwHash", "pwahash", "pweSum", "pwhSum", " pwSum", "PwHash", "pwdMac", "pwtSum", "pwdHash", "pwSum", "pwdhash", "pWMac", "pwhash", " pwhash", "pwBlock", " pwDig", "PWBlock", "pwhHash", "qxMac", "pweDig", " pwaSum", "pwehash", "pwtMac", "PwSum", " pwaDig"], "md": ["dc", "mb", "mg", "mp", "pd", "ms", "pm", "mage", "od", "mand", "cm", "mac", "Cmd", "m", "rm", "sm", " MD", "um", "d", "sha", "hm", "MD", "bd", "meta", "ad", "M", "dd", "ld", "mc", "cd", "mod", "cmd", "ma", "mag", "am", "dm", "hash", "nm", "amd", "mi", "kg", "dig", "mm", "metadata", "mt", "me", "mu", "bm", "db", "mo"], "b": ["ib", "mb", "nb", "u", "bs", "B", "ob", "d", "bin", "be", "bd", "buf", "emb", "bi", "orb", "eb", "p", "batch", "br", "lb", "l", "gb", "reb", "base", "sb", "f", "e", "a", "bytes", "cb", "bis", "bb", "r", "fb", "buff", "ba", "bf", "binary", "buffer", "wb", "ab", "rb", "db"], "i": ["si", "chi", "qi", "ip", "u", "multi", "n", "ii", "c", "pi", "o", "d", "abi", "ci", "di", "io", "z", "slice", "ji", "ui", "vi", "ri", "bi", "mu", "p", "it", "l", "phi", "s", "base", "j", "I", "x", "index", "f", "e", "oi", "li", "a", "start", "h", "ni", "v", "gi", "ti", "data", "ai", "r", "xi", "zi", "id", "info", "uri", "block"]}}
{"id1": "7458833", "id2": "19868933", "code1": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyParseFileToCodeFile": [" copyParseFileTocodeFiles", " copyParseFileToOutputFiles", " copyParseFiletoCodeFiles", " copyParseFileToMapFile", " copyParseFiletoCodeClass", " copyParseFileTocodeFile", " copyParseFiletoOutputFile", " copyParseFiletoCodefile", " copyParseFileToOutputfile", " copyParseFileToMapfile", " copyParseFileToMapClass", " copyParseFileToOutputFile", " copyParseFileToMapFiles", " copyParseFileToCodefile", " copyParseFiletoOutputfile", " copyParseFileTocodeClass", " copyParseFileToOutputClass", " copyParseFiletoOutputFiles", " copyParseFiletoOutputClass", " copyParseFiletoCodeFile", " copyParseFileTocodefile", " copyParseFileToCodeFiles", " copyParseFileToCodeClass"], "in": ["In", "pull", "again", "n", "ini", "oin", "IN", "m", "cin", "is", "inner", "din", "bin", "input", "ic", "as", "con", "io", "pin", "ins", "impl", "min", "inn", "err", "kin", "up", "init", "win", "rin", "lin", "ls", "get", "gin", "read", "f", "inside", "i", "nin", "image", "socket", "login", "reader", "r", "id", "inc", "stream"], "out": ["again", "n", "cache", "o", "ex", "exp", "inner", "bin", "Out", "log", "outer", "as", "io", "outs", "post", "sync", "this", "conn", "user", "err", "up", "net", "w", "exec", "server", "work", "other", "i", "image", "socket", "writer", "plain", "ext", "output", "OUT", "inc", "parent", "source", "client", "one", "file"], "buffer": ["position", "string", "cache", "channel", "capacity", "request", "uffer", "limit", "total", "pause", "input", "layer", "shape", "wave", "sequence", "feed", "buf", "queue", "slice", "number", "pad", "address", "count", "batch", "document", "base", "event", "server", "read", "array", "Buffer", "iter", "uf", "result", "reference", "data", "raw", "null", "fb", "buff", "duration", "binary", "available", "source", "padding"], "length": ["distance", "pull", "row", "line", "position", "ob", "string", "full", "volume", "view", "limit", "character", "total", "time", "shape", "path", "Length", "partial", "sequence", "match", "feed", "number", "slice", "repeat", "address", "count", "weight", "l", "part", "url", "load", "size", "index", "before", "code", "len", "value", "start", "range", "level", "bb", "type", "ength", "point", "style", "duration", "id", "offset", "lock", "block", "width", "end"]}}
{"id1": "9096319", "id2": "1371265", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "label": 1, "substitutes": {"handleNodeRegainedService": ["handleNodeRegainingService", "handleNodeReginedServices", "handleNodeRegainsService", "handleNoderegainsEvent", "handleNodeRegainingEvent", "handleNodeReginedService", "handleNoderegainsService", "handleNodeRegainedEvent", "handleNodeReginedEvent", "handleNodeRegainedServices", "handleNodeRegainsEvent", "handleNoderegainsServices", "handleNoderegainedService", "handleNoderegainedEvent", "handleNodeRegainingServices", "handleNoderegainedServices", "handleNodeRegainsServices"], "eventID": ["issueID", "serviceTime", " eventName", "issueName", " eventid", "serviceId", "updateName", "issueid", "serviceid", "nodeTime", "updateid", "updateID", "serviceName", "eventId", " eventId", "eventid", "updateId", "nodeName", "issueId", "eventName", "nodeId"], "nodeID": [" nodeResult", " nodeName", " nodeRI", "globalid", "globalID", "eventPath", " nodePath", "resourceID", "serviceId", "odeName", "siteid", " nodeKey", "sourceId", "eventResult", "odeID", "sourceID", "objectName", "odeId", "serviceid", "objectid", "resourceKey", "resourceId", "nodeResult", "odeResult", " nodeId", "nodeKey", "nodeid", "eventId", "eventid", "nodePath", "packageId", "objectID", "nodeRI", "packageID", "siteID", "odeRI", "siteName", "nodeName", "siteId", "sourceRI", "eventName", "nodeId", "globalId", "globalPath", "objectId", "eventKey", "packageid", " nodeid"], "ipAddr": ["ipAddrt", " ipApprs", " ipAttr", "ipAder", " ipAddrs", "ipAppvr", "ipAttr", " ipAddress", "ipaddri", " ipAddvr", "ipCher", "IPAddressrs", "IPAddressn", " ipAppvr", "ipadder", "ipaddrs", " ipAttvr", "ipAddresser", "ipAddressn", "ipAddressvr", "ipAddressr", "IPAddr", "ipAddressrs", " ipAdder", " ipAttrs", "ipApprs", "ipOffrs", "ipAddn", "ipaddvr", "ipAdn", "IPAddrs", "IPAddressr", " ipAtter", "IPAddrt", "ipAddressri", "ipAdder", "IPAddressri", "ipChn", "ipOffrt", "ipAddressress", "ipAdr", " ipAppr", "ipAddri", "ipAddressrt", "ipChr", "ipaddress", " ipAttri", "ipAddress", "ipAppr", "ipAddvr", "ipAttvr", "ipAddrs", "ipAtter", "ipChrs", "IPAddn", "ipAttri", " ipAddri", "IPAdder", "ipOffri", "ipOffr", "ipAttrs", "IPAddressrt", "IPAddri", "IPAddresser", "ipAdrs", "ipaddr"], "serviceID": [" serviceX", "skillName", "skillId", "serverId", "featureHandle", " serviceType", "serviceHandle", "skillID", " serviceName", " serviceIDs", "serverName", "featureId", "resourceID", "skillNAME", "serviceId", "featureIP", "eventX", "serviceX", " serviceNAME", "serverX", " serviceHandle", " serviceIP", "resourceId", "ServiceName", "resourceType", "serviceName", "serviceNAME", " serviceId", "serverID", "eventId", "eventIDs", "serviceIDs", "ServiceNAME", "ServiceType", "processName", "featureID", "serviceIP", "eventName", "ServiceIDs", "ServiceIP", "ServiceId", "processID", "ServiceHandle", "serviceType", "processId", "ServiceID"], "eventTime": ["errorTIME", "eventPoint", "EventName", "errorType", " eventPoint", " eventTim", " eventName", "errorTime", "eventType", "processTime", "EventTim", "EventID", "changeType", "eventTim", "errorPoint", "EventTime", "eventTIME", "changeTIME", "processName", "processTim", "eventName", "changeTime", "processID", " eventType", " eventTIME", "changePoint"], "log": ["or", "entry", "ch", "temp", "cat", "full", "c", "blog", "host", "cache", "exp", "call", "http", "tool", "pl", "ge", "path", "lex", "feed", "key", "conn", "bug", "build", "it", "cl", "l", "connection", "w", "tag", "net", "out", "pe", "event", "Log", "port", "model", "get", "thread", "plug", "config", "sec", "url", "contract", "pool", "crit", "stop", "format", "stat", "lo", "level", "type", "gen", "error", "output", "write", "LOG", "debug", "put", "sign", "fail", "info", "og", "lock", "com", "loop", "db"], "dbConn": ["realColl", "databaseconn", "dbConnection", "dbconn", "databaseLoc", "cbConn", "cbConnect", "bbconn", "fbCon", "Dbconn", "databaseConn", " dbCon", "dbCt", " dbLoc", "bbCon", " dbConnect", "fbCt", "DbConnection", "logconn", "DBConnect", "dbLoc", "databaseConnection", "DBConn", "realCon", "DbLoc", "logDb", "DBCon", " dbconn", "logConn", "bbConnect", "realConn", "logConnect", "DbCt", " dbColl", "fbColl", "bbConnection", "DbConn", "dbConnect", " dbCt", "cbconn", "DbDb", "dbColl", "DBconn", "dbCon", "bbConn", "DBConnection", "realCt", "DBCt", "fbConn", "DbConnect", " dbDb", " dbConnection", "dbDb", "cbConnection"], "outageUpdater": ["outageuplaser", "outageuplusher", "outageUpraser", "outageUpdarer", "outageUpfatter", "outageUpdatatter", "outageUdater", "outageUpdrator", "outageChdoder", "outageUnaser", "outageUpdrarer", "outageUpnager", "outageUpdatarer", "outageUpndter", "outageUpdatater", "outageUpratter", "outageupdatter", "outageUptaser", "outageUpnaser", "outageUpndatter", "outageChdroder", "outageUpdatable", "outageUpdatedapper", "outageupdaser", "outageUpmager", "outageUpdroder", "outageUpnoster", "outageUpnater", "outageUppter", "outageUpdrusher", "outageUtdarter", "outageUtdatatter", "outageupdusher", "outageAppdater", "outageUpdatedrATER", "outageUpdator", "outageUpdatedaser", "outageAppnter", "outageUpdatedratable", "outageChdater", "outageUpstater", "outageAppdager", "outageAppnator", "outageUptatable", "outageUpdATER", "outageUnarer", "outageUdaser", "outageUplaser", "outageUppatter", "outageupdater", "outageUdarer", "outageUpnoder", "outageUpdusher", "outageUpnter", "outageUplater", "outageUnater", "outageUpdaser", "outageUpfapper", "outageUpdrater", "outageUplusher", "outageUpdatedraser", "outageUppATER", "outageuplater", "outageUpfaser", "outageChdoster", "outageAppdator", "outageUpdraser", "outageUprater", "outageUpdoder", "outageUplatter", "outageUpdatATER", "outageUpmator", "outageChdator", "outageUpdatedATER", "outageUpdatarter", "outageUpnator", "outageUppaser", "outageUpdatatable", "outageAppnater", "outageUpnarer", "outageUplapper", "outageUpdataser", "outageUtdter", "outageUpparter", "outageUpdsoder", "outageUprusher", "outageUpdapper", "outageUptater", "outageUpndater", "outageAppdter", "outageUpnATER", "outageUpfater", "outageUpdarter", "outageUpmter", "outageChdrater", "outageUnATER", "outageUpdatedatable", "outageUpdratter", "outageUtdater", "outageUpstager", "outageUtdatarter", "outageUpdter", "outageUpdroster", "outageUpdatedater", "outageUpdatedrater", "outageUpndarter", "outageUpstator", "outageChdroster", "outageUpdager", "outageChdrator", "outageUtdatter", "outageUpdatter", "outageUpdrapper", "outageUpdsater", "outageUpmater", "outageUpdatedrapper", "outageUpdsator", "outageUpdsoster", "outageUpdoster", "outageUpdratable", "outageUpdatedrarer", "outageUpdrATER", "outageUdATER", "outageUptarer", "outageUppater", "outageUtdatater", "outageUpdatedarer", "outageUpdatedratter", "outageAppnager", "outageUpdatedatter", "outageuplatter", "outageUpstter"]}}
{"id1": "16590954", "id2": "5148212", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 1, "substitutes": {"createJAR": ["createJPJar", "createJPAP", " createPHAP", "createPHAR", "createPHARS", "createAMARS", "createAMJar", "createPHJar", "createJPARS", " createJAP", "createJARS", " createJARS", "createJJar", " createPHJar", "createPHAP", "createJAP", " createPHARS", "createAMAP", "createJPAR", " createPHAR", "createAMAR", " createJJar"], "fileString": [" filestring", "modelString", "fileName", "loadString", "modelText", "filestring", "Filestring", "fileText", "loadstring", "lineName", " fileFile", " fileName", "fileStream", "FileStream", "FileStr", " fileArray", "basestring", "loadName", "loadText", "linestring", "resourceStream", " fileStr", "FileArray", "baseFile", "baseStr", "fileArray", "FileText", "FileString", "FileName", " fileText", "lineString", "modelStr", "resourceStr", "FileFile", "fileFile", "modelStream", "resourceText", "baseString", "fileStr", "lineArray", "resourceString"], "ext": ["txt", "xt", "class", "external", "Ext", "exe", "zip", "append", "ex", "exp", "version", "str", "dist", "EXT", "path", "desc", "content", " Ext", "app", "url", "x", "config", "enc", "code", "filename", "format", "extra", "v", "data", "type", "ax", "req", "prot", "info", "text", "dep", "name", "end"], "file": ["File", "resource", "folder", "fe", "local", "class", "ger", "use", "line", "full", "zip", "cache", "http", "le", "log", "path", "wave", "force", "queue", "place", "files", "doc", "let", "single", "unit", "build", "it", "up", "l", "part", "base", "pe", "model", "url", "get", "work", "f", "FILE", "per", "bar", "flat", "filename", "h", "socket", "fp", "page", "test", "output", "change", "module", "b", "jar", "parent", "buffer", "source", "ile", "binary", "name", "db"], "i": ["hi", "iu", "si", "qi", "ip", "multi", "ini", "ii", "c", "pi", "limit", "abi", "ci", "di", "key", "slice", "ui", "p", "it", "l", "phi", "j", "I", "eni", "x", "index", "f", "li", "ori", "ind", "ni", "v", "mini", "mi", "ai", "yi", "xi", "uri", "uni"], "dir": ["folder", "class", "zip", "string", "ir", "str", "area", "dist", "path", "manager", "doc", "div", "DIR", "loc", "rel", "base", "domain", "prefix", "tmp", "coll", "url", "cur", "config", "pkg", "Dir", "filename", " directory", "lib", "format", "directory", "output", "data", "direction", "type", "module", "jar", "id", "info", "uri", "src", "name", "db"], "jarFile": ["jarFiles", "archiveFolder", "jarLine", "archiveFiles", "sessionfile", "javaFiles", " jarFiles", "archiveDir", "jarSourceFile", " jarLine", " jarfile", "tarF", "javaSourceFile", " jarSourceFile", "tarSourceFile", "jarF", "tarFile", "javaDir", "archiveFile", "jarFolder", "reportF", "tarfile", "sessionSourceFile", "reportSourceFile", "reportfile", "reportFile", " jarDir", "jarfile", "sessionFile", "jarDir", "javaFile", "tarLine", "javaFolder", "sessionLine", " jarFolder", "javafile", "javaF"], "fstrm": ["Fsrmd", "fbrm", " fsrm", "fstM", "fbrM", "fgrcm", "Fsrcm", "fstum", "fstrmd", "fsrmd", " fsrum", " fsrM", "FsrM", "fstcm", " fstrM", "fstrum", "FstrM", "fstrcm", " fstrum", "fgrmd", "fbrcm", " fsrcm", "Fstrmd", "fstrM", "fgrm", " fstrcm", "fsrcm", "Fstrm", "fstmd", "fstm", "fsrM", "Fstrcm", "Fsrm", "fsrum", "fbrum", "fgrM", "fsrm"], "in": ["In", "pull", "or", "again", "n", "c", "IN", "m", "is", "din", "inner", "bin", "input", "io", "pin", "sync", "ins", "ac", "conn", "min", "inn", "into", "p", "up", "l", "part", "init", "s", "rin", "gin", "read", "f", "inside", "nin", "image", "socket", "to", "login", "reader", "r", "inc", "id", "binary", "stream"], "out": ["resource", "group", "plus", "line", "again", "outside", "c", "channel", "m", "exp", "call", "inner", "bin", "Out", "self", "outer", "io", "outs", "this", "sync", "doc", "conn", "user", "err", "up", "connection", "net", "init", "part", "all", "server", "pool", "off", "image", "to", "plain", "v", "writer", "output", "OUT", "null", "b", "inc", "source", "client", "flow"], "temp": ["folder", "pipe", "wrap", "or", "local", "full", "zip", "c", "cache", "clean", " temporary", "input", "path", "export", "api", "key", "dest", "doc", "archive", "unit", "single", "build", "p", "store", "it", "w", "base", " Temp", "storage", "tmp", "server", "get", "config", "tem", "fake", "f", "iter", "dump", "controller", "home", " tmp", "emp", "writer", "v", "test", "output", "Temp", "directory", "porary", "buffer", "source", "form", "db", "Output", "template"], "fstrm2": ["fhrms1", "fstrM2", "fstrm02", "fstrms2", "fhrms2", "fhrm002", "fstm2", "fstrm1", "fstrM1", "fstrms1", "fstrmr1", "fstrm0", "fhrm2", "fstrM02", "fstrp2", "fstrM0", "fstrmr02", "fhrms002", "fstM1", "fstm0", "fhrms02", "fstrmr002", "fstM2", "fstrmr2", "fstrms002", "fstrm002", "fstrp0", "fhrm1", "fstrms02", "fhrm02", "fstrM002", "fstm1", "fstrp1", "fstrms0", "fstM0"], "ostrm": ["otherrt", "ostmr", "odm", "otherrom", "obsrm", "othermr", "ooprm", "ophm", "ostrob", "oodrem", "obsrt", "istmr", "ostm", "ophmr", "ostrt", "oodrm", "oodrt", "otherrm", "ooprt", "oscrt", "obsrem", "obsrob", "oscmr", "oscm", "ooprom", "odmr", "ostrem", "ophrt", "obrt", "obrom", "ophrm", "oscrm", "obmr", "istrt", "oodrob", "ostrom", "odrt", "odrm", "istrm", "istrom", "oopmr", "obrm"], "docFile": [" docFiles", "docDir", "documentFiles", "DocFile", "docF", " docDir", "documentFile", "documentF", "DocF", "documentDir", "docFiles", "DocDir", "DocFiles", " docF"]}}
{"id1": "14303294", "id2": "20208819", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getServerHash": ["getSessionHash", "getServerAddress", " getServerAddress", "getSecureSalt", "getServerSalt", "getserverAddress", " getSecureAddress", "getserverHash", "getSessionAddress", "getserverSHA", "getSecureSHA", "getSecureHash", "getSecureAddress", "getserverSalt", "getSessionSalt", "getSessionSHA", " getServerSHA", " getSecureSalt", " getSecureHash", "getServerSHA", " getServerSalt", " getSecureSHA"], "passwordHash": ["passwordhash", " PasswordHash", " passwordCode", "PasswordHash", "passwordPass", "PasswordPassword", " passwordhash", "PasswordPass", " passwordPass", "privatePassword", " PasswordPass", " PasswordCode", "privatehash", "passwordCode", "privateHash", " passwordSalt", "passwordSalt", "privateSalt", " passwordPassword", "Passwordhash", "PasswordCode", "passwordPassword"], "PasswordSalt": [" PasswordHash", "password256", " passwordSecret", "PasswordHash", "PasswordPassword", "passwordSecret", "PasswordSecret", "PASSSalt", "PASSPassword", "PASSHash", " Password256", " passwordSalt", "passwordSalt", "Password256", "PASS256", " passwordPassword", " PasswordPassword", " PasswordSecret", "passwordPassword"], "hash": ["row", "sh", "string", "cache", "mac", "Hash", "sha", "response", "sum", "copy", "log", "search", "hex", "number", "key", "auth", "content", "user", "address", "kh", "build", "crypt", "ha", "base", "url", "work", "ash", "size", "array", "pool", "code", "value", "password", "her", "image", "h", "check", "result", "change", "html", "error", "data", "dig", "message", "update", "buffer", "block"], "digest": ["hashener", "digener", " digall", "generall", "hashest", " diger", "digusher", "mdest", "Digener", " digher", "Digester", " digusher", "integested", "mdested", "signest", "Digested", "integest", " digger", "digested", "digester", "signer", "Digusher", " digester", " digested", "Digher", "generest", "mdusher", "signester", "hasher", "hashester", "signher", "generester", "Diger", "diger", "Digger", "integester", "generested", " digener", "integall", "digger", "mdester", "Digest", "digher", "digall", "signger"]}}
{"id1": "3024987", "id2": "5676111", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStreamForEncode", "testCopy_readerToOutputStream_Coding", "testCopy_readerToOutputStream_Code", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStream_Integoder", "testCopy_readerToOutputStream_Coded", "testCopy_readerToOutputStream_Integode", "testCopy_readerToOutputStreamForencoding", "testCopy_readerToOutputStream_Encode", "testCopy_readerToOutputStream_Integoding", "testCopy_readerToOutputStream_Coder", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStreamForencoded", "testCopy_readerToOutputStream_encode", "testCopy_readerToOutputStream_Integoded", "testCopy_readerToOutputStreamForencoder", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStreamForEncoded", "testCopy_readerToOutputStreamForEncoding", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStreamForencode", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStreamForEncoder"], "in": ["In", "or", "entry", "pass", "inas", "again", "ini", "n", "include", "IN", "rec", "m", "reading", "is", "inner", "din", "bin", "with", "input", "io", "slice", "ins", "min", "inn", "err", "init", "win", "rin", "url", "read", "Reader", "inside", "i", "image", "a", "file", "login", "arin", "data", "r", "inc", "id", "source", "buffer", "re"], "reader": ["or", "reading", "pointer", "oder", "inner", "ler", "input", "io", "ner", "feed", "driver", "er", "handler", "ra", "x", "loader", "read", "Reader", "iter", "rer", "per", "i", "ink", "her", "worker", "iner", "writer", "rr", "r", "b", "parser", "rar", "buffer", "stream", "rx", "source", "file"], "baout": ["vaOut", "BAOUT", "baOut", "abaOut", "wain", "daout", "aaout", "daOut", "Baout", "baOUT", "daOUT", "BAOut", "waoutput", "vaout", "baparent", "waOut", "BAparent", "BAout", "abaOUT", "aain", "BAoutput", "BaOut", "bain", "vain", "BAin", "dain", "vaparent", "Baparent", "abaout", "aaoutput", "aaOut", "Bain", "abain", "waout", "baoutput"], "out": ["inas", "line", "again", "cache", "o", "inner", "with", "Out", "io", "outs", "object", "user", "err", "up", "base", "exec", "server", "arr", "array", "pool", "image", "lib", "to", "writer", "file", "ext", "output", "write", "obj", "OUT", "null", "inc", "parent", "buffer", "client", "builder", "ref"], "bytes": ["pages", "reads", "Bytes", "classes", "codes", "bs", "zip", "string", "bps", "ies", "css", "lines", "ones", "values", "bits", "objects", "outs", "os", "files", "content", "seconds", "tes", "pieces", "cells", "strings", "ls", "size", "its", "ns", "blocks", "units", "ips", "output", "data", "parts", "items", "ipes", "null", "comments", "android", "es", "binary", "les", "text", "body", "odes", "rows"]}}
{"id1": "8087001", "id2": "10540676", "code1": "    public static String generateStackHashKey() {\n        Exception e = null;\n        try {\n            throw new Exception();\n        } catch (Exception ex) {\n            e = ex;\n        }\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(getStackTrace(e).getBytes());\n            byte[] hash = digest.digest();\n            String rtn = Base64.encode(new String(hash));\n            if (keys.contains(rtn)) {\n                return generatedIterStackHashKey(rtn);\n            }\n            keys.add(rtn);\n            return rtn;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public static void checkForUpgrade(Event event) throws Exception {\n        ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"applyUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(false);\n        new Command(\"DELETE FROM TBLINSTALLATION WHERE STATUS<>'APPLIED'\").executeNonQuery();\n        String clientAppliedVersion = new Command(\"SELECT MAX(VERSION) FROM TBLINSTALLATION WHERE STATUS='APPLIED'\").executeScalarAsString();\n        if (NullStatus.isNull(clientAppliedVersion)) {\n            clientAppliedVersion = \"20050101\";\n        }\n        String macquery = \"\";\n        String clientMAC = \"\";\n        String clientUNITID = UiUtil.getUNITUID();\n        ArrayList<String> macList = getMacList();\n        for (int i = 0; i < macList.size(); i++) {\n            clientMAC += macList.get(i) + \",\";\n            macquery += \"'\" + macList.get(i) + \"'\";\n            if (i < macList.size() - 1) {\n                macquery += \",\";\n            }\n        }\n        URL urlLICENSEQUERY = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC + \"&tegsoftCOMMAND=LICENSEQUERY\");\n        URLConnection urlConnection = urlLICENSEQUERY.openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String commingList = \"\";\n        String line;\n        while ((line = in.readLine()) != null) {\n            commingList += line;\n        }\n        in.close();\n        String licenseArray[] = commingList.split(\"</ROW>\");\n        if (licenseArray.length > 0) {\n            String fields[] = licenseArray[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        Dataset TBLLICENSE = new Dataset(\"TBLLICENSE\", \"TBLLICENSE\");\n        Command command = new Command(\"DELETE FROM TBLLICENSE WHERE UNITUID={UNITUID} AND (NOTES IN (\");\n        command.append(macquery);\n        command.append(\") OR NOTES IS NULL) \");\n        command.executeNonQuery();\n        for (int i = 1; i < licenseArray.length; i++) {\n            String fields[] = licenseArray[i].split(\"</FLD>\");\n            String LICTYPE = fields[0];\n            String UNIQUEKEY = fields[1];\n            String LICKEY = fields[2];\n            DataRow dataRow = TBLLICENSE.addNewDataRow();\n            dataRow.set(\"LICENSENAME\", LICTYPE);\n            dataRow.set(\"LICENSE\", LICKEY);\n            dataRow.set(\"NOTES\", UNIQUEKEY);\n            TBLLICENSE.save();\n        }\n        URL url = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC);\n        urlConnection = url.openConnection();\n        in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String upgradeList = \"\";\n        while ((line = in.readLine()) != null) {\n            upgradeList += line;\n        }\n        in.close();\n        Dataset TBLINSTALLATION = new Dataset(\"TBLINSTALLATION\", \"TBLINSTALLATION\");\n        String upgrades[] = upgradeList.split(\"</ROW>\");\n        if (upgrades.length > 0) {\n            String fields[] = upgrades[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        boolean restartRequired = false;\n        boolean updateAvailable = false;\n        for (int i = 1; i < upgrades.length; i++) {\n            String fields[] = upgrades[i].split(\"</FLD>\");\n            String VERSION = fields[0];\n            String ORDERID = fields[1];\n            String UPGRADETYPE = fields[2];\n            String DESCRIPTION = fields[3];\n            String STATUS = \"UNAPPLIED\";\n            String PRDNAME = \"TegsoftCC\";\n            if (\"TEGSOFTJARS\".equals(UPGRADETYPE) || \"TOBEJARS\".equals(UPGRADETYPE) || \"ALLJARS\".equals(UPGRADETYPE) || \"CONFIGASTERISK\".equals(UPGRADETYPE)) {\n                restartRequired = true;\n            }\n            DataRow dataRow = TBLINSTALLATION.addNewDataRow();\n            dataRow.set(\"ORDERID\", ORDERID);\n            dataRow.set(\"PRDNAME\", PRDNAME);\n            dataRow.set(\"UPGRADETYPE\", UPGRADETYPE);\n            dataRow.set(\"VERSION\", VERSION);\n            dataRow.set(\"STATUS\", STATUS);\n            dataRow.set(\"DESCRIPTION\", DESCRIPTION);\n            TBLINSTALLATION.save();\n            updateAvailable = true;\n        }\n        UiUtil.getDataset(\"TBLINSTALLATION\").reFill();\n        if (restartRequired) {\n            ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(true);\n            ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(true);\n        }\n        if (updateAvailable) {\n            ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(true);\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_4));\n        } else {\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_5));\n        }\n    }\n", "label": 0, "substitutes": {"generateStackHashKey": ["generateStackHeaderString", "generatestackhashKey", "generatestackHashKey", "generateStackhashKey", "generatestackhashKeys", "generateStackHeaderKeys", "generateStackhashKeys", "generatestackHashKeys", "generatestackhashkey", "generatestackHashString", "generateStackHashKeys", "generateStackHeaderKey", "generateStackhashkey", "generatestackhashString", "generateStackHashkey", "generateStackHashString", "generatestackHashkey", "generateStackHeaderkey", "generateStackhashString"], "e": ["body", "fe", "n", "c", "est", "oe", "m", "o", "ex", "d", "ee", "this", "enter", "ed", "er", "ie", "err", "Exception", "p", "ef", "ception", "ea", "pe", "element", "event", "exec", "exc", "x", "he", "f", "E", "ele", "ze", "el", "a", "h", "ae", "error", "se", "ev", "r", "b", "en", "t", "esi", "ec", "es", "me", "ace", "et"], "digest": ["Signester", "digator", "logest", "Digator", " Digester", "digusher", " diger", "mdest", " digator", " digher", "mdate", "Digester", " digusher", "Signate", "mdested", "Digested", "digate", "digge", "digested", "Digge", "digester", " Digator", "decest", "Digusher", "digenge", " digester", "mdature", " digested", "Digher", "mdusher", "logester", "Diger", " Digested", " Digest", "diger", "mder", "Signature", " digenge", "decate", " digge", "logge", "digature", "mdenge", "mdester", "Digest", "decature", "Signest", "logher", "decester", "digher", "Digenge"], "hash": ["bh", "hed", "sh", "string", "history", "mac", "Hash", "rh", "total", "sha", "sum", "key", "hex", "ashes", "header", "kh", "build", "ha", "ph", "base", "ash", "array", "f", "code", "value", "her", "image", "h", "dot", "result", "v", "data", "dig", "b", "message", "text", "body"], "rtn": ["txc", "retb", "RTns", "latN", "vrns", "rtnin", "RTnin", "RTnn", "rtns", "gtn", "ntn", "ortN", "ntN", "RTne", "ortne", "RTc", "RTb", "ortnn", "rdn", "gtb", "retns", "ntb", "ntc", "vrN", "rdN", "vrn", "ntnin", "rtnn", "ntpn", "retN", "rtpn", "latns", "RTN", "RTn", "rtc", "txn", "rtb", "latn", "rtne", "vrnn", "rtN", "gtpn", "retn", "rdns", "vrne", "RTpn", "latne", "ortn", "txN", "gtN", "txnin", "rdb"]}}
{"id1": "160739", "id2": "17580775", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "label": 0, "substitutes": {"createOutputStream": [" createOutputSteam", " createIOStream", " createInputSteam", " createByteFile", " createOutputFile", " createByteSteam", " createInputReader", " createIOSteam", " createByteReader", " createOutputReader", "createInputFile", " createInputFile", "createInputStream", " createIOFile", " createInputStream", "createOutputFile", "createInputSteam", " createByteStream", "createOutputReader", " createIOReader", "createOutputSteam", "createInputReader"], "inFile": ["outfile", "sourceFiles", "inputFile", "insfile", "sourcefile", "insFiles", "outFiles", "incStream", "inputStream", "infile", "inputFiles", "inStream", "sourceFile", "outStream", "insFile", "insStream", "incFiles", "inFiles", "inputfile", "incFile", "sourceStream", "incfile"], "outFile": ["outfile", "targetFile", "inDir", "workDir", "outDirectory", "workingFile", "inputFile", "outDir", "infile", "workingDirectory", " outDirectory", "workingfile", "workfile", "workTime", "workFile", "inTime", "outStream", "inputDir", "inputfile", "outTime", "inputTime", " outfile", "workingStream", " outStream", "targetfile", "targetDirectory", "targetStream"], "k_blockSize": ["k_byteLen", "k_blocksLength", "k_lineSize", "k_lockSize", "k_bitInfo", "k_blockCount", "k_blocksSize", "k_lockLen", "k_lockLength", "k_blockLength", "k_byteLength", "k_byteInfo", "k_lineCount", "k_blocksLen", "k_BlockCode", "k_byteCount", "k_BlockCount", "k_bitSize", "k_byteCode", "k_lineInfo", "k_lockCode", "k_byteSize", "k_blockCode", "k_blocksCount", "k_BlockSize", "k_BlockLength", "k_lockCount", "k_blockLen", "k_blockInfo", "k_bitCount"], "byteCount": ["blockSize", "byteSize", " byteSize", " byteLength", "byteLen", "blockCount", " bytecount", "Bytecount", "byteSum", "characterSize", "ByteLength", "flushcount", "blockLength", "flushLength", "ByteCount", "characterCount", "flushSize", "characterLen", " byteSum", "flushCount", "ByteSize", "ByteLen", "ByteSum", "characterLength", "byteLength", " byteLen", "blockSum", "bytecount"], "buf": ["background", "brace", "bh", "vec", "alloc", "cas", "append", "cv", "fd", "ctx", "feed", "queue", "la", "seq", "ucc", "loc", "batch", "bag", "base", "rc", "cmd", "tmp", "exc", "config", "Buffer", "len", "uf", "cap", "bytes", "cb", "border", "result", "img", "data", "feat", "Buff", "b", "fb", "buff", "flush", "bf", "buffer", "font", "src", "rb"], "ofp": ["OFnp", "Ofc", "Ofl", "Oft", "afl", "fort", "OFtp", "OFc", "afnp", "ofl", "forp", "afp", "Ofp", "Oftp", "afc", "ofnp", "Ofnp", "fortp", "ofc", "oft", "forc", "OFp", "OFl", "OFt", "oftp"], "zos": ["ses", "osi", "z", "iffs", "obb", "zig", "tz", "liquid", "obs", "webkit", "oda", "zyk", "gz", "zb", "soon", "zh", "zon", "nz", "robe", "js", "bs", "css", "zin", "cfg", "fits", "zn", "utils", "lol", "dylib", "zy", "oses", "zer", "zik", "rons", "zes", "za", "zona", "inos", "enos", "abi", "os", "outs", "packs", "iframe", "ZA", "oS", "los", "ls", "zx", "ops", "jas", "cos", "zar", "ws", "ZI", "zi", "lins", "forge", "owicz", "budget", "zers", "ozo", "ossus", "zen", "zip", "rez", "bitcoin", "bos", "zag", "nox", "bes", "uz", "zo", "ros", "hz", "ogl", "kos", "zl", "core", "modules"], "osw": ["osx", "isd", "eshell", "bswo", "bsws", "isnow", "eswd", "bws", "lsw", "ossd", "bx", "osssw", "esfw", "osd", "osswd", " osww", " osow", "esnow", "oswo", " osfw", "ishell", "isw", "esww", "osshell", "lsws", "esy", "isy", "ossy", "esow", "ossww", "esd", "oswd", "iswd", "ossow", "bwo", "bsx", "osfw", "ossnow", "ossfw", "oshell", "osww", "esw", "ossw", "osws", "osy", "osnow", "issw", "lsx", "essw", "lswo", "bsw", "osow"], "bw": ["bbew", "bz", "bbz", "ebW", "ebwe", "abwd", "owa", "lbwh", "lwa", "bws", "bwe", "lsw", "Bws", " bws", "lx", "ow", " bwa", "bx", "lbx", " bz", "fx", "bbws", "bwd", "fwh", "bbw", "bwa", "bbaw", "Bew", "lbsw", "Bw", "lw", "fbwd", " baw", "abwe", "owu", "oaw", "fw", " bew", "lbz", "bwu", "ebw", "bbwa", "ebwd", "bbwu", "abw", "lbwa", "lbws", "bwh", "Bwa", "lbw", "bew", "bbwh", " bwu", "bW", "fbw", "fbW", "baw", "fwa", "lbr", "fsw", "fbwe", "abW", " bwh", "fr", "bsw"], "zot": ["Ziot", "aziot", "Zot", "zori", "jot", "azit", "zerita", " zor", "zor", "jos", "jori", "zerit", "zeros", "zerott", "azor", "Zit", "zita", "jit", "ziot", "Zor", " ziot", "Zita", "azot", "Zott", "zerori", "zott", "zerot", "azita", " zori", "azott"], "ifp": [" ifc", "Ifc", "Ifi", "ifl", "ifb", "ifi", "ifc", " iff", "IFf", "IFp", " ifi", "ipl", "IFc", " ifb", "Iff", "IFb", "ipp", " ifl", "iff", "Ifp", "ipb", "IFi", "ipc", "IFl"], "zis": ["zits", "ziss", " zais", "zeip", "zais", "zip", "zeiss", "xIS", "zib", "jis", "zenis", "Ziss", "zipits", "zipis", " zits", " zisi", "zenIS", "zipip", "Zip", "jit", "xib", "zenais", "xisi", "xis", "xais", "xits", "Zits", "jisi", " zIS", "Zis", " zib", "zenib", "zeis", "zisi", "jits", "zipiss", "xit", "zIS", "zeits"], "isr": ["irr", "ISr", " issr", "ISrc", "ISsr", "irrb", "irpr", "isrb", "rispr", "irrc", "ispr", "risrc", "ISrb", "isrs", "isscr", "ISrs", "IScr", "risr", "ISpr", " isrs", "issrs", "isssr", "risrb", " iscr", "iscr", "issr", "isrc"], "br": ["Br", "ch", "ctr", "bh", "HR", "kr", "ob", "obl", "ocr", "str", " fr", "shr", "ber", "obi", "yr", "sr", "bro", "BR", "div", "bsp", "tr", "gr", " BR", "bp", "cro", "mr", "lr", "browser", "bl", "ibl", "err", "rib", " dr", "ibr", "arr", "sp", " Br", "bc", "bar", "img", "hr", "r", "b", "rs", "body", "rb", "fr"], "zit": [" zic", "zits", "zic", "jic", "zeitter", "zipith", "zipIT", "zip", " zip", "jita", "zenits", "jIT", "zeit", "zipit", "zeIT", "zenit", "zipits", " zits", "zIT", "ji", "zipip", "jite", "zita", "jit", " zith", "xic", "zeith", "zitter", "xith", "zith", "jith", "zenitter", "jip", " zite", "zenith", "zipita", "jits", "zite", "zi", "zipite", "xi", "xit", "zeita", "zipitter", " zi", "zeits"]}}
{"id1": "397240", "id2": "17193692", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void execUpdate(String sqlStmts[]) throws SQLException {\n        if (conn == null || conn.isClosed()) throw new SQLException(\"The connection has not been established yet.\");\n        if (sqlStmts == null || sqlStmts.length == 0) throw new SQLException(\"SQL-statement is null.\");\n        conn.setAutoCommit(false);\n        try {\n            for (int i = 0; i < sqlStmts.length; i++) {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sqlStmts[i]);\n                logger.debug(sqlStmts[i]);\n                stmt.close();\n            }\n            conn.commit();\n        } catch (SQLException ex) {\n            conn.rollback();\n            throw ex;\n        }\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "6966398", "id2": "471804", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"reader": ["resource", "df", "or", "row", "reads", "ry", "k", "instance", "context", "o", "reading", "rake", "oder", "ler", "raf", "input", "cer", "manager", "io", "ner", "feed", "driver", "cms", "ri", "client", "pp", "keeper", "er", "handler", "book", "p", "connection", "rc", "pe", "server", "load", "dr", "config", "loader", "read", "Reader", "iter", "per", "rw", "her", "writer", "se", "rr", "r", "parser", "rar", "source", "stream", "buffer", "builder", "file"], "ks": ["ics", "acts", "akes", "reads", "kes", "hs", "KS", "ms", "books", "bs", "k", "opens", "ko", "checks", "gets", "orks", "ctx", "co", "ke", "powers", "acs", "fs", "qs", "ki", "ans", "ls", "inks", "acks", "cks", "vs", "ops", "ches", "keys", "icks", "cs", "ns", "ds", "ku", "CS", "kb", "ges", "ips", "sk", "se", "ps", "DS", "es", "rs", "works", "ck", "kies", "ss", "rows"], "key": ["Key", "seed", "k", "c", "cache", "pg", "ca", "secret", "ee", "service", "state", "io", "co", "char", "pair", "ke", "ce", "ring", "trust", "user", "p", "base", "ki", "court", "pe", "server", "keys", "read", "code", "value", "transfer", "ssl", "type", "point", "sign", "lock", "client", "file"], "chain": ["wrap", "root", "container", "c", "cache", "chains", "table", "wheel", "secret", "circle", "family", "path", "sequence", "box", "network", "list", "none", "slice", "pair", "object", "store", "cr", "rule", "mc", "scale", "base", "coll", "Chain", "config", "enc", "code", "set", "image", "range", "stack", "lock", "crypt", "block", "collection", "file"], "os": ["rss", "ms", "ol", "ios", "ob", "osi", "oid", "op", "o", "opens", "is", " o", "oss", "options", "io", "outs", "aos", "object", "bos", " bos", "p", "fs", "s", "pos", "los", "iso", "ops", "cos", "ot", "Os", "ds", "oses", "ros", "res", "ou", "ps", "es", "rs", "OS"], "stamper": ["starmple", "spampe", "function", " nostameple", "g", "spamper", " nostamler", "streampe", "stammper", "stAMper", "spammer", "path", "spAMpe", "stAMmer", "stampper", "stammple", "this", " nostamepper", "starmper", "stammpe", "starmpper", " nostamper", " nostameper", "stammmer", "s", "stAMpe", "stampe", "streammer", "stameple", "streamper", "spamler", "stamler", "spAMler", "stameler", "_", "stample", "starmler", "stammler", "stammer", "stammpper", "stamepper", "stAMler", "stameper", "data", " nostample", "streamler", " nostameler", " nostampper", "spAMper", "spAMmer"], "appearance": ["ppearance", "attfacing", "installear", "appasion", " appears", "ppearing", "suppearing", "byearance", "feedearance", "feedointment", "formismo", "atteared", "formearing", "appfacing", "askence", "appence", " appfacing", "appearing", "suppearance", "appismo", "ppaser", "signearing", "appointment", "attence", "feedfacing", "suppfacing", "byismo", "askeared", "feedear", " appeared", "Appearance", "signfacing", "ppear", "signear", "byearing", "suppasion", "signearance", "askearance", "installearing", "Appears", "formaser", " applier", "appears", "signointment", "askfacing", "formear", "byear", "installearance", "appear", "ppasion", "signears", "signlier", "attearance", "suppointment", "applier", "Appearing", " appence", "appaser", " appear", " appearing", " appaser", "formearance", " appismo", "installasion", "Applier", "suppear", "appeared"]}}
{"id1": "20623709", "id2": "732800", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"split": ["share", "run", "cmp", "join", "execute", "append", "copy", "Split", "open", "match", "add", "process", "sync", "archive", "build", "part", "init", "exec", "delete", "set", "format", "start", "transfer", "diff", "parse", "update", "sort"], "targetDirectory": ["targetFile", "targetFolder", "destDir", " targetFolder", " targetPath", "masterDatabase", "TargetDir", "TargetDirectory", "outputFile", "currentDirectory", "TargetFolder", "destFile", "targetPath", "masterDirectory", " targetFile", "currentDir", "baseDir", " targetRoot", "basePath", "baseFolder", "TargetDatabase", "outputFolder", "masterPath", "destDirectory", "TargetFile", "outputDirectory", " targetDir", "TargetPath", "baseFile", "currentRoot", "targetRoot", "currentPath", "destFolder", "targetDatabase", "outputDir", "baseDatabase", "TargetRoot", "currentFolder", "masterDir", "targetDir", "baseDirectory"], "prefix": ["folder", "timeout", "resource", "temp", "txt", "root", "username", "string", "cache", "append", "path", "fixed", "patch", "sequence", "number", "queue", "first", " suffix", "unit", "template", "base", "fix", "domain", "config", "index", "pre", "filename", "format", "resolution", "fp", "FIX", "directory", "type", "prot", "offset", "uri", "ix", "pattern", "name", "Pref", "padding"], "maxUnitBases": ["maxUnitChase", "maxUnitChasing", "maxunitAliasing", "maxUnitQuease", "maxUnitAliues", "maxunitBaches", "maxUnitEases", "maxunitBails", "maxunitAliues", "maxUnitAliasing", "maxUnitBues", "maxUnitQueasing", "maxunitBase", "maxUnitPlase", "maxUnitEaches", "maxUnitChases", "maxUnitPlaches", "maxUnitBasing", "maxunitAliails", "maxunitAliases", "maxunitBues", "maxunitBases", "maxUnitAliails", "maxUnitEase", "maxUnitBails", "maxUnitEails", "maxUnitBase", "maxunitAliase", "maxUnitAliases", "maxunitBasing", "maxUnitQueues", "maxUnitBaches", "maxUnitQueases", "maxUnitPlases", "maxUnitAliase", "maxUnitPlails", "maxUnitAliaches", "maxUnitChues", "maxunitAliaches"], "maxUnitEntries": ["maxUnitOrdry", "maxUnitEntryries", "maxUnitOrdrys", "maxUnitEntry", "maxUnitEnties", "maxUnitErry", "maxUnitErrations", "maxUnitErines", "maxLineEntries", "maxUnitCountries", "maxUnitEntrys", "maxUnitEntures", "maxUnitOrdries", "maxLineOrdines", "maxUnitIntresses", "maxUnitCountines", "maxUnitEntrations", "maxUnitCountrations", "maxLineOrdries", "maxUnitEntryrys", "maxunitEntryrys", "maxLineEntry", "maxUnitOrdrations", "maxunitEntries", "maxUnitEntryresses", "maxLineOrdrations", "maxUnitOrdines", "maxUnitAddures", "maxUnitIntrys", "maxLineEntrations", "maxunitEntrys", "maxUnitIntries", "maxunitEntresses", "maxUnitInties", "maxunitEntryresses", "maxUnitAddresses", "maxUnitCountry", "maxUnitEntines", "maxUnitErries", "maxLineOrdry", "maxUnitAddry", "maxUnitAddries", "maxUnitEntryures", "maxunitEnties", "maxunitEntryries", "maxUnitOrdresses", "maxLineEntines", "maxUnitEntresses", "maxUnitEntryies", "maxUnitOrdies", "maxUnitEntryry", "maxunitEntryies"], "fis": ["Fiss", " fisc", "forIs", "vIs", "foriss", "fisc", " fIs", "fIs", " fiss", "fris", "forris", "vis", "forisc", "foris", " fris", "fisa", " fai", "Fis", "forisa", "fai", "forai", "vai", "Fris", "fiss", "visa", "Fisc", " fisa"], "fci": ["vco", "fii", "vci", " foci", "efcos", "Fci", "vcos", "efci", "Fai", "Foci", "hcos", "dci", "efco", "hai", "fcos", "Fii", "dco", "dii", "hci", "Fis", " fai", "Fco", "bai", "fai", "foci", "efai", "hco", "bis", "vai", "doci", "bco", " fii", "bci"], "fos": ["infoes", "fsos", "ifos", "fo", "ifo", "fso", "fios", " fcos", "infos", "fscos", "ifios", "infis", " fios", " fo", "tos", "foes", "fcos", "infoss", "Fis", "ifcos", "fsios", "Fos", "Foss", "toes", "Foes", "tis", "foss", "toss"], "fco": ["fileico", "Fico", "fbo", "hgo", "fileco", "Fci", "lcos", "lco", "lci", " fcos", "Fbo", " fico", "fico", "fgo", "dcos", "hcos", "dro", "dci", "filebo", " fro", "fcos", "dco", "hci", "lgo", "lro", " fgo", "Fco", "hco", "fro", "fileci", " fbo"], "buffer": ["resource", "timeout", "entry", "window", "position", "channel", "cache", "zero", "capacity", "context", "request", "view", "uffer", "expression", "comment", "bin", "pause", "response", "copy", "input", "layer", "texture", "feed", "buf", "queue", "pad", "length", "header", "translation", "batch", "document", "base", "device", "rate", "scale", "server", "size", "loader", "bc", "Buffer", "iter", "bar", "read", "callback", "image", "writer", "border", "transfer", "memory", "result", "reader", "counter", "data", "null", "buff", "flush", "message", "offset", "binary", "info", "block", "source", "reference"], "currentBasesCount": ["currentBaseCount", "currentBasesCounter", "currentChasecount", "currentBasesNum", "currentBaseCounter", "currentChaseCount", "currentChasesNum", "currentBatchesNum", "currentBasingNum", "currentBasingCount", "currentBatchescount", "currentChasescount", "currentBasingcount", "currentChaseNum", "currentBasescount", "currentBatchesCounter", "currentBasingCounter", "currentChasesCounter", "currentBasecount", "currentBatchesCount", "currentBaseNum", "currentChasesCount", "currentChaseCounter"], "currentEntriesCount": ["currentEntriesOffset", "currentEntrasOffset", "currentEntrasCount", "currentEntursLimit", "currentEntriesSize", "currentAdduresSize", "currentAddriesLimit", "currentEntrasSize", "currentEnturesOffset", "currentAddriesOffset", "currentEnturesSize", "currentEntriesLimit", "currentEntrasLimit", "currentAdduresCount", "currentEntursOffset", "currentAdduresOffset", "currentAddriesCount", "currentEntursCount", "currentEnturesCount", "currentAddriesSize", "currentAdduresLimit", "currentEnturesLimit", "currentEntursSize"], "targetCount": ["targetSize", "patternCount", "argetcount", "patterncount", "TargetSize", "TargetSum", "patternSize", "argetSize", "patternSum", "targetcount", "targetSum", "argetSum", "argetCount", "TargetCount", "Targetcount"], "fastaChannel": ["fastasContext", "fastanChannel", "fastanContext", " fastaColumn", "fastasBuffer", "fastAColumn", "fastaColumn", "fastaContext", "fastaContainer", " fastAContext", " fastAContainer", " fastaContext", " fastaContainer", "fastABuffer", "fastasChannel", " fastABuffer", " fastAColumn", "fastanContainer", "fastAContainer", "fastasConnection", "fastAConnection", "fastasColumn", "fastasContainer", "fastaqChannel", "fastaqBuffer", "fastAChannel", " fastAConnection", "fastaConnection", " fastaConnection", " fastAChannel", "fastAContext", "fastaqColumn", "fastanBuffer", "fastaqConnection"], "totalSeqCount": ["totalSeQcount", "totalSeuxcount", "totalSeQNum", "totalSeQCounter", "totalSeQCount", "totalQueQcount", "totalSeqscount", "totalQueQCounter", "totalQueqCount", "totalQueqcount", "totalQueqNum", "totalQueqCounter", "totalSeqcount", "totalSeuxCount", "totalSeqsCounter", "totalSeuxCounter", "totalSeuxNum", "totalSeqNum", "totalSeqsNum", "totalSeqsCount", "totalSeqCounter", "totalQueQCount", "totalQueQNum"], "totalResiduesCount": ["totalResqueuresCount", "totalResiduationNum", "totalResidurescount", "totalResiduingNum", "totalResqueuesNum", "totalResiduescount", "totalResiduesSize", "totalResiduresCount", "totalResiduationcount", "totalResqueuesSize", "totalResqueuresNum", "totalResiduingSize", "totalResqueurescount", "totalResiduationCount", "totalResiduingCount", "totalResiduresSize", "totalResqueuesCount", "totalResqueuresSize", "totalResiduresNum", "totalResiduationSize", "totalResqueuescount", "totalResiduesNum", "totalResiduingcount"], "prevTime": ["prevSize", "PrevFile", "prevValue", " prevValue", " prevFile", "prevFile", "PrevValue", "commitSize", "PrevSize", "commitFile", "commitTime", "PrevTime", " prevSize", "commitValue"], "fastaFileSize": ["fastasFileLength", "fastaBufferSize", "fastaFilesSize", "fastAFileAddress", "fastasFileAddress", "fastasFileName", "fastaHeaderSize", "fastasHeaderLength", "fastaFileName", "fastaBlockSize", "fastaLineLength", "fastaFilesAddress", "fastaBlockLength", "fastaLineCount", "fastaHeaderAddress", "fastaFileCount", "fastaLineAddress", "fastaBlockAddress", "fastaBlockCount", "fastAFileCount", "fastaHeaderLength", "fastasHeaderSize", "fastaPageSize", "fastaBufferAddress", "fastABufferAddress", "fastaFileLength", "fastasFileSize", "fastaFileAddress", "fastaHeaderName", "fastaPageLength", "fastaFilesName", "fastABufferSize", "fastasHeaderName", "fastaLineSize", "fastaFilesLength", "fastABufferCount", "fastaBufferLength", "fastaPageAddress", "fastAFileLength", "fastABufferLength", "fastaBufferCount", "fastAFileSize", "fastasHeaderAddress", "fastaPageName"], "fastaFileReadOffset": ["fastaFileLoadLength", "fastaFileLengthOff", "fastaFilesReadOffset", "fastaDirectoryReadOff", "fastaFilesReadLength", "fastaFileLoadoffset", "fastaFilesWriteOffset", "fastaBufferReadLength", "fastaFileReadAmount", "fastaFilesReadOff", "fastaFileStartOffset", "fastaFileStartOff", "fastaFilereadLength", "fastaFileRunoffset", "fastaDirectoryWriteOffset", "fastaDirectoryWriteEntry", "fastaFileLengthAmount", "fastaFileStartEntry", "fastaFileWriteEntry", "fastaDirectoryWriteOff", "fastaFileRunOffset", "fastaDirectoryReadOffset", "fastaFilesWriteoffset", "fastaFilereadOff", "fastaFileReadoffset", "fastaBufferReadAmount", "fastaFileRunEntry", "fastaBufferWriteOffset", "fastaFileReadEntry", "fastaFileWriteLength", "fastaBufferReadoffset", "fastaDirectoryReadEntry", "fastaFilereadoffset", "fastaFileWriteOff", "fastaFileLengthOffset", "fastaFileWriteAmount", "fastaFileReadLength", "fastaFileRunOff", "fastaFilesReadoffset", "fastaFilesWriteOff", "fastaDirectoryWriteoffset", "fastaFilesWriteLength", "fastaBufferWriteLength", "fastaBufferWriteAmount", "fastaFileWriteOffset", "fastaFileLengthoffset", "fastaFileStartoffset", "fastaBufferWriteoffset", "fastaFileLoadAmount", "fastaFilereadOffset", "fastaBufferReadOffset", "fastaDirectoryReadoffset", "fastaFileLengthLength", "fastaFileReadOff", "fastaFileWriteoffset", "fastaFileLoadOffset"], "partitionStartOffset": ["partitionStopOrder", "partitionStopOffset", "partitionStopOff", "partitionsStartOrder", "partitionEndOrder", "partitionBufferOffset", "partitionStartOrder", "partitionEndOff", "partitionsStartRange", "partitionEndRange", "partitionStartRange", "partitionBufferOff", "partitionStopRange", "partitionsStartOffset", "partitionsEndOrder", "partitionsEndOffset", "partitionsEndOff", "partitionsEndRange", "partitionBufferOrder", "partitionStartOff", "partitionsStartOff", "partitionBufferRange"], "bufferSize": ["queueSize", "BufferSize", " bufferType", "processC", "queueCount", "bufferType", "bufferC", "bufferSIZE", " bufferSIZE", "BufferCount", "BufferSIZE", "processSize", "processSIZE", "BufferC", "bufferCount", " bufferC", " bufferCount", "processType", "BufferType"], "fastaBuffer": ["fastaPtr", "FastaBuffer", "fastaaBuffer", "fastanChannel", "fastasStream", "FastaPtr", "fastAQueue", "fastasBuffer", " fastAQueue", " fastAFile", "fastaContainer", "fastanBuff", " fastaBuff", "fastAPtr", "FastasBuffer", " fastaContainer", "fastasFile", " fastasBuffer", "FastasBuff", "fastanPtr", " fastABuff", " fastasContainer", "fastABuff", "fastaceBuff", "fastasQueue", "fastABuffer", "fastasChannel", "fastanStream", "fastAFile", "FastaBuff", " fastaQueue", "fastaFile", "fastasBuff", "FastasStream", " fastasFile", " fastABuffer", "fastanContainer", "fastasPtr", " fastaFile", "fastanQueue", "fastanFile", "FastaChannel", "fastAContainer", "fastaBuff", "FastasPtr", "fastaaPtr", "fastaQueue", "fastaceChannel", "fastasContainer", "fastaceBuffer", "fastaaBuff", "FastasChannel", "FastaStream", "fastaStream", "fastaaStream", "fastAChannel", " fastAChannel", "fastacePtr", "fastanBuffer", " fastasChannel"], "fastaReadState": ["fastasReaderMode", "fastaFileState", "fastaFileMode", "fastaReaderState", "fastasReaderstate", "fastaReadingstate", "fastasReaderType", "fastasReadMode", "fastaReaderstate", "fastaReadMode", "fastaReadingMode", "fastaReaderType", "fastaFilestate", "fastaReadingState", "fastaReadstate", "fastaFileType", "fastaReadType", "fastasReadType", "fastaReaderMode", "fastasReaderState", "fastasReadstate", "fastaReadingType", "fastasReadState"], "nBytes": [" nFrames", "NParts", "obytes", "nByte", "lenFrames", "NByte", "pBytes", "pParts", "pbytes", "lenFiles", " nByte", "oBytes", " nParts", "Nbytes", "oFiles", "lenbytes", "nParts", "pByte", "numFrames", "lenBytes", "numBytes", "oParts", "NFiles", "numbytes", "nFiles", " nbytes", "nFrames", "NBytes", " nFiles", "numFiles", "nbytes"]}}
{"id1": "3330944", "id2": "11032546", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 1, "substitutes": {"extractImage": ["extressImage", "extressLayer", "compressFile", "compressLayer", "extressText", "extrateLayer", "extrateFile", "extressFile", "extrateText", "extvertLayer", "extractText", "extvertFile", "extvertImage", "extrateImage", "compressImage", "extvertText", "compractLayer", "extractLayer", "extractFile", "compractImage", "compressText", "compractFile", "compractText"], "input": ["dc", "In", "pull", "temp", "media", "ini", "string", "include", "IN", "current", "qa", "API", "request", "view", "xml", "inner", "bin", "src", "path", "empty", "address", "command", "audio", "amp", "init", "base", "rc", "out", "prefix", "tmp", "url", "work", "config", "DATA", "standard", "Input", "inside", "i", "ink", "image", "SOURCE", "sin", "inf", "img", "reader", "data", "type", "raw", "picture", "PUT", "null", "OUT", "id", "inc", "RAW", "source", "parent", "text", "form", "file"], "output": ["resource", "temp", "external", "exit", "string", "current", "secret", "response", "path", "STDOUT", "address", "dir", "unit", "document", "out", "prefix", "config", "name", "password", "filename", "image", "format", "page", "result", "write", "target", "message", "parent", "source", "generated", "text", "version", "file", "Output"], "params": ["names", "dis", "si", "words", "resources", "pi", "mos", "py", "results", "xml", "pixel", "spec", "http", "options", "manager", "ctx", "api", "Param", "param", "details", "attr", "styles", "json", "properties", "plugins", "theme", "afi", "p", "batch", "proc", "s", "ams", "pins", "Parameters", "vs", "base", "phrase", "phys", "server", "config", "settings", "processor", "services", "lp", "i", "Par", "features", "rules", "bis", "reader", "lis", "data", "parts", "obj", "mm", "ps", "conf", "las", "fps", "ras", "par", "photos", "pro", "lc", "models"], "w": ["pipe", "temp", "wi", "we", "kw", "wt", "war", "wh", "nw", "m", "xml", "wx", "wave", "wa", "wcs", "wd", "world", "wal", "wp", "p", "sw", "fw", "out", "wic", "work", "aw", "ws", "f", "hw", "rw", "worker", "writer", "widget", "reader", "write", "W", "web", "wl", "wb", "wm", "ow"], "in": ["fa", "In", "temp", "inas", "again", "n", "ini", "qa", "IN", "m", "cin", "include", "ex", "din", "bin", "ani", "con", "pin", "ins", "ac", "min", "conn", "inn", "p", "kin", "err", "connection", "init", "win", "rin", "lin", "out", "part", "mc", "isin", "gin", "config", "thin", "f", "cgi", "index", "inside", "cli", "i", "nin", "image", "socket", "login", "ssl", "img", "arin", "data", "vin", "ai", "null", "b", "r", "inc", "id", "source", "binary", "src", "file"], "dest": ["dc", "resource", "txt", "temp", "done", "folder", "dis", "route", "exit", "project", "rest", "dat", "gui", "d", "din", "dist", "destroy", "dep", " Dest", "desc", "di", "path", "die", "doc", "wd", "coord", "dir", "loc", "sup", "comb", "default", "decl", "tmp", "delete", "config", "flat", "home", "dom", "Dest", "remote", "img", "st", "test", "style", "target", "beta", "de", "nam", "prop", "null", "id", "source", "parent", "wb", "cont", "src", "name"], "bi": ["fa", "ib", "wi", "bh", "nb", "si", "chi", "Bi", "qi", "bs", "ini", "ii", "pi", "dat", " bio", "bin", "bank", "abi", "BI", "ci", "di", "agi", "obi", "vi", "ji", "pin", "oci", "umi", "cu", "phi", "gb", "ki", "ga", "fi", "eni", "bc", "sb", "cli", "bas", "isi", "bid", "oi", "i", "li", "ori", "ni", "gi", "bis", "mini", "wei", "ti", "ai", "b", "zi", "xi", "ba", "info", "mu", "bm"], "os": ["ks", "us", "ios", "bs", "so", "osi", "ob", "o", "dos", "oa", "is", "fits", "oss", "as", "io", "co", "outs", "ors", "aos", "xs", "bos", "oes", " bos", "oos", "fs", "obs", "s", "pos", "nos", "out", "oS", "los", "vs", "ops", "cos", "cs", "ws", "ot", "Os", "i", "ds", "ns", "des", "oses", "ou", "es", "OS"]}}
{"id1": "3375722", "id2": "9526031", "code1": "    public void importarSetor(File pArquivoXLS, String pCabecalhoSetor, Andamento pAndamento) throws FileNotFoundException, IOException, SQLException, InvalidFormatException {\n        int iLinha = -1;\n        Statement stmtLimpezaInicialDestino = null;\n        OraclePreparedStatement stmtDestino = null;\n        try {\n            Workbook arquivo = WorkbookFactory.create(new FileInputStream(pArquivoXLS));\n            Sheet plan1 = arquivo.getSheetAt(0);\n            int QUANTIDADE_DE_REGISTROS_DE_CABECALHO = 7;\n            int QUANTIDADE_DE_REGISTROS_DE_RODAPE = 14;\n            int QUANTIDADE_DE_REGISTROS_DE_METADADOS = QUANTIDADE_DE_REGISTROS_DE_CABECALHO + QUANTIDADE_DE_REGISTROS_DE_RODAPE;\n            int quantidadeDeRegistrosEstimada = plan1.getPhysicalNumberOfRows() - QUANTIDADE_DE_REGISTROS_DE_METADADOS;\n            String vSetor = \"\", vSubsetor = \"\", vSegmento = \"\";\n            LinhaDaPlanilhaDosSetores registroAtual;\n            int vPapeisPorSegmento = 0;\n            stmtLimpezaInicialDestino = conDestino.createStatement();\n            String sql = \"TRUNCATE TABLE TMP_TB_SETOR_SUBSETOR_SEGMENTO\";\n            stmtLimpezaInicialDestino.executeUpdate(sql);\n            sql = \"INSERT INTO TMP_TB_SETOR_SUBSETOR_SEGMENTO(SIGLA_EMPRESA, NOME_SETOR, NOME_SUBSETOR, NOME_SEGMENTO) VALUES(:SIGLA_EMPRESA, :NOME_SETOR, :NOME_SUBSETOR, :NOME_SEGMENTO)\";\n            stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosImportados = 0;\n            iLinha = 8;\n            while (true) {\n                registroAtual = new LinhaDaPlanilhaDosSetores(plan1.getRow(iLinha));\n                if (registroAtual.nomeDoSetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    if (registroAtual.nomeDoSubsetor.equalsIgnoreCase(\"\")) {\n                        break;\n                    } else {\n                        vSetor = registroAtual.nomeDoSetor;\n                        vSubsetor = null;\n                        vSegmento = null;\n                    }\n                }\n                if (registroAtual.nomeDoSubsetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    vSubsetor = registroAtual.nomeDoSubsetor;\n                    vSegmento = null;\n                }\n                String nomeDoSegmento = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (nomeDoSegmento.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && registroAtual.siglaDaEmpresa.equals(\"\")) {\n                    if (vSegmento != null && vPapeisPorSegmento == 0) {\n                        vSegmento = vSegmento + \" \" + nomeDoSegmento;\n                    } else {\n                        vSegmento = nomeDoSegmento;\n                    }\n                    vPapeisPorSegmento = 0;\n                }\n                String nomeDaEmpresa = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (registroAtual.siglaDaEmpresa.length() == 4 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && !nomeDaEmpresa.equals(\"\")) {\n                    String vCodneg = registroAtual.siglaDaEmpresa;\n                    stmtDestino.clearParameters();\n                    stmtDestino.setStringAtName(\"SIGLA_EMPRESA\", vCodneg);\n                    stmtDestino.setStringAtName(\"NOME_SETOR\", vSetor);\n                    stmtDestino.setStringAtName(\"NOME_SUBSETOR\", vSubsetor);\n                    stmtDestino.setStringAtName(\"NOME_SEGMENTO\", vSegmento);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    vPapeisPorSegmento++;\n                }\n                iLinha++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoXLS.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = iLinha;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    public boolean register(Object o) {\n        String passwordAsText;\n        if (o == null) throw new IllegalArgumentException(\"object cannot be null\");\n        if (!(o instanceof User)) {\n            throw new IllegalArgumentException(\"passed argument is not an instance of the User class\");\n        }\n        User newUser = (User) o;\n        passwordAsText = newUser.getPassword();\n        newUser.setPassword(passwordEncoder.encodePassword(passwordAsText, null));\n        newUser.setRegDate(new Date());\n        logger.debug(\"Setting default Authority {} to new user!\", Authority.DEFAULT_NAME);\n        newUser.getAuthorities().add(super.find(Authority.class, 1));\n        logger.debug(\"Creating hash from email address! using Base64\");\n        newUser.setHash(new String(Base64.encodeBase64(newUser.getEmail().getBytes())));\n        logger.debug(\"Creating phpBB forum User, by calling URL: {}\", forumUrl);\n        try {\n            StringBuilder urlString = new StringBuilder(forumUrl);\n            urlString.append(\"phpBB.php?action=register\").append(\"&login=\").append(newUser.getLogin()).append(\"&password=\").append(passwordAsText).append(\"&email=\").append(newUser.getEmail());\n            sqlInjectionPreventer(urlString.toString());\n            logger.debug(\"Connecting to URL: {}\", urlString.toString());\n            URL url = new URL(urlString.toString());\n            URLConnection urlCon = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlCon.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) newUser.setForumID(Integer.valueOf(inputLine));\n            in.close();\n        } catch (IOException io) {\n            logger.error(\"Connecting failed! Msg: {}\", io.getMessage());\n            throw new RuntimeException(\"Couldn't conntect to phpBB\");\n        } catch (NumberFormatException e) {\n            logger.error(\"phpBB user generation failed! Msg: {}\", e.getMessage());\n            throw new RuntimeException(\"phpBB user generation failed!\");\n        }\n        entityManager.persist(newUser);\n        try {\n            sendConfirmationEmail(newUser);\n            return true;\n        } catch (MailException ex) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"importarSetor": [" importTarsetorn", " importarProcessutor", " importTarsetori", " importTarSetorn", " importTarsetutor", " importarsetorn", " importarProcessori", " importarProcessorn", " importarStructutor", " importTarSetutor", " importarStructor", " importTarsetor", " importarSetutor", " importTarSetor", " importarsetori", " importarStructori", " importarSetorn", " importTarSetori", " importarStructorn", " importarSetori", " importarsetutor", " importarProcessor", " importarsetor"], "pArquivoXLS": ["pArquivaXLS", "pArquivaXSL", "pArquivoZXls", "pArquivoYls", "pArquivoEXCL", "pArquivaEXCL", "pArquivaXls", "pArquivoXML", "pArquivaEXls", "pArquivoTXML", "pArquivoYLS", "pArquivoYML", "pArquivoXls", "pArquivoYCL", "pArquivoZXSL", "pArquivoTXCL", "pArquivoXSL", "pArquivoEXls", "pArquivaEXML", "pArquivoZXLS", "pArquivoEXSL", "pArquivoEXLS", "pArquivaXML", "pArquivoTXls", "pArquivaXCL", "pArquivoXCL", "pArquivaEXLS", "pArquivoEXML", "pArquivoTXSL", "pArquivoZXML", "pArquivoTXLS", "pArquivaEXSL"], "pCabecalhoSetor": ["pCabecalhaSelector", "pCabecalhaSeteur", "pCabecalhaSelecteur", "pCabecalhaSelectors", "pCabecalhoEditeur", "pCabecalhoSelecteur", "pCabecalhoSetors", "pCabecalhaSete", "pCabecalhaSetor", "pCabecalhoSete", "pCabecalhaSetors", "pCabecalhoSelector", "pCabecalhoEditors", "pCabecalhoEdite", "pCabecalhoSeteur", "pCabecalhaSelecte", "pCabecalhoEditor", "pCabecalhoSelecte", "pCabecalhoSelectors"], "pAndamento": ["pAndmentO", "pAndemento", "pAndmentos", "pAndementO", "pAndementono", "pAndamentono", "pOramentO", "pOrementono", "pAndamentO", "pAndietono", "pAndamentos", "pAndementos", "pOramento", "pAndietos", "pOremento", "pAndmentono", "pAndieto", "pAndietO", "pAndmento", "pOrementos", "pOrementO", "pOramentos", "pOramentono"], "iLinha": ["iFranya", "iMalHa", "iFranha", "iMaleno", "iLineno", "NumLinya", "NumPlaneno", "iLinHa", "iPlanha", "NumPlanya", "NumLinHa", "iPlaneno", "NumPlanHa", "iMalha", "iMalya", "iPlanHa", "NumLineno", "NumPlanha", "iFranHa", "iPlanya", "iFraneno", "iLinya", "NumLinha"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialCombaco", "stmtLimpezaInicioDestania", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialDestaco", "stmtLimpezaIniciaDestination", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialdestination", "stmtLimpezaIniciodestina", "stmtLimpezaInicialDestania", "stmtLimpezaInicialdestania", "stmtLimpezaIniciodestino", "stmtLimpezaInicioDestaco", "stmtLimpezaIniciadestination", "stmtLimpezaInicialDesination", "stmtLimpezaInicialdestino", "stmtLimpezaInicialDestina", "stmtLimpezaInicialdestin", "stmtLimpezaInicialESTin", "stmtLimpezaIniciodestaco", "stmtLimpezaInicialDestin", "stmtLimpezaInicialESTination", "stmtLimpezaInicialDesania", "stmtLimpezaInicialCombINO", "stmtLimpezaInicioDestino", "stmtLimpezaIniciaDestin", "stmtLimpezaInicialESTino", "stmtLimpezaInicialCombina", "stmtLimpezaIniciodestination", "stmtLimpezaInicialESTaco", "stmtLimpezaInicioDestina", "stmtLimpezaIniciadestaco", "stmtLimpezaInicialdestaco", "stmtLimpezaInicialDestination", "stmtLimpezaInicialDestINO", "stmtLimpezaInicialdestina", "stmtLimpezaInicioDestINO", "stmtLimpezaInicialDesINO", "stmtLimpezaInicialdestINO", "stmtLimpezaInicialDesino", "stmtLimpezaInicioDestination", "stmtLimpezaIniciadestino", "stmtLimpezaIniciodestINO", "stmtLimpezaIniciadestin", "stmtLimpezaIniciodestania", "stmtLimpezaInicialCombino"], "stmtDestino": ["stmpDestino", "stmtDestinning", "stmrdestinning", "stmdestin", "stmtRestin", "stmtRestino", "stmtdestinos", "stmtLocationaco", "stmtDestorno", "stmtDistINO", "stmtLocationinning", "stmpDestorno", "stmtdestin", "stmtdestino", "stmtCombino", "stmtRestaco", "stmdestinos", "stmDestino", "stmpdestorno", "stmrDestaco", "stmtLocationino", "stmrdestINO", "stmtDestaco", "stmtDestin", "stmtdestaco", "stmpDestINO", "stmDestin", "stmtdestorno", "stmDestinos", "stmpdestINO", "stmrdestino", "stmtRestinos", "stmtCombinos", "stmtLocationINO", "stmtDestINO", "stmtRestinning", "stmtdestinning", "stmtDistorno", "stmdestino", "stmpDestaco", "stmtdestINO", "stmdestINO", "stmtDestinos", "stmpdestaco", "stmtDistino", "stmtRestINO", "stmpdestino", "stmDestINO", "stmrdestaco", "stmtDistaco", "stmtCombINO", "stmrDestinning", "stmrDestINO", "stmrDestino", "stmtCombin"], "arquivo": ["arqarius", " ar\u00e7ivo", "Arqoso", " arQuicio", "Arqico", "arqico", "Arqiva", "Arquico", "arquiva", " arqiva", " arQuivo", "arQuoso", " arquiva", "Arquiva", " arquarius", "Arqivo", "arqivo", "arqiva", "arQuivo", "arQuico", " arQuiva", " arqarius", "arquoso", "Arquivo", " arquicio", "arQUico", " ar\u00e7iva", "arquarius", "arQUiva", "arquico", " ar\u00e7icio", "arQUivo", " arqicio", "arqicio", "arQuiva", " arqivo", "arQUoso", " arQuarius", "arqoso", "arquicio", "Arquoso", " ar\u00e7arius"], "plan1": [" Plan2", "planOne", "plan2", "product0", "plan0", "Plan0", "planName", "Plan1", "productName", "Plan2", "product2", " Plan1", " planOne", "PlanName", " plan2", " PlanOne", "product1", " planName", " plan0", " Plan0", "PlanOne"], "QUANTIDADE_DE_REGISTROS_DE_CABECALHO": ["QUANTIDADE_DE_REGISTROSAD", "QUANTIDADE_DE_REGISTERO__", "QUANTIDADE_DE_REGISTEROSAD", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTRONS_", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTROS__", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRO__", "QUANTIDADE_DE_REGISTRATES__", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTRASAD", "QUANTIDADE_DE_REGISTEROS__", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTRosAD", "QUANTIDADE_DE_REGISTRosJ", "QUANTIDADE_DE_REGISTROAD", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTRONS__", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTEROAD", "QUANTIDADE_DE_REGISTRASJ"], "QUANTIDADE_DE_REGISTROS_DE_RODAPE": ["QUANTIDADE_DE_REGISTROs_", "QUANTIDADE_DE_REGISTRosEC", "QUANTIDADE_DE_REGISTEROEC", "QUANTIDADE_DE_REGISTROsJ", "QUANTIDADE_DE_REGISTRYOSJ", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTROSEC", "QUANTIDADE_DE_REGISTROEC", "QUANTIDADE_DE_REGISTEROSEC", "QUANTIDADE_DE_REGISTRYOS_", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRYAS_", "QUANTIDADE_DE_REGISTROsEC", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTRosJ", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTRYASJ", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTRASJ"], "QUANTIDADE_DE_REGISTROS_DE_METADADOS": ["QUANTIDADE_DE_REGISTRON_", "QUANTIDADE_DE_REGISTRESJ", "QUANTIDADE_DE_REGISTRATESEC", "QUANTIDADE_DE_REGISTRosID", "QUANTIDADE_DE_REGISTEROEC", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTEROSID", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTROSEC", "QUANTIDADE_DE_REGISTROEC", "QUANTIDADE_DE_REGISTEROSEC", "QUANTIDADE_DE_REGISTRONID", "QUANTIDADE_DE_REGISTROSID", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTEROID", "QUANTIDADE_DE_REGISTRESEC", "QUANTIDADE_DE_REGISTRES_", "QUANTIDADE_DE_REGISTRATESJ", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROID", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTEROSJ"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstifator", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstifada", "quantidadeDeRegistrosEstifado", "quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstimator", "quantidadeDeRegistrosEstivator", "quantidadeDeRegistrosEstifadas", "quantidadeDeRegistrosEstimmator", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstivado"], "vSetor": ["vShiporing", "vSelector", " vSetoring", "vSelectoring", "vShipors", "vShipe", "vSetors", " vSetors", "vSetoring", "vSelecte", "vSelectors", " vSete", "vShipor", "vSete"], "vSubsetor": ["vSubjecto", "vsubscor", "vSubjector", "vSubscr", "vSubscripto", "vsubsetr", "vsubsetors", "vSubscriptr", "vsubsco", "vSubsetr", "vSubseto", "vsubscors", "vSubscor", "vSubscriptor", "vSubscriptors", "vSubjectr", "vsubseto", "vSubjectors", "vsubscr", "vSubsetors", "vSubsco", "vSubscors", "vsubsetor"], "vSegmento": ["vGamento", "vGmento", "vSegMENTos", "vGamentor", "vSegmentationo", "vSegmentationos", "vSegmentos", "vSegMENTor", "vSegmentationa", "vGamentos", "vSegamento", "vSegMENTa", "vGamenta", "vSegmentationor", "vSegamenta", "vSegMENTo", "vSegamentos", "vGmentor", "vGmenta", "vSegamentor", "vSegmenta", "vGmentos", "vSegmentor"], "registroAtual": ["RegistrosAtUAL", "RegistroGenional", "RegistrosatUAL", "RegistroGenUAL", "RegistroGenial", "Registrosatual", "RegistrosAtual", "RegistroAtUAL", "RegistroatUAL", "RegistroAtual", "Registrosatial", "RegistroAtional", "RegistroExUAL", "RegistrosAtial", "RegistroAtial", "Registroatial", "RegistroExual", "Registroational", "RegistroExial", "Registroatual", "RegistroGenual", "RegistrosAtional", "Registrosational", "RegistroExional"], "vPapeisPorSegmento": ["vPapeisPorFragmentos", "vPapeisPorSegmentor", "vPapeisPorSegmentationo", "vPapeisPorSegmentatione", "vPapeisPorSegamento", "vPapeisPorSegamentor", "vPapeisPorSegamentos", "vPapeisPorFragmentor", "vPapeisPorFragmente", "vPapeisPorSegmentsor", "vPapeisPorFragmentsor", "vPapeisPorFragmentsos", "vPapeisPorFragmento", "vPapeisPorSegmente", "vPapeisPorSegmentso", "vPapeisPorSegmentse", "vPapeisPorSegmentationor", "vPapeisPorSegmentsos", "vPapeisPorFragmentse", "vPapeisPorSegmentationos", "vPapeisPorSegmentos", "vPapeisPorSegamente", "vPapeisPorFragmentso"], "sql": ["section", "seed", "serv", "description", "zip", "string", "SQL", "pr", "statement", "sf", " SQL", "select", "str", "comment", "dl", "spec", "script", "eps", "http", "msg", "log", "params", "os", "util", "sol", "slice", "json", "spr", "s", "base", "csv", "setup", "ls", "layout", "install", "shell", "query", "sn", "QL", "url", "where", "sl", "sb", "nl", "html", "ssl", "data", "sg", "acl", "sv", "term", "ql", "id", "body", "ln", "db", "sq"]}}
{"id1": "2808955", "id2": "12242903", "code1": "    @Override\n    public EntrySet read(EntrySet set) throws ReadFailedException {\n        if (!SourceCache.contains(url)) {\n            SSL.certify(url);\n            try {\n                super.setParser(Parser.detectParser(url.openStream()));\n                final PipedInputStream in = new PipedInputStream();\n                final PipedOutputStream forParser = new PipedOutputStream(in);\n                new Thread(new Runnable() {\n\n                    public void run() {\n                        try {\n                            OutputStream out = SourceCache.startCaching(url);\n                            InputStream is = url.openStream();\n                            byte[] buffer = new byte[100000];\n                            while (true) {\n                                int amountRead = is.read(buffer);\n                                if (amountRead == -1) {\n                                    break;\n                                }\n                                forParser.write(buffer, 0, amountRead);\n                                out.write(buffer, 0, amountRead);\n                            }\n                            forParser.close();\n                            out.close();\n                            SourceCache.finish(url);\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }).start();\n                super.setIos(in);\n            } catch (Exception e) {\n                throw new ReadFailedException(e);\n            }\n            return super.read(set);\n        } else {\n            try {\n                return SourceCache.get(url).read(set);\n            } catch (IOException e) {\n                throw new ReadFailedException(e);\n            }\n        }\n    }\n", "code2": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "label": 0, "substitutes": {"read": ["ping", "resource", "reads", "run", "ry", "stream", "scan", "send", "readable", "current", "reading", "request", "fill", "select", "view", "http", "input", "copy", "READ", "ic", "search", "open", "feed", "add", "process", "skip", "content", "build", "play", "print", "Read", "weak", "exec", "find", "query", "get", "load", "work", "wait", "index", "iter", "start", "check", "close", "socket", "next", "reader", "parse", "write", "data", "es", "update", "block", "create"], "set": ["resource", "entry", "or", "setting", "use", "seed", "send", "cache", "site", "context", "spec", "sets", "src", "state", "sync", "object", "store", "rule", "init", "base", "setup", "server", "url", "get", "load", "config", "SET", "size", "settings", "ut", "session", "start", "reset", "ssl", "test", "type", "parse", "id", "source", "update", "et", "name", "end"], "in": ["resource", "In", "pull", "again", "ini", "cache", "IN", "inner", "bin", "input", "ic", "con", "io", "pin", "ins", "on", "min", "inn", "p", "it", "init", "win", "url", "gin", "f", "i", "image", "socket", "login", "ssl", "reader", "data", "spin", "inc", "id", "source", "client", "src", "file"], "forParser": ["ofListener", " forReader", "ofJar", "withFile", "ForFile", " forJar", "forReader", "ForListener", "withJar", "withparser", "ForJar", "forJar", "forparser", "foreReader", "foreParser", " forparser", "ofReader", "forFile", "foreparser", "forListener", "foreMaster", "Forparser", "ForMaster", "forMaster", "ForParser", "ofParser", " forFile", "withParser", " forListener", "ForReader", " forMaster"], "out": ["again", "cache", "o", "ex", "http", "inner", "bin", "Out", "copy", "outer", "log", "io", "can", "os", "outs", "co", "sync", "conn", "err", "up", "app", "init", "net", "exec", "url", "cli", "i", "image", "socket", "writer", "to", "page", "ssl", "output", "ext", "OUT", "null", "inc", "parent", "source", "client", "file"], "is": ["ib", "or", "us", "ip", "isa", "ios", "im", "bs", "ois", "isl", "ir", "was", "iris", "ci", "as", "has", "api", "ais", "os", "IS", "ui", "ins", "ri", "are", "does", "fs", "isin", "s", "Is", "vs", "iss", "url", "its", "isi", "i", "sin", "bis", "lis", "ai", "ps", "id", "ris"], "buffer": ["slave", "seed", "cache", "channel", "uffer", "limit", "padding", "bin", "delay", "layer", "feed", "sequence", "buf", "queue", "slice", "length", "repeat", "address", "count", "batch", "base", "phrase", "server", "url", "size", "Buffer", "iter", "bytes", "border", "page", "memory", "counter", "reader", "transfer", "data", "null", "buff", "offset", "source", "binary", "info", "uri", "reference"], "amountRead": ["enoughReader", "lengthRead", "poolWrite", "amountLoad", "AmountWrite", "amountReader", "weightReader", "poolLoad", "AmountStart", "weightLoad", " numberLoad", "poolRead", "numberRead", "amountBuild", "AmountReader", " amountReader", "AmountLoad", " amountStart", "AmountRead", "numberReader", "weightRead", " numberRead", " numberWrite", " amountWrite", "AmountHandle", "weightBuild", "numberLoad", " amountBuild", "AmountBuild", "enoughRead", "numberWrite", "poolReader", "lengthWrite", "enoughWrite", "lengthLoad", "lengthHandle", " amountLoad", "amountStart", "enoughStart", " numberHandle", "amountHandle", "amountWrite"]}}
{"id1": "20019847", "id2": "539195", "code1": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyBuffer", " copyFiles", "copyBuffer", " copyingSource", " copyingFile", " copiedFile", " copiedBuffer", " copiedSource", "copyFiles", " copyingFiles", " copiedFiles", "copySource", " copyingBuffer", " copySource"], "source": ["resource", "scene", "slave", "route", "use", "seed", "project", "string", "current", "site", "channel", "Source", "inner", "service", "input", "copy", "ource", "from", "slice", "object", "archive", "unit", "grade", "connection", "base", "server", "url", "config", "size", "before", "SOURCE", "start", "sin", "reader", "se", "null", "id", "parent", "stream", "src", "name", "file", "origin"], "target": ["timeout", "resource", "temp", "project", "pointer", "path", "dest", "arget", "compatible", "download", "object", "conn", "content", "archive", "that", "goal", "connection", "net", "base", "port", "server", "config", "director", "socket", "Target", "to", "remote", "result", "next", "output", "reference", "point", "end", "parent", "master", "src", "file", "template"], "in": ["In", "pull", "again", "n", "c", "IN", "rec", "m", "is", "din", "inner", "bin", "input", "as", "io", "pin", "sync", "ins", "impl", "min", "conn", "inn", "ie", "err", "up", "init", "win", "rin", "url", "f", "inside", "i", "nin", "socket", "sin", "login", "file", "reader", "r", "b", "inc", "id", "src"], "out": ["temp", "again", "outside", "n", "c", "channel", "o", "ex", "bin", "Out", "copy", "outer", "io", "outs", "sync", "conn", "err", "connection", "w", "net", "init", "exec", "x", "other", "off", "i", "image", "lib", "check", "writer", "plain", "v", "output", "write", "obj", "OUT", "b", "point", "t", "inc", "parent", "client", "file", "extra"]}}
{"id1": "13012591", "id2": "16092702", "code1": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"getPasswordHash": ["getPasswordhash", "getHashSum", " getPasswordSum", " getPasswordSecret", "getHashHash", "getPasswordSecret", "getStringhash", "getPasswordSum", "getpasswordHash", " getPasswordhash", " getpasswordHash", "getStringSum", "getStringHash", "getpasswordhash", "getHashSecret", " getpasswordhash", "getpasswordSum", "getpasswordSecret", "getStringSecret", "getHashhash", " getpasswordSum", " getpasswordSecret"], "password": ["pass", "attribute", "token", "username", "words", "sword", "string", "cache", "word", "secret", "input", "Password", "PASS", "path", "key", "number", " passwords", "auth", "database", "email", "wd", "user", "content", "address", "p", "prefix", "phrase", "security", "config", "array", "confirmed", "code", "data", "account", "message", "pattern", "buffer", "crypt", "text", "source", "name", "padding"], "md": ["dc", "mb", "mg", "mp", "pd", "mage", "pm", "ms", "od", "mand", "cm", "mac", "map", "m", "mem", "sm", " MD", "d", "sha", "hm", "MD", "bd", "meta", "alg", "hd", "ad", "dd", "ld", "mc", "amp", "gb", "mod", "cmd", "dh", "dr", "ma", "mag", "pkg", "arm", "gd", "gm", "dm", "material", "nm", "amd", "dig", "mm", "metadata", "vd", "mt", "mu", "bm", "db", "mo"], "hash": ["body", "row", "mask", "bh", "hed", "sh", "mac", "cache", "map", "Hash", "host", "secret", "total", "cover", "sha", "sum", "search", "match", "hex", "key", "number", "ashes", "length", "address", "square", "header", "kh", "build", "count", "batch", "carry", "ha", "url", "query", "ash", "array", "index", "code", "image", "h", "check", "dot", "html", "filter", "handle", "diff", "error", "data", "dig", "message", "block"], "buf": ["bh", "nb", "aux", " buffer", "cas", "pb", "cv", "bin", "src", "conv", "abi", "ctx", "abs", "box", "pad", "cf", "bp", "ab", "book", "br", "bag", "ff", "tmp", "bc", "sb", "Buffer", "f", "array", "af", "pkg", "home", "uf", "cap", "h", "cb", "fp", "v", "bb", "img", "data", "Buff", "b", "fb", "buff", "bf", "buffer", "va", "rb", "db", "ref"], "i": ["hi", "si", "chi", "qi", "ip", "u", "multi", "k", "c", "ii", "m", "pi", "o", "d", "abi", "ci", "di", "io", "vi", "ui", "ji", "ri", "length", "bi", "p", "it", "l", "phi", "s", "j", "I", "eni", "x", "uli", "fi", "index", "f", "field", "e", "oi", "li", "h", "v", "gi", "ti", "data", "ai", "r", "b", "xi", "t", "id", "uri", "mu", "end"]}}
{"id1": "7757297", "id2": "19739421", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"submit": ["run", "accept", "send", "register", "execute", "request", "input", "report", "open", "process", "post", "download", "init", " submission", "complete", "success", "start", "close", "login", "apply", "save", "type", "write", "sub", "update", "Submit", "form"], "uri": ["resource", " ur", "route", "username", " Uri", "description", "string", "href", "http", "xml", "response", "URL", "path", "report", "api", "io", "ui", "absolute", "Url", "database", "ri", "address", "URI", "base", " URI", "server", "location", "cli", "i", "filename", "iri", "format", "directory", "data", "plugin", "duration", "id", "message", "source", "text", "file"], "Exception": ["Response", " exception", "Null", "Application", "Adapter", "Description", "Connection", "Request", "A", "Problem", "Error", "Exit", "Document", "Except", "Ex", "except", "ception", "Interface", "ceptions", "Record", "Transaction", "Event", "Exc", "Timeout", "End"], "encodedrdf": ["encodedrtf", "encodedudf", "encodingrdF", "encodedrtrf", "encodedudrf", "encoderdf", "encodedrrrf", "encodedwdF", "encodedudef", "encodedvrF", "encodedvrrf", "encodedwdf", "encodedude", "encodedwdbf", "encodedrde", "encodedrdef", "encodingrdbf", "encodedrtbf", "encodedrdF", "encodingrdrf", "encodingrdf", "encodeudrf", "encoderde", "encodingwdF", "encodedrre", "encodedvrf", "encodedwdef", "encodeudf", "encoderdrf", "encodedwde", "encoderdef", "encodingwdrf", "encodingwdf", "encodedvrbf", "encodingwdbf", "encodedrref", "encodedwdrf", "encodedrrf", "encodeude", "encodedrtF", "encodedrdbf", "encodedrdrf", "encodeudef"], "url": ["resource", "use", "position", "string", "Connection", "channel", "http", "proxy", "service", "URL", "path", "contact", "open", "text", "Url", "relation", "database", "conn", "user", "address", "loc", "l", "base", "server", "location", "config", "link", "control", "session", "image", "connect", "socket", "page", "ssl", "job", "source", "client", "name", "file"], "connection": ["or", "application", "use", " Connection", "section", "function", "position", "n", "c", "Connection", "channel", "string", "context", "http", "proxy", "character", "service", "condition", "response", "URL", "con", "io", "open", "contact", "number", "driver", "in", "database", "relation", "client", "conn", "handler", "loc", "l", "document", "communication", "server", "config", "link", "session", "password", "connect", "socket", "writer", "directory", "b", "connected", "source", "text", "org", "version"], "lastUser": ["lastRow", "LastCategory", "lastCategory", " lastRow", " lastWord", "LastWord", "latestRow", "latestWord", " lastCategory", "LastRow", "latestUser", "latestCategory", "lastWord", "LastUser"], "out": ["again", "global", "full", "view", "call", "log", "w", "prefix", "pool", "image", "check", "writer", "plain", "socket", "error", "write", "flush", "file", "external", "cache", "o", "comment", "bin", "outer", "io", "user", "init", "office", "dump", "off", "password", "editor", "page", "login", "output", "data", "OUT", "req", "extra", "at", "word", "exp", "copy", "down", "outs", "sync", "doc", "no", "part", "cli", "obj", "lock", "client", "name", "temp", "window", "line", "inner", "Out", "key", "list", "in", "conn", "err", "up", "cmd", "exec", "server", "commit", "wrapper", "result", "builder"]}}
{"id1": "21531069", "id2": "2198730", "code1": "    public int updateuser(User u) {\n        int i = 0;\n        Connection conn = null;\n        PreparedStatement pm = null;\n        try {\n            conn = Pool.getConnection();\n            conn.setAutoCommit(false);\n            pm = conn.prepareStatement(\"update user set username=?,passwd=?,existstate=?,management=? where userid=?\");\n            pm.setString(1, u.getUsername());\n            pm.setString(2, u.getPasswd());\n            pm.setInt(3, u.getExiststate());\n            pm.setInt(4, u.getManagement());\n            pm.setString(5, u.getUserid());\n            i = pm.executeUpdate();\n            conn.commit();\n            Pool.close(pm);\n            Pool.close(conn);\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            Pool.close(pm);\n            Pool.close(conn);\n        } finally {\n            Pool.close(pm);\n            Pool.close(conn);\n        }\n        return i;\n    }\n", "code2": "    public void importCSV(InputStream csvfile) throws Exception {\n        try {\n            String[] qmarks = new String[columns.length];\n            for (int i = 0; i < qmarks.length; i++) {\n                qmarks[i] = \"?\";\n            }\n            if (cleartable) {\n                String delsql = \"delete from \" + table;\n                Statement delstm = conn.createStatement();\n                delstm.executeUpdate(delsql);\n            }\n            String sql = \"insert into \" + table + \" (\" + StringUtils.join(columns, \", \") + \") values (\" + StringUtils.join(qmarks, \", \") + \")\";\n            log.debug(\"SQL: \" + sql);\n            PreparedStatement stm = conn.prepareStatement(sql);\n            int datatypes[] = new int[columns.length];\n            for (int i = 0; i < columns.length; i++) {\n                Table tbl = project.getTableByName(table);\n                if (tbl == null) throw new OntopiaRuntimeException(\"Unknown table: \" + table);\n                Column col = tbl.getColumnByName(columns[i]);\n                if (col == null) throw new OntopiaRuntimeException(\"Unknown table column: \" + columns[i]);\n                if (col.getType() == null) throw new OntopiaRuntimeException(\"Column type is null: \" + col.getType());\n                DataType datatype = project.getDataTypeByName(col.getType(), \"generic\");\n                if (datatype == null) throw new OntopiaRuntimeException(\"Unknown column type: \" + col.getType());\n                String dtype = datatype.getType();\n                if (\"varchar\".equals(dtype)) datatypes[i] = Types.VARCHAR; else if (\"integer\".equals(dtype)) datatypes[i] = Types.INTEGER; else throw new OntopiaRuntimeException(\"Unknown datatype: \" + dtype);\n            }\n            LineNumberReader reader = new LineNumberReader(new InputStreamReader(csvfile));\n            for (int i = 0; i < ignorelines; i++) {\n                String line = reader.readLine();\n                if (line == null) break;\n            }\n            log.debug(\"[\" + StringUtils.join(columns, \", \") + \"]\");\n            int lineno = 0;\n            while (true) {\n                lineno++;\n                String line = reader.readLine();\n                if (line == null) break;\n                try {\n                    String[] cols = StringUtils.split(line, separator);\n                    if (cols.length > columns.length && !ignorecolumns) log.debug(\"Ignoring columns: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    log.debug(\"CVALUES: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    String dmesg = \"(\";\n                    for (int i = 0; i < columns.length; i++) {\n                        String col = cols[i];\n                        if (stripquotes) {\n                            int len = col.length();\n                            if (len > 1 && ((col.charAt(0) == '\"' && col.charAt(len - 1) == '\"') || (col.charAt(0) == '\\'' && col.charAt(len - 1) == '\\''))) col = col.substring(1, len - 1);\n                        }\n                        if (col != null && col.equals(\"\")) col = null;\n                        dmesg = dmesg + col;\n                        if (i < columns.length - 1) dmesg = dmesg + \", \";\n                        stm.setObject(i + 1, col, datatypes[i]);\n                    }\n                    dmesg = dmesg + \")\";\n                    log.debug(dmesg);\n                    stm.execute();\n                } catch (Exception e) {\n                    conn.rollback();\n                    throw new OntopiaRuntimeException(\"Cannot read line \" + lineno + \": '\" + line + \"'\", e);\n                }\n            }\n            conn.commit();\n        } finally {\n            if (conn != null) conn.close();\n        }\n    }\n", "label": 1, "substitutes": {"updateuser": [" updateusers", "updateusers", "editUser", "UPDATEuser", " updateperson", "updateUser", "UPDATEperson", " updateUser", "editperson", "updateperson", "editusers", "edituser", "UPDATEusers", "UPDATEUser"], "u": ["eu", "iu", "us", "uu", "username", "n", "c", "m", "ru", "o", "uid", "U", "ur", "ue", "util", "ui", "cu", "user", " su", "p", "gu", "up", "l", "w", "du", "ut", "f", "cli", "fu", "e", "su", "ul", "h", "hu", "v", "ou", "tu", "b", "t", "users", "nu", "uri", "client", "mu", "lu", "un"], "i": ["iu", "hi", "si", "qi", "ip", "n", "ii", "c", "m", "pi", "ini", "o", "limit", "d", "ci", "di", "api", "ui", "ri", "bi", "count", "p", "it", "l", "phi", "j", "I", "fi", "f", "cli", "e", "oi", "li", "ori", "ni", "gi", "ti", "mi", "ai", "b", "xi", "t", "id", "info"], "conn": ["dc", "ch", "pc", "pn", "cat", "serv", "cm", "n", "c", "Connection", "pr", "pg", "ca", "act", "col", "Conn", "ann", "ci", "ctx", "con", "api", "pt", "co", "rt", "sync", "Connect", "ct", "oci", "ht", "client", "sql", "loc", "p", "cc", "cl", "connection", "mc", "cn", "rc", "cp", "Exec", "exec", "coll", "server", "cmd", "config", "Sync", "pool", "enc", "cli", "session", "Pool", "Con", "h", "close", "fp", "nt", "jp", "po", "mm", "nc", "lock", "connect", "db", "core", "lc", "MC"], "pm": ["mp", "pc", "LM", "ml", "pd", "vim", "cm", "rm", "m", "em", "pi", "PM", "pb", "pr", "py", "pg", "gp", " PM", "prem", "pl", "hm", "con", "mor", "pt", "px", "param", "pp", "mr", "om", "p", "vm", "wp", "mc", "cn", "pa", "mn", "pool", "cli", "lp", "fm", "am", "sem", "arm", "gm", "dm", "fp", "nm", "mi", "rpm", "mon", "jp", "prom", "module", "mm", "po", "wm", "bm", "db", "lc"]}}
{"id1": "19738435", "id2": "10540676", "code1": "    public Resource parse(URL url, IRDFContainer target) throws RDFException, IOException {\n        parseURL = url;\n        URLConnection connection = url.openConnection();\n        if (charset == null) {\n            charset = Charset.forName(\"UTF-8\");\n        }\n        Reader reader = new InputStreamReader(connection.getInputStream(), charset);\n        return internalParse(reader, target);\n    }\n", "code2": "    public static void checkForUpgrade(Event event) throws Exception {\n        ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"applyUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(false);\n        new Command(\"DELETE FROM TBLINSTALLATION WHERE STATUS<>'APPLIED'\").executeNonQuery();\n        String clientAppliedVersion = new Command(\"SELECT MAX(VERSION) FROM TBLINSTALLATION WHERE STATUS='APPLIED'\").executeScalarAsString();\n        if (NullStatus.isNull(clientAppliedVersion)) {\n            clientAppliedVersion = \"20050101\";\n        }\n        String macquery = \"\";\n        String clientMAC = \"\";\n        String clientUNITID = UiUtil.getUNITUID();\n        ArrayList<String> macList = getMacList();\n        for (int i = 0; i < macList.size(); i++) {\n            clientMAC += macList.get(i) + \",\";\n            macquery += \"'\" + macList.get(i) + \"'\";\n            if (i < macList.size() - 1) {\n                macquery += \",\";\n            }\n        }\n        URL urlLICENSEQUERY = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC + \"&tegsoftCOMMAND=LICENSEQUERY\");\n        URLConnection urlConnection = urlLICENSEQUERY.openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String commingList = \"\";\n        String line;\n        while ((line = in.readLine()) != null) {\n            commingList += line;\n        }\n        in.close();\n        String licenseArray[] = commingList.split(\"</ROW>\");\n        if (licenseArray.length > 0) {\n            String fields[] = licenseArray[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        Dataset TBLLICENSE = new Dataset(\"TBLLICENSE\", \"TBLLICENSE\");\n        Command command = new Command(\"DELETE FROM TBLLICENSE WHERE UNITUID={UNITUID} AND (NOTES IN (\");\n        command.append(macquery);\n        command.append(\") OR NOTES IS NULL) \");\n        command.executeNonQuery();\n        for (int i = 1; i < licenseArray.length; i++) {\n            String fields[] = licenseArray[i].split(\"</FLD>\");\n            String LICTYPE = fields[0];\n            String UNIQUEKEY = fields[1];\n            String LICKEY = fields[2];\n            DataRow dataRow = TBLLICENSE.addNewDataRow();\n            dataRow.set(\"LICENSENAME\", LICTYPE);\n            dataRow.set(\"LICENSE\", LICKEY);\n            dataRow.set(\"NOTES\", UNIQUEKEY);\n            TBLLICENSE.save();\n        }\n        URL url = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC);\n        urlConnection = url.openConnection();\n        in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String upgradeList = \"\";\n        while ((line = in.readLine()) != null) {\n            upgradeList += line;\n        }\n        in.close();\n        Dataset TBLINSTALLATION = new Dataset(\"TBLINSTALLATION\", \"TBLINSTALLATION\");\n        String upgrades[] = upgradeList.split(\"</ROW>\");\n        if (upgrades.length > 0) {\n            String fields[] = upgrades[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        boolean restartRequired = false;\n        boolean updateAvailable = false;\n        for (int i = 1; i < upgrades.length; i++) {\n            String fields[] = upgrades[i].split(\"</FLD>\");\n            String VERSION = fields[0];\n            String ORDERID = fields[1];\n            String UPGRADETYPE = fields[2];\n            String DESCRIPTION = fields[3];\n            String STATUS = \"UNAPPLIED\";\n            String PRDNAME = \"TegsoftCC\";\n            if (\"TEGSOFTJARS\".equals(UPGRADETYPE) || \"TOBEJARS\".equals(UPGRADETYPE) || \"ALLJARS\".equals(UPGRADETYPE) || \"CONFIGASTERISK\".equals(UPGRADETYPE)) {\n                restartRequired = true;\n            }\n            DataRow dataRow = TBLINSTALLATION.addNewDataRow();\n            dataRow.set(\"ORDERID\", ORDERID);\n            dataRow.set(\"PRDNAME\", PRDNAME);\n            dataRow.set(\"UPGRADETYPE\", UPGRADETYPE);\n            dataRow.set(\"VERSION\", VERSION);\n            dataRow.set(\"STATUS\", STATUS);\n            dataRow.set(\"DESCRIPTION\", DESCRIPTION);\n            TBLINSTALLATION.save();\n            updateAvailable = true;\n        }\n        UiUtil.getDataset(\"TBLINSTALLATION\").reFill();\n        if (restartRequired) {\n            ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(true);\n            ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(true);\n        }\n        if (updateAvailable) {\n            ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(true);\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_4));\n        } else {\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_5));\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["resource", "run", "instance", "request", "open", "match", "process", "from", "add", "replace", " parser", "find", "Parser", "get", "load", "read", "link", "arse", "set", "start", "format", "apply", "se", "pack", "parser", "source", "create"], "url": ["resource", "entry", "string", "channel", "host", "request", "http", "str", "proxy", "input", "URL", "path", "ur", "api", "feed", "io", "text", "absolute", "Url", "client", "object", "conn", "address", "l", "document", "base", "element", "server", "location", "config", "loader", "link", "e", " URL", "image", "page", "ssl", "error", "r", "uri", "stream", "source", "buffer", "src", "file"], "target": ["resource", "timeout", "root", " Target", "class", "container", "project", "resources", "host", "current", "context", "pointer", "response", "node", "path", "ctx", "this", "arget", "object", "content", "address", "document", "event", "component", "config", "format", "Target", "to", "result", "output", "data", "t", "parent", "source", "collection", "reference"], "parseURL": ["parseResource", " parseUrl", "parserType", "parserResource", "parseType", " parseResource", "parserUrl", "parseUrl", " parseType", "readUrl", "readResource", "parserURL", "readURL", "readType"], "connection": ["resource", "timeout", "or", "application", "section", "container", "function", "c", "Connection", "channel", "context", "character", "service", "response", "ion", "ctx", "con", "io", "open", "text", "database", "relation", "conn", "creator", "handler", "which", "normal", "out", "config", "bc", "pool", "director", "connect", "writer", "directory", "connected", "source", "uri", "client", "body", "db"], "charset": ["chasetter", "chARSect", "chaset", "CharsET", "chipset", "chipsets", "chasec", "charsets", "chanset", "choarset", "chansect", "chARSetter", "chaseting", "chasets", "Charsec", "Chaset", "chipseting", "choipseting", "chipsec", "chapterset", "chARSET", "choipset", "ChARSet", "Charset", "Charsect", "ChARSec", "Charsetter", "chaptersET", "charsetter", "Chasetter", "choarsets", "chaptersetter", "ChasET", "chipsET", "chARSet", "chaptersec", "choarsET", "chansET", "choipsets", "ChARSET", "charsET", "choipsET", "chipsect", "choarseting", "charseting", "charsect", "chansec", "chasET", "ChARSect", "charsec", "Chasec", "chARSec"], "reader": ["resource", "or", "row", "entry", "container", "channel", "context", "reading", "pointer", "oder", "ler", "input", "io", "feed", "driver", "in", "object", "keeper", "er", "handler", "server", "x", "loader", "read", "Reader", "per", "iter", "director", "i", "worker", "writer", "data", "rr", "r", "parser", "rar", "source", "stream"]}}
{"id1": "16820041", "id2": "755203", "code1": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"encodePassword": ["encodepassword", "enoderSecret", "enodepassword", "enoderString", "enccodePassword", "encodeString", "enoderPassword", "enodeString", "enodedSecret", "enccodeString", "enodedPassword", "enodedString", "enccodeSecret", "enoderpassword", "encodeSecret", "enodePassword", "enodeSecret", "enodedpassword", "enccodepassword"], "_originalPassword": ["_editedPassword", "_actualPass", "_encryptedSalt", "theorigPass", " _actualPass", "_originalpassword", "_originalPass", " _actualPassword", "_Originalpassword", "_OriginalSalt", " _originalSecret", "_encryptedPassword", " _actualSecret", "theoriginalPassword", "_encryptedpassword", "_origSalt", "theorigpassword", "_OriginalSecret", "theoriginalSalt", "theoriginalPass", "_editedSecret", "_origPassword", "_OriginalPass", "_actualSecret", "theorigPassword", "_encryptedPass", "_originalSecret", "_OriginalPassword", " _originalPass", "_editedPass", "_origPass", "theoriginalpassword", "theorigSalt", "_origpassword", "_actualPassword", "_originalSalt"], "md": ["dc", "df", "mb", "mg", "mp", "pd", "ms", "pm", "od", "mand", "cm", "mac", "Cmd", "m", "sm", " MD", "d", "sha", "hm", "MD", "bd", "pad", "meta", "alg", "hd", "ad", "dd", "ld", "ph", "mc", "gb", "cd", "mod", "cmd", "dh", "mn", "dr", "ma", "mag", "code", "gd", "dm", "hash", "amd", "data", "dig", "kg", "sd", "mm", "metadata", "vd", "id", "mad", "mt", "db", "mo"], "encodedPassword": ["enccodedPassword", "encapedString", "encodedpassword", "enoderSecret", "enryptedString", "encodedString", "enccodedpassword", "ecryptedPassword", "encidedSecret", "enoderPassword", "enodedSecret", "encryptedpassword", "enccodedSecret", "ecodedString", "encodedPass", "encidedPass", "encoderSecret", "encidedPassword", "enodedPass", "enodedPassword", "ecryptedString", "ecryptedSecret", "enodedString", "ecodedSecret", "encoderString", "encapedpassword", "encryptedPassword", "enoderpassword", "encoderpassword", "enoderPass", "encidedpassword", "encoredString", "encachedSecret", "enryptedpassword", "enryptedPass", "encoderPass", "ecodedPassword", "encoredSecret", "encachedPassword", "encoredPassword", "encoderPassword", "encryptedPass", "encryptedSecret", "enryptedPassword", "encapedPass", "encapedPassword", "encodedSecret", "encachedString", "enodedpassword", "encryptedString", "enccodedPass"]}}
