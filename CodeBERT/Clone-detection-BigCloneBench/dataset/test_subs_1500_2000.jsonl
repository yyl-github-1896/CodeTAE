{"id1": "8000624", "id2": "16388708", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"CopyTo": [" transferto", "copyto", "CopyFrom", " transferFrom", " copyTo", " copyFile", "copyFrom", "CopyFile", " copyFrom", "copyTo", " transferTo", "copyFile", " copyto", " transferFile", "Copyto"], "dest": ["folder", "wb", "die", " destination", "temp", "cont", "done", "content", "w", "transform", " Dest", "write", "target", "them", "src", "filename", "output", "later", "bin", "table", "object", "sup", "comb", "txt", "class", "orig", "exit", "dist", "path", "opt", "flat", "img", "rest", "tmp", "name", "test", "Dest", "data", "file", "desc", "delete", "destroy", "source", "obj"], "in": ["re", "image", "ini", "kin", "login", "wave", "fa", "inner", "inn", "gin", "input", "din", "In", "up", "l", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "plus", "source", "nin", "sin", "x", "cin", "issue", "pull", "ins", "as", "init", "inside", "ac", "thin", "h", "con", "ln", "rin", "ax", "isin", "id", "reader", "i", "win", "n", "vin", "lib", "connection", "m", "inc", "f", "lin", "s"], "out": ["err", "ou", "image", "o", "outer", "temp", "other", "this", "inner", "outside", "w", "net", "target", "our", "up", "or", "cache", "sync", "output", "OUT", "writer", "b", "conn", "bin", "object", "url", "pin", "external", "again", "outs", "not", "plus", "nin", "part", "io", "x", "Out", "client", "off", "app", "name", "ext", "data", "file", "vert", "user", "call", "ex", "i", "no", "timeout", "n", "one", "lib", "inc", "exec", "socket", "copy"], "c": ["enc", "lc", "esc", "o", "config", "dc", "content", "exc", "cl", "pc", "fc", "cu", "ca", "l", "ch", "cb", "arc", "C", "code", "cf", "r", "ct", "buffer", "rc", "t", "ic", "d", "ci", "p", "sc", "pointer", "v", "x", "ce", "cy", "xc", "cc", "oc", "cm", "col", "ac", "e", "char", "u", "comment", "i", "abc", "n", "uc", "bc", "ec", "m", "cr", "f"]}}
{"id1": "18046717", "id2": "5725177", "code1": "    private String getFullClassName(URL url, String className) throws Exception {\n        JarInputStream jis = new JarInputStream(url.openStream());\n        ZipEntry zentry = null;\n        while ((zentry = jis.getNextEntry()) != null) {\n            String name = zentry.getName();\n            int lastPos = name.lastIndexOf(\".class\");\n            if (lastPos < 0) {\n                continue;\n            }\n            name = name.replace('/', '.');\n            int pos = -1;\n            if (className != null) {\n                pos = name.indexOf(className);\n                if (pos >= 0 && name.length() == pos + className.length() + 6) {\n                    jis.close();\n                    return (name.substring(0, lastPos));\n                }\n            }\n        }\n        jis.close();\n        return (null);\n    }\n", "code2": "    @Override\n    protected <T> T execute(final HttpMethod method, final String url, Parameters parameters, final Handler<T> handler) throws FoursquareException {\n        HttpURLConnection connection = null;\n        try {\n            switch(method) {\n                case GET:\n                    connection = openConnection(url.concat(\"?\").concat(formEncode(parameters)));\n                    connection.setRequestMethod(\"GET\");\n                    connection.connect();\n                    break;\n                case POST:\n                    connection = openConnection(url);\n                    connection.setRequestMethod(\"POST\");\n                    connection.setDoOutput(true);\n                    connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                    connection.connect();\n                    final OutputStream out = connection.getOutputStream();\n                    out.write(formEncode(parameters).getBytes());\n                    out.flush();\n                    out.close();\n                    break;\n            }\n            final int statusCode = connection.getResponseCode();\n            if (statusCode / 100 != 2) {\n                final Error error = parseBody(connection.getErrorStream(), new ErrorHandler());\n                if (error == null) throw new FoursquareException(connection.getResponseMessage()); else if (\"error\".equals(error.getType())) throw new FoursquareException(error.getMessage()); else if (\"unauthorized\".equals(error.getType())) throw new AuthenticationException(error.getMessage()); else if (\"ratelimited\".equals(error.getType())) throw new RateLimitingException(error.getMessage()); else throw new FoursquareException(connection.getResponseMessage());\n            }\n            return parseBody(connection.getInputStream(), handler);\n        } catch (final IOException e) {\n            throw new FoursquareException(e);\n        } catch (final ParserConfigurationException e) {\n            throw new FoursquareException(e);\n        } catch (final SAXException e) {\n            throw new FoursquareException(e);\n        } finally {\n            if (connection != null) connection.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"getFullClassName": ["getShortclassName", "getFullclassPath", "getShortClassName", "getFullClassNames", "getFullFullPath", "getShortclassPath", "getFullFileName", "getFullFilePath", "getFullFileNames", "getFullClassPath", "getShortclassname", "getFullFullName", "getFullFilename", "getShortClassname", "getFullclassname", "getShortClassPath", "getFullclassName", "getFullFullNames", "getFullFullname", "getFullClassname", "getShortclassNames", "getShortClassNames", "getFullclassNames"], "url": ["image", "html", "URL", "service", "base", "lr", "resource", "feed", "Url", "entry", "http", "src", "l", "page", "string", "path", "job", "io", "org", "uri", "bug", "ur", "loader", "location", "ssl", "loc", "server", "user", "file", "gl", "host", "sl", "date", "or", "connection", "jar", "source", "address"], "className": [" classCode", "classCode", "typeLine", "shortName", "typeNumber", "ClassType", " classLine", "classNames", "objectNAME", "classNAME", " classNames", "ClassPath", "shortNumber", "typename", "sourceNames", "fullCode", "objectName", "classType", "classLine", "fullname", " classname", "ClassCode", "sectionname", "classname", "sourceName", "ClassName", "sectionName", "sourceNAME", " classNAME", "fullPath", "classNumber", "objectname", "classPath", "Classname", "typeName", "fullName", "sourcename", "shortname", "sectionPath", "shortLine", "objectNames", "sectionType", " classNumber", " classType", " classPath"], "jis": ["ajais", " jas", "zris", "zists", "jists", "joris", "jois", " jiss", "jetas", "jais", "jiss", "zis", " jais", " ji", "ajiss", "Jis", "jetis", "ajris", "jetais", "joiss", "zas", "ji", " jists", "jetris", "ajis", "Jais", "jris", "ajists", "joais", "Ji", "ziss", "jas", " jris", "zais", "zi", "Jiss"], "zentry": ["gzconnection", "zpart", "jpart", "ezpie", "zerenter", "lenter", "ezpart", " zpart", "jpie", "zoEntry", "gzEntry", "zoconnection", "jentry", " zenter", "zoentry", " zfile", "zenter", "zoenter", "lester", " zpie", "zerfile", "lfile", "jEntry", "ezentry", "zester", "zerentry", " zconnection", "zpie", "ezEntry", "gzenter", "gzentry", "lentry", " zester", "zfile", " zEntry", "zerester", "zconnection", "zEntry"], "name": ["image", "base", "in", "address", "end", "prefix", "NAME", "default", "inner", "common", "alias", "none", "entry", "ix", "up", "filename", "key", "l", "space", "info", "now", "api", "object", "connection", "home", "string", "style", "ame", "class", "code", "pass", "Name", "path", "work", "type", "part", "named", "x", "number", "start", "size", "clean", "word", "search", "data", "file", "id", "error", "e", "names", "str", "i", "no", "comment", "n", "value", "one", "date", "old", "f", "s"], "lastPos": [" lastIndex", "nextIndex", " lastPart", "firstPos", "fullLen", "lastPart", "lastIndex", "lastLen", "nextRes", "nextPart", " lastPosition", "nextpos", " lastpos", "nextPos", "fullPos", "finalLen", "nextLen", "fullpos", "lastPosition", "lastRes", "firstPosition", "finalIndex", " lastRes", " lastLen", "finalPos", "lastpos", "finalRes", "firstpos", "firstPart", "fullPosition", "firstLen"], "pos": ["unit", "index", "j", "end", "offset", "pt", "fun", "val", "po", " position", "none", "ix", "count", "rev", "POS", "post", "style", "act", "position", "spec", "ps", "push", "pass", "p", "doc", "part", "line", "Pos", "os", "nos", "len", "pointer", "diff", "eff", "x", "length", "is", "cos", "size", "start", "off", "col", "neg", "limit", "cond", "no", "i", "pose", "pro", "seq", "loc"]}}
{"id1": "12197169", "id2": "21979714", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    @ActionMethod\n    public void list() throws IOException {\n        final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/list?version=1000\");\n        final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n        con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n        final InputStream in = con.getInputStream();\n        final byte[] buf = new byte[4096];\n        textArea.setText(\"\");\n        for (int bytesRead; (bytesRead = in.read(buf)) != -1; ) {\n            textArea.append(new String(buf, 0, bytesRead));\n        }\n    }\n", "label": 0, "substitutes": {"read": ["create", "end", "continue", "stream", "check", "download", "write", "open", "parse", "load", "reading", "Read", "process", "run", "replace", "print", "readable", "work", "loop", "start", "report", "init", "ready", "request", "reader", "println", "get"], "in": ["ini", "err", "image", "log", "index", "login", "fr", "o", "of", "ing", "stream", "inner", "inn", "input", "scan", "In", "at", "cms", "l", "bin", "b", "conn", "info", "c", "r", "IN", "from", "buffer", "again", "token", "path", "er", "doc", "source", "nin", "io", "it", "min", "out", "by", "ins", "is", "ssl", "a", "con", "server", "data", "file", "isin", "id", "e", "on", "error", "ex", "reader", "n", "connection", "din", "f", "url", "inc", "s"], "line": ["link", "lc", "log", "unit", "end", "val", "lf", "lines", "inline", "entry", "LINE", "parse", "text", "message", "ne", "Line", "key", "L", "l", "b", "object", "page", "ine", "string", "code", "status", "buffer", "record", "se", "frame", "row", "le", "block", "name", "col", "ge", "data", "file", "id", "cell", "e", "el", "str", "sl", "comment", "value", "reader", "source", "f", "url", "lin"], "i": ["ini", "ski", "index", "j", "o", "oi", "phi", "ii", "fi", "ix", "slice", "l", "b", "info", "ui", "ri", "pi", "gi", "abi", "li", "ci", "p", "ie", "uni", "si", "io", "ni", "bi", "eni", "xi", "x", "ai", "ip", "is", "ori", "qi", "ti", "e", "u", "f", "n", "di", "I", "zi"], "logDatum": ["logdata", "logDum", "logDsatum", "logDatam", "logDsata", "Logdict", "LogDict", "logDictionary", "LogDum", "logDam", "exDDatum", "exDam", "logDatatum", "logDDam", "exDDictionary", "exDictionary", "logdict", "logDsict", "LogData", "logdatum", "logFictionary", "logDatictionary", "exDDam", "logDDictionary", "exData", "logDatata", "logFam", "LogDatum", "logFata", "logFatum", "logData", "logDict", "Logdatum", "logdum", "Logdum", "logDsum", "exDData", "exDatum", "Logdata", "logDDatum", "logDData", "logDatict"]}}
{"id1": "1357662", "id2": "21348951", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "label": 1, "substitutes": {"copyFileTo": ["copyChannelFile", "copyFileTO", " copyfileTo", " copyfileTO", "copyfileTO", "copyFileFile", " copyFileFrom", "copyChannelFrom", "copyfileTo", " copyFileFile", "copyChannelTo", "copyFilesFile", "copyChannelTO", "copyFilesFrom", "copyFilesTO", " copyFileTO", "copyFileFrom", "copyfileFrom", " copyfileFile", "copyfileFile", "copyFilesTo", " copyfileFrom"], "destination": ["distinator", "targetinate", "destinator", " destruction", "sourceinated", "distruction", "destribution", "Destination", "distinations", " destinator", "configinated", "separinator", "targetination", "destruction", "Destined", "separination", " Destribution", "configinator", "sourceinator", "targetruction", "destined", " destinations", "sourceinations", "Destinator", "targetinations", "separinations", " Destination", "Destinations", "separinated", "distined", "destinate", "destinated", "configination", "destinations", " Destinator", "distination", "Destribution", " destinate", " destribution", "configinations", "distinate", " destined", "sourceination"], "srcChannel": ["srcchannel", "srcContext", " srcConnection", "destchannel", "rcChan", "destConnection", " srcContext", " srcChan", "rcchannel", "sourcechannel", "rcChannel", "srcChan", " srcchannel", "sourceChan", "sourceConnection", "sourceChannel", "sourceContext", "destChan", "rcContext", "rcConnection", "srcConnection"], "destChannel": [" destchannel", "restChan", "srcchannel", "DestChan", "destchannel", "destConnection", " destChan", "Destchannel", "sourcechannel", "srcButton", " destConnection", "srcChan", " destButton", "sourceChan", "descChannel", "DestConnection", "destButton", "sourceConnection", "sourceChannel", "destChan", "descButton", "restChannel", "descchannel", "restchannel", "DestChannel", "srcConnection"]}}
{"id1": "5061606", "id2": "3767903", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNequccessarily", "createSettingsIfNecesseless", "createSettingsIfNeceseless", "createSettingsIfNecesarily", "createSettingsIfNececnecessary", "createSettingsIfNequccessary", "createSettingsIfNequessnecessary", "createSettingsIfNecccesseless", "createSettingsIfNequccessnecessary", "createSettingsIfNecessnecessary", "createSettingsIfNecccessarily", "createSettingsIfNecccessary", "createSettingsIfNequesseless", "createSettingsIfNecesary", "createSettingsIfNececary", "createSettingsIfNequccesseless", "createSettingsIfNecessarily", "createSettingsIfNequessarily", "createSettingsIfNecesnecessary", "createSettingsIfNececarily", "createSettingsIfNequessary", "createSettingsIfNececeless", "createSettingsIfNecccessnecessary"], "out": ["err", "image", "log", "model", "pool", "o", "index", "prefix", "this", "flush", "write", "plain", "net", "at", "channel", "window", "up", "group", "cache", "sync", "output", "OUT", "password", "bin", "conn", "writer", "object", "page", "url", "null", "array", "exit", "again", "outs", "path", "io", "result", "by", "Out", "client", "cookie", "off", "app", "socket", "init", "name", "a", "server", "data", "file", "user", "parent", "lock", "error", "ex", "i", "timeout", "connection", "config", "source", "exec", "plugin", "obj", "copy", "editor"], "fSettings": ["fsConfig", "FJs", "rfFs", "filesettings", "FConfig", "fConfig", "fettings", "FSetting", "sfettings", "rfSettings", "fmSetting", "fmConfig", "fmSettings", "fsSettings", "FSetup", " fFs", " fConfig", "FSettings", "rfConfig", "fsSetting", "Fsettings", "fJs", "sfsettings", "sfSettings", "fFs", " fSetting", "fileSetting", "fSetting", "fmSetup", " fsettings", "fsFs", " fJs", "fsettings", "sfSetting", "fileSettings", "fileettings", "fsSetup", "fSetup", "sfJs", "rfSetting", " fettings"], "src": ["base", "sub", "storage", "stream", "cur", "req", "ref", "text", "filename", "b", "ctr", "cb", "prot", "string", "gb", "dist", "route", "rc", "path", "st", "sc", "settings", "ource", "uri", "sb", "dest", "attr", "img", "fp", "ins", "tmp", "ssl", "sr", "sel", "loc", "file", "str", "sl", "rb", "lower", "uc", "config", "source", "url"], "in": ["ini", "image", "err", "kin", "index", "login", "stream", "inner", "gin", "inn", "input", "din", "In", "inc", "l", "bin", "b", "c", "IN", "r", "again", "path", "source", "ins", "init", "thin", "con", "data", "file", "rin", "id", "i", "win", "reader", "n", "connection", "sin", "f", "url", "copy", "s"]}}
{"id1": "10214218", "id2": "14733078", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["encress", " encipher", " enccrypt", "enrypt", "decrypt", "encipher", "decress", "enress", "deccrypt", "decipher", " encress", "enipher", "enccrypt"], "plaintext": ["battxt", "plainText", "batsource", " plainstruct", "battext", "batText", " plainsource", "maintext", "anytxt", "plaintxt", " plainText", "mainsource", "mainstruct", "anystruct", "plainstruct", "plainsource", "mainText", "batstruct", "anytext", "anyText", " plaintxt"], "md": ["dd", "nm", "sha", "cmd", "dr", "meta", "mage", "am", "dig", "metadata", "amd", "ma", " MD", "arm", "mm", "mad", "mo", "message", "mu", "key", "ms", "ld", "wd", "mp", "mand", "d", "kg", "bd", "ad", "pg", "pm", "mg", "mt", "mac", "sm", "od", "cm", "MD", "Cmd", "mod", "data", "dh", "pd", "mag", "dm", "mc", "em", "mb", "hm", "m", "db"], "raw": ["enc", "Raw", "image", "dec", "wave", "feed", "hex", "content", "input", "none", "serial", "text", "message", "load", "bytes", "full", "null", "array", "buf", "initial", "ack", "buffer", "rc", "good", "rew", "original", " RAW", "row", "block", "pack", "clean", "unsigned", "wrapper", "data", "binary", "RAW", "unknown", "instance", "ng", "words"], "hash": ["image", "her", "sha", "base", "log", "html", "hex", "version", "alpha", "message", "cache", "key", " hex", "ruby", "code", "array", "kh", "abi", "sh", "rh", "response", "mac", "ashes", "secret", "block", "ash", "Hash", "sum", "hed", "h", "ha", "id", "data", "url", "header"]}}
{"id1": "7396682", "id2": "8932510", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["link", "create", "change", "clone", "share", "download", "write", "paste", "cop", "load", "sync", "remote", "replace", "cat", "update", "url", "clip", "path", "drop", "split", "opy", "dump", "archive", "Copy", "file", "transfer", "rm", "move", "delete", "get", "cp", "source", " cp", "save"], "srcFS": ["sbFs", " srcTS", "rcfs", "srcfs", "srcFC", " srcfs", "srcFP", "rcFS", "rubyFS", " srcFC", "srcTS", "sourceFs", "srcFs", "sbFP", "rcTS", "rubyFs", " srcFP", "rubyfs", "sbfs", "rcFC", "sourceFC", " srcFs", " srcFB", "sourceFS", "rubyFB", "sbFS", "sourcefs", "rcFs", "srcFB", "sourceFB", "sourceTS", "rcFP"], "src": ["resource", "sub", "config", "view", "stream", "Source", "inf", "share", "RC", "target", "obj", "feat", "req", "sec", "http", "filename", "slice", "sync", "href", "cb", "sup", "url", "code", "gb", "dist", "spec", "rc", "core", "sn", "path", "st", "sc", "cmp", "ource", "upload", "uri", "sb", "sin", "dest", "SourceFile", "attr", "img", "rest", "fp", "sit", "secure", "name", "ssl", "sr", "sel", "sys", "host", "file", "inst", "username", "sth", "sl", "rb", "ctx", "bh", "loc", "source", "project", "rss", "supp"], "dst": [" drest", "lst", "drc", "pdrc", "pdsc", "Dst", "ddst", "dsts", "idrest", "ddest", "drest", "lsts", "lST", "pdst", "cdrc", "cdst", "Drc", "cddest", "Ddest", " dsts", "ldest", " drc", "dsc", "ddrc", "pdST", "idst", "cdST", "ddST", " dsc", "dST", " ddest", "Dsts", "Drest", "iddest", " dST", "ddsc", "DST", "idsts"], "deleteSource": ["deleteMode", " deleteTarget", " deleteOrigin", "delSources", "deleteOrigin", "delOrigin", "DeleteSources", "destroySource", "DeleteType", "copyMode", "DeleteOrigin", "delTarget", "copySource", "deleteTarget", "destroyOrigin", "delType", " deleteType", "deleteType", "deleteSources", " deleteMode", " deleteSources", "destroyTarget", "destroyMode", "delSource", "delMode", "DeleteTarget", "copyOrigin", "DeleteSource", "DeleteMode", "copyTarget"], "conf": ["lc", "conv", "Conf", "cli", "cl", "param", " Conf", "fi", "ref", "cache", "ca", "ch", "conn", "cb", "info", "raf", "cd", "cfg", "def", "cf", "c", "confirmed", "ci", "sc", "cmp", "cor", "cs", "prop", "client", "cc", "bug", "context", "cm", "con", "cn", "const", "comment", "ctx", "bc", "uc", "config", "cr", "f"], "contents": ["contentENTS", "stacts", "Content", "Contils", "Contains", "locents", "CONTains", "content", "contENTS", "CONTacts", "contils", "locContents", "locains", "contentients", "contains", "contentent", "contients", "CONTients", "contContents", "containers", "stences", "latacts", " content", "contentents", "contences", "Contents", "Contacts", "stENTS", "latent", "ContContents", "contacts", "latils", "CONTContents", "locainers", "CONTents", "Containers", "CONTainers", "latents", "stents", "ContENTS", "CONTences", " contients", "CONTent", "CONTils", " contENTS", "CONTENTS", "Contences"], "i": ["ini", "index", "j", "o", "oi", "hi", "inner", "phi", "ii", "fi", "ix", "count", "slice", "key", "mu", "b", "ui", "iv", "ri", "pi", "c", "gi", "abi", "d", "li", "k", "ci", "p", "ie", "type", "multi", "si", "io", "xi", "uri", "uni", "v", "x", "ai", "diff", "ji", "y", "ip", "start", "name", "init", "ori", "ti", "h", "id", "data", "qi", "e", "iu", "u", "f", "n", "di", "m", "I"], "in": ["ini", "kin", "login", "serv", "gin", "inn", "input", "din", "In", "l", "bin", "b", "conn", "c", "r", "IN", "pass", "doc", "source", "nin", "part", "min", "out", "ins", "is", "as", "inas", "a", "ac", "thin", "con", "data", "file", "rin", "ax", "id", "win", "connection", "sin", "f", "socket", "inc"]}}
{"id1": "3187685", "id2": "1473212", "code1": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "code2": "    @Test\n    public void test_validate_geo_getEvents() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=geo.getevents&location=madrid&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"copyJar": ["CopyZip", "zipJam", " copyingJam", "zipSocket", " copyingZip", "CopyJam", "copySocket", " copyingSocket", "copyJam", "CopySocket", "CopyJar", " copyingJar", "zipJar", "zipZip", "copyZip"], "src": ["image", "resource", "sub", "storage", "config", "stream", "input", "download", "ls", "obj", "filename", "l", "b", "buf", "files", "dist", "rc", "core", "path", "st", "sc", "upload", "uri", "sb", "dest", "img", "sit", "sq", "rs", "ssl", "sel", "archive", "host", "file", "inst", "sl", "rb", "uc", "loc", "source", "url", "s"], "dst": ["ldst", "odst", "fst", "dput", "ldsts", "dset", "edsts", "odsts", "edput", "fsts", "dsts", " dput", "ldput", "eddr", "edst", "ddr", "fset", " dsts", "lddr", " ddr", " dset", "odset", "odput", "fput"], "srcChannel": [" srcPage", "srcchannel", "sslChannel", "sourcePage", " srcConnection", "srcContext", "rcClient", " srcSocket", "destChannel", "rcChan", "destConnection", " srcContext", "instConnection", " srcChan", "sslContext", "rcchannel", "instChan", "rcChannel", "sourcechannel", "srcChan", "srcSocket", "sslChan", " srcchannel", "sourceChan", "instChannel", " srcClient", "sourceConnection", "sourceChannel", "destClient", "sourceContext", "instPage", "sslSocket", "srcClient", "destChan", "srcPage", "rcContext", "rcSocket", "rcConnection", "srcConnection"], "dstChannel": ["drdChan", "dspChannel", "dspchannel", "dstStream", "DstChannel", "DestChan", "destchannel", "dspConnection", "ddestConnection", "DstChan", "dspChan", "dstschannel", "dstsChan", "dstsConnection", "drestStream", "drdChannel", "destChannel", "Dstchannel", "DdestChannel", "drdchannel", "drdStream", "dstConnection", "destConnection", "dostChan", "Destchannel", "drestchannel", "Ddestchannel", "drestChannel", "dstchannel", "drestChan", "dstsStream", "dostChannel", " drdChan", "dstsChannel", "dostchannel", " drdchannel", "DdestChan", " dstchannel", " drdChannel", "DestConnection", "dstChan", "ddestChannel", "DdestConnection", " dstChan", "ddestChan", " drdStream", "DstConnection", "destChan", " dstStream", "ddestchannel", "DestChannel"]}}
{"id1": "310182", "id2": "19134229", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["oconversion", "CONversion", "oconverting", " deconverted", "CONverting", " deconvert", "conception", "CONception", " deconverting", "unverted", "subversion", "CONverted", "Conception", " deconversion", "oconvert", "unversion", "converted", "unception", "subvert", "conversion", "Convert", "unvert", "Converted", "subverted", "subverting", "converting", "oconverted", "Converting", "Conversion", "CONvert"], "src": ["video", "resource", "storage", "config", "stream", "Source", "impl", "gz", "RC", "input", "download", "feat", "req", "ref", "load", "back", "filename", "slice", "href", "cb", "prot", "url", "string", "code", "buf", "gb", "spec", "dist", "cpp", "rc", "stage", "sn", "path", "st", "sc", "cmp", "upload", "ource", "uri", "sb", "proc", "SourceFile", "sin", "img", "fp", "supp", "attr", "sit", "secure", "tmp", "name", "ssl", "Dest", "sel", "sys", "component", "file", "fn", "inst", "username", "sth", "reader", "rb", "rl", "ctx", "scene", "loc", "source", "obj", "s"], "dest": [" destination", "temp", "cont", "dc", "dat", "target", "bin", "home", "null", "txt", "class", "orig", "lib", "dist", "path", " dst", "img", "dir", "std", "tmp", "test", "Dest", "fn", "di", "source", "obj", "disk"], "in": ["ini", "err", "login", "stream", "inn", "inf", "val", "input", "In", "up", "bin", "pin", "r", "IN", "ps", "t", "pass", "d", "doc", "source", "io", "ins", "is", "as", "inas", "a", "data", "isin", "file", "ex", "i", "reader", "win", "n", "din", "f", "inc"], "p": ["np", "j", "o", "po", "pre", "py", "P", "pc", "cop", "parser", "l", "b", "jp", "pr", "bp", "lp", "pi", "pp", "sp", "pe", "c", "r", "wp", "g", "ps", "t", "pa", "d", "op", "pg", "part", "pm", "v", "fp", "pb", "h", "tp", "pd", "e", "i", "per", "cp", "m", "f", "s"], "ds": ["ths", "dp", "vals", "ls", "services", "ads", "ld", "lp", "groups", "dt", " ps", "os", "ins", "icks", "nas", "ts", "dates", "scripts", "s", "dc", "dat", "Ds", "points", "els", "sync", "tools", "ipes", "xs", "obs", "sts", "d", "ils", "dds", "hs", "gs", "docs", "sys", "pd", "dm", "ss", "dl", "des", "posts", " DS", "utils", "cons", "lines", "ns", "ges", "da", "tests", "ays", "dist", " props", "eps", "cs", "df", "uds", "gd", "qs", "ys", "data", "ded", "ks", "words", "di", "db", "parts", "dd", "ants", "vs", "amps", "ans", "DS", "dos", "plugins", "styles", "js", "ps", "rs", "ups", "models", "bs", " sd"], "format": ["letter", "model", "unit", "nat", "plugin", "prefix", "form", "function", "pattern", "at", "feat", "filter", "version", "parser", "atter", "filename", "sche", "api", "table", "Format", "struct", "style", "string", "class", "scale", "act", "spec", "t", "fd", "path", "handler", "ant", "template", "source", "type", "record", "part", "frame", "fp", "name", "language", "host", "data", "file", "layout", "fn", "magic", "config", "tag", "f", "url"], "hasPixelData": ["hasPixelStyle", "haspixeldata", "showsByteDATA", "hasByteStyle", " hasPixelSize", "hasByteDATA", "showsPixelDATA", "hasPixelDATA", "hasPictureSize", "hasPixeldata", "hasByteData", "hasPixelSize", "showsPixelData", "haspixelData", "hasPicturedata", "showsByteData", "hasByteSize", "showsByteStyle", "haspixelSize", "showsPixeldata", "showsBytedata", "showsPixelStyle", "hasBytedata", "hasPictureData", " hasPixeldata"], "inflate": ["inadequode", "infloation", "inadequATE", "InFlace", "infloace", "Inflation", "inflation", "InFlate", "Inflated", "inflode", "infolode", "insflating", "invenate", "insvenate", "infolate", "Inflate", "infolATE", "infolating", "InFlated", "insvenATE", "invenating", "inFlace", "inflace", "insflode", "invenode", "inadequating", "insvenating", "inffate", "InFlation", "insflate", "inffation", "invenATE", "infloated", "inffated", "inflating", "inFlate", "Inflace", "insflATE", "infface", "infloate", "inFlated", "inadequate", "insvenode", "inflated", "inflATE", "inFlation"], "pxlen": ["pxden", "pxdata", "mxlen", "campos", "pxln", "mxln", "pxlon", "camln", "mxcount", "pxlin", "pngsize", "xplength", "fxln", "xpsize", "pgden", "ppl", "pplen", "fxden", "pxsize", "pxcount", "fxpos", "axlin", "pclon", "ppLen", "pnglength", "txlon", "pnglen", "pxl", "mxlength", "xplen", "xpcount", "axlen", "txlin", "txln", "pxpos", "ppden", "mxdata", "pglen", "pgLen", "mxpos", "pxlength", "fxl", "pclen", "pgl", "camlen", "pclin", "camdata", "axln", "txlen", "pcln", "fxLen", "pxLen", "mxsize", "fxdata", "pngcount", "fxlen", "axlon"], "out": ["re", "err", "log", "point", "step", "cli", "inter", "up", "group", "cache", "output", "OUT", "list", "conn", "post", "page", "pad", "store", "session", "state", "again", "outs", "work", "query", "line", "io", "v", "Out", "co", "dump", "sys", "server", "user", "gen", "lock", "error", "lib", "parent", "obj", "copy"]}}
{"id1": "13757855", "id2": "3809087", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"process": ["resource", "create", "submit", "view", "transform", "project", "parse", "load", "run", "processing", "output", "update", "code", "path", "build", "proc", "cess", "evaluate", "handle", "Process", "request", "construct", "call", "exec", "processor"], "tpl": ["Tpp", "templates", "tml", "Tbl", "qtple", "lPL", "atpl", "psl", "itpl", " tplug", "Tplates", "ttemplate", "tmpl", "tplates", " tple", " tper", " tplate", "lml", "temPL", "atplate", "tplate", " ttemplate", "tcp", "Ttemplate", "fplug", "Tml", "lcl", "TPL", "tbl", "Tsl", " tfc", "fplate", "tipl", "latcp", " tipl", "Tpl", "atml", "stPL", "Tipl", "pipl", " tbl", "qtcp", "lplate", "tplug", "Tple", "qtpl", "atplug", "Tper", "itplates", "tsl", "temtemplate", "tfc", "tple", "qtbl", "latpl", "lpl", "fpl", "tPL", "itPL", "pPL", "tpp", " tcl", "tcl", "lper", "tmyl", "itplate", " tPL", "ppl", "latyl", "tmcp", "qtfc", " tplates", "tper", "pcl", "stpl", " tsl", " tpp", "lple", "qtyl", "tmple", "templ", "latple", "stpp", "stplate", "Tfc", "Tcl", "fml", "Tplate", "tyl", " tml"], "model": ["body", "log", "graph", "module", "Model", "config", "json", "param", "message", "media", "params", "node", "m", "doc", "result", "command", "where", "xml", "models", "language", "data", "document", "location", "project", "conf", "copy"], "packageName": ["PackageNames", "PackageName", " packagename", "groupName", "packageUrl", "modulename", "contextName", "groupUrl", "packageKey", " packageNames", "moduleUrl", "moduleKey", "contextInfo", "projectKey", "Packagename", "groupKey", "contextname", " packageInfo", "groupname", "projectName", "moduleName", "packageNames", "packagename", "projectUrl", "contextNames", "projectname", "PackageInfo", "packageInfo"], "outFileName": ["inFilePath", "outFileTime", "diffFileOnce", "OutDirNames", "outDirEnd", " outFullType", "inDirPath", "outBufferHalf", "outDirInfo", "outFileType", "outDirname", "outFullInfo", "outfileMode", "difffileInfo", "outfileOnce", "outLinename", "outDirCopy", "OUTFileHalf", " outFileInfo", "inDirEnd", "outDirTime", "diffFileInfo", "outFullType", " outFilePath", "outLineNames", "outFileOnce", "outFullTime", "outFileHalf", "outfileCopy", "OutDirName", "outRuleType", "outLineName", "outFilenameHalf", " outDirPath", "outLineOnce", "OUTBufferHalf", "outFullNames", "outFilenameCopy", "outFilesLine", "OUTBufferMode", "diffFileTime", "outFileInfo", " outFullInfo", "outDirName", "inDirCopy", "OUTBufferName", "outfileName", "difffileName", "outFileLine", "outFileEnd", " outFileTime", "OutFileName", "OutDirLine", "outFilenameName", "outFilesPath", "inFileCopy", " outDirTime", "OutFileNames", "OUTFileName", "outFileCopy", "outDirOnce", "diffFileName", "outfileTime", "outfilePath", "outFilePath", "OutDirname", "outFilename", "outBufferMode", "OUTFileNames", "OUTBufferNames", "outFilenamePath", " outFileLine", "difffileTime", "outStreamInfo", "outStreamType", "outLineInfo", " outDirName", " outFileType", "outfileInfo", "outFilenameEnd", "OutFileLine", "outFileMode", "outfileHalf", "outBufferName", "outDirLine", " outDirLine", "outFullname", "outfileEnd", "outFullPath", "outRuleInfo", "outBufferNames", "outStreamName", "OutFilename", "outRuleName", "inFileName", "outFullLine", "outfileNames", "outFilesTime", "outDirPath", "inFileEnd", "OUTFileMode", "outFilenameNames", "outFilesName", "outLineTime", "inDirName", "outDirNames", "outFullName", "outFilenameMode", "outFileNames", "outLineLine", "difffileOnce", " outFullName"], "xsltParam": ["xldVal", "xldMode", "xslicParam", "xsltparam", "xltVal", "xslpVal", "xsldVal", "xslpparam", "xslicVal", "xldParam", "xslpMode", "xslicparam", "xltparam", "xslpParam", "xsldParam", "xslicMode", "xsltMode", "xsldMode", "xsltVal", "xltParam", "xsldparam", "xldparam", "xltMode"], "artifact": ["aratifacts", "Artifact", "Artribution", "adverturation", "Artfact", "aratifact", " artribution", "arturation", "aratifest", "artfact", " artifacts", "ARTifacts", "ARTifact", "aratfact", "advertifacts", " arturation", "artifacts", "Artifest", "artribution", "Arturation", "ARTifest", "artifest", "advertifact", "ARTfact", "advertribution", "Artifacts"], "destinationPath": ["destiningpath", "distinatorName", "destinationspath", "constinationsPoint", "destiningName", "destinationsPath", "constinationWidth", "destinatedString", "restificationPoint", "destinationHandler", "datinatePath", "distributionCase", "destplingPath", "tempinationHalf", "desticationKey", "combinationHandler", "destinationPoint", "destinerPath", "desticationFile", "DestinationPart", "destiningDir", "constinationDir", "restinationHalf", "combinatorpath", "destributionDir", "desticationStep", "destinatedPoint", "distinationCase", "destinationsName", "destificationLog", "constinatorUrl", "destinationPart", "destinationStep", "destationLocation", "destificationName", "tempinatedHalf", "destinatorWidth", "destinateHalf", " destificationAuth", "destiningContext", "DestinationPoint", "constinatorWidth", "destinateDir", "destinationLocation", "destinatorContext", "constinationsPath", " destificationLog", "destinatingpath", "destinatedFile", "destationpath", "distinatorStep", "DestinatingPath", "destinatePart", "restinatorPath", "destificationLocation", "combinatorName", "tempinatedpath", "destinatedCase", "destplingUrl", "distinatorPath", "destplingLog", "destinationHalf", "DestinationText", "destributionCase", "datinationTime", "destinatorCase", "destinerContext", "destinatePoint", "destignmentCry", "restificationPath", "desticationPath", "datinationPath", "destinatepath", "tempinatedPath", "destinationCry", "constinationPoint", "destributionpath", "combinationPath", "destensionText", "destinatedDir", "combinationName", "destinatorFile", "destinatingText", "constinatorDir", "datinatepath", "destinatedKey", "DestificationName", "restificationLocation", "destignmentCase", "distinatorFile", "constinationspath", "constinationContext", "DestinatingText", "destcreationPath", "distinatorKey", "constinatorPath", "destinationName", "distinationDir", "restinationLocation", "destinateTime", "destificationPart", "destensionPath", "desticationPart", "distinatorCase", "destinateHandler", "restinationPoint", "destiationAuth", "destinatorUrl", "destificationAuth", "combinatorPath", "destinatorPath", "destplingAuth", "distinationFile", "destinationFile", "datinateTime", "destributionCry", "DestinatingPoint", "destiningPath", "destiationDir", "constinatorpath", "datinationLocation", "tempinationDir", "constinationUrl", "destinateText", "destensionPoint", "desturationHandler", "destiningPoint", "destificationDir", "destignmentPath", "destinatingPath", "tempinationPath", "desturationPath", "destinatorpath", "combinationpath", "destinationKey", "destinationpath", "constinatorContext", "destificationpath", "destinatorKey", " destinationLog", "destinateString", "datinateLocation", "destificationPoint", "destinatingLocation", "restificationpath", "destationPath", "destinationWidth", "destributionPath", "distinationPath", "destributionName", "destinatorString", "distinationKey", "destinatorCry", "tempinatedDir", "destinationAuth", "destinatingPoint", " destificationDir", "destcreationUrl", "DestificationPath", "destinerpath", "DestinationPath", "destinationLog", "destinationDir", "destplingDir", "distributionpath", "tempinationpath", "datinationpath", "destinatorHalf", "distinationStep", "destinationText", "restinatorString", "restinationPath", "distinationpath", "constinationsName", "restinationString", "destinatingName", "constinationName", "destinateName", "destiationLog", " destinationDir", "destinatorHandler", "destinatePath", "restinatorPoint", "destensionName", "destinatorTime", "distributionPath", "destinationCase", "destinatorPoint", "combinatorHandler", "desturationName", " destificationPath", "destinatorStep", "destinationsPoint", "destinatedPath", "destignmentName", "destiationPath", "distinationName", "destinationContext", "destinateLocation", "desturationpath", "destificationPath", "destinatedHalf", "destinatedStep", "DestinationName", "distributionDir", "destinatorName", "destinationTime", "destcreationWidth", " destinationAuth", "destinatorDir", "DestificationPart", "desticationName", "DestinatingName", "restinationpath", "destplingWidth", "destinatorLocation", "destationTime", "destinationString", "constinationPath", "destinatedpath", "distinatorCry", "destinationUrl", "distinationCry", "constinationpath", "destinerDir", "restinatorHalf"], "in": ["image", "input", "In", "cache", "bin", "c", "r", "IN", "t", "d", "doc", "source", "x", "min", "ins", "name", "con", "data", "ex", "reader", "i", "n", "connection", "config", "din", "inc"], "out": ["err", "log", "index", "pool", "o", "outer", "temp", "prefix", "point", "w", "write", "cli", "with", "version", "group", "up", "cache", "exec", "ne", "output", "OUT", "writer", "key", "list", "bin", "conn", "page", "post", "string", "full", "store", "session", "state", "again", "outs", "path", "free", "doc", "line", "part", "io", "result", "all", "Out", "client", "manager", "name", "sys", "dump", "user", "file", "server", "Output", "gen", "lock", "error", "ex", "comment", "str", "lib", "connection", "msg", "source", "parent", "obj", "copy"], "root": [" roots", "resources", "_", "index", "graph", "module", "options", " result", "history", "transform", "format", "json", "pattern", "Root", "cache", "roots", "cat", "r", "collection", "params", "path", "query", "node", "values", "xml", "loader", "tree", "id", "include", "modules", "instance", "results", "meta", "parent", "url"]}}
{"id1": "4895903", "id2": "3767903", "code1": "    public List load(String sourceType, Object source, String param) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"load \" + source);\n        }\n        String location = null;\n        String type = null;\n        Object inputsource = null;\n        if (source instanceof DynamicMBean) {\n            sourceType = \"MbeansDescriptorsDynamicMBeanSource\";\n            inputsource = source;\n        } else if (source instanceof URL) {\n            URL url = (URL) source;\n            location = url.toString();\n            type = param;\n            inputsource = url.openStream();\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof File) {\n            location = ((File) source).getAbsolutePath();\n            inputsource = new FileInputStream((File) source);\n            type = param;\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof InputStream) {\n            type = param;\n            inputsource = source;\n        } else if (source instanceof Class) {\n            location = ((Class) source).getName();\n            type = param;\n            inputsource = source;\n            if (sourceType == null) {\n                sourceType = \"MbeansDescriptorsIntrospectionSource\";\n            }\n        }\n        if (sourceType == null) {\n            sourceType = \"MbeansDescriptorsDigesterSource\";\n        }\n        ModelerSource ds = getModelerSource(sourceType);\n        List mbeans = ds.loadDescriptors(this, location, type, inputsource);\n        return mbeans;\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"load": ["link", "create", "view", "check", "transform", "find", "parse", "add", "process", "list", "read", "loaded", "LOAD", "loading", "build", "loop", "loader", "init", "construct", "dump", "include", "Load", "loads", "get"], "sourceType": ["ourceUnit", "proxyType", "parentType", "typeType", " sourceCase", "resourceInfo", "ourceTyp", "ourceTime", " sourceTyp", "sourceUnit", "optionType", "resourceName", "resourceType", "cacheTyp", "ourceType", "ourceParam", "viewtype", "sourceTime", "sessionTYPE", "SourceType", " sourceTypes", "sourceTypes", "parseName", "secureName", "srcName", "typePath", " sourceUnit", "sourceInfo", "parenttype", "proxyPath", "parsetype", "sessionType", "parseTyp", "srcUnit", "resourceUnit", "sizeType", "SourceTypes", "ourceName", "sourceStyle", "cacheTime", " sourcetype", "ourcePath", "sourceTYPE", "sourcetype", "cacheName", "typeTyp", "ourceCode", " sourceName", "Sourcetype", "securetype", "optionInfo", "resourceTypes", "cacheType", "sourceName", " sourceInfo", "sourceTyp", "parseType", "parentPath", "resourceCode", "proxyTyp", "sizeParam", "srcCase", "resourcetype", "sourceParam", " sourceTime", "sourceCode", " sourceStyle", "SourceName", " sourceParam", "sourceCase", "optionTYPE", "sizeName", "srcType", "sessionStyle", "viewPath", "secureTyp", "typeStyle", "resourcePath", "sourcePath", "viewType", "ourcetype", "optionStyle", "resourceCase", "sizetype", "secureStyle", "proxyStyle", "ourceStyle", " sourceTYPE", "secureType", "ourceInfo", "sessionInfo", " sourceCode", " sourcePath"], "source": ["unit", "model", "resource", "create", "current", "ources", "status", "class", "element", "single", "result", "context", "see", "name", "component", "file", "comment", "connection", "parent", "service", "input", "function", "grade", "target", "src", "slice", "info", "style", "string", "driver", "session", "core", "handler", "size", "language", "server", "id", "reference", "document", "get", "SOURCE", "stream", "Source", "inner", "form", "parse", "text", "use", "remote", "object", "option", "position", "dist", "path", "ce", "client", "secure", "term", "request", "address", "link", "site", "view", "scope", "spec", "route", "item", "ource", "uri", "dest", "missing", "proxy", "e", "iter", "config", "project"], "param": ["model", "unit", "num", "resource", "config", "view", "prom", "am", "ram", "meter", "channel", "property", "mode", "reason", "aram", "message", "asm", "ref", "problem", "media", "member", "required", "par", "page", "option", "pos", "params", "amp", "item", "path", "large", "m", "lang", "p", "pm", "client", "see", "name", "cm", "cp", "keep", "language", "con", "include", "const", "Parameter", "Param", "rm", "comment", "vm", "im", "default", "template", "project", "python", "address"], "location": ["containing", "image", "folder", "lc", "resource", "address", "section", "shape", "localhost", "site", "storage", "point", "root", "direction", "format", "function", "usage", "which", "target", "entry", "property", "mode", "message", "platform", "filename", "slice", "area", "remote", "local", "selection", "definition", "position", "condition", "collection", "session", "route", "path", "node", "uri", "response", "layer", "command", "region", "where", "ocation", "length", "expression", "loader", "name", "operation", "language", "layout", "instance", "Location", "description", "error", "comment", "connection", "loc", "owner", "directory"], "type": ["link", "unit", "method", "field", "index", "resource", "site", "types", "form", "to", "format", "role", "function", "with", "none", "target", "Type", "key", "media", "info", "full", "page", "style", "null", "class", "TYPE", "pe", "position", "option", "params", "t", "tag", "path", "single", "p", "lang", "part", "attribute", "rel", "ty", "by", "block", "length", "ype", "where", "name", "pretty", "col", "language", "search", "id", "user", "valid", "weight", "port", "error", "comment", "no", "time", "like", "parent", "address"], "inputsource": ["selectresource", "requestresource", "requestservice", "sessionsite", "outputsource", " inputservice", "imageresource", "Inputscope", "imagescope", " inputsite", "selectsource", "selectsite", "imageource", " inputscope", "outputscope", "Inputsource", "imagesource", "outputsite", "inputscope", "inputconfig", " Inputsite", " Inputservice", "inputsite", "inputource", "inputservice", " inputconfig", " Inputsource", " inputresource", "Inputsite", "Inputservice", " Inputresource", "Inputource", "requestsource", "Inputconfig", "requestconfig", "Inputresource", "requestource", "inputresource", "sessionresource", "requestsite", "outputresource", "selectource", "outputource", "sessionsource", "sessionource", " inputource"], "url": ["image", "link", "err", "URL", "base", "email", "resource", "www", "feed", "fr", "stream", "coll", "Url", "http", "remote", "shell", "l", "object", "page", "string", "r", "bel", "route", "rel", "uri", "pull", "layer", "blog", "ur", "ssl", "server", "user", "file", "ll", "ob", "host", "id", "browser", "sl", "rl", "connection", "loc", "web", "address"], "ds": ["dd", "iffs", "des", "ants", "dc", " docs", " DS", "DS", "ls", "Ds", "ads", "ns", "ides", " dd", "da", "ts", "ipes", "xs", "ps", "d", "ils", "dt", "ails", "ands", "os", "cs", "df", "uds", " db", "dds", "fs", "gd", "qs", " cs", "rs", "ys", "gs", "nas", "bs", "ists", "pd", "ains", "dm", "ss", "ks", "di", "dl", "db", "cks", "s"], "mbeans": ["bmones", "mnotations", "gmones", "bmbeans", "mobs", "gmnotations", "gmbs", "modelbs", "lnotations", "bmobs", "gmbean", "gmbeans", " mobs", "mbean", "bmbean", " mbean", " mones", "modelbean", "mbs", "modelbeans", "mones", "gmobs", "lbs", "lbeans", "lbean", "modelnotations"]}}
{"id1": "10385815", "id2": "5977352", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["create", "change", "send", "clone", "download", "write", "open", " Copy", "paste", "zip", "Transfer", "process", "sync", "replace", "Cop", "update", "split", "cmp", "upload", "Copy", "file", "transfer", "put", "move", "delete", "get", "exec"], "fileFrom": ["FileStart", "ioStart", " fileIn", "mailTo", "fileIn", " fileStart", "fileAs", "fileSource", "ioTo", "ioFrom", "FileSource", "FileAs", "FileIn", "fileStart", "mailAs", "FileFrom", " fileAs", "mailFrom", " fileSource", "mailIn", "FileTo", "ioSource"], "fileTo": ["resourceFile", " fileTO", "resourceFrom", "fpTo", "resourceTo", "FileFile", "fpTO", "Fileto", "fileTarget", "FileTO", "fileTO", "fpto", "resourceTarget", "FileFrom", " fileFile", "fpFrom", "FileTo", "fileFile", " fileTarget", "fileto", "FileTarget", " fileto"], "inputStream": ["outputstream", "outputSync", "inputContext", "InputChannel", "InputContext", "outputContext", "inputstream", "InputSteam", "InputFile", "outputSteam", "InputSync", " inputSteam", "inputFile", "inputSteam", " inputFile", " inputContext", "InputStream", " inputstream", " inputSync", "Inputstream", "outputFile", "inputSync"], "outputStream": ["OutputSteam", " outputSteam", "referenceSteam", "OutputPath", "inputPath", "writeSteam", "inputSocket", "OutputStream", "referenceSocket", "fourStreamer", "outputChan", "writeStream", "referenceStream", " outputPath", "outputSteam", "OutputChannel", "referenceChannel", " outputStreamer", "fourSteam", "writeSocket", "inputChan", "outputSocket", "OutputChan", "inputSteam", "writeChannel", "outputPath", "OutputStreamer", "outputStreamer", " outputChan", "fourChannel", "fourStream"], "inputChannel": ["butCommand", " inputSocket", " inputPassword", "inputContext", "InputChannel", "InputContext", "inputSocket", "outputContext", "audioStream", "InputChan", " inputCam", "outputChan", "audioClient", "butChan", "inputCam", "parentChan", "inputClient", "parentPassword", " inputCommand", "outputPassword", "outputCam", "inputPassword", " inputChan", "InputSocket", "butContext", "outputCommand", "inputChan", "outputSocket", "parentStream", "audioCam", "audioChannel", " inputClient", "butChannel", " inputContext", "parentChannel", "InputStream", "inputCommand", "outputClient"], "outputChannel": [" outputQueue", "outContext", "inputContext", " outputchannel", "outputchannel", "outputContext", "inputchannel", "OutputQueue", "OutputStream", " outputContext", "outputChan", "inputQueue", "OutputChannel", "outChan", "inputChan", "OutputChan", "Outputchannel", "outStream", "outChannel", "outputQueue", "OutputContext", " outputChan"]}}
{"id1": "20365090", "id2": "13644375", "code1": "        public HttpResponseExchange execute() throws Exception {\n            HttpResponseExchange forwardResponse = null;\n            int fetchSizeLimit = Config.getInstance().getFetchLimitSize();\n            while (null != lastContentRange) {\n                forwardRequest.setBody(new byte[0]);\n                ContentRangeHeaderValue old = lastContentRange;\n                long sendSize = fetchSizeLimit;\n                if (old.getInstanceLength() - old.getLastBytePos() - 1 < fetchSizeLimit) {\n                    sendSize = (old.getInstanceLength() - old.getLastBytePos() - 1);\n                }\n                if (sendSize <= 0) {\n                    break;\n                }\n                lastContentRange = new ContentRangeHeaderValue(old.getLastBytePos() + 1, old.getLastBytePos() + sendSize, old.getInstanceLength());\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_RANGE, lastContentRange);\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sendSize));\n                forwardResponse = syncFetch(forwardRequest);\n                if (sendSize < fetchSizeLimit) {\n                    lastContentRange = null;\n                }\n            }\n            return forwardResponse;\n        }\n", "code2": "    public String get(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toString(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"execute": [" refresh", " parse", " future", " generate", " produce", " go", " open", " async", " exec", " await", " resolve", " initialize", " feed", " work", " current", " prepare", " poll", " ping", " finish", " proceed", " dispatch", " flush", " pull", " perform", " serve", " handle", " fulfill", " end", " transfer"], "forwardResponse": ["forwardRequest", " forwardAnswer", "ForwardResp", "forwardResp", " backwardRequest", "forwardServer", "publicRequest", " backwardServer", " forwardresponse", "publicServer", " forwardResp", "wardresponse", "ForwardRequest", "wardResponse", " backwardAnswer", "forwardresponse", "publicAnswer", " forwardServer", "wardResp", "Forwardresponse", " backwardResponse", "publicResponse", " forwardRequest", "forwardView", "forwardAnswer", "wardView", "ForwardView", "wardRequest", "ForwardResponse", " forwardView"], "fetchSizeLimit": ["fetchCountLimit", "fetchCountUnit", "faitLimitGlobal", "fetchRangeRange", "fushSizeRange", "fatchSizeRange", "fushCountRange", "fetchLengthPage", "fetchSizeGlobal", "faitLimitBlock", "fetchsizeLimit", "fetchLengthLimited", "fetchLengthLock", "fetchLengthUnit", "fushCountPage", "faitSizeGlobal", "fushCountUnit", "fetchSizePage", "fushSizeLimit", "fetchCountBlock", "fetchLimitPosition", "fetchSizeRange", "fatchLengthLimited", "fetchRangeUnit", "fatchSizePosition", "fetchLengthBlock", "fushSizePage", "faitSizeLimit", "faitLimitLock", "fetchLengthLimit", "fatchSizeLimit", "fushSizeUnit", "fetchSizeLim", "fatchLengthPosition", "fatchLengthLimit", "fetchCountPosition", "fetchSizeUnit", "fetchLimitRange", "fetchLimitGlobal", "fetchLengthGlobal", "fetchLimitLock", "fetchLengthPosition", "fetchsizeLimited", "fatchSizeLock", "fushCountLimit", "fetchSizeLock", "fatchSizeLimited", "fetchsizeLock", "fetchSizeBlock", "fatchLengthLim", "fetchSizeLimited", "fetchLimitBlock", "fetchsizeGlobal", "fetchLengthLim", "fetchRangePage", "fetchSizePosition", "fetchLimitLimit", "fatchLengthRange", "fetchCountRange", "faitSizeLock", "faitLimitLimit", "fetchRangeLimit", "fetchsizeBlock", "fetchCountPage", "fetchLengthRange", "fatchSizeBlock", "faitSizeBlock", "fatchSizeLim", "fatchLengthLock", "fetchsizeLim", "fatchLengthBlock"], "lastContentRange": ["lastResourcerange", " lastHeaderRegion", " lastReadrange", "lastMessageRow", "lastReadRow", " lastContentRegion", "LastMessageLine", "lastContentRegion", " lastHeaderOrigin", "LastContentSpace", "lastContentArea", "LastContentResource", " lastSizeSpace", "lastFileResource", "lastContentInfo", " lastContentOrigin", "lastResourceRow", "lastResourceSpace", " lastContentrange", "lastReadSpace", "lastVersionrange", "lastContentResource", "lastSizeRange", "lastSizeSpace", " lastSizeRegion", "lastResourceArea", " lastReadResource", " lastContentSpace", "lastContentSpace", "lastReadRegion", "lastReadrange", " lastSizeRange", "lastCharacterRegion", "lastMessageLine", "lastHeaderLine", "latestFileRange", "lastHeaderResource", " lastContentRow", " lastHeaderRow", "lastReadInfo", "lastMessageResource", "lastReadResource", "lastContentOrigin", "LastMessageSpace", "LastContentRange", "lastCurrentRange", "lastReadArea", "latestContentRange", "latestFileResource", "lastCharacterRow", "latestContentRow", "lastVersionResource", "lastReadRange", "LastContentLine", "lastFileRange", "lastMessageRange", "lastCurrentResource", " lastHeaderRange", "lastResourceOrigin", "lastContentLine", "lastHeaderSpace", "lastMessageSpace", "lastCurrentLine", "latestContentResource", "lastCharacterOrigin", " lastReadInfo", "lastResourceRange", "lastHeaderRange", "lastResourceRegion", "LastMessageRange", " lastContentInfo", "LastMessageResource", "lastSizeArea", "lastHeaderOrigin", "lastSizeRegion", "lastResourceInfo", " lastReadRange", "lastContentrange", "lastResourceResource", "lastCharacterRange", "lastHeaderRegion", " lastSizeArea", "lastVersionRange", " lastContentArea", "latestFileRow", " lastContentResource", "lastVersionInfo", "lastFileRow", "lastHeaderRow", "lastContentRow", "lastCurrentSpace"], "old": ["folder", "base", "older", "other", "before", "current", "inner", "val", "to", "format", "common", "form", "expected", "ore", "less", "add", "existing", "local", "slice", "l", "list", "now", "ld", "object", "full", "after", "update", "element", "string", "future", "orig", "from", "front", "past", "ant", "original", "part", "build", "and", "diff", "small", "prev", "handle", "client", " Old", "la", "arrow", "ext", "OLD", "low", "file", "later", "last", "el", "normal", "or", "Old", "plugin", "obj"], "sendSize": [" sendLength", "sentSize", "endTime", "drawLimit", "pushTime", "sentSIZE", "drawSIZE", "loadLength", "transferSize", "drawSize", "forceSize", "pushLength", "forceTime", "writeRange", "sendLimit", " sendSIZE", "endSize", "updateLen", "sendOffset", "updateLimit", "pushLen", "forceLength", "loadRange", "sentLimit", "forceSIZE", "endSIZE", " sendTime", "writeSize", " sendStorage", "endLimit", "sendLength", "drawLength", "loadSize", "transferRange", "SendLength", "sendLen", "endLength", "SendSize", "loadSIZE", "pushSize", "updateSize", "sendStorage", "updateSIZE", "writeOffset", "sendRange", "pushSIZE", "SendStorage", "loadOffset", "sendEnd", "endStorage", " sendLen", " sendEnd", "sendTime", "transferOffset", "writeLength", "sendSIZE", "endEnd", " sendLimit", "SendEnd", "loadTime", "sentLength", "transferLength", "pushLimit"]}}
{"id1": "8119563", "id2": "18693224", "code1": "    protected boolean checkLink(URL url) {\n        try {\n            URLConnection connection = url.openConnection();\n            connection.connect();\n            return true;\n        } catch (IOException e) {\n            MsgLog.error(\"DapParser.checkLink(): IOException: \" + e.toString());\n            return false;\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"checkLink": ["checklink", "CheckLink", " checklink", "checkConnect", "loadConnect", "loadLink", " checkLine", "loadLine", "Checklink", "checkLine", "CheckConnect", "loadlink", "CheckLine", " checkConnect"], "url": ["link", "image", "base", "URL", "service", "resource", "Url", "open", "entry", "http", "l", "conn", "object", "page", "string", " URL", "class", "null", "element", "route", "uri", "client", "name", "location", "socket", "ssl", "proxy", "loc", "server", "host", "file", "instance", "str", "sl", "or", "config", "source", "address"], "connection": ["link", "image", "unit", "resource", "ion", "config", "function", "open", "channel", "Connection", "http", "l", "b", "conn", "writer", "object", "application", "builder", "c", "position", "relation", "handler", "io", "uri", "network", "response", "client", "character", "communication", "server", "data", " Connection", "connect", "i", "database", "timeout", "connected", "loc", "socket"]}}
{"id1": "8430178", "id2": "14191679", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", "transferFile", "CopyFile", "transferPath", " copyfile", "Copyfile", " copyPath", "copyfile", "copyFiles", "copyPath", "CopyPath", "CopyFiles"], "source_name": ["Source_file", "source_key", "source_uri", "source_Name", "src_name", "src_file", "source_names", "sourceCname", "sourceNtype", "source_size", "source_data", "Source_data", "src_alias", "source_alias", "sourceNname", " source_Name", "Source_name", "source_type", "src_uri", "sourceNalias", "src_size", "sourceNfile", "source_path", "sourceCfile", "sourceCtype", "sourceCalias", " source_path", " source_key", " source_names", "src_type"], "dest_name": ["dest_resource", "destappnames", "dest_id", " dest_path", "destFilename", "destFilenamed", " destination_resource", "dest_none", "dest_word", " destinationFresource", " dest_none", "destflabel", "source_Name", "destRdefinition", "target_names", "destJnames", "destPmodel", "destPtype", "source_names", "dest_definition", "Dest_id", "destPpath", "destPword", "target_type", "destapptype", " dest_type", "dest_names", " dest_names", "destRName", " dest_Name", " destinationFpath", "destRpath", "destRname", " destination_name", "dest_label", "destJname", "destJword", " dest_file", " destination_path", "dest_named", "destFname", " dest_named", "Dest_name", "destFpath", "target_model", "destJName", "destFilelabel", "destfnamed", "dest_model", " dest_word", "destffile", " destinationFinfo", "source_path", " dest_label", " dest_definition", "destPnames", "destPname", "destFilefile", "dest_file", "target_name", "Dest_path", "dest_Name", "dest_type", " destinationFname", "destappname", "dest_path", "destFresource", "dest_info", "destfname", "Dest_Name", "destPName", "destFinfo", "destappmodel", " destination_info"], "source_file": ["source_url", "source_File", "ource_line", "sourcefname", "src_name", "source_class", "src_file", " source_class", "source_files", "source_stream", "source__name", "source__class", "sourceffile", "source__base", "source_base", " source_url", "sourcefFile", "source__file", "ource_file", " source_base", " source_cache", "ource_files", " source_File", "src_files", " source_files", "src_stream", "source_line", "source_cache", "sourcefurl", "ource_name"], "destination_file": ["destention_name", "destination_files", "destination_page", "destination2file", "destation_name", "destention4file", "destinate_files", "destation_folder", "destination2name", "destinationablefile", "destination_path", "destention_source", "destination4file", "destinate_base", "destination4source", "destinationablebase", "destention_path", "destation_function", "destination_folder", "destination_name", "destination_source", "destention_file", "destention4source", "destation_file", "destinationablefiles", "destention4path", "destination2source", "destinate_file", "destination4path", "destinationablepage", "destention4name", "destation_files", "destination_function", "destination4name", "destinate_page", "destination2path", "destination_base"], "source": ["image", "resources", "unit", "slave", "ize", "service", "resource", "SOURCE", "index", "site", "storage", "view", "stream", "Source", "current", "inner", "input", "open", "target", "master", "src", "cache", "load", "local", "slice", "output", "remote", "object", "scope", "ources", "via", "class", "from", "spec", "core", "single", "ource", "result", "uri", "dest", "diff", "client", "secure", "ite", "start", "name", "proxy", "search", "server", "file", "reference", "reader", "get", "connection", "config", "parent", "copy"], "destination": ["Destension", "destension", "foreigninated", "constining", "targetinate", "destinator", " destina", "targetination", "destribution", "Destination", "variinator", " destinator", "testribution", "foreigninator", "Destinated", "destina", " destining", "validination", "dependinate", "variinate", "coordination", "foreigninate", "constribution", "descinated", "testinated", "variination", "Destinator", "identination", "validinator", "testinator", "variinated", "identribution", "identinated", "Destining", "coordinated", "dependination", "targetinator", "destinate", "destinated", "testination", "descination", "constination", "coordension", "identina", "dependinator", "foreignination", "constinator", "Destina", " destinated", "coordinator", "dependinated", "Destribution", " destribution", "descinator", "destining", "validinate", "targetinated", "descension", "validinated"], "buffer": ["image", "pool", "temp", "flush", "sequence", "input", "window", "channel", "text", "cache", "queue", "writer", "bin", "buf", "buff", "Buffer", "padding", "uffer", "block", "binary", "transfer", "limit", "reader", "timeout", "iter", "batch", "memory", "header"], "bytes_read": ["bytesUnRead", "Bytes_set", "bytesUnread", "bytes_set", "bytesUnset", "Bytes_found", "bytesUnfound", "bytes_found", "Bytes_read", "Bytes_Read", "bytes_Read"], "in": ["ini", "image", "re", "log", "resource", "login", "temp", "serv", "stream", "inner", "current", "inn", "val", "input", "din", "In", "fe", "rec", "l", "bin", "b", "read", "r", "IN", "session", "again", "token", "path", "p", "doc", "line", "nin", "container", "min", "out", "ins", "is", "as", "ssl", "a", "request", "con", "h", "data", "file", "id", "lock", "reader", "get", "n", "or", "connection", "f", "url", "inc", "s"], "response": ["re", "body", "onse", "image", "model", "answer", "resource", "feed", "question", "view", "sequence", "Response", "respons", "json", "version", "reason", "offer", "text", "message", "reset", "output", "api", "respond", "object", "update", "status", "example", "string", "application", "r", "resp", "next", "success", "line", "result", "uri", "su", "report", "received", "request", "server", "data", "true", "error", "description", "value", "res", "location", "reply", "dict", "header"], "parentdir": ["parentDir", "parentdict", "parentfile", "partlib", " parentdirectory", "rootdir", "parentsDir", "partdirectory", "Parentdir", "parentdiff", "hostdirectory", "rootfile", "partfile", " parentdict", " parentfile", " parentlib", "partdir", "parentlib", "parentsfile", "rootdirectory", "parentsdir", "rootlib", "homefile", "parentsdiff", "hostdir", "homeDir", "homediff", " parentDir", " parentdiff", "Parentdirectory", "homedir", "Parentdict", "hostdict", "parentdirectory"]}}
{"id1": "9081749", "id2": "16063533", "code1": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "code2": "    public static byte[] encrypt(String x) throws Exception {\n        java.security.MessageDigest d = null;\n        d = java.security.MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(x.getBytes());\n        return d.digest();\n    }\n", "label": 1, "substitutes": {"encrypt": ["decryption", "escrypt", "esccrypt", "encryption", "Enccrypt", "Encrypt", "decrypt", "Encryption", "encipher", "escipher", "escryption", "deccrypt", "decipher", "Encipher", "enccrypt"], "password": ["encrypted", "Password", "image", "email", "mask", "account", "prefix", "this", "root", " passwords", "pattern", "picture", "text", "message", "parser", "cache", "key", "wallet", "wd", "pad", "string", "array", "null", "params", "buffer", "pass", "crypt", "token", "padding", "strip", "phrase", "css", "secret", "command", "auth", "name", "PASS", "word", "data", "user", "seed", "parent", "username", "weight", "sword", "description", "database", "value", "words", "project", "python", "address"], "encryptType": ["encriptTypes", "encrupttype", "encryptionType", "encryptTyp", "eciphertype", "encPTtype", "encipherType", "acryptionTypes", "acryptTyp", "acryptTypes", "encryptiontype", "encipherClass", "ecryptClass", "encPTType", "encertKey", "encripttype", "encruptTypes", "ecrypttype", "encriptType", "encryptClass", "encPTKey", "encriptTyp", "enciphertype", "encPTClass", "encryptTypes", "acryptiontype", "acryptType", "ecipherKey", "encertType", "acrypttype", "encerttype", "encruptTyp", "encruptType", "ecipherClass", "encryptionTyp", "acryptionTyp", "encertClass", "ecryptType", "encryptionTypes", "ecipherType", "encryptKey", "acryptionType", "encipherKey", "encrypttype", "ecryptKey"], "md": ["dd", "nm", "cmd", "dig", "metadata", "amd", "um", " MD", "hd", "mm", "mad", "mo", "cd", "mp", "vd", "der", "grad", "mand", "d", "bd", "pm", "df", "mt", "mac", "gd", "od", "MD", "Cmd", "hed", "mod", "dh", "pd", "mag", "rm", "dm", "mc", "f", "mb", "hm", "di", "m", "rpm"], "hash": ["image", "her", "html", "sha", "log", "base", "index", "body", "ver", "hard", "hex", "check", "filter", "version", "cache", "message", "count", "bit", "how", "key", "full", "style", "fill", "array", "code", "flash", "print", "kh", "throw", "query", "part", "build", "len", "sh", "diff", "number", "mac", "handle", "ashes", "bug", "ash", "block", "Hash", "digit", "sum", "hed", "h", "search", "ha", "data", "id", "char", "chip", "str", "value", "error", "dot", "memory", "url", "header"], "hexString": [" hexstring", "hexLine", "pixelString", "pixelstring", "hashFile", "hexSet", "blackstring", "alphLine", "alphFile", "blackString", "squareField", "hashArray", "hashString", "blackFile", "squareSet", " hexSet", " hexLine", "hexFile", "pixelBuffer", "zipArray", "zipSet", "alphstring", "alphString", " hexFile", "zipString", "hexBuffer", "rawBuffer", " hexField", "rawstring", " hexArray", "hexstring", "hexArray", "squareArray", "rawString", "zipField", "hexField", " hexBuffer", "hashstring", "rawArray", "blackLine", "rawFile", "squareString", "pixelFile"], "i": ["ini", "index", "j", "o", "oi", "temp", "end", "phi", "ii", "ix", "count", "slice", "l", "b", "info", "ui", "ri", "pi", "c", "r", "gi", "abi", "li", "ci", "p", "ie", "multi", "si", "io", "xi", "bi", "uri", "v", "x", "ai", "it", "ji", "ip", "length", "start", "off", "h", "ti", "id", "data", "qi", "e", "u", "f", "n", "di", "I", "s"]}}
{"id1": "1180878", "id2": "949327", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["frieveUrldata", "fetchURLDATA", "frieveURLDATA", "fetchJSONData", "frieveUrlDATA", "fetchHTTPDATA", "fetchUrldata", "fetchURLdata", "fetchUrlDATA", "frieveURLdata", "fetchHTTPdata", "fetchUrlData", "frieveURLData", "fetchHTTPData", "fetchJSONdata", "fetchJSONDATA", "frieveUrlData"], "url": ["image", "html", "URL", "base", "resource", "feed", "www", "view", "download", "Url", "ls", "http", "text", "src", "filename", "l", "href", "api", "page", "string", "path", "fl", "source", "uri", "xml", "ur", "name", "location", "ssl", "server", "data", "file", "user", "gl", "username", "sl", "el", "connection", "loc", "host", "f", "address"], "proxyHost": ["cacheHost", " proxyServer", "serverAddress", "serverPath", " proxyAddress", "baseHost", "baseDomain", "remoteAddress", "proxyHead", "baseAddress", "ProxyHead", "remoteDomain", "ProxyHost", " proxyPath", "proxyhost", "serverServer", " proxyhost", "proxyDomain", "baseHead", "ProxyDomain", "ProxyServer", "cachePort", "proxyPath", "remoteHead", "ProxyPath", "proxyAddress", "proxyServer", "cachehost", "cacheAddress", "ProxyPort", "ProxyAddress", "remoteHost", "Proxyhost", "serverHost"], "proxyPort": ["cacheHost", " proxyServer", " proxyport", " proxyAddress", "httpPort", "ProxyHost", "httpServer", "httpAddress", "cachePort", "Proxyport", "ProxyServer", "cacheport", "proxyAddress", "proxyServer", "proxyport", "cacheAddress", "ProxyPort", "ProxyAddress", "httpHost"], "con": ["com", "fa", "ls", "rec", "ch", "c", "cf", "rc", "ci", "per", "uc", "connection", "cr", "f", "login", "cl", "pc", "cur", "ca", "cache", "run", "sync", "conn", "CON", "ran", "co", "ocon", "cone", "connect", "go", "win", "re", "conv", "change", "sub", "fac", "fun", "don", "common", "pre", "cons", "fc", "remote", "un", "an", "x", "out", "xc", "Con", "pub", "cn", "on", "gen", "mc", "cp", "ec", "inc", "exec", "conf", "socket", "ver", "canon", "func", "can", "syn", "open", "pen", "ctrl", "http", "act", "pin", "fl", "en", "part", "ai", "min", "cc", "cas", "close", "cm", "ac", "n", "bc", "fan"], "is": ["ib", "its", "in", "can", "serv", "isi", "vs", "abs", "ops", "mis", "cms", "ir", "lis", "has", "does", "api", "info", "conn", "isu", "ws", "IS", "js", "ri", "act", "sp", "state", "ps", "was", "ie", "p", "ci", "ris", "si", "os", "it", "cs", "oss", "ai", "out", "isa", "isl", "fs", "iss", "cos", "il", "as", "es", "iso", "are", "bis", "us", "ori", "bs", "isin", "id", "isc", "ios", "Is", "i", "im", "get", "ais", "or", "ar", "iris", "ics", "s"], "u": ["ou", "o", "q", "U", "ul", "up", "ue", "http", "cu", "ut", "l", "un", "b", "ui", "uv", "api", "conn", "uci", "c", "m", "p", "io", "su", "uri", "os", "v", "client", "hu", "fu", "ur", "nu", "us", "h", "user", "file", "yu", "tu", "iu", "i", "uc", "ru", "lu", "f"], "proxy": ["force", "pool", "resource", "create", "clone", "phone", "pc", "fe", "http", "zip", "cache", "cop", " Proxy", "l", "api", "remote", "prot", "XY", "c", "pe", "pin", "Proxy", "pa", "plus", "p", "type", "xy", "uri", "x", "roxy", "ip", "client", "pse", "ssl", "bean", "wrapper", "server", "shadow", "port", "timeout", " proxies", "lib", "connection", "config", "host", "web", "f", "socket", "copy", "address"], "baos": ["abis", "baOS", "caas", "caos", "haOS", "bao", "bais", "BAOS", "BAos", "BAis", "pao", "boOS", "hao", "BaOs", "Baos", "boas", "haos", "calos", "caOS", "paOS", "Bais", "balos", "paos", "baas", "boos", "abOs", "abros", "BAo", "baOs", "aas", "bolos", "Baros", "pais", "hais", "alos", "baros", "BAOs", "aos", "aOS", "abos", "BAros"]}}
{"id1": "9319440", "id2": "10715601", "code1": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"load": ["link", "resource", "create", "check", "download", "open", "find", "show", "update", "read", "loaded", "LOAD", "work", "upload", "loading", "start", "loader", "init", "dump", "file", "transfer", "Load", "loads", "get", "install", "library"], "id": ["image", "link", "plugin", "base", "resource", "create", "root", "json", "bid", "kid", "ids", "text", "filename", "key", "info", "uid", "string", "code", "did", "token", "path", "pid", "type", "ID", "uri", "aid", "Id", "ip", "is", "start", "name", "sid", "request", "file", "data", "i", "source", "f"], "xml": ["image", "model", "html", "log", "dr", "email", "expl", "feed", "www", "raw", "impl", "stream", "wl", "xxx", "content", "sheet", "event", "ul", "audio", "write", "json", "input", "plain", "entry", "zip", "http", "text", "parser", "java", "writer", "full", "ws", "page", "string", "element", "txt", "form", "spec", "path", "work", "job", "doc", "line", "ml", "x", "response", "layer", "bug", "name", "ssl", "request", "server", "file", "document", "data", "layout", "php", "el", "enter", "web", "address"], "url": ["image", "log", "URL", "base", "resource", "service", "feed", "www", "stream", "download", "Url", "open", "channel", "http", "zip", "l", "b", "bb", "api", "page", "string", "db", "org", "uri", "build", "layer", "blog", "client", "loader", "socket", "ssl", "tool", "server", "file", "ll", "gl", "ob", "user", "connect", "browser", "sl", "connection", "config", "source", "web", "f", "address"], "conn": [" manager", " con", " factory", "Url", "nc", " net", "Connection", "http", "l", "ch", " conf", "c", "r", " mc", "er", "ci", "io", " pool", " db", "client", "loader", "ssl", " connection", "con", " internet", " auth", "Conn", "connection"], "reader": ["err", "dr", "lr", "feed", "rx", "stream", "rer", "inner", "input", "worker", "rt", "http", "reading", "parser", "ler", "rar", "bird", "l", "writer", "finder", "read", "ri", "driver", "builder", "r", "buffer", "rc", "oder", "handler", "er", "io", "rr", "uri", "row", "ner", "loader", "hr", "server", "ser", "iterator", "Reader", "i", "iter", "connection", "f", "editor"], "str": ["enc", "err", "lc", "in", "dr", "fr", "kr", "coll", "val", "input", "arr", "cl", "entry", "text", "l", "STR", "pr", "string", "read", "code", "txt", "r", "t", "tr", "wr", "strip", "st", "er", "stri", "p", "line", "doc", "dict", "x", "sr", "data", "inst", "char", "e", "Str", "sl", "i", "iter", "br", "cr", "f", "obj", "s"]}}
{"id1": "3558512", "id2": "19378010", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static Multimap<String, String> getProteins(final Set<String> queries, final int taxon) throws ParserConfigurationException, XPathExpressionException {\n        final DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        final XPathExpression xpe = XPathFactory.newInstance().newXPath().compile(__xpath);\n        final Multimap<String, String> proteins = HashMultimap.create();\n        for (final String query : queries) {\n            HttpURLConnection connection = null;\n            try {\n                final String encoded = URLEncoder.encode(query.trim(), \"UTF-8\");\n                final URL url = new URL(String.format(__urlTempl2, encoded, taxon));\n                connection = (HttpURLConnection) url.openConnection();\n                connection.setConnectTimeout(__connTimeout);\n                connection.setReadTimeout(__readTimeout);\n                connection.setRequestProperty(\"Connection\", \"close\");\n                connection.connect();\n                final InputStream stream = connection.getInputStream();\n                final Document doc = parser.parse(stream);\n                final NodeList nodes = (NodeList) xpe.evaluate(doc, XPathConstants.NODESET);\n                if (nodes != null) {\n                    final int n = nodes.getLength();\n                    for (int i = 0; i < n; i++) {\n                        final Node node = nodes.item(i);\n                        proteins.put(node.getTextContent().trim(), query.trim());\n                    }\n                }\n            } catch (final Exception ex) {\n                continue;\n            } finally {\n                if (connection != null) connection.disconnect();\n            }\n        }\n        return proteins;\n    }\n", "label": 0, "substitutes": {"serialize": ["Serialify", " serializable", "erialize", "serialization", "erialze", "erialization", "Serialized", "Serializable", "Serialize", "finalze", "normalized", "finalize", " serialze", "Serialze", " serialization", "normalize", "serialze", "serialify", "serializable", "normalify", "erializable", "finalify", "finalized", "Serialization", "serialized", "normalze"], "out": ["err", "image", "pool", "o", "temp", "raw", "content", "w", "up", "cache", "exec", "filename", "output", "OUT", "writer", "conn", "bin", "page", "string", "buffer", "outs", "io", "Out", "client", "loader", "report", "name", "a", "dump", "archive", "server", "data", "file", "gen", "png", "ex", "i", "source", "parent", "obj", "copy"], "parser": ["base", "system", "tt", "arser", "pillar", "worker", "up", "parse", "master", "cache", "rar", "writer", "lp", "builder", "class", "txt", "pp", "pe", "handler", "er", "p", "upload", "Parser", "xml", "as", "manager", "loader", "test", "wrapper", "server", "file", "seed", "php", "instance", "ss", "reader", "per", "pkg", "cp", "parent", "plugin", "copy", "processor"], "on_disk": ["onJdisk", "onjspace", "onJdemand", "onjdrive", "on_delete", "on_drive", "onjfile", "onJlock", "onbookdisk", "onnetdemand", "on_storage", "off_demand", "on_file", "onnetdisk", "onbootdisk", "onnetspace", "onJdrive", "onbookdelete", "on_lock", "off_disk", "off_storage", "onbootlock", "onjdisk", "onnetdrive", "onbookdrive", "onbootstorage", "off_file", "onbootdrive", "off_space", "on_space", "onnetfile", "off_lock", "off_drive", "off_delete", "on_demand"], "in": ["ini", "kin", "o", "login", "stream", "inner", "inn", "input", "In", "bin", "conn", "info", "c", "pin", "IN", "r", "again", "pass", "source", "min", "ins", "lin", "as", "inas", "ac", "thin", "con", "data", "file", "rin", "ax", "reader", "i", "win", "connection", "din", "f", "socket", "inc", "copy"]}}
{"id1": "17190057", "id2": "1097147", "code1": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"encode": ["encescape", "Enescape", "enccode", "unode", "unescape", "enescape", "enode", "Encode", "uncode", "Enode"], "input": ["image", "in", "temp", "raw", "prefix", "this", "stream", "xxx", "hex", "inf", "form", "format", "audio", "pattern", "Input", "alpha", "text", "output", "password", "string", "null", "array", "def", "buffer", "amp", "crypt", "plus", "result", "addin", "img", "context", "secure", "ssl", "request", "data", "binary", "instance", "str", "empty", "i", "reader", "config", "source", "address"], "NoSuchAlgorithmException": ["NoSuchAlodingError", "NoSuchAlgoWarning", "NoSuchEdryptionement", "NoSuchAlgorithmWarning", "NoSuchEdgorithmException", "NoSuchEdryptionWarning", "NoSuchAlgorithmError", "NoSuchAlryptionError", "NoSuchAlgorithmement", "NoSuchAlodingWarning", "NoSuchAlgoException", "NoSuchEdryptionException", "NoSuchAlodingException", "NoSuchEdryptionError", "NoSuchAlryptionWarning", "NoSuchAlgoError", "NoSuchAlryptionement", "NoSuchEdgorithmWarning", "NoSuchAlryptionException", "NoSuchEdgorithmError", "NoSuchAlgoement", "NoSuchAlodingement", "NoSuchEdgorithmement"], "md": ["dd", "nm", "mi", "sha", "cmd", "dc", "dig", "metadata", "ma", "um", " MD", "amd", "hd", "mm", "mad", "mo", "message", "zip", "key", "ms", "cd", "wd", "mp", "code", "hash", "mand", "d", "m", "bd", "ad", "doc", "pm", "df", "mt", "mac", "od", "me", "MD", "sum", "mod", "pd", "mag", "dm", "mc", "mb", "meta", "db"]}}
{"id1": "11645260", "id2": "6371589", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "code2": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doGet": [" doGET", "doRead", "handleGet", "partialPut", "handlePut", " doRead", "partialGET", "partialGet", "handleGET", "partialRead", "doPut", " doPut", "doGET", "handleRead"], "request": ["image", "method", "model", "right", "in", "resource", "create", "child", "service", "view", "this", "current", "event", "forward", "input", "project", "order", "worker", "version", "req", "message", "queue", "key", "authorized", "info", "post", "object", "QUEST", "application", "string", "position", "condition", "subject", "external", "session", "next", "query", "path", "join", "Request", "hello", "type", "require", "result", "uri", "rest", "client", "context", "xml", "report", "name", "server", "user", "data", "reference", "e", "call", "instance", "reader", "complete", "web", "enter", "connection", "requ", "host"], "response": ["re", "onse", "body", "model", "image", "service", "resource", "wave", "feed", "site", "view", "this", "event", "Response", "respons", "function", "json", "fire", "version", "http", "message", "cache", "output", "queue", "api", "respond", "environment", "object", "writer", "page", "remote", "status", "application", "subject", "resp", "session", "success", "result", "client", "manager", "report", "ception", "esi", "server", "user", "document", "error", "results", "res", "complete", "connection", "host", "parent", "reply"], "target": ["force", "base", "resource", "site", "point", "root", "content", "format", "head", "Target", "open", "pattern", "blank", "top", "src", "output", "remote", "href", "replace", "object", "home", "params", "route", "external", "session", "token", "path", "join", "template", "source", "type", "result", "it", "uri", "dest", "context", "name", "location", "test", "bean", "loc", "component", "shadow", "range", "port", "parent", "timeout", "arget", "follow", "rel", "host", "project", "address"], "requestUrl": ["requestURL", "queryEl", "nextLocation", "requestElement", "queryURL", " requestURL", "adjustHost", " requestHost", " requestLocation", "adjustElement", "raiseUrl", "adjustLocation", "requestLocation", "nextURL", "requestHost", "queryUrl", "raiseElement", " requestElement", " requestEl", "raiseLocation", "adjustUrl", "queryLocation", "nextEl", "raiseHost", "requestEl"], "en": ["enc", "de", "in", "ern", " EN", "end", "env", "EN", "eng", "et", "ener", "fen", "ane", "ne", "den", "que", "un", "ann", "En", " En", "set", "ven", "pe", "wen", "au", "er", "ren", "ent", "an", "len", "eni", "es", "ens", "ena", "ae", "esi", "on", "oa", "e", "gen", "el", "n", "een", "enn", "ec", "m", " e"], "nextUrl": [" nextURL", "NextURL", "newEl", " nextEl", "NextUrl", "newURL", "nextURL", "NextLine", "nextPage", "newPage", "newUrl", " nextPage", "NextPage", "nextLine", "nextEl", "newLine", "NextEl", " nextLine"], "allowedToAccess": [" allowedToAuth", "allowedFromaccess", "allowedtoaccess", "allowedFromAccess", "allowedTOAuth", "allowedTOAccess", " allowedtoAccess", "allowedtoAuth", " allowedtoRead", "allowedTORead", "allowedtoAccess", " allowedtoAuth", "allowedToAuth", "allowedToRead", " allowedToaccess", "allowedFromRead", "allowedTooAuth", "allowedToaccess", "allowedtoRead", "allowedTooRead", " allowedTOaccess", " allowedToRead", " allowedTOAccess", " allowedTORead", "allowedTOaccess", "allowedTooAccess", " allowedtoaccess"], "is": ["image", "ib", "its", "in", "address", "can", "serv", "isi", "inner", "vs", "abs", "ops", "over", "ls", "up", "src", "cms", "ir", "http", "does", "has", "api", "info", "ui", "conn", "bb", "IS", "iv", "ri", "ise", "ack", "was", "ic", "ci", "p", "ie", "ris", "it", "os", "uri", "isl", "ai", "isa", "iss", "ip", "ins", "cos", "as", "close", "app", "iso", "us", "ori", "bs", "id", "ob", "isc", "ios", "browser", "Is", "i", "ais", "get", "or", "loc", "web", "s"], "out": ["ou", "err", "log", "image", "pool", "in", "o", "outer", "temp", "resource", "can", "gin", "inner", "to", "obj", "up", "exp", "group", "cache", "sync", "output", "OUT", "remote", "bin", "conn", "writer", "object", "c", "external", "again", "outs", "path", "not", "io", "Out", "client", "block", "cos", "as", "off", "app", "name", "socket", "init", "ext", "co", "ac", "con", "parent", "lock", "error", "ex", "no", "win", "get", "timeout", "inc", "exec"], "url": ["image", "log", "URL", "base", "resource", "www", "config", "impl", "stream", "mount", "ul", "Url", "cur", "channel", "http", "l", "page", "c", "rc", "path", "source", "uri", "plug", "blog", "client", "bug", "ur", "ssl", "server", "user", "sl", "get", "bc", "connection", "loc", "host", "web", "f"], "uc": ["ou", "lc", "UC", "in", "uu", "cci", "self", "ud", "ub", "ul", "um", "nc", "pc", "usc", "anc", "up", "http", "fc", "conn", "connection", "uci", "soc", "c", "unic", "rc", "path", "sc", "ci", "uri", "su", "unc", "xc", "client", "cc", "oc", "ucc", "cus", "auc", "us", "ac", "con", "union", "cv", "mc", "uca", "bc", "ec", "loc"], "buf": ["wb", "pool", "box", "cmd", "br", "vec", "ba", "av", "ff", "queue", "bag", "uf", "b", "cb", "bytes", "bin", "pad", "cap", "cat", "bh", "cf", "buff", "buffer", "rc", "fd", "bb", "fb", "lb", "bf", "bd", "len", "block", "cas", "ucc", "map", "loc", "data", "cv", "af", "rb", "bc", "seq", "batch", "ctx"], "bytesRead": ["secondsread", "wordsRead", "wordsCopy", "bytesread", "tesread", "tesTotal", "BytesRead", "unitsWritten", "secondsCopy", "tesWrite", "tesRead", "wordsWrite", "unitsHave", "secondsWrite", "bitsRead", "tesCopy", " bytesWritten", "unitsWrite", "BytesWritten", "BytesWrite", "secondsRead", " bytesWrite", "bytesTotal", "bytesCopy", "wordsread", "bitsWritten", "bytesHave", "BytesHave", "bitsread", " bytesHave", "bytesWrite", "bytesWritten", "unitsRead", " bytesTotal", " bytesread", "bitsTotal", "tesWritten"]}}
{"id1": "9096319", "id2": "20073619", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "label": 0, "substitutes": {"handleNodeRegainedService": ["handleNoderegainedServices", "handleNodeReginedEvent", "handleNodeRegainsServices", "handleNodeRegainsService", "handleNoderegainedService", "handleNodeReginedService", "handleNodeRegainingService", "handleNoderegainsService", "handleNodeRegainingEvent", "handleNoderegainedEvent", "handleNodeRegainsEvent", "handleNoderegainsServices", "handleNodeReginedServices", "handleNodeRegainingServices", "handleNodeRegainedServices", "handleNodeRegainedEvent", "handleNoderegainsEvent"], "eventID": ["issueName", "issueId", "eventid", "updateId", "issueid", "updateid", "nodeName", " eventId", " eventid", "updateName", "updateID", "nodeId", "issueID", "nodeTime", "serviceId", "serviceName", " eventName", "eventId", "eventName", "serviceTime", "serviceid"], "nodeID": ["globalId", " nodeRI", "siteid", "globalID", " nodeName", "nodeResult", "eventid", "siteName", "odeName", "nodeName", "odeResult", " nodeId", "siteID", "globalPath", "eventResult", "objectName", "odeID", "odeRI", "sourceId", "nodeId", "resourceID", "eventPath", "packageId", "eventKey", "serviceId", "odeId", "objectid", "eventId", "nodeKey", "nodePath", "packageID", "resourceKey", "objectId", "globalid", " nodeid", "nodeRI", "eventName", "sourceID", " nodeKey", "packageid", "serviceid", "siteId", "resourceId", " nodeResult", "objectID", "sourceRI", "nodeid", " nodePath"], "ipAddr": ["IPAddresser", " ipAppr", "IPAddri", " ipAttrs", "IPAddr", "ipAdr", "ipOffri", "ipAdrs", "IPAddressn", "IPAdder", "IPAddn", " ipAddri", "ipAtter", "ipCher", "ipAttrs", "ipAddrs", "IPAddrs", "ipAddresser", "ipAttvr", "ipAddressn", " ipAppvr", "ipaddvr", "ipAddrt", " ipAdder", "ipOffr", "IPAddressrt", "ipaddress", "ipChr", "ipaddri", "ipAdder", "ipAddressri", "ipAttr", " ipAtter", "ipChrs", "ipAppr", "IPAddressrs", " ipAttr", "ipaddr", "ipAddvr", " ipAddrs", "ipAddressrs", "IPAddrt", "ipAddress", "ipOffrt", "ipAddressr", "ipAppvr", "ipAttri", " ipAttvr", "IPAddressri", "ipAddressress", "ipAder", "ipadder", " ipApprs", "ipAddressrt", "ipApprs", "ipAdn", "IPAddressr", "ipAddressvr", " ipAddvr", " ipAddress", "ipOffrs", "ipaddrs", "ipChn", " ipAttri", "ipAddn", "ipAddri"], "serviceID": ["eventIDs", "ServiceId", "ServiceName", "featureIP", "serverId", "serviceIP", "skillNAME", "featureID", "featureHandle", "processName", "serverName", "serverID", "featureId", " serviceNAME", " serviceName", "ServiceType", " serviceId", "serviceHandle", "serviceIDs", " serviceHandle", "serviceNAME", "ServiceIDs", "resourceID", "ServiceNAME", "ServiceIP", "processId", "serviceId", "serviceName", "ServiceHandle", "serviceX", "ServiceID", "resourceType", "skillName", "serverX", "eventId", "processID", " serviceIP", "skillId", "eventName", "serviceType", " serviceType", "resourceId", "skillID", "eventX", " serviceX", " serviceIDs"], "eventTime": [" eventTim", " eventTIME", "changeType", "errorTime", "processTime", "eventPoint", "processTim", "processName", " eventPoint", "EventName", "eventType", "changePoint", "changeTime", "eventTim", " eventType", "EventID", "EventTime", "EventTim", "errorPoint", " eventName", "errorType", "changeTIME", "eventTIME", "processID", "eventName", "errorTIME"], "log": ["com", "model", "pool", "feed", "temp", "crit", "event", "debug", "stop", "w", "format", "cl", "write", "net", "entry", "exp", "sec", "http", "cache", "key", "output", "l", "ch", "conn", "info", "cat", "full", "contract", "c", "LOG", "pe", "path", "pl", "type", "stat", "fail", "it", "plug", "build", "out", "sign", "loop", "blog", "bug", "lex", "Log", "tool", "ge", "host", "lo", "gen", "level", "port", "call", "put", "lock", "thread", "error", "og", "get", "or", "connection", "config", "tag", "db", "url"], "dbConn": ["fbConn", "fbCon", "DBCon", "Dbconn", "cbConnection", "DBConn", "DBConnection", "databaseConnection", "DBCt", " dbCt", "dbConnection", "dbColl", "dbCon", " dbConnection", "dbLoc", "cbConn", "bbConnect", "DbLoc", "DbCt", "DbConn", " dbLoc", "dbDb", "bbCon", " dbconn", "dbconn", "databaseConn", " dbCon", "fbCt", "bbConnection", "realCon", "logDb", "DbConnection", " dbDb", "databaseLoc", "DbConnect", "DBConnect", "cbconn", "fbColl", "realConn", "DbDb", "logconn", "cbConnect", "bbConn", "bbconn", "databaseconn", "logConn", "realCt", " dbConnect", "realColl", "DBconn", "dbCt", " dbColl", "dbConnect", "logConnect"], "outageUpdater": ["outageUdarer", "outageUpdatedrapper", "outageuplatter", "outageUpraser", "outageUpdrATER", "outageUpnoster", "outageUppaser", "outageAppnator", "outageUpfapper", "outageUpdager", "outageUpdrapper", "outageUpdoder", "outageUprater", "outageUpdsator", "outageUpdatter", "outageAppnager", "outageUpdatATER", "outageUpdrarer", "outageUpdatedratable", "outageUpdATER", "outageUpdatedapper", "outageUpdoster", "outageUpnoder", "outageUpstater", "outageUtdatter", "outageUpmager", "outageUpdusher", "outageUptaser", "outageChdroster", "outageUtdater", "outageAppdter", "outageAppdator", "outageAppnater", "outageUpfater", "outageUdaser", "outageUpdroster", "outageUpfaser", "outageUpdataser", "outageUpdatatable", "outageChdoder", "outageUpdatedrater", "outageUptatable", "outageUpdsoster", "outageUtdarter", "outageUpparter", "outageUpdarter", "outageUpdsoder", "outageUpdatedrarer", "outageUplusher", "outageUpnager", "outageUpdter", "outageuplater", "outageUpdatatter", "outageUpndter", "outageUpratter", "outageUpdatedrATER", "outageUnater", "outageUpnter", "outageUpdapper", "outageUprusher", "outageupdusher", "outageChdrator", "outageUpnater", "outageUpnATER", "outageUptarer", "outageUpndatter", "outageUpnaser", "outageUpdsater", "outageUppter", "outageUpdatable", "outageupdater", "outageupdaser", "outageUdATER", "outageUpdrusher", "outageUpmator", "outageUtdter", "outageChdroder", "outageUplatter", "outageChdator", "outageUpdatedatable", "outageUpnarer", "outageUpdratable", "outageChdrater", "outageUpdratter", "outageUtdatater", "outageUdater", "outageUtdatarter", "outageUpdatedraser", "outageUnaser", "outageUpnator", "outageUpdatedarer", "outageUpdrater", "outageAppnter", "outageUpndater", "outageUpdatedaser", "outageUpstager", "outageUpstter", "outageUpdatarter", "outageUpdatarer", "outageUpdatedratter", "outageUpdatedATER", "outageUplapper", "outageUpdraser", "outageUnarer", "outageUpmater", "outageupdatter", "outageuplaser", "outageUpdatedater", "outageUpdrator", "outageUptater", "outageUppater", "outageuplusher", "outageUpdatedatter", "outageUnATER", "outageUpndarter", "outageChdater", "outageUtdatatter", "outageUpstator", "outageUpmter", "outageUpfatter", "outageAppdager", "outageUpdator", "outageUplater", "outageAppdater", "outageUpdatater", "outageUpdroder", "outageUplaser", "outageUpdarer", "outageChdoster", "outageUppATER", "outageUpdaser", "outageUppatter"]}}
{"id1": "14390569", "id2": "13499897", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 1, "substitutes": {"title": ["image", "body", "html", "resource", "section", "prefix", "itle", " Title", "content", "format", "itles", "version", "alpha", "license", "text", "message", "details", "filename", "label", "page", "string", "summary", "heading", "subject", "phrase", "type", "part", "notes", "ppa", "Title", "size", "name", "term", "TIT", "chapter", "data", "id", "layout", "description", "theme", "desc", "msg", "url", "header"], "imageURL": [" imageurl", "mediaUrl", "ImageUrl", "pictureURI", "filePath", "imgPath", "ImagePath", "pictureUrl", "mediaURI", "imgURL", "ImageURI", "imgUrl", "fileURI", "imageURI", "mediaURL", "ImageURL", " imageUrl", " imageURI", "imageurl", "imageUrl", "fileURL", "fileurl", "fileUrl", "pictureurl", "imgURI", "pictureURL", "imagePath"], "jd": [" jdl", "je", "ajD", "qdh", " jdd", "Jb", "jjdh", "jds", "zl", "ajdos", "Jdos", "Je", "jjdo", "jackb", "jackf", "ajdl", "jdom", "ssdo", "Jdo", "jdi", "ajdh", "jobdo", "ssdi", " jdo", "jsdh", "jD", "jjb", "Jds", "adjdos", "qb", "ajdo", "zf", "jsdo", "jsb", "jobD", "zb", "ajdi", "zd", " jdh", "jf", "ajd", "qd", " jds", "jackdd", "jjd", "argdo", "qdo", "Jf", "argf", " je", "zdo", "jsd", " jdi", " jf", "adjdo", "qdom", "JD", "jdos", "zdd", "zds", "jobb", "jdd", "Jl", "Jdom", "jdh", "adjb", "jdo", " jdom", "ze", "ssd", "ajb", "jobd", "argd", "jdl", "Jd", "ajf", "argdl", "jackd", " jD", "ssD", "adjd"], "jl": ["j", "jc", "eb", "nl", "kn", "wl", "kj", "syn", "lf", "bl", "cli", "Label", "l", "label", "ld", "vd", "lp", "NJ", "uj", "hl", "chal", "kl", "li", "dl", "iji", "lb", "ja", "JM", "elly", "ji", "jon", "elt", "dj", "fp", "zl", "il", "jj", "oji", "iol", "bn", "lv", "kel", "ll", "adj", "el", "bj", "lu", "igl"], "icon": ["image", "pic", "action", "resource", "ion", "content", " Icon", "alias", "picture", "text", "fc", "iao", "label", "info", "ui", "ann", "Icon", "core", "token", "ic", "note", "uni", "io", "eye", "uri", "icons", "cha", "css", "img", "size", "bn", " image", "cn", "on", "gn", "artist", "png", "ico", "n", "plugin", "url", "header"], "chooser": ["Chooses", "Choosen", " choressor", "closer", "boosen", " choosen", " chooses", "clressor", "Chooder", "boressor", "choose", " choose", "chooses", "chooder", "choressor", "Choose", " chooder", "choosen", "dialoser", "joose", "boose", "booser", "Chooser", "close", "cler", "dialosen", "jooses", "closen", "dialer", "jooder", "choer", "jooser", "dialose", "Choer"], "jp": ["j", "JP", " pa", " dock", " JM", " cm", " gp", " ax", " pane", " app", " j", " bridge", " dj", "bj", " tmp", "ja", " bar", "ji", " robot", " np", " js", " je", " plugin", "Panel", " pic", " mp", " obj", " sp", " cp"], "jb": ["ajsb", " jcb", "jbb", "djcb", "qf", "jscb", "djb", "jf", " jbb", "ajcb", "ajb", " jsb", "djd", "qsb", "jsbb", "ajf", "qb", "qcb", "jsd", "djbb", " jf", "jcb", "jsb"], "e": ["de", " ate", "in", " fe", "event", "exc", " Event", "je", "et", "E", " E", "c", "pe", "t", "ie", "v", "x", "ce", "ception", "a", "ae", "ev", "te", "ctx", "ec", "f", "ee"], "returnVal": ["Returnval", "returnNum", "resultNum", "ReturnVal", " returnVAL", "ReturnVAL", "resultVal", "returnValue", "ReturnValue", "replyVAL", " returnNum", " returnValue", "replyVal", "resultval", " returnval", "resultValue", "replyval", "replyValue", "returnVAL", "ReturnNum", "returnval"], "file": ["model", "force", "unit", "ban", "filename", "queue", "full", "page", "show", "future", "single", "dir", "name", "binary", "comment", "lib", "parent", "f", "directory", "body", "folder", "log", "pool", "po", "function", "local", "play", "b", "info", "auto", "files", "core", "handler", "io", "build", "fp", "FILE", "il", "user", "document", "get", "book", "File", "base", "module", "ile", "parse", "zip", "use", "l", "object", "home", "path", "line", "type", "out", "data", "lock", "db", "image", "letter", "rule", "die", "picture", "load", "http", "message", "pe", "buffer", "work", "part", "live", "url"], "fileName": ["singlePath", " filePath", "imageName", "binaryPath", "fileType", "filePath", "singleType", "resourceInfo", "FileInfo", "filename", "resourcePath", "binaryUrl", "FilePath", "imagename", "imageInfo", "FileName", " fileUrl", "Filename", " fileType", " filename", "imageUrl", "resourceName", "singleName", "fileUrl", " fileInfo", "singlename", "binaryName", "fileInfo", "FileType", "imagePath", "singleInfo", "resourcename"], "ext": ["enc", "format", "eng", "ension", "feat", "version", "oct", "exp", "sec", "xt", "ch", "extra", "txt", "class", "pe", "orig", "ct", "ace", "t", " Ext", "path", "fb", "p", "Ext", "type", "phrase", "alg", "v", "xp", "name", "EXT", "word", "ax", " extension", "qt", "ex", "desc", "abc", "lib", "f", "obj"], "i": ["z", "ini", "mi", "j", "o", "ion", "ment", "phi", "cli", "ii", "mini", "api", "b", "info", "ui", "ri", "pi", "c", "gi", "li", "ci", "p", "multi", "si", "ni", "io", "xi", "bi", "v", "uri", "ai", "y", "ip", "is", "bis", "a", "ti", "id", "iu", "u", "di", "m", "I"], "doIt": ["DOIt", "DOIT", "DOWhich", " doIT", "doYou", "poIt", "poit", "diIts", "addIt", " doNot", "doNot", "doit", "hoit", "diIT", "diIt", "skipit", "odoIt", "poIT", "poYou", "skipIts", "hoIT", "addIT", "doIts", "doWhich", "doIT", "skipIT", "odoNot", "odoWhich", " doYou", "odoit", " doit", "addit", " doIts", "skipIt", "DOit", " doWhich", "odoIT", "hoIt", "diit", "addNot", "hoYou"], "src": ["conv", "rx", "sub", "impl", "storage", "stream", "gz", "RC", "input", "ff", "cur", "target", "fi", "fc", "slice", "sync", "b", "bb", "cb", "sup", "ources", "buf", "gb", "r", "dist", "cdn", "rc", "sn", "path", "split", "st", "sc", "cmp", "ource", "upload", "rel", "sb", "attr", "img", "pull", "rest", "sq", "secure", "cos", "rs", "tmp", "socket", "ssl", "us", "sel", "Dest", "inst", "sth", "sl", "desc", "rb", "ctx", "uc", "bc", "loc", "source", "url"], "dest": ["wb", "die", "dev", "cont", "config", "done", "dc", "dat", " Dest", "trans", "target", "output", "later", "ctr", "uv", "wd", "sup", "home", "comb", "usr", "exit", "dist", "cdn", "route", "st", "proc", "prop", "destroy", "rest", "img", "gd", "std", "dir", "tmp", "Dest", "dep", "inst", "gen", "desc", "uc", "di", "loc", "source"]}}
{"id1": "3252116", "id2": "3187685", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"getMD5": ["getMAC3", "getMAC512", "getMD512", " getMD3", " getMD4", "getMD4", " getSHA3", "getMAC5", "getMP5", " getSHA4", " getSHA512", "getMD3", "getMP512", " getSHA5", " getMD512", "getSHA512", "getSHA5", "getMP4", "getMP3", "getSHA4", "getSHA3", "getMAC4"], "source": ["body", "base", "service", "resource", "SOURCE", "this", "stream", "Source", "content", "input", "target", "src", "text", "slice", "output", "password", "object", "string", "code", "sp", "from", "buffer", "ource", "result", "uri", "dest", "fp", "secret", "data", "file", "document", "e", "sl", "security", "connection", "config", "parent", "f", "url"], "s": ["its", "ops", "ls", "services", "ns", "ends", "als", "b", "bytes", "js", "ws", "string", "r", "g", "ps", "t", "rows", "d", "p", "ds", "si", "S", "os", "sb", "sg", "series", "fs", "ins", "is", "ses", "rs", "es", "bis", "ssl", "gs", "ings", "h", "e", "sym", "ss", "sl", "results", "n", "sets", "ts", "m", "strings", "f"], "hexDigits": ["hexdigitives", "hexdigings", " hexDigings", "tempSignites", "hashFormits", "hexdigats", "hexSignings", "hexDigats", "hexSignals", "tempDigals", "hexdigases", "hexSignitives", "hexdigits", " hexDigases", "hashDigists", "hexEdites", "hexdigites", "tempSignists", "tempDigits", "hexEdits", "hexEdals", "hexFormats", "hexDigings", "hexFormitives", "hexdigit", "hexSignits", "hexdigists", "hexFormists", "hexSignases", "tempDigites", "hexSignats", "hexDigites", "tempSignits", "hexdigals", "hexEdists", "hexDigit", "hexDigases", "tempDigists", "hexSignit", "hashDigits", "hexSignites", "hexFormits", "hexDigals", "tempSignals", "hashFormists", "hexDigists", "hashDigitives", " hexDigit", "hexDigitives", "hashDigats", "hexSignists", "hashFormitives", "hashFormats"], "md": ["dd", "nm", "mi", "sha", "mail", "cmd", "meta", "am", "dc", "dig", "amd", "ma", "um", " MD", "metadata", "hd", "mm", "mad", "mu", "cd", "wd", "mp", "vd", "mand", "bf", "bd", "pm", "df", "sm", "mg", "mac", "mt", "cm", "MD", "pd", "mag", "rm", "dm", "mc", "em", "mb", "di", "m", "rpm", "f"], "tmp": ["np", "base", "temp", "storage", "config", "pre", "area", "api", "now", "cb", "mp", "sup", "extra", "pad", "bp", "txt", "array", " temp", "sp", "buf", "buff", "pp", "params", "buffer", "cpp", "wp", "fb", "p", "cmp", "pointer", "v", "dest", "proc", "img", "bt", "app", "test", "ppo", "data", "seed", "append", "stuff", "rb", "meta", "obj"], "str": ["enc", "err", "dec", "unit", "j", "dr", "fr", "temp", "hex", "inner", "arr", "cur", "exp", "text", "sec", "exec", " substr", "STR", "ctr", "pr", "style", "string", "code", "pos", "sp", "txt", "r", "spec", "tr", "st", "stri", "dict", "doc", "div", "part", "v", "cs", "hr", "sr", "data", "char", "Str", "ss", "sl", "iter", "br", " sp", "cr", "obj"], "k": ["ek", "j", "o", "q", "ak", "unk", "ku", "sk", "w", "kid", "kat", "key", "b", "ch", "kk", "c", "g", "d", "ok", "kick", "ck", "p", "work", "v", "x", "y", "kw", "mk", "K", "ko", "dk", "id", "e", "u", "n", "ks", "ki", "f"], "i": ["z", "ini", "j", "index", "in", "chi", "oi", "hi", "phi", "ii", "mu", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "t", "abi", "li", "d", "ci", "p", "shift", "multi", "si", "io", "xi", "bi", "uri", "v", "x", "ai", "it", "ji", "y", "ip", "a", "ti", "qi", "e", "iu", "u", "f", "n", "di", "m", "I"], "byte0": ["byte2", " byte5", "word5", "pixel0", "word0", "number00", " byte6", "pixelk", "byte6", "byte1", "word1", "numberk", " byte00", " byte1", "letter00", " byte2", "letterk", "byte5", "pixel5", "number2", "number6", "pixel00", "letter2", "pixel6", "word2", "letter0", "number0", "number1", "bytek", "number5", "pixel2", "byte00"]}}
{"id1": "3745402", "id2": "23335922", "code1": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 1, "substitutes": {"createCipher": ["createScursor", "createCSecret", "createCrypt", " createScursor", "createScrypt", " createCSecret", "createScSecret", "createcipher", " createScipher", "createIntegrypt", "createCursor", "createIntegSecret", " createCrypt", "createIntegipher", "createIntegursor", "createScipher", " createScrypt", " createScSecret", "createcursor", "createcSecret", " createCursor", "createcrypt"], "passwd": ["Password", "passwordpassword", "passwordword", "Passphrase", "passwordphrase", "passpassword", "password", "failword", "passphrase", "passWD", "passwordwd", "failWD", "failwd", "Passwd", " password", "failpassword", "PassWD", " passWD", "Passpassword", " passpassword", " passphrase"], "mode": ["method", "slave", "cmd", "module", "mask", "depth", "prefix", "direction", "role", "domain", "mm", "version", "message", "slice", "password", "MODE", "driver", "code", "core", "path", "phrase", "type", "mac", "command", "dir", "manager", "name", "language", "mod", "server", "range", "seed", "Mode", "level", "delay", "time", "phase", "source", "address"], "keySpec": ["keyConfig", "KeySpec", "secretCS", "KeyCS", "KeyConfig", "KeyFactory", "secretSet", "Keyspec", "signSpec", " keyspec", "secretFactory", " keyConfig", "signConfig", " keyCS", "keyCS", "signspec", "KeySet", "keySet", "secretSpec", "keyspec", " keySet"], "keyFactory": ["KeySpec", "KeyFactory", "KeyFamily", "secretFactory", "kService", "keyFamily", "kFactory", "kFamily", "keyService", "secretService", "KeyService", " keyService", "kSpec", "secretSpec", " keyFamily"], "key": ["enc", "base", "temp", "keys", "sk", "KEY", "text", "message", "cache", "pair", "ke", "password", "cert", "code", "hash", "c", "pe", "state", "pass", "core", "k", "p", "phrase", "type", "source", "ce", "sign", "secret", "mac", "pub", "name", "ssl", "sum", "data", "file", "id", "seed", "user", " secret", "Key", "config", "ki"], "md": ["dd", "sha", "cmd", "dr", "meta", "dc", "dig", "metadata", "ma", "amd", " MD", "hd", "mm", "message", "cd", "mp", "vd", "mand", "d", "bd", "ad", "pm", "df", "mt", "sm", "mac", "cm", "MD", "material", "msg", "dh", "mag", "dm", "mc", "f", "mb", "m", "db"], "digest": ["mdested", "digend", "mdend", "demested", "DigEST", "mdest", "mdEST", "digester", "Digester", "demeter", "demester", " digend", "Digested", "digeter", "Digend", "mdester", " digeter", "signeter", "signest", "signester", "demest", "digested", "digEST", "signested", " digEST", " digested", "Digest", " digester"], "salt": ["isALT", "Ssecret", "sALT", "sodium", "dsort", "psodium", "secretipher", "SALT", "secretalt", "isalt", "secretsecret", "sesSalt", "sipher", " sALT", "sssecret", "Salt", "Sipher", "secretALT", " sodium", "sSalt", "psalt", " sort", "Sodium", "sort", "SSalt", "isodium", "sesodium", "ssalt", "dsalt", "dsALT", "psALT", "sesalt", "ssALT", "ssecret", "dsodium", "isSalt", "sesALT", "ssipher", "psort"], "i": ["z", "index", "j", "in", "o", "oi", "uli", "hi", "at", "ii", "ix", "mu", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "t", "d", "ind", "li", "k", "ci", "p", "si", "xi", "I", "it", "v", "x", "ai", "uri", "bi", "y", "ip", "init", "ti", "qi", "id", "e", "u", "n", "di", "m", "f", "s"], "paramSpec": ["aramSpec", "parspec", "paramSel", " paramConfig", "paramsspec", "paramCS", "ParamCS", "ParamSpec", "parConfig", "parCS", "aramSel", "Paramspec", "ParamConfig", "aramSpe", " parameterSel", " paramSpe", "paramConfig", "aramConfig", "paramsConfig", "paramsSpec", "paramSpe", "parSpec", " parameterSpec", " paramSel", "paramspec", " parameterConfig", " parameterSpe", "paramsCS"], "cipher": ["Cipher", "Crypt", "encursor", "couster", "conuster", "pipher", "coursor", "encairo", "encoder", "cairo", "Cairo", "Coder", "coder", "crypt", "encistor", " cairo", "conrypt", "custer", "cistor", "conursor", " cursor", "coipher", "encipher", "encrypt", "conipher", "prypt", "Cistor", "Cursor", "cursor", " coder", "pairo", "encuster", "corypt", "pistor"]}}
{"id1": "5607440", "id2": "15745420", "code1": "    public void updateShoppingBean(String userId) {\n        Connection connection = null;\n        PreparedStatement preparedStatement1 = null;\n        PreparedStatement preparedStatement2 = null;\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            connection = DriverManager.getConnection(this.jdbcURL);\n            connection.setAutoCommit(false);\n            String preparedQuery = \"INSERT INTO dbComputerShopping.order(name,product_id,quantity,date,status)VALUES(?,?,?,?,?)\";\n            preparedStatement1 = connection.prepareStatement(preparedQuery);\n            Date date = new Date();\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            String orderDate = format.format(date);\n            Iterator iterator = this.cart.iterator();\n            Object[] shoppingInfo = null;\n            while (iterator.hasNext()) {\n                shoppingInfo = (Object[]) iterator.next();\n                ProductBean product = (ProductBean) shoppingInfo[0];\n                int quantity = (Integer) shoppingInfo[1];\n                preparedStatement1.setString(1, userId);\n                preparedStatement1.setInt(2, product.getId());\n                preparedStatement1.setInt(3, quantity);\n                preparedStatement1.setString(4, orderDate);\n                preparedStatement1.setString(5, \"confirmed\");\n                preparedStatement1.executeUpdate();\n            }\n            Object[] cartInfo = null;\n            preparedQuery = \"UPDATE components SET quantity=quantity-? WHERE comp_id=?\";\n            preparedStatement2 = connection.prepareStatement(preparedQuery);\n            for (Iterator i = this.cart.iterator(); i.hasNext(); ) {\n                cartInfo = (Object[]) i.next();\n                ProductBean product = (ProductBean) cartInfo[0];\n                int quantity = (Integer) cartInfo[1];\n                ProductListBean productList = new ProductListBean(jdbcURL);\n                ArrayList components = productList.getComponents(product.getId());\n                for (Iterator j = components.iterator(); j.hasNext(); ) {\n                    ComponentBean component = (ComponentBean) j.next();\n                    preparedStatement2.setInt(1, quantity);\n                    preparedStatement2.setInt(2, component.getId());\n                    preparedStatement2.executeUpdate();\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n            }\n        } finally {\n            try {\n                connection.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement1.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement2.close();\n            } catch (SQLException ex) {\n            }\n        }\n    }\n", "code2": "    private void download(String address, String localFileName) throws UrlNotFoundException, Exception {\n        String ext = G_File.getExtensao(address);\n        if (ext.equals(\"jsp\")) {\n            throw new Exception(\"Erro ao baixar pagina JSP, tipo negado.\" + address);\n        }\n        File temp = new File(localFileName + \".tmp\");\n        if (temp.exists()) temp.delete();\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            try {\n                URL url = new URL(address);\n                conn = url.openConnection();\n                in = conn.getInputStream();\n            } catch (FileNotFoundException e2) {\n                throw new UrlNotFoundException();\n            }\n            out = new BufferedOutputStream(new FileOutputStream(temp));\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n        } catch (UrlNotFoundException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException ioe) {\n            }\n        }\n        File oldArq = new File(localFileName);\n        if (oldArq.exists()) {\n            oldArq.delete();\n        }\n        oldArq = null;\n        File nomeFinal = new File(localFileName);\n        temp.renameTo(nomeFinal);\n    }\n", "label": 0, "substitutes": {"updateShoppingBean": ["updateShoppingBaning", "updateShippingBAN", "updateShoppingBeans", "updateShoppingBans", "updateShoppingBEans", "updateShippingBans", "updateShoppingBoAN", "updateShippingBeAN", "updateShoppingBeaning", "updateShoppingBEan", "updateShippingBeaning", "updateShippingBean", "updateShoppingBoan", "updateShippingBaning", "updateShippingBeans", "updateShoppingBeAN", "updateShoppingBEAN", "updateShoppingBoans", "updateShoppingBEaning", "updateShoppingBan", "updateShoppingBoaning", "updateShoppingBAN", "updateShippingBan"], "userId": ["userData", "clientName", " userID", "UserPath", "userName", " userName", " userData", " userType", "clientType", "clientPath", "UserName", "clientId", "UserData", "userID", "clientData", "UserID", "userPath", "userType", "clientID", " userPath", "UserId", "UserType"], "connection": ["log", "index", "pool", "service", "resource", "graph", "section", "ion", "function", "channel", "Connection", "cache", "table", "writer", "conn", "management", "driver", "class", "application", "engine", "c", "sql", "condition", "session", "collection", "state", "relation", "subject", "BC", "query", "handler", "result", "container", "client", "context", "manager", "name", "statement", "communication", "con", "server", "data", "document", " Connection", "connect", "lock", "general", "database", "bc", "connected", "config", "db", "machine", "directory"], "preparedStatement1": ["preppedStatl", "preparedStatementone", "preparedObject01", "preparedStatement9", "prearedStatement0", "preppedStatement3", "preparedObject1", "preakedStatement4", "preparedStatl", "preppedStatementl", "preparedStatone", "preakedQuery1", "preparedStatement4", "preparedEvent1", "preparedQueryB", "preparedState0", "prefixedStatement0", "preferredStatement2", "preparedTransaction0", "prearedStatement1", "preakedQuery2", "preparedMaterial17", "preparedObject1001", "preparedstatement01", "preparedContext31", "preparedDocument2", "prearedSession1", "preparedState31", "preparedState01", "preparedComment3", "preparedObjectone", "preparedContext4", "preparedQuery0", "preparedStruct1", "preparedStat1", "preparedTransaction31", "preppedStat1", "preparedstatementone", "preparedStatementB", "preparedQueryn", "preparedDocument4", "preparedStat31", "preakedQuery4", "preparedDatabase1", "preparedState1", "preparedStatement1001", "prefixedStruct31", "preferredStatement1", "preuredStat4", "preparedDocument1", "preparedQuery2", "preparedQuery1", "preparedstatement1001", "preparedTransaction1", "prefixedStatement9", "preparedEvent01", "preparedStatement3", "preculatedEvent1", "preparedStruct0", "preparedStruct9", "preparedState9", "preferredStatement17", "preparedDatabase17", "preparedDatabase2", "preasterStatementone", "prearedSession0", "prearedSessionB", "preparedSessionB", "preparedComment1001", "preferredQuery1", "preparedQueryl", "preparedStatement31", "preparedStatement0", "preparedSession0", "preakedStatementn", "preparedDocument31", "preparedMaterial2", "preparedstatement1", "prefixedStruct1", "prefixedStruct0", "prefixedStruct9", "preparedSession1", "preakedStatement1", "preakedQueryn", "preparedCommentone", "preppedStatement1", "preasterStatement1001", "preparedComment1", "preparedDocumentB", "preasterStatement1", "preuredStatement1", "preparedStatementl", "preculatedStatement1", "preculatedEvent01", "preakedStatement2", "preuredStatone", "preparedStat4", "preasterObject1", "prearedStatementB", "preasterObject1001", "preferredQuery2", "preuredStat1", "preparedStat3", "preparedStatement17", "preparedDocumentn", "preparedSession2", "preparedStruct31", "preuredStat31", "preferredQuery17", "preparedContext1", "preuredStatement4", "preppedStat3", "preparedComment01", "preasterObjectone", "preparedQuery3", "preparedTransaction9", "preuredStatementone", "prefixedStatement1", "preasterStatement01", "preparedDatabase4", "preparedStatementn", "preparedDocument0", "preparedMaterial1", "preasterObject01", "preparedQuery17", "preparedCommentl", "preparedStatement01", "prefixedStatement31", "preparedQuery4", "prearedStatement2", "preuredStatement31", "preparedDocumentone", "preparedDatabasen", "preparedContextone", "preculatedStatement01", "prearedSession2"], "preparedStatement2": ["prearedSession0", "preparedstatement2", "prearedSession1", "preparedScope8", "preuredStatement2", "preparedstatement8", "preparedSession2", "preparedResult2", "preparedstatement404", "prearedStatement0", "preparedStatement0", "preparedScope404", "preparedConditiontwo", "preparedSession0", "preparedSession52", "preparedstatementtwo", "preparedResult52", "preparedCondition2", "preparedConfiguration2", "preuredstatement8", "preparedConfiguration52", "preuredstatementtwo", "preparedConfiguration0", "preparedScopetwo", "preuredStatementtwo", "preparedConfiguration1", "preparedStatement52", "preparedCondition8", "preparedStatement8", "preuredStatement404", "preparedSession1", "preparedScope2", "preparedCondition404", "preuredStatement8", "preparedResult0", "prearedStatement52", "prearedStatement1", "preparedStatementtwo", "preparedResult1", "prearedSession52", "preparedStatement404", "preuredstatement2", "prearedStatement2", "preuredstatement404", "prearedSession2"], "preparedQuery": ["prearedCommand", "preparedquery", "PreparedStatement", "prevertedFunction", "prearedquery", "PrearedQuery", "PreppedStatement", "perparedBody", "precedStatement", "previsedStatement", "perppedQuery", "perparedquery", "PreparedInfo", "preppedQu", "PrearedQu", "peraredStatement", "prevertedQu", "preculatedQu", "PreparedFunction", "preparedInfo", "precedQuery", "precedCommand", "PreparedQuery", "preparedBody", "prearedInfo", "perppedquery", "PrearedInfo", "preparedCommand", "PreparedQu", "perparedQuery", "preculatedInfo", "prearedQuery", "prevertedBody", "preppedBody", "preplannedCommand", "prevertedInfo", "previsedQuery", "perparedCommand", "prevertedquery", "PreppedQuery", "previsedquery", "prevertedQuery", "peraredCommand", "preculatedFunction", "preplannedStatement", "preppedquery", "prevertedStatement", "peraredquery", "PrearedFunction", "preppedStatement", "perppedBody", "Preppedquery", "preppedQuery", "perparedStatement", "preparedFunction", "prearedStatement", "preparedStatement", "PreppedQu", "preplannedquery", "previsedBody", "peraredQuery", "perppedStatement", "preculatedQuery", "preplannedQuery", "prearedQu", "precedquery", "previsedQu", "Preparedquery", "prearedFunction", "preparedQu"], "date": ["log", "model", "index", "resource", "module", "change", "event", "form", "dat", "duration", "order", "grade", "open", "match", "version", "day", "age", "message", "use", "rate", "update", "style", "status", "string", "set", "Date", "stage", "d", "ate", "month", "type", "dt", "record", "year", "number", "bug", "start", "name", "data", "file", "document", "complete", "time", "tag", "db"], "format": ["letter", "unit", "html", "method", "printf", "prefix", "point", "prep", "form", "transform", "function", "pattern", "at", "filter", "parse", "atter", "parser", "process", "add", "table", "writer", "info", "replace", "Format", "struct", "style", "string", "scale", "class", "set", " formatted", "cut", "print", "export", "sort", "split", "handler", " Format", "join", "type", "wrap", "part", "and", "handle", "name", "report", "pretty", "term", " fmt", "data", "value", " formatting", "str", "dot", "time"], "orderDate": ["serverTime", "requestDat", "orderdate", " orderData", "OrderTime", "OrderDat", " orderDay", " orderDat", "requestDate", "OrderData", "orderTime", "orderDat", "OrderName", "serverdate", "orderName", "OrderDay", "requestDay", "serverDate", "requestName", "serverData", " orderTime", "orderData", "OrderDate", " orderName", "Orderdate", " orderdate", "orderDay"], "iterator": ["ident", "ski", "interstitial", "outer", "river", "walker", "storage", "stream", "inner", "done", "sequence", "step", "metadata", "atio", "gener", "entry", "inter", "ators", "parser", "slice", "random", "later", "writer", "finder", "consider", "driver", "set", "Iter", "selection", "engine", "collection", "creator", "vector", "path", "ater", "ie", "er", "adder", "pointer", "uri", "started", "oper", "it", "choice", "loop", "series", "context", "start", "loader", "runners", "init", "runner", "ter", "until", "wrapper", "former", "server", "header", "instance", "Iterator", "ator", "reader", "timer", "database", "iter", "enter", "you", "append", "starter", "holder", "processor"], "shoppingInfo": ["hoppingMeta", "hillingData", "shillingArea", "swopingArea", "shppingInf", "shopingInfo", "ShoppingInfo", "ShippingInfo", "shoppingArea", "shillingInf", "ShippingInf", "shppinginfo", "shoppingObj", "shoppingData", "hillinginfo", "hoppingId", "swopingInf", "shoutingInfo", "shoppingINFO", "hillingInfo", "shashingInfo", "shippingINFO", "shppingId", "swoppingObj", "shppingData", "swoppingInfo", "hillingInf", "shillingINFO", "ShoppingInf", "shppingMeta", "shillingInfo", "shashingId", "shppingInfo", "hoppingInf", "shopingInf", "hillingMeta", "shashinginfo", "shillinginfo", "shppingArea", "shopingData", "shopingArea", "shoutingInf", "shillingId", "ShippingINFO", "shopingObj", "shopingMeta", "shippingInf", "swopingObj", "swopingInfo", "shippingInfo", "shoppinginfo", "hillingId", "ShoppingINFO", "hoppingData", "shillingMeta", "shoppingMeta", "shppingObj", "shashingInf", "swoppingArea", "shoutingINFO", "swoppingInf", "shoppingId", "hoppinginfo", "shoppingInf", "hoppingInfo", "shillingObj", "shillingData"], "product": ["image", "model", "service", "resource", "module", "child", "production", "payment", "input", "order", "target", "property", "version", "filter", "process", "Product", "output", "object", "class", "pp", "pe", "position", "creator", "collection", "relation", "p", "type", "attribute", "company", "result", "client", "cart", "products", "user", "data", "seller", "band", "parent", "feature", "per", "contact", "config", "source", "project", "plugin", "copy", "processor"], "quantity": ["aquance", "compifier", "commentity", "authority", "authorality", "quantification", "primality", "compicity", "necessifier", "commentifier", "mentity", "quantifier", "primification", "aquality", "commentality", "necessation", "mentITY", "aquity", "necessity", "primation", "necessification", "aquicity", "primity", "compance", "mentifier", "compity", "quantality", "primifier", "quanticity", "compation", "authoricity", "authorance", "quantance", "commentITY", "quantation", "compification", "compality", "quantITY", "mentality", "primITY"], "cartInfo": ["cartInf", " cartSize", "frontInf", " cartData", "carInfo", "productObj", "carSize", "frontStyle", "carObj", " cartList", " cartStyle", " cartMeta", "frontObj", " cartInf", "cartMeta", "cartObj", "cartSize", "contactData", "productInfo", "carMeta", "contactInfo", "cartStyle", "productSize", "cartData", "productData", "frontMeta", "productInf", "cartList", " cartObj", "contactInf", "frontInfo", "carStyle", "contactList", "carInf"], "i": ["ini", "index", "oi", "chi", "hi", "phi", "cli", "ii", "list", "api", "info", "ui", "l", "ami", "ri", "pi", "c", "ic", "abi", "ati", "li", "ci", "p", "ie", "ani", "multi", "io", "si", "xi", "it", "uri", "v", "bi", "ai", "ip", "is", "init", "ori", "qi", "id", "e", "iu", "f", "vi", "n", "di", "I"], "productList": [" productSet", "resourceCollection", "pageGroup", "pageList", "configlist", "resourceSet", "cartlist", " productArray", "pageArray", "cartGroup", "productGroup", "resourceList", "productArray", "productCollection", "configCollection", "productlist", "cartArray", "configList", "configSet", "cartList", " productCollection", "resourcelist", "productSet", " productlist", " productGroup", "pagelist"], "components": ["comositories", "compategories", "supplements", "comparts", "compenses", "productonents", "commients", "pategories", "deponent", "comients", "depients", "commonent", "complements", "cproducts", " compenses", "carts", "comenses", "comonents", "conents", "ponents", "commonents", "supponents", "categories", "compositories", "productarts", " complements", "depositories", " compositories", "compients", "comlements", "suppenses", "comonent", "deponents", "productproducts", "compproducts", "pproducts", "suppositories", "commositories", "productategories", "parts"], "j": ["z", "_", "index", "jc", "o", "other", "Query", "this", "add", "area", "l", "b", "jp", "js", "update", "url", "Select", "sql", "Insert", "r", "Config", "k", "query", "ie", "p", "er", "v", "all", "ji", "where", "jj", "jo", " ii", "J", "id", "adj", "database", "ij", "n", "bj", "config", "f", "obj"]}}
{"id1": "1371265", "id2": "3375718", "code1": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "code2": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "label": 1, "substitutes": {"update": ["index", "resource", "create", "write", "json", "edit", "UPDATE", "add", "run", "replace", "table", "info", "post", "set", "updated", "apply", "Update", "query", "insert", "report", "request", "data", "append", "delete", "select", "save"], "channelPath": ["fileObject", "resourceObject", "filepath", "downloadPath", "resourcePath", " channelMap", "fileMap", " channelObject", " channelpath", "downloadpath", "downloadMap", "resourcepath", "filePath", "resourceMap", "downloadObject"], "dataField": ["datafield", "alphaArea", "dataTerm", "responseTerm", " datafield", "responseField", " dataTerm", "DataTable", "dataArea", "responseFIELD", "alphaTable", "dataFIELD", " dataArea", "dataTable", "resourcefield", " dataFIELD", " dataTable", "DataArea", "DataTerm", "resourceFIELD", "responsefield", "alphaTerm", "DataField", "resourceField", "alphaField", "resourceTerm"], "fatherDocId": ["fatherDocumentInfo", "fatherDocumentPath", "fatherFileInfo", "fatherdocPath", "motherDocumentPath", "motherDocInfo", "motherDocumentID", "fatherFileid", "fatherDocumentID", "fatherFileId", "fatherFileName", "fatherPoName", "motherDocumentId", "fatherDocName", "motherDocPath", "fatherPoID", "fatherDocumentId", "motherDocumentName", "fatherdocName", "fatherdocInfo", "fatherDocPath", "motherDocumentid", "fatherPoId", "motherDocid", "fatherFilePath", "fatherDocInfo", "fatherDocid", "motherDocumentInfo", "fatherWriterName", "fatherWriterID", "fatherPoid", "fatherDocID", "fatherWriterInfo", "motherDocName", "fatherdocId", "fatherFileID", "fatherDocumentName", "fatherDocumentid", "fatherWriterId", "motherDocID", "motherDocId", "fatherWriterid"], "sqlInitial": ["sqlInit", " sqlinitial", "SQLinitial", "queryinitial", "SQLInit", "SQLFinal", "sqlFinal", "queryInitial", "SQLInitialized", " sqlInit", " sqlInitialized", "SQLInitial", "queryFinal", "qlinitial", "qlInitialized", "sqlinitial", "sqlInitialized", "qlInit", "qlInitial", "queryInit", "qlFinal"], "sqlsortURL": ["sqlssortURI", "sqLSortURL", "sqlsaltURL", "sqllaltUrl", "sqlsorturl", "sqllortSSL", "sqlsourceurl", "sqlssortURL", "sqlsourceSSL", "sqllortURL", "sqlsendURI", "sqLSorturl", "sqLSORTUrl", "sqlsORTUrl", "sqllortURI", "sqlsORTURI", "sqlsortSSL", "sqllaltSSL", "sqlsORTurl", "sqLSORTURL", "sqlsendURL", "sqlsORTURL", "sqlsendSSL", "sqlssortUrl", "sqlsourceURL", "sqlsortUrl", "sqlssorturl", "sqlsaltUrl", "sqllortUrl", "sqLSortURI", "sqlsourceURI", "sqllaltURL", "sqlsortURI", "sqlsendUrl", "sqllaltURI", "sqLSortUrl", "sqlsaltURI", "sqLSORTURI", "sqlsourceUrl", "sqLSORTurl", "sqlsaltSSL"], "conn": ["enc", "apt", "nt", "pt", "coll", "dc", "syn", " con", "ht", "oci", "nc", "pc", "net", "rt", "Connection", "ca", "Connect", "sync", "ch", "cat", "ann", "pr", "sql", "c", "act", "cr", "session", "ct", "rc", "orp", "core", "ci", "ds", "p", "en", "conf", "cs", "oss", "client", "cc", "pub", "ens", "reg", "co", "col", "con", "cn", "dn", "connect", "lock", "mc", "Conn", "res", "ctx", "cp", "connection", "n", "db", "pg"], "rs": ["ars", "sels", "its", "asts", "rys", "rx", "ans", "vs", "DS", "rep", "lines", "runs", "arch", "rt", "ns", "maps", "ges", "vers", "ocr", "repl", "src", "pers", "ms", "pr", "Rs", "rd", "rg", "r", "xs", "rows", "rc", "obs", "ats", "ows", "sc", "ds", "ues", "ris", "ros", "acks", "rr", "ras", "cs", "mr", "rors", "ra", "qs", "ins", "hs", "hr", "ys", "sr", "icks", "bs", "RS", "PS", "rb", "results", "res", "ks", "ts", "rl", "cr", "rss", "s"], "ps": ["ports", "ars", "pt", "posts", "syn", "vs", "ans", "amps", "po", "pre", "DS", "Ps", "pc", "ns", "aps", "ons", "pers", "ms", "pex", "jp", "pr", "Rs", "ws", "LS", "pos", "sp", "pp", "pe", "pps", "pres", "pa", "pass", "pl", "ples", "p", "ds", "ros", "ras", "eps", "cs", "os", "pm", "fs", "ins", "ups", "pse", "ys", "ens", "gs", "co", "ips", "con", "bs", "RS", "ss", "PS", "res", "ks", "ts", "pg", "s"], "dbo": ["mdbo", " dBo", "dbi", " dbi", "Dbo", "Dbi", "mdba", "bbo", " dbc", "bBo", "ldbo", "mdBo", "Dpo", "bpo", " dba", "mdbc", "dpo", "dBo", "dbc", "ldba", "bbi", "ldBo", "dba", "ldbc", " dpo", "DBo"], "url": ["rule", "image", "force", "html", "URL", "resource", "fr", "www", "feed", "email", "q", "nl", "view", "download", "Url", "http", "text", "src", "filename", "href", "l", "page", "string", "r", "hl", "route", "path", "fl", "source", "rel", "uri", "response", "layer", "blog", "ur", "name", "ssl", "request", "language", "host", "id", "file", "data", "ll", "server", "username", "str", "sl", "rl", "date", "loc", "location", "f", "address"], "st": ["nd", "th", "fr", "pt", "est", "stop", "bl", "cl", "rt", "src", "stack", "ust", "ut", "l", "ld", "pr", "ST", "string", "rd", "sp", "pe", "r", "t", "sn", "sts", "sc", "p", "stri", "sb", "ste", "x", "sh", "rest", "std", "start", "ost", "la", "St", "ft", "sta", "stress", "const", "inst", "Str", "str", "sl", "ss", "sth", "ist", "sw", "cr", "ast", "s"], "sortDocId": ["sortDOCID", "sortdocInfo", "sortFileId", "sortDepid", "updateDocInfo", "sortDocumentId", " sortDocumentId", "sortWriterID", "sortdocId", "sortDocInfo", "updateDocumentId", " sortDocInfo", "sortDocumentid", "sortDocumentPath", "sortWriterid", "sortDocumentName", " sortFileID", " sortFileInfo", "sortFileID", "sortdocID", "updateDocId", " sortDocID", "sortDocumentID", "sortDOCId", "sortDOCName", " sortDocid", "sortDocID", "sortPageId", "updateDocumentid", "updateDocID", "sortPageid", "sortDocName", "sortDepID", "updateDocumentInfo", "sortFileid", "sortDocumentInfo", "sortFilePath", "sortDepName", "updateDocumentID", " sortDocumentID", "sortDepInfo", " sortFilePath", "updateDocid", "sortDOCid", " sortDocName", "sortWriterId", "sortdocid", "sortDocPath", "sortPageName", "sortdocPath", "sortWriterName", "sortPageID", "sortFileInfo", "sortDocid", " sortDocPath", " sortDocumentid", "sortDepId", " sortFileId", "sortdocName", " sortDocumentName"], "flag": ["force", "field", "child", "func", "offset", "fun", "debug", "FLAG", "format", "ag", "match", "inline", "count", "standard", "sync", "bit", "use", "key", "cat", "agg", "leaf", "string", "status", "store", "ind", "fl", "arg", "part", "ret", "prop", "blog", "bug", "start", "only", "flags", "ext", "Flag", "lag", "id", "data", "file", " Flag", "star", "binary", "char", "str", "kind", "bool", "wait", "tag"], "sqlsort": [" sqlesorted", " sqlesorter", "sqllORT", "sqlesort", "sqlesORT", "sqLSort", "sqlsORT", " sqLSorts", " sqLSsort", " sqlsorts", "sqLSorted", "sqLSorts", "sqlsorts", "sqLSorter", "sqlesorter", "sqLSsort", " sqlsorted", "sqllorter", "sqlsorter", "sqsORT", "sqsort", " sqlesort", " sqlsORT", "sqlesorts", "sqllort", "sqllorted", " sqLSORT", " sqlssort", "sqlsorted", " sqlsorter", "sqsorts", " sqLSort", " sqlesORT", "sqlessort", "sqssort", "sqlesorted", "sqlssort", "sqLSORT"], "sortURL": ["ortSSL", "updateSSL", "altUrl", " sortSSL", " sortID", "Sorturl", "searchURI", "sortURI", " sortUrl", "SortUrl", "editURL", " sortUR", " sortURI", "altURL", "searchID", "updateUR", "searchUrl", "searchUR", "sortUR", "ortURL", "sortSSL", "editurl", "updateURI", "SortURL", "ortURI", "altSSL", "sorturl", "editUrl", "ortUR", "sortUrl", "ortUrl", "updateURL", "sortID", "SortUR", "editUR", "ortID", "altUR", "searchURL", " sorturl"], "sortflag": ["sortFlag", "ortfeed", "addresslike", "addressfeed", "considerlike", "filterflag", "considerflag", "sorttype", " sortFlag", "ortFlag", "filterFLAG", "sortfeed", " sortFLAG", "sortlike", "sortFLAG", "addressflags", " sorttype", "ortFLAG", "considerflags", "ortflag", "Sortflag", "considerfeed", "sortflags", "filtertype", "SortFlag", "ortflags", "ortlike", "addressflag", "SortFLAG", "orttype"]}}
{"id1": "18374598", "id2": "17116123", "code1": "    private synchronized File download() throws AMSpacksException {\n        String a = addr.url.toExternalForm();\n        int p = a.lastIndexOf('/');\n        if (p < 0) {\n            p = a.lastIndexOf('\\\\');\n        }\n        if (p < 0) {\n            a = \"\" + Math.random();\n        } else {\n            a = a.substring(p + 1);\n        }\n        File td = null;\n        try {\n            td = File.createTempFile(a, \"\").getParentFile();\n        } catch (IOException ex) {\n            td = new File(\".\");\n        }\n        File f = new File(td, a);\n        td.delete();\n        long total = addr.update.getSize();\n        int progress = 0;\n        try {\n            InputStream in = new BufferedInputStream(addr.url.openStream());\n            FileOutputStream out = new FileOutputStream(f);\n            byte[] buf = new byte[500];\n            int n;\n            long percentage = 0;\n            callback.updateProgress(percentage);\n            do {\n                n = in.read(buf);\n                if (n > 0) {\n                    out.write(buf, 0, n);\n                    progress += n;\n                    long tmpPercentage = progress * 100 / total;\n                    if (percentage != tmpPercentage) {\n                        percentage = tmpPercentage;\n                        callback.updateProgress(percentage);\n                    }\n                }\n            } while (n > 0);\n            in.close();\n            out.flush();\n            out.close();\n        } catch (Exception ex) {\n            f.delete();\n            throw new DownloadFailedException(\"Error downloading update.\", ex);\n        }\n        long size = f.length();\n        String checksum = CheckSumFinder.checkSum(f);\n        if (size == addr.update.getSize() && checksum.equalsIgnoreCase(addr.update.getChecksum())) return f; else {\n            f.delete();\n            throw new CheckSumMismathchException(\"Checksum mismatch: \" + addr.update.getChecksum() + \" expected but was \" + checksum);\n        }\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"download": ["setup", "write", "open", "load", "Download", "filename", "output", "update", "string", " Download", "external", "upload", "diff", "pull", "loader", "name", "dump", "archive", "data", "file", "transfer", "release", "get", "exec", "install", "url", "copy"], "a": ["aw", "action", "base", "za", "ga", "tta", "fa", "ba", "am", "audio", "aux", "ma", "input", "art", "sa", "at", "alpha", "ua", "ca", "ada", "area", "l", "b", "A", "ata", "api", "auto", "asa", "url", "string", "da", "array", "c", "about", "aa", "r", "amp", "wa", "pa", "access", "t", "au", "ea", "ad", "an", "cha", "addr", "ppa", "va", "na", "as", "name", "la", "ae", "ac", "sta", "ha", "data", "oa", "file", "af", "e", "qa", "u", "i", "m", "ab", "aaa", "ast", "s"], "p": ["np", "pat", "j", "o", "dp", "q", "po", "w", "ap", "py", "pre", "P", "ping", "api", "b", "l", "jp", "pr", "bp", "after", "pi", "pp", "sp", "c", "pe", "pos", "pa", "t", "d", "op", "part", "v", "x", "fp", "y", "ip", "start", "h", "tp", "e", "u", "i", "cp", "m"], "td": ["dd", "nd", "th", "fr", "tt", "det", "pt", "fa", "ud", "dc", "lf", "dat", "fm", "ht", "tn", "pc", "hd", "ff", "aff", "rt", "fc", "table", "b", "ld", "cd", "tl", "rd", "txt", "cf", "gb", "buff", "tif", "t", "fd", "tr", "d", "fb", "bd", "dt", "sb", "elt", "fp", "od", "sd", "bt", "tmp", "pb", "tf", "tc", "file", "dh", "af", "pd", "sf", "TD", "dl", "db", "ppa"], "f": ["fo", "j", "base", "o", "fr", "feed", "of", "fast", "fa", "form", "lf", "w", "fm", "F", "function", "ff", "fen", "fe", "fi", "aff", "fw", "fc", "xf", "l", "b", "uf", "info", "full", "c", "rf", "r", "cf", "g", "buffer", "t", "fd", "d", "fb", "handler", "fl", "v", "df", "flat", "fp", "fs", "fx", "tf", "h", "fold", "fam", "file", "fn", "e", "sf", "u", "i", "bf", "m"], "total": ["num", "reported", "base", "temp", "nt", "done", "current", "cost", "json", "available", "active", "quant", "serial", "count", "local", "full", "post", "info", "now", "scale", "set", "percent", "recent", "ok", "next", "doc", "otal", "Total", "upload", "used", "finished", "all", "length", "start", "sum", "server", "valid", "last", "error", "complete", "normal", "partial", "parent", "max"], "progress": ["err", "np", "Progress", "num", "resource", "vance", "done", "current", "coll", "step", "content", "cost", "grade", "skip", "active", "count", "process", "rec", "conn", "status", "scale", "summary", "c", "running", "dist", "resp", "path", "success", "next", "recent", "width", "number", "length", "xp", "bar", "roll", "error", "complete", "wait", "partial", "rss"], "in": ["ini", "kin", "login", "o", "stream", "gin", "inner", "inn", "input", "In", "l", "b", "bin", "url", "c", "pin", "r", "IN", "again", "ie", "source", "nin", "io", "v", "cin", "ins", "as", "lin", "init", "ac", "con", "data", "isin", "i", "win", "reader", "vin", "din", "socket", "inc"], "out": ["err", "flow", "log", "o", "inner", "to", "w", "up", "cache", "output", "b", "bin", "conn", "extra", "full", "cb", "ch", "url", "update", "c", "code", "buffer", "again", "outs", "line", "conf", "io", "v", "Out", "client", "ins", "off", "ext", "co", "data", "file", "fn", "parent", "call", "callback", "error", "ex", "inc", "exec", "obj", "s"], "buf": ["wb", "cmd", "box", "raw", "ba", "uno", "ff", "feat", "queue", "bag", "area", "uf", "b", "bytes", "bin", "cb", "pad", "cap", "bh", "bp", "cf", "buff", "border", "buffer", "rc", "padding", "fb", "bf", "Buff", "v", "fp", "tmp", "auc", "loc", "data", "cv", "callback", "pkg", "rb", "bc", "seq", "grab", "br", "uc", "header"], "n": ["z", "np", "num", "j", "nb", "o", "nor", "br", "N", "current", "coll", "w", "none", "nc", "skip", "net", "ns", "ne", "count", "l", "b", "un", "pos", "c", "r", "g", "sn", "d", "node", "not", "en", "len", "nr", "x", "min", "nn", "number", "network", "v", "length", "cn", "nit", "fn", "dn", "rn", "e", "u", "no", "i", "error", "ng", "non", "m"], "percentage": ["percentability", " percentile", "percentrage", "missay", "percentile", "metile", "variide", "parager", "metay", "poundability", "percentide", "Percentile", "percentager", "poundage", "variay", "Percentager", " percentency", "percentency", "percentity", "Percentages", "varirage", "variile", "metage", "latide", "metency", "latage", "variage", "metages", "missage", "parage", "Percentency", "metrage", "compity", "Percentage", "latay", " percentages", "voltages", "parages", "percenture", "parile", "poundages", "voltager", "pardages", "percentages", "variity", "latity", "compay", "compage", "pardure", "pardage", "pardability", "Percentability", "voltage", "poundure", "percentay", "missile", "compide", "Percenture", "voltile", "missrage"], "tmpPercentage": ["cpppercentment", "tmppercentment", "temppercentle", "tmpCompages", "tmppercentages", "tmppercentag", "ptypercentag", "tmpPassency", "temppercentency", "tmpPercentle", "tmpPassment", "tmpMagnrage", "ptypercentency", "tmpPassag", "tmppercentency", "tmpPassage", "tmppercentrage", "tmpPassile", "ptypercentage", "ptyPercentile", "tmpPercentag", "tmpPercentment", "ptyPercentag", "cpppercentrage", "cppPercentage", "ptyPercentency", "tmppercentle", "cpppercentay", "tmppercentay", "tmpComple", "tmpPercentrage", "temppercentages", "tmpMagnage", "cppPercentrage", "cppPercentment", "tmpPercentay", "tmpHalfile", "tmpPassay", "tmpMagnment", "tempPercentage", "tmpMagnay", "tmpPercentages", "tempPercentages", "tmpHalfency", "tmpHalfage", "temppercentage", "tmpHalfag", "tempPercentency", "tempPercentle", "tmpCompency", "tmpPercentency", "tmpPercentile", "cpppercentage", "tmpCompage", "cppPercentay", "tmppercentile", "tmppercentage", "ptyPercentage", "tmpPassrage", "ptypercentile"], "size": ["fee", "ize", "esc", "unit", "send", "offset", "capacity", "content", "grade", "sec", "ne", "count", "speed", "scale", "code", "c", "external", "core", "sn", "rc", "sized", "len", "width", "small", "length", "SIZE", "name", "clean", "sum", "data", "e", "Size", "error", "empty", "i", "time", "loc", "max", "address"], "checksum": [" Checksme", "cksam", "ckssum", " checksal", "getsum", "getsam", "getsumm", "timesums", "checkum", " checksig", "cksums", "cksumm", "timesig", "getssum", " checksumm", "checksam", "checksig", " checksme", "checkssum", "checksal", " Checksal", "cksum", "checksme", "checkme", " Checkssum", " Checksum", " checksums", "checksumm", "timesum", " checksam", "checkal", " checkssum", "checksums", "cksig", "timessum"]}}
{"id1": "22977189", "id2": "18613870", "code1": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"in": ["re", "err", "ini", "image", "login", "this", "gin", "inner", "inn", "input", "In", "up", "bin", "b", "url", "read", "c", "r", "IN", "g", "again", "pass", "er", "plus", "source", "nin", "cin", "min", "ins", "is", "as", "lin", "init", "inside", "con", "ln", "isin", "data", "id", "i", "win", "reader", "n", "din", "f", "socket", "inc"], "out": ["flow", "temp", "window", "list", "page", "again", "query", "strip", "block", "name", "file", "call", "comment", "connection", "parent", "f", "editor", "s", "log", "pool", "o", "outer", "this", "point", "flush", "write", "cache", "sync", "output", "OUT", "password", "bin", "b", "conn", "r", "outs", "io", "Out", "app", "init", "server", "user", "error", "copy", "err", "prefix", "self", "inner", "at", "object", "client", "off", "ext", "data", "ex", "default", "inc", "exec", "obj", "raw", "w", "plain", "up", "key", "writer", "part", "as", "a", "word", "n"], "line": ["rule", "letter", "log", "link", "lc", "unit", "feed", "end", "content", "lf", "write", "cl", "lines", "inline", "entry", "LINE", "text", "message", "Line", "key", "column", "l", "page", "style", "string", "code", "c", "pe", "pass", "next", "row", "character", "block", "name", "word", "data", "file", "id", "cell", "char", "header", "lock", "str", "comment", "i", "sl", "value", "source", "f", "url", "lin"]}}
{"id1": "9210168", "id2": "10547671", "code1": "            @Override\n            public void run() {\n                try {\n                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n                    InputStream fis = url.openStream();\n                    InputStreamReader r = new InputStreamReader(fis, \"UTF-8\");\n                    BufferedReader br = new BufferedReader(r);\n                    String line;\n                    StringBuilder sb = new StringBuilder();\n                    while (null != (line = br.readLine())) {\n                        sb.append(line);\n                        sb.append(\"\\r\\n\");\n                    }\n                    br.close();\n                    r.close();\n                    fis.close();\n                    final String text = sb.toString();\n                    SwingUtilities.invokeLater(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            MainPanel.this.source.setText(text);\n                            MainPanel.this.source.setCaretPosition(0);\n                        }\n                    });\n                } catch (Exception ex) {\n                }\n            }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 1, "substitutes": {"run": ["image", "register", "unit", "base", "in", "create", "inner", "stop", "render", "launch", "runs", "process", "add", "output", "replace", "un", "update", "show", "home", "code", "background", "display", "apply", "running", "work", "job", "out", "loop", "start", "name", "test", "runner", "call", "Run", "execute", "exec", "invoke"], "url": ["re", "err", "image", "URL", "base", "resource", "fr", "lr", "service", "Url", "http", "remote", "l", "b", "api", "string", "path", "uri", "plug", "nr", "ur", "loader", "ssl", "loc", "server", "user", "file", "id", "browser", "str", "sl", "rl", "source", "f", "address"], "fis": ["Fais", "flisa", "flis", " fIS", "pis", " fIs", "bais", "bIS", "pIs", "piss", "fais", "FIs", "fIs", "bIs", " fisa", " fiss", "Fis", " fais", "fIS", "fisa", "bis", "pisa", "Fiss", "fliss", "fiss", "biss", "FIS", "flIs"], "r": ["err", "resource", "fr", "rx", "vr", "kr", "rt", "ir", "ler", "rar", "l", "b", "pr", "ri", "c", "rf", "rc", "wr", "tr", "d", "er", "p", "rr", "BR", "nr", "rh", "rus", "mr", "is", "rs", "ur", "hr", "sr", "R", "e", "Reader", "reader", "rb", "i", "res", "rl", "ru", "ar", "cr", "f", "s"], "br": ["err", "dr", "lr", "fr", "rx", "vr", "HR", "bl", "arr", "rt", "yr", "bridge", "b", "bb", "ch", "buf", "gr", "tr", "wr", "fb", "bro", "bf", "be", "result", "Br", "BR", "mr", "B", "hr", "sr", "ob", "brush", "browser", "str", "reader", "rb", "res", "bc", "bh", "cr"], "line": ["link", "letter", "lc", "base", "end", "nl", "liner", "lf", "bl", "cl", "lines", "entry", "inline", "LINE", "Line", "key", "column", "l", "b", "shell", "style", "string", "code", "buffer", "pass", "li", "split", "part", "number", "row", "le", "character", "name", "word", "sel", "ge", "data", "file", "id", "cell", "char", "header", "str", "sl", "i", "rl", "comment", "el", "cr", "f", "lin"], "sb": ["ib", "wb", "nb", "bsp", "lr", "bm", "eb", "storage", "zb", "bl", "SB", "ls", "sa", "xb", "src", "amb", "b", "bb", "cb", "bp", "usb", "buf", "gb", "buff", "abb", "buffer", "sn", "fb", "lb", "rob", "bf", "bd", "si", "obb", "sg", "sv", "erb", "bt", "pb", "bis", "bs", "binary", "sf", "sth", "rb", "mb", "bc", "bh", "bj", "BB", "db", "ab"], "text": ["letter", "config", "content", "format", "input", "entry", "obj", "message", "output", "b", "info", "object", "string", "txt", "code", "TEXT", "font", "buffer", "Text", "path", "translation", "result", "name", "title", "test", "ext", "data", "id", "str", "value", "comment", "connection", "source"]}}
{"id1": "11341711", "id2": "15645004", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"makeBackup": ["makePickup", "createbackups", "createbackUp", "createbackup", "makebackdown", "makePickups", "makeCleanup", "makeBackups", "makeCleanUp", "createBackdown", "makeBackUp", "makebackups", "makePickdown", "createBackups", "makebackUp", "makeCleanups", "makeCleandown", "createBackup", "makebackup", "createbackdown", "makePickUp", "makeBackdown", "createBackUp"], "dir": ["folder", "log", "base", "module", "DIR", "done", "root", "direction", "download", "up", "group", "zip", "cache", "ir", "run", "wd", "Directory", "dist", "store", "rc", "path", "d", "work", "dict", "doc", "io", "build", "dest", "diff", "director", "Dir", "manager", "init", "name", "md", "dep", "data", "file", "desc", "pkg", "lib", "config", "source", "db", "url", "directory"], "sourcedir": ["seedIR", "sortedir", "sourcedirs", "sodedore", "sourcesiri", "sodedirs", "ssodedIR", "asourcedIR", "asourcedore", "seedir", "sourcesirs", "sourceddir", "sortedIR", "sourcesIR", "seeddir", "sourcesdir", "sourcesir", "ssourceddir", "ssourcedIR", "sodediri", "ssourcediri", "sodedir", "sortedirs", "sourcesore", "sodedIR", "ssourcedir", "asortedirs", "asourcedir", "sourcedIR", "asortedIR", "asourcedirs", "ssodediri", "sourcedore", "seediri", "sodeddir", "sourcediri", "asortedir", "asortedore", "sortedore", "ssodedir", "ssodeddir"], "destinationdir": ["destinatorDIR", "dominationDir", "Destificationdirection", "destinationDIR", "Destificationfolder", "destificationfolder", "desturationfolder", "destificationdir", "Destinationfolder", "destificationDir", "dominationdir", "desturationdir", "dominatorDir", "destinateDIR", "destinatefolder", "destinatorfile", "dominationDIR", "destinatefile", "destificationdirection", "destinatedirection", "destinationfolder", "DestificationDir", "Destificationdir", "destinationsDir", "destinationsDIR", "destinationdirection", "destinatordir", "dominatorDIR", "destinatedir", "destinationsdir", "dominatordir", "destinatorDir", "desturationDir", "desturationdirection", "destinationDir", "Destinationdir", "destinationfile", "Destinationdirection", "dominatorfile", "destinationsfile", "DestinationDir", "destinateDir", "dominationfile"], "destinationDirEnding": ["destinationDirPassING", "destinationDirectorySignING", "destinationPathEndING", "destinationDirectoryEndining", "destinationDirectoryEndING", "destinationDirBegining", "destinationPathBeginging", "destinationDirEndING", "destinationDirectorySigning", "destinationDirSignening", "destinationDirEndining", "destinationDirPassging", "destinationDirectorySignening", "destinationDirPassing", "destinationDirSignING", "destinationPathBeginING", "destinationDirSignining", "destinationPathBeginning", "destinationDirLeadING", "destinationDirENDing", "destinationDirENDging", "destinationDirLeadining", "destinationDirEndening", "destinationDirSigning", "destinationDirectoryEnding", "destinationPathEndging", "destinationDirEndning", "destinationPathBegining", "destinationPathEnding", "destinationDirBeginning", "destinationDirectorySignining", "destinationDirBeginING", "destinationDirLeading", "destinationPathEndning", "destinationDirEndging", "destinationDirBeginging", "destinationDirectoryEndening", "destinationDirENDING", "destinationDirBeginining", "destinationDirENDning", "destinationDirPassning", "destinationDirBeginening", "destinationDirLeadening"], "files": ["resources", "log", "boxes", "books", "its", "index", "objects", "keys", "locks", "errors", "types", "bugs", "flows", "ls", "runs", "lines", "children", "services", "planes", "sections", "thumbnails", "rules", "ids", "links", "output", "l", "blocks", "events", "iles", "uploads", "tests", "projects", "groups", "rows", "ps", "images", " Files", "split", "Files", "parents", "fields", "actions", "items", "fs", "reports", "users", "xml", "ins", "models", "features", "ips", "docs", "pages", "data", "file", "modules", "classes", "names", "balls", "results", "words", "strings"], "checkdir": ["checkDIR", "checkFolder", "blockdraft", "checklog", "checkfile", "workDIR", "ckdirectory", "workfolder", "workdirectory", " checkDIR", "searchdir", "lockDir", "locklog", "blockdirectory", "ckDir", "checkdraft", "workfile", " checkd", "searchdirectory", "calldirectory", "CheckDIR", " checkDir", "calld", "workdraft", "lockFolder", " checklog", "blockdir", "searchDir", "checkdirectory", "workdir", "checkfolder", "calldir", "Checkfile", "worklog", "callfolder", "blockDir", "workDir", " checkFolder", "ckdir", " checkfile", "checkDir", " checkdirectory", "ckfolder", "CheckDir", "checkd", " checkfolder", "searchdraft", "ckd", "lockdir", "workFolder", "ckfile", "Checkdir"], "date": ["image", "log", "de", "late", "change", "event", "dat", "open", "at", "age", "day", "mu", "rate", "now", "update", "set", "Date", "state", "d", "m", "ate", "doc", "month", "dt", "mate", "sign", "start", "name", "zone", "ime", "ge", "data", "file", "user", "e", "contact", " Date", "time", "config", "tag", "md"], "msec": ["Msecond", "dseconds", "mnsec", "cseconds", " msc", "misec", "lseconds", "mnSec", "csecond", "lss", "dsecond", "rsec", "Msec", "lsecond", "disec", " minsec", "dsec", "msc", "mss", " minif", "mnif", " minSec", "Mseconds", " mif", " mSec", "fmsec", "css", "lsec", "mnsc", "fmisec", "mif", " minsc", "fmseconds", "mSec", "mseconds", "Misec", "fmsecond", "msecond", "rsecond", "csec", "rseconds", "rss"], "checkFile": ["CheckDirectory", " checkDirectory", "checkfile", "CheckFile", "workFiles", "checkLine", "checkDirectory", "workfile", "checkFilename", "changeFilename", "ckFiles", " checkDir", "CheckFiles", "checkFiles", "workFile", "ckFile", "ckDirectory", "Checkfile", "controlfile", "changeLine", "controlFile", "workDir", " checkfile", "checkDir", " checkFiles", "changefile", "changeFile", "controlLine", "controlFilename", "CheckDir", " checkFilename", " checkLine", "ckfile"], "i": ["ini", "index", "j", "field", "oi", "hi", "phi", "ii", "fi", "ix", "slice", "key", "mu", "b", "info", "ui", "ri", "pi", "gi", "li", "ci", "p", "ie", "part", "multi", "si", "xi", "io", "bi", "uri", "v", "x", "ai", "ji", "eni", "y", "ip", "is", "ti", "qi", "id", "e", "iu", "u", "im", "vi", "n", "di", "m", "I"], "f": ["folder", "j", "o", "fr", "q", "feed", "fun", "w", "F", "fe", "fi", "fc", "l", "b", "info", "cf", "r", "fd", "t", "d", "fb", "fl", "p", "v", "df", "fp", "fs", "fx", "h", "file", "fn", "e", "sf", "u", "n", "m"], "g": ["ga", "q", "gar", "G", "gin", "global", "w", "group", "ger", "l", "b", "gg", "rg", "gb", "r", "gh", "gi", "tg", "t", "eg", "d", "m", "ig", "pg", "p", "gc", "sg", "mg", "gd", "gu", "gs", "ge", "h", "erg", "file", "gn", "e", "s", "go", "og", "ng", "bg", "u", "reg", "msg", "n", "vg", "gm", "gp"], "destinationFile": ["destinationsFile", "DestinationFile", "destacementfile", "destiningFile", "DestationDir", "destinationFilename", "destificationDir", "Destinationfile", "destinatorDirectory", "DestinationLocation", "destiningDir", "destiningfile", "DestificationDir", "destificationLocation", "destiningFilename", "destationFile", "destinationsDir", "destinatorFile", "destificationFile", "destacementFile", "DestificationLocation", "DestificationDirectory", "destacementFilename", "destinatorDir", "destinationDir", "destinationfile", "destationfile", "destinatorLocation", "DestationFilename", "destationFilename", "destinationDirectory", "DestinationDir", "DestinationFilename", "DestinationDirectory", "destinationLocation", "Destationfile", "DestificationFile", "destinationsDirectory", "destacementDir", "destationDir", "destificationDirectory", "destinationsLocation", "DestationFile"], "sourceFile": ["sourceDirectory", "srcDir", "ourceDirectory", " sourceModule", "sourceDir", "SourceDir", "ourceFiles", "inputDirectory", "inputDir", " sourcefile", " sourceFiles", "inputFiles", "sourceModule", "SourceFile", "SourceModule", "inputFile", "sourcefile", "Sourcefile", "ourceDir", "srcfile", "srcFile", "sourceFiles", " sourceDir", "srcModule", "ourceFile", " sourceDirectory"], "infile": ["indir", "outf", "windir", "outdir", "inf", "outFile", "inputfile", "diffFile", "inputstream", "inFile", "InFile", "outstream", " instream", "Instream", "diffdir", " inFile", "indata", "difffile", "winstream", "inputdata", "inputFile", "winFile", "diffstream", "instream", "outdata", "winfile", "Inf", " indata", "inputf", "Infile"], "outfile": ["exstream", "intstream", "outline", "Outstream", " outpage", "outFile", "againFile", " outFile", "intFile", "inputfile", "outpage", "Outlive", "againpage", "outfunction", "outstream", "againfile", "inputline", "exfile", " outfunction", "intlive", "Outfunction", " outstream", "againstream", "inputfunction", "inputFile", "outlive", "intfile", "expage", "exFile", " outline", "OutFile", "Outline", "Outfile", " outlive"], "c": ["z", "lc", "enc", "esc", "index", "dec", "in", "ice", "o", "end", "cont", "w", "cl", "pc", "channel", "cu", "l", "ch", "b", "C", "code", "string", "r", "ct", "rc", "t", "d", "k", "ci", "p", "pointer", "v", "x", "cy", "xc", "character", "cm", "col", "ac", "a", "h", "id", "e", "char", "comment", "u", "abc", "n", "uc", "ec", "m", "cr"]}}
{"id1": "9413074", "id2": "23517481", "code1": "    String getLocation(Class clazz) {\n        try {\n            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();\n            String location = url.toString();\n            if (location.startsWith(\"jar\")) {\n                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();\n                location = url.toString();\n            }\n            if (location.startsWith(\"file\")) {\n                java.io.File file = new java.io.File(url.getFile());\n                return file.getAbsolutePath();\n            } else {\n                return url.toString();\n            }\n        } catch (Throwable t) {\n        }\n        return Messages.getMessage(\"happyClientUnknownLocation\");\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"getLocation": ["getFile", "GetURL", "getURL", "newLocation", "getPath", "findURL", "findFile", "setURL", "findLocation", "setPath", " getAddress", "findLoc", "newURL", "newLoc", "GetAddress", "setLocation", "setAddress", "getAddress", "newFile", " getPath", "GetFile", " getURL", "getLoc", "GetLoc", "GetLocation", "GetPath"], "clazz": ["cllass", "Cluster", " cluster", "Clclass", "CLlass", "CLuster", "CLazz", "cluster", " clclass", "Cllass", "Clazz", "CLclass", " cllass", "clclass"], "url": ["URL", "resource", "lr", "impl", "channel", "ref", "href", "bb", "page", "null", "class", "layer", "context", "name", "ll", "browser", "connection", "host", "source", "f", "log", "html", "service", "cl", "local", "api", "b", "string", "code", "pull", "loader", "language", "server", "user", "jar", "loc", "base", "email", "entry", "text", "zip", "l", "object", "position", "path", "client", "ssl", "Location", "or", "rel", "web", "mount", "address", "image", "link", "feed", "site", "coll", "Url", "http", "route", "buffer", "org", "uri", "bug", "gl", "ob", "sl", "i", "config"], "location": ["lc", "image", "URL", "resource", "site", "storage", "directory", "content", "warning", "function", "property", "message", "local", "filename", "area", "l", "home", "string", "via", "style", "position", "route", "path", "translation", "result", "uri", "response", "layer", "region", "where", "length", "library", "operation", "language", "data", "layout", "instance", "Location", "description", "feature", "error", "connection", "loc", "source", "address"], "file": ["File", "folder", "image", "base", "log", "resource", "child", "ile", "entry", "fe", "cache", "filename", "key", "remote", "l", "full", "object", "page", "class", "pe", "files", "path", "able", "line", "io", "uri", "it", "entity", "fp", "dir", "FILE", "il", "name", "el", "per", "get", "lib", "source", "f"]}}
{"id1": "19944975", "id2": "5299276", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["saveConfig", "writeConfig", " writeConfig", " writeReport", "writeReport", "WriteReport", "WriteConfiguration", "WriteSection", " writeSection", "saveConfiguration", "saveSection", "saveReport", "WriteConfig", "writeSection"], "out": ["err", "pool", "resource", "base", "o", "temp", "prefix", "this", "inner", "flush", "w", "write", "plain", "project", "at", "obj", "window", "exp", "exec", "filename", "output", "OUT", "password", "writer", "conn", "list", "object", "key", "sync", "scope", "string", "c", "IN", "external", "again", "outs", "path", "m", "line", "io", "Out", "client", "xml", "report", "name", "init", "inas", "ext", "dump", "server", "user", "file", "ex", "reader", "res", "lib", "connection", "config", "parent"], "url": ["image", "URL", "base", "resource", "service", "feed", "stream", "Url", "open", "channel", "http", "l", "b", "api", "conn", "object", "page", "string", "r", "path", "io", "rel", "org", "uri", "xml", "location", "ssl", "server", "data", "file", "ll", "ob", "sl", "connection", "config", "source", "web", "f", "address"], "in": ["ini", "err", "kin", "resource", "login", "serv", "stream", "gin", "inner", "inn", "input", "In", "inc", "cms", "bin", "b", "conn", "c", "pin", "r", "IN", "again", "source", "nin", "cin", "min", "ins", "is", "xml", "as", "lin", "socket", "inas", "ssl", "a", "inside", "ac", "data", "rin", "isin", "file", "id", "i", "reader", "win", "n", "din", "f", "copy", "s"]}}
{"id1": "21092340", "id2": "20100809", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addToSlives", "addtoAsively", "addToAdaptive", "addtoAsives", "addToAdaptively", "addtoArchIVE", "addToAsives", "addToArchIVE", "addToAdaptives", "addToArchives", "addToAsIVE", "addtoAsIVE", "addtoAsive", "addToSlive", "addToAsively", "addToArchively", "addToAsive", "addtoArchive", "addToAdaptIVE", "addToSlively", "addtoArchives", "addToSlIVE", "addtoArchively"], "pod": ["module", "child", "po", "pc", "Pod", "zip", "cache", "table", "post", "object", "pad", "product", "pi", "pe", "node", "pl", "pid", "p", "ad", "part", "pot", "plug", "proc", "ce", "od", "tmp", "loader", "bean", "peer", "component", "ods", "host", "cer", "pkg", "per", "project", "plugin"], "podArchiveOutputStream": ["podArchivingOutputSteam", "podArchiveByteDirectory", "podArchiveWriteSteam", "podArchivingWriteFile", "podArchiveWriteStream", "podArchiveInputStream", "podArchiveFilePath", "podArchiveInputPath", "podArchiveByteSteam", "podArchiveOutputPath", "podArchivesOutputSteam", "podArchiveByteStream", "podArchiveOperationSteam", "podArchiveOutputDirectory", "podArchivesFileResource", "podArchiveFileFile", "podArchIVEInputFile", "podArchivingOutputFile", "podArchiveOperationStream", "podArchivesOutputStream", "podArchiveOperationResource", "podArchiveOutputSteam", "podArchIVEInputStream", "podArchiveFileDirectory", "podArchiveIOResource", "podArchiveWriteFile", "podArchIVEOutputStream", "podArchiveInputFile", "podArchiveInputDirectory", "podArchiveOperationFile", "podArchivesFileStream", "podArchivingWriteSteam", "podArchiveIOFile", "podArchIVEOutputDirectory", "podArchiveIOSteam", "podArchiveFileStream", "podArchiveFileResource", "podArchiveInputSteam", "podArchivingOutputStream", "podArchiveOutputResource", "podArchivesOutputFile", "podArchivesOutputResource", "podArchiveByteFile", "podArchivingOutputPath", "podArchIVEOutputFile", "podArchIVEInputSteam", "podArchivesFileFile", "podArchiveOutputFile", "podArchiveIODirectory", "podArchiveFileSteam", "podArchivesFileSteam", "podArchivingWritePath", "podArchIVEOutputSteam", "podArchivingWriteStream", "podArchiveIOStream", "podArchiveWritePath", "podArchIVEInputDirectory"], "filename": ["folder", "module", "prefix", "kn", "dll", "sequence", "alias", "download", "which", "property", "platform", "l", "label", "string", "application", "files", "subject", "route", "path", "kl", "fil", "Filename", "uri", "SourceFile", "named", "fp", "ename", "FILE", "il", "loader", "name", "location", "title", "nil", "word", "archive", "file", "fn", "binary", "username", "sf", "database", "f", "url", "ppa", "directory"], "source": ["image", "unit", "slave", "service", "resource", "SOURCE", "stream", "Source", "input", "target", "src", "text", "zip", "slice", "output", "stack", "use", "string", "driver", "path", "ource", "result", "uri", "loader", "proxy", "archive", "file", "document", "seed", "sl", "reader", "connection", "config", "parent", "url", "copy"], "entry": ["image", "letter", "index", "resource", "child", "feed", "this", "stream", "event", "obj", "zip", "Entry", "add", "post", "object", "auto", "string", "element", "r", "path", "ie", "line", "record", "result", "pointer", "it", "se", "row", "article", "ge", "archive", "data", "file", "e", "iterator", "reader", "or", "connection", "parent", "address"]}}
{"id1": "19322941", "id2": "2910383", "code1": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "code2": "    public String downloadAndOpen(JProgressBar bar) {\n        long size = 0;\n        try {\n            size = photo.getSize();\n        } catch (ServiceException ex) {\n            ex.printStackTrace();\n        }\n        try {\n            bar.setMaximum((int) size);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        bar.setValue(0);\n        image = new File(\"TMP/\" + photo.getTitle().getPlainText());\n        try {\n            if (!image.exists()) {\n                image.createNewFile();\n                image.deleteOnExit();\n                URL url = null;\n                BufferedOutputStream fOut = null;\n                try {\n                    url = new URL(photo.getMediaContents().get(0).getUrl());\n                    InputStream html = null;\n                    html = url.openStream();\n                    fOut = new BufferedOutputStream(new FileOutputStream(image));\n                    byte[] buffer = new byte[32 * 1024];\n                    int bytesRead = 0;\n                    int in = 0;\n                    while ((bytesRead = html.read(buffer)) != -1) {\n                        in += bytesRead;\n                        bar.setValue(in);\n                        fOut.write(buffer, 0, bytesRead);\n                    }\n                    html.close();\n                    fOut.close();\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return image.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"test_lookupResourceType_FullSearch_TwoWordsInMiddle": ["test_lookupResourceType_FullSearchWithtwoW", "test_lookupResourceType_FullSearchWithtwoWord", "test_lookupResourceType_FullSearch_ThreeWord", "test_lookupResourceType_FullSearch_Threewords", "test_lookupResourceType_FullSearch_ThreeW", "test_lookupResourceType_FullSearch_twoW", "test_lookupResourceType_FullSearchWithtwoWords", "test_lookupResourceType_FullSearchWithtwowords", "test_lookupResourceType_FullSearch_Fourwords", "test_lookupResourceType_FullSearch_twoWords", "test_lookupResourceType_FullSearch_FourW", "test_lookupResourceType_FullSearch_FourWords", "test_lookupResourceType_FullSearch_TwoWords", "test_lookupResourceType_FullSearch_twowords", "test_lookupResourceType_FullSearch_Twowords", "test_lookupResourceType_FullSearch_twoWord", "test_lookupResourceType_FullSearchWithTwoWords", "test_lookupResourceType_FullSearch_TwoWord", "test_lookupResourceType_FullSearchWithTwoWord", "test_lookupResourceType_FullSearch_ThreeWords", "test_lookupResourceType_FullSearch_FourWord", "test_lookupResourceType_FullSearchWithTwowords", "test_lookupResourceType_FullSearchWithTwoW", "test_lookupResourceType_FullSearch_TwoW"], "url": ["link", "image", "method", "log", "URL", "base", "resource", "feed", "system", "Url", "entry", "channel", "http", "l", "b", "conn", "object", "page", "string", "c", "position", "path", "https", "org", "uri", "client", "bug", "ssl", "server", "user", "file", "document", "sl", "contact", "config", "location", "web", "f", "address"], "connection": ["body", "image", "method", "j", "link", "service", "resource", "section", "ion", "event", "function", "which", "entry", "channel", "version", "Connection", "http", "cache", "use", "l", "b", "conn", "password", "object", "application", "c", "position", "condition", "session", "relation", "handler", "translation", "result", "io", "uri", "number", "response", "client", "character", "context", "bug", "expression", "communication", "proxy", "operation", "con", "wrapper", "server", "loc", "document", "established", "connect", "database", "contact", "bc", "connected", "config", "location", "db"]}}
{"id1": "20717531", "id2": "937612", "code1": "    public static String encrypt(String plainText) {\n        if (TextUtils.isEmpty(plainText)) {\n            plainText = \"\";\n        }\n        StringBuilder text = new StringBuilder();\n        for (int i = plainText.length() - 1; i >= 0; i--) {\n            text.append(plainText.charAt(i));\n        }\n        plainText = text.toString();\n        MessageDigest mDigest;\n        try {\n            mDigest = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            return plainText;\n        }\n        mDigest.update(plainText.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    public String new2Password(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            String clearPassword = passwd;\n            md.update(clearPassword.getBytes());\n            byte[] digestedPassword = md.digest();\n            return new String(digestedPassword);\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"MD5 doesn't exist\");\n            System.out.println(e.toString());\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": [" decipher", " deccrypt", "encress", "Enccrypt", " encipher", "Encrypt", "encipher", "Encress", " decress", " decrypt", " enccrypt", " encress", "Encipher", "enccrypt"], "plainText": ["protectedString", "flatTEXT", "publicTEXT", "protectedTextColor", " plainTarget", "binarytext", "batTEXT", "simpletext", "plainTextColor", "singletext", "binaryText", "externalText", "binaryPart", "externalString", "batText", "flatText", "batContent", "protectedContent", "battext", "simpleText", "flatTime", "singleString", "singlePart", " plainPart", "protectedtext", "publictext", " plainTextColor", "fullData", "plaintext", "originalTextColor", "externaltext", "flattext", "plainTarget", "fullTEXT", "plainTime", " plainData", "externalKey", " plainTEXT", "plainString", "fulltext", "originalText", " plainKey", "plainData", "binaryString", "publicTarget", "originalTEXT", "publicText", "plainContent", "simpleTime", "protectedKey", "flatContent", "protectedTEXT", " plainString", "plainKey", "originaltext", "flatData", "simpleTEXT", "plainTEXT", "singleText", "fullText", " plainContent", "plainPart", "flatTarget", "protectedText", "fullTime", " plaintext"], "text": ["image", "letter", "service", "feed", "null", "config", "event", "form", "input", "pattern", "message", "output", "key", "use", "b", "writer", "post", "object", "struct", "password", "print", "string", "txt", "builder", "code", "math", "contract", "font", "url", "buffer", "Text", "path", "source", "result", "width", "out", "length", "editor", "context", "off", "test", "ext", "word", "data", "id", "port", "str", "value", "tx", "TEXT", "append", "address"], "i": ["ini", "z", "mi", "index", "j", "o", "in", "chi", "temp", "io", "field", "hi", "phi", "ii", "ix", "fi", "slice", "mu", "key", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "t", "abi", "li", "ind", "k", "ci", "ie", "p", "multi", "si", "ni", "xi", "I", "bi", "v", "x", "ai", "ji", "uri", "eni", "it", "ip", "y", "ti", "h", "id", "qi", "e", "iu", "f", "u", "vi", "n", "di", "m", "oi", "s"], "mDigest": ["mDest", "mHashusher", " mDigester", "mDigusher", "mdigEST", "MDester", "MDex", "mHashester", "mEdest", "cmdigester", "cmDigester", " mDigEST", "MDest", "mHashest", "mDigse", "mDigEST", "mDigex", "MDigex", "cmdigest", "mdigex", "mdigester", "mDigger", " mHashusher", "mdigusher", "mdigse", "mDer", " mHashest", "mDigester", "mDester", " mDEST", "mDusher", "cmDigest", "mEdester", "mDger", " mDse", "mDigests", "mCompest", "mCompester", "mDested", " mDest", "mDiger", "mDex", "cmDiger", "mdigested", "mdiger", "mDests", "mEder", " mHashester", "mCompex", "mEdested", "mdigger", " mHashger", "MDigest", "mdigest", " mDigse", "MDigests", " mDester", "mHashse", "cmdigested", "cmdiger", " mDigger", "mDigested", "cmDigested", "mHashger", "mDse", "MDests", "mdigests", "mCompests", "mDEST", "mHashEST", " mDigusher", "MDigester"], "d": ["dd", "z", "dim", "dr", " D", "dc", "dat", "dig", "D", "dos", "l", "b", "bytes", "ld", "cd", "string", "da", "did", "c", " data", "t", "fd", "p", "ds", "dt", "v", "x", "sd", "md", "a", "h", "data", "id", "dh", "ded", "e", "dn", "str", "u", "n", "di", "dl", "m", "db", "f", "s"], "hash": ["image", "her", "sha", "html", "log", "base", "hex", "history", "square", "version", "message", "key", "output", "b", "bin", "print", "string", "code", "array", "kh", "buffer", "db", "result", "build", "v", "sh", "number", "ashes", "secret", "carry", "mac", "ash", "block", "size", "ssh", "Hash", "bar", "hed", "sum", "h", "ha", "shadow", "user", "header", "str", "dot", "memory", "f", "url", "cover"]}}
{"id1": "22135199", "id2": "2668634", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testCodingEmptyFile": ["testCodingOfStream", "testCodingOfFile", "testCodingNoFile", "testCodingZeroSourceFile", "testCachingOfStream", "testCodingEmptyFiles", "testCodingNoFiles", "testCachingEmptyFile", "testCachingEmptyFiles", "testCodingOfFiles", "testCodingNoSourceFile", "testCodingNoStream", "testCachingEmptySourceFile", "testCachingOfSourceFile", "testCodingEmptyStream", "testCachingEmptyStream", "testCodingOfSourceFile", "testCodingZeroStream", "testCodingZeroFiles", "testCodingEmptySourceFile", "testCachingOfFiles", "testCodingZeroFile", "testCachingOfFile"], "baos": ["waoS", "baOS", "kaos", "kaOS", "aaaaoS", "bao", " baoS", "bioS", "pao", "BaOs", "Baos", "waos", "buoa", "buo", "Baoes", "kao", "buOS", "paos", " baotes", "waOS", "aaaaos", "baoS", "biotes", "BaoS", "baOs", "aaaaOs", "baotes", "BaOS", " baoes", "Baotes", "waOs", "aaaaOS", "bioes", "baoes", "bios", "kaoa", "paOS", "paoa", "baoa", "buos"], "channel": ["flow", "log", "video", "service", "system", "feed", "can", "stream", "self", "cam", "group", "camera", "queue", "ch", "conn", "url", "c", "annels", "handler", "sc", "io", "an", "container", "console", "out", "client", "Channel", "context", "chan", "socket", "cho", "bean", "server", "data", "sea", "reader", "connection", "config", "source", "parent"], "params": ["options", "Par", " parameters", "ops", "param", "mm", "http", "cms", "parser", "ams", "api", "conn", "par", "null", " param", "ps", "settings", "Parameters", "cmp", "stats", "processor", "proc", "css", "size", "Param", "tx", "ctx", "cpu", "config"], "outbuf": ["outbuff", "Outbuf", " outbuff", "outbuffer", "outputbag", " outqueue", " outbuffer", "inputqueue", "outbag", "Outbuff", "inputbag", "inputbuf", "outputcb", "outputbuffer", "outputbuf", "Outcb", "outcb", "outputqueue", "outputbuff", " outbag", "outqueue", "Outbuffer", "inputbuff", " outcb"], "metrics": [" metals", "Metrics", "metics", "metrix", "monics", "metras", "matrics", "Metric", "monrics", "Metics", "monras", "matric", "matrix", "Metras", " metric", "metric", "metals", " metics", "matals", "Metals", " metras", "monric", " metrix", "Metrix"], "encoder": ["ecler", "enccode", "ecressor", "Encoding", "eccode", " encoded", "ecoding", " encoding", "encoded", "encressor", "Encipher", "enressor", "Encoser", "Encoded", "encoser", "encoding", "Encoder", "ecoded", "ecoder", " encoser", "ecode", "encode", "ecoser", "encipher", " encressor", "enoder", "encler", " encler", "Encler", " encode", " encipher", "enode", "enoded", "Encode", " enccode", "enoser", "ecipher"], "tmpFile": ["tempFolder", "mpFilename", "tempFile", "mpFile", "tmpFiles", " tmpFolder", "tempfile", "mpFunction", "mpPath", "mpFiles", " tmpDir", "txtfile", "tmpFunction", "poraryFunction", "vtFilename", " tmpPath", "tmpfile", "mpfile", "poraryFile", "vtFile", "testFiles", " tmpFiles", "tmpFilename", " tmpFilename", "tmpDir", "testfile", "mpDir", "testFile", "tmpFolder", "tempFiles", "testFolder", "txtFile", "mpPage", "tempPath", "tmpPath", "txtFunction", "poraryfile", "vtfile", "txtPage", "vtDir", "tmpPage", "poraryPage", " tmpfile"], "fout": ["flout", "fio", "fdagain", "ffile", "Fio", "fdout", "sfio", " fio", "frout", "flagain", "frurl", "furl", "fagain", "flwrite", "frwrite", "Fchannel", "sffile", "fdwrite", "sfout", "flurl", "Fout", "fdurl", "fragain", "sfchannel", "Ffile", "fwrite", " ffile"], "wrtout": ["wRTwriter", "wadrin", "Wrtwriter", " wrtouter", "wRTouter", "WRTin", "WrtOut", "wrin", "wrdouter", "wrdin", "WRTwriter", "Wrtin", "wadrouter", "WRTouter", "wrcagain", "wrOut", "wrcouter", "wrtouter", "WRTout", "Wrtouter", "wrcin", "wrn", "wrcn", "wRTout", "wrtagain", " wrcout", "wadragain", "wrcOut", "Wrtn", " wrcagain", "wadrwriter", "wrtin", " wrtagain", " wrtin", "wrdout", "wrtwriter", "wadrout", "wRTin", "wRTn", "wrout", "WRTn", " wrcouter", "WRTOut", " wrcin", "Wrtout", "wrtOut", "wrdwriter", "wrtn", "wRTagain", "wrcout", "wRTOut"], "fchannel": ["fqueue", "fenresource", "pconn", " fcontainer", "fconn", "fstream", "bconn", "bchannel", "fenqueue", "pchannel", "pstream", "presource", "pchan", " fchan", "fresource", "pqueue", "hstream", "fchan", "hchannel", "fenchannel", "bcontainer", "pcontainer", "fenstream", "fcontainer", "hqueue", "hresource", "bchan", " fconn"], "s": ["o", "abs", "ls", "services", "ns", "l", "b", "ms", "js", "string", "c", "r", "g", "ps", "t", "p", "settings", "S", "su", "os", "v", "states", "qs", "ins", "ses", "es", "gs", "ings", "e", "u", "ss", "i", "n", "ts", "m", "strings", "f"]}}
{"id1": "3558512", "id2": "11673907", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"serialize": ["Serialify", " serializable", "erialize", "serialization", "erialze", "erialization", "Serialized", "Serializable", "Serialize", "finalze", "normalized", "finalize", " serialze", "Serialze", " serialization", "normalize", "serialze", "serialify", "serializable", "normalify", "erializable", "finalify", "finalized", "Serialization", "serialized", "normalze"], "out": ["err", "image", "pool", "o", "temp", "raw", "content", "w", "up", "cache", "exec", "filename", "output", "OUT", "writer", "conn", "bin", "page", "string", "buffer", "outs", "io", "Out", "client", "loader", "report", "name", "a", "dump", "archive", "server", "data", "file", "gen", "png", "ex", "i", "source", "parent", "obj", "copy"], "parser": ["base", "system", "tt", "arser", "pillar", "worker", "up", "parse", "master", "cache", "rar", "writer", "lp", "builder", "class", "txt", "pp", "pe", "handler", "er", "p", "upload", "Parser", "xml", "as", "manager", "loader", "test", "wrapper", "server", "file", "seed", "php", "instance", "ss", "reader", "per", "pkg", "cp", "parent", "plugin", "copy", "processor"], "on_disk": ["onJdisk", "onjspace", "onJdemand", "onjdrive", "on_delete", "on_drive", "onjfile", "onJlock", "onbookdisk", "onnetdemand", "on_storage", "off_demand", "on_file", "onnetdisk", "onbootdisk", "onnetspace", "onJdrive", "onbookdelete", "on_lock", "off_disk", "off_storage", "onbootlock", "onjdisk", "onnetdrive", "onbookdrive", "onbootstorage", "off_file", "onbootdrive", "off_space", "on_space", "onnetfile", "off_lock", "off_drive", "off_delete", "on_demand"], "in": ["ini", "kin", "o", "login", "stream", "inner", "inn", "input", "In", "bin", "conn", "info", "c", "pin", "IN", "r", "again", "pass", "source", "min", "ins", "lin", "as", "inas", "ac", "thin", "con", "data", "file", "rin", "ax", "reader", "i", "win", "connection", "din", "f", "socket", "inc", "copy"]}}
{"id1": "1180878", "id2": "812803", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["frieveUrldata", "fetchURLDATA", "frieveURLDATA", "fetchJSONData", "frieveUrlDATA", "fetchHTTPDATA", "fetchUrldata", "fetchURLdata", "fetchUrlDATA", "frieveURLdata", "fetchHTTPdata", "fetchUrlData", "frieveURLData", "fetchHTTPData", "fetchJSONdata", "fetchJSONDATA", "frieveUrlData"], "url": ["image", "html", "URL", "base", "resource", "feed", "www", "view", "download", "Url", "ls", "http", "text", "src", "filename", "l", "href", "api", "page", "string", "path", "fl", "source", "uri", "xml", "ur", "name", "location", "ssl", "server", "data", "file", "user", "gl", "username", "sl", "el", "connection", "loc", "host", "f", "address"], "proxyHost": ["cacheHost", " proxyServer", "serverAddress", "serverPath", " proxyAddress", "baseHost", "baseDomain", "remoteAddress", "proxyHead", "baseAddress", "ProxyHead", "remoteDomain", "ProxyHost", " proxyPath", "proxyhost", "serverServer", " proxyhost", "proxyDomain", "baseHead", "ProxyDomain", "ProxyServer", "cachePort", "proxyPath", "remoteHead", "ProxyPath", "proxyAddress", "proxyServer", "cachehost", "cacheAddress", "ProxyPort", "ProxyAddress", "remoteHost", "Proxyhost", "serverHost"], "proxyPort": ["cacheHost", " proxyServer", " proxyport", " proxyAddress", "httpPort", "ProxyHost", "httpServer", "httpAddress", "cachePort", "Proxyport", "ProxyServer", "cacheport", "proxyAddress", "proxyServer", "proxyport", "cacheAddress", "ProxyPort", "ProxyAddress", "httpHost"], "con": ["com", "fa", "ls", "rec", "ch", "c", "cf", "rc", "ci", "per", "uc", "connection", "cr", "f", "login", "cl", "pc", "cur", "ca", "cache", "run", "sync", "conn", "CON", "ran", "co", "ocon", "cone", "connect", "go", "win", "re", "conv", "change", "sub", "fac", "fun", "don", "common", "pre", "cons", "fc", "remote", "un", "an", "x", "out", "xc", "Con", "pub", "cn", "on", "gen", "mc", "cp", "ec", "inc", "exec", "conf", "socket", "ver", "canon", "func", "can", "syn", "open", "pen", "ctrl", "http", "act", "pin", "fl", "en", "part", "ai", "min", "cc", "cas", "close", "cm", "ac", "n", "bc", "fan"], "is": ["ib", "its", "in", "can", "serv", "isi", "vs", "abs", "ops", "mis", "cms", "ir", "lis", "has", "does", "api", "info", "conn", "isu", "ws", "IS", "js", "ri", "act", "sp", "state", "ps", "was", "ie", "p", "ci", "ris", "si", "os", "it", "cs", "oss", "ai", "out", "isa", "isl", "fs", "iss", "cos", "il", "as", "es", "iso", "are", "bis", "us", "ori", "bs", "isin", "id", "isc", "ios", "Is", "i", "im", "get", "ais", "or", "ar", "iris", "ics", "s"], "u": ["ou", "o", "q", "U", "ul", "up", "ue", "http", "cu", "ut", "l", "un", "b", "ui", "uv", "api", "conn", "uci", "c", "m", "p", "io", "su", "uri", "os", "v", "client", "hu", "fu", "ur", "nu", "us", "h", "user", "file", "yu", "tu", "iu", "i", "uc", "ru", "lu", "f"], "proxy": ["force", "pool", "resource", "create", "clone", "phone", "pc", "fe", "http", "zip", "cache", "cop", " Proxy", "l", "api", "remote", "prot", "XY", "c", "pe", "pin", "Proxy", "pa", "plus", "p", "type", "xy", "uri", "x", "roxy", "ip", "client", "pse", "ssl", "bean", "wrapper", "server", "shadow", "port", "timeout", " proxies", "lib", "connection", "config", "host", "web", "f", "socket", "copy", "address"], "baos": ["abis", "baOS", "caas", "caos", "haOS", "bao", "bais", "BAOS", "BAos", "BAis", "pao", "boOS", "hao", "BaOs", "Baos", "boas", "haos", "calos", "caOS", "paOS", "Bais", "balos", "paos", "baas", "boos", "abOs", "abros", "BAo", "baOs", "aas", "bolos", "Baros", "pais", "hais", "alos", "baros", "BAOs", "aos", "aOS", "abos", "BAros"]}}
{"id1": "20024612", "id2": "5723876", "code1": "    private void parse() throws Exception {\n        BufferedReader br = null;\n        InputStream httpStream = null;\n        URL fileURL = new URL(url);\n        URLConnection urlConnection = fileURL.openConnection();\n        httpStream = urlConnection.getInputStream();\n        br = new BufferedReader(new InputStreamReader(httpStream, \"UTF-8\"));\n        String ligne;\n        String post;\n        String date;\n        String titre;\n        String resume;\n        String url2DL;\n        while ((ligne = br.readLine()) != null) {\n            if (ligne.indexOf(\"div class=\\\"post\\\" id=\\\"post\") != -1) {\n                post = null;\n                date = null;\n                titre = null;\n                try {\n                    post = ligne.substring(ligne.indexOf(\"post-\") + 5, ligne.indexOf(\"\\\"\", ligne.indexOf(\"post-\")));\n                    ligne = br.readLine();\n                    date = ligne.substring(ligne.indexOf(\"<div class=\\\"date\\\"><span>\") + 24);\n                    date = date.replaceAll(\"</span>\", \"\").replaceAll(\"</div>\", \"\").trim();\n                    log.info(\"Post   : \" + post + \" du \" + date);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    titre = ligne.substring(ligne.indexOf(\">\", ligne.indexOf(\"title\")) + 1, ligne.indexOf(\"</a>\"));\n                    titre = titre.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    url2DL = ligne.substring(ligne.indexOf(\"<a href=\\\"\") + 9, ligne.indexOf(\"/\\\"\")).trim();\n                    url2DL = url2DL.replace(\"mega-films.net\", \"mega-protect.com\") + \".php\";\n                    log.info(\"Titre  : \" + titre);\n                    log.info(\"To DL  : \" + url2DL);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    resume = ligne.substring(ligne.indexOf(\"<em>\") + 4, ligne.indexOf(\"</em>\"));\n                    resume = resume.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    log.info(\"Resume : \" + resume);\n                } catch (Exception e) {\n                    log.error(\"ERREUR : Le film n'a pas pu etre parse...\");\n                }\n                log.info(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\");\n            }\n        }\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["setup", "raw", "check", "format", "load", "parser", "process", "update", "print", "read", "split", " parsing", "se", "build", "Parser", "handle", " serve", "xml", "report", "pack", "init", "request", " parser", "file", "get", "arse", "url"], "br": ["err", "dr", "lr", "fr", "vr", "HR", "bl", "arr", "pre", "http", "ocr", "cro", "ler", "yr", "bridge", "ger", "b", "bb", "cb", "ch", "pr", "bolt", "buf", "sp", "r", "ber", "bel", "gr", "tr", "wr", "next", "bro", "bf", "be", "obl", "div", "result", "Br", "BR", "mr", "bre", "img", "blog", "ner", "orb", "bt", "ur", "report", "hr", "bar", "sr", "jar", "browser", "str", "rb", "res", "bc", "bh", "cr", "url"], "httpStream": ["fileSync", "resourceReader", "urlSteam", "httpSteam", "resourcestream", "fileCh", "httpConnection", "fileStream", " httpReader", "httpsStream", "resourceStream", "urlStream", "httpInput", "databaseSteam", "ttpConnection", "ttpSync", "httpstream", " httpCh", "databaseConnection", "httpReader", "urlInput", "httpsSteam", " httpstream", "databaseStream", "ttpStream", " httpSteam", " httpInput", " httpConnection", "resourceSteam", "ttpCh", "httpsReader", "httpCh", "httpsstream", " httpSync", "databaseInput", "fileConnection", "httpSync"], "fileURL": ["urlLocation", "FileUrl", "FileURL", "urlUrl", "baseLink", "baseURL", "urlURL", " fileSR", " fileLink", " fileUrl", "fileLocation", " fileLocation", "FileLocation", "FileLink", "fileUrl", "fileLink", "baseLocation", "baseSR", "fileSR", "urlSR", "baseUrl"], "urlConnection": ["fileconnection", "inputBuffer", "httpConnection", "resourceConnection", "httpBuffer", "httpconnection", "resourceconnection", "inputConnection", "inputConnect", "fileConnect", "fileConn", "urlconnection", "httpConn", "httpConnect", "resourceConnect", "urlConn", "resourceConn", "inputConn", "fileBuffer", "urlConnect", "urlBuffer", "fileConnection"], "ligne": ["iluble", "slitte", "ilffe", "yline", "lilette", "ilonge", "tinois", "pline", "lgent", "zigne", "lounge", "olitte", "loyer", "sluble", "slourse", " lidable", "slidable", "tivia", " lagi", "slounge", "olidable", "slinea", "ylitte", "ilourse", "iloyer", "zuble", "iloodle", "ylinois", "sligne", "sloyer", " lffe", "slonge", "elounge", "lille", "tille", "slignment", " longe", "liner", " linea", "liorde", "eliner", "lige", " lgent", "lourse", "livia", "elidable", "slffe", " lourse", "ylorde", "ylivia", "lionge", "slauga", "lidable", "klauga", "lorde", "tigne", "tine", "kligne", "ilitte", " livia", "zlette", "olourse", "liivia", "iligne", "elinea", "torde", " lounge", " liner", "oline", "tuble", "ylounge", "lagi", "plonge", "sloodle", "loodle", "tinea", "iline", "elourse", "ilige", "kline", "yligne", "olonge", "slagi", "luble", "oligne", "liiner", "tiner", "liuble", "liauga", "elitte", "line", " loodle", "lffe", "pligne", "zauga", " lauga", " line", "tgent", "tauga", "ilgent", "olinea", "ilauga", "litte", " linois", " lige", " lorde", " loyer", "longe", "tonge", "sliner", "liignment", " luble", "elonge", "ylourse", "ylige", "ilagi", "plounge", "klille", "lauga", "liigne", "yloyer", "lignment", "linois", "linea", "eligne", "elffe", " llette", "ylinea", "sline", " lille", "ilinea", "tignment", "llette", "olounge", "toyer", " litte"], "post": ["dd", "image", "body", "log", "posts", "draw", "po", "pre", "ticket", "patch", "head", "topic", "text", "message", "add", "zip", "password", "media", "object", "update", "style", "string", "class", "pe", "tax", "POST", "pass", "cod", "p", "type", "month", "record", "build", "ip", "bug", "od", "name", "title", "word", "the", "mod", "id", "data", "user", "valid", "comment", "thread", "pod", "Post", "time", "meta", "tag", "project", "address"], "date": ["body", "image", "index", "dr", "resource", "module", "change", "create", "button", "event", "debug", "dat", "draw", "pre", "duration", "grade", "patch", "open", "match", "format", "reason", "day", "zip", "message", "key", "rate", "update", "trade", "page", "string", "style", "status", "pe", "Date", "stage", "d", "doc", "type", "div", "month", "mate", "gender", "year", "number", "sign", "bug", "name", "mark", "id", "file", "data", "user", "value", "complete", "pose", "time", "tag", "dates", "md", "url", "save"], "titre": ["tittingrex", "tipren", "tractpen", "tizbre", "tigritic", "ttitsro", "ttigre", "ntittingrex", "ntitbre", "taitril", "ntitrell", "titsbre", "titspen", "ntitspen", "titbre", "titare", "ttitsret", "titr", "tizren", "titaril", "titaro", "titrell", "ntitsritic", "tittre", "tractren", "titsere", "tithrex", "tractrer", "tibrex", "ttigritic", "ttitrex", "tuitritic", "tittingrell", "ticres", "ntitritic", "tittere", "ttitro", "ticre", "atitbre", "tizre", "tuitpen", "tuitbre", "titsro", "titsret", "ptitsrone", "tipre", "titret", "tithr", "titrex", "tittres", "titere", "ntitpen", "titres", "ttitret", "titsres", "tipbre", "titril", "ntitsre", "ptitere", "tittingre", "tractbre", "titsre", "ntitr", "tuitre", "titsritic", "tigrex", "atitren", "ntittingr", "tractre", "tithrell", "ptitrone", "titro", "atipbre", "titsrone", "taitro", "ptitsre", "titreen", "ptitres", "tittrone", "tractritic", "atipre", "tittingr", "ntitre", "ptitsere", "titaret", "ptitsres", "taitre", "tibr", "titritic", "tithreen", "ttitre", "tibrell", "ptitre", "titrone", "ntitrex", "titren", "ttigreen", "titsril", "ttitsre", "ticrone", "atiprer", "tibre", "titrer", "tigreen", "atipren", "ttitritic", "tizrer", "titpen", "tiprer", "ttitril", "tithritic", "titsreen", "ntittingrell", "ttitsril", "ticere", "atitre", "ntittingre", "ttigrex", "tithre", "ntitsbre", "titsrex", "taitret", "atitrer", "ttitreen", "tigre"], "resume": ["preserve", "resumption", "revend", "presend", " resumption", "presumption", "reverve", "revumption", "presume", "revume", " resend", "resend", " reserve", "reserve"], "url2DL": ["url62LC", "url4NL", "fileTwoDL", "urlTwoLC", " url6LP", "url2LP", "url2LM", "urlTwoLL", "url4LL", "file2LC", "urlBLR", "url4DL", "url4LM", "url2LC", "fileTwoLL", "url2UL", "urlTwoUL", "url62LL", "url2NL", "urlGETLL", "file2LR", "url2dl", "url62DL", " url6LL", "urlToNL", "urlTwoLP", "url2LR", " url6DL", "url4TL", "file2DL", "url4UL", "urlBDL", " url2LM", " url2NL", " url2SL", " url2dl", "urlBLC", "urlTwoSL", "url6LP", " url6dl", " url2TL", "urlGETdl", "urlTwoDL", "url6LL", "url62LR", "urlToLM", "urlGETDL", " url2LL", "url2SL", "urlGETLP", " url2LP", "fileTwoLC", " url2UL", "url6dl", "fileTwoLR", "url2LL", "url6DL", "urlTwodl", "urlToTL", "file2LL", "url4SL", "urlBLL", "urlToDL", "urlTwoLR", "url2TL"]}}
{"id1": "1421557", "id2": "16590954", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeString2File", "encodeFileFromStream", "encodeFileFromString", "encodeStringToStream", "encodeString2Files", "encodeFiletoStream", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFiles", "encodeFiletoFile", "encodeFileFromFiles", "encodeFileFromFile", "encodeString2Stream", "encodeStringToString", "encodeFileToString", "encodeFile2String", "encodeString2String", "encodeFile2File", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFile2Files", "encodeFileToStream"], "infile": [" infilename", "infiles", "Infilename", "outFile", "inputfile", "outfiles", "inFile", "InFile", "inputfilename", " infiles", " infp", "inputFile", "outfilename", "outfp", "Infiles", "inputfiles", "infp", "inputfp", "infilename", "Infile"], "outfile": ["newfolder", "outname", "outFile", " outFile", "outputfp", "outputfilename", " outfilename", "Outname", "outfolder", "outputfolder", " outfp", "Outfolder", "newfile", "newname", " outfolder", "infolder", "newFile", "outfilename", "outfp", "outputfile", "OutFile", "infp", " outname", "infilename", "Outfile"], "in": ["re", "err", "ini", "image", "base", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "vin", "m", "din", "socket", "inc", "s"], "out": ["err", "ou", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "In", "obj", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "outs", "work", "job", "source", "line", "io", "Out", "client", "off", "name", "co", "on", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "count", "cache", "slice", "queue", "b", "bytes", "bb", "null", "buf", "buff", "border", "padding", "fb", "split", "uffer", "type", "result", "len", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "input", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "close", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "model", "method", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "respons", "open", "better", "message", "growth", "modified", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "20623709", "id2": "19849797", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"split": ["share", "format", "open", "match", "parse", "add", "process", "run", "sync", "update", "set", "sort", "join", "part", "cmp", "build", "diff", "Split", "start", "init", "archive", "transfer", "delete", "execute", "exec", "append", "copy"], "targetDirectory": ["TargetDir", " targetPath", "basePath", "destFile", "baseFolder", "targetPath", "targetRoot", "TargetDirectory", "TargetDatabase", "outputFolder", "TargetFile", "currentFolder", "TargetRoot", "masterDirectory", "currentDirectory", "targetDatabase", "currentPath", "baseDatabase", "outputDir", "targetFolder", "baseDirectory", "destDirectory", "destFolder", " targetRoot", "TargetFolder", "destDir", "masterDir", "baseFile", " targetFolder", " targetFile", "targetFile", "currentRoot", "TargetPath", " targetDir", "currentDir", "outputDirectory", "masterDatabase", "baseDir", "targetDir", "outputFile", "masterPath"], "prefix": ["folder", "unit", "index", "base", "resource", "temp", "offset", "config", "root", "fix", "sequence", "format", "pre", "domain", "patch", "Pref", "pattern", "ix", "cache", "resolution", "filename", "queue", " suffix", "prot", "string", "txt", "padding", "path", "type", "fixed", "uri", "number", "fp", "first", "name", "FIX", "username", "timeout", "template", "append", "directory"], "maxUnitBases": ["maxunitBases", "maxUnitPlases", "maxunitAliaches", "maxUnitAliails", "maxUnitBasing", "maxUnitEase", "maxUnitQueues", "maxUnitEails", "maxUnitAliases", "maxUnitAliase", "maxunitBaches", "maxUnitQuease", "maxUnitBase", "maxunitBails", "maxunitAliails", "maxUnitQueasing", "maxUnitBues", "maxUnitBaches", "maxUnitAliaches", "maxUnitBails", "maxunitBasing", "maxunitBues", "maxUnitChase", "maxUnitChases", "maxUnitAliasing", "maxunitAliase", "maxunitAliases", "maxUnitPlaches", "maxUnitEaches", "maxUnitChasing", "maxunitAliasing", "maxUnitAliues", "maxUnitChues", "maxUnitPlase", "maxUnitQueases", "maxUnitEases", "maxUnitPlails", "maxunitBase", "maxunitAliues"], "maxUnitEntries": ["maxUnitInties", "maxUnitOrdresses", "maxLineOrdines", "maxLineOrdrations", "maxUnitCountrations", "maxUnitEntryures", "maxUnitAddry", "maxUnitOrdrys", "maxUnitOrdines", "maxunitEnties", "maxunitEntrys", "maxUnitEntryries", "maxUnitAddries", "maxUnitIntrys", "maxUnitEntrys", "maxUnitAddures", "maxUnitOrdries", "maxUnitAddresses", "maxunitEntryries", "maxUnitCountry", "maxUnitEntryresses", "maxunitEntries", "maxUnitEntines", "maxUnitErries", "maxUnitEntryrys", "maxUnitErry", "maxLineOrdry", "maxunitEntryies", "maxLineEntry", "maxUnitErrations", "maxLineOrdries", "maxUnitEntresses", "maxLineEntries", "maxUnitOrdry", "maxUnitOrdrations", "maxUnitEntryry", "maxUnitErines", "maxunitEntresses", "maxUnitEntry", "maxUnitCountines", "maxLineEntrations", "maxUnitOrdies", "maxUnitCountries", "maxunitEntryresses", "maxUnitIntries", "maxUnitEnties", "maxUnitEntryies", "maxUnitIntresses", "maxUnitEntures", "maxunitEntryrys", "maxUnitEntrations", "maxLineEntines"], "fis": ["vai", " fai", " fIs", " fris", " fisc", "fisc", "forisc", "vIs", "vis", "forris", "forIs", "visa", "fIs", "foriss", "forai", "forisa", " fiss", "Fis", "fris", "fisa", "Fiss", "fiss", "foris", "Fisc", "fai", " fisa", "Fris"], "fci": ["hcos", "vai", " fai", "hco", "hai", "efco", "vcos", "fii", "efcos", " fii", "doci", "efai", "dco", "vco", "hci", "bci", "Fii", "bai", "vci", "Fis", "Foci", "dci", " foci", "efci", "bis", "Fci", "Fai", "foci", "fcos", "dii", "Fco", "bco", "fai"], "fos": ["fios", "fo", " fo", "fsios", " fcos", "tos", " fios", "toes", "infoss", "infos", "fso", "Foes", "fscos", "ifios", "foes", "fsos", "infoes", "Fos", "toss", "Fis", "ifo", "Foss", "infis", "ifos", "fcos", "tis", "ifcos", "foss"], "fco": ["hcos", "hgo", " fgo", "Fico", "dcos", "fbo", "hco", "fgo", "fileco", " fcos", "fileico", " fbo", "lci", "lco", "hci", "dco", "fileci", "dro", " fro", "Fbo", "lgo", "lcos", "dci", " fico", "filebo", "fico", "Fci", "fro", "fcos", "Fco", "lro"], "buffer": ["image", "base", "resource", "feed", "offset", "capacity", "view", "flush", "input", "entry", "channel", "window", "cache", "message", "queue", "rate", "bin", "writer", "info", "texture", "pad", "null", "scale", "buf", "read", "buff", "border", "position", "Buffer", "uffer", "translation", "result", "counter", "response", "layer", "block", "length", "context", "size", "expression", "loader", "pause", "bar", "request", "server", "data", "reference", "binary", "document", "transfer", "header", "callback", "comment", "zero", "reader", "timeout", "iter", "bc", "batch", "source", "memory", "copy", "device"], "currentBasesCount": ["currentChasesCount", "currentBatchescount", "currentChaseCount", "currentBasingNum", "currentBasingCounter", "currentBasingcount", "currentBasesCounter", "currentBasingCount", "currentBatchesCounter", "currentBatchesCount", "currentBasesNum", "currentBasescount", "currentBaseNum", "currentBaseCount", "currentChasesCounter", "currentChaseCounter", "currentChasecount", "currentBatchesNum", "currentBaseCounter", "currentChasescount", "currentChaseNum", "currentChasesNum", "currentBasecount"], "currentEntriesCount": ["currentEntrasLimit", "currentEntursOffset", "currentEnturesCount", "currentAddriesSize", "currentAddriesOffset", "currentEnturesOffset", "currentEnturesLimit", "currentEntursCount", "currentAdduresSize", "currentEntursSize", "currentEntrasCount", "currentAdduresCount", "currentAdduresOffset", "currentEntrasSize", "currentEntrasOffset", "currentEnturesSize", "currentEntriesOffset", "currentEntriesLimit", "currentAdduresLimit", "currentAddriesLimit", "currentEntursLimit", "currentAddriesCount", "currentEntriesSize"], "targetCount": ["Targetcount", "patternSize", "argetSum", "argetCount", "patternSum", "targetcount", "TargetSum", "patterncount", "argetcount", "targetSize", "patternCount", "TargetSize", "TargetCount", "targetSum", "argetSize"], "fastaChannel": ["fastABuffer", "fastanChannel", "fastasConnection", "fastanBuffer", " fastaContext", "fastasContainer", "fastaqColumn", "fastAContainer", "fastAChannel", "fastAConnection", "fastaContainer", "fastasBuffer", "fastaColumn", " fastAChannel", "fastanContainer", " fastAColumn", "fastaqBuffer", " fastAConnection", "fastAColumn", "fastasColumn", "fastaContext", "fastasChannel", "fastanContext", " fastaContainer", "fastaqChannel", "fastAContext", "fastasContext", " fastAContainer", " fastaColumn", " fastaConnection", "fastaConnection", " fastAContext", " fastABuffer", "fastaqConnection"], "totalSeqCount": ["totalSeqCounter", "totalQueQcount", "totalSeuxNum", "totalQueQNum", "totalSeqscount", "totalSeuxCounter", "totalSeuxCount", "totalQueqCounter", "totalQueqcount", "totalQueQCounter", "totalQueQCount", "totalSeQCounter", "totalSeuxcount", "totalSeqNum", "totalQueqNum", "totalSeQCount", "totalSeqsNum", "totalSeQNum", "totalSeQcount", "totalSeqsCount", "totalSeqcount", "totalSeqsCounter", "totalQueqCount"], "totalResiduesCount": ["totalResiduingcount", "totalResqueurescount", "totalResiduationCount", "totalResiduationNum", "totalResiduingCount", "totalResqueuesNum", "totalResqueuresSize", "totalResiduresNum", "totalResidurescount", "totalResiduesSize", "totalResiduresSize", "totalResiduesNum", "totalResiduationSize", "totalResiduresCount", "totalResqueuresCount", "totalResqueuesSize", "totalResiduescount", "totalResiduingSize", "totalResqueuescount", "totalResiduingNum", "totalResqueuesCount", "totalResiduationcount", "totalResqueuresNum"], "prevTime": ["PrevSize", "PrevFile", "prevSize", " prevFile", "prevValue", " prevValue", "PrevValue", " prevSize", "prevFile", "commitValue", "commitFile", "PrevTime", "commitTime", "commitSize"], "fastaFileSize": ["fastasHeaderName", "fastaBlockLength", "fastaPageSize", "fastasFileName", "fastaHeaderSize", "fastaBlockSize", "fastasFileSize", "fastaFileAddress", "fastaFileCount", "fastABufferLength", "fastAFileAddress", "fastaBufferSize", "fastaFilesName", "fastaHeaderLength", "fastaFilesAddress", "fastaFilesSize", "fastaLineAddress", "fastaBufferAddress", "fastasHeaderAddress", "fastABufferSize", "fastaLineCount", "fastaPageLength", "fastABufferAddress", "fastaFilesLength", "fastasHeaderLength", "fastaHeaderAddress", "fastaLineSize", "fastaBufferCount", "fastaHeaderName", "fastAFileLength", "fastasFileAddress", "fastaFileName", "fastaBlockAddress", "fastaFileLength", "fastasFileLength", "fastaLineLength", "fastasHeaderSize", "fastAFileCount", "fastAFileSize", "fastaPageAddress", "fastaBlockCount", "fastABufferCount", "fastaPageName", "fastaBufferLength"], "fastaFileReadOffset": ["fastaDirectoryReadOff", "fastaBufferReadoffset", "fastaFileWriteAmount", "fastaFilesWriteoffset", "fastaFilesReadLength", "fastaDirectoryWriteEntry", "fastaFileLoadOffset", "fastaDirectoryWriteOffset", "fastaDirectoryReadoffset", "fastaFileLengthoffset", "fastaFilesWriteOff", "fastaFilereadLength", "fastaFileWriteEntry", "fastaFileStartOff", "fastaFilereadoffset", "fastaFileLoadLength", "fastaFileStartOffset", "fastaFileLengthLength", "fastaBufferReadAmount", "fastaFileReadAmount", "fastaFileRunOffset", "fastaFilereadOff", "fastaFileReadoffset", "fastaFileStartoffset", "fastaFileRunoffset", "fastaFileWriteLength", "fastaFileLengthOff", "fastaFileLoadoffset", "fastaFilesReadoffset", "fastaFileReadOff", "fastaFileStartEntry", "fastaFileRunEntry", "fastaFileRunOff", "fastaBufferReadOffset", "fastaFilereadOffset", "fastaFileLengthAmount", "fastaFileWriteOffset", "fastaDirectoryReadEntry", "fastaDirectoryReadOffset", "fastaFileLengthOffset", "fastaFileReadLength", "fastaBufferReadLength", "fastaDirectoryWriteOff", "fastaDirectoryWriteoffset", "fastaFileReadEntry", "fastaBufferWriteOffset", "fastaFileLoadAmount", "fastaFileWriteoffset", "fastaBufferWriteAmount", "fastaFilesReadOffset", "fastaBufferWriteLength", "fastaBufferWriteoffset", "fastaFilesWriteOffset", "fastaFileWriteOff", "fastaFilesReadOff", "fastaFilesWriteLength"], "partitionStartOffset": ["partitionStopOrder", "partitionsStartRange", "partitionEndOrder", "partitionBufferOrder", "partitionsEndRange", "partitionEndRange", "partitionStopOffset", "partitionStopRange", "partitionsEndOffset", "partitionsEndOrder", "partitionsStartOff", "partitionStartOrder", "partitionBufferRange", "partitionsStartOrder", "partitionsStartOffset", "partitionStartRange", "partitionBufferOffset", "partitionStartOff", "partitionEndOff", "partitionsEndOff", "partitionBufferOff", "partitionStopOff"], "bufferSize": ["BufferCount", "BufferType", "BufferSize", "processC", "bufferSIZE", " bufferType", " bufferC", "processSize", " bufferCount", "BufferSIZE", "bufferCount", "queueCount", "processType", " bufferSIZE", "bufferType", "BufferC", "bufferC", "processSIZE", "queueSize"], "fastaBuffer": ["fastaPtr", "fastABuffer", "fastaBuff", "fastaQueue", " fastasFile", "FastaStream", " fastAFile", " fastasChannel", "fastanChannel", "FastasBuffer", "fastasBuff", "fastanBuffer", " fastasBuffer", "fastAPtr", "fastanQueue", "fastasContainer", "FastaBuff", "fastABuff", "fastaceChannel", "fastAContainer", "fastAChannel", "fastaContainer", "fastasStream", "fastAFile", "FastasStream", " fastaQueue", "fastasBuffer", "fastanStream", "fastasPtr", "FastasBuff", " fastAQueue", "fastaaPtr", " fastAChannel", "FastasChannel", "FastaPtr", "fastanContainer", "FastaBuffer", "fastaceBuff", "fastAQueue", "fastacePtr", "fastaceBuffer", " fastaBuff", "fastasChannel", "FastaChannel", " fastaContainer", "fastaaStream", " fastasContainer", "fastasFile", "FastasPtr", "fastanBuff", "fastaStream", "fastaaBuff", "fastasQueue", " fastABuff", "fastanFile", "fastanPtr", "fastaFile", " fastaFile", "fastaaBuffer", " fastABuffer"], "fastaReadState": ["fastaReaderMode", "fastasReaderState", "fastaReadingMode", "fastaFileState", "fastaReaderState", "fastasReaderstate", "fastaReadingstate", "fastaReadstate", "fastaReaderType", "fastaReadingType", "fastaReadingState", "fastasReaderType", "fastaReaderstate", "fastaFileType", "fastasReadType", "fastasReadstate", "fastaReadType", "fastasReadState", "fastaFileMode", "fastasReadMode", "fastasReaderMode", "fastaFilestate", "fastaReadMode"], "nBytes": ["numFrames", "pByte", "oParts", "NByte", "Nbytes", "lenFrames", "lenbytes", "nFiles", "nFrames", "NParts", " nFrames", "lenFiles", "NFiles", "nbytes", "numbytes", "obytes", "lenBytes", "numBytes", " nFiles", " nbytes", "oFiles", "pbytes", "oBytes", "pParts", " nParts", "nByte", "nParts", "numFiles", " nByte", "pBytes", "NBytes"]}}
{"id1": "6988216", "id2": "755203", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" runBasicConnect", "runRawQuery", " runSimpleConnect", " runBasicQuery", " runBasicSearch", " runSimpleFilter", " runClientSearch", " runClientFilter", "runSimpleConnect", "runSimpleFilter", "runSimpleSearch", " runSimpleQuery", " runBasicFilter", "runRawSearch", " runClientQuery", "runRawConnect", " runClientConnect", " runRawFilter", "runRawFilter", " runSimpleSearch", " runRawSearch", " runRawConnect", " runRawQuery", "runSimpleQuery"], "dummySource": ["puddyService", "dandySource", "dummyType", "dundleContent", "dellyService", "puddyType", "pummySite", "dumbContent", "dummyService", "dundleConfig", "duddyOrigin", "pummySource", "dumbSource", "puddySource", "dellySource", "daddyContent", " dumbSource", "puddyContent", "puddySourceFile", "pummyService", " dummyConfig", "puddySite", "dumbOrigin", "dummySourceFile", "dummySite", "daddySourceFile", "daddyService", "dundleOrigin", "dumbConfig", "duddySourceFile", "dandyClient", "duddyService", "dellyContent", "daddySource", " dumbOrigin", "duddyConfig", " dumbConfig", "pummyType", "duddySite", "duddyContent", "pummySourceFile", "puddyClient", "duddySource", " dummyOrigin", " dumbContent", "duddyType", "pummyContent", "dellyType", "dummyOrigin", "daddyClient", "dandySourceFile", "dummyClient", "daddyType", "dummyConfig", "pummyClient", "dandySite", "dundleSource", "duddyClient", "daddySite"], "os": ["ou", "o", "vs", "ops", "ls", "dos", "osi", "bos", "ox", "ns", "mos", "acs", "ms", "conn", "object", "pos", "obs", "ps", "ok", "ows", "op", "ds", "io", "ros", "om", "Os", "nos", "oss", "css", "out", "fs", "is", "cos", "as", "iso", "oS", "es", "oc", "ens", "us", "ori", "sys", "bs", "oa", "oses", "uns", "ose", "ol", "ios", "OS", "ss", "i", "ols", "oos", "ks", "or", "los", "aos", "s"], "dummyContent": ["DummyContent", "DuckyContent", "dummyReader", " dummyContents", "dellyContents", "dumperBody", "dumpingOutput", " dellycontent", " dummyOutput", "dumpingContent", "DummySource", "duddyReader", "DuckyBody", "dumperContent", "dumperSource", "dumpercontent", "dumpingContents", "DummyBody", "duckyReader", "dellyContent", "dumperContents", " dellyOutput", "dummyBody", " dellyContent", "duckySource", "duckyContent", "dummyContents", "dummyOutput", " dellyContents", "duddyContent", "dumpingcontent", "dumperOutput", "duddyBody", " dummycontent", "dummycontent", "duddySource", "DuckyReader", "dumperReader", "DummyReader", "dellyOutput", "DuckySource", "duckyBody", "dellycontent"], "source": ["resources", "unit", "slave", "service", "resource", "SOURCE", "site", "storage", "stream", "Source", "target", "channel", "src", "text", "cache", "sync", "use", "info", "object", "scope", "ources", "string", "class", "element", "core", "sn", "node", "sc", "ource", "result", "uri", " Source", "sin", "client", "secure", "cos", "size", "proxy", "search", "host", "seed", "e", "ser", "sl", "reader", "i", " sources", "connection", "config", "parent", "url", "s"], "content": ["body", "image", "model", "sol", "html", "service", "resource", "Content", "child", "feed", "comments", "cont", "current", "transform", "input", "children", "target", "match", "version", "text", "load", "cms", "message", "output", "music", "media", "update", "code", "news", "result", "css", "response", "xml", "cos", "size", "expression", "report", "title", "clean", "host", "data", "server", "document", "header", "value", "description", "activity", "comment", "config", "url", "cover", "address"], "qResult": ["qResponse", " qresult", "qresult", "kResults", "QFilter", "iqResults", "kresult", "qSource", "rSource", "rResult", "kResult", "kFilter", "queryResponse", "kRes", "queryRes", "qResults", "kReturn", "QResult", " qResponse", "iqResponse", "QReturn", "queryResult", "querySource", "qRes", "rresult", "qReturn", "iqResult", "queryReturn", "qFilter", "queryFilter", "queryResults", "queryresult", " qResults", "rRes", "kSource", "iqresult", "QResults"], "results": ["resources", "its", "versions", "objects", "errors", "shows", "children", "runs", "lines", "ids", "RESULTS", "details", "vers", "events", "blocks", "tests", "files", "collection", "rows", "groups", "successful", "ions", "result", "items", "response", "values", "qs", "reports", "users", "members", "ins", "models", "features", "docs", "pages", "data", "ries", "res", "Results", "s"], "it": ["IT", "its", "in", "ited", "rit", "lit", "which", "entry", "edit", "slice", "mit", "list", "l", "info", "itted", "pit", "r", "t", "ic", "not", "split", "ati", "ait", "op", "p", "ci", "ort", "si", "stat", "v", "and", "ip", "sit", "ins", "ite", "init", "iti", "the", "ITS", "id", " It", "It", "i", "iter", "or", "you"], "rSrc": ["rAsource", "rDssrc", "rPsource", " rEsource", "rIsRC", " rSsrc", "RSrc", "rEsource", "rIsrec", "rEssrc", " rEsRC", "rAssrc", " rDsource", "rPsRC", "rSource", "rAsrec", " rSource", "rAsrc", "rEsRC", "rSrec", "RIsRC", "RIsrec", "rAsRC", "RIsrc", "RIsource", "rPsrc", "rDsRC", "RSource", "rDsrc", "RSrec", " rSRC", "rEsrc", " rDsrc", "rSRC", "rPssrc", " rDssrc", "rIsrc", " rEsrc", "rIsource", "rDsource", "RSRC", "rSsrc", " rEssrc", " rDsRC"], "rSrcIn": ["rSvcin", "rAsRCIn", "rAsRCOut", "rCsrcOut", "rSRCIn", "rCrcin", "rAsrcOut", "rCRCIn", "rSvcIns", "rSourceOut", "rSourceIn", "rCrcIns", "rSvcIN", "rCrcIN", "rCrcOut", "rSrcOut", "rSRCIN", "rCRCOut", "rCsrcIn", "rCrcIn", "rSrcin", "rSrcIns", "rCRCIns", "rSRCOut", "rAsrcIn", "rSourceIns", "rSvcIn", "rSourcein", "rSsrcin", "rSrcIN", "rSsrcOut", "rSvcOut", "rSsrcIn", "rAsrcin", "rCsrcIN", "rCsrcin", "rAsRCin", "rSsrcIN", "rSRCIns", "rSRCin"], "actualOut": ["realout", " actualBridge", "eventout", "actualIn", "nexpectedOut", "assertOut", " actualout", "assertIn", "operatorout", "eventOUT", "actualOutput", "actualOUT", " ActualBridge", "realWin", " ActualOUT", "illegalOutput", " actualOutput", "illegalOUT", "illegalOut", " ActualOut", " actualOUT", "illegalIn", "publicOut", "operatorIn", "actualout", "operatorOUT", "eventOut", "actualWin", " ActualIn", "realOut", "nexpectedIn", "publicIn", "assertOUT", "nexpectedWin", "eventIn", "assertBridge", "operatorOut", " actualWin", " actualIn", "nexpectedout", "realIn", "publicOUT", "publicOutput", "actualBridge"]}}
{"id1": "1180878", "id2": "720361", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        int result = 20;\n        if (args.length == 1) {\n            StringBuffer urlString = new StringBuffer(args[0]);\n            if (urlString.lastIndexOf(\"/\") != urlString.length() - 1) {\n                urlString.append('/');\n            }\n            urlString.append(\"GetConfig.jsp\");\n            URLConnection conn = new URL(urlString.toString()).openConnection();\n            System.out.println(Configuration.readObject(conn.getInputStream()));\n            result = 0;\n        } else {\n            System.err.println(\"usage: GetConfig <URL>\");\n        }\n        System.exit(result);\n    }\n", "label": 0, "substitutes": {"fetchURLData": ["frieveUrldata", "fetchURLDATA", "frieveURLDATA", "fetchJSONData", "frieveUrlDATA", "fetchHTTPDATA", "fetchUrldata", "fetchURLdata", "fetchUrlDATA", "frieveURLdata", "fetchHTTPdata", "fetchUrlData", "frieveURLData", "fetchHTTPData", "fetchJSONdata", "fetchJSONDATA", "frieveUrlData"], "url": ["image", "html", "URL", "base", "resource", "feed", "www", "view", "download", "Url", "ls", "http", "text", "src", "filename", "l", "href", "api", "page", "string", "path", "fl", "source", "uri", "xml", "ur", "name", "location", "ssl", "server", "data", "file", "user", "gl", "username", "sl", "el", "connection", "loc", "host", "f", "address"], "proxyHost": ["cacheHost", " proxyServer", "serverAddress", "serverPath", " proxyAddress", "baseHost", "baseDomain", "remoteAddress", "proxyHead", "baseAddress", "ProxyHead", "remoteDomain", "ProxyHost", " proxyPath", "proxyhost", "serverServer", " proxyhost", "proxyDomain", "baseHead", "ProxyDomain", "ProxyServer", "cachePort", "proxyPath", "remoteHead", "ProxyPath", "proxyAddress", "proxyServer", "cachehost", "cacheAddress", "ProxyPort", "ProxyAddress", "remoteHost", "Proxyhost", "serverHost"], "proxyPort": ["cacheHost", " proxyServer", " proxyport", " proxyAddress", "httpPort", "ProxyHost", "httpServer", "httpAddress", "cachePort", "Proxyport", "ProxyServer", "cacheport", "proxyAddress", "proxyServer", "proxyport", "cacheAddress", "ProxyPort", "ProxyAddress", "httpHost"], "con": ["com", "fa", "ls", "rec", "ch", "c", "cf", "rc", "ci", "per", "uc", "connection", "cr", "f", "login", "cl", "pc", "cur", "ca", "cache", "run", "sync", "conn", "CON", "ran", "co", "ocon", "cone", "connect", "go", "win", "re", "conv", "change", "sub", "fac", "fun", "don", "common", "pre", "cons", "fc", "remote", "un", "an", "x", "out", "xc", "Con", "pub", "cn", "on", "gen", "mc", "cp", "ec", "inc", "exec", "conf", "socket", "ver", "canon", "func", "can", "syn", "open", "pen", "ctrl", "http", "act", "pin", "fl", "en", "part", "ai", "min", "cc", "cas", "close", "cm", "ac", "n", "bc", "fan"], "is": ["ib", "its", "in", "can", "serv", "isi", "vs", "abs", "ops", "mis", "cms", "ir", "lis", "has", "does", "api", "info", "conn", "isu", "ws", "IS", "js", "ri", "act", "sp", "state", "ps", "was", "ie", "p", "ci", "ris", "si", "os", "it", "cs", "oss", "ai", "out", "isa", "isl", "fs", "iss", "cos", "il", "as", "es", "iso", "are", "bis", "us", "ori", "bs", "isin", "id", "isc", "ios", "Is", "i", "im", "get", "ais", "or", "ar", "iris", "ics", "s"], "u": ["ou", "o", "q", "U", "ul", "up", "ue", "http", "cu", "ut", "l", "un", "b", "ui", "uv", "api", "conn", "uci", "c", "m", "p", "io", "su", "uri", "os", "v", "client", "hu", "fu", "ur", "nu", "us", "h", "user", "file", "yu", "tu", "iu", "i", "uc", "ru", "lu", "f"], "proxy": ["force", "pool", "resource", "create", "clone", "phone", "pc", "fe", "http", "zip", "cache", "cop", " Proxy", "l", "api", "remote", "prot", "XY", "c", "pe", "pin", "Proxy", "pa", "plus", "p", "type", "xy", "uri", "x", "roxy", "ip", "client", "pse", "ssl", "bean", "wrapper", "server", "shadow", "port", "timeout", " proxies", "lib", "connection", "config", "host", "web", "f", "socket", "copy", "address"], "baos": ["abis", "baOS", "caas", "caos", "haOS", "bao", "bais", "BAOS", "BAos", "BAis", "pao", "boOS", "hao", "BaOs", "Baos", "boas", "haos", "calos", "caOS", "paOS", "Bais", "balos", "paos", "baas", "boos", "abOs", "abros", "BAo", "baOs", "aas", "bolos", "Baros", "pais", "hais", "alos", "baros", "BAOs", "aos", "aOS", "abos", "BAros"]}}
{"id1": "17111859", "id2": "11005804", "code1": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"getHash": ["buildhash", "gethash", "getHTML", " gethash", " getSalt", "Gethash", "GetHash", "buildHTML", "buildHash", "buildSalt", "GetHTML", "GetSalt", "getSalt", " getHTML"], "string": ["in", "resource", "address", "section", "prefix", "this", "content", "sequence", "format", "duration", "input", "version", "text", "message", "cache", "slice", "filename", "password", "STR", "object", "null", "array", "hash", "buffer", "p", "source", "uri", "number", "name", "word", "ring", "server", "data", "file", "reference", "value", "database", "time", "strings", "s"], "hashTime": ["HashTimer", " hashFunction", "versionTime", "hexTime", "versionTimer", " hashTrack", "versionFunction", " hashtime", "HashTrack", "versiontime", "HashFunction", "hexTrack", "hashCheck", " hashTimer", "hashTimer", "hashFunction", "Hashtime", " hashCheck", "hexTimer", "hashTrack", "HashTime", "HashCheck", "hashtime", "hexCheck"], "md5": ["hash5", "mand5", "digdown", " mdql", "mandql", "hash2", "md6", "digb", "MD53", "MD5", "sha2", "mdkey", " md53", "sha5", "md512", " md6", "digql", "MDol", "mad5", " md512", "hashol", "md2", "mddown", "MDkey", " mdse", " md2", "shab", "mdql", "md25", "dig2", "mdol", "mdse", "mad2", "madse", "mand25", "mdb", "sha6", "dig6", "madkey", " md3", "dig25", " mdkey", "MD2", "dig512", "mand2", "MD3", " md25", " mdb", " mdol", "hash53", "dig5", "mad3", " mddown", "maddown", "digse", "mad512", "md3", "md53"], "result": ["err", "section", "Result", "found", "prefix", "hex", "current", "format", "function", "json", "expected", "match", "entry", "message", "list", "page", "product", "array", "hash", "r", "buffer", "work", "success", "part", "uri", "diff", "number", "response", "character", "length", "digit", "test", "word", "search", "data", "range", "valid", "card", "error", "comment", "feature", "value", "results", "res", "default", "source", "dict"], "hexString": [" hexstring", "tempString", "packstring", "hashArray", "packArray", "hashString", "hexStr", "rexString", "tempstring", "packStr", "rexstring", "exArray", "tempBuffer", "exBuffer", "exString", " hexStr", "packString", "hexBuffer", "exstring", "rawBuffer", "hashBuffer", "rawstring", " hexArray", "hexstring", "hexArray", "rexArray", "tempArray", "rawString", " hexBuffer", "hashstring", "rawArray", "rexStr"], "i": ["index", "j", "o", "in", "oi", "end", "phi", "ii", "fi", "ix", "slice", "l", "b", "ui", "ri", "code", "c", "pi", "gi", "abi", "d", "li", "k", "ci", "p", "multi", "si", "xi", "io", "uri", "bi", "v", "x", "ai", "ip", "length", "start", "a", "h", "ti", "id", "data", "qi", "e", "u", "f", "di", "m", "I", "zi", "s"], "str": ["enc", "err", "fr", "val", "input", "entry", "obj", "text", "output", "key", "STR", "pr", "url", "code", "c", "sp", "r", "buffer", "pass", "t", "tr", "st", "p", "uri", "x", "out", "name", "sr", "data", "id", "char", "e", "Str", "sl", "res", "br", "source", "f", "s"]}}
{"id1": "15737836", "id2": "8046691", "code1": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "code2": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"delete": ["de", "create", "del", "write", "process", "sync", "replace", "update", "clear", "sql", " Delete", "drop", "remove", "destroy", "where", "close", "execute", "id", " destroy", "Delete", "connect", " update", "get", " create", "select", "exec", "release", "save"], "site": ["image", "model", "unit", "base", "isite", "module", "section", "course", "sample", "project", "domain", "install", "target", "profile", "license", "cache", "sync", "remote", "environment", "conn", "space", "object", "page", "null", "set", "sql", "class", "status", "session", "item", "node", "note", "source", "type", "line", "result", "si", "se", "network", "blog", "sit", "xml", "ite", "edge", "Site", "name", "zone", "server", "data", "sites", " Site", "theme", "database", "config", "location", "db", "plugin"], "dbo": ["dho", "idebo", "jBo", "jba", " dBo", "fbo", " dBO", "dbi", "gBO", " dbi", "fBo", "gbo", "ideho", "Dbo", "drbi", "dbos", "drbc", "jBO", "drBo", " dbc", "idbl", "fBO", "dBO", "rdbi", "dbl", "pBO", "pba", "DBO", "gbos", " dba", "pBo", "idebl", "Dbos", "rdbc", "Dho", "Dbl", "dBo", "dbc", "ideBo", "rdBo", "fba", "idBo", " dbos", "jbo", "dba", "idbo", "Dba", "idho", "pbo", "drbo", "DBo", "rdbo", "gBo"], "connection": ["image", "unit", "index", "pool", "graph", "resource", "log", "section", "ion", "directory", "function", "channel", "Connection", "cache", "use", "table", "environment", "conn", "ongo", "connected", "management", "application", "builder", "driver", "c", "sql", "position", "condition", "engine", "session", "creator", "collection", "relation", "subject", "query", "node", "handler", "ci", "translation", "result", "io", "container", "response", "client", "character", "context", "manager", "statement", "communication", "con", "loc", "union", "server", "component", "document", "reference", "connect", "instance", "lock", "database", "bc", "ctx", "config", "db", "machine", "library"], "preparedStatement": ["prefixedHeader", "PreparedTransaction", "proparableStat", "prehedScope", "PreparedDocument", "previsedComment", "prepperConnection", "prequalifiedStat", "preciseStat", "eculatedstatement", "proparableStatement", "preppedTransaction", "PrearedService", "preppedComment", "preutedHeader", "preferredString", "partvisedStatement", "proparedStat", "preachedString", "preparableStat", "preformedTransaction", "preparedComment", "preparedInstance", "prefixedComment", "preculatedStatement", "preplacedQuery", "preformedString", "prearedScope", "eculatedTransaction", "preferredComment", "preplacedStat", "prefixedStatement", "preppedQuery", "preppedConnection", "PreparedParent", "prearedString", "psefixedScope", "prepperTransaction", "psefixedStatement", "pseparedComment", "preparedParent", "preparedHeader", "eparedStatement", "preamedString", "eparedConfiguration", "PreparedStatement", "preparableInstance", "preparedDatabase", "preciseStatement", "prequalifiedstatement", "partvisedQuery", "prelyingstatement", "preppedDocument", "prepperDocument", "preparedConnection", "caparedTransaction", "preamedStatement", "preparedOperation", "preparedDocument", "previousComment", "preparedConfiguration", "prefixedOperation", "partparedComment", "PreppedConnection", "eparedTransaction", "psefixedQuery", "preplacedComment", "prehedStatement", "pseparedQuery", "prearedService", "eparedstatement", "preachedDatabase", "partvisedComment", "PrearedString", "preferredStatement", "partparedStatement", "preparedTransaction", "prearedComment", "preamedStat", "PrearedStatement", "prehedComment", "preparedstatement", "proparedStatement", "preculatedTransaction", "PreparedDatabase", "PrearedQuery", "PreppedTransaction", "pseparedScope", "prefixedQuery", "PrearedHeader", "prefixedScope", "PrearedParent", "preciseString", "previsedStatement", "preparedScope", "preferredQuery", "proparedstatement", "PreparedQuery", "partparedQuery", "PreparedOperation", "prearedInstance", "preciseParent", "preplacedStatement", "prearedstatement", "eculatedConfiguration", "calyingTransaction", "preformedService", "preutedQuery", "preformedDatabase", "partparedStat", "preformedStatement", "prehedQuery", "prearedDatabase", "preppedString", "psefixedComment", "prepperStatement", "preppedStatement", "PreparedConnection", "proparableInstance", "prearedStatement", "previousTransaction", "PreparedStat", "prelyingComment", "prearedOperation", "preformedConfiguration", "previousstatement", "PreppedStatement", "prequalifiedStatement", "PrearedDatabase", "preutedStatement", "caparedStatement", "caparedstatement", "preachedStatement", "preamedParent", "PreparedService", "partvisedStat", "proparedInstance", "previousDocument", "preparedString", "preachedService", "previousConnection", "preparablestatement", "prearedStat", "prearedConfiguration", "preparedService", "PrearedStat", "previousStatement", "eculatedStatement", "prearedQuery", "preparedStat", "preculatedConfiguration", "caparedComment", "PreparedComment", "previsedQuery", "pseparedStatement", "calyingComment", "prelyingTransaction", "proparablestatement", "preparedQuery", "PreparedHeader", "PrearedOperation", "prearedParent", "prelyingStatement", "prearedHeader", "PreppedDocument", "preculatedstatement", "prequalifiedInstance", "preutedOperation", "preparableStatement", "PrearedComment", "previsedStat", "prearedTransaction", "calyingStatement", "calyingstatement", "PreparedString", "preformedstatement"], "resultSet": [" resultList", "ResultSource", " resultLine", "resultSource", " resultSource", "resultsLine", "resultGet", "ResultLine", "rowSet", "responseList", "rowSize", "ResultSize", "responseLine", "resultLine", "resultsSource", "ResultGet", "rowSource", "resultsSet", "responseSource", "ResultList", "rowGet", "ResultSet", "responseSet", " resultSize", "resultList", "resultSize", "resultsList", " resultGet"], "chkSql": ["chkPssql", "chksAsq", "chksAsql", "chksAsQL", "chKSsql", "chkPsq", "chkSQL", "chkPresql", "chkOsq", "chkOsql", "chkOssl", "chKSql", "chkRssql", "chksSql", "chkPresQL", "chkPsql", "chKRsq", "chkAsq", "chkSq", "chkRssl", "chkOsQL", "chkPressql", "chKSq", "chksSsql", "chkSsl", "chkOssql", "chkPssl", "chkRsql", "chKSsl", "chkAsQL", "chKRsql", "chksSQL", "chKRssl", "chkPresq", "chKRssql", "chksAssql", "chkSsql", "chkRsq", "chksSq", "chkAsql", "chkAssql"], "selfDefinePath": ["selfDefinedpath", "selfDefinesKey", "selfDeclinedpath", "selfDefenPath", "selfDefinedName", "selfDefineKey", "selfDefiningPath", "selfDeclineKey", "selfDefinedLocation", "selfDeclinepath", "selfDefinespath", "selfDeclineUrl", "selfDefenName", "selfDefinesPath", "selfDeclinedUrl", "selfDefineLocation", "selfDeclinedKey", "selfDefinesName", "selfDefinedKey", "selfDefiningKey", "selfDefinepath", "selfDefinedUrl", "selfDefenLocation", "selfDefiningUrl", "selfDeclinePath", "selfDefinesUrl", "selfDefineUrl", "selfDefinesLocation", "selfDefinedPath", "selfDefenpath", "selfDefiningpath", "selfDeclinedPath", "selfDefineName"], "sqlStr": [" sqlString", " sqlDec", "sqlString", "sqlDec", "sqlBr", "sqlText", "queryText", "SQLBr", "querystr", "SQLText", "SQLDec", "SQLWr", "sqlWr", "qlString", "SQLstr", "queryDec", "SQLStr", "sqlstr", "qlStr", " sqlText", " sqlWr", "SQLString", " sqlstr", "qlBr", "qlWr", " sqlBr", "queryStr"]}}
{"id1": "10131427", "id2": "1421557", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", "CopyChannel", "transferFile", "CopyFile", " copyfile", "Copyfile", " copyChannel", "copyFiles", "copyfile", "CopyFiles", "transferChannel", "copyChannel"], "in": ["ini", "image", "index", "base", "login", "resource", "config", "inner", "inn", "input", "In", "at", "bin", "b", "c", "IN", "buffer", "again", "work", "source", "io", "diff", "min", "ins", "name", "a", "ac", "id", "file", "data", "ex", "i", "reader", "or", "m", "inc", "url", "copy"], "out": ["image", "base", "o", "temp", "prefix", "point", "w", "at", "target", "cache", "output", "OUT", "writer", "conn", "object", "string", "c", "external", "buffer", "outs", "p", "part", "io", "v", "x", "dest", "Out", "client", "off", "name", "data", "file", "ex", "n", "connection", "source", "exec", "copy"], "sourceChannel": ["SourceStream", " sourceStream", "SourceChannel", "sourceQueue", " sourceManager", "srcManager", "srcStream", "targetchannel", "Sourcechannel", " sourceConnection", "SourceChan", "sourcechannel", "targetStream", "ourcechannel", "srcSocket", " sourceSocket", " sourcechannel", "ourceChannel", "srcChan", "sourceSocket", "targetChan", "sourceChan", "srcQueue", "SourceManager", "ourceStream", "sourceManager", " sourceQueue", "sourceConnection", " sourceChan", "targetChannel", "SourceQueue", "srcChannel", "SourceConnection", "ourceChan", "SourceSocket", "srcConnection", "sourceStream"], "destinationChannel": ["destationCh", "Destinationchannel", "DestinatorChannel", "destinationchannel", "DestinatorChan", "destinationsStream", "destinationsChannel", "destinationConnection", "destinationChan", "DestinationConnection", "DestinatorStream", "destinatorCh", "destationchannel", "DestinationCh", "DestinationChannel", "destinatorConnection", "destationConnection", "destinateChannel", "destationChannel", "destinatorStream", "Destinatorchannel", "destinatorchannel", "destinateStream", "destinatedCh", "destinationCh", "DestinatorCh", "destinatorChan", "destinatedChan", "destinationStream", "destinationsConnection", "destinatedChannel", "DestinationStream", "destinatechannel", "destinateConnection", "destinatorChannel", "destationChan", "DestinationChan", "DestinatorConnection", "destinatedConnection", "destinationschannel"]}}
{"id1": "1362", "id2": "15822137", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public TableDirectory(RandomAccessFile raf) throws IOException {\n        version = raf.readInt();\n        numTables = raf.readShort();\n        searchRange = raf.readShort();\n        entrySelector = raf.readShort();\n        rangeShift = raf.readShort();\n        entries = new DirectoryEntry[numTables];\n        for (int i = 0; i < numTables; i++) {\n            entries[i] = new DirectoryEntry(raf);\n        }\n        boolean modified = true;\n        while (modified) {\n            modified = false;\n            for (int i = 0; i < numTables - 1; i++) {\n                if (entries[i].getOffset() > entries[i + 1].getOffset()) {\n                    DirectoryEntry temp = entries[i];\n                    entries[i] = entries[i + 1];\n                    entries[i + 1] = temp;\n                    modified = true;\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"bubbleSort": ["bubbleOrder", "bubblingsort", "bubblingSort", "bubblerCompare", "ubbleOrder", "ubblingOrder", "bubblerSort", "bubblessort", "bubblesSort", "ubblingsort", "ubblingCompare", "bubblingCompare", "bubblerOrder", "bubbleCompare", "ubbleSort", "ubblingSort", "ubblesort", "bubblesort", "ubbleCompare", "bubblingOrder", "bubblesCompare", "bubblesOrder", "bubblersort"], "a": ["aj", "aw", "index", "o", "address", "ga", "tta", "am", "ba", "ans", "abs", "ama", "ma", "aux", "sa", "at", "active", "another", "alpha", "area", "A", "something", "b", "l", "auto", "sup", "list", "array", "c", "apps", "aa", "ack", "access", "au", "d", "work", "m", "p", "ad", "result", "an", "all", "img", "va", "na", "any", "as", "la", "ae", "ac", "data", "oa", "e", "u", "empty", "ata", "f", "aaa", "ab", "s"], "swapped": ["rewapping", "swoped", "swapping", "swaped", " swapping", "rewapped", " swaps", "wapping", " swap", "wapped", "flapped", "swap", "flap", "flapping", " swaped", "floped", "Swap", "rewoped", "waps", "rewaps", "Swapping", "Swapped", "swaps", "waped", "Swaped", "rewap", "Swoped", "rewaped", "wap"], "i": ["ini", "mi", "index", "j", "in", "io", "oi", "module", "anti", "hi", "ii", "ix", "mini", "fi", "key", "l", "b", "api", "ui", "info", "sup", "ami", "iv", "ri", "pi", "gi", "next", "d", "li", "ind", "k", "ci", "p", "ie", "uni", "multi", "si", "xi", "ni", "I", "bi", "v", "x", "ai", "uri", "it", "y", "eni", "ip", "adi", "start", "init", "ori", "h", "ti", "qi", "id", "e", "iu", "u", "di", "m", "ki", "f"], "tmp": ["mmm", "j", "nb", "foo", "temp", "tt", "xxx", "vt", "yy", "pre", "tv", "alpha", "qq", "area", "b", "bb", "mp", "sup", "pad", "txt", "kk", "pp", "front", "amp", "t", "st", "ie", "p", "part", "cmp", "v", "x", "addr", "dest", "prev", "emp", "test", "tc", "opp", "append", "angle", "stuff", " ff", "m", "f", "obj"]}}
{"id1": "13333160", "id2": "14317425", "code1": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"run": ["module", "submit", "config", "render", "edit", "process", "Main", "update", "read", "apply", "running", "work", "doc", "uri", "evaluate", "loop", "Test", "man", "report", "test", "Process", "runner", "Run", "execute", "exec"], "xmlIn": ["xmlin", "xmlSource", "phpReader", "jsonOut", "inputIns", "mlIns", "jsonReader", "phpSource", "mlIn", "mlOut", "jsonSource", "phpOut", "jsonIn", " xmlin", " xmlIns", "xmlReader", "xmlOut", " xmlReader", "mlin", "phpIn", "inputin", " xmlSource", "inputOut", "xmlIns", "inputIn", " xmlOut"], "out": ["err", "log", "in", "resource", "temp", "prefix", "w", "write", "project", "window", "up", "cache", "output", "OUT", "table", "writer", "bin", "list", "page", "builder", "string", "external", "buffer", "again", "outs", "doc", "io", "result", "dest", "Out", "client", "report", "name", "dump", "server", "file", "ex", "timeout", "res", "connection", "source", "parent"], "dom": ["com", "ver", "html", "base", "dr", "fr", "Dom", "form", "domain", "bot", "hub", "up", "http", "parser", "ch", "home", "builder", "c", "d", "node", "doc", "p", "div", "result", "om", "frame", "df", "img", "DOM", "bug", "xml", "cm", "tree", "h", "live", "nav", "document", "valid", "browser", "dm", "m", "host", "db", "url"], "f": ["Factory", "o", "fr", "fac", "fa", "inf", "w", "fm", "F", "function", "fe", "aff", "http", "fc", "l", "full", "raf", "fab", "c", "cf", "rf", "def", "g", "fd", "t", "fb", "d", "p", "conf", "v", "df", "x", "fp", "fs", "fx", "framework", "tf", "h", "af", "e", "sf", "u", "i", "bf", "m", "s"], "b": ["body", "ib", "base", "br", "ba", "abs", "xb", "Builder", "l", "bb", "builder", "c", "gb", "r", "abb", "bel", "lib", "fb", "d", "be", "lb", "bd", "p", "sb", "v", "build", "B", "orb", "bt", "library", "bar", "h", "bs", "ob", "e", "rb", "bc", "bf", "m", "db", "ab", "s"], "root": ["Dom", "rec", "page", "leaf", "null", "element", "c", "ok", "p", "div", "result", "xml", "article", "Element", "nav", "component", "Supported", "m", "host", "parent", "cover", "html", "child", "found", "this", "Root", "ow", " Root", " Dom", "builder", "string", "r", "core", "supported", " allowed", "legal", "doc", "allow", "allowed", "tree", " Document", "document", "ax", " DOM", "loc", "right", "parse", "master", "Node", "home", "path", "node", "container", "attr", "af", "rss", "default", "obj", "Doc", "ver", " rooted", "transform", "head", "parser", " empty", "writer", " node", "rew", "author", "Valid", "DOM", "Document", "h", "valid", "e", "false", " correct", "url", "owner"], "att": ["aj", "_", "apt", "html", "nat", "nt", "tt", "lit", "utt", "arr", "ht", "art", "av", "at", "text", " ax", "annot", "attach", "cat", "ann", "struct", "mat", "ct", "ack", "atts", "t", "ATT", "ant", "attribute", "aut", "attr", "ai", "ott", " attribute", " Att", "rs", "Attribute", "name", "app", "ac", "Att", "alt", "Info", "adj", "str", " html", "acc", "Attributes", "obj"], "menu": ["image", "video", "resource", "module", "site", "view", "ul", "group", "license", "cache", "cu", "queue", "list", "info", "ui", "page", "gi", "item", "query", "li", "m", "gui", "doc", " menus", "uni", "container", "uri", "v", "command", "Menu", "manager", "us", "nav", "server", "user", "cal", "layout", "category", "u", "theme", "i", "wiki", "config", "parent", "plugin"], "id": ["action", "end", "alias", "rid", "target", "version", "ids", "key", "href", "info", "class", "code", "option", "path", "pid", "ID", "oid", "prop", "start", "name", "sid", "mid", "title", "data", "category", "tag"], "zout": ["azOut", "zenunk", "zconn", "zhagain", "zipOut", "azout", " zagain", "Zobject", "zenagain", "zipagain", "zOut", "azagain", "ezconn", "jin", " zconn", "azzip", "zhouter", "zOUT", "zeagain", "ezouter", "ZOut", "ldagain", "zenzip", "ezio", "Zin", "gzout", "ldOut", "zipio", "zunk", "Zio", "zendiff", "gzin", "zio", "zeout", " zio", "zinner", " zOut", " zin", "zeOut", "ezdiff", "zipin", "gzOUT", "zouter", "ezobject", "zeninner", "ezinner", " zdiff", " zunk", "ldout", "zenOut", "zdiff", "zhinner", "zagain", "jio", "zenouter", "gzagain", "ezagain", "zzip", " zzip", "zenin", "ldOUT", "ezOut", "ezin", "zobject", "ZOUT", "jout", "zeconn", "Zagain", "jobject", "zin", "zenout", "azOUT", "ezunk", "zhout", "zipout", "Zout", "zipOUT", "ezout"], "content": ["model", "resource", "create", "temp", "current", "full", "page", "null", "status", "job", "context", "ontent", "xml", "expression", "search", "file", "const", "value", "time", "connection", "host", "parent", "body", "lc", "child", "cont", "continue", "children", "cache", "ca", "output", "column", "password", "music", "conn", "string", "code", "example", "fill", "response", "handle", "character", "size", "language", "server", "document", "activity", "help", "header", "Content", "script", "version", "text", "process", "update", "left", "path", "gc", "x", " Content", "ce", "ext", "request", "data", "empty", "default", "location", "exec", "address", "image", "section", "gray", "load", "message", "media", "work", "prev", "cm", "title", "word", "wrapper", "complete", "config", "url"], "signal": ["signaled", "ignale", "SIGNale", "signale", "SIGNig", "seal", "mental", "seature", "signals", "Signaled", "signature", "SignAL", "mentig", " signature", "Signal", "SIGNal", "signig", "ignature", "ignal", " signals", "signAL", "ignaled", " signaled", "Signale", "sealed", "mentature", "ignAL", "mentaled", "SIGNature", "seig", "Signig", "Signals", "ignals", "ignig", "Signature", " signig", " signAL"], "n": ["z", "num", "index", "nb", "j", "o", "nor", "nl", "N", "inn", "none", "net", "ns", "ne", "l", "un", "conn", "c", "r", "g", "sn", "norm", "t", "d", "node", "not", "k", "en", "p", "ni", "eni", "nn", "len", "nr", "v", "x", "y", "all", "size", "h", "fn", "e", "adj", "u", "i", "ng", "m", "s"], "entry": ["lc", "letter", "de", "her", "in", "module", "nt", "feed", "system", "child", "this", "inner", "event", "je", "ry", "channel", "zip", "Entry", "parser", "add", "info", "auto", "string", "element", "r", "cel", "next", "record", "ent", "se", "row", " Entry", "archive", "server", "data", "file", "ries", "cell", "e", "no", "reader", "per", "enter", "or", "obj"], "pout": ["pconn", "pOut", "pouter", "lpnet", "patchio", " pOut", "Pin", " pouter", " pnet", "pwriter", "lpout", " pwriter", "pnet", "Pn", "patchout", "patchin", "ppio", "cpout", " pio", " pagain", "print", "prin", "zOut", "pin", "zin", "POut", " pn", "ppnet", " pint", "ppin", "cpio", "prout", "cpconn", "pint", " pconn", "Pwriter", "ppagain", "ppconn", "pn", "prwriter", "pagain", "lpio", "Pio", "Pout", " pin", "Pouter", "cpagain", "Pint", "zouter", "pio", "patchn", "ppout", "lpin"]}}
{"id1": "18489832", "id2": "18748516", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"downLoadZippedFile": [" doLoadZedFile", " doLoadZaggedContent", " doLoadZippingFile", " doLoadZippingFiles", " doLoadzippingFiles", " doLoadZippedFile", " doLoadZippedContent", " doLoadZaggedFile", " doLoadZaggedFiles", " doLoadZedContent", " doLoadzippedFile", " doLoadZippedFiles", " doLoadZippingDir", " doLoadzippingDir", " doLoadZedFiles", " doLoadzippingFile", " doLoadZippingContent", " doLoadZedDir", " doLoadzippingContent", " doLoadzippedContent", " doLoadZaggedDir", " doLoadzippedFiles", " doLoadzippedDir", " doLoadZippedDir"], "url": ["image", "link", "log", "URL", "base", "lr", "resource", "event", "download", "Url", "open", "http", "zip", "l", "b", "page", "update", "c", "lib", "r", "store", "route", "uri", "pull", "client", "bug", "ur", "loader", "ssl", "proxy", "server", "file", "ll", "sl", "i", "or", "connection", "config", "source", "web", "f"], "destDir": ["tempFolder", "tempFile", "DestFile", "destFile", "outputFolder", "tmpDirectory", "outputDir", "destFolder", "destDirectory", "tempDir", "tmpdir", "destdir", " destdir", "outputDIR", " destDIR", "DestDIR", "tmpDir", "outputdir", " destFile", "tempDIR", "destDIR", "DestDir", "tmpDIR", " destDirectory", " destFolder", "outputDirectory", "DestFolder", "outputFile"], "urlConnection": ["fileFactory", "URLConnect", "httpConnection", "URLConnection", "webConnection", " urlChannel", "downloadConn", "urlNetwork", "URLconnection", "httpFactory", "webChannel", "URLChannel", "fileConn", "urlconnection", "urlFactory", "httpConn", "webConnect", "httpNetwork", "urlConn", " urlConnect", "webconnection", "downloadFactory", "downloadConnection", " urlconnection", "fileNetwork", "urlConnect", "urlChannel", "fileConnection", "downloadNetwork"], "tmpFile": ["tempFile", "destFile", "tempLine", "mpFile", "tmpFiles", " tmpFolder", " tmpLine", "tempfile", "mpPath", "mpFiles", " tmpDir", "TempPath", "tmpWorld", "tempEntry", " tmpEntry", "destWorld", "destEntry", "Tempfile", " tmpPath", "tmpfile", "mpfile", "destFolder", "partfile", "partDir", "zipLine", "mpFolder", "tempDir", "destfile", " tmpFiles", "tmpDir", "mpDir", "tmpEntry", "zipFiles", "tmpFolder", "tempFiles", "TempFile", "zipfile", "tempPath", "tmpPath", " tmpWorld", "destPath", "zipFile", "TempWorld", "tmpLine", "partFile", "partFolder", " tmpfile"], "in": ["ini", "err", "kin", "login", "inner", "gin", "inn", "arin", "input", "din", "In", "up", "sync", "l", "bin", "conn", "info", "c", "pin", "IN", "r", "again", "token", "work", "en", "source", "nin", "cin", "min", "pull", "Out", "ins", "is", "as", "init", "socket", "a", "ac", "con", "data", "rin", "ax", "id", "file", "ex", "i", "win", "reader", "n", "connection", "inc", "f", "lin", "copy"], "out": ["err", "index", "o", "outer", "cmd", "login", "point", "this", "inner", "check", "download", "at", "In", "obj", "up", "sync", "output", "OUT", "bin", "conn", "writer", "null", "IN", "again", "outs", "op", "source", "nin", "line", "io", "min", "Out", "client", "off", "init", "name", "ext", "co", "server", "file", "call", "ex", "i", "no", "one", "n", "connection", "inc", "exec", "socket", "copy"], "localURL": ["LocalURL", " localUrl", "localAPI", "LocalAPI", "localURI", "remoteURI", "LocalUrl", " localCL", "externalAPI", "baseURL", "externalURL", " localURI", "remoteFile", "baseURI", "remoteUrl", "baseFile", "externalUrl", "localCL", "externalCL", "localUrl", "localFile", " localAPI", "remoteURL", " localFile", "LocalCL", "baseUrl"]}}
{"id1": "23199071", "id2": "22264586", "code1": "            @Override\n            public InputStream getInputStream() {\n                try {\n                    String url = webBrowserObject.resourcePath;\n                    File file = Utils.getLocalFile(url);\n                    if (file != null) {\n                        url = webBrowserObject.getLocalFileURL(file);\n                    }\n                    url = url.substring(0, url.lastIndexOf('/')) + \"/\" + resource;\n                    return new URL(url).openStream();\n                } catch (Exception e) {\n                }\n                return null;\n            }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"getInputStream": ["getInputSteam", "newInputSteam", "getInputChannel", "getInputstream", "getReadStream", "newContentStream", "newContentChannel", "getStreamSteam", "newInputChannel", "getStreamstream", "getReadstream", "getContentstream", "newContentstream", "getContentSteam", "getStreamChannel", "getReadSteam", "getContentStream", "getStreamStream", "newInputstream", "newContentSteam", "getReadChannel", "getContentChannel", "newInputStream"], "url": ["image", "resources", "log", "html", "URL", "base", "resource", "in", "email", "feed", "lr", "service", "www", "q", "fr", "coll", "rule", "ul", "cl", "Url", "download", "ref", "http", "remote", "l", "api", "full", "href", "page", "left", "string", "class", "null", "link", "r", "bel", "route", "buffer", "path", "fl", "type", "rel", "uri", "build", "pull", "dir", "secure", "ur", "name", "location", "ssl", "tool", "loc", "host", "id", "data", "server", "ll", "ob", "gl", "user", "str", "sl", "i", "el", "rl", "default", "jar", "source", "web", "f", "address"], "file": ["File", "log", "folder", "base", "letter", "resource", "unit", "feed", "image", "child", "model", "rule", "plain", "fe", "http", "cache", "zip", "local", "play", "use", "l", "b", "info", "full", "object", "page", "class", "files", "route", "path", "work", "able", "job", "line", "part", "place", "uri", "fp", "dir", "FILE", "name", "live", "data", "id", "e", "money", "lib", "connection", "loc", "source", "db", "f"]}}
{"id1": "10759917", "id2": "8778962", "code1": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"delete": ["link", "de", "register", "create", "del", "flush", "write", "load", "sync", " deleting", "post", "update", " deletion", " Delete", "drop", "remove", "dump", "execute", "id", " destroy", "Delete", "database", "get", "connection", "destroy", "exec", "save"], "name": ["link", "action", "model", "base", "resource", "create", "NAME", "prefix", "alias", "none", "active", "version", "filename", "key", "label", "table", "info", "now", "object", "space", "style", "string", "class", "ame", "null", "code", "definition", "pass", "path", "Name", "type", "part", "named", "client", "size", "missing", "word", "id", "data", "on", "true", "e", "false", "names", "no", "comment", "old", "database", "n", "value", "default", "time", "like", "one", "parent", "url", "address"], "CannotDeleteSystemLinkException": ["CannotDeleteSysLinkception", "CannotDeleteSystemLinkError", "CannotDeleteSysLinkException", "CannotDeleteClassLinkInformation", "CannotDeleteSystemLinksException", "CannotDeleteSystemLinksInformation", "CannotDeleteSysLinkError", "CannotDeleteSystemRelception", "CannotDeleteSystemReferenceception", "CannotDeleteSystemlinkception", "CannotDeleteSystemLinkApplication", "CannotDeleteSystemlinkException", "CannotDeleteClassLinkException", "CannotDeleteSystemLinksception", "CannotDeleteSystemRelException", "CannotDeleteSystemLinkception", "CannotDeleteClassLinkception", "CannotDeleteSystemLinksApplication", "CannotDeleteSystemReferenceException", "CannotDeleteSystemlinkApplication", "CannotDeleteSystemReferenceError", "CannotDeleteSystemLinkInformation", "CannotDeleteSysLinkEx", "CannotDeleteSystemRelEx", "CannotDeleteSystemLinkEx", "CannotDeleteSystemReferenceEx", "CannotDeleteSystemRelError", "CannotDeleteClassLinkApplication", "CannotDeleteSystemlinkInformation"], "ClassLinkTypeNotFoundException": ["ClassLinkTypeNotfoundException", "ClassLinkTypeNotFoundError", "ClassLinkTypeNotSourceRequest", "ClassLinkTypeNotfoundError", "ClassLinkTypeNotFoundRequest", "ClassLinkTypeNotSourceException", "ClassLinkTypeNotSourceError", "ClassLinkTypeNotfoundRequest"], "conn": ["enc", "ou", "lc", "ver", "nt", "config", "serv", "coll", "dc", "po", "cli", "oci", "nc", "pc", "cur", "open", "rt", "Connection", "ns", "cache", "ca", "exec", "sync", "ch", "bb", "cat", "ann", "pr", "cb", "c", "act", "session", "ct", "orp", "core", "query", "ci", "p", "conf", "org", "oss", "client", "cc", "util", "pub", "close", "cm", "ssl", "ac", "co", "con", "h", "cn", "server", "ec", "ob", "dn", "cond", "connect", "lock", "mc", "Conn", "error", "n", "ctx", "cp", "connection", "loc", "uc", "db", "pg"], "stmt": ["stob", "Stdt", " stmm", "ctmd", "stlt", "strsql", "Stmm", "Stmt", "estmt", "istdt", "strmd", "Stmn", "rdmt", "rdsql", "ctmt", "sthmt", "stmp", "rddd", "sthmd", "Stdb", "stmd", "STsql", " stsql", "Stnt", "stsql", "playdt", "Stmp", "estlt", "sthdb", " stmn", "stnt", "stmn", "sthmn", "strlt", "playmt", "STlt", " stob", "estdd", " stmd", "stmm", "strnt", " stdd", "Stmd", "Stob", "stdd", "estsql", " stmb", "strmp", "stm", " stmp", "strmm", "strmt", "rdmd", "istmt", "istmd", "strmb", "strob", "STdd", "ctmb", "strdd", " stnt", "Stm", " stm", "stdt", "istnt", "stmb", " stdb", "stdb", "playnt", "playmd", "Stmb", "ctm", "STmt", "strm"], "prepTable": ["supable", "Preptable", "prepType", "initTable", "inittable", " prepCol", "PrepType", " prepable", "parCol", "partable", "prepable", "PrepTable", "prepCol", "initType", "supTable", "preptable", "Prepable", " preptable", "supType", "parType", " prepType", "suptable", "initCol", "parTable"], "objectLinkTable": ["objLinkStore", "objectLinkFile", "objlinkTable", "objectlinkTable", "objectLineTable", "objectLinkType", "ObjectLinkFile", "objectTypeFile", "objectlinkTab", "objectLineSource", "objLinkType", "objectlinkFile", "objectlinkSource", "objLinkChain", "objectRelStore", "objectlinkChain", "objectLinkChain", "ObjectLineTable", "ObjectLinkTab", "objectRelType", "objectSyncStore", "objectlinkType", "objectSyncChain", "objectLinkStore", "objlinkStore", "objectSyncType", "objectLineTab", "objectlinkStore", "objlinkType", "objectTypeSource", "objectLinkSource", "objlinkChain", "ObjectLineTab", "ObjectLinkTable", "objectTypeTab", "objectRelChain", "objectTypeTable", "objectLinkTab", "ObjectLineSource", "objectRelTable", "ObjectLineFile", "objLinkTable", "objectLineFile", "objectSyncTable", "ObjectLinkSource"], "sql": ["log", "cmd", "function", "ls", "SQL", "zip", "shell", "csv", "pr", "update", "string", "summary", "spec", "params", " SQL", "query", "join", "result", "ql", "sg", "sb", "sv", "su", "insert", "sq", "expression", "statement", "ssl", "term", "id", "sf", "general", "description", "comment", "str", "sl", "dl", "select", "db", "url", "s"]}}
{"id1": "3053403", "id2": "9846843", "code1": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"fc": ["enc", "lc", "FC", "feed", "rx", "circ", "fa", "fat", "dc", "lf", "fm", "cl", "ff", "nc", "pc", "fen", "fe", "fi", "hub", "exp", "fw", "exec", "ref", "xf", "full", "cb", "conn", "roc", "raf", "fact", "cf", "c", "vc", "ct", "hl", "rc", "fd", "irc", "fb", "dl", "pl", "sc", "flo", "fl", "io", "cs", "df", "console", "wk", "fp", "fs", "cc", "xc", "il", "central", "fx", "col", "ac", "co", "con", "ll", "fn", "af", "sf", " FC", "mc", "win", "bc", "bf", "ec", "loc", "inc", "uc", "f"], "buff": ["eb", "tab", "both", "ref", "prof", "bb", "utf", "cb", "agg", "fab", "null", "cf", "font", "abb", "cod", "boot", "p", "sb", "img", "lab", "rb", "mb", "bg", "f", "bo", "FF", "xb", "fw", "b", "info", "bed", "gg", "txt", "front", "uff", "bet", "obb", "Buff", "build", "comp", "app", "fam", "bh", "loc", "np", "cast", "bm", "form", "bl", "ff", "fe", "feat", "aff", "text", "comb", "home", "gb", "fb", "ind", "ph", "pb", "fx", "butt", "callback", "cp", "grab", "bu", "fo", "box", "feed", "gap", "load", "back", "bas", "bag", "uf", "now", "buf", "pp", "buffer", "pl", "bd", "loop", "bug", "hand", "ob", "cell", "ctx", "bf", "bc", "config"], "encoding": ["decoding", "decryption", "Encoding", "Encaging", "encryption", "encasing", "encording", "ecoding", "encoded", "Encasing", "encoder", " encryption", "Encoded", "Encryption", "encaging", "enryption", "Encoder", "Encording", "ecoded", "ecoder", " encasing", " encaging", " encoder", "decasing", "enoder", "decoder", "decording", "enaging", "decoded", " encording", "enoding", "ecryption"]}}
{"id1": "20660203", "id2": "22611968", "code1": "    public static void main(String args[]) {\n        int temp;\n        int[] a1 = { 6, 2, -3, 7, -1, 8, 9, 0 };\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < a1.length; i++) {\n            System.out.print(\" \" + a1[i]);\n        }\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"temp": ["z", "num", "index", "stable", "prefix", "pt", "current", "pre", " Temp", "mini", "count", "cache", "modified", "output", "style", "null", "pi", "c", "t", "k", "p", "Temp", "v", "diff", "flat", "length", "size", "tmp", "emp", "perature", "test", "tc", "e", "level", "adj", "str", "fake", "empty", "tem", "n", "iter", "default", "partial", "m", "source", "parent", "f", "max"], "a1": ["as4", " a9", "aOne", "A100", "array1", " a0", " a127", "ama100", "A1", "safirst", "sa1", "alpha0", "an5", "aa1", "aa4", "alpha2", "an0", "a91", " aOne", "a0", "saone", "an2", "aa2", "aaone", "amaOne", "alpha4", "aone", "aa51", "an1", "Afirst", "ama1", "a51", " a100", "alphaOne", "a100", "ha2", " a001", "a5", " aone", "array5", "aa91", "A2", "ama51", "Aone", "A5", "anfirst", "eOne", "a4", "e100", "a2", "ha1", "alpha9", "alpha1", "arrayOne", "ama127", "p4", " afirst", " a4", " a2", "an100", "sa5", "a001", "AOne", " a51", "A0", "ama001", "saOne", "alphaone", "a9", "p2", "A91", "aa001", "A9", "ama4", "p0", "p1", "afirst", "as2", "ha100", "arrayfirst", "asone", "hafirst", " a91", "e1", "a127", "e127", "A4", " a5", "as1"], "j": ["z", "aj", "jc", "o", "oi", "jl", "ii", "ik", "l", "b", "jp", "js", "pi", "c", "g", "k", "d", "ind", "li", "ci", "p", "xi", "ni", "si", "bi", "ja", "v", "x", "ji", "it", "I", "y", "length", "jj", "a", "h", "J", "e", "u", "ij", "n", "di", "bj", "m", "f"], "i": ["ini", "z", "mi", "index", "o", "in", "yi", "anti", "phi", "cli", "ii", "ix", "fi", "mini", "slice", "ik", "api", "b", "l", "ui", "jp", "info", "ami", "ri", "pi", "c", "r", "gi", "g", "abi", "it", "li", "ci", "ie", "multi", "si", "xi", "ni", "bi", "I", "uri", "x", "ai", "ji", "io", "y", "v", "ip", "adi", "is", "init", "ori", "a", "qi", "h", "ti", "id", "e", "iu", "u", "vi", "f", "di", "ki", "oi"]}}
{"id1": "21979714", "id2": "9996334", "code1": "    @ActionMethod\n    public void list() throws IOException {\n        final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/list?version=1000\");\n        final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n        con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n        final InputStream in = con.getInputStream();\n        final byte[] buf = new byte[4096];\n        textArea.setText(\"\");\n        for (int bytesRead; (bytesRead = in.read(buf)) != -1; ) {\n            textArea.append(new String(buf, 0, bytesRead));\n        }\n    }\n", "code2": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "label": 0, "substitutes": {"list": ["index", "stop", "LIST", "check", "download", "ls", "find", "parse", "load", "ping", "sync", "info", "show", "print", "read", "export", "sort", "query", "split", "pull", "start", "test", "request", "search", "get", "delete"], "url": ["log", "URL", "base", "resource", "www", "ul", "cl", "Url", "ls", "entry", "http", "l", "api", "bb", "conn", "page", "string", " URL", "path", "fl", "org", "uri", "build", "pull", "client", "blog", "bug", "ur", "ssl", "server", "file", "ll", "ob", "lock", "sl", "rl", "connection", "config", "host", "web", "f"], "con": ["com", "lc", "ver", "conv", "login", "sub", "func", "can", "fac", "fa", "cl", "cons", "open", "cur", "pc", "ctrl", "fc", "run", "ca", "http", "ch", "conn", "un", "ann", "CON", "ran", "c", "cf", "rc", "en", "part", "an", "xc", "client", "Con", "close", "cm", "cp", "co", "ec", "ln", "cn", "on", "fn", "connect", "f", "ex", "Conn", "bc", "uc", "connection", "ctx", "exec", "conf"], "in": ["ini", "re", "login", "sub", "this", "stream", "inner", "inn", "input", "In", "rec", "bin", "conn", "b", "c", "r", "IN", "again", "conf", "min", "out", "client", "ins", "is", "as", "socket", "a", "data", "rin", "file", "ex", "reader", "i", "win", "n", "vin", "m", "inc", "f", "lin"], "buf": ["wb", "base", "conv", "func", "vec", "abs", "ff", "cur", "aka", "src", "bag", "uf", "bytes", "bin", "b", "cb", "bp", "bb", "fab", "utf", "orig", "buff", "buffer", "rc", "Buffer", "fb", "bf", "bd", "grab", "seq", "Buff", "sb", "cas", "pb", "tmp", "la", "bu", "data", "cv", "rb", "bc", "bh", "batch", "br", "uc", "db", "exc", "ab"], "bytesRead": ["wordsRead", "byteWrite", "bytesread", "BytesLength", "tesread", "bytesFound", "tesLength", "BytesRead", " bytesLoad", " bytesLength", "wordsFound", "stringsRead", "tesRead", "bytesFind", "byteLength", " bytesWritten", "BytesWritten", "BytesWrite", "stringsWritten", "byteRead", "wordsLength", " bytesWrite", "wordsread", " bytesFound", "byteWritten", " bytesFind", "tesFound", "bytesWrite", "stringsFind", "bytesWritten", "stringsLoad", "bytesLength", "bytesLoad", "BytesLoad", " bytesread", "BytesFind"]}}
{"id1": "755203", "id2": "665420", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndrewrites", "readAndRebwrite", "readandrewrite", "readAndSwwrite", "readAndRewwrite", "readAndSwrap", "readAndSwrite", "readandRewrite", "readAndrewrap", "readAndRewrap", "readAndRebrites", "readandrewwrite", "readAndRebrap", "readandRewrap", "readandRewrites", "readAndSwrites", "readandrewrites", "readAndrewrite", "readAndrewwrite", "readAndRebrite", "readandRewwrite", "readAndRewrites", "readandrewrap"], "inFile": ["inFilename", "loginFile", "outFilename", "inputfile", "InFiles", "InFile", " inFiles", "oldFile", "loginFilename", " inSourceFile", "outSourceFile", "InSourceFile", "inputFiles", "outFiles", "oldFiles", " inFilename", "loginFiles", "inputFile", "inSourceFile", "loginfile", "outfile", " infile", "inputFilename", "inFiles", "oldfile", "infile", "oldFilename", "Infile"], "outFile": [" outStream", "offPlace", "outFilename", " outDir", "outputPlace", "outFILE", "OutStream", "outputFilename", "newDir", " outfile", "thisFILE", "outputFile", "offFile", "outDir", "processFilename", "exfile", "exFILE", "newfile", "processPlace", "thisFile", "processFILE", "thisfile", "offFilename", "thisFilename", "outStream", "outPlace", "newFile", "exFile", "exFilename", "outfile", "outputfile", "OutFile", "outputFILE", "OutDir", "offFILE", "processFile", "newStream", "Outfile"], "iis": ["iniis", "Iiss", "iiIs", "iiIS", " iIS", " iIs", "iIs", "iniiss", "ciiss", "ciis", "Iis", "Iais", " iris", "IIS", "ciais", "ciIs", "iiss", "ciris", "iniIS", "iniIs", "iiris", "iiis", "iiiss", "ciIS", "iniris", "iais", " iiss", "iris", "iIS", " iais"], "dcmParser": ["dcmHelper", "dpmarser", "dmcPar", "dmoduleJar", "dmcJar", "dcmPar", "dbmPolicy", "dCMPlugin", "dmoduleParser", "dcmJar", "fcmHandler", "dcrPar", "fpmParser", "dmcarser", "dpmparser", "dbmHelper", "dmissionReader", "dpmLoader", " dpmLoader", "dcrReader", "dbmPlugin", "dCMParser", "dmoduleparser", "dpmPolicy", " dcrParser", "dmPlugin", "dkmHelper", "DcmInstallation", "dmmParser", "dcmparser", " dpmPolicy", " dcmPlugin", "dcmLoader", " dpmHelper", "dmLoader", "dhemReader", "dcmarser", "dpmHelper", "dbmParser", "fpmHandler", "dpmHandler", "dhemParser", "dcrJar", "dpmJar", " dcmLanguage", "fcmParser", "dcrarser", "dcmPolicy", "dkmParser", "dpmInstallation", " dpmJar", "dmodulePlugin", "dmmparser", "dcmLanguage", "dhemInstallation", "dcmInstallation", "fpmparser", "dpmParser", " dpmparser", " dcmPar", "dcmHandler", "dcrPlugin", "dmcParser", " dcmparser", "dcmReader", " dcrReader", "fcmReader", "DcmReader", " dpmPlugin", "dCMparser", "dpmLanguage", " dpmReader", "dmParser", "dmoduleReader", "dmissionPlugin", "dhemJar", " dpmPar", " dcrLoader", "dpmPar", "fpmReader", "dcrParser", "DcmJar", "dmissionParser", " dcmReader", "dCMHandler", "dpmPlugin", " dpmarser", " dpmLanguage", "dmmPlugin", " dcmarser", "dkmPolicy", " dcmHelper", " dcmLoader", "fcmparser", "dpmReader", " dpmParser", "dmReader", " dcmJar", " dcrPlugin", "dCMReader", "dmmLoader", "DcmParser", " dcmPolicy", "dkmPlugin", "dcmPlugin", "dCMLoader", "dcrLoader", "dmissionLanguage"], "ds": ["dd", "dr", "vals", "des", "ants", "os", "vs", "dc", "amps", "dat", "utils", "DS", "ls", "services", "details", "Ds", "ads", "src", "ns", "points", "sync", "ld", "conn", "js", "ws", "da", "ts", "ays", "cdn", "xs", "ps", "session", "d", "ils", "Db", "dt", "ros", "Os", "tes", "cs", "df", "uds", "dds", "ras", "eps", "gd", "ins", "iss", "qs", "is", "rs", "ys", "gs", "icks", "nas", "bs", "data", "sys", "pd", "ss", "tx", "ks", "di", "asi", "db", "parts", "drivers", "s"], "pdReader": ["ddRunner", "hdWriter", "hdLoader", "xdRead", "hdStream", "pcLoader", "pdStream", "pbLoader", "dsLoader", "pbReader", "ddLoader", "pcRead", "ddReader", "pdreader", "xdWriter", "hdReader", "hdRunner", "hdreader", "pbRunner", "ddStream", "pcWriter", "dsreader", "pdLoader", "pbStream", "dsReader", "xdReader", "hdRead", "pdRead", "pcReader", "dsRead", "xdreader", "pdRunner", "dsWriter"], "out": ["flow", "her", "model", "temp", "group", "list", "full", "page", "null", "again", "result", "img", "layer", "name", "file", "lib", "connection", "parent", "s", "device", "in", "o", "login", "outer", "child", "point", "to", "write", "cli", "over", "cache", "sync", "output", "OUT", "password", "conn", "auto", "builder", "code", "session", "pass", "outs", "doc", "io", "Out", "co", "sys", "user", "down", "copy", "err", "base", "inner", " in", "at", "exp", "later", "object", "array", "external", "line", "diff", "client", "ssl", "term", "ext", "data", "gen", "lock", "ex", "default", "inc", "db", "exec", "obj", "image", "dev", "w", "order", "with", "net", "up", "key", "writer", "store", "oder", "part", "director", "manager", "as", "word", "dot", "url"], "dcmEncParam": ["dcmEnParam", "dcmArchArg", "dcmEnPar", "dcmEnArg", "dcmDecParam", "dcmDecType", "dcmDecArg", "dcmElType", "dcmArchParameter", "dcmEncArg", "dcmEnPart", "dcmElPar", "dcmArchParam", "dcmEncType", "dcmSecParam", "dcmEnType", "dcmDecPar", "dcmEstParameter", "dcmDecParameter", "dcmEncPart", "dcmEncParameter", "dcmEstPar", "dcmEncPar", "dcmElParam", "dcmEnParameter", "dcmElParameter", "dcmEstParam", "dcmSecType", "dcmDecPart", "dcmSecPar", "dcmEstType", "dcmSecPart"], "pdWriter": ["htReader", "ddOutput", "htWriter", "hdWriter", "dpWriting", "htWrite", "dsOutput", "PDWrite", "PDWriter", "ddWrite", "ddReader", "hdReader", "pdOutput", "pdWrite", "dpReader", "dsWrite", "ddWriter", "PDReader", "PDWriting", "hdWrite", "dsReader", "pdWriting", "hdOutput", "dpWrite", "dpWriter", "dsWriter", "htWriting"]}}
{"id1": "17475530", "id2": "11952735", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 1, "substitutes": {"testAddLinkToImage": ["testAddLinkFromImage", "testAddLinkToFile", "testAddLinkFromPicture", "testAddLinkstoImage", "testAddLinkstoFile", "testAddLinkOfFile", "testAddLinkToLink", "testAddLinkOfLink", "testAddLinkstoLink", "testAddLinktoImage", "testAddLinkOfPicture", "testAddLinkFromLink", "testAddLinktoPicture", "testAddLinktoLink", "testAddLinkFromFile", "testAddLinkToPicture", "testAddLinksToPicture", "testAddLinksToLink", "testAddLinktoFile", "testAddLinkOfImage", "testAddLinksToFile", "testAddLinkstoPicture", "testAddLinksToImage"], "in": ["ini", "image", "err", "index", "resource", "login", "serv", "stream", "gin", "inn", "val", "input", "with", "din", "In", "at", "version", "exp", "bin", "conn", "pin", "r", "IN", "again", "pass", "token", "path", "work", "doc", "nin", "uri", "cin", "diff", "min", "out", "ins", "is", "xml", "as", "socket", "ssl", "name", "ac", "con", "data", "file", "isin", "rin", "ax", "id", "el", "ex", "i", "win", "reader", "n", "get", "or", "connection", "m", "source", "exec", "f", "url", "inc", "copy"]}}
{"id1": "7166270", "id2": "8665321", "code1": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"issueCommandToServer": [" sendCommandWithService", " sendRequestToService", " sendCommandFromServer", " sendCommandToServer", " sendCommandtoServer", " sendCommandtoClient", " sendCommandWithserver", " sendRequestToClient", " sendCommandtoserver", " sendCommandFromClient", " sendCommandtoService", " sendRequestToserver", " sendRequestToServer", " sendRequestFromService", " sendCommandWithServer", " sendCommandFromserver", " sendRequestFromClient", " sendRequestFromServer", " sendCommandToService", " sendCommandToClient", " sendCommandWithClient", " sendCommandToserver", " sendCommandFromService", " sendRequestFromserver"], "command": ["action", "method", "argument", "cmd", "Command", "service", "script", "resource", "module", "directory", "event", "sequence", "domain", "function", "pattern", "patch", "version", "text", "message", "queue", "password", "application", "string", "code", "buffer", "query", "attribute", "comm", "request", "operation", "component", "data", "document", "value", "description", "timeout", "connection", "execute", "menu", "address"], "changeCapsule": ["changeCapsole", "changeCAPSule", "changeScapulate", "changeCambulate", "changecapsules", "changeCAPSules", "changeCorpure", "changeScapure", "changeCambule", "changeScapsure", "changeCambure", "changeCapsulation", "changecAPSule", "changeCapesulation", "changeCapsure", "changeCapulation", "changecAPSules", "changeCapules", "changeCapole", "changeCapesules", "changeScapsole", "changeCambole", "changeCapule", "changecapsulation", "changeCAPSulate", "changeCapulate", "changeScapole", "changecAPSulate", "changeCorpulate", "changeCAPSulation", "changeCapsulate", "changeScapsulate", "changeScapule", "changeCapesule", "changeCorpole", "changeCapsules", "changecapsule", "changecAPSulation", "changeScapsule", "changeCapure", "changecapsulate", "changeCorpule", "changeCapesulate"], "urlConn": ["httpOpen", "userConnection", "serverConnector", "userOpen", "urlAuth", " urlConnection", " urlOpen", " urlEnc", " urlCo", "httpConnection", " urlDec", "serverEnc", "serverCo", "urlOpen", " urlFs", "userConn", " urlConnector", "UrlEnc", "lFs", "lConn", "UrlConnect", "serverAuth", "httpCo", "serverConn", "UrlExec", "serverConnect", "serverExec", "urlExec", "httpDec", "urlEnc", "userConnect", "UrlAuth", "httpConn", "httpConnect", "urlFs", "urlCo", " urlExec", "urlConnection", "urlConnector", " urlConnect", "serverDec", "lConnect", "urlDec", "UrlConn", "lConnection", "urlConnect", "UrlConnector", "httpFs", " urlAuth", "serverConnection"], "wr": ["err", "wb", "vr", "raft", "rx", "kr", "wl", "w", "worker", "fw", "wer", "wh", "writer", "conn", "wd", "ws", "RW", "usr", "r", "wt", "wp", "wa", "wx", "wire", "rr", "nw", "nr", "rh", "wk", "mr", "tw", "wm", "Writer", "hr", "sr", "war", "Wr", "NW", "WR", "rw", "sw", "wcs", "cr", "shr"], "content": ["enc", "body", "esc", "method", "resource", "Content", "section", "raw", "script", "cont", "child", "create", "temp", "wave", "format", "write", "json", "text", "message", "output", "password", "string", "code", "array", "c", "equ", "buffer", "work", "context", "xml", "request", "server", "data", "document", "const", "value", "description", "comment", "activity", "config", "source", "exec", "url", "header"], "input": ["image", "in", "resource", "wave", "raw", "temp", "stream", "self", "inner", "ink", "inf", "form", "w", "audio", "json", "inch", "cur", "Input", "worker", "active", "acl", "output", "writer", "conn", "through", "element", "usr", "r", "ack", "buffer", "rc", "amp", "er", "source", "rr", "out", "pull", "xml", "hr", "ssl", "init", "request", "keep", "inside", "data", "error", "reader", "i", "rss", "enter", "ctx", "iter", "inc", "socket"], "response": ["onse", "image", "model", "service", "answer", "resource", "wave", "feed", "office", "site", "Response", "json", "message", "output", "api", "respond", "writer", "object", "page", "application", "string", "array", "collection", "resp", "buffer", "vector", "line", "result", "uri", "secret", "generation", "report", "tree", "ception", "request", "server", "data", "reference", " Response", "value", "connection", "reply"], "str": ["enc", "err", "dec", "letter", "lc", "dr", "fr", "raw", "strike", "kr", "coll", "cl", "arr", "obj", "exp", "text", "exec", "l", "list", "STR", "pr", "style", "string", "sp", "r", "spec", "tr", "st", "er", "stri", "line", "type", "result", "div", "ner", "name", "hr", "data", "id", "char", "Str", "sl", "i", "iter", "br", "cr", "f", "url"]}}
{"id1": "3401153", "id2": "14054923", "code1": "    private String getHTML(String pageURL, String encoding, String dirPath) throws IOException {\n        StringBuilder pageHTML = new StringBuilder();\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(pageURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"MSIE 7.0\");\n            connection.connect();\n            BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), encoding));\n            String line = null;\n            while ((line = br.readLine()) != null) {\n                pageHTML.append(line);\n                pageHTML.append(\"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            connection.disconnect();\n        }\n        if (dirPath != null) {\n            File file = new File(dirPath);\n            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file));\n            bufferedWriter.write(pageHTML.toString());\n            bufferedWriter.close();\n        }\n        return pageHTML.toString();\n    }\n", "code2": "    protected Document getRawResults(String urlString, Map args) throws Exception {\n        int count = 0;\n        Iterator keys = args.keySet().iterator();\n        while (keys.hasNext()) {\n            String sep = count++ == 0 ? \"?\" : \"&\";\n            String name = (String) keys.next();\n            if (args.get(name) != null) {\n                urlString += sep + name + \"=\" + args.get(name);\n            }\n        }\n        URL url = new URL(urlString);\n        URLConnection conn = url.openConnection();\n        conn.connect();\n        SAXBuilder builder = new SAXBuilder();\n        return builder.build(conn.getInputStream());\n    }\n", "label": 0, "substitutes": {"getHTML": ["createHTML", "createPage", "updatePage", "createJSON", "loadPage", "getURL", "loadURL", "createURL", "getJSON", "getPage", "updateHTML", "updateURL", "loadJSON", "loadHTML", "updateJSON"], "pageURL": ["basePath", "Pageurl", " pagePath", "PagePath", "pageurl", "pageUrl", "PageURI", "pageURI", " pageURI", "badUrl", "badURI", "baseURL", "PageUrl", "baseURI", " pageurl", "badURL", "pagePath", "PageURL", "badurl", " pageUrl", "baseUrl"], "encoding": ["decoding", "Encoding", "Encaging", "encasing", "coded", "enasing", "encoded", "Encasing", "encension", "encoder", "Encoded", "coding", "encaging", "contoder", "Encoder", "caging", "contasing", "decension", "decasing", "contoding", "contension", "decoder", "enaging", "enoded", "casing", "enoding", "Encension"], "dirPath": ["folderPath", "directoryFile", "DirFile", "DirLocation", "dirDir", " dirDir", "DirLog", "buildLog", "zippath", "Dirpath", "DirDir", "buildPath", "directoryDir", "dirFile", "folderpath", " dirLocation", "dirPoint", "directoryLog", "directorypath", "directoryLocation", "DirPath", " dirpath", "zipPath", "dirLog", "dirpath", "buildFile", "zipFile", "zipPoint", "folderFile", "directoryPoint", "dirLocation", "folderPoint", "directoryPath"], "pageHTML": [" pageBody", "resultUrl", " pageJSON", "PageHTTP", "sectionHTML", "pageWriter", "pageBody", "sectionHTTP", "PageJSON", "pageUrl", "PageURI", "Pagehtml", "pageURI", " pageURI", "pagehtml", " pagehtml", "codeWriter", "rowURL", "sectionURL", "siteHTML", "PageUrl", "resultURL", "rowHTML", "siteURL", "codehtml", "pageHTTP", "sectionBody", "PageHTML", "PageURL", "resultWriter", "rowJSON", "codeHTML", " pageHTTP", " pageUrl", "pageJSON", "resultJSON", "resulthtml", "codeUrl", "siteURI", "resultHTML", "rowhtml", "PageBody", " pageWriter", "siteUrl"], "connection": ["body", "log", "pool", "o", "resource", "section", "ion", "function", "open", "channel", "Connection", "http", "text", "cache", "password", "b", "conn", "cb", "connected", "application", "string", "builder", "c", "position", "condition", "collection", "session", "relation", "handler", "ci", "io", "org", "uri", "bec", "number", "director", "response", "client", "character", "context", "manager", "socket", "communication", "proxy", "con", "loc", "server", "union", "user", "wrapper", "connect", "database", "reader", "timeout", "bc", "or", "config", "ctx", "db", "uc", "directory"], "url": ["link", "image", "log", "URL", "base", "feed", "stream", "coll", "function", "Url", "channel", "http", "Connection", "l", "conn", "page", "update", "string", "builder", "path", "uri", "build", "plug", "client", "ssl", "server", "user", "connect", "browser", "sl", "contact", "loc", "location", "web", "f", "address"], "br": ["body", "err", "dr", "lr", "fr", " reader", "stream", "bl", "arr", "src", "ocr", "ler", "bridge", "ch", "b", "cb", "ctr", "pr", "bh", "buf", "r", "tr", "bro", "result", "io", "Br", "BR", "mr", "ner", "hr", "ori", "sr", "ob", "str", "Reader", "reader", "rb", "keeper", "bc", "cro", "cr"], "line": ["link", "letter", "lc", "unit", "base", "end", "lf", "cl", "lines", "entry", "inline", "LINE", "up", "text", "message", "Line", "sync", "key", "column", "l", "b", "object", "page", "ine", "string", "code", "style", "c", "pe", "r", "pass", "li", "frame", "row", "response", "le", "character", "block", "name", "word", "ge", "data", "cell", "char", "str", "sl", "comment", "el", "lin"], "e": ["re", "err", "force", "die", "o", "exc", "je", "fe", "ue", "E", "ve", "c", "pe", "r", "ise", "ace", "ze", "oe", "be", "ie", "er", "en", "type", "Exception", "p", "se", "ea", "x", "ce", "es", "ception", "ae", "esi", "ev", "te", "error", "i", "one", "or", "ec", "f", "ee"], "file": ["File", "folder", "log", "body", "base", "resource", "feed", "ile", "http", "zip", "filename", "output", "l", "writer", "b", "page", "null", "pe", "files", "buffer", "path", "handler", "io", "result", "fp", "book", "dir", "FILE", "le", "name", "socket", "h", "data", "lock", "reader", "angle", "per", "source", "db", "f"], "bufferedWriter": ["BufferedReader", "bufferingW", " bufferingReader", "BuffererReader", "buffinedWriter", "buffenedWriter", "buffererFile", "buffererReader", " bufferedW", "uferedWriter", "uferedWriting", "ufaredwriter", "buffilledwriter", "buffererWrite", "bufferedW", "buffinedFile", "bufferedWrite", "bufferingWrite", "BuffererWrite", "bufferedwriter", "buffenedW", "uferedwriter", "BuffererWriter", "buffinedReader", "BufferedWrite", "bufferingFile", "buffererW", " bufferingW", "buffererWriter", "buffaredwriter", "buffedWriting", "buffaredWriter", "bufferedReader", " bufferedReader", "buffenedFile", "buffedwriter", "bufferingWriter", "ufaredWriter", "ufaredWriting", "buffenedReader", "buffinedWrite", "buffilledWriter", "BufferedWriter", " bufferingWriter", "BuffererFile", " bufferedFile", "buffedWriter", "buffilledWriting", "buffaredWriting", "BufferedFile", " bufferingFile", "bufferingReader", "bufferedWriting", "bufferedFile"]}}
{"id1": "20414923", "id2": "3184073", "code1": "    protected int deleteBitstreamInfo(int id, Connection conn) {\n        PreparedStatement stmt = null;\n        int numDeleted = 0;\n        try {\n            stmt = conn.prepareStatement(DELETE_BITSTREAM_INFO);\n            stmt.setInt(1, id);\n            numDeleted = stmt.executeUpdate();\n            if (numDeleted > 1) {\n                conn.rollback();\n                throw new IllegalStateException(\"Too many rows deleted! Number of rows deleted: \" + numDeleted + \" only one row should be deleted for bitstream id \" + id);\n            }\n        } catch (SQLException e) {\n            LOG.error(\"Problem deleting bitstream. \" + e.getMessage(), e);\n            throw new RuntimeException(\"Problem deleting bitstream. \" + e.getMessage(), e);\n        } finally {\n            cleanup(stmt);\n        }\n        return numDeleted;\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 0, "substitutes": {"deleteBitstreamInfo": ["deleteBitstoreDetails", "deleteBitstreamINFO", "deleteBitStreamINFO", "deleteBitsystemINFO", "deleteBitStreamDetails", "deletebitStreamDetails", "deletebitStreaminfo", "deleteBitsystemInfo", "deleteBitStreamInfo", "deleteBitsystemDetails", "deleteBitstoreInfo", "deletebitStreamINFO", "deleteBitstreamDetails", "deletebitstreamInfo", "deleteBitStreaminfo", "deleteBitstoreINFO", "deletebitstreamINFO", "deleteBitstoreinfo", "deleteBitstreaminfo", "deletebitstreamDetails", "deletebitStreamInfo", "deleteBitsysteminfo", "deletebitstreaminfo"], "id": ["ident", "vid", "num", "index", "in", "create", "offset", "root", "rid", "which", "entry", "ids", "ref", "count", "key", "info", "uid", "object", "status", "code", "did", "path", "d", "ide", "pid", "db", "p", "ad", "type", "part", "ID", "oid", "aid", "x", "number", "Id", "ip", "start", "name", "sid", "mid", "data", "error", "no", "i", "one", "seq", "like", "source", "parent", "kid", "url", "address"], "conn": ["enc", "nt", "serv", "coll", "dc", "nc", "rt", "Connection", "ca", "exec", "sync", "ch", "jp", "ann", "pr", "sql", "c", "cf", "act", "cr", "mn", "session", "ct", "rc", "ci", "stat", "client", "cc", "cm", "col", "co", "con", "cn", "server", "dn", "connect", "mc", "Conn", "ctx", "cp", "connection", "config", "db", "pg", "obj"], "stmt": ["strst", "stlt", "Stmt", "shmd", "strmd", "Stmn", "stMT", "shMT", " stmr", " sttr", "Stdb", "stmd", "strpr", "Stst", "strmn", "Stmr", "shart", "strMT", " stst", "sttr", "Sttr", "Stlt", "stmn", "Stpr", "strlt", " start", " stlt", "Start", "Stmd", "StMT", "stm", "strmt", "start", "stst", " stMT", "shmt", " stpr", "strmr", "strtr", "Stm", " stm", " stdb", "stdb", "stmr", "strdb", "stpr", " stmd", " stmn", "strm"], "numDeleted": ["Numdeued", "numDeflected", "numdeleted", "Numdeleted", "numExletes", "NumDeleted", " numdeashed", "numUndued", "numdeued", "numDeDelete", "numNeleted", "numDelected", "NumDeigrated", "numdeased", " numDeased", "numModleted", " numdeleted", "numDeoded", "NumdeDelete", "Numdeigrated", "numNeletes", "numUndDelete", "numDellected", "numDeletes", "NumDeDelete", "numDuDelete", "numdeletes", "numModletes", "numDeued", "numDefased", "numDuleted", "numMododed", "numModashed", "numDeigrated", "numDeashed", "numDeased", " numdeased", " numdelected", "numDelased", " numDeoded", "numdelete", "numdeoded", " numDeashed", "numDelete", " numdeletes", "numExashed", " numDeletes", "numdeDelete", "numDelleted", "numUndleted", "numExoded", "numExleted", "numDeloded", "numDefleted", "numDuigrated", "numNelete", " numDelete", "numdeigrated", " numdeoded", " numDelected", "numDefoded", "numdelected", "numdeashed", "NumDeued"]}}
{"id1": "6009527", "id2": "15580610", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishloadAttachachment", "doFinishLoadInstachment", "doFinishLoadAttments", "doFinishloadAttortion", "doFinishLoadInstment", "doFinishLoadAssment", "doFinishLoadAssments", "doFinishLoadInstortion", "doFinishloadAttachment", "doFinishLoadAssachment", "doFinishLoadAttachachment", "doFinishloadAttment", "doFinishLoadAttachortion", "doFinishLoadInstments", "doFinishLoadAttment", "doFinishLoadAttachments", "doFinishloadAttachortion", "doFinishloadAttments", "doFinishLoadAssortion", "doFinishloadAttachments", "doFinishLoadAttortion"], "attachmentId": ["ttociationID", "attachmentType", "attachmentID", "attociationID", "attachmentid", "attachmentInfo", "attimageInfo", "attociationId", "AttachmentType", "attlementType", "ttociationId", "attachmentPath", "attociationid", "adachmentPath", "adociationInfo", "adociationID", "ttachmentID", "adociationPath", "AttachmentId", "attentionPath", "attentionid", "adachmentInfo", "adachmentID", "attlementid", "attentionID", "attplementationid", "ttociationid", "AttachmentID", "ttachmentId", "attociationPath", "attplementationId", "attplementationID", "ttachmentid", "attimagePath", "attentionInfo", "adociationId", "attimageID", "attlementId", "attociationInfo", "Attachmentid", "attentionType", "attentionId", "attlementID", "attimageId", "adachmentId"], "attachment": ["appachment", "adment", " adaptachment", "attment", "instachment", "adachment", "assention", "attociation", "appment", " attociation", "instention", "assachment", "attention", "adention", "assment", "appruction", "instment", " adaptention", "attached", " adaptociation", " attment", "attachruction", "attachention", "instruction", " adaptment", "attachached", " attention", "attruction", "appention", "adached", "attachachment", "assached", "association"], "attachmentUri": ["attachedAri", "attachmentAuri", "attachmentSuRI", "attachedAti", "attmentUuri", "attachmentCuURI", "attachmentSuri", "attachedUri", "attachmentSuuri", "attachmentIURI", "attachmentARI", "attachmentIuri", "attachmentSuti", "attachedUuri", "attachmentUuri", "attachmentAti", "attachmentSuris", "attachmentURI", "attachmentSuURI", "attmentUri", "attmentUris", "attachmentERI", "attmentIris", "attachmentUti", "attachmentAri", "attachedARI", "attachmentEti", "attachmentUURI", "attachmentEuri", "attachmentIri", "attachedAuri", "attachmentEri", "attmentUURI", "attmentIuri", "attachmentCuri", "attachedUti", "attachmentUris", "attachmentIris", "attmentIURI", "attachmentCuuri", "attmentIri", "attachedURI", "attachmentCuris"], "contentUri": ["contentCdi", "contentCri", "contentCris", "contentIuri", "resourceIri", "contentURI", "contentUuri", "contentFileRI", " contentSuris", "contentURi", "contentUsRI", "contentUsri", "contentCuri", "resourceIris", " contentSudi", "contentUdi", "resourceUi", "contentFileuri", "contentFileri", "contentUsdi", "contentUi", "contentURri", "resourceUris", "contentSuris", "contentUsris", " contentSuRI", "contentIi", "resourceUri", "contentIris", "resourceIi", " contentSuri", "contentCi", "contentURris", " contentUris", "contentIri", "contentUris", "resourceIRI", "contentFileris", "contentUsuri", "contentURuri", "contentSudi", "resourceIuri", "contentIRI", " contentURI", "resourceUuri", "contentSuri", "contentSuRI", "resourceURI", "contentCRI", " contentUdi"], "file": ["File", "folder", "letter", "unit", "base", "resource", "create", "child", "image", "log", "model", "this", "stream", "view", "content", "to", "input", "picture", "up", "zip", "cache", "load", "local", "filename", "use", "output", "ger", "b", "auto", "object", "url", "via", "files", "pe", "buffer", "path", "work", "handler", "able", "single", "line", "upload", "io", "uri", "entity", "fp", "le", "FILE", "name", "socket", "data", "binary", "f", "reader", "get", "connection", "source", "book", "copy"], "in": ["ini", "err", "image", "o", "login", "this", "inner", "inn", "gin", "input", "cli", "In", "up", "sync", "b", "bin", "conn", "c", "pin", "r", "IN", "again", "source", "nin", "io", "pull", "ins", "as", "init", "socket", "a", "ac", "con", "data", "id", "binary", "e", "s", "i", "reader", "win", "or", "connection", "m", "din", "f", "url", "inc", "copy"], "out": ["err", "image", "log", "base", "o", "resource", "outer", "this", "view", "inner", "to", "cli", "net", "In", "up", "cache", "sync", "output", "OUT", "b", "bin", "conn", "writer", "page", "null", "IN", "again", "outs", "source", "line", "nin", "io", "by", "Out", "client", "init", "ext", "data", "on", "lock", "ex", "i", "one", "connection", "inc", "exec", "socket", "copy", "s"], "intent": ["enc", "action", "impact", "agent", "this", "ink", "event", "content", "effect", "eng", "entry", " Intent", "feat", "anc", "text", "animate", "concept", "object", "ents", "element", "act", "intention", "anim", "vent", "ant", "ani", "activation", "ent", "it", "advert", "entity", "response", "context", "xml", "Activity", "spirit", "init", "term", "request", "android", "language", "document", "inst", "category", "focus", "activity", "feature", "contact", "ctx", "acc", "activate"]}}
{"id1": "16760971", "id2": "3945236", "code1": "    public static String generateHash(String key) {\n        key += \"use_your_key_here\";\n        MessageDigest md;\n        try {\n            md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            StringBuffer buff = new StringBuffer();\n            for (int l = 0; l < bytes.length; l++) {\n                String hx = Integer.toHexString(0xFF & bytes[l]);\n                if (hx.length() == 1) buff.append(\"0\");\n                buff.append(hx);\n            }\n            return buff.toString().trim();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"generateHash": ["generatedKey", " GenerateSalt", " GeneratedKey", "generoseKey", "generateSalt", " GenerateKey", "generatesHash", " GenerateHash", "generatesSalt", "generateKey", " GenerateMac", "generatedHash", "generatesMac", "generoseSalt", "generateMac", "generoseMac", " GeneratedHash", "generatedMac", " GeneratedMac", "generatedSalt", "generoseHash", " GeneratedSalt", "generatesKey"], "key": ["rule", "body", "fee", "base", "trust", "prefix", "point", "keys", "hex", "self", "KEY", "text", "message", "pair", "cert", "password", "connection", "full", "string", "hash", "code", "pe", "ace", "crypt", "token", "path", "k", "proof", "work", "type", "ce", "mac", "secret", "cy", "sign", "block", "name", "word", "data", "file", "id", "seed", "char", "user", "str", "date", "Key", "msg", "url", "address"], "md": ["dd", "nm", "nd", "mail", "cmd", "dr", "bm", "mage", "am", "dc", "dig", "metadata", "ma", "amd", " MD", "po", "hd", "mm", "mad", "mo", "message", "ms", "ld", "cd", "mp", "wd", "hash", "d", "mand", "bd", "ds", "ad", "pm", "df", "sm", "mt", "mac", "mg", "od", "me", "editor", " Md", "cm", "MD", "clean", "Cmd", "mod", "dh", "pd", "mag", "rm", "dm", "mc", "mem", "mb", "hm", "di", "m", "rpm"], "bytes": ["pins", "vals", "objects", "codes", "keys", "seconds", "vs", "errors", "ops", "bits", "lines", "ls", "zip", "bles", "blocks", "b", "gb", "files", " bits", "rows", "outs", "fb", "boot", "cells", "os", "items", "values", "parts", "ones", "es", "bis", "ips", "letters", "pages", "bs", "data", "binary", "bps", "les", "s", "words", "strings", "pieces", "Bytes"], "buff": ["bo", "cast", "html", "nb", "kb", "bm", "tt", "eb", "hack", "py", "ff", "fw", "bag", "b", "bb", "uf", "cb", "agg", "txt", "buf", "pp", "gb", "abb", "cpp", "buffer", "uff", "amp", "fb", "ph", "bd", "obb", "Buff", "sb", "diff", "flat", "bug", "tmp", "fx", "app", "pb", "cp", "bis", "tf", "ob", "mb", "ctx", "bf", "batch", "Buffer", "f", "append"], "l": ["z", "lc", "j", "o", "ly", "nl", "jl", "ul", "bl", "cl", "ls", "L", "b", "lp", "c", "t", "ell", "d", "li", "pl", "lb", "fl", "p", "kl", "v", "x", "le", "il", "length", "la", "col", "lv", "h", "ln", "al", "ll", " L", "e", "ol", "el", "u", "i", "sl", "rl", "n", "dl", "lu", "f"], "hx": [" hy", "hxa", "Hrx", " hxc", "hex", "Hx", "Hwx", "Hxs", "Hc", "dhx", " hex", "hsrx", "Hxa", "hmxa", "hc", "hmxs", " hxa", " hrx", "hwx", "dhex", "hxc", "hmx", "dhc", " hc", "hmy", "hrx", " hwx", "Hex", "hsxc", " hxs", "Hxc", "hy", "dhxc", "Hy", "hxs", "hsx", "hswx"]}}
{"id1": "4593011", "id2": "7545002", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public static String POST(String url, String[][] props) throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        for (int i = 0; i < props.length; ++i) {\n            conn.addRequestProperty(props[i][0], props[i][1]);\n        }\n        conn.connect();\n        try {\n            return new String((byte[]) conn.getContent());\n        } finally {\n            conn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"loadDDL": ["loadODLL", "loadDDLL", "LoadDDML", "LoadCDLL", "loadODML", "loadSDLL", "LoadCDML", "LoadDDL", "loadSDML", "loadCDE", "loadSDL", "loadCDL", "loadSDE", "loadODE", "loadCDML", "LoadCDL", "loadDDML", "loadODL", "LoadCDE", "LoadDDE", "loadCDLL", "LoadDDLL", "loadDDE"], "stmt": ["STmr", "rdb", "Stmt", "estmt", "Stmn", "stmp", "estmr", "Stmb", "constdb", "constmt", " sttr", "Stdb", "stmd", "tm", "constmn", "strpr", "rmd", "Stmr", "Stmp", "Sttt", " sttt", "sttr", "estmp", "estm", "stmn", "STmb", "STpr", "estmb", "constm", "Stmd", "tdb", "STgr", "STmp", "stm", "tmd", "strmt", " stpr", "rmt", "sttt", "stpr", "stgr", "STtr", "estmd", "Stm", "strgr", " stm", "rm", "STmt", "strtr", "stmb", " stdb", "stdb", "esttt", "tmt", "stmr", " stgr", " stmd", " stmn"], "qry": ["eqrys", "quRY", "Qry", " qri", "quri", "quries", " qury", "qRY", "Qri", " qries", "eqRY", "equry", "Qrys", " qRY", "quury", "Qries", "eqry", "qurys", " qrys", "qrys", "qury", "qri", "qries"], "q": ["eq", " sq", "quant", "req", " p", "qq", "key", "queue", "ch", "qu", "b", " req", "c", "r", "t", "iq", "query", "k", "d", "p", "select", "ql", "v", "quest", "dq", "qs", "requ", "sq", "request", "id", "e", "qa", "qt", "Q", "i", "n", " query", "config", "f"]}}
{"id1": "13563706", "id2": "3409084", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    protected String getRequestContent(String urlText) throws Exception {\n        URL url = new URL(urlText);\n        HttpURLConnection urlcon = (HttpURLConnection) url.openConnection();\n        urlcon.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream()));\n        String line = reader.readLine();\n        reader.close();\n        urlcon.disconnect();\n        return line;\n    }\n", "label": 0, "substitutes": {"doGet": [" doGET", " doPut", "didGET", "handleget", "handleGet", "didGet", "didPut", "didget", " doget", "handlePut", "handleGET", "doPut", "doget", "doGET"], "request": ["image", "model", "method", "resource", "create", "view", "current", "event", "Response", "input", "req", "message", "queue", "remote", "info", "QUEST", "object", "application", "string", "buffer", "query", "Request", "p", "type", "attribute", "result", "frame", "client", "xml", "report", "server", "user", "data", "document", "instance", "complete", "connection", "config", "url"], "response": ["re", "onse", "image", "model", "body", "pool", "service", "resource", "index", "feed", "site", "view", "Response", "json", "reason", "http", "message", "output", "respond", "writer", "api", "object", "application", "status", "resp", "subject", "wa", "collection", "query", "result", "client", "report", "server", "document", " Response", "error", "description", "results", "res", "connection", "location", "reply", "header"], "selectedPage": ["selectionButton", "selectionHour", " selectedLine", "selectedAction", "lectedHour", "lectedSite", " selectedFile", "electedLine", "namedPage", " selectedSite", "selectedItem", "selectedHour", "selectedButton", "selectionFile", " selectedItem", "namedLine", "lectedAction", " selectedButton", "electedButton", "selectedSite", "electedPage", "lectedLine", "selectionPage", "lectedPage", "selectionpage", "selectedFile", "namedpage", " selectedpage", "namedSite", "selectedpage", "lectedFile", "lectedItem", "electedpage", "lectedpage", "lectedButton", " selectedHour", "selectedLine", "selectionItem", " selectedAction", "selectionAction", "selectionLine", "namedFile"], "page": ["model", "unit", "resource", "ice", "je", "phone", "channel", "queue", "display", "p", "result", "number", "block", "article", "ge", "layout", "per", "connection", "parent", "f", "html", "pool", "child", "account", "point", "po", "cache", "handler", "record", "ip", "peer", "language", "server", "user", "document", "instance", "plugin", "pg", "module", "change", "office", " Page", "fe", "sp", "position", "node", "type", "row", "client", "me", "photo", "Page", "port", "location", "menu", "address", "rule", "image", "section", "site", "view", "age", "message", "pp", "route", "item", "pl", "proxy", "profile", "project", "url"], "portalRequest": ["portalOrder", " portalResponse", "portallingResponse", "portpalAccess", "portugalResponse", "portallServer", "portailResponse", "portelResponse", "portalQuery", "portalAccess", "PortortalPage", "portpalPage", " portalPage", "PortortalRequest", "portallingCommand", "portALResponse", "portialQuery", "portortalAccess", " portalQuery", "portalEvent", "PortalCommand", "PortortalOrder", "PortalRequest", "portpalRequest", "portortalPage", "PortalPage", "portallingPage", "portialPage", "portalResponse", "portialRequest", "portallResponse", " portialRequest", "portelPage", "portailRequest", "PortalResponse", "portALRequest", "portugalUser", "portelCommand", "PortalEvent", " portialQuery", "PortalOrder", "portALEvent", "PortortalResponse", "portialResponse", "portortalOrder", "PortortalUser", "PortalAccess", "portugalOrder", "portbalQuery", "portbalResponse", " portialPage", "portALUser", "portortalRequest", "portortalResponse", "portalPage", "portalUser", "portelRequest", "portortalCommand", "portallingRequest", "portallRequest", "portbalPage", "portallingAccess", "portelQuery", "PortalServer", "PortortalCommand", "PortortalServer", "PortortalAccess", "PortalUser", "portortalEvent", "portailOrder", "portugalEvent", "portailUser", "portpalResponse", "portallUser", "portalCommand", " portialResponse", "portortalServer", "portbalRequest", "PortortalEvent", "portugalServer", "portugalRequest", "portalServer", "portortalUser"], "pageProp": [" pageStr", "pageprop", "PageProp", "agePro", "pluginprop", "pageProperty", "projectPro", "parentProp", "ageprop", "pluginProp", "pageStr", "PageStr", "peerStr", "parentPro", "peerPro", "parentProperty", "parentObj", "pagePro", "projectProperty", "projectprop", "resourceProperty", "resourcePro", " pageProperty", "resourceProp", "PageProperty", "pluginPro", "PageObj", "PagePro", " pagePro", "ageProperty", "resourceprop", "ageProp", "peerProperty", "projectProp", "pageObj", " pageObj", "Pageprop", "pluginProperty", "peerProp"], "possiblePage": ["possibleLine", "PossibilityPages", "patchedLine", "PossiblyLine", "pablePages", "possibilitypage", "puredPage", "possiblyPages", "PossibilityPage", "pablePage", "permanentPage", "patchingPage", "PossiblyOrder", "possibleGroup", "possiblyGroup", "patchedPage", "Possibilitypage", "possiblyOrder", "possibilityPage", "possibleOrder", "possibilityLine", "patchedOrder", "possiblypage", "possiblePages", "Possiblepage", "PossiblePage", "possibleItem", "possiblyItem", "PossibleLine", "PossibleItem", "patchingpage", "PossiblyPage", "permanentLine", "pablepage", "PossibleGroup", "puredItem", "PossiblePages", "PossiblyGroup", "permanentpage", "possiblyPage", "patchingItem", "PossiblyItem", "permanentOrder", "pableLine", "puredpage", "PossibilityLine", "possiblyLine", "patchingGroup", "puredGroup", "PossibleOrder", "patchedpage", "Possiblypage", "possiblepage", "possibilityPages"], "property": ["resource", "section", "config", "prefix", "integer", "duration", "function", "key", "properties", "label", "notation", "table", "Property", "object", "string", "class", "set", "future", "binding", "t", "p", "type", "attribute", "result", "entity", "number", "prop", "layer", "character", "expression", "name", "term", "uration", "operator", "language", "perties", "data", "binary", " Property", "variable", "value", "feature", "maximum", "profile", "project", "f", "header", "address"], "referer": ["Referer", "redrer", "Refre", "Refere", "fere", " refeline", "referers", "afferer", " refiner", "defender", " refre", "refrer", "affere", "redeline", " refrer", " referers", "rederer", " refere", "Refrer", "deferer", "defere", "defber", "defrer", "reerer", "Refender", "Refiner", "Referers", "reiner", " referen", "diffrer", "refender", "refber", "rerer", " refender", "ferers", "referen", "afferen", "diffender", "diffiner", "Referen", "reere", "redber", " refber", "Refeline", "refre", "refeline", "refiner", "frer", "differer", "ferer", "refere", "Refber", "rere", "affrer"], "e": ["err", "de", "o", "eme", "this", "event", "fe", "message", "E", "null", "element", "ed", "d", "er", "ea", "p", "ie", "type", "se", "see", "me", "es", "ception", "a", "ae", "esi", "f", "error", "i", "one", "or", "ele", "exc", "ee"]}}
{"id1": "8216539", "id2": "23370621", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileContentInStr", "getFileContentasStr", "getFileContentasStream", "getFileContentInString", "getFileContentFromStr", "getFilecontentAsStr", "getFileContentFromText", "getFileContentFromStream", "getFilecontentAsString", "getFileContentasText", "getFileContentAsText", "getFilecontentInStr", "getFileContentFromString", "getFileContentInStream", "getFileContentInText", "getFileContentAsStream", "getFilecontentInString", "getFilecontentAsStream", "getFileContentasString", "getFilecontentInStream", "getFilecontentInText", "getFilecontentAsText", "getFileContentAsStr"], "filePath": ["basePath", "singlePath", "Filepath", "FileStr", "FileUrl", "baseStr", "fileName", "resourcepath", "fileStr", "baseName", "resourcePath", " fileStr", "FilePath", "singleLocation", " fileUrl", "FileName", "singlepath", "fileLocation", "FileLocation", "resourceLocation", "singleUrl", "resourceName", "fileUrl", "basepath", "filepath", "baseLocation", " filepath", "baseUrl"], "encoding": ["decoding", "languageging", "decryption", "Encoding", "encryption", "Enclocking", "encasing", "coded", "encging", "enclocking", "languagelocking", "encoded", "Encging", "encpling", "Encasing", "languageoding", "Encoded", "Encpling", "coding", "Encryption", "languagepling", "equpling", "cryption", "equoding", "decasing", "equging", "decoded", "equlocking", "casing"], "testURL": ["appurl", "testUrl", "testingurl", "testingURL", "shortTL", "shortUrl", "testUR", "appUR", "testingTL", "shorturl", "TestUrl", "testTL", "testingURI", "testingRL", "TestUR", "fileURI", "shortURL", "testingUR", " testUrl", "appURL", " testurl", "testingUrl", "testurl", "fileURL", "appUrl", "fileUrl", "testURI", "fileRL", " testRL", " testURI", "Testurl", "testRL", " testTL", "TestURL"], "input": ["enc", "image", "ou", "flow", "in", "resource", "temp", "raw", "feed", "this", "stream", "current", "ink", "inner", "form", "inf", "dc", "audio", "acl", "Input", "entry", "active", "text", "http", "output", "api", "bin", "conn", "url", "null", "through", "act", "element", "ack", "rc", "path", "op", "type", "upload", "result", "out", "pull", "img", "client", "xml", "but", "init", "ssl", "ac", "inside", "wrapper", "data", "file", "binary", "parent", "qa", "instance", "error", "i", "reader", "get", "connection", "config", "source", "exec", "socket", "inc"], "sw": ["aw", "ib", "wb", "rx", "SW", "stream", "sk", "w", "sa", "WS", "writer", "now", "ow", "ws", "we", "ew", "wt", "wp", "rc", "sn", "wr", "wx", "work", "iw", "rew", "sc", "en", "wrap", "io", "sb", "nw", "sh", "sv", "sm", "fp", "tw", "ww", "wrapper", " SW", "sf", "hw", "Sw", "sl", "rw", "web", "cr"]}}
{"id1": "17791385", "id2": "3266833", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", "transferFile", "transferStream", "CopyFile", " copyStream", " copyfile", "Copyfile", "copyStream", "copyfile", "CopyStream", "copyFiles", "CopyFiles"], "src": ["image", "resource", "config", "stream", "inf", "input", "ls", "http", "back", "filename", "b", "sup", "url", "txt", "files", "dist", "ipl", "rc", "st", "sc", "source", "upload", "uri", "sb", "dest", "img", "ins", "sit", "sel", "file", "inst", "sl", "rb", "loc", "sin", "obj", "s"], "dst": ["ststs", "dlt", "stlt", "fdst", "pdfd", "ddfd", "Dst", " dlt", "ddst", "dsts", "fdfd", "ddest", "pdsp", "ddft", "pdst", "pdft", "Ddest", " dsts", "dfd", "dft", "stst", "fdft", "stdest", "dsp", " ddest", "Dsts", "fdsp", "Dlt", "ddsp"], "in": ["ini", "err", "kin", "login", "impl", "inner", "gin", "inn", "input", "In", "bin", "conn", "pin", "r", "IN", "again", "oin", "nin", "sin", "cin", "pull", "ins", "is", "lin", "as", "init", "socket", "inside", "h", "con", "ln", "rin", "id", "file", "data", "i", "win", "reader", "n", "m", "din", "f", "url", "inc"], "out": ["err", "o", "outer", "raw", "temp", "other", "self", "w", "plain", "at", "net", "up", "exp", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "null", "again", "outs", "part", "line", "io", "x", "Out", "client", "off", "ext", "server", "file", "parent", "ex", "i", "n", "inc", "exec", "f", "obj", "copy", "s"], "buf": ["wb", "base", "cmd", "br", "raw", "vec", "val", "bl", "ff", "cur", "count", "queue", "bag", "uf", "b", "cb", "bytes", "cat", "pad", "cap", "bin", "bh", "c", "buff", "buffer", "rc", "fd", "bb", "fb", "bf", "bd", "fl", "v", "lim", "length", "off", "loc", "data", "rb", "bc", "seq", "batch", "uc", "ctx"], "len": ["lc", "err", "base", "nt", "end", "val", "lf", "cl", "ix", "count", "rev", "l", "bin", "cap", "pos", "c", "fd", "split", "ind", "li", "fl", "en", "line", "part", "Len", "all", "lim", "le", "length", "size", "name", "ln", "data", "ll", "lt", "el", "no", "i", "sl", "n", "fin", "f", "lin"]}}
{"id1": "4973095", "id2": "1097146", "code1": "    public Wget2(URL url, File f) throws IOException {\n        System.out.println(\"bajando: \" + url);\n        if (f == null) {\n            by = new ByteArrayOutputStream();\n        } else {\n            by = new FileOutputStream(f);\n        }\n        URLConnection uc = url.openConnection();\n        if (uc instanceof HttpURLConnection) {\n            leerHttp((HttpURLConnection) uc);\n        } else {\n            throw new IOException(\"solo se pueden descargar url http\");\n        }\n    }\n", "code2": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"url": ["link", "image", "URL", "base", "resource", "lr", "www", "service", "feed", " http", "config", " web", "download", "Url", "open", "bad", "http", "use", "l", "b", "conn", "api", "full", "string", "null", " URL", "c", "r", "buffer", "ado", "path", "not", "uri", "all", "rest", "client", "xml", "ur", "ssl", "server", "host", "file", "ll", "gl", "e", "user", "u", "sl", "str", "lib", "connection", "loc", "source", "web", "address"], "f": ["fo", "fr", "fa", "fat", "inf", "w", "F", "fen", "fi", "fe", "aff", "ref", "fc", "filename", "l", "b", "info", "c", "files", "rf", "g", "buffer", "fd", "t", "d", "fb", "p", "io", "v", "x", "df", "flat", "fp", "fs", "tf", "file", "fn", "e", "sf", "fed", "u", "i", "bf", "m"], "by": ["body", "re", "log", "html", "j", "service", "in", "feed", "serv", "content", "to", "with", "open", "BY", "via", "from", "r", "buffer", "it", "v", "out", "as", "report", "ssl", "server", "By", "browser", "reader", "or", "acc", "source", "web"], "uc": ["lc", "UC", "uu", "FC", "uh", "cci", "ud", "dc", "ub", "coll", "ul", "usc", "pc", "cur", "http", "fc", "cu", "conn", "ws", "uci", "contract", "soc", "c", "cf", "ct", "rc", "BC", "sc", "ci", "https", "SC", "su", "unc", "acc", "xc", "client", "cc", "cas", "cus", "ucc", "auc", "us", "ac", "tc", "ec", "con", "cv", "cca", "mc", "u", "ru", "bc", "connection", "loc"]}}
{"id1": "14168494", "id2": "23370621", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", " copyFiles", "transferfile", " copyClass", "transferFile", " copiedfile", " copiedFiles", " copyfile", "transferClass", " copiedClass", "copyFiles", "copyfile", "copyClass", " copiedFile"], "dest": ["wb", " destination", "resource", "temp", "done", "this", " Dest", "target", "output", "later", "sup", "comb", "null", "txt", "class", "orig", "dist", "path", "d", "st", "out", "destroy", "dir", "tmp", "name", "Dest", "data", "file", "true", "transfer", "desc", "loc", "source", "obj"], "src": ["sub", "storage", "config", "stream", "download", "target", "master", "filename", "sync", "slice", "bin", "cb", "sup", "gb", "dist", "rc", "split", "st", "rob", "sc", "ds", "upload", "sb", "sin", "img", "sq", "sit", "tmp", "ssl", "Dest", "sel", "file", "inst", "sl", "rb", "loc", "source", "url", "copy", "s"], "srcChannel": ["distCh", "srcchannel", "sourceButton", "rcButton", "distChan", " srcConnection", "destchannel", "inputchannel", "srcStream", "destChannel", "rcChan", "destConnection", "inputSection", "inputChannel", "rcCh", "inputConnection", " srcChan", "rcchannel", " srcStream", "rcChannel", "srcButton", "sourcechannel", "srcSection", "srcChan", " srcchannel", "sourceChan", "distStream", " srcSection", "sourceChannel", " srcCh", "rcStream", "destChan", "srcCh", "distChannel", "rcConnection", "srcConnection", " srcButton", "rcSection"], "dstChannel": ["drdChan", " dstsConnection", "drcChannel", "dstStream", "DstChannel", "drdContext", "dDestStream", " drdContext", "dDestChannel", "dstschannel", "ddestConnection", "drcChan", "dstsConnection", "drdChannel", "ddestContext", "DdestChannel", "Dstchannel", "drdchannel", " dstschannel", "ddestVideo", "dstConnection", "dstVideo", "DstVideo", "DdestVideo", "Ddestchannel", "dstchannel", "dstsStream", " dstsChannel", "drcVideo", "ddestStream", " drdChan", "dstsChannel", " drdchannel", "dDestchannel", " dstchannel", " drdChannel", "ddestChannel", "dstChan", " dstChan", "dsrcChannel", " dstsStream", "drcchannel", "ddestChan", "dDestConnection", "dsrcVideo", " dstContext", "dsrcchannel", " dstStream", "drcContext", "ddestchannel", "dstContext", " dstConnection"]}}
{"id1": "20623709", "id2": "7911686", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"split": ["share", "format", "open", "match", "parse", "add", "process", "run", "sync", "update", "set", "sort", "join", "part", "cmp", "build", "diff", "Split", "start", "init", "archive", "transfer", "delete", "execute", "exec", "append", "copy"], "targetDirectory": ["TargetDir", " targetPath", "basePath", "destFile", "baseFolder", "targetPath", "targetRoot", "TargetDirectory", "TargetDatabase", "outputFolder", "TargetFile", "currentFolder", "TargetRoot", "masterDirectory", "currentDirectory", "targetDatabase", "currentPath", "baseDatabase", "outputDir", "targetFolder", "baseDirectory", "destDirectory", "destFolder", " targetRoot", "TargetFolder", "destDir", "masterDir", "baseFile", " targetFolder", " targetFile", "targetFile", "currentRoot", "TargetPath", " targetDir", "currentDir", "outputDirectory", "masterDatabase", "baseDir", "targetDir", "outputFile", "masterPath"], "prefix": ["folder", "unit", "index", "base", "resource", "temp", "offset", "config", "root", "fix", "sequence", "format", "pre", "domain", "patch", "Pref", "pattern", "ix", "cache", "resolution", "filename", "queue", " suffix", "prot", "string", "txt", "padding", "path", "type", "fixed", "uri", "number", "fp", "first", "name", "FIX", "username", "timeout", "template", "append", "directory"], "maxUnitBases": ["maxunitBases", "maxUnitPlases", "maxunitAliaches", "maxUnitAliails", "maxUnitBasing", "maxUnitEase", "maxUnitQueues", "maxUnitEails", "maxUnitAliases", "maxUnitAliase", "maxunitBaches", "maxUnitQuease", "maxUnitBase", "maxunitBails", "maxunitAliails", "maxUnitQueasing", "maxUnitBues", "maxUnitBaches", "maxUnitAliaches", "maxUnitBails", "maxunitBasing", "maxunitBues", "maxUnitChase", "maxUnitChases", "maxUnitAliasing", "maxunitAliase", "maxunitAliases", "maxUnitPlaches", "maxUnitEaches", "maxUnitChasing", "maxunitAliasing", "maxUnitAliues", "maxUnitChues", "maxUnitPlase", "maxUnitQueases", "maxUnitEases", "maxUnitPlails", "maxunitBase", "maxunitAliues"], "maxUnitEntries": ["maxUnitInties", "maxUnitOrdresses", "maxLineOrdines", "maxLineOrdrations", "maxUnitCountrations", "maxUnitEntryures", "maxUnitAddry", "maxUnitOrdrys", "maxUnitOrdines", "maxunitEnties", "maxunitEntrys", "maxUnitEntryries", "maxUnitAddries", "maxUnitIntrys", "maxUnitEntrys", "maxUnitAddures", "maxUnitOrdries", "maxUnitAddresses", "maxunitEntryries", "maxUnitCountry", "maxUnitEntryresses", "maxunitEntries", "maxUnitEntines", "maxUnitErries", "maxUnitEntryrys", "maxUnitErry", "maxLineOrdry", "maxunitEntryies", "maxLineEntry", "maxUnitErrations", "maxLineOrdries", "maxUnitEntresses", "maxLineEntries", "maxUnitOrdry", "maxUnitOrdrations", "maxUnitEntryry", "maxUnitErines", "maxunitEntresses", "maxUnitEntry", "maxUnitCountines", "maxLineEntrations", "maxUnitOrdies", "maxUnitCountries", "maxunitEntryresses", "maxUnitIntries", "maxUnitEnties", "maxUnitEntryies", "maxUnitIntresses", "maxUnitEntures", "maxunitEntryrys", "maxUnitEntrations", "maxLineEntines"], "fis": ["vai", " fai", " fIs", " fris", " fisc", "fisc", "forisc", "vIs", "vis", "forris", "forIs", "visa", "fIs", "foriss", "forai", "forisa", " fiss", "Fis", "fris", "fisa", "Fiss", "fiss", "foris", "Fisc", "fai", " fisa", "Fris"], "fci": ["hcos", "vai", " fai", "hco", "hai", "efco", "vcos", "fii", "efcos", " fii", "doci", "efai", "dco", "vco", "hci", "bci", "Fii", "bai", "vci", "Fis", "Foci", "dci", " foci", "efci", "bis", "Fci", "Fai", "foci", "fcos", "dii", "Fco", "bco", "fai"], "fos": ["fios", "fo", " fo", "fsios", " fcos", "tos", " fios", "toes", "infoss", "infos", "fso", "Foes", "fscos", "ifios", "foes", "fsos", "infoes", "Fos", "toss", "Fis", "ifo", "Foss", "infis", "ifos", "fcos", "tis", "ifcos", "foss"], "fco": ["hcos", "hgo", " fgo", "Fico", "dcos", "fbo", "hco", "fgo", "fileco", " fcos", "fileico", " fbo", "lci", "lco", "hci", "dco", "fileci", "dro", " fro", "Fbo", "lgo", "lcos", "dci", " fico", "filebo", "fico", "Fci", "fro", "fcos", "Fco", "lro"], "buffer": ["image", "base", "resource", "feed", "offset", "capacity", "view", "flush", "input", "entry", "channel", "window", "cache", "message", "queue", "rate", "bin", "writer", "info", "texture", "pad", "null", "scale", "buf", "read", "buff", "border", "position", "Buffer", "uffer", "translation", "result", "counter", "response", "layer", "block", "length", "context", "size", "expression", "loader", "pause", "bar", "request", "server", "data", "reference", "binary", "document", "transfer", "header", "callback", "comment", "zero", "reader", "timeout", "iter", "bc", "batch", "source", "memory", "copy", "device"], "currentBasesCount": ["currentChasesCount", "currentBatchescount", "currentChaseCount", "currentBasingNum", "currentBasingCounter", "currentBasingcount", "currentBasesCounter", "currentBasingCount", "currentBatchesCounter", "currentBatchesCount", "currentBasesNum", "currentBasescount", "currentBaseNum", "currentBaseCount", "currentChasesCounter", "currentChaseCounter", "currentChasecount", "currentBatchesNum", "currentBaseCounter", "currentChasescount", "currentChaseNum", "currentChasesNum", "currentBasecount"], "currentEntriesCount": ["currentEntrasLimit", "currentEntursOffset", "currentEnturesCount", "currentAddriesSize", "currentAddriesOffset", "currentEnturesOffset", "currentEnturesLimit", "currentEntursCount", "currentAdduresSize", "currentEntursSize", "currentEntrasCount", "currentAdduresCount", "currentAdduresOffset", "currentEntrasSize", "currentEntrasOffset", "currentEnturesSize", "currentEntriesOffset", "currentEntriesLimit", "currentAdduresLimit", "currentAddriesLimit", "currentEntursLimit", "currentAddriesCount", "currentEntriesSize"], "targetCount": ["Targetcount", "patternSize", "argetSum", "argetCount", "patternSum", "targetcount", "TargetSum", "patterncount", "argetcount", "targetSize", "patternCount", "TargetSize", "TargetCount", "targetSum", "argetSize"], "fastaChannel": ["fastABuffer", "fastanChannel", "fastasConnection", "fastanBuffer", " fastaContext", "fastasContainer", "fastaqColumn", "fastAContainer", "fastAChannel", "fastAConnection", "fastaContainer", "fastasBuffer", "fastaColumn", " fastAChannel", "fastanContainer", " fastAColumn", "fastaqBuffer", " fastAConnection", "fastAColumn", "fastasColumn", "fastaContext", "fastasChannel", "fastanContext", " fastaContainer", "fastaqChannel", "fastAContext", "fastasContext", " fastAContainer", " fastaColumn", " fastaConnection", "fastaConnection", " fastAContext", " fastABuffer", "fastaqConnection"], "totalSeqCount": ["totalSeqCounter", "totalQueQcount", "totalSeuxNum", "totalQueQNum", "totalSeqscount", "totalSeuxCounter", "totalSeuxCount", "totalQueqCounter", "totalQueqcount", "totalQueQCounter", "totalQueQCount", "totalSeQCounter", "totalSeuxcount", "totalSeqNum", "totalQueqNum", "totalSeQCount", "totalSeqsNum", "totalSeQNum", "totalSeQcount", "totalSeqsCount", "totalSeqcount", "totalSeqsCounter", "totalQueqCount"], "totalResiduesCount": ["totalResiduingcount", "totalResqueurescount", "totalResiduationCount", "totalResiduationNum", "totalResiduingCount", "totalResqueuesNum", "totalResqueuresSize", "totalResiduresNum", "totalResidurescount", "totalResiduesSize", "totalResiduresSize", "totalResiduesNum", "totalResiduationSize", "totalResiduresCount", "totalResqueuresCount", "totalResqueuesSize", "totalResiduescount", "totalResiduingSize", "totalResqueuescount", "totalResiduingNum", "totalResqueuesCount", "totalResiduationcount", "totalResqueuresNum"], "prevTime": ["PrevSize", "PrevFile", "prevSize", " prevFile", "prevValue", " prevValue", "PrevValue", " prevSize", "prevFile", "commitValue", "commitFile", "PrevTime", "commitTime", "commitSize"], "fastaFileSize": ["fastasHeaderName", "fastaBlockLength", "fastaPageSize", "fastasFileName", "fastaHeaderSize", "fastaBlockSize", "fastasFileSize", "fastaFileAddress", "fastaFileCount", "fastABufferLength", "fastAFileAddress", "fastaBufferSize", "fastaFilesName", "fastaHeaderLength", "fastaFilesAddress", "fastaFilesSize", "fastaLineAddress", "fastaBufferAddress", "fastasHeaderAddress", "fastABufferSize", "fastaLineCount", "fastaPageLength", "fastABufferAddress", "fastaFilesLength", "fastasHeaderLength", "fastaHeaderAddress", "fastaLineSize", "fastaBufferCount", "fastaHeaderName", "fastAFileLength", "fastasFileAddress", "fastaFileName", "fastaBlockAddress", "fastaFileLength", "fastasFileLength", "fastaLineLength", "fastasHeaderSize", "fastAFileCount", "fastAFileSize", "fastaPageAddress", "fastaBlockCount", "fastABufferCount", "fastaPageName", "fastaBufferLength"], "fastaFileReadOffset": ["fastaDirectoryReadOff", "fastaBufferReadoffset", "fastaFileWriteAmount", "fastaFilesWriteoffset", "fastaFilesReadLength", "fastaDirectoryWriteEntry", "fastaFileLoadOffset", "fastaDirectoryWriteOffset", "fastaDirectoryReadoffset", "fastaFileLengthoffset", "fastaFilesWriteOff", "fastaFilereadLength", "fastaFileWriteEntry", "fastaFileStartOff", "fastaFilereadoffset", "fastaFileLoadLength", "fastaFileStartOffset", "fastaFileLengthLength", "fastaBufferReadAmount", "fastaFileReadAmount", "fastaFileRunOffset", "fastaFilereadOff", "fastaFileReadoffset", "fastaFileStartoffset", "fastaFileRunoffset", "fastaFileWriteLength", "fastaFileLengthOff", "fastaFileLoadoffset", "fastaFilesReadoffset", "fastaFileReadOff", "fastaFileStartEntry", "fastaFileRunEntry", "fastaFileRunOff", "fastaBufferReadOffset", "fastaFilereadOffset", "fastaFileLengthAmount", "fastaFileWriteOffset", "fastaDirectoryReadEntry", "fastaDirectoryReadOffset", "fastaFileLengthOffset", "fastaFileReadLength", "fastaBufferReadLength", "fastaDirectoryWriteOff", "fastaDirectoryWriteoffset", "fastaFileReadEntry", "fastaBufferWriteOffset", "fastaFileLoadAmount", "fastaFileWriteoffset", "fastaBufferWriteAmount", "fastaFilesReadOffset", "fastaBufferWriteLength", "fastaBufferWriteoffset", "fastaFilesWriteOffset", "fastaFileWriteOff", "fastaFilesReadOff", "fastaFilesWriteLength"], "partitionStartOffset": ["partitionStopOrder", "partitionsStartRange", "partitionEndOrder", "partitionBufferOrder", "partitionsEndRange", "partitionEndRange", "partitionStopOffset", "partitionStopRange", "partitionsEndOffset", "partitionsEndOrder", "partitionsStartOff", "partitionStartOrder", "partitionBufferRange", "partitionsStartOrder", "partitionsStartOffset", "partitionStartRange", "partitionBufferOffset", "partitionStartOff", "partitionEndOff", "partitionsEndOff", "partitionBufferOff", "partitionStopOff"], "bufferSize": ["BufferCount", "BufferType", "BufferSize", "processC", "bufferSIZE", " bufferType", " bufferC", "processSize", " bufferCount", "BufferSIZE", "bufferCount", "queueCount", "processType", " bufferSIZE", "bufferType", "BufferC", "bufferC", "processSIZE", "queueSize"], "fastaBuffer": ["fastaPtr", "fastABuffer", "fastaBuff", "fastaQueue", " fastasFile", "FastaStream", " fastAFile", " fastasChannel", "fastanChannel", "FastasBuffer", "fastasBuff", "fastanBuffer", " fastasBuffer", "fastAPtr", "fastanQueue", "fastasContainer", "FastaBuff", "fastABuff", "fastaceChannel", "fastAContainer", "fastAChannel", "fastaContainer", "fastasStream", "fastAFile", "FastasStream", " fastaQueue", "fastasBuffer", "fastanStream", "fastasPtr", "FastasBuff", " fastAQueue", "fastaaPtr", " fastAChannel", "FastasChannel", "FastaPtr", "fastanContainer", "FastaBuffer", "fastaceBuff", "fastAQueue", "fastacePtr", "fastaceBuffer", " fastaBuff", "fastasChannel", "FastaChannel", " fastaContainer", "fastaaStream", " fastasContainer", "fastasFile", "FastasPtr", "fastanBuff", "fastaStream", "fastaaBuff", "fastasQueue", " fastABuff", "fastanFile", "fastanPtr", "fastaFile", " fastaFile", "fastaaBuffer", " fastABuffer"], "fastaReadState": ["fastaReaderMode", "fastasReaderState", "fastaReadingMode", "fastaFileState", "fastaReaderState", "fastasReaderstate", "fastaReadingstate", "fastaReadstate", "fastaReaderType", "fastaReadingType", "fastaReadingState", "fastasReaderType", "fastaReaderstate", "fastaFileType", "fastasReadType", "fastasReadstate", "fastaReadType", "fastasReadState", "fastaFileMode", "fastasReadMode", "fastasReaderMode", "fastaFilestate", "fastaReadMode"], "nBytes": ["numFrames", "pByte", "oParts", "NByte", "Nbytes", "lenFrames", "lenbytes", "nFiles", "nFrames", "NParts", " nFrames", "lenFiles", "NFiles", "nbytes", "numbytes", "obytes", "lenBytes", "numBytes", " nFiles", " nbytes", "oFiles", "pbytes", "oBytes", "pParts", " nParts", "nByte", "nParts", "numFiles", " nByte", "pBytes", "NBytes"]}}
{"id1": "13852596", "id2": "8024375", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"execute": ["register", "create", " invoke", "submit", "Exec", "ute", "parse", "load", "run", "process", "code", "apply", "all", "evaluate", "handle", " perform", "start", "report", "test", "server", "transfer", "call", "exec", "install", "copy", "invoke"], "resources": ["rings", "archives", "resource", "objects", "types", "locks", "chains", "stores", "rates", "workers", "flows", "plugins", "services", "maps", "ids", "rules", "thumbnails", "events", "roots", "files", "apps", "projects", "params", "groups", "images", "Resources", "works", "writers", "relations", "ions", "cells", "issues", "items", "series", "reports", "users", "models", "features", "pages", "stars", "classes", "results", "strings", "scripts"], "i": ["ini", "j", "o", "hi", "isi", "phi", "iri", "cli", "ii", "ir", "mu", "l", "info", "ui", "we", "ami", "ri", "pi", "gi", "ic", "abi", "li", "k", "ci", "ie", "p", "ani", "multi", "xi", "si", "io", "bi", "I", "uri", "v", "ai", "eni", "wei", "ip", "is", "ori", "esi", "h", "ti", "qi", "id", "e", "iu", "vi", "f", "u", "di", "oi", "s"], "classFile": ["CLASSFile", "sessionfile", " classClass", " classfile", "ClassEntry", "classGlobal", "packFile", "ClassGlobal", "classUrl", "staticLine", "serviceLine", " classStream", "lassFile", "classDirectory", "CLASSPage", "customEntry", "objectFile", " classFilename", "sessionFactory", "ClassFilename", "CLASSFiles", "serviceFILE", "staticFILE", " classDir", "finalfile", "finalFILE", " classFILE", " classLine", "fileLine", "CLASSLoader", "fileFiles", "ruleFilename", "classPage", "ClassDir", "sessionFile", "ClassFile", "sessionEntry", "CLASSEntry", "classFILE", "ruleLine", "objectFiles", " classFactory", "staticfile", "CLASSUrl", "CLASSfile", "classLine", "classImage", "packEntry", "ruleFiles", "classStream", "ClassPage", "fileFile", "classesPath", "classPath", "objectfile", "basefile", "servicefile", "classEntry", "sessionFiles", "ClassLine", " classPage", " classPath", "lassClass", "classesfile", "filefile", " classLoader", "packfile", "ClassFactory", "classfile", "packFILE", "ClassClass", "baseFILE", "serviceFile", "customFiles", "ClassDirectory", "classesFile", "CLASSFILE", "baseFile", "CLASSDirectory", " classEntry", "Classfile", "objectDir", "finalFile", "fileImage", " classGlobal", "classFactory", "classClass", "CLASSLine", "classFiles", "classLoader", "classesFiles", "lassFiles", "ClassFiles", "ruleFile", "ClassStream", "connectionfile", "staticFile", "ClassFILE", "customFile", "connectionFile", "ClassPath", "finalUrl", "sessionFILE", " classFiles", "classFilename", "CLASSImage", "customFILE", "connectionFiles", "lassGlobal", "fileDirectory", "classDir", "ClassImage", "connectionStream", "fileLoader", "baseUrl"], "inputStream": ["outputstream", "childStream", "inputContext", "binaryStreamer", "importStreamer", "outputSw", "outputContext", "importStream", "inputstream", "binarySteam", "binaryFile", "InputSteam", "InputFile", "importSteam", "InputSw", "InputStreamer", "uploadStream", "outputSteam", "childReader", "inputSw", "initstream", "outputReader", "initStream", "initSteam", " inputSteam", "rawSteam", "uploadstream", "activeSteam", "inputFile", "rawStreamer", "inputSteam", " inputFile", " inputReader", "activestream", "rawStream", "importstream", "activeStream", "inputStreamer", " inputContext", " inputStreamer", "inputReader", "InputStream", "uploadSw", "childstream", "outputStreamer", "initStreamer", "uploadFile", " inputstream", "childContext", "rawFile", "Inputstream", "outputFile", "activeStreamer", "binaryStream"], "reader": ["re", "right", "dr", "resource", "draft", "system", "rx", "stream", "rer", "inner", "arser", "owner", "input", "entry", "worker", "http", "parser", "ler", "reading", "rar", "key", "sync", "ger", "copy", "read", "driver", "builder", "ri", "buffer", "rc", "oder", "reflect", "handler", "er", "writers", "author", "io", "rr", "row", "director", "layer", "client", "ner", "context", "manager", "riter", "loader", "report", "Writer", "request", "wrapper", "server", "war", "seed", "Reader", "per", "shared", "keeper", "iter", "or", "source", "book", "ee", "editor"], "oldSize": ["OldName", "OldLength", "prevSize", "prevName", "prevLength", " oldSc", "oldLength", "oldName", "OldSize", " oldName", "oldSc", " oldLength", "prevSc", "OldSc"], "writer": ["writing", "her", "written", "index", "draft", "resource", "service", "child", "walker", "inner", "dc", "w", "format", "write", "player", "worker", "parser", "ler", "widget", "wer", "object", "builder", "driver", "engine", "read", "string", "r", "element", "creator", "buffer", "wr", "token", "oder", "handler", "er", "writers", "author", "winner", "io", "wire", "row", "director", "ner", "manager", "riter", "Writer", "loader", "report", "word", "wrapper", "data", "war", "document", "e", "Reader", "rw", "writ", "iter", "maker", "ee", "editor"], "b": ["base", "br", "eb", "ba", "w", "l", "bin", "bb", "object", "null", "c", "r", "buffer", "g", "d", "fb", "k", "be", "bd", "p", "boot", "db", "lb", "B", "orb", "pb", "bar", "a", "h", "binary", "ob", "e", "emb", "u", "abc", "rb", "m", "f", "ab"], "outputStream": ["outputstream", "OutputSteam", " outputSteam", "dataSteam", "inputView", "outputView", "OutputStream", "inputstream", "protectedstream", "protectedStreamer", "outputContainer", "outstream", "dataStreamer", " outputContainer", "outputSteam", " outputStreamer", "outStreamer", "inputSteam", "outSteam", "outStream", "Outputstream", "inputStreamer", "OutputView", "inputContainer", " outputstream", "outputStreamer", " outputView", "dataStream", "dataContainer", "OutputStreamer", "protectedStream", "protectedSteam"], "injectedClasses": ["injectedClasss", "injectedclassies", "injectedClassies", "injectedWrities", "injectionClassies", "injectedclasses", "injectedclasss", "injectionclasses", "injectedClassites", "injectedProjects", "injectionclassites", "injectionclassies", "injectionClassites", "injectionclasss", "injectedWritites", "injectedWrites", "injectedProjectites", "injectionClasss", "injectedProjecties", "injectedclassites", "injectedWrits", "injectionClasses", "injectedProjectes"], "newSize": [" newLength", "newFontSize", "NewLength", " newStorage", "newLength", "finalSize", "newStorage", "NewStorage", "NewFontSize", "finalStorage", "finalLength", "finalFontSize", " newFontSize", "NewSize"]}}
{"id1": "481364", "id2": "9099457", "code1": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "code2": "    public static String hash(String value) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] md5hash = new byte[32];\n            md.update(value.getBytes(\"iso-8859-1\"), 0, value.length());\n            md5hash = md.digest();\n            return Hex.encodeHexString(md5hash);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"downloadFiles": ["downloadItems", "processFiles", "uploadFiles", "DownloadFile", "DownloadItems", "downloadImages", "processItems", "processImages", "uploadFile", "uploadItems", "DownloadImages", "processFile", "downloadFile", "uploadImages", "DownloadFiles"], "downloadFilesWorker": ["downloadFilesLinker", "downloadPhotosPooller", "downloadPhotosPooler", "downloadPhotosWorkler", "downloadFilesLinkER", "downloadPhotosWorker", "downloadFilesLinkers", "downloadFilesLinkler", "downloadFilesWorkers", "downloadPhotosWorkers", "downloadPhotosWorkER", "downloadPhotosPoolER", "downloadFilesPoolER", "downloadFilesWorkER", "downloadFilesWler", "downloadFilesWers", "downloadFilesWorkler", "downloadFilesWER", "downloadPhotosPoolers", "downloadFilesWer", "downloadFilesPooler", "downloadFilesPoolers", "downloadFilesPooller"], "startDownloadDate": ["startInstallData", "startUploadStatus", "startImportTime", "startInstallTime", "startReviewData", "startDownloadTime", "StartDownloadYear", "startDownloadData", "startUploadTime", "startDownloadYear", "startPullTime", "StartDownloadTime", " startDownloadDay", "StartDownloadDate", " startUploadData", "startUploadData", "startUploadDate", "StartReviewYear", " startDownloadTime", "startUploadDay", " startDownloadStatus", "startInstallYear", "startUploadMark", "StartDownloadData", " startUploadDate", "startFileData", " startDownloadMark", "startDownloadStatus", "startReviewDate", "StartReviewDate", "startFileDate", "startImportDate", "startDownloadMark", " startUploadDay", "StartReviewTime", "startFileMark", "StartReviewData", "startReviewYear", "startImportDay", "startDownloadDay", "startInstallStatus", "startUploadYear", "startReviewTime", "startPullDate", "startPullMark", " startUploadStatus", " startDownloadData", "startImportStatus", "startPullData", "startFileTime", " startUploadMark", " startUploadTime", "startInstallDay", "startInstallDate"], "refreshSpeed": ["refreshScore", "defreshStyle", "refetchSpeed", "refractionStep", "refractionStyle", "refractionSpeed", "defractionStyle", "defractionStep", "refetchScore", "refillStep", "refetchStyle", "defreshStep", "defractionScore", "defractionSpeed", "refillSpeed", "defreshSpeed", "refreshStyle", "refetchStep", "refillStyle", "refillScore", "refreshStep", "refractionScore", "defreshScore"], "lastDate": [" lastTime", "firstTime", "LastTime", "firstData", "lastDay", " lastDay", "LastDay", "lastTime", "firstDay", "LastDate", "firstDate", " lastData", "LastData", "lastData"], "totalSizeRead": ["totalUrlREAD", "TotalNumberRead", "totalsizeRead", "totalsizeWritten", "totalStringNeed", " totalSizeREAD", "totalSizeREAD", "totalNameRead", " totalNumberREAD", "TotalNumberNeed", "totalSizeReader", "totalSectionWritten", "totalNameWritten", " totalNumberWritten", "totalNumberEx", "totalTimeWritten", "totalTimeEx", "TotalSizeRead", "totalTimeRead", "TotalSizeWritten", "totalNameNeed", "TotalSizeNeed", " totalSizeWritten", "totalNumberWritten", "totalSectionREAD", "totalSizeEx", "totalSectionRead", "totalNumberReader", "TotalNumberWritten", "TotalNumberEx", "totalStringWritten", "totalUrlReader", "TotalSizeEx", "totalUrlWritten", "totalsizeEx", "totalNumberNeed", "totalSizeNeed", " totalSizeReader", "totalStringRead", "totalSectionReader", "totalSizeWritten", " totalNumberReader", "totalNumberREAD", "totalUrlRead"], "totalNumberRead": [" totalNumberWrite", " totalSizeread", "totalSizeWrite", " totalSizeWrite", " totalnumberRead", "totalSizeread", "totalnumberFound", " totalnumberFound", "totalNumRead", "totalSizeFound", "totalNumberFound", "totalLengthWritten", " totalNumberWritten", " totalnumberread", "totalNumFound", "totalLengthread", "totalLengthRead", "totalNumWritten", " totalNumberread", "totalnumberRead", " totalNumberFound", "totalAmountWritten", " totalSizeWritten", "totalNumberWritten", "totalnumberWritten", "totalAmountRead", "totalNumread", "totalNumberread", "totalnumberread", "totalStringWritten", "totalStringread", "totalAmountread", " totalnumberWritten", "totalNumberWrite", "totalLengthWrite", "totalStringRead", "totalSizeWritten", "totalAmountWrite"], "photo": ["image", "pic", "video", " Photo", "login", " photography", "ickr", "audio", "phot", "json", "vision", "phone", "picture", "entry", "jpg", "facebook", "license", "sharing", "camera", "room", "journal", "obj", "widget", "slice", "filename", "opa", "api", "media", "member", "jp", "voice", "info", "page", "l", "pin", "collection", "item", " photos", "album", " photograph", "large", "favorite", "job", "photos", "single", "Photos", "avi", "record", "cover", "friend", "result", "gal", "student", "layer", "Flickr", "pixel", "la", "gallery", "language", "Photo", "trial", "lo", "document", " photographer", "username", "opus", "data", "person", "instance", "profile", "project", "copy"], "url": ["image", "link", "URL", "resource", "www", "system", "stream", "download", "Url", "open", "channel", "http", "l", "conn", "api", "page", "string", "position", "path", "source", "org", "uri", "out", "response", "client", "name", "socket", "ssl", "loc", "server", "user", "file", "document", "host", "sl", "contact", "config", "location", "web", "address"], "connection": ["image", "body", "URL", "in", "stream", "uno", "function", "which", "channel", "Connection", "http", "l", "conn", "api", "info", "connected", "application", "c", "position", "session", "handler", "control", "io", "uri", "out", "response", "director", "client", "context", "socket", "communication", "con", "server", "document", "connect", "reader", "database", "bc", "or", "loc", "web", "directory"], "dis": ["re", "body", "de", "service", "resource", "fr", "des", "det", "serv", "coll", "DIS", " Dis", "to", "pre", "channel", "http", "rec", "api", "conn", "ui", "info", "ws", "pos", "lib", "dist", "di", "dl", "io", "Dis", "se", "out", "dir", "con", "loc", "data", "file", "mor", "no", "reader", "res", "normal", "or", "non", "pro", "web", "device"], "fos": [" fops", "fOS", "foses", "fis", "bose", "bops", "Fou", " fose", "bos", "fou", "phOS", "phou", "baos", "pOS", "FOS", "pos", "Foses", "fose", "pou", "paos", " faos", "Fose", "faos", "phos", " foses", "Fos", "Fis", "phaos", "bis", "Faos", "fops", "Fops", "boses", " fis"], "b": ["wb", "nb", "base", "eb", "ba", "bl", "xb", "bit", "l", "bb", "bytes", "bin", "cb", "c", "gb", "r", "buff", "buffer", "split", "lb", "be", "boot", "p", "job", "sb", "v", "B", "pb", "bar", "bs", "ob", "binary", "e", "emb", "rb", "mb", "n", "bf", "batch", "br", "db", "f", "ab"], "sizeRead": [" sizeFind", "lengthReader", " sizeWalk", "stringFind", "stringRead", "SizeRead", "externalFind", "lengthPass", " sizeUse", "sizeReader", "externalReader", "sizePass", "izeIn", "izeRead", "scaleFind", "stringReader", " sizeReader", "sizeLoad", "sizeWrite", "sizeWalk", "SizeIn", "izeUse", "externalRead", "stringWrite", "lengthFind", "scaleWalk", "scaleRead", " sizePass", "nowRead", "nowLoad", "lengthLoad", " sizeIn", "nowReader", "sizeUse", " sizeLoad", "SizeWalk", "nowFind", "externalWrite", "izeReader", "SizeFind", "sizeIn", " sizeWrite", "izePass", "SizeUse", "sizeFind", "lengthRead"], "totalDiffTime": ["totaldiffCount", "totaldiffTime", "totalChangeTimes", "finalDiffCount", "totaldiffRate", "finalDiffRate", "finalDiffTime", "partialDiffSize", "totalDiffSize", "totalChangeSize", "totalChangeTime", "totalDistSpeed", "finaldiffRate", "finaldiffTime", "totaldiffTimes", "totalDeltaRate", "totaldiffSize", "partialDiffTime", "finaldiffSpeed", "totalDeltaSpeed", "totaldiffSpeed", "totalDiffSpeed", "partialDiffTimes", "totalDiffCount", "totalDiffRate", "totalDeltaCount", "totalDeltaTime", "totalDistTime", "finaldiffCount", "finalDiffSpeed", "totalDiffTimes", "totalDistCount", "totalDistRate"], "totalSpeed": ["tSpeed", "Totalspeed", "validSpeed", "totalDiff", " totalRate", "TotalSpeed", "validAverage", "TotalTime", "totalAverage", "validRate", "completeAverage", "tTime", "completeDiff", "completeSpeed", "TotalDiff", "totalRate", "tspeed", "validDiff", "totalTime", "TotalAverage", " totalspeed", "completeRate", "totalspeed", "TotalRate", " totalTime", "tRate"], "list": ["pool", "cont", "detail", "view", "coll", "LIST", "ul", "bl", "cli", "cl", "ls", "entry", "load", "slice", "queue", "stack", "l", "full", "table", "object", "page", "lp", "status", "set", "array", "left", "code", "collection", "not", "li", "st", "fl", "p", "lists", "part", "type", "record", "result", "all", "see", "la", "test", "gallery", "live", "low", "best", "layout", "complete", "batch", "source"]}}
{"id1": "13852596", "id2": "22410173", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"execute": ["register", "create", " invoke", "submit", "Exec", "ute", "parse", "load", "run", "process", "code", "apply", "all", "evaluate", "handle", " perform", "start", "report", "test", "server", "transfer", "call", "exec", "install", "copy", "invoke"], "resources": ["rings", "archives", "resource", "objects", "types", "locks", "chains", "stores", "rates", "workers", "flows", "plugins", "services", "maps", "ids", "rules", "thumbnails", "events", "roots", "files", "apps", "projects", "params", "groups", "images", "Resources", "works", "writers", "relations", "ions", "cells", "issues", "items", "series", "reports", "users", "models", "features", "pages", "stars", "classes", "results", "strings", "scripts"], "i": ["ini", "j", "o", "hi", "isi", "phi", "iri", "cli", "ii", "ir", "mu", "l", "info", "ui", "we", "ami", "ri", "pi", "gi", "ic", "abi", "li", "k", "ci", "ie", "p", "ani", "multi", "xi", "si", "io", "bi", "I", "uri", "v", "ai", "eni", "wei", "ip", "is", "ori", "esi", "h", "ti", "qi", "id", "e", "iu", "vi", "f", "u", "di", "oi", "s"], "classFile": ["CLASSFile", "sessionfile", " classClass", " classfile", "ClassEntry", "classGlobal", "packFile", "ClassGlobal", "classUrl", "staticLine", "serviceLine", " classStream", "lassFile", "classDirectory", "CLASSPage", "customEntry", "objectFile", " classFilename", "sessionFactory", "ClassFilename", "CLASSFiles", "serviceFILE", "staticFILE", " classDir", "finalfile", "finalFILE", " classFILE", " classLine", "fileLine", "CLASSLoader", "fileFiles", "ruleFilename", "classPage", "ClassDir", "sessionFile", "ClassFile", "sessionEntry", "CLASSEntry", "classFILE", "ruleLine", "objectFiles", " classFactory", "staticfile", "CLASSUrl", "CLASSfile", "classLine", "classImage", "packEntry", "ruleFiles", "classStream", "ClassPage", "fileFile", "classesPath", "classPath", "objectfile", "basefile", "servicefile", "classEntry", "sessionFiles", "ClassLine", " classPage", " classPath", "lassClass", "classesfile", "filefile", " classLoader", "packfile", "ClassFactory", "classfile", "packFILE", "ClassClass", "baseFILE", "serviceFile", "customFiles", "ClassDirectory", "classesFile", "CLASSFILE", "baseFile", "CLASSDirectory", " classEntry", "Classfile", "objectDir", "finalFile", "fileImage", " classGlobal", "classFactory", "classClass", "CLASSLine", "classFiles", "classLoader", "classesFiles", "lassFiles", "ClassFiles", "ruleFile", "ClassStream", "connectionfile", "staticFile", "ClassFILE", "customFile", "connectionFile", "ClassPath", "finalUrl", "sessionFILE", " classFiles", "classFilename", "CLASSImage", "customFILE", "connectionFiles", "lassGlobal", "fileDirectory", "classDir", "ClassImage", "connectionStream", "fileLoader", "baseUrl"], "inputStream": ["outputstream", "childStream", "inputContext", "binaryStreamer", "importStreamer", "outputSw", "outputContext", "importStream", "inputstream", "binarySteam", "binaryFile", "InputSteam", "InputFile", "importSteam", "InputSw", "InputStreamer", "uploadStream", "outputSteam", "childReader", "inputSw", "initstream", "outputReader", "initStream", "initSteam", " inputSteam", "rawSteam", "uploadstream", "activeSteam", "inputFile", "rawStreamer", "inputSteam", " inputFile", " inputReader", "activestream", "rawStream", "importstream", "activeStream", "inputStreamer", " inputContext", " inputStreamer", "inputReader", "InputStream", "uploadSw", "childstream", "outputStreamer", "initStreamer", "uploadFile", " inputstream", "childContext", "rawFile", "Inputstream", "outputFile", "activeStreamer", "binaryStream"], "reader": ["re", "right", "dr", "resource", "draft", "system", "rx", "stream", "rer", "inner", "arser", "owner", "input", "entry", "worker", "http", "parser", "ler", "reading", "rar", "key", "sync", "ger", "copy", "read", "driver", "builder", "ri", "buffer", "rc", "oder", "reflect", "handler", "er", "writers", "author", "io", "rr", "row", "director", "layer", "client", "ner", "context", "manager", "riter", "loader", "report", "Writer", "request", "wrapper", "server", "war", "seed", "Reader", "per", "shared", "keeper", "iter", "or", "source", "book", "ee", "editor"], "oldSize": ["OldName", "OldLength", "prevSize", "prevName", "prevLength", " oldSc", "oldLength", "oldName", "OldSize", " oldName", "oldSc", " oldLength", "prevSc", "OldSc"], "writer": ["writing", "her", "written", "index", "draft", "resource", "service", "child", "walker", "inner", "dc", "w", "format", "write", "player", "worker", "parser", "ler", "widget", "wer", "object", "builder", "driver", "engine", "read", "string", "r", "element", "creator", "buffer", "wr", "token", "oder", "handler", "er", "writers", "author", "winner", "io", "wire", "row", "director", "ner", "manager", "riter", "Writer", "loader", "report", "word", "wrapper", "data", "war", "document", "e", "Reader", "rw", "writ", "iter", "maker", "ee", "editor"], "b": ["base", "br", "eb", "ba", "w", "l", "bin", "bb", "object", "null", "c", "r", "buffer", "g", "d", "fb", "k", "be", "bd", "p", "boot", "db", "lb", "B", "orb", "pb", "bar", "a", "h", "binary", "ob", "e", "emb", "u", "abc", "rb", "m", "f", "ab"], "outputStream": ["outputstream", "OutputSteam", " outputSteam", "dataSteam", "inputView", "outputView", "OutputStream", "inputstream", "protectedstream", "protectedStreamer", "outputContainer", "outstream", "dataStreamer", " outputContainer", "outputSteam", " outputStreamer", "outStreamer", "inputSteam", "outSteam", "outStream", "Outputstream", "inputStreamer", "OutputView", "inputContainer", " outputstream", "outputStreamer", " outputView", "dataStream", "dataContainer", "OutputStreamer", "protectedStream", "protectedSteam"], "injectedClasses": ["injectedClasss", "injectedclassies", "injectedClassies", "injectedWrities", "injectionClassies", "injectedclasses", "injectedclasss", "injectionclasses", "injectedClassites", "injectedProjects", "injectionclassites", "injectionclassies", "injectionClassites", "injectionclasss", "injectedWritites", "injectedWrites", "injectedProjectites", "injectionClasss", "injectedProjecties", "injectedclassites", "injectedWrits", "injectionClasses", "injectedProjectes"], "newSize": [" newLength", "newFontSize", "NewLength", " newStorage", "newLength", "finalSize", "newStorage", "NewStorage", "NewFontSize", "finalStorage", "finalLength", "finalFontSize", " newFontSize", "NewSize"]}}
{"id1": "822452", "id2": "15445861", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewrites", "readAndRebwrite", "readandrewrite", "readAndSwwrite", "readAndRewwrite", "readAndSwrap", "readAndSwrite", "readandRewrite", "readAndrewrap", "readAndRewrap", "readAndRebrites", "readandrewwrite", "readAndRebrap", "readandRewrap", "readandRewrites", "readAndSwrites", "readandrewrites", "readAndrewrite", "readAndrewwrite", "readAndRebrite", "readandRewwrite", "readAndRewrites", "readandrewrap"], "inFile": ["inFilename", "loginFile", "outFilename", "inputfile", "InFiles", "InFile", " inFiles", "oldFile", "loginFilename", " inSourceFile", "outSourceFile", "InSourceFile", "inputFiles", "outFiles", "oldFiles", " inFilename", "loginFiles", "inputFile", "inSourceFile", "loginfile", "outfile", " infile", "inputFilename", "inFiles", "oldfile", "infile", "oldFilename", "Infile"], "outFile": [" outStream", "offPlace", "outFilename", " outDir", "outputPlace", "outFILE", "OutStream", "outputFilename", "newDir", " outfile", "thisFILE", "outputFile", "offFile", "outDir", "processFilename", "exfile", "exFILE", "newfile", "processPlace", "thisFile", "processFILE", "thisfile", "offFilename", "thisFilename", "outStream", "outPlace", "newFile", "exFile", "exFilename", "outfile", "outputfile", "OutFile", "outputFILE", "OutDir", "offFILE", "processFile", "newStream", "Outfile"], "iis": ["iniis", "Iiss", "iiIs", "iiIS", " iIS", " iIs", "iIs", "iniiss", "ciiss", "ciis", "Iis", "Iais", " iris", "IIS", "ciais", "ciIs", "iiss", "ciris", "iniIS", "iniIs", "iiris", "iiis", "iiiss", "ciIS", "iniris", "iais", " iiss", "iris", "iIS", " iais"], "dcmParser": ["dcmHelper", "dpmarser", "dmcPar", "dmoduleJar", "dmcJar", "dcmPar", "dbmPolicy", "dCMPlugin", "dmoduleParser", "dcmJar", "fcmHandler", "dcrPar", "fpmParser", "dmcarser", "dpmparser", "dbmHelper", "dmissionReader", "dpmLoader", " dpmLoader", "dcrReader", "dbmPlugin", "dCMParser", "dmoduleparser", "dpmPolicy", " dcrParser", "dmPlugin", "dkmHelper", "DcmInstallation", "dmmParser", "dcmparser", " dpmPolicy", " dcmPlugin", "dcmLoader", " dpmHelper", "dmLoader", "dhemReader", "dcmarser", "dpmHelper", "dbmParser", "fpmHandler", "dpmHandler", "dhemParser", "dcrJar", "dpmJar", " dcmLanguage", "fcmParser", "dcrarser", "dcmPolicy", "dkmParser", "dpmInstallation", " dpmJar", "dmodulePlugin", "dmmparser", "dcmLanguage", "dhemInstallation", "dcmInstallation", "fpmparser", "dpmParser", " dpmparser", " dcmPar", "dcmHandler", "dcrPlugin", "dmcParser", " dcmparser", "dcmReader", " dcrReader", "fcmReader", "DcmReader", " dpmPlugin", "dCMparser", "dpmLanguage", " dpmReader", "dmParser", "dmoduleReader", "dmissionPlugin", "dhemJar", " dpmPar", " dcrLoader", "dpmPar", "fpmReader", "dcrParser", "DcmJar", "dmissionParser", " dcmReader", "dCMHandler", "dpmPlugin", " dpmarser", " dpmLanguage", "dmmPlugin", " dcmarser", "dkmPolicy", " dcmHelper", " dcmLoader", "fcmparser", "dpmReader", " dpmParser", "dmReader", " dcmJar", " dcrPlugin", "dCMReader", "dmmLoader", "DcmParser", " dcmPolicy", "dkmPlugin", "dcmPlugin", "dCMLoader", "dcrLoader", "dmissionLanguage"], "ds": ["dd", "dr", "vals", "des", "ants", "os", "vs", "dc", "amps", "dat", "utils", "DS", "ls", "services", "details", "Ds", "ads", "src", "ns", "points", "sync", "ld", "conn", "js", "ws", "da", "ts", "ays", "cdn", "xs", "ps", "session", "d", "ils", "Db", "dt", "ros", "Os", "tes", "cs", "df", "uds", "dds", "ras", "eps", "gd", "ins", "iss", "qs", "is", "rs", "ys", "gs", "icks", "nas", "bs", "data", "sys", "pd", "ss", "tx", "ks", "di", "asi", "db", "parts", "drivers", "s"], "pdReader": ["ddRunner", "hdWriter", "hdLoader", "xdRead", "hdStream", "pcLoader", "pdStream", "pbLoader", "dsLoader", "pbReader", "ddLoader", "pcRead", "ddReader", "pdreader", "xdWriter", "hdReader", "hdRunner", "hdreader", "pbRunner", "ddStream", "pcWriter", "dsreader", "pdLoader", "pbStream", "dsReader", "xdReader", "hdRead", "pdRead", "pcReader", "dsRead", "xdreader", "pdRunner", "dsWriter"], "out": ["flow", "her", "model", "temp", "group", "list", "full", "page", "null", "again", "result", "img", "layer", "name", "file", "lib", "connection", "parent", "s", "device", "in", "o", "login", "outer", "child", "point", "to", "write", "cli", "over", "cache", "sync", "output", "OUT", "password", "conn", "auto", "builder", "code", "session", "pass", "outs", "doc", "io", "Out", "co", "sys", "user", "down", "copy", "err", "base", "inner", " in", "at", "exp", "later", "object", "array", "external", "line", "diff", "client", "ssl", "term", "ext", "data", "gen", "lock", "ex", "default", "inc", "db", "exec", "obj", "image", "dev", "w", "order", "with", "net", "up", "key", "writer", "store", "oder", "part", "director", "manager", "as", "word", "dot", "url"], "dcmEncParam": ["dcmEnParam", "dcmArchArg", "dcmEnPar", "dcmEnArg", "dcmDecParam", "dcmDecType", "dcmDecArg", "dcmElType", "dcmArchParameter", "dcmEncArg", "dcmEnPart", "dcmElPar", "dcmArchParam", "dcmEncType", "dcmSecParam", "dcmEnType", "dcmDecPar", "dcmEstParameter", "dcmDecParameter", "dcmEncPart", "dcmEncParameter", "dcmEstPar", "dcmEncPar", "dcmElParam", "dcmEnParameter", "dcmElParameter", "dcmEstParam", "dcmSecType", "dcmDecPart", "dcmSecPar", "dcmEstType", "dcmSecPart"], "pdWriter": ["htReader", "ddOutput", "htWriter", "hdWriter", "dpWriting", "htWrite", "dsOutput", "PDWrite", "PDWriter", "ddWrite", "ddReader", "hdReader", "pdOutput", "pdWrite", "dpReader", "dsWrite", "ddWriter", "PDReader", "PDWriting", "hdWrite", "dsReader", "pdWriting", "hdOutput", "dpWrite", "dpWriter", "dsWriter", "htWriting"]}}
{"id1": "1235538", "id2": "14231545", "code1": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 0, "substitutes": {"encrypt": ["encress", "Enccrypt", " encipher", "Encrypt", "decrypt", "encipher", "Encress", "decress", " enccrypt", "deccrypt", "decipher", " encress", "Encipher", "enccrypt"], "pass": ["Password", "parse", "text", "key", "use", "password", "wd", "post", "hash", "Pass", "pp", "act", "code", "params", "pa", "token", "path", "strip", "Secret", "phrase", "ask", "fail", "rip", "sign", "secret", "na", "auth", " password", "PASS", "request", "word", "ass", "user", "port", "ss", "ress"], "md": ["dd", "nd", "sha", "cmd", "am", "dig", "metadata", "ma", "amd", " MD", "hd", "mm", "mad", "mo", "cd", "mp", "km", "der", "grad", "mand", "d", "kg", "bd", "ad", "pm", "df", "sm", "mt", "mac", "gd", "od", "sd", " Md", "MD", "Cmd", "mod", "dh", "pd", "mag", "rm", "dm", "mc", "mb", "di", "m"]}}
{"id1": "2396191", "id2": "9236363", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksFromURLSafe", "getLinksfromURLfast", "getLinksFromStringSafe", "getLinksFromUrlfast", "getLinksfromURLSafe", "getLinksFromStringfast", "getLinksfromUrlSafe", "getLinksFromUrlSlow", "getLinksfromURLFast", "getLinksFromSSLfast", "getLinksFromSSLSlow", "getLinksfromUrlSlow", "getLinksfromUrlfast", "getLinksFromStringFast", "getLinksFromURLSlow", "getLinksFromUrlSafe", "getLinksFromStringSlow", "getLinksFromUrlFast", "getLinksfromUrlFast", "getLinksfromURLSlow", "getLinksFromURLfast", "getLinksFromSSLFast", "getLinksFromSSLSafe"], "p_url": ["pkurl", "pklink", "p_file", "e_layer", "pffile", "tp24link", "pfroot", "pxurl", "p25link", "pfpath", "p64path", "p_link", "tp24url", "ekhtml", "p9domain", "p9url", "pe_line", "piproot", "x_resource", "p__url", "x_domain", "p_page", "ekurl", " p_path", "tp24root", "p24file", "pfline", "p_root", " p_resource", "p_service", "p64line", "pe_url", "eklink", "pkhtml", "tp24file", "pamurl", "pfurl", "p25url", "p__name", "pxconfig", "p_resource", "tp_link", "pxroot", "p24url", "pe_config", "p64url", "e_html", "p__path", "pflink", "p__resource", "p_html", "p_path", "p6url", " p_name", "pfpage", " p_page", "p_layer", "pamlayer", "piplink", "p9resource", "p6config", "p_line", "eklayer", "p25html", "tp_url", "p_config", "p24link", " p_line", "pe_root", "p9service", "p_domain", "p_name", "p24root", "e_url", "tp_root", "pklayer", "p6root", "e_link", "p6line", "pxline", "x_service", "tp_file", "p64page", "pipurl", "pamhtml", "p25layer", "pamlink", "pipfile"], "x_url": ["x_host", " x_ssl", " x_log", "x_ssl", "p_loc", "p_host", "x_log", "x_loc", "p_conn", " x_resource", "x_resource"], "x_conn": ["x_conv", "x___con", "wx_cat", "x_db", "wx_conv", "x_client", "x___db", "x___conn", "x_cat", "x_con", "p_db", "p_conn", "wx_con", "wx_conn", "x___client", "p_client", "p_con"], "x_is_reader": ["x_is_writer", "x_ismldraft", "x_is_resource", "x_is_stream", "x_ismlmanager", "x_is_draft", "x_ismlstream", "x_is_manager", "x_ismlreader", "x_is_pointer"], "x_reader": ["x8reader", "x67reader", "x_stream", "cross_root", "X_result", "x24stream", "x8root", "cross8url", "X_parser", "x8url", "x8parser", "cross8reader", "cross8root", "cross_url", "x24parser", "cross8parser", "X_reader", "x67root", "cross_reader", "x67url", "x67parser", "x24result", "x24reader", "x_parser", "X_stream", "cross_parser"], "x_line": ["p_page", "x__page", "x__url", "xx_link", "xx_line", "x_comment", "x24line", "x24link", "xingcell", "xingrecord", "p_link", "xx_comment", "x_record", "x_lin", "xx_lin", "x24comment", "x_cell", "ex_record", "x__line", "ex_page", "x24lin", "ex_line", "ex_cell", "xingpage", "p_line", "x__link", "xingline"], "e": ["re", "body", "o", "eb", "end", "event", "je", "match", "entry", "fe", "ue", "exec", "ne", "E", " E", "b", "eur", "l", "engine", "code", "element", "c", "pe", "r", "driver", "ace", "g", "oe", "ze", "t", "d", "ie", "p", "ea", "line", "er", "en", "se", "eps", "v", "entity", "ce", "y", "le", "me", "eu", "edge", "es", "he", "ae", "esi", "ge", "ev", "file", "te", "ente", "el", "error", "n", "ec", "m", "ele", "f", "eve", "ee"], "x_match": ["xlgroup", "xlpattern", "ext_pattern", "ax_link", "x_tag", "x__pattern", "x5info", "xJmatch", "ax5case", " x_tag", "x_pattern", "extJpattern", "xlmember", "ax5match", "x_info", "x_member", "p_matched", "x_slice", " x_slice", "ax5link", " x__replace", "xldate", "ax_info", "e___matched", " x_replace", "xJpattern", "e_check", "x_date", "p__url", "x_matched", "e___check", "xjmatched", "x___check", "x_replace", "x__replace", "xlmatch", "p__match", "x_case", "x__match", "x__matched", "x5link", "xammatch", "x5match", "xJmember", "extJmatch", "xJsearch", "p__pattern", "xjpattern", "ax_case", "extJmember", "x_group", "xamcase", "p__matched", "x__url", "ext_member", "xamslice", "e___match", " x__case", "xlsearch", "x__case", "x__slice", " x_date", "ext_search", "x___matched", " x__slice", "e_match", "ax_match", "x_check", "xltag", "x5case", "p_match", "xjmatch", "p_pattern", " x_group", "e_matched", "e___meet", "xamreplace", "extJsearch", "x_search", "x___match", "x_meet", "x___meet", " x_case", " x__match", "ext_match", "ax5info", "e_meet", "xjurl"], "x_dir": ["x6dir", "x_file", "xnetfile", "x6group", "x6url", "xnetdir", "x6file", "x_group", "xnetgroup", " x_file", "xneturl", " x_group"], "x_root": ["x7alias", "x7directory", "x_alias", "xml_root", "xml_alias", "x7root", "xml_path", "x_directory", "x7path", "xml_directory", "x_path"], "x_links": ["x_ids", "x_lines", "x_points", "x67points", "x67ids", "x67lines", " x_ids", "x67links", " x_points", " x_lines"], "x_texts": ["x_urlls", "x_pathes", "x_urlches", "x_textes", "x_urles", "x_pathches", "x_logls", "x_paths", "x_textls", "x_logches", "x_urls", "x_pathls", "x_logs", "x_loges", "x_textches"], "x_buf": ["y__buf", "y__rc", "x__rc", "X_wb", "y_bag", "ex_buf", "y_uf", "x_wb", "X_buf", "x_buff", "x__wb", "X_buffer", "x_bag", "x___buf", "ex__tmp", "x1buf", "x__cb", "ex_tmp", "x64rc", "ex__cb", "x___uf", "X_buff", "y_rc", "x1cb", "x64bag", "x1buff", "x__buf", "x__buffer", "x_tmp", "x_cb", "ex_cb", "ex__buff", "x_rc", "x___bag", "x__uf", "x1tmp", "y_buf", "y__bag", "x64buf", "x__tmp", "y__uf", "x__buff", "x64uf", "ex_buff", "x__bag", "x_uf", "ex__buf", "x___rc", "x_buffer"], "x_matches": ["x__matures", "x_pathes", "x_attches", "x_calhes", "x_batches", "x_morched", "x_Matches", "x_patched", "x_morting", "x_calches", "x_textoms", "xKmathes", "x_locches", "x_Mathes", "x_matched", "x_matchchers", "x_batures", "x_batchers", "x_Matcher", "x_locched", "x_attcks", "x_morhes", "x_Matchers", "xKtextoms", "x__mathes", "xKmatches", "x_patches", "x_loches", "x_attched", "x_matcher", "xKtextches", "x_matcks", "x_texthes", "x_matchches", "x_matchcher", "x_matchcks", "x_Matures", "x_patcks", "x_matchched", "x_matchers", "x_matchoms", "x_caloms", "x_textings", "x_matchhes", "xKtextings", "x_locting", "x_calings", "x_matings", "x_matchings", "x_patcher", "xKtexthes", "x_atthes", "x_matting", "x_matoms", "xKmatings", "x__matchers", "x_matchting", "x_mathes", "x_bathes", "x_morches", "x__matches", "x_textches", "x_matures", "xKmatoms", "x_patchers"], "x_page": ["ex_loc", "X_page", "tx_feed", "X_path", "x_file", "X_url", "xerpage", "x67file", "xerfeed", "tx_link", "ex_file", "xerline", "tx_line", "x_feed", "tx_page", "x67page", "x67link", "ex_page", "ex_link", "x_loc", "X_line", "xerlink", "x67loc", "x_path"], "x_link": [" x_target", "xpubloc", "xpubline", "xpubtarget", "ex_page", "ex_line", "ex_link", "x_loc", " x_loc", "ex_url", "x_target", "xpublink"], "i": ["ini", "z", "index", "j", "o", "in", "oi", "chi", "hi", "phi", "ii", "ix", "count", "key", "b", "info", "ui", "iv", "ri", "pi", "c", "r", "gi", "k", "li", "ci", "p", "ie", "multi", "si", "xi", "io", "uri", "bi", "v", "x", "ai", "ji", "it", "y", "eni", "a", "ori", "ti", "qi", "id", "iu", "u", "f", "n", "di", "I", "zi"]}}
{"id1": "21488868", "id2": "23510383", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeString2File", "encodeFileFromStream", "encodeFileFromString", "encodeStringToStream", "encodeString2Files", "encodeFiletoStream", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFiles", "encodeFiletoFile", "encodeFileFromFiles", "encodeFileFromFile", "encodeString2Stream", "encodeStringToString", "encodeFileToString", "encodeFile2String", "encodeString2String", "encodeFile2File", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFile2Files", "encodeFileToStream"], "infile": [" infilename", "infiles", "Infilename", "outFile", "inputfile", "outfiles", "inFile", "InFile", "inputfilename", " infiles", " infp", "inputFile", "outfilename", "outfp", "Infiles", "inputfiles", "infp", "inputfp", "infilename", "Infile"], "outfile": ["newfolder", "outname", "outFile", " outFile", "outputfp", "outputfilename", " outfilename", "Outname", "outfolder", "outputfolder", " outfp", "Outfolder", "newfile", "newname", " outfolder", "infolder", "newFile", "outfilename", "outfp", "outputfile", "OutFile", "infp", " outname", "infilename", "Outfile"], "in": ["re", "err", "ini", "image", "base", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "vin", "m", "din", "socket", "inc", "s"], "out": ["err", "ou", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "In", "obj", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "outs", "work", "job", "source", "line", "io", "Out", "client", "off", "name", "co", "on", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "count", "cache", "slice", "queue", "b", "bytes", "bb", "null", "buf", "buff", "border", "padding", "fb", "split", "uffer", "type", "result", "len", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "input", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "close", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "model", "method", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "respons", "open", "better", "message", "growth", "modified", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "12055086", "id2": "7908169", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copydeleing", " copyDeletting", " copyDequeing", " copydeletting", " copyDequeging", " copydeletging", " copyDeleteing", " copyDeleteter", " copyDeletging", " copyDeleing", " copyDeleging", " copydeleging", " copyDequeting", " copydeletter", " copyDeleteting", " copyDequeter", " copyDeleter", " copyDeletter", " copydeleting", " copyDeleteging", " copydeleter"], "source": ["image", "base", "resource", "SOURCE", "service", "site", "storage", "view", "stream", "Source", "inner", "input", "target", "master", "src", "cache", "use", "remote", "ources", "from", "route", "path", "ie", "ource", "sin", "archive", "file", "down", "e", "reader", "i", "iter", "connection", "config", "f", "copy", "s"], "dest": ["folder", "de", "wb", "die", " destination", "slave", "temp", "done", "content", "trans", "target", "master", "src", "slice", "later", "bin", "destruct", "comb", "home", "null", "class", "orig", "exit", "dist", "path", "result", "opt", "flat", "img", "dir", "tmp", "Dest", "thin", "file", "desc", "pipe", "default", "destroy"], "buf": ["base", "cmd", "raw", "br", "feed", "vec", "config", "ff", "feat", "src", "queue", "bag", "uf", "b", "cb", "bh", "bytes", "pad", "bp", "txt", "code", "pos", "buff", "buffer", "rc", "fb", "bf", "bd", "result", "len", "img", "length", "off", "tmp", "cp", "data", "cv", "port", "rb", "uc", "seq", "batch", "loc", "ctx", "Buffer", "bc", "append"], "in": ["ini", "image", "login", "stream", "gin", "inn", "inner", "input", "din", "In", "up", "src", "bin", "b", "conn", "read", "c", "pin", "IN", "again", "tin", "plus", "p", "nin", "io", "sin", "min", "ins", "is", "socket", "init", "inside", "thin", "con", "rin", "isin", "data", "id", "file", "i", "win", "reader", "n", "exec", "f", "url", "inc"], "out": ["err", "image", "pool", "o", "outer", "inner", "w", "at", "up", "exp", "sync", "output", "OUT", "bin", "conn", "writer", "b", "buffer", "again", "outs", "part", "io", "img", "Out", "client", "app", "socket", "ext", "file", "down", "parent", "ex", "i", "win", "n", "lib", "exec", "f", "obj", "inc"], "count": ["num", "index", "base", "pool", "child", "feed", "depth", "offset", "coll", "current", "val", "zip", "cache", "key", "use", "b", "ch", "read", "code", "c", "buffer", "path", "ind", "type", "part", "allow", "len", "all", "number", "handle", "length", "close", "start", "size", "name", "sum", "id", "weight", "limit", "cond", "lock", "Count", "n", "parent", "f", "max"]}}
{"id1": "11183087", "id2": "9857412", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    @Override\n    public void writeData(byte[] data, byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        OutputStream os = urlc.getOutputStream();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        byte[] buffer = new byte[1024];\n        int br;\n        while ((br = bis.read(buffer)) > 0) {\n            os.write(buffer, 0, br);\n            if (!transferMetaData) {\n                transferredBytesNum += br;\n                elapsedTime = System.currentTimeMillis() - startTime;\n                fireOnProgressEvent(transferredBytesNum, elapsedTime);\n            }\n        }\n        bis.close();\n        os.close();\n    }\n", "label": 0, "substitutes": {"doPost": ["doPOST", "handleSearch", "doingPost", "handlePOST", "handlePost", "doingPOST", "handlePut", " doSearch", "doingPut", "doSearch", "doPut", " doPut", "doingSearch", " doPOST"], "request": ["image", "model", "right", "resource", "q", "create", "child", "view", "current", "event", "forward", "input", "order", "project", "req", "http", "message", "have", "use", "rate", "queue", "info", "post", "QUEST", "object", "remote", "application", "rf", "pe", "r", "initial", "route", "subject", "external", "state", "buffer", "query", "join", "Request", "er", "hello", "type", "result", "frame", "pull", "client", "context", "xml", "report", "the", "server", "user", "data", "e", "call", "parent", "instance", "error", "press", "web", "complete", "enter", "get", "config", "url"], "response": ["onse", "body", "model", "pool", "resource", "site", "view", "Response", "http", "message", "output", "api", "writer", "respond", "object", "page", "status", "application", "resp", "next", "result", "client", "report", "server", "document", "guide", "parent", "results", "res", "connection", "template", "web", "reply"], "senha": ["renha", "senwa", " senwa", "senlah", "zenha", "senhi", "tonHa", "zenca", " senca", "sanwa", "tonwa", "renaka", "zenhi", "sensha", "senla", "tonlah", "senaka", "suithi", " senaka", "sanha", "tonha", "snha", " senHa", "snsha", "suitsha", "zenHa", "zensha", "suitha", "zenaka", "sanHa", "sanlah", "suitla", "senca", "renca", "senHa", "zenla", "renHa", "snla", " senlah", "snhi"], "email": ["letter", "model", "mail", "service", "login", "office", "account", "Email", "mobile", "alias", "zip", "message", "label", "password", "environment", "home", "string", "example", "hello", "phrase", "line", "secret", "ip", "xml", "business", "name", "language", "server", "data", "file", "id", "user", "e", "username", "fax", "url", "address"], "messageDigest": ["messageDigher", "messageDest", "messageDigester", "messageMailester", " messagedigEST", "messageDher", "meDigEST", "messageDigEST", "messagedigend", "meDigester", "messageMailest", "medigEST", "messageMailEST", "medigher", "medigester", " messagedigester", " messageDigester", "meDigest", "medigest", " messageDend", " messageDest", "messageDend", "messageDester", "messagedigEST", "messagedigher", " messageDigend", " messageDEST", "meDigher", " messagedigest", "messagedigester", "messageDigend", "messageDEST", "messageMailend", " messageDester", "messagedigest", " messageDigEST"], "usuario": ["suuario", "usuarium", "ususariat", "usuillo", "ussuario", "ussuasio", "usueillo", " usuarium", " usuasio", "usguillo", "usituario", " usuiasio", "ususarius", "ussuarium", " usuiarium", "ususillo", "sulurio", "usuariat", " ususillo", " usuariat", "usueario", "usguarius", "usueariat", " usuarius", "usluario", "usuitario", "usuearius", " usuiario", "usuitasio", "usituarial", "usuitrio", "usguario", " usuirio", "uslurio", " ususariat", "usuarial", "suluasio", "usuarius", "usluasio", "usuiarium", "suuasio", " usuillo", "usuirio", "usuitarium", "usuiasio", "suurio", "usluarial", "usguariat", "suluarial", " usurio", "usuiario", "usurio", " ususario", "ussurio", "usuasio", "ususario", " ususarius", "suuarial", "usituasio", "ussuarial", "suluario", "usiturio"], "redirect": ["Redurl", "redrict", "predirection", "indirect", "predroute", " redition", "Redrict", "Redition", "predirect", "redirection", " redRECT", " redurl", "preduce", "Redroute", "Redirect", "RedRECT", " redirection", "induce", " reduce", "edurl", "indrict", " redrict", "reroute", "edirection", "predrict", "edition", "Redirection", "reirection", "redRECT", "rerict", "reirect", "reduce", "redroute", "predRECT", "edirect", "redition", "redurl", "indirection"], "session": ["image", "service", "child", "system", "site", "storage", "view", "event", "input", "group", "http", "message", "cache", "use", "info", "object", "page", "sp", "flash", "state", "query", "node", "result", "ession", "client", "cookie", "Session", "app", "sid", "ssl", "proxy", "server", "data", "user", "document", "browser", "comment", "sl", "person", "connection", "config"]}}
{"id1": "13852596", "id2": "397240", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"execute": ["register", "create", " invoke", "submit", "Exec", "ute", "parse", "load", "run", "process", "code", "apply", "all", "evaluate", "handle", " perform", "start", "report", "test", "server", "transfer", "call", "exec", "install", "copy", "invoke"], "resources": ["rings", "archives", "resource", "objects", "types", "locks", "chains", "stores", "rates", "workers", "flows", "plugins", "services", "maps", "ids", "rules", "thumbnails", "events", "roots", "files", "apps", "projects", "params", "groups", "images", "Resources", "works", "writers", "relations", "ions", "cells", "issues", "items", "series", "reports", "users", "models", "features", "pages", "stars", "classes", "results", "strings", "scripts"], "i": ["ini", "j", "o", "hi", "isi", "phi", "iri", "cli", "ii", "ir", "mu", "l", "info", "ui", "we", "ami", "ri", "pi", "gi", "ic", "abi", "li", "k", "ci", "ie", "p", "ani", "multi", "xi", "si", "io", "bi", "I", "uri", "v", "ai", "eni", "wei", "ip", "is", "ori", "esi", "h", "ti", "qi", "id", "e", "iu", "vi", "f", "u", "di", "oi", "s"], "classFile": ["CLASSFile", "sessionfile", " classClass", " classfile", "ClassEntry", "classGlobal", "packFile", "ClassGlobal", "classUrl", "staticLine", "serviceLine", " classStream", "lassFile", "classDirectory", "CLASSPage", "customEntry", "objectFile", " classFilename", "sessionFactory", "ClassFilename", "CLASSFiles", "serviceFILE", "staticFILE", " classDir", "finalfile", "finalFILE", " classFILE", " classLine", "fileLine", "CLASSLoader", "fileFiles", "ruleFilename", "classPage", "ClassDir", "sessionFile", "ClassFile", "sessionEntry", "CLASSEntry", "classFILE", "ruleLine", "objectFiles", " classFactory", "staticfile", "CLASSUrl", "CLASSfile", "classLine", "classImage", "packEntry", "ruleFiles", "classStream", "ClassPage", "fileFile", "classesPath", "classPath", "objectfile", "basefile", "servicefile", "classEntry", "sessionFiles", "ClassLine", " classPage", " classPath", "lassClass", "classesfile", "filefile", " classLoader", "packfile", "ClassFactory", "classfile", "packFILE", "ClassClass", "baseFILE", "serviceFile", "customFiles", "ClassDirectory", "classesFile", "CLASSFILE", "baseFile", "CLASSDirectory", " classEntry", "Classfile", "objectDir", "finalFile", "fileImage", " classGlobal", "classFactory", "classClass", "CLASSLine", "classFiles", "classLoader", "classesFiles", "lassFiles", "ClassFiles", "ruleFile", "ClassStream", "connectionfile", "staticFile", "ClassFILE", "customFile", "connectionFile", "ClassPath", "finalUrl", "sessionFILE", " classFiles", "classFilename", "CLASSImage", "customFILE", "connectionFiles", "lassGlobal", "fileDirectory", "classDir", "ClassImage", "connectionStream", "fileLoader", "baseUrl"], "inputStream": ["outputstream", "childStream", "inputContext", "binaryStreamer", "importStreamer", "outputSw", "outputContext", "importStream", "inputstream", "binarySteam", "binaryFile", "InputSteam", "InputFile", "importSteam", "InputSw", "InputStreamer", "uploadStream", "outputSteam", "childReader", "inputSw", "initstream", "outputReader", "initStream", "initSteam", " inputSteam", "rawSteam", "uploadstream", "activeSteam", "inputFile", "rawStreamer", "inputSteam", " inputFile", " inputReader", "activestream", "rawStream", "importstream", "activeStream", "inputStreamer", " inputContext", " inputStreamer", "inputReader", "InputStream", "uploadSw", "childstream", "outputStreamer", "initStreamer", "uploadFile", " inputstream", "childContext", "rawFile", "Inputstream", "outputFile", "activeStreamer", "binaryStream"], "reader": ["re", "right", "dr", "resource", "draft", "system", "rx", "stream", "rer", "inner", "arser", "owner", "input", "entry", "worker", "http", "parser", "ler", "reading", "rar", "key", "sync", "ger", "copy", "read", "driver", "builder", "ri", "buffer", "rc", "oder", "reflect", "handler", "er", "writers", "author", "io", "rr", "row", "director", "layer", "client", "ner", "context", "manager", "riter", "loader", "report", "Writer", "request", "wrapper", "server", "war", "seed", "Reader", "per", "shared", "keeper", "iter", "or", "source", "book", "ee", "editor"], "oldSize": ["OldName", "OldLength", "prevSize", "prevName", "prevLength", " oldSc", "oldLength", "oldName", "OldSize", " oldName", "oldSc", " oldLength", "prevSc", "OldSc"], "writer": ["writing", "her", "written", "index", "draft", "resource", "service", "child", "walker", "inner", "dc", "w", "format", "write", "player", "worker", "parser", "ler", "widget", "wer", "object", "builder", "driver", "engine", "read", "string", "r", "element", "creator", "buffer", "wr", "token", "oder", "handler", "er", "writers", "author", "winner", "io", "wire", "row", "director", "ner", "manager", "riter", "Writer", "loader", "report", "word", "wrapper", "data", "war", "document", "e", "Reader", "rw", "writ", "iter", "maker", "ee", "editor"], "b": ["base", "br", "eb", "ba", "w", "l", "bin", "bb", "object", "null", "c", "r", "buffer", "g", "d", "fb", "k", "be", "bd", "p", "boot", "db", "lb", "B", "orb", "pb", "bar", "a", "h", "binary", "ob", "e", "emb", "u", "abc", "rb", "m", "f", "ab"], "outputStream": ["outputstream", "OutputSteam", " outputSteam", "dataSteam", "inputView", "outputView", "OutputStream", "inputstream", "protectedstream", "protectedStreamer", "outputContainer", "outstream", "dataStreamer", " outputContainer", "outputSteam", " outputStreamer", "outStreamer", "inputSteam", "outSteam", "outStream", "Outputstream", "inputStreamer", "OutputView", "inputContainer", " outputstream", "outputStreamer", " outputView", "dataStream", "dataContainer", "OutputStreamer", "protectedStream", "protectedSteam"], "injectedClasses": ["injectedClasss", "injectedclassies", "injectedClassies", "injectedWrities", "injectionClassies", "injectedclasses", "injectedclasss", "injectionclasses", "injectedClassites", "injectedProjects", "injectionclassites", "injectionclassies", "injectionClassites", "injectionclasss", "injectedWritites", "injectedWrites", "injectedProjectites", "injectionClasss", "injectedProjecties", "injectedclassites", "injectedWrits", "injectionClasses", "injectedProjectes"], "newSize": [" newLength", "newFontSize", "NewLength", " newStorage", "newLength", "finalSize", "newStorage", "NewStorage", "NewFontSize", "finalStorage", "finalLength", "finalFontSize", " newFontSize", "NewSize"]}}
{"id1": "5760649", "id2": "400275", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createFile": [" createResource", "CreateContent", "CreateFolder", " createFolder", "CreateFile", "createContent", " createContent", "createResource", "createFolder", "saveContent", "CreateResource", "saveFile", "saveFolder", "saveResource"], "src": ["resources", "resource", "stream", "Source", "content", "input", "load", "slice", "href", "ruby", "cb", "url", "string", "txt", "buf", "gb", "files", "r", "rc", "path", "rob", "sc", "upload", "uri", "sb", "proc", "SourceFile", "dest", "img", "fp", "sit", "secure", "name", "ssl", "sel", "data", "file", "fn", "username", "rss", "sl", "rb", "loc", "source", "obj", "s"], "filename": ["wb", "resource", "prefix", "dll", "metadata", "acl", "which", "feat", "output", "l", "utf", "string", "txt", "ame", "files", "ames", "route", "path", "fil", "Filename", "source", "uri", "SourceFile", "fp", "ename", "FILE", "length", "loader", "name", "title", "nil", "file", "fn", "sf", "username", "s", "rl", "location", "f", "url", "directory"], "fis": ["sfos", "Fais", " fIS", "cfais", "cfris", " fbs", "cfis", "cfIS", "fais", "sfiss", " fiss", "Fbs", "Fos", "Fis", " fais", "cfos", "fris", "fIS", "Fiss", "sfris", "fiss", "sfis", "fbs", "FIS", "Fris", "cfbs", " fris"], "fos": ["fios", "sfios", "sfos", " fops", "fOS", "affis", "Fas", "Fbos", "bos", "Fios", " fios", "foras", "FOS", "bbos", "fbos", "foros", " fas", "Fos", "Fis", "affios", "bis", "sfis", "fops", "Fops", "affbos", "foris", "affos", "sfops", " fOS", "fas", "bios", "forOS"]}}
{"id1": "16851955", "id2": "5414088", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testTrainingBackprop": ["testTrainBackpointer", "testTrainBackdrop", "testTrainingFrontpressure", "testTrainingFrontdrop", "testTrainBACKdrop", "testTrainingBACKpressure", "testTrainingBackpressure", "testTrainingBackpointer", "testTrainBACKpressure", "testTrainingBACKprop", "testTrainBackpressure", "testTrainBACKprop", "testTrainingBACKpointer", "testTrainBackprop", "testTrainingFrontpointer", "testTrainingBackdrop", "testTrainingFrontprop", "testTrainingBACKdrop", "testTrainBACKpointer"], "temp": ["folder", "model", "base", "stable", "pdf", "storage", "this", "current", "form", "dat", "input", "zip", "cache", "http", "local", "output", "writer", "full", "txt", "font", "cel", "session", "buffer", "path", "template", "Temp", "wrap", "io", "container", "v", "dest", "flat", "out", "tmp", "save", "test", "emp", "clean", "archive", "data", "file", "porary", "parent", "lock", "fake", "empty", "ex", "tem", "pipe", "config", "mount", "f", "copy", "directory"], "layers": ["licagers", "gobs", " lients", "nlayers", "blasses", "dlasks", "lasses", " lasses", "lasks", "slayers", "bays", "bllements", "dlayers", "flanguages", "liayers", "Lients", "liores", "gients", "lobs", "players", "dlacks", "gayers", "lagers", "licibraries", " libraries", "placks", "planguages", " lays", "Lobs", "nlibraries", "lowers", "slowers", "licayers", " lowers", " lasks", " llements", "blayers", "liibraries", "flayers", "bayers", "flasses", " likes", " lagers", "blanguages", "lays", "lients", "dlores", "llements", "likes", "nlagers", "slacks", "Layers", "dlanguages", "libraries", "nlikes", "slays", " lores", "plasks", "languages", "dlibraries", "bowers", " lobs", "fllements", " languages", "lacks", "lores", "liacks", " lacks", "backs", "licikes"], "fann": ["lnn", "lann", "elfann", "xfanny", "xfann", "fnn", "sfanny", "farn", "fana", "fain", "elfarn", "xfannon", "fannon", "Fain", "gann", "lana", "garn", "Fann", "sfannon", "elfnn", "Fanny", "gana", "xfain", "fanny", "sfain", "Fannon", "larn", "elfana", "gnn", "sfann"], "trainer": ["rainer", "retacer", "trayer", "tacer", "striner", "Tracer", " tracker", "retainer", "Trrain", "strain", "traacer", "tainer", "Trayer", "triner", "Trainer", "retiner", "stracer", "trrain", "rain", " tracer", "Triner", "strainer", "stracker", "strayer", "racer", "traacker", "retayer", "tacker", "traainer", "Tracker", "tracer", "trarain", "racker", "tracker", "train", " train"], "desiredError": ["desiredSize", "reservedError", "DesireSize", "resiredError", "despectedError", "desireError", "deservedEvent", "resiredEvent", "desirableEvent", "desiringError", "designedOrder", "desirableSize", "designedError", "despectederror", "DesiredSize", "desirederror", "designedSize", "desidedFailure", "desciredFailure", "desidederror", "desivedSize", "resiredSize", "DesireException", "deservedOrder", "desizedSize", "desirableOrder", "desciredError", "despectedProblem", "resiredOrder", "despectedFailure", "DesiredException", "reservedOrder", "desiringFailure", "desiredFailure", "desivedException", "DesiredError", "desciredProblem", "desizedError", "reservedEvent", "DesireError", "descidedProblem", "desiringerror", "desiredOrder", "desiringProblem", "desidedError", "desiredException", "reservedSize", "desireException", "deservedSize", "descidederror", "descidedError", "deservedError", "desirableError", "desiredProblem", "desizedException", "designedEvent", "desidedProblem", "descidedFailure", "desireSize", "desivedError", "descirederror", "desiredEvent"], "mse": [" mge", "MSE", " mte", " mze", " mSE", "mce", "fmse", "fSE", "Mte", "Mse", " mce", "Mce", "fce", "fmte", "gmSE", "mge", "mte", "Mze", "fmze", "gmce", "fse", "gmse", "gmge", "mze", "Mge", "fge", "fmce", "mSE"]}}
{"id1": "9805906", "id2": "21656668", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"dump": ["flush", "download", "load", "zip", " dumps", "info", " dumped", "update", "files", "export", "store", " dumping", "diff", "df", "out", "Dir", "all", "dir", "ln", "data", "ump", "transfer", "println", "db", "f", "copy", "save"], "source": ["unit", "slave", "base", "service", "resource", "SOURCE", "site", "view", "stream", "Source", "current", "this", "input", "src", "http", "slice", "use", "remote", "connection", "ources", "string", "from", "core", "ource", "se", "uri", "series", "start", "server", "file", "s", "iter", "scene", "sin", "parent", "address"], "target": ["force", "base", "resource", "office", "root", "to", "alias", "effect", "Target", "top", "master", "src", "platform", "output", "table", "replace", "object", "null", "next", "path", "large", "goal", "settings", "result", "pointer", "it", "dest", "out", "enemy", "host", "file", "follow", "port", "parent", "database", "arget", "connection", "template", "project", "address"], "is": ["gets", "its", "in", "isi", "abs", "ops", "mis", "ls", "bos", "nis", "lis", "has", "info", "ui", "ws", "IS", "ps", "was", "obs", "ris", "io", "isl", "cs", "oss", "isa", "ai", "opens", "iss", "ip", "ins", "ses", "as", "iso", "bis", "es", "ens", "ori", "us", "ois", "bs", "ists", "oses", "ios", "Is", "i", "im", "ais", "or", "iris", "ics", "s"], "os": ["its", "o", "vs", "ops", "osi", "bos", "dos", "acs", "pos", "ps", "obs", "outs", "ies", "ows", "ues", "boot", "ds", "io", "ros", "Os", "nos", "oss", "cs", "fs", "cos", "oes", "as", "es", "ens", "ori", "us", "ips", "bs", "oa", "oses", "ose", "OS", "ios", "ss", "ais", "oos", "i", "ks", "ols", "or", "los", "aos", "s"], "done": ["enabled", "de", "die", "gone", "foo", "got", "current", "expected", "none", "always", "odo", "nice", "later", "doing", "after", "disabled", "Done", "did", "dad", "future", "loaded", "checked", "running", "once", "confirmed", "next", "part", "progress", "started", "finished", " finished", "yes", " Done", "defined", "dirty", "ready", "data", "last", "made", "empty", "complete", "one", "due"]}}
{"id1": "7143591", "id2": "324679", "code1": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "code2": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"getWebByUrl": ["getwebbyUrl", "getwebByurl", "getwebByLocation", "getWebFromUrl", "getWebByIdUrl", "getWebbyUrl", "getWebByIdurl", "getwebbyurl", "getWebByIdLocation", "getwebbyURL", "getWebByurl", "getWebFromURL", "getWebByLocation", "getWebFromurl", "getWebFromLocation", "getwebbyLocation", "getWebByIdURL", "getwebByUrl", "getWebbyurl", "getwebByURL", "getWebbyLocation", "getWebbyURL", "getWebByURL"], "strUrl": ["arrUrl", "srurl", "STRUrl", "strLink", "arrUr", "srURL", "stUrl", " strRoute", "STRURL", "arrPath", "STRFile", " strFile", "objUr", "objFile", "strURL", "StrPath", "strPath", "sturl", "stEmail", " strBase", "StrLink", "slUrl", "stURL", " strurl", "stFile", "slUr", "wrUrl", "StrUr", " strPath", "StrFile", "srLink", "arrURL", "wrEmail", "objURL", "strUr", "strRoute", "strFile", "StrUrl", "StrBase", " strURL", "arrurl", "wrUr", "srUrl", "StrEmail", "arrRoute", "strurl", "stUr", "STRUr", "Strurl", "StrURL", "objUrl", "StrRoute", "strBase", "slBase", " strLink", "slURL", " strUr", "strEmail", "wrURL"], "charset": ["chARSet", " Charsetting", " Charset", "chasetting", "chactersec", " ChARSet", " ChARSetting", "chacterset", "chactersetting", " ChARSec", "chasET", "chARSetting", "chasec", "chaset", "charsET", "chactersET", "charsec", "chARSET", "chARSec", " Charsec", " CharsET", "charsetting", " ChARSET"], "fileIndex": ["fileName", "FileNumber", "fileindex", "fileNumber", " fileName", "fullNumber", "FilePath", "FileIndex", " fileNumber", "fullindex", "FileVersion", "webVersion", "FileName", " fileVersion", "fileVersion", " fileindex", "Fileindex", "webIndex", "fullIndex", "webindex", "fullPath", "webName"], "url": ["link", "image", "ib", "URL", "base", "resource", "service", "www", "serv", "download", "Url", "open", "ls", "http", "zip", "l", "b", "api", "bb", "page", "string", "bel", "r", "path", "fl", "org", "uri", "blog", "client", "ur", "loader", "ssl", "proxy", "server", "host", "file", "ll", "id", "str", "sl", "connection", "config", "source", "web", "f", "address"], "conn": ["enc", "conv", "nt", "serv", "config", "w", "cli", "Url", "nc", "open", "Connection", "http", "ca", "sync", "api", "ch", "b", "l", "ann", "cb", "c", "r", "sn", "ci", "conf", "client", "ssl", "ac", "con", "cn", "server", "connect", "Conn", "n", "ctx", "cp", "connection", "loc", "exec", "f"], "is": ["err", "ib", "its", "in", "serv", "isi", "internet", "mis", "ls", "ii", "http", "src", "ir", "lis", "b", "info", "ui", "IS", "ri", "ps", "was", "li", "ie", "ris", "io", "si", "os", "it", "x", "ai", "out", "isa", "oss", "fs", "ip", "ins", "iss", "il", "as", "iso", "init", "bis", "are", "es", "us", "ssl", "h", "ob", "isc", "ios", "browser", "Is", "i", "im", "ais", "iter", "ar", "jar", "iris", "ab", "s"], "filePath": ["outputHome", "basePath", "FileHome", "FileUrl", "fileHome", "baseIndex", "FileBase", "cacheLocation", "cacheIndex", "FilePath", "cachepath", "pageIndex", " fileUrl", "fileLocation", "outputUrl", "pagepath", "pagePath", "fileUrl", "basepath", "outputBase", "outputPath", "filepath", " fileBase", "baseLocation", "pageLocation", " fileHome", "cachePath", "fileBase"], "pw": [" pv", " pW", " pws", "psw", "pwa", "spW", "Pow", " pow", " pb", "Psw", "spwb", "PW", "ppsw", "Pv", "Pwa", "ppb", "cpw", "pv", "ppW", "Pb", " pwb", "pws", " pwr", "pwr", "cpwr", "pwb", "spw", "pow", "spv", "ppws", " psw", "spow", "pb", "spws", " pwa", "ppw", "Pwb", "pW", "ppow", "cpW", "Pw", "Pwr", "ppwa", "Pws", "cpwa"], "fos": [" fops", "fOS", "fis", "fsaos", "pOS", "FOS", "pos", "fsops", " faos", "faos", "fsos", "Fos", "Fis", "Faos", "fops", "Fops", " fOS", "fsis", "pops", " fis"], "writer": ["writing", "wb", "wave", "walker", "w", "format", "write", "worker", "wer", "output", "ws", "builder", "driver", "null", "r", "wt", "store", "buffer", "wa", "fd", "wr", "handler", "er", "writers", "wrap", "io", "wire", "out", "director", "xml", "riter", "Writer", "file", "war", "reader", "rw", "writ", "angler", "ee", "editor"], "bReader": ["bbWriter", "rRead", "rWriter", "bResource", "rbRead", "bbReader", "bRead", " bWriter", "BRead", " bRead", "bbRead", "bCh", "rReader", "BResource", "bbResource", "rCh", " bResource", "rbWriter", "bWriter", "rbReader", "BWriter", " bCh", "BReader", "rbCh"], "sb": ["ib", "wb", "nb", "bsp", "kb", "bm", "zb", "SB", "sa", "xb", "src", "b", "bb", "cb", "bp", "usb", "lp", "gb", "abb", "wp", "stab", "fb", "lb", "rob", "si", "obb", "sg", "sm", "erb", "sq", "pb", "tmp", "ssl", "lab", "bps", "sf", "sth", "rb", "mb", "bg", "bf", "db", "ab"], "rLine": ["rUrl", "prLin", "rLo", "lrBlock", "rrLine", "rLin", " rBlock", "srLine", "prLine", "rWr", "rtWr", "rRange", "arline", "prBlock", "rrUrl", "rtline", " rWr", "arWr", "lrRange", "srBlock", "rrBlock", "lrLin", "srLin", " rRange", " rUrl", "rBlock", "lrLine", "rtLo", " rLo", " rline", "prRange", " rLin", "srUrl", "arLo", "rtLine", "arLine", "rline", "rrLin"], "tmp_rLine": ["tmp_errLine", "tmp_lLetter", "tmp_prSe", "tmp_brLetter", "tmp_rBlock", "tmp_RSe", "tmp_rbline", "tmp_lFile", "tmp_brLine", "tmp_roRecord", "tmp_prLine", "tmp_errline", "tmp_rLink", "tmp_RValue", "tmp_rnCopy", "tmp_RItem", "tmp_RRecord", "tmp_lPage", "tmp_rbLine", "tmp_nrline", "tmp_rItem", "tmp_rPage", "tmp_rtline", "tmp_rnline", "tmp_vrline", "tmp_vrLine", "tmp_vrLink", "tmp_rnLink", "tmp_rLetter", "tmp_roSe", "tmp_errLink", "tmp_lBlock", "tmp_rRecord", "tmp_nrLine", "tmp_roFile", "tmp_roPage", "tmp_RFile", "tmp_Rline", "tmp_rbItem", "tmp_rline", "tmp_RLine", "tmp_prFile", "tmp_RLetter", "tmp_lLine", "tmp_rbBlock", "tmp_RBlock", "tmp_rtLine", "tmp_rtItem", "tmp_nrFile", "tmp_RPage", "tmp_lRecord", "tmp_roValue", "tmp_roLine", "tmp_errCopy", "tmp_rnLine", "tmp_rValue", "tmp_brFile", "tmp_rtBlock", "tmp_rCopy", "tmp_prValue", "tmp_vrCopy", "tmp_rSe", "tmp_nrBlock", "tmp_roBlock", "tmp_rFile"], "str_len": ["str_length", "str64pos", "str_ln", "str5ler", "stri5ler", "dr_Len", "str5pos", "stri_pos", "dr_length", "str2len", "str5lin", "str64ler", "stri_len", "stri5len", "dr_len", "stri5lin", "stri_ler", "str64len", "str_pos", "str2ler", "stri5pos", "str5len", "str_Len", "str64lin", "str2pos", "stri_lin", "str_ler", "str_lin", "dr_ln", "str2lin"]}}
{"id1": "3330775", "id2": "620855", "code1": "    public static JSONObject getJSONData(String url) throws JSONException {\n        JSONObject jObject = null;\n        InputStream data = null;\n        DefaultHttpClient httpClient = new DefaultHttpClient();\n        URI uri;\n        try {\n            uri = new URI(url);\n            HttpGet httpGet = new HttpGet(uri);\n            HttpResponse response = httpClient.execute(httpGet);\n            data = response.getEntity().getContent();\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader;\n            reader = new BufferedReader(new InputStreamReader(data), 8192);\n            while ((line = reader.readLine()) != null) builder.append(line);\n            reader.close();\n            jObject = (JSONObject) new JSONTokener(builder.toString()).nextValue();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return jObject;\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"getJSONData": ["getJObject", "loadJData", "loadJSONResponse", "getJSONObject", "getjsonObject", "getJResponse", "getJSObject", "getjsonData", "getJSResponse", "loadJSONData", "getJSONResponse", "loadJdata", "getJdata", "getJSData", "getJSdata", "getJData", "loadJSONdata", "loadJObject", "loadJSONObject", "loadJResponse", "getjsonResponse", "getjsondata", "getJSONdata"], "url": ["image", "html", "URL", "base", "resource", "feed", "coll", "input", "Url", "json", "ls", "http", "filename", "href", "l", "api", "full", "style", "string", "buffer", "route", "path", "source", "xml", "ur", "name", "ssl", "request", "proxy", "server", "id", "file", "ll", "host", "username", "str", "sl", "i", "connection", "like", "location", "address"], "jObject": [" jData", "jData", "JObject", "jobobject", "jiData", "ojobject", "ojJSON", "Jobject", "jiObject", "jobData", "JObj", "jobject", "JJSON", "jJSON", "jObj", " jObj", "jobObject", "jiobject", "ojObject", "jobObj", " jobject", "JData", " jJSON", "jiJSON", "ojData", "ojObj"], "data": ["dd", "body", "image", "html", "base", "resource", "feed", "storage", "done", "stream", "content", "to", "dat", "input", "json", "download", "plain", "entry", "zip", "message", "cache", "load", "text", "slice", "api", "writer", "info", "media", "bytes", "post", "style", "buffer", "handler", "DATA", "ad", "part", "record", "result", "client", "as", "memory", "server", "file", "error", "i", "results", "database", "partial", "source", "address"], "httpClient": [" httpCall", "urlclient", "urlCl", "Httpclient", "HttpCl", "HttpGet", "HttpConnect", "ttpClient", " httpC", "httpC", "HttpCall", "ttpCall", "httpConnect", "HttpC", " httpCl", "httpclient", "urlClient", " httpConnect", "urlConnect", "HttpClient", "ttpC", "httpCall", " httpclient", "ttpGet", "httpCl"], "uri": ["mi", "folder", "base", "service", "resource", "API", " URI", "iri", "cli", "http", "cache", "api", "ui", "string", "ri", "pi", "route", "query", "handler", "source", "uni", "si", "io", "client", "URI", "ur", "request", "qi", "server", "file", "id", "reference", "absolute", "range", "i", "database", "connection", "location", "address"], "httpGet": ["HttpGet", "jsonGet", "apiReturn", " httpget", "httpReturn", "jsonClient", "httpPut", "apiClient", "ttpQuery", "jsonget", "apiget", " httpQuery", "HttpPut", "jsonReturn", "httpget", " httpReturn", "httpQuery", "ttpPut", "apiGet", "HttpQuery", " httpPut", "ttpGet"], "response": ["body", "onse", "resource", "feed", "stream", "Response", "json", "http", "message", "output", "api", "writer", "respond", "object", "page", "status", "resp", "next", "query", "result", "client", "report", "received", "request", "server", "file", "document", "e", "results", "res", "connection", "reply"], "line": ["link", "letter", "lc", "unit", "base", "feed", "end", "liner", "point", "content", "val", "lf", "cl", "lines", "entry", "inline", "LINE", "text", "message", "Line", "key", "column", "l", "object", "page", "style", "string", "code", "buffer", "pass", "li", "type", "part", "len", "number", "row", "layer", "ip", "le", "character", "lin", "name", "file", "jo", "cell", "e", "char", "id", "str", "el", "i", "one", "comment", "header"], "builder": ["letter", "base", "address", "office", "inner", "ener", "entry", "worker", "up", "parser", "Builder", "writer", "b", "object", "null", "string", "driver", "array", "r", "creator", "buffer", "oder", "built", "handler", "er", "builders", "type", "result", "obb", "build", "sb", "number", "row", "layer", "length", "runner", "wrapper", "building", "keeper", "database", "iter", "or", "db", "upper", "editor"], "reader": ["resource", "feed", "rx", "stream", "rer", "input", "ry", "entry", "worker", "parser", "reading", "ler", "rar", "bird", "writer", "finder", "read", "ri", "driver", "r", "buffer", "ro", "oder", "handler", "er", "io", "rr", "rh", "row", "ra", "client", "ner", "loader", "runner", "server", "file", "iterator", "Reader", "i", "per", "keeper", "iter", "or", "source", "editor"]}}
{"id1": "13499897", "id2": "8150996", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"CopyFile": ["CreateFolder", " CopyDir", "CopyFolder", "CreateFile", "Createfile", " copyFile", " CopyFolder", " copyDir", "CreateDir", " copyfile", "Copyfile", "CopyDir", " copyFolder", " Copyfile"], "sourcefile": ["destfilename", "configlog", "destFile", "deststream", " sourceFile", "configstream", "sinstream", "configFile", "sinFile", "sourcefilename", "Sourcefilename", "sourceFile", "SourceFile", "configfile", "sinlog", "Sourcef", "sourcestream", "Sourcefile", " sourcefilename", "sourcelog", "sinfile", "destf", " sourcef", "sourcef", "destlog"], "destfile": ["destfilename", "sourcestring", "tempFile", "destFile", "DestFile", "targetfilename", "tempfile", "buildfile", "srcfilename", "srcpath", "destroypath", "Destfilename", " desturl", "newfp", "desturl", "tempfilename", "destfp", "targeturl", "deststream", "newfilename", "Destpath", "tempstream", " deststring", "destroyfile", " destFile", "Desturl", "newfile", "buildstring", "srcstream", "deststring", "sourcefilename", "sourceFile", "targetfile", " destpath", "targetFile", "temppath", "destroystream", " destfp", "newFile", "destroyfilename", "Destfp", "srcfile", "destpath", "srcFile", "buildFile", "Destfile", "buildfilename", "targetpath", "sourcepath", " destfilename"], "last": ["nd", "right", "base", "child", "end", "depth", "offset", "latest", "current", "event", "cur", "count", "total", "key", "use", "later", "full", "cat", "after", "left", "style", "code", "from", "route", "core", "path", "next", "recent", "part", "Last", "se", "real", "prev", "first", "ending", "length", "size", "start", "range", "value", "empty", "old", "or", " Last", "max", "ast"], "parent": ["unit", "base", "child", "temp", "section", "point", "root", "fat", "current", "content", "po", "function", "patch", "target", "anc", "exp", "text", "cache", "filename", "key", "remote", "api", "post", "Parent", "home", "string", "null", "pa", "path", "next", "ant", "p", "line", "parents", "part", "pointer", "and", "dest", "mac", "ip", "name", "location", "test", "ac", "search", "data", "file", "id", "valid", "port", "shared", "partial", "loc", "source", "url", "ppa"], "f": ["folder", "j", "base", "o", "feed", "of", "found", "self", "fa", "inf", "lf", "F", "fe", "ref", "fc", "l", "b", "full", "c", "cf", "r", "g", "fd", "t", "d", "fb", "p", "v", "df", "flat", "fp", "fs", "dir", "h", "file", "af", "e", "sf", "i", "m", "s"], "srcChannel": ["srcchannel", " srcConnection", "destchannel", "rcClient", "destChannel", "rcChan", "destConnection", " srcChan", "rcchannel", "sourcechannel", "rcChannel", "srcChan", " srcchannel", "sourceChan", " srcClient", "sourceConnection", "sourceChannel", "destClient", "destChan", "srcClient", "rcConnection", "srcConnection"], "dstChannel": ["drcChannel", "idrcButton", "DstContext", "idstchannel", "DstChannel", "DestChan", "dstschannel", "destchannel", "DstChan", "drcChan", "DestContext", "dstsChan", "idstChan", "ddestContext", "dstButton", "DstBuffer", "destChannel", "dstBuffer", "Dstchannel", "dntChan", "ddestBuffer", "DestBuffer", "idrcChan", "idrcChannel", "dntBuffer", "dstchannel", "destBuffer", "dstsChannel", "drcButton", "idrcchannel", "destContext", "idstChannel", "dsrcChan", "dntContext", "dstChan", "ddestChannel", "destButton", "idstButton", "ddestChan", "drcchannel", "dsrcChannel", "destChan", "dsrcButton", "dsrcchannel", "Destchannel", "DestChannel", "dstContext", "dntChannel"]}}
{"id1": "9319440", "id2": "18748516", "code1": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"load": ["link", "resource", "create", "check", "download", "open", "find", "show", "update", "read", "loaded", "LOAD", "work", "upload", "loading", "start", "loader", "init", "dump", "file", "transfer", "Load", "loads", "get", "install", "library"], "id": ["image", "link", "plugin", "base", "resource", "create", "root", "json", "bid", "kid", "ids", "text", "filename", "key", "info", "uid", "string", "code", "did", "token", "path", "pid", "type", "ID", "uri", "aid", "Id", "ip", "is", "start", "name", "sid", "request", "file", "data", "i", "source", "f"], "xml": ["image", "model", "html", "log", "dr", "email", "expl", "feed", "www", "raw", "impl", "stream", "wl", "xxx", "content", "sheet", "event", "ul", "audio", "write", "json", "input", "plain", "entry", "zip", "http", "text", "parser", "java", "writer", "full", "ws", "page", "string", "element", "txt", "form", "spec", "path", "work", "job", "doc", "line", "ml", "x", "response", "layer", "bug", "name", "ssl", "request", "server", "file", "document", "data", "layout", "php", "el", "enter", "web", "address"], "url": ["image", "log", "URL", "base", "resource", "service", "feed", "www", "stream", "download", "Url", "open", "channel", "http", "zip", "l", "b", "bb", "api", "page", "string", "db", "org", "uri", "build", "layer", "blog", "client", "loader", "socket", "ssl", "tool", "server", "file", "ll", "gl", "ob", "user", "connect", "browser", "sl", "connection", "config", "source", "web", "f", "address"], "conn": [" manager", " con", " factory", "Url", "nc", " net", "Connection", "http", "l", "ch", " conf", "c", "r", " mc", "er", "ci", "io", " pool", " db", "client", "loader", "ssl", " connection", "con", " internet", " auth", "Conn", "connection"], "reader": ["err", "dr", "lr", "feed", "rx", "stream", "rer", "inner", "input", "worker", "rt", "http", "reading", "parser", "ler", "rar", "bird", "l", "writer", "finder", "read", "ri", "driver", "builder", "r", "buffer", "rc", "oder", "handler", "er", "io", "rr", "uri", "row", "ner", "loader", "hr", "server", "ser", "iterator", "Reader", "i", "iter", "connection", "f", "editor"], "str": ["enc", "err", "lc", "in", "dr", "fr", "kr", "coll", "val", "input", "arr", "cl", "entry", "text", "l", "STR", "pr", "string", "read", "code", "txt", "r", "t", "tr", "wr", "strip", "st", "er", "stri", "p", "line", "doc", "dict", "x", "sr", "data", "inst", "char", "e", "Str", "sl", "i", "iter", "br", "cr", "f", "obj", "s"]}}
{"id1": "23008590", "id2": "3536332", "code1": "            public void run() {\n                URL url;\n                try {\n                    url = new URL(Config.UPDATE_SITE_URL);\n                    InputStream is = url.openStream();\n                    Writer writer = new StringWriter();\n                    char[] buffer = new char[1024];\n                    Reader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n                    int n;\n                    while ((n = reader.read(buffer)) != -1) {\n                        writer.write(buffer, 0, n);\n                    }\n                    String updatePage = writer.toString();\n                    is.close();\n                    writer.close();\n                    System.out.println(\"DOWNLOAD PAGE :\\n\" + updatePage);\n                    int pos1 = updatePage.indexOf(\"[ANA-CABV]\") + 10;\n                    int pos2 = updatePage.indexOf(\"[/ANA-CABV]\");\n                    int pos3 = updatePage.indexOf(\"[ANA-CABVURL]\") + 13;\n                    int pos4 = updatePage.indexOf(\"[/ANA-CABVURL]\");\n                    String currentVersion = updatePage.substring(pos1, pos2);\n                    currentVersionLabel.setText(currentVersionLabel.getText() + currentVersion);\n                    if (Double.valueOf(Config.VERSION) < Double.valueOf(currentVersion)) {\n                        downloadButton.setEnabled(true);\n                        label0.setText(mw.getLangMap().get(\"Update_Avalaible\"));\n                    } else label0.setText(mw.getLangMap().get(\"Update_NonAvalaible\"));\n                    downloadURL = updatePage.substring(pos3, pos4);\n                } catch (MalformedURLException e) {\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"run": ["login", "submit", " Run", "launch", "up", "load", "process", "output", "Main", "java", " deploy", "info", "update", "apply", "running", "work", "build", "start", "report", "init", "test", "server", "Run", "execute", "exec", "install"], "url": ["image", "URL", "base", "resource", "service", "feed", "lr", "www", "download", "Url", "hub", "http", "l", "api", "page", "update", "string", "r", "bel", "path", "uri", "blog", "il", "ur", "article", "loader", "name", "ssl", "location", "proxy", "loc", "server", "host", "file", "id", "browser", "str", "sl", "i", "keeper", "config", "source", "web", "f", "address"], "is": ["ini", "err", "image", "its", "in", "address", "stream", "isi", "ls", "http", "src", "ir", "lis", "has", "api", "info", "ui", "IS", "iv", "ri", "r", "was", "ie", "ris", "io", "os", "uri", "it", "ai", "out", "fs", "ip", "iss", "il", "as", "es", "app", "bis", "id", "ios", "browser", "Is", "i", "ais", "iterator", "iter", "or", "ar", "s"], "writer": ["writing", "letter", "written", "in", "temp", "feed", "walker", "w", "write", "player", "worker", "zip", "parser", "ler", "widget", "wer", "key", "journal", "ws", "page", "string", "driver", "builder", "null", "r", "creator", "wr", "work", "handler", "er", "writers", "winner", "wire", "out", "director", "layer", "ner", "riter", "Writer", "word", "server", "data", "file", "war", "maker", "writ", "source", "parent", "ee", "editor"], "buffer": ["base", "resource", "wave", "feed", "sequence", "player", "cache", "slice", "queue", "stack", "bin", "b", "bytes", "page", "string", "read", "buf", "buff", "position", "border", "vector", "padding", "Buffer", "uffer", "phrase", "counter", "result", "row", "layer", "block", "length", "character", "data", "binary", "seed", "char", "transfer", "iter", "batch", "source", "memory", "address"], "reader": ["in", "dr", "rx", "stream", "rer", "input", "worker", "reading", "ler", "rar", "parser", "ir", "bird", "read", "ri", "r", "oder", "handler", "er", "io", "rr", "row", "ner", "loader", "e", "ser", "iterator", "Reader", "i", "per", "iter", "source", "f", "editor"], "n": ["z", "num", "j", "nb", "o", "nt", "nor", "nl", "N", "nc", "ns", "ne", "count", "l", "b", "pos", "c", "r", "t", "sn", "k", "d", "not", "p", "en", "nin", "len", "x", "number", "out", "nn", "nr", "y", "ner", "na", "h", "e", "dn", "u", "no", "i", "ng", "m", "f", "s"], "updatePage": ["updateSite", " updateSite", "currentSite", "updatedpage", "currentpage", " updatepage", " updateUrl", "updatedPage", " updateServer", "updatepage", "UpdatePage", "downloadVersion", " updateLine", "updateVersion", "downloadPage", "updatedLine", "currentPage", "updateServer", "Updatepage", "currentUrl", "currentServer", "updateLine", "downloadUrl", "updateUrl", "workSite", "workLine", "updatedVersion", "downloadLine", "downloadpage", "UpdateVersion", "updatedFile", "updateFile", " updateFile", " updateVersion", "workPage", "updatedServer", "UpdateUrl", "currentLine", "UpdateFile", "updatedUrl"], "pos1": ["Pos4", "position4", "POS3", "position2", "POS0", " posOne", "posOne", "POS1", "Pos1", "Pos2", "position1", "Pos3", "pos0", " pos0", "position3", "POSOne", "position0", "positionOne"], "pos2": ["index5", "posSecond", "positionSecond", "index1", "POS22", "POS2", "indexSecond", "index4", "position2", " posSecond", "POS5", "po4", "po5", "pos5", "index2", "POS4", "position1", "index3", "po2", "position3", "po22", "index22", "pos22"], "pos3": ["pose3", " pos03", "pos43", "position2", "pose43", "pose2", "pose1", "Pos1", "position43", "Pos2", "position03", "Pos43", "position1", "Pos3", "position3", "Pos03", "pos03"], "pos4": [" pos7", "position4", "pose04", "pos7", "index4", "position2", "pofour", "pos04", " pos04", "po1", "po04", "posefour", "po4", "pose1", "index7", "index2", "pose4", "position7", "index3", "position3", "posfour", " posfour"], "currentVersion": ["initialVersion", "initialPackage", "CurrentPage", " currentPatch", "CurrentPatch", "currentName", "CurrentName", "reportedPatch", " currentPage", "CurrentVersion", "currentVer", "updateVersion", " currentName", "currentPage", "initialVer", "updateRelease", "CurrentRelease", "currentUrl", "CurrentPackage", "CurrentVer", " currentPackage", "updateVer", "reportedVersion", "reportedName", "initialPage", " currentUrl", "reportedUrl", "CurrentUrl", "currentPatch", "updatePackage", " currentRelease", "currentPackage", "currentRelease"], "downloadURL": ["installLocation", " downloadLocation", "installUrl", " downloadUrl", "installURL", "downloadLocation", "updateURL", "downloadUrl", "updateLocation", "updateUrl"]}}
{"id1": "17161805", "id2": "12417893", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"encode": ["enccode", "enccod", "encod", "recod", "Enode", "reoding", "recode", "encoder", "enscode", "encoding", "Enoder", "Enoding", "ensoder", "enscod", "enoder", "ensode", "reode", "enode", "Encode", "enoding", "Encod"], "plaintext": ["longform", "plainText", "batTEXT", " plaincontent", " plainstring", "batText", "battext", " plainText", "foreTEXT", " plainform", "plaincontent", "bodyText", " plainTEXT", "plainform", "longcontent", "foreText", "longText", "foretext", "longtext", "forestring", "bodycontent", "plainTEXT", "bodytext", "batstring", "bodyform", "plainstring"], "md": ["dd", "sha", "cmd", "meta", "metadata", "ma", "amd", " MD", "po", "hd", "mm", "um", "mad", "cd", "ms", "wd", "mp", "code", "grad", "mand", "d", "ind", "bd", "ad", "pm", "df", "sm", "mac", "gd", "od", "me", "MD", "mod", "dh", "pd", "mag", "rm", "dm", "mc", "mb", "di", "m", "rpm", "f"], "raw": ["enc", "dec", "Raw", "ghost", "ode", " Raw", "feed", "stream", "hex", "input", "serial", "alpha", "load", "local", " hex", "remote", "blocks", "array", "orig", "initial", "buffer", "pure", "ack", "custom", "rew", "original", "all", "out", "row", "micro", "block", "missing", "pack", "unsigned", "clean", "internal", "binary", "RAW", "unknown", "instance", "shared"]}}
{"id1": "22977189", "id2": "742465", "code1": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"in": ["re", "err", "ini", "image", "login", "this", "gin", "inner", "inn", "input", "In", "up", "bin", "b", "url", "read", "c", "r", "IN", "g", "again", "pass", "er", "plus", "source", "nin", "cin", "min", "ins", "is", "as", "lin", "init", "inside", "con", "ln", "isin", "data", "id", "i", "win", "reader", "n", "din", "f", "socket", "inc"], "out": ["flow", "temp", "window", "list", "page", "again", "query", "strip", "block", "name", "file", "call", "comment", "connection", "parent", "f", "editor", "s", "log", "pool", "o", "outer", "this", "point", "flush", "write", "cache", "sync", "output", "OUT", "password", "bin", "b", "conn", "r", "outs", "io", "Out", "app", "init", "server", "user", "error", "copy", "err", "prefix", "self", "inner", "at", "object", "client", "off", "ext", "data", "ex", "default", "inc", "exec", "obj", "raw", "w", "plain", "up", "key", "writer", "part", "as", "a", "word", "n"], "line": ["rule", "letter", "log", "link", "lc", "unit", "feed", "end", "content", "lf", "write", "cl", "lines", "inline", "entry", "LINE", "text", "message", "Line", "key", "column", "l", "page", "style", "string", "code", "c", "pe", "pass", "next", "row", "character", "block", "name", "word", "data", "file", "id", "cell", "char", "header", "lock", "str", "comment", "i", "sl", "value", "source", "f", "url", "lin"]}}
{"id1": "21754659", "id2": "4938100", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"getButtonSonido": ["getButtonJonido", "getButtonJonendo", "getButtonSenico", "getbuttonSenendo", "getButtonJonico", "getbuttonSenira", "getButtonSenido", "getButtonSonendo", "getButtonJonira", "getbuttonSenico", "getButtonSonira", "getbuttonSonido", "getbuttonSonendo", "getbuttonSonira", "getButtonSenira", "getButtonSenendo", "getbuttonSonico", "getbuttonSenido", "getButtonSonico"], "buttonSonido": ["buttonDonino", "btnDonido", "buttonHonido", "ButtonSonida", "buttonSonida", "buttonHonardo", "buttonSenida", "ButtonSonado", "btnSonido", "ButtonDonida", " buttonSenino", "buttonHomido", "buttonsonardo", "buttonSonini", " buttonSonino", " buttonSenado", "buttonTanida", " buttonSenida", "ButtonDonini", "btnSonigo", "buttonsonado", " buttonSenardo", "buttonTanado", "btnDonado", "ButtonSonardo", "buttonHomardo", "ButtonSonini", "buttonHonino", "buttonDonido", "btnDonardo", "buttonHomida", "buttonHonado", "buttonDonini", "buttonDonardo", "buttonSenado", "ButtonDonado", "buttonHomado", " buttonSenido", "buttonSenardo", " buttonSonardo", "buttonSonino", "btnDonigo", "btnSonini", "buttonDonigo", "buttonDonado", "ButtonDonardo", "buttonTanardo", "buttonSenino", "btnSonado", "buttonSonado", "btnSonardo", "ButtonSonido", "buttonsonido", "ButtonDonido", "buttonSenini", "buttonSenigo", "buttonSonardo", "buttonTanido", "buttonsonigo", "buttonSonigo", "buttonSenido", " buttonSonida", "buttonDonida", "buttonsonini", " buttonSonado"], "e": [" ate", " fe", "event", " cause", " Event", " other", " pe", "E", " events", " E", " exc", "ed", " invoked", "t", " caught", " en", " inst", " ev", " ie", " te", " exception", " je", " exp", "Event", " ace", " ignored", "ee"], "fc": ["enc", "lc", "Factory", "fr", "FC", "fa", "dc", "lf", "fm", "F", "nc", "pc", "fe", "FS", "fi", "WF", "fw", "wic", "xf", "roc", "GF", "cf", "c", "wt", "ct", "fd", "irc", "fb", "fl", "flo", "wk", "CF", "fp", "fs", "xc", "WC", "il", "FE", "LC", "fx", "PF", "tc", "DC", "con", "fn", "isc", "af", " FC", "fed", "mc", "bc", "bf", "ec", "f"], "returnVal": ["backVAL", "Returnval", "returnNum", "continueNum", "ReturnVal", "backValue", " returnVAL", "backVal", "backval", "ReturnVAL", "continueValue", "returnValue", "ReturnValue", " returnNum", " returnValue", "continueval", " returnval", "returnVAL", "ReturnNum", "continueVal", "returnval"], "file": ["File", "image", "folder", "log", "base", "resource", "feed", "global", "to", "function", "ile", "input", "fe", "up", "http", "zip", "message", "local", "filename", "use", "l", "b", "info", "full", "object", "page", "url", "class", "cf", "files", "path", "handler", "single", "type", "part", "io", "uri", "out", "fp", "dir", "FILE", "name", "socket", "data", "user", "binary", "sf", "php", "document", "lock", "per", "get", "lib", "connection", "source", "db", "f", "directory"], "rutaGlobal": ["srutaReal", " rutaInternational", "rugaInternational", "rutaGeneral", "rutiLocal", "rutiCore", "rettaGlobal", " rutoGlobal", "rettaInternational", "rutaLocal", "rundaInternational", "srettaGlobal", "rottaGeneral", "rutiReal", "rundaGlobal", " rutaGeneral", "rutiInternational", "rutoCore", "srottaCore", "srottaGlobal", "rucaGlobal", "rundaGeneral", "srettaReal", "rutoGeneral", "rottaGlobal", " rutoGeneral", "rottaLocal", "srutaGeneral", "rottaCore", "srettaLocal", "rucaInternational", "rutiGeneral", "rettaLocal", "srettaInternational", "srutaGlobal", "srutaCore", "rucaGeneral", "srottaLocal", " rutoInternational", "srutaInternational", "rutoLocal", "rutaInternational", "rutaCore", "rutoInternational", "srutaLocal", "srottaGeneral", "rettaReal", "rutaReal", "rutoGlobal", "rugaGlobal", "rugaLocal", "rugaReal", "rutiGlobal"], "rutaRelativa": ["rutaRelateiva", "rutaRelattiva", "rutaRelarativo", "rutaRelariv", "rutaRelarativ", "rutaMalativism", "rutaMalarivo", "rutaRelariva", "rutaRelateivism", "rutaRelATivas", "rutaRelattivism", "rutaRelateiv", "rutaRelarativa", "rutaRelATiva", "rutaMalariva", "rutaMalarivas", "rutaRelativism", "rutaRelarativas", "rutaRelattiv", "rutaRelarivas", "rutaRelATiv", "rutaMalarivism", "rutaRelativo", "rutaRelATivo", "rutaMalativo", "rutaRelativ", "rutaRelarivism", "rutaMalativa", "rutaRelattivas", "rutaRelattivo", "rutaRelateivo", "rutaRelativas", "rutaRelarativism", "rutaMalativas", "rutaRelarivo"], "fis": ["viss", " fIs", " fris", "xys", "vIs", "vis", "FIs", "fIs", "xris", "Fys", " fiss", "Fos", "Fis", "frir", "friss", "fris", "Fiss", "fys", "fiss", " fys", "Fir", " fir", "xis", "fir", "fros", "xiss", "vos", "Fris"], "fos": ["fileos", "fios", "fo", " fops", "fOS", " fo", "Fios", "infOS", " fios", "FOS", " focks", "tfo", "infios", "fileo", "infos", "tfOS", "tfops", "Fos", "Fis", "infis", "Focks", "focks", "fileocks", "fops", "Fops", "tfos", "fileops", " fOS", "Fo"], "canalFuente": ["canalsFuent", "canalBuenza", "canalJuante", "canalBuent", "canulFience", "canalFUento", "canallFuence", "canalKuenza", "canalFuencer", "canalfuence", "canalKuente", "canalMuence", "canallFuente", "canulFient", "canalBuence", "canalsFuento", "canalBuente", "canalFiencer", "canalKuence", "canalKugent", "canalFuento", "canalMuencer", "canalFuent", "canallFugent", "canalFient", "canalsFuante", "canalsFuente", "canalsBuent", "canallBuence", "canalFuence", "canulFuencer", "canalBuento", "canalFUante", "canulFiencer", "canulFuente", "canalFUent", "canallFuenza", "canalFiente", "canalBuante", "canallBuenza", "canalsBuente", "canalJuencer", "canalJuento", "canallBugent", "canalJuent", "canalFUente", "canalsBuento", "canalsBuante", "canalFuante", "canulFiente", "canallBuente", "canalMuente", "canalBugent", "canalFuenza", "canalFugent", "canulFuent", "canalfugent", "canalJuence", "canulFuence", "canalFience", "canalfuenza", "canalJuente", "canalMuent", "canalfuente"], "canalDestino": ["canalCampina", "canalldestania", "canelDestania", "canalNegination", "canalldestino", "canalCampination", "canaldestinos", "canallDestino", "canelDestino", "canalNegania", "canelCampino", "canaldestania", "canallDestina", "canalDestania", "canalNegina", "canaldestina", "canelDestina", "canalCampinos", "canalldestinos", "canalldestina", "canalDestinos", "canelCampania", "canalCampino", "canallDestania", "canelCampina", "canaldestination", "canaldestino", "canalDestina", "canelDestination", "canalCampania", "canelCampination", "canalDestination", "canallDestinos", "canalNegino"]}}
{"id1": "18374478", "id2": "22879400", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "label": 0, "substitutes": {"updateUser": ["Updateuser", "addUser", " updateUsers", "createUsers", "updateAccount", "createRole", "updatedUser", "UpdateUsers", "UpdateMember", " updateWord", "editRole", "deleteuser", "updatedUsers", " updateAccount", "updatedWord", "updatePassword", "deleteRole", "editUser", "updateRole", " updateMember", "adduser", "addUsers", "updateduser", "UpdateWord", "deleteUsers", "deletePassword", "updateMember", "deleteWord", "deleteUser", "UpdatePassword", "editUsers", "deleteMember", "createUser", "editAccount", " updatePassword", "createAccount", "addWord", "UpdateUser", "updateWord", "UpdateRole", "updateuser", " updateuser", "updateUsers", " updateRole"], "user": ["rule", "model", "ver", "pool", "log", "resource", "module", "system", "account", "site", "view", "self", "current", "this", "content", "project", "match", "profile", "version", "group", "message", "use", "User", "member", "full", "object", "post", "update", "page", "string", "null", "you", "session", "creator", "ro", "custom", "job", "author", "p", "result", "record", "used", "row", "response", "client", "character", "users", "bug", "manager", "auth", "me", "app", "name", "server", "data", "parent", "username", "instance", "str", "person", "per", "contact", "connection", "config", "USER", "plugin"], "conn": ["enc", "ou", "log", "pool", "nt", "serv", "pt", "coll", "dc", "cli", "nc", "pc", "Connection", "ca", "exec", "cache", "sync", "api", "ch", "cb", "cat", "ann", "pr", "act", "c", "sql", "cr", "ct", "core", "rc", "ci", "part", "conf", "org", "oss", "client", "cc", "util", "pub", "close", "socket", "cm", "col", "ac", "co", "reg", "con", "h", "cn", "loc", "ec", "ha", "server", "ob", "cond", "connect", "lock", "sth", "Conn", "mc", "el", "n", "ctx", "cp", "connection", "config", "host", "db", "pg", "url", "uc"], "autoCommit": ["autoDebIT", "autoCommitting", "autoRebit", "autoCited", "autoCommend", "autoDebend", " autoDebited", " autoCommite", "automaticCommmit", "autoBlmit", "automaticDebIT", "autoComite", "autoComIT", " autoCommmit", "autoDebited", "autoAbmit", "autoCommited", " autoDebit", " autoDebitting", "autoDebits", "autoAbit", "autoDebitting", "autoBlend", "autoBlIT", "autoDebit", "autoDebmit", "automaticDebit", "automaticCommend", "autoCommits", " autoCommitting", "autoRebits", "autoBlit", " autoComit", " autoComits", "autoCmit", " autoCommits", " autoCommited", "autoCitting", "autoAbited", "autoCommmit", "automaticCommIT", "autoRebite", "automaticDebmit", " autoComite", "autoDebite", "automaticCommit", "autoComit", "autoCommIT", "automaticDebend", "autoComits", "autoCommite", "autoCit", "autoComend", "autoAbitting", " autoDebmit"], "deleteRoles": ["insertRases", "destroyNoots", "deleteDole", "deleteDases", "deleteRooles", "delRases", "deleteRules", "deleteDols", "delLodes", "insertRoases", "deleteRoots", "deleteGroots", "deleteSloles", "deleteNoles", "insertRoole", "deleteRoole", "deleteSlases", "delLole", "destroyNols", "deleteSlodes", "deleteNils", "deleteGrils", "deleteRsules", "deleteNols", "deleteLoles", "deleteCases", "deleteRole", "insertRoules", "deleteRsases", "deleteGrols", "insertRole", "destroyRols", "deleteDils", "destroyNoles", "delRole", "deleteDoles", "delRoles", "delRodes", "deleteRsoles", "delLases", "deleteRoases", "deleteLodes", "deleteRoules", "deleteCole", "deleteCodes", "deleteRases", "destroyRoots", "deleteLole", "insertRules", "deleteRsole", "deleteRols", "deleteLases", "deleteRils", "deleteDules", "destroyRils", "insertRooles", "deleteSlole", "deleteGroles", "delLoles", "destroyRoles", "deleteDoots", "deleteRodes", "destroyNils", "deleteNoots", "deleteColes"], "insertRoles": ["insertLols", "insertRoots", "insertSules", "insertLows", "deleteSloots", "updateRles", "insertRanges", " insertShole", "updateLoles", "insertRodes", "insertSodes", "insertRsoles", " insertSholes", "copyGoots", "insertRules", "copyGows", "updateRoles", "insertSlodes", " insertRules", "copyRoots", "insertSholes", "deleteRanges", "insertRsows", "deleteRoots", "deleteSloles", "copyGules", "deleteSlodes", "insertRsoots", "insertLles", "insertSoles", "insertRole", "insertGules", " insertRole", "insertLules", "updateLols", "insertRsules", "insertShodes", "insertGoots", "insertShole", "copyGoles", "insertLoots", "insertShules", "insertRsodes", "insertRsles", "insertGows", "copyRules", " insertShules", "updateLules", " insertRodes", "insertGoles", "updateRules", "insertLoles", "copyRows", "copyRoles", " insertShodes", "updateLles", "insertRles", "insertRsols", "updateRols", "insertSole", "insertRows", "insertSlanges", "deleteSlanges", "insertSloles", "insertRols", "deleteRodes", "insertSloots", "insertRsanges"], "role": ["rule", "link", "de", "slave", "ole", "base", "resource", "module", "force", "service", "val", "to", "alias", "function", "entry", "group", "repl", "key", "l", "label", "member", "string", "route", "ro", "relation", "Role", "type", "row", "le", "tool", "zone", "roller", "shadow", "range", "username", "error", "rl", "one", "rol", "or", "profile", "tag", "guard"]}}
{"id1": "3330775", "id2": "1508930", "code1": "    public static JSONObject getJSONData(String url) throws JSONException {\n        JSONObject jObject = null;\n        InputStream data = null;\n        DefaultHttpClient httpClient = new DefaultHttpClient();\n        URI uri;\n        try {\n            uri = new URI(url);\n            HttpGet httpGet = new HttpGet(uri);\n            HttpResponse response = httpClient.execute(httpGet);\n            data = response.getEntity().getContent();\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader;\n            reader = new BufferedReader(new InputStreamReader(data), 8192);\n            while ((line = reader.readLine()) != null) builder.append(line);\n            reader.close();\n            jObject = (JSONObject) new JSONTokener(builder.toString()).nextValue();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return jObject;\n    }\n", "code2": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "label": 1, "substitutes": {"getJSONData": ["getJObject", "loadJData", "loadJSONResponse", "getJSONObject", "getjsonObject", "getJResponse", "getJSObject", "getjsonData", "getJSResponse", "loadJSONData", "getJSONResponse", "loadJdata", "getJdata", "getJSData", "getJSdata", "getJData", "loadJSONdata", "loadJObject", "loadJSONObject", "loadJResponse", "getjsonResponse", "getjsondata", "getJSONdata"], "url": ["image", "html", "URL", "base", "resource", "feed", "coll", "input", "Url", "json", "ls", "http", "filename", "href", "l", "api", "full", "style", "string", "buffer", "route", "path", "source", "xml", "ur", "name", "ssl", "request", "proxy", "server", "id", "file", "ll", "host", "username", "str", "sl", "i", "connection", "like", "location", "address"], "jObject": [" jData", "jData", "JObject", "jobobject", "jiData", "ojobject", "ojJSON", "Jobject", "jiObject", "jobData", "JObj", "jobject", "JJSON", "jJSON", "jObj", " jObj", "jobObject", "jiobject", "ojObject", "jobObj", " jobject", "JData", " jJSON", "jiJSON", "ojData", "ojObj"], "data": ["dd", "body", "image", "html", "base", "resource", "feed", "storage", "done", "stream", "content", "to", "dat", "input", "json", "download", "plain", "entry", "zip", "message", "cache", "load", "text", "slice", "api", "writer", "info", "media", "bytes", "post", "style", "buffer", "handler", "DATA", "ad", "part", "record", "result", "client", "as", "memory", "server", "file", "error", "i", "results", "database", "partial", "source", "address"], "httpClient": [" httpCall", "urlclient", "urlCl", "Httpclient", "HttpCl", "HttpGet", "HttpConnect", "ttpClient", " httpC", "httpC", "HttpCall", "ttpCall", "httpConnect", "HttpC", " httpCl", "httpclient", "urlClient", " httpConnect", "urlConnect", "HttpClient", "ttpC", "httpCall", " httpclient", "ttpGet", "httpCl"], "uri": ["mi", "folder", "base", "service", "resource", "API", " URI", "iri", "cli", "http", "cache", "api", "ui", "string", "ri", "pi", "route", "query", "handler", "source", "uni", "si", "io", "client", "URI", "ur", "request", "qi", "server", "file", "id", "reference", "absolute", "range", "i", "database", "connection", "location", "address"], "httpGet": ["HttpGet", "jsonGet", "apiReturn", " httpget", "httpReturn", "jsonClient", "httpPut", "apiClient", "ttpQuery", "jsonget", "apiget", " httpQuery", "HttpPut", "jsonReturn", "httpget", " httpReturn", "httpQuery", "ttpPut", "apiGet", "HttpQuery", " httpPut", "ttpGet"], "response": ["body", "onse", "resource", "feed", "stream", "Response", "json", "http", "message", "output", "api", "writer", "respond", "object", "page", "status", "resp", "next", "query", "result", "client", "report", "received", "request", "server", "file", "document", "e", "results", "res", "connection", "reply"], "line": ["link", "letter", "lc", "unit", "base", "feed", "end", "liner", "point", "content", "val", "lf", "cl", "lines", "entry", "inline", "LINE", "text", "message", "Line", "key", "column", "l", "object", "page", "style", "string", "code", "buffer", "pass", "li", "type", "part", "len", "number", "row", "layer", "ip", "le", "character", "lin", "name", "file", "jo", "cell", "e", "char", "id", "str", "el", "i", "one", "comment", "header"], "builder": ["letter", "base", "address", "office", "inner", "ener", "entry", "worker", "up", "parser", "Builder", "writer", "b", "object", "null", "string", "driver", "array", "r", "creator", "buffer", "oder", "built", "handler", "er", "builders", "type", "result", "obb", "build", "sb", "number", "row", "layer", "length", "runner", "wrapper", "building", "keeper", "database", "iter", "or", "db", "upper", "editor"], "reader": ["resource", "feed", "rx", "stream", "rer", "input", "ry", "entry", "worker", "parser", "reading", "ler", "rar", "bird", "writer", "finder", "read", "ri", "driver", "r", "buffer", "ro", "oder", "handler", "er", "io", "rr", "rh", "row", "ra", "client", "ner", "loader", "runner", "server", "file", "iterator", "Reader", "i", "per", "keeper", "iter", "or", "source", "editor"]}}
{"id1": "21754659", "id2": "21232043", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    @Override\n    public File call() throws IOException {\n        HttpURLConnection conn = null;\n        ReadableByteChannel fileDownloading = null;\n        FileChannel fileWriting = null;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            if (size == -1) {\n                size = conn.getContentLength();\n            }\n            fileDownloading = Channels.newChannel(conn.getInputStream());\n            fileWriting = new FileOutputStream(file).getChannel();\n            long left = size;\n            long chunkSize = BLOCK_SIZE;\n            for (long downloaded = 0; downloaded < size; left = size - downloaded) {\n                if (left < BLOCK_SIZE) {\n                    chunkSize = left;\n                }\n                fileWriting.transferFrom(fileDownloading, downloaded, chunkSize);\n                downloaded += chunkSize;\n                setProgress(downloaded);\n            }\n        } finally {\n            if (file != null) {\n                file.deleteOnExit();\n            }\n            if (conn != null) {\n                conn.disconnect();\n            }\n            if (fileDownloading != null) {\n                try {\n                    fileDownloading.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0441\u043a\u0430\u0447\u0438\u0432\u0430\u043d\u0438\u044f\", ioe);\n                }\n            }\n            if (fileWriting != null) {\n                try {\n                    fileWriting.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 \u0444\u0430\u0439\u043b\", ioe);\n                }\n            }\n        }\n        return file;\n    }\n", "label": 0, "substitutes": {"getButtonSonido": ["getButtonJonido", "getButtonJonendo", "getButtonSenico", "getbuttonSenendo", "getButtonJonico", "getbuttonSenira", "getButtonSenido", "getButtonSonendo", "getButtonJonira", "getbuttonSenico", "getButtonSonira", "getbuttonSonido", "getbuttonSonendo", "getbuttonSonira", "getButtonSenira", "getButtonSenendo", "getbuttonSonico", "getbuttonSenido", "getButtonSonico"], "buttonSonido": ["buttonDonino", "btnDonido", "buttonHonido", "ButtonSonida", "buttonSonida", "buttonHonardo", "buttonSenida", "ButtonSonado", "btnSonido", "ButtonDonida", " buttonSenino", "buttonHomido", "buttonsonardo", "buttonSonini", " buttonSonino", " buttonSenado", "buttonTanida", " buttonSenida", "ButtonDonini", "btnSonigo", "buttonsonado", " buttonSenardo", "buttonTanado", "btnDonado", "ButtonSonardo", "buttonHomardo", "ButtonSonini", "buttonHonino", "buttonDonido", "btnDonardo", "buttonHomida", "buttonHonado", "buttonDonini", "buttonDonardo", "buttonSenado", "ButtonDonado", "buttonHomado", " buttonSenido", "buttonSenardo", " buttonSonardo", "buttonSonino", "btnDonigo", "btnSonini", "buttonDonigo", "buttonDonado", "ButtonDonardo", "buttonTanardo", "buttonSenino", "btnSonado", "buttonSonado", "btnSonardo", "ButtonSonido", "buttonsonido", "ButtonDonido", "buttonSenini", "buttonSenigo", "buttonSonardo", "buttonTanido", "buttonsonigo", "buttonSonigo", "buttonSenido", " buttonSonida", "buttonDonida", "buttonsonini", " buttonSonado"], "e": [" ate", " fe", "event", " cause", " Event", " other", " pe", "E", " events", " E", " exc", "ed", " invoked", "t", " caught", " en", " inst", " ev", " ie", " te", " exception", " je", " exp", "Event", " ace", " ignored", "ee"], "fc": ["enc", "lc", "Factory", "fr", "FC", "fa", "dc", "lf", "fm", "F", "nc", "pc", "fe", "FS", "fi", "WF", "fw", "wic", "xf", "roc", "GF", "cf", "c", "wt", "ct", "fd", "irc", "fb", "fl", "flo", "wk", "CF", "fp", "fs", "xc", "WC", "il", "FE", "LC", "fx", "PF", "tc", "DC", "con", "fn", "isc", "af", " FC", "fed", "mc", "bc", "bf", "ec", "f"], "returnVal": ["backVAL", "Returnval", "returnNum", "continueNum", "ReturnVal", "backValue", " returnVAL", "backVal", "backval", "ReturnVAL", "continueValue", "returnValue", "ReturnValue", " returnNum", " returnValue", "continueval", " returnval", "returnVAL", "ReturnNum", "continueVal", "returnval"], "file": ["File", "image", "folder", "log", "base", "resource", "feed", "global", "to", "function", "ile", "input", "fe", "up", "http", "zip", "message", "local", "filename", "use", "l", "b", "info", "full", "object", "page", "url", "class", "cf", "files", "path", "handler", "single", "type", "part", "io", "uri", "out", "fp", "dir", "FILE", "name", "socket", "data", "user", "binary", "sf", "php", "document", "lock", "per", "get", "lib", "connection", "source", "db", "f", "directory"], "rutaGlobal": ["srutaReal", " rutaInternational", "rugaInternational", "rutaGeneral", "rutiLocal", "rutiCore", "rettaGlobal", " rutoGlobal", "rettaInternational", "rutaLocal", "rundaInternational", "srettaGlobal", "rottaGeneral", "rutiReal", "rundaGlobal", " rutaGeneral", "rutiInternational", "rutoCore", "srottaCore", "srottaGlobal", "rucaGlobal", "rundaGeneral", "srettaReal", "rutoGeneral", "rottaGlobal", " rutoGeneral", "rottaLocal", "srutaGeneral", "rottaCore", "srettaLocal", "rucaInternational", "rutiGeneral", "rettaLocal", "srettaInternational", "srutaGlobal", "srutaCore", "rucaGeneral", "srottaLocal", " rutoInternational", "srutaInternational", "rutoLocal", "rutaInternational", "rutaCore", "rutoInternational", "srutaLocal", "srottaGeneral", "rettaReal", "rutaReal", "rutoGlobal", "rugaGlobal", "rugaLocal", "rugaReal", "rutiGlobal"], "rutaRelativa": ["rutaRelateiva", "rutaRelattiva", "rutaRelarativo", "rutaRelariv", "rutaRelarativ", "rutaMalativism", "rutaMalarivo", "rutaRelariva", "rutaRelateivism", "rutaRelATivas", "rutaRelattivism", "rutaRelateiv", "rutaRelarativa", "rutaRelATiva", "rutaMalariva", "rutaMalarivas", "rutaRelativism", "rutaRelarativas", "rutaRelattiv", "rutaRelarivas", "rutaRelATiv", "rutaMalarivism", "rutaRelativo", "rutaRelATivo", "rutaMalativo", "rutaRelativ", "rutaRelarivism", "rutaMalativa", "rutaRelattivas", "rutaRelattivo", "rutaRelateivo", "rutaRelativas", "rutaRelarativism", "rutaMalativas", "rutaRelarivo"], "fis": ["viss", " fIs", " fris", "xys", "vIs", "vis", "FIs", "fIs", "xris", "Fys", " fiss", "Fos", "Fis", "frir", "friss", "fris", "Fiss", "fys", "fiss", " fys", "Fir", " fir", "xis", "fir", "fros", "xiss", "vos", "Fris"], "fos": ["fileos", "fios", "fo", " fops", "fOS", " fo", "Fios", "infOS", " fios", "FOS", " focks", "tfo", "infios", "fileo", "infos", "tfOS", "tfops", "Fos", "Fis", "infis", "Focks", "focks", "fileocks", "fops", "Fops", "tfos", "fileops", " fOS", "Fo"], "canalFuente": ["canalsFuent", "canalBuenza", "canalJuante", "canalBuent", "canulFience", "canalFUento", "canallFuence", "canalKuenza", "canalFuencer", "canalfuence", "canalKuente", "canalMuence", "canallFuente", "canulFient", "canalBuence", "canalsFuento", "canalBuente", "canalFiencer", "canalKuence", "canalKugent", "canalFuento", "canalMuencer", "canalFuent", "canallFugent", "canalFient", "canalsFuante", "canalsFuente", "canalsBuent", "canallBuence", "canalFuence", "canulFuencer", "canalBuento", "canalFUante", "canulFiencer", "canulFuente", "canalFUent", "canallFuenza", "canalFiente", "canalBuante", "canallBuenza", "canalsBuente", "canalJuencer", "canalJuento", "canallBugent", "canalJuent", "canalFUente", "canalsBuento", "canalsBuante", "canalFuante", "canulFiente", "canallBuente", "canalMuente", "canalBugent", "canalFuenza", "canalFugent", "canulFuent", "canalfugent", "canalJuence", "canulFuence", "canalFience", "canalfuenza", "canalJuente", "canalMuent", "canalfuente"], "canalDestino": ["canalCampina", "canalldestania", "canelDestania", "canalNegination", "canalldestino", "canalCampination", "canaldestinos", "canallDestino", "canelDestino", "canalNegania", "canelCampino", "canaldestania", "canallDestina", "canalDestania", "canalNegina", "canaldestina", "canelDestina", "canalCampinos", "canalldestinos", "canalldestina", "canalDestinos", "canelCampania", "canalCampino", "canallDestania", "canelCampina", "canaldestination", "canaldestino", "canalDestina", "canelDestination", "canalCampania", "canelCampination", "canalDestination", "canallDestinos", "canalNegino"]}}
{"id1": "20011285", "id2": "3187685", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["link", "log", "create", "change", "clone", "share", "download", "write", "py", "paste", "cop", "load", "zip", "sync", "replace", "cat", "update", "apply", "clip", "split", "type", "upload", "opy", "Copy", "file", "transfer", "rm", "move", "delete", "get", "cp", " cp", "save"], "sourceFile": ["sourceDirectory", "sourceBook", "ourcePage", " sourcePlace", "apiFilename", " sourcePage", "ourceDirectory", "apiFile", " sourceSourceFile", "SourceDir", "sourceDir", "sourcePage", "apiFiles", "sourceFilename", "SourceBook", " sourceDirectory", "sampleFile", "ourceFiles", "sourceFolder", "sampleFilename", "ourceTime", "targetFolder", " sourceBook", " sourcefile", "sourceSourceFile", "SourcePlace", "SourceDirectory", "sampleFiles", " sourceFiles", "siteFILE", " sourceDir", "slaveFile", "sourceFILE", "slaveFILE", "SourceTime", "ourcefile", "targetPage", "SourceFile", "sourcefile", "apiFILE", "targetFile", "slaveFiles", "Sourcefile", "ourceFolder", "targetFiles", "sourceFiles", "ourceBook", "sampleFILE", "ourcePlace", "sourcePlace", " sourceFILE", "sourceTime", "siteFiles", "targetDirectory", "siteFile", " sourceFilename", "siteFilename", "slaveFilename", "SourceFiles", "SourceSourceFile", "targetDir", " sourceTime", "ourceFile", "ourceSourceFile", " sourceFolder"], "destinationFile": ["destinationFolder", "dominatorFile", "destwayFILE", "destinatefile", "targetinatedFiles", "targetinationFile", "targetinationfile", "destuationFile", "dominationFILE", "destructionfile", "destuationfile", "destinatorSourceFile", "destructionFILE", "destinatedfile", "dominatorfile", "destinationDirectory", "dominatorFILE", "destuationFILE", "dominationfile", "distructionFile", "destinatedFile", "DestinatingFile", "targetinatedFile", "distructionfile", "destinateFolder", "destinatingFiles", "distructionFILE", "desturationFiles", "destwayfile", "desturationSourceFile", "destinatingFile", "DestinationSourceFile", "DestinatingDirectory", "destinatorFile", "destinatorFILE", " destinationfile", " destinatingFolder", "destinateFile", "destinatingDirectory", "destinationFiles", "dominatorPath", " destinatingFile", "desturationDirectory", "distinationFile", "destinatorPath", "destwayFiles", "distinationfile", "destinatorFolder", "dominationPath", "destinatingPath", "DestinatingSourceFile", "destinatorDirectory", "dominatorFiles", "destinatingfile", "targetinatedFolder", "distructionFolder", "targetinationFiles", "destuationFolder", "destinationSourceFile", "destinatingFolder", "destinationfile", "destinatedFolder", "destructionFile", "destinatingSourceFile", "destinationPath", " destinationFiles", " destinatingFiles", "DestinationFile", "DestinationFiles", "destructionFolder", "destinatePath", "targetinatedfile", "dominationFile", "destinatedFiles", " destinatingfile", "destinatingFILE", "targetinationFolder", "destinatorfile", "distinationFolder", "dominationFiles", "destinateFiles", "destwayFile", "desturationFile", " destinationFolder", "DestinatingFiles", "destinatorFiles", "DestinationDirectory", "destinationFILE", "distinationFILE"], "tmp": ["np", "folder", "nb", "temp", "storage", "tab", "current", "dat", "po", "py", "mm", "zip", "cache", "mo", "slice", "area", "list", "media", "api", "bb", "mp", "sup", "page", "csv", "txt", "array", "pp", "files", "apps", "sp", "buf", "pos", "amp", "params", "t", "fb", "st", "handler", "split", "p", "cmp", "upload", "part", "v", "diff", "flat", "dest", "img", "ip", "dir", "pty", "data", "tp", "e", "rm", "vm", "stuff", "rb", "mb", "meta", "db", "obj", "ppa"], "f": ["fo", "j", "o", "fr", "this", "fa", "inf", "lf", "F", "ff", "fe", "fi", "fc", "xf", "l", "b", "info", "full", "uf", "c", "cf", "r", "rf", "g", "t", "fd", "d", "fb", "handler", "fl", "p", "conf", "io", "v", "x", "df", "fp", "fs", "fx", "tf", "file", "fn", "af", "e", "u", "bf", "m"], "i": ["lc", "j", "index", "o", "in", "oi", "hi", "ii", "fi", "ix", "key", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "d", "li", "ci", "p", "ie", "multi", "si", "xi", "io", "uri", "bi", "v", "x", "ai", "ji", "y", "ip", "start", "name", "h", "ti", "id", "qi", "e", "iu", "u", "vi", "ij", "n", "di", "m", "I", "s"], "source": ["force", "slave", "base", "service", "resource", "SOURCE", "site", "storage", "view", "stream", "Source", "current", "this", "input", "grade", "target", "src", "cache", "back", "slice", "use", "scope", "null", "from", "core", "ie", "ource", "si", "result", "io", "uri", "diff", "ce", "client", "secure", "start", "proxy", "ge", "wrapper", "server", "id", "component", "e", "sl", "reader", "get", "connection", "parent"], "destination": ["estinate", "partinator", "combination", "destinator", "Destation", "destinating", "Destination", "Destinating", " destinator", "combinating", "Destinated", "combinated", " destation", "Destinator", "generinator", "generination", "Destinate", "combinator", "generinated", "partinated", "generinate", "estinator", "estinating", "estination", "destinate", "destinated", "combinate", " destinated", "partination", "destation", "partation"]}}
{"id1": "13757855", "id2": "18693224", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"process": ["resource", "create", "submit", "view", "transform", "project", "parse", "load", "run", "processing", "output", "update", "code", "path", "build", "proc", "cess", "evaluate", "handle", "Process", "request", "construct", "call", "exec", "processor"], "tpl": ["Tpp", "templates", "tml", "Tbl", "qtple", "lPL", "atpl", "psl", "itpl", " tplug", "Tplates", "ttemplate", "tmpl", "tplates", " tple", " tper", " tplate", "lml", "temPL", "atplate", "tplate", " ttemplate", "tcp", "Ttemplate", "fplug", "Tml", "lcl", "TPL", "tbl", "Tsl", " tfc", "fplate", "tipl", "latcp", " tipl", "Tpl", "atml", "stPL", "Tipl", "pipl", " tbl", "qtcp", "lplate", "tplug", "Tple", "qtpl", "atplug", "Tper", "itplates", "tsl", "temtemplate", "tfc", "tple", "qtbl", "latpl", "lpl", "fpl", "tPL", "itPL", "pPL", "tpp", " tcl", "tcl", "lper", "tmyl", "itplate", " tPL", "ppl", "latyl", "tmcp", "qtfc", " tplates", "tper", "pcl", "stpl", " tsl", " tpp", "lple", "qtyl", "tmple", "templ", "latple", "stpp", "stplate", "Tfc", "Tcl", "fml", "Tplate", "tyl", " tml"], "model": ["body", "log", "graph", "module", "Model", "config", "json", "param", "message", "media", "params", "node", "m", "doc", "result", "command", "where", "xml", "models", "language", "data", "document", "location", "project", "conf", "copy"], "packageName": ["PackageNames", "PackageName", " packagename", "groupName", "packageUrl", "modulename", "contextName", "groupUrl", "packageKey", " packageNames", "moduleUrl", "moduleKey", "contextInfo", "projectKey", "Packagename", "groupKey", "contextname", " packageInfo", "groupname", "projectName", "moduleName", "packageNames", "packagename", "projectUrl", "contextNames", "projectname", "PackageInfo", "packageInfo"], "outFileName": ["inFilePath", "outFileTime", "diffFileOnce", "OutDirNames", "outDirEnd", " outFullType", "inDirPath", "outBufferHalf", "outDirInfo", "outFileType", "outDirname", "outFullInfo", "outfileMode", "difffileInfo", "outfileOnce", "outLinename", "outDirCopy", "OUTFileHalf", " outFileInfo", "inDirEnd", "outDirTime", "diffFileInfo", "outFullType", " outFilePath", "outLineNames", "outFileOnce", "outFullTime", "outFileHalf", "outfileCopy", "OutDirName", "outRuleType", "outLineName", "outFilenameHalf", " outDirPath", "outLineOnce", "OUTBufferHalf", "outFullNames", "outFilenameCopy", "outFilesLine", "OUTBufferMode", "diffFileTime", "outFileInfo", " outFullInfo", "outDirName", "inDirCopy", "OUTBufferName", "outfileName", "difffileName", "outFileLine", "outFileEnd", " outFileTime", "OutFileName", "OutDirLine", "outFilenameName", "outFilesPath", "inFileCopy", " outDirTime", "OutFileNames", "OUTFileName", "outFileCopy", "outDirOnce", "diffFileName", "outfileTime", "outfilePath", "outFilePath", "OutDirname", "outFilename", "outBufferMode", "OUTFileNames", "OUTBufferNames", "outFilenamePath", " outFileLine", "difffileTime", "outStreamInfo", "outStreamType", "outLineInfo", " outDirName", " outFileType", "outfileInfo", "outFilenameEnd", "OutFileLine", "outFileMode", "outfileHalf", "outBufferName", "outDirLine", " outDirLine", "outFullname", "outfileEnd", "outFullPath", "outRuleInfo", "outBufferNames", "outStreamName", "OutFilename", "outRuleName", "inFileName", "outFullLine", "outfileNames", "outFilesTime", "outDirPath", "inFileEnd", "OUTFileMode", "outFilenameNames", "outFilesName", "outLineTime", "inDirName", "outDirNames", "outFullName", "outFilenameMode", "outFileNames", "outLineLine", "difffileOnce", " outFullName"], "xsltParam": ["xldVal", "xldMode", "xslicParam", "xsltparam", "xltVal", "xslpVal", "xsldVal", "xslpparam", "xslicVal", "xldParam", "xslpMode", "xslicparam", "xltparam", "xslpParam", "xsldParam", "xslicMode", "xsltMode", "xsldMode", "xsltVal", "xltParam", "xsldparam", "xldparam", "xltMode"], "artifact": ["aratifacts", "Artifact", "Artribution", "adverturation", "Artfact", "aratifact", " artribution", "arturation", "aratifest", "artfact", " artifacts", "ARTifacts", "ARTifact", "aratfact", "advertifacts", " arturation", "artifacts", "Artifest", "artribution", "Arturation", "ARTifest", "artifest", "advertifact", "ARTfact", "advertribution", "Artifacts"], "destinationPath": ["destiningpath", "distinatorName", "destinationspath", "constinationsPoint", "destiningName", "destinationsPath", "constinationWidth", "destinatedString", "restificationPoint", "destinationHandler", "datinatePath", "distributionCase", "destplingPath", "tempinationHalf", "desticationKey", "combinationHandler", "destinationPoint", "destinerPath", "desticationFile", "DestinationPart", "destiningDir", "constinationDir", "restinationHalf", "combinatorpath", "destributionDir", "desticationStep", "destinatedPoint", "distinationCase", "destinationsName", "destificationLog", "constinatorUrl", "destinationPart", "destinationStep", "destationLocation", "destificationName", "tempinatedHalf", "destinatorWidth", "destinateHalf", " destificationAuth", "destiningContext", "DestinationPoint", "constinatorWidth", "destinateDir", "destinationLocation", "destinatorContext", "constinationsPath", " destificationLog", "destinatingpath", "destinatedFile", "destationpath", "distinatorStep", "DestinatingPath", "destinatePart", "restinatorPath", "destificationLocation", "combinatorName", "tempinatedpath", "destinatedCase", "destplingUrl", "distinatorPath", "destplingLog", "destinationHalf", "DestinationText", "destributionCase", "datinationTime", "destinatorCase", "destinerContext", "destinatePoint", "destignmentCry", "restificationPath", "desticationPath", "datinationPath", "destinatepath", "tempinatedPath", "destinationCry", "constinationPoint", "destributionpath", "combinationPath", "destensionText", "destinatedDir", "combinationName", "destinatorFile", "destinatingText", "constinatorDir", "datinatepath", "destinatedKey", "DestificationName", "restificationLocation", "destignmentCase", "distinatorFile", "constinationspath", "constinationContext", "DestinatingText", "destcreationPath", "distinatorKey", "constinatorPath", "destinationName", "distinationDir", "restinationLocation", "destinateTime", "destificationPart", "destensionPath", "desticationPart", "distinatorCase", "destinateHandler", "restinationPoint", "destiationAuth", "destinatorUrl", "destificationAuth", "combinatorPath", "destinatorPath", "destplingAuth", "distinationFile", "destinationFile", "datinateTime", "destributionCry", "DestinatingPoint", "destiningPath", "destiationDir", "constinatorpath", "datinationLocation", "tempinationDir", "constinationUrl", "destinateText", "destensionPoint", "desturationHandler", "destiningPoint", "destificationDir", "destignmentPath", "destinatingPath", "tempinationPath", "desturationPath", "destinatorpath", "combinationpath", "destinationKey", "destinationpath", "constinatorContext", "destificationpath", "destinatorKey", " destinationLog", "destinateString", "datinateLocation", "destificationPoint", "destinatingLocation", "restificationpath", "destationPath", "destinationWidth", "destributionPath", "distinationPath", "destributionName", "destinatorString", "distinationKey", "destinatorCry", "tempinatedDir", "destinationAuth", "destinatingPoint", " destificationDir", "destcreationUrl", "DestificationPath", "destinerpath", "DestinationPath", "destinationLog", "destinationDir", "destplingDir", "distributionpath", "tempinationpath", "datinationpath", "destinatorHalf", "distinationStep", "destinationText", "restinatorString", "restinationPath", "distinationpath", "constinationsName", "restinationString", "destinatingName", "constinationName", "destinateName", "destiationLog", " destinationDir", "destinatorHandler", "destinatePath", "restinatorPoint", "destensionName", "destinatorTime", "distributionPath", "destinationCase", "destinatorPoint", "combinatorHandler", "desturationName", " destificationPath", "destinatorStep", "destinationsPoint", "destinatedPath", "destignmentName", "destiationPath", "distinationName", "destinationContext", "destinateLocation", "desturationpath", "destificationPath", "destinatedHalf", "destinatedStep", "DestinationName", "distributionDir", "destinatorName", "destinationTime", "destcreationWidth", " destinationAuth", "destinatorDir", "DestificationPart", "desticationName", "DestinatingName", "restinationpath", "destplingWidth", "destinatorLocation", "destationTime", "destinationString", "constinationPath", "destinatedpath", "distinatorCry", "destinationUrl", "distinationCry", "constinationpath", "destinerDir", "restinatorHalf"], "in": ["image", "input", "In", "cache", "bin", "c", "r", "IN", "t", "d", "doc", "source", "x", "min", "ins", "name", "con", "data", "ex", "reader", "i", "n", "connection", "config", "din", "inc"], "out": ["err", "log", "index", "pool", "o", "outer", "temp", "prefix", "point", "w", "write", "cli", "with", "version", "group", "up", "cache", "exec", "ne", "output", "OUT", "writer", "key", "list", "bin", "conn", "page", "post", "string", "full", "store", "session", "state", "again", "outs", "path", "free", "doc", "line", "part", "io", "result", "all", "Out", "client", "manager", "name", "sys", "dump", "user", "file", "server", "Output", "gen", "lock", "error", "ex", "comment", "str", "lib", "connection", "msg", "source", "parent", "obj", "copy"], "root": [" roots", "resources", "_", "index", "graph", "module", "options", " result", "history", "transform", "format", "json", "pattern", "Root", "cache", "roots", "cat", "r", "collection", "params", "path", "query", "node", "values", "xml", "loader", "tree", "id", "include", "modules", "instance", "results", "meta", "parent", "url"]}}
{"id1": "11616716", "id2": "22734545", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    public void generate(String urlString, String target) throws Exception {\n        URL url = new URL(urlString);\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        BufferedInputStream inputStream = new BufferedInputStream(urlConnection.getInputStream());\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target));\n        byte[] buf = new byte[10 * 1024];\n        int len;\n        while ((len = inputStream.read(buf, 0, buf.length)) != -1) {\n            outputStream.write(buf, 0, len);\n        }\n        inputStream.close();\n        outputStream.close();\n        urlConnection.disconnect();\n    }\n", "label": 0, "substitutes": {"getCMSResultAsStream": ["getCMSResultAsReader", "getCMSResultAsFile", "getCMSResultAsSteam", "getCMSResultWithFile", "getCMSResponseasSteam", "getCMSResponseAsFile", "getCMSResponseAsStream", "getCMSResultasSteam", "getCMSResultWithStream", "getCMSResultasReader", "getCMSResultInFile", "getCMSResultasStream", "getCMSResponseasFile", "getCMSResultasFile", "getCMSResultInSteam", "getCMSResponseAsReader", "getCMSResultInStream", "getCMSResponseAsSteam", "getCMSResultWithReader", "getCMSResultWithSteam", "getCMSResultInReader", "getCMSResponseasStream", "getCMSResponseasReader"], "rqlQuery": ["srQLQ", "rsqlQ", " rsqlMethod", "rqlQ", "riliQuery", " rsqlQuery", "srqlQ", " rqlquery", "rSQLMethod", "rSQLQu", "rqlquery", " rsqlQu", "riliquery", "rQLQ", "srqlQu", "srqlquery", "srQLQuery", "rsqlQu", "rqlMethod", "srQLQu", "rQLQuery", "rsqlQuery", " rsqlquery", " rqlQu", "riliQ", "srqlQuery", " rqlMethod", "rQLQu", "rsqlMethod", "rqlQu", "rsqlquery", "riliQu", "rQLMethod", "rSQLQuery", "rSQLquery", "srQLquery", "rQLquery"], "osr": ["iosrw", "obsR", "losrr", "losrt", "opsr", "opswer", "bosR", "ysrt", "osspr", " osrr", "ossr", "osrt", "otsrm", "cosrt", " osrar", "osscr", "losfr", " osrm", "ossrar", "opsR", "usrr", "ysr", "ossrs", "usrt", "osrr", "ossrt", "obswer", " osrt", "osrw", "yscr", "userr", "OSrt", "iosrs", "usr", "oserr", "iospr", "osrar", "cosfr", "cosr", "oscr", "oswer", "otspr", "osR", "otsr", "usrw", "ysrar", "osrm", " osfr", "ospr", "opsrar", " oscr", "ossrw", "losr", "osrs", " ossr", "OSr", "cosrr", "usrs", "obsrar", "bosr", "osserr", "boswer", "osssr", "uspr", " ospr", "ossrr", "OSerr", "otssr", "iosr", "bosrar", "ossrm", "osfr", "OSrr", "obsr"], "url": ["lc", "URL", "base", "resource", "www", "nl", "Url", "open", "ls", "channel", "http", "l", "b", "page", "string", "r", "path", "fb", "fl", "source", "org", "uri", "client", "blog", "socket", "ssl", "server", "file", "ll", "ob", "sl", "rl", "connection", "config", "host", "web", "f"], "conn": ["enc", "lc", "err", "conv", "nt", "coll", "dc", "nc", "open", "net", "cur", "pc", "rt", "Connection", "http", "exec", "ca", "sync", "l", "ch", "cb", "pr", "ann", "act", "c", "cr", "ct", "rc", "ci", "p", "en", "org", "oss", "attr", "client", "ssl", "col", "reg", "con", "h", "server", "cn", "ec", "fn", "wrapper", "rn", "connect", "Conn", "n", "ctx", "cp", "connection", "loc", "db", "f"]}}
{"id1": "12236729", "id2": "14758866", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" dup", "clone", "download", "py", " copied", " copying", " Copy", "paste", "zip", "cop", "sync", "replace", "cat", "clip", "split", "p", "cmp", "upload", "io", "diff", "dump", "Copy", "transfer", "php", "get", "cp", " transfer"], "inputFile": [" inputPath", " inputFiles", "inputPath", "currentFile", "inputfile", "outputDir", " inputDir", "sourcePath", "inputDir", " inputfile", "currentfile", "inputFiles", "sourceFile", "sourcefile", "currentDir", "outputFiles", "outputfile", "outputPath", "currentFiles", "sourceFiles"], "outputFile": [" outputDirectory", "tempFile", "referenceFile", "tempfile", "OutputFile", "inputfile", "outputDir", "outputFilename", "tempDir", "inputDir", "referencefile", " outputfile", " outputDir", "Outputfile", "OutputDirectory", "tempDirectory", "outputfile", "referenceFilename", "outputDirectory", " outputFilename", "referenceDir", "inputFilename", "OutputDir"], "in": ["ini", "err", "kin", "image", "login", "inner", "inn", "gin", "input", "In", "up", "l", "bin", "conn", "read", "pin", "IN", "r", "again", "source", "nin", "sin", "cin", "min", "pull", "ins", "into", "is", "lin", "as", "init", "inside", "a", "con", "ln", "id", "file", "e", "lock", "reader", "i", "win", "n", "get", "connection", "din", "f", "socket", "inc", "s"], "out": ["err", "log", "o", "outer", "temp", "outside", "w", "write", "plain", "over", "net", "at", "obj", "up", "cache", "sync", "output", "OUT", "writer", "bin", "b", "extra", "conn", "post", "null", "again", "outs", "plus", "line", "io", "v", "Out", "off", "file", "parent", "error", "ex", "i", "one", "n", "inc", "exec", "socket"], "c": ["lc", "esc", "o", "cl", "pc", "count", "cu", "fc", "l", "b", "cd", "ch", "C", "code", "cf", "r", "ct", "rc", "d", "k", "ci", "p", "sc", "line", "pointer", "v", "x", "ce", "cy", "xc", "cc", "character", "cm", "col", "a", "id", "char", "e", "u", "i", "n", "uc", "ec", "m", "cr", "f"]}}
{"id1": "10674824", "id2": "4531653", "code1": "    @Before\n    public void setUp() throws Exception {\n        final URL url = getClass().getClassLoader().getResource(\"insecureSSL.keystore\");\n        final KeyStore keystore = KeyStore.getInstance(\"jks\");\n        final char[] pwd = \"nopassword\".toCharArray();\n        keystore.load(url.openStream(), pwd);\n        final TrustManagerFactory trustManagerFactory = createTrustManagerFactory();\n        trustManagerFactory.init(keystore);\n        final TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();\n        final KeyManagerFactory keyManagerFactory = createKeyManagerFactory();\n        keyManagerFactory.init(keystore, pwd);\n        final KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();\n        final SSLContext serverSSLContext = SSLContext.getInstance(\"TLS\");\n        serverSSLContext.init(keyManagers, trustManagers, null);\n        localServer_ = new LocalTestServer(serverSSLContext);\n        localServer_.registerDefaultHandlers();\n        localServer_.start();\n    }\n", "code2": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"setUp": [" setup", " setUP", "setup", " setDown", "cleanUP", "startUP", "startUp", "cleanUp", "setDown", "setUP", "cleanDown", "startup", "startDown", "cleanup"], "url": ["image", "URL", "base", "resource", "service", "feed", "system", "Url", "ls", "channel", "entry", "http", "src", "key", "cert", "l", "api", "page", "string", "class", " URL", "buffer", "path", "uri", "client", "context", "manager", "loader", "name", "ssl", "server", "host", "file", "user", "gl", "browser", "sl", "connection", "config", "source", "f", "address"], "keystore": [" keyStore", " keycache", "airStore", "airstorage", "KeyStore", " keymanager", "keytool", "truststorage", "Keycache", "keybase", "rowstorage", "trustmanager", " keyserver", "keyStore", "certbase", "keystorage", "certStore", "keycache", "airmanager", "rowserver", "Keyserver", " keytool", " keybase", "truststore", "trustserver", "keyserver", "keymanager", " keystorage", "trustStore", "certstore", "trustcache", "trusttool", "airstore", "Keystore", "trustbase", "certserver", "rowtool", "Keybase", "rowstore"], "pwd": [" pword", "cwd", "Pword", "Ppass", "cword", "fword", "pWD", "fw", "prew", "prepass", "ppass", "PWD", " pw", "pword", "pw", "prewd", "preword", "Pwd", "fwd", " pWD", "cpass", "cw", "Pw", "cWD", "fpass", " ppass"], "trustManagerFactory": ["trustDirectoryBuilder", " trustManagerService", "trustDirectoryInterface", "trustmanagerInterface", "trustmanagerStore", " trustManagerStore", "trustManService", "keyManagerBuilder", "TrustManagerService", "trustLayerHelper", "trustManagerHelper", "trustManagementBuilder", "TrustManagerHelper", "trustLayerService", "TrustManagerFactory", "trustmanagerService", "trustManagerStore", "trustmanagerFactory", "trustDirectoryService", "TrustLayerFactory", "trustmanagerHelper", "trustDirectorHelper", "keyManagerService", "trustManagerBuilder", " trustDirectorStore", "trustManagerInterface", "trustDirectorStore", "trustManBuilder", "trustDirectoryFactory", "trustLayerFactory", "trustmanagerBuilder", "trustManFactory", "trustManInterface", "TrustLayerHelper", "keymanagerInterface", "trustManagementService", "keyManagerInterface", "trustDirectorService", "TrustLayerService", "trustDirectorFactory", "keymanagerBuilder", "keymanagerService", "trustDirectorBuilder", "trustManagerService", " trustDirectorFactory", "keymanagerFactory", " trustManagerBuilder", " trustDirectorService", "trustManagementStore", "trustManagementFactory", " trustDirectorBuilder"], "trustManagers": ["trustManagerager", "keymanurers", " trustManages", "trustMages", "trustMagers", "keyManages", "trustMurers", " trustManurers", " trustmanurers", "trustManageragers", "keyManurers", "trustManurers", "trustMatager", "trustmanager", " trustmanager", " trustmanagers", " trustmanages", "keymanages", "keyManager", "trustmanurers", " trustManager", "trustMager", "trustmanagers", "trustManagerages", "trustMaturers", "trustmanages", "keymanager", "trustManagerurers", "trustMatages", "trustManages", "trustMatagers", "keymanagers", "trustManager"], "keyManagerFactory": ["keyDirectorService", "sslManagerInterface", "sslManagerFactory", "keyManagementInterface", "keyManagerHelper", "keyManagementService", "sslManagementHelper", "keyDirectorHelper", "sslManagementFactory", "trustmanagerF", "sslManagerService", "keyManagerProvider", "trustmanagerProvider", "keyDirectorFactory", "keyLayerProvider", "sslManagementInterface", "trustmanagerService", "trustmanagerFactory", "keyManagerF", "keymanagerProvider", "keyManagerService", "keyManagementF", "trustManagerF", "trustManagerProvider", "keymanagerInterface", "keyManagerInterface", "keymanagerF", "keymanagerService", "sslManagerHelper", "trustManagerService", "keyManagementHelper", "keyLayerService", "keyLayerFactory", "keymanagerHelper", "keymanagerFactory", "keyManagementFactory", "sslManagementService", "keyDirectorInterface"], "keyManagers": ["keymanurers", "keyManages", "trustManainers", "keymanainers", "keyMANages", "KeyMANapters", "KeyManurers", "KeyMANurers", "keyManisters", "keyMANagers", "keyMANisters", "trustmanisters", "keyMANurers", "keyManainers", "keyManurers", "trustManurers", "keyMutainers", "keyMANapters", "keymanages", "trustmanurers", "keyMutisters", "trustManisters", "keyMuturers", "KeyManapters", "trustmanagers", "keymanisters", "keymanapters", "keyManapters", "trustmanainers", "keymanagers", "KeyManages", "KeyMANagers", "keyMutagers", "keyMANainers", "KeyMANages", "KeyManagers"], "serverSSLContext": ["serverSecurityService", "serverHTTPContext", "serverLSConn", " serverSSLFactory", " serverSSLClient", " serverSSLConn", " serverSLSupport", "serverServerSupport", "serverHTTPChannel", "serverSLClient", "serverSecureConn", "serverSSLClient", "serverSLSession", " serverSecureClient", "serverSSLFactory", "serverServerContext", "masterSecurityContext", "serverSSLSupport", " serverSSLSupport", "serverSecureContext", " serverSSLSession", "serverSLConn", "masterSecurityService", "serverSLContext", " serverSLSession", "serverSecureClient", "serverHttpSupport", "serverHttpFactory", "masterSSLService", " serverSLContext", "serverSSLService", " serverSecureContext", "serverSSLSession", "serverLSFactory", "serverSLSupport", "serverHTTPService", "serverSSLConn", "serverSecureFactory", "serverLSContext", " serverSecureConn", "masterSecurityChannel", "serverSecurityContext", "serverLSClient", "masterSSLChannel", "serverServerFactory", "serverHttpContext", "masterSSLContext", "serverHttpSession", " serverSLFactory", "serverSecurityChannel", "serverSLFactory", " serverSecureFactory", "serverServerSession", "serverSSLChannel"], "localServer_": ["localClient_", "localserverPool", "localServerlib", "globalServerPool", "localSocketPool", "localConnectorlib", "serverServer_", "globalSocket_", "localServiceRes", "localPortWork", "localClientPool", "localManager_", "localSocket_", "globalSocketPool", " localConnectorRes", "localConnectorRes", " localConnector_", "localManagerRes", "localserver_", "serverClientWork", " localServerRes", "localserverWork", "serverClientPool", "localServerWork", "serverServerPool", "localConnector_", " localServerlib", "globalServer_", " localConnectorlib", "localManagerlib", "localService_", "localPort_", "localPortPool", "localClientWork", "serverClient_", "localServerPool", "localServerRes", "localServicelib", "serverServerWork"]}}
{"id1": "19147279", "id2": "9096319", "code1": "    public boolean actualizarDatosFinal(int idJugadorDiv, int idRonda, jugadorxDivxRonda unjxdxr) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET resultado = ?, puntajeRonda = ? \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatementActFinal(unjxdxr);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"actualizarDatosFinal": [" actualizarDataoFinal", " actualizarBatosResult", " actualizarBatosComplete", " actualizarBatocResult", " actualizarBatosFinal", " actualizarDataoTotal", " actualizarBatosTotal", " actualizarDatosComplete", " actualizarDatOSFinal", " actualizarBatocTotal", " actualizarDatosResult", " actualizarDataoResult", " actualizarDatOSResult", " actualizarDataoComplete", " actualizarDatosTotal", " actualizarDatocResult", " actualizarDatOSTotal", " actualizarBatocComplete", " actualizarDatocComplete", " actualizarDatOSComplete", " actualizarDatocFinal", " actualizarBatocFinal", " actualizarDatocTotal"], "idJugadorDiv": ["idJugadorDoc", "idJugaderDec", "idJudadorDIV", "idJubordOrd", "idJubadorOrd", "idJugaderDoc", "idJugrarDec", "idJugaderDIV", "idJubordDiv", "idJugordDIV", "idJubordDec", "idJugadeDIV", "idJubadorDoc", "idJubadorDiv", "idJugordDec", "idJubordDoc", "idJudadorDiv", "idJugaderOrd", "idJugordDiv", "idJugaderDiv", "idJugadeDec", "idJugadeDiv", "idJugrarDoc", "idJugordOrd", "idJugadorDIV", "idJubadorDec", "idJudadeDec", "idJugadorOrd", "idJudadeDiv", "idJugordDoc", "idJudadorDec", "idJudadeDIV", "idJugadorDec", "idJugrarOrd", "idJugrarDiv"], "idRonda": ["idGrado", "idGronda", "pidRora", " idronda", "idRona", "idrona", "idrora", "idRhanna", "idRhora", "idGrona", "idRhado", "idGrora", "pidRhora", "idRanna", " idRora", "idRhona", "pidRhado", "idrado", "pidRona", " idRanna", "idRora", "pidRonda", "idronda", " idranna", "pidRado", "pidRhonda", " idrora", " idRona", "idranna", " idrona", "pidRhona", "idRhonda", "idRado"], "unjxdxr": ["unjxdexr", "unjxdxtr", "unjxdxR", "unjxdxxR", "unjxdxtrs", "unjxdxl", "unjxfexrs", "unjxfxR", "unjddxxR", "unjxdxxer", "unjxfexR", "unjxdexrs", "unjxdxtR", "unjxdxter", "unjxdxrs", "unjxfxrs", "unjddxxl", "unjxdxxl", "unjxdddrs", "unjxfxr", "unjddxl", "unjxdexl", "unjddxR", "unjxdexR", "unjddxxer", "unjxdxxr", "unjxdddr", "unjddxxr", "unjxdxtl", "unjxdxer", "unjddxer", "unjxdddR", "unjddxr", "unjxdexer", "unjxfexr"], "intResult": ["IntRate", "intResponse", "IntResponse", "mintOrder", "longResponse", "longCode", "intCode", "INTResult", " intRes", "intRest", "ntResponse", "longRes", "IntReturn", "mintRate", "intOrder", "intReturn", "longResult", " intRest", "IntRest", "ntResult", "intRes", "IntResult", " intReturn", "ntCode", "IntRes", "INTReturn", "INTRes", "ntRes", "mintReturn", "IntOrder", "mintResult", "IntCode", "intRate", " intRate", "INTRest", " intOrder"], "sql": ["dd", "log", "cmd", "section", "printf", "nl", "plan", "SQL", "sync", "l", "conn", "pr", "url", "string", "params", " SQL", "query", "join", "job", "ql", "eps", "sb", "mt", "sq", "socket", "ssl", "statement", "joined", "msg", "search", "fn", "limit", "str", "sl", "comment", "database", "dl", "select", "db", "pg", "QL"], "connection": ["log", "index", "section", "ion", "function", "Connection", "table", "environment", "conn", "writer", "application", "driver", "c", "engine", "position", "condition", "collection", "session", "relation", "BC", "query", "handler", "container", "client", "cc", "character", "context", "manager", "statement", "communication", "cp", "proxy", "con", "loc", "server", "document", "connect", "database", "reader", "ctx", "connected", "config", "bc", "db", "pg", "socket"], "ps": ["ports", "posts", "syn", "changes", "po", "ops", "Ps", "ls", "pc", "details", "ns", "ping", "pers", "ms", "conn", "mp", "pr", "sp", "pe", "pp", "pps", "params", "pa", "p", "ds", "relations", "os", "eps", "cs", "qs", "ins", "hs", "rs", "ups", "pse", "cp", "gs", "proxy", "ips", "bs", "PS", "ks", "ts", "pg", "ppa"]}}
{"id1": "21999120", "id2": "3536332", "code1": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"encrypt": ["encrypted", "decryption", "decrypted", "encryption", "Encrypt", "Encrypted", "crypted", "decrypt", "Encryption", "encipher", "cryption", "cipher", "decipher", "crypt", "Encipher"], "password": ["enc", "Password", " Password", "account", "prefix", "content", "input", " passwords", "pattern", "text", "message", "key", "wd", "string", "buffer", "pass", "crypt", "token", "path", "padding", "phrase", "p", "attribute", "number", "secret", "auth", "name", "PASS", "word", "data", "seed", "username", "sword", "security", "address"], "md5": ["hash5", "MD4", "hash2", "MD512", "MD53", "MD5", " md53", "md512", " MD2", "md8", " md512", "md2", "md4", " md2", " MD512", " MD8", " MD5", " MD4", " MD53", " mdless", " md8", "MDless", " md4", "MD2", "MD8", "mdless", "hash512", "md53", "hashless"], "hash": ["image", "her", "sha", "num", "log", "html", "hex", "check", "square", "version", "message", "count", "cache", "key", "output", "object", "update", "string", "fill", "array", "kh", "result", "build", "sh", "number", "sign", "mac", "handle", "ash", "length", "auth", "Hash", "sum", "hed", "h", "value", "dot", "cover"], "hashword": ["ashword", "Hashkey", " hashWord", "hashpassword", "hashkey", "Hashwords", "sumword", "sumwords", " hashkey", "hashWord", "HashWord", "sumkey", "Hashword", "trustbyte", "hashbyte", "trustWord", "ashbyte", "ashWord", "trustpassword", " hashbyte", "sumWord", "trustword", "hashwords", " hashpassword", " hashwords", "ashpassword"]}}
{"id1": "12537270", "id2": "12490144", "code1": "    public Vector parse(String link) {\n        addMessage(\"Parsing: \" + link);\n        links.removeAllElements();\n        URLConnection conn = null;\n        Reader rd = null;\n        EditorKit kit = new HTMLEditorKit();\n        Document doc = kit.createDefaultDocument();\n        doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE);\n        URL url = null;\n        try {\n            url = new URL(link);\n        } catch (MalformedURLException err) {\n            System.out.println(\"Malformed URL\");\n            return links;\n        }\n        try {\n            conn = new URL(link).openConnection();\n            rd = new InputStreamReader(conn.getInputStream());\n        } catch (Exception err) {\n            err.printStackTrace();\n            return links;\n        }\n        try {\n            kit.read(rd, doc, 0);\n            ElementIterator it = new ElementIterator(doc);\n            javax.swing.text.Element elem;\n            while ((elem = it.next()) != null) {\n                SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A);\n                if (s != null) {\n                    if (s.toString().indexOf(\"script\") >= 0) continue;\n                    String lnk = \"\";\n                    try {\n                        lnk = s.getAttribute(HTML.Attribute.HREF).toString();\n                    } catch (Exception err) {\n                        continue;\n                    }\n                    int j = 0;\n                    if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j);\n                    URL urlLink = new URL(url, lnk);\n                    if (!url.getHost().equals(urlLink.getHost())) continue;\n                    String str = urlLink.toString();\n                    if (!str.startsWith(\"http\")) continue;\n                    if (str.endsWith(\".pdf\")) {\n                        continue;\n                    }\n                    for (int i = 0; i < leaveSuffix.length; i++) {\n                        if ((str.endsWith(leaveSuffix[i]))) continue;\n                    }\n                    boolean skip = false;\n                    for (int i = 0; i < suffix.length; i++) {\n                        if ((str.endsWith(suffix[i]))) skip = true;\n                    }\n                    if (!skip) {\n                        try {\n                            conn = urlLink.openConnection();\n                        } catch (Exception err) {\n                        }\n                        String contentType = null;\n                        if (contentType == null) contentType = conn.getContentType();\n                        if (contentType.equals(\"application/pdf\")) {\n                            continue;\n                        } else if (!contentType.equals(\"text/html\")) {\n                            continue;\n                        }\n                    }\n                    if (!links.contains(urlLink.toString())) {\n                        links.addElement(urlLink.toString());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "code2": "    private void createJCoPluginProject(IProgressMonitor monitor, String sourceFileName, String pluginName) throws CoreException, IOException {\n        monitor.subTask(MessageFormat.format(Messages.ProjectGenerator_CreatePluginTaskDescription, pluginName));\n        final Map<String, byte[]> files = readArchiveFile(sourceFileName);\n        monitor.worked(10);\n        IProject project = workspaceRoot.getProject(pluginName);\n        if (project.exists()) {\n            project.delete(true, true, new SubProgressMonitor(monitor, 5));\n        } else {\n            monitor.worked(5);\n        }\n        project.create(new SubProgressMonitor(monitor, 5));\n        project.open(new SubProgressMonitor(monitor, 5));\n        IProjectDescription description = project.getDescription();\n        description.setNatureIds(new String[] { JavaCore.NATURE_ID, PLUGIN_NATURE_ID });\n        project.setDescription(description, new SubProgressMonitor(monitor, 5));\n        IJavaProject javaProject = JavaCore.create(project);\n        IFolder binDir = project.getFolder(\"bin\");\n        IPath binPath = binDir.getFullPath();\n        javaProject.setOutputLocation(binPath, new SubProgressMonitor(monitor, 5));\n        project.getFolder(\"jni\").create(true, true, new SubProgressMonitor(monitor, 5));\n        project.getFile(\"sapjco3.jar\").create(new ByteArrayInputStream(files.get(\"sapjco3.jar\")), true, new SubProgressMonitor(monitor, 10));\n        IFolder metaInfFolder = project.getFolder(\"META-INF\");\n        metaInfFolder.create(true, true, new SubProgressMonitor(monitor, 5));\n        StringBuilder manifest = new StringBuilder();\n        manifest.append(\"Manifest-Version: 1.0\\n\");\n        manifest.append(\"Bundle-ManifestVersion: 2\\n\");\n        manifest.append(\"Bundle-Name: SAP Java Connector v3\\n\");\n        manifest.append(MessageFormat.format(\"Bundle-SymbolicName: {0}\\n\", pluginName));\n        manifest.append(\"Bundle-Version: 7.11.0\\n\");\n        manifest.append(\"Bundle-ClassPath: bin/,\\n\");\n        manifest.append(\" sapjco3.jar,\\n\");\n        manifest.append(\" jni/\\n\");\n        manifest.append(\"Bundle-Vendor: SAP AG, Walldorf (packaged using RCER)\\n\");\n        manifest.append(\"Bundle-RequiredExecutionEnvironment: J2SE-1.5\\n\");\n        manifest.append(\"Export-Package: com.sap.conn.jco,\\n\");\n        manifest.append(\" com.sap.conn.jco.ext,\\n\");\n        manifest.append(\" com.sap.conn.jco.monitor,\\n\");\n        manifest.append(\" com.sap.conn.jco.rt,\\n\");\n        manifest.append(\" com.sap.conn.jco.server\\n\");\n        manifest.append(\"Bundle-ActivationPolicy: lazy\\n\");\n        writeTextFile(monitor, manifest, metaInfFolder.getFile(\"MANIFEST.MF\"));\n        final IPath jcoPath = new Path(MessageFormat.format(\"/{0}/sapjco3.jar\", pluginName));\n        IClasspathEntry jcoEntry = JavaCore.newLibraryEntry(jcoPath, Path.EMPTY, Path.EMPTY, true);\n        final IPath jniPath = new Path(MessageFormat.format(\"/{0}/jni\", pluginName));\n        IClasspathEntry jniEntry = JavaCore.newLibraryEntry(jniPath, Path.EMPTY, Path.EMPTY, true);\n        javaProject.setRawClasspath(new IClasspathEntry[] { jcoEntry, jniEntry }, new SubProgressMonitor(monitor, 5));\n        StringBuilder buildProperties = new StringBuilder();\n        buildProperties.append(\"bin.includes = META-INF/,\\\\\\n\");\n        buildProperties.append(\"               sapjco3.jar,\\\\\\n\");\n        buildProperties.append(\"               jni/,\\\\\\n\");\n        buildProperties.append(\"               .\\n\");\n        writeTextFile(monitor, buildProperties, project.getFile(\"build.properties\"));\n        exportableBundles.add(modelManager.findModel(project));\n    }\n", "label": 0, "substitutes": {"parse": ["ize", "raw", "ract", "format", "scan", "patch", "open", "match", "load", "parser", "process", "update", "read", "apply", "split", "se", "build", "Parser", "see", "xml", "report", "pack", "ge", "eval", "arse", " analyse"], "link": ["linked", "image", "html", "URL", "base", "Link", "ink", "match", "inline", "links", "text", "message", "http", "load", "local", "add", "l", "href", "info", "page", "like", "string", "style", "route", "tag", "path", "li", "lang", "line", "type", "rel", "uri", "bug", "xml", "name", "location", "word", "loc", "ln", "data", "file", "id", "e", "lock", "connection", "msg", "source", "address"], "conn": ["enc", "err", "apt", "dr", "cmd", "nt", "config", "pt", "dc", "nc", "pc", "open", "ctrl", "rt", "Connection", "ca", "rec", "ch", "ann", "act", "c", "r", "Config", "ct", "rc", "db", "ci", "er", "p", "io", "ai", "out", "client", "cc", "socket", "ssl", "col", "ac", "con", "cn", "rn", "connect", "Conn", "mc", "n", "ctx", "cp", "connection", "loc", "cr", "pg"], "rd": ["dd", "nd", "dr", "lr", "fr", "rx", "dc", "rog", "rid", "xd", "rt", "RD", "RR", "adr", "ld", "wd", "rg", "r", "rc", "fd", "bd", "ds", "rr", "rh", "ra", "rs", "hr", "sr", "RM", "rn", "rm", "RS", "rss", "rl", "rw", "rb", "reader", "ru", "dra"], "kit": ["kin", "plugin", "base", "nt", "feed", "site", "sci", "ku", "w", "format", "et", "py", "bot", "net", "rt", "kat", "tk", "ut", "api", "b", "ui", "info", "cat", "auto", "tools", "pit", "Kit", "kt", "ct", "wt", "spec", "t", "k", "p", "io", "pot", "os", "sit", "util", "bug", "fit", "loader", "tool", "init", "h", "qt", "browser", "reader", "rot", "lib", "config", "ki", "cr", "f"], "doc": ["Doc", "body", "dec", "de", "html", "base", "in", "dr", "fr", "tt", "DOC", "config", "root", "coll", "dc", "val", "po", "open", "mm", "pc", "text", "http", "ref", "api", "info", "page", "pos", "dom", "d", "div", "out", "dir", "bug", "xml", "pub", "md", "ac", "docs", "loc", "msg", "data", "file", "document", "mc", "tx", "desc", "bc", "di", "m", "tag", "db", "f"], "url": ["image", "log", "html", "URL", "base", "resource", "lr", "www", "feed", "service", "config", "download", "Url", "hub", "http", "src", "github", "href", "l", "page", "cdn", "path", "org", "uri", "pull", "blog", "bug", "util", "xml", "ur", "name", "location", "ssl", "host", "server", "file", "ll", "gl", "sl", "rl", "el", "connection", "loc", "source", "f", "address"], "it": ["IT", "its", "in", "nt", "end", "lit", "et", "edit", "mit", "l", "info", "pit", "r", "t", "ic", "st", "split", "ait", "ci", "p", "stat", "se", "v", "ip", "sit", "ite", "iz", "init", "iti", "id", "iterator", " It", "It", "iter", "or", "you", "dit"], "elem": ["Elements", "elev", "eelement", "selement", "oelement", "selem", "pelement", "eade", "eelem", "Elem", "eler", "seject", "selements", "elements", "element", "Eject", "oelev", " nelem", "eelements", "Elev", "Eler", "peler", "eeject", "pelem", " Eler", "eject", "Element", " nelement", "oelem", " neade", " neler", " Element", "oeler", "pelev", " Elem", " Eade", "Eade"], "s": ["o", "service", "submit", "sch", "ops", "ls", "services", "details", "ns", "sync", "b", "ws", "scope", "js", "string", "set", "c", "r", "spec", "session", "g", "xs", "t", "ps", "params", "d", "ds", "p", "si", "S", "se", "sb", "v", "sv", "attr", "os", "fs", "ses", "rs", "es", "ssl", "a", "gs", "h", "server", "e", "sf", "sym", "u", "sl", "ss", "n", "sets", "ts", "m", "strings", "f", "parts"], "lnk": ["lnks", "nlky", "nnku", "olnke", "gnky", "knK", "dlk", "dlf", "linke", "knk", "lenky", "dlke", "dnf", "gnok", "nlkh", "nlok", "nnk", "lnkr", "lnf", "olnK", "nlk", "nnky", "dlok", "dnk", "nlf", "nlks", "lnke", "linf", "lenke", "gnk", "lenks", "olnkr", "lnK", "olnk", "lenku", "gnke", "lnkh", "dnke", "lnku", "dlky", "lnky", "dlkr", "nnke", "dnky", "nlke", "nlK", "knke", "linky", "olnf", "dnkr", "lnok", "knkh", "dnku", "lenk", "olnkh", "dlks"], "j": ["z", "aj", "index", "jc", "o", "fr", "kj", "syn", "jl", "ii", "ne", "key", "ch", "info", "jp", "js", "pr", "pos", "uj", "g", "ind", "li", "job", "ie", "note", "p", "m", "part", "ni", "si", "ja", "x", "ji", "dj", "y", "jj", "name", "oj", "a", "qi", "jo", "J", "adj", "im", "ij", "n", "br", "obj"], "urlLink": ["urllink", "URLLink", "strLink", " urlLine", "UrlRel", "UrlPath", "urlPath", "filePath", "strLine", "URLRel", "urlUrl", " urllink", "resourcelink", "URLPage", "resourceLink", " urlUrl", " urlPage", "urlRel", "URLUrl", "fileHub", "urlLine", "urlHub", "UrlLink", "urlPage", "strlink", "resourceConnect", "UrlUrl", " urlRel", " urlConnect", "fileUrl", "fileLink", "urlConnect", "strConnect", "resourceLine", "UrlHub", " urlPath", "UrlPage", " urlHub"], "str": ["enc", "dec", "err", "dr", "fr", "spr", "kr", "coll", "inner", "arr", "obj", "text", "l", "STR", "b", "ctr", "js", "pr", "string", "txt", "sp", "r", "pass", "t", "tr", "wr", "strip", "st", "stri", "line", "div", "elt", "name", "hr", "ext", "sr", "sta", "data", "inst", "char", "Str", "sl", "res", "n", "br", "cr", "f"], "i": ["ini", "mi", "index", "o", "in", "yi", "oi", "chi", "uli", "hi", "phi", "ii", "ix", "fi", "slice", "mu", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "abi", "li", "ci", "p", "en", "multi", "si", "ni", "xi", "bi", "v", "x", "ai", "ji", "io", "eni", "y", "ip", "uri", "init", "ori", "qi", "ti", "id", "e", "iu", "f", "u", "vi", "n", "di", "m", "I", "zi"], "skip": [" dup", "fast", "stop", " scan", "scan", "special", "active", "add", "replace", "jump", " bypass", " skipped", " exclude", "sp", " skipping", "Skip", "cmp", "loop", " duplicate", " repeat", "ips", "error", "empty", "complete", "iter", "append", "copy"]}}
{"id1": "1421557", "id2": "6866575", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeString2File", "encodeFileFromStream", "encodeFileFromString", "encodeStringToStream", "encodeString2Files", "encodeFiletoStream", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFiles", "encodeFiletoFile", "encodeFileFromFiles", "encodeFileFromFile", "encodeString2Stream", "encodeStringToString", "encodeFileToString", "encodeFile2String", "encodeString2String", "encodeFile2File", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFile2Files", "encodeFileToStream"], "infile": [" infilename", "infiles", "Infilename", "outFile", "inputfile", "outfiles", "inFile", "InFile", "inputfilename", " infiles", " infp", "inputFile", "outfilename", "outfp", "Infiles", "inputfiles", "infp", "inputfp", "infilename", "Infile"], "outfile": ["newfolder", "outname", "outFile", " outFile", "outputfp", "outputfilename", " outfilename", "Outname", "outfolder", "outputfolder", " outfp", "Outfolder", "newfile", "newname", " outfolder", "infolder", "newFile", "outfilename", "outfp", "outputfile", "OutFile", "infp", " outname", "infilename", "Outfile"], "in": ["re", "err", "ini", "image", "base", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "vin", "m", "din", "socket", "inc", "s"], "out": ["err", "ou", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "In", "obj", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "outs", "work", "job", "source", "line", "io", "Out", "client", "off", "name", "co", "on", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "count", "cache", "slice", "queue", "b", "bytes", "bb", "null", "buf", "buff", "border", "padding", "fb", "split", "uffer", "type", "result", "len", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "input", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "close", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "model", "method", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "respons", "open", "better", "message", "growth", "modified", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "20717531", "id2": "23398710", "code1": "    public static String encrypt(String plainText) {\n        if (TextUtils.isEmpty(plainText)) {\n            plainText = \"\";\n        }\n        StringBuilder text = new StringBuilder();\n        for (int i = plainText.length() - 1; i >= 0; i--) {\n            text.append(plainText.charAt(i));\n        }\n        plainText = text.toString();\n        MessageDigest mDigest;\n        try {\n            mDigest = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            return plainText;\n        }\n        mDigest.update(plainText.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    public String getUser() {\n        try {\n            HttpGet get = new HttpGet(\"http://api.linkedin.com/v1/people/~\");\n            consumer.sign(get);\n            HttpClient client = new DefaultHttpClient();\n            HttpResponse response = client.execute(get);\n            if (response != null) {\n                int statusCode = response.getStatusLine().getStatusCode();\n                if (statusCode != 200) {\n                    this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n                }\n                StringBuffer sBuf = new StringBuffer();\n                String linea;\n                BufferedReader reader = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), \"UTF-8\"));\n                while ((linea = reader.readLine()) != null) {\n                    sBuf.append(linea);\n                }\n                reader.close();\n                response.getEntity().consumeContent();\n                get.abort();\n                String salida = sBuf.toString();\n                String user_firstname = salida.split(\"</first-name>\")[0].split(\"<first-name>\")[1];\n                String user_lastname = salida.split(\"</last-name>\")[0].split(\"<last-name>\")[1];\n                return user_firstname + \" \" + user_lastname;\n            }\n        } catch (UnsupportedEncodingException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (IOException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthMessageSignerException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthExpectationFailedException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthCommunicationException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"encrypt": [" decipher", " deccrypt", "encress", "Enccrypt", " encipher", "Encrypt", "encipher", "Encress", " decress", " decrypt", " enccrypt", " encress", "Encipher", "enccrypt"], "plainText": ["protectedString", "flatTEXT", "publicTEXT", "protectedTextColor", " plainTarget", "binarytext", "batTEXT", "simpletext", "plainTextColor", "singletext", "binaryText", "externalText", "binaryPart", "externalString", "batText", "flatText", "batContent", "protectedContent", "battext", "simpleText", "flatTime", "singleString", "singlePart", " plainPart", "protectedtext", "publictext", " plainTextColor", "fullData", "plaintext", "originalTextColor", "externaltext", "flattext", "plainTarget", "fullTEXT", "plainTime", " plainData", "externalKey", " plainTEXT", "plainString", "fulltext", "originalText", " plainKey", "plainData", "binaryString", "publicTarget", "originalTEXT", "publicText", "plainContent", "simpleTime", "protectedKey", "flatContent", "protectedTEXT", " plainString", "plainKey", "originaltext", "flatData", "simpleTEXT", "plainTEXT", "singleText", "fullText", " plainContent", "plainPart", "flatTarget", "protectedText", "fullTime", " plaintext"], "text": ["image", "letter", "service", "feed", "null", "config", "event", "form", "input", "pattern", "message", "output", "key", "use", "b", "writer", "post", "object", "struct", "password", "print", "string", "txt", "builder", "code", "math", "contract", "font", "url", "buffer", "Text", "path", "source", "result", "width", "out", "length", "editor", "context", "off", "test", "ext", "word", "data", "id", "port", "str", "value", "tx", "TEXT", "append", "address"], "i": ["ini", "z", "mi", "index", "j", "o", "in", "chi", "temp", "io", "field", "hi", "phi", "ii", "ix", "fi", "slice", "mu", "key", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "t", "abi", "li", "ind", "k", "ci", "ie", "p", "multi", "si", "ni", "xi", "I", "bi", "v", "x", "ai", "ji", "uri", "eni", "it", "ip", "y", "ti", "h", "id", "qi", "e", "iu", "f", "u", "vi", "n", "di", "m", "oi", "s"], "mDigest": ["mDest", "mHashusher", " mDigester", "mDigusher", "mdigEST", "MDester", "MDex", "mHashester", "mEdest", "cmdigester", "cmDigester", " mDigEST", "MDest", "mHashest", "mDigse", "mDigEST", "mDigex", "MDigex", "cmdigest", "mdigex", "mdigester", "mDigger", " mHashusher", "mdigusher", "mdigse", "mDer", " mHashest", "mDigester", "mDester", " mDEST", "mDusher", "cmDigest", "mEdester", "mDger", " mDse", "mDigests", "mCompest", "mCompester", "mDested", " mDest", "mDiger", "mDex", "cmDiger", "mdigested", "mdiger", "mDests", "mEder", " mHashester", "mCompex", "mEdested", "mdigger", " mHashger", "MDigest", "mdigest", " mDigse", "MDigests", " mDester", "mHashse", "cmdigested", "cmdiger", " mDigger", "mDigested", "cmDigested", "mHashger", "mDse", "MDests", "mdigests", "mCompests", "mDEST", "mHashEST", " mDigusher", "MDigester"], "d": ["dd", "z", "dim", "dr", " D", "dc", "dat", "dig", "D", "dos", "l", "b", "bytes", "ld", "cd", "string", "da", "did", "c", " data", "t", "fd", "p", "ds", "dt", "v", "x", "sd", "md", "a", "h", "data", "id", "dh", "ded", "e", "dn", "str", "u", "n", "di", "dl", "m", "db", "f", "s"], "hash": ["image", "her", "sha", "html", "log", "base", "hex", "history", "square", "version", "message", "key", "output", "b", "bin", "print", "string", "code", "array", "kh", "buffer", "db", "result", "build", "v", "sh", "number", "ashes", "secret", "carry", "mac", "ash", "block", "size", "ssh", "Hash", "bar", "hed", "sum", "h", "ha", "shadow", "user", "header", "str", "dot", "memory", "f", "url", "cover"]}}
{"id1": "255765", "id2": "17296916", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "label": 1, "substitutes": {"f": ["fo", "j", "folder", "fr", "feed", "of", "this", "fa", "self", "fun", "inf", "form", "w", "lf", "F", "function", "ff", "fen", "fm", "fe", "fi", "ref", "fc", "filename", "l", "b", "c", "cf", "r", "rf", "g", "t", "fd", "path", "d", "p", "io", "v", "df", "flat", "x", "fp", "fs", "fx", "name", "a", "tf", "h", "fold", "file", "fn", "e", "sf", "n", "bf", "m", "s"], "in": ["fa", "In", "rec", "c", "again", "t", "p", "it", "v", "ins", "thin", "isin", "str", "connection", "m", "source", "lin", "login", "gin", "input", "bin", "b", "r", "session", "g", "pass", "token", "ic", "d", "nin", "is", "init", "reader", "win", "get", "din", "ini", "err", "serv", "inner", "inn", "fe", "l", "IN", "cin", "diff", "ssl", "data", "gen", "lock", "ex", "vin", "or", "inc", "exec", "socket", "image", "w", "with", "up", "pin", "part", "min", "a", "ac", "con", "rin", "n", "config"], "cbuf": ["bburs", "rburs", "cbuu", "bcuf", "ebutf", "bcurs", "rbul", "rbuu", "bcuc", "cbur", "bault", "ebuu", "dbuf", "rbuc", "dbur", "bcault", "rbuf", "CBuc", "dbuff", "cfuff", "CBuff", "bcux", "zbuf", "rbbuf", "bbuf", "zbuu", "cfuc", "cbault", "rbull", "bcull", "bux", "buf", "buff", "cbux", "fbuff", "bcur", "dbuc", "bcuff", "cbuc", "rbutf", "fbuf", "cbbuf", "fbbuf", "cburs", "bbull", "CBul", "ebuff", "ebuf", "cbuff", "fbuc", "cbul", "rbux", "zbuff", "bcul", "cfbuf", "rbault", "cbutf", "rbuff", "CBuf", "bbuff", "zbutf", "cfuf", "cfur", "cbull"], "read": ["repeat", "create", "q", " reading", "ak", "bind", "hex", "skip", "full", "print", "ack", "rc", "ok", "it", "length", "only", "name", "report", "call", "old", "lex", "log", "send", "child", "check", "write", "input", "oct", "count", "reading", "Read", "run", "add", "play", "sync", "ride", "fill", "r", "cel", "g", "pass", "d", "k", "io", "record", "allow", "used", "build", "insert", "size", "id", "connect", "last", "error", "reader", "get", "wait", "seek", "select", "re", "change", "stream", "ink", "parse", "text", "reads", " write", "bit", "use", "un", "update", " READ", "ed", "readable", "ind", "er", "type", "sleep", "se", "x", "know", "each", "data", "READ", "level", "put", "inc", "socket", "num", "index", "ize", "feed", "raw", "end", "ing", "view", "val", "draw", "w", "open", "find", "load", "want", "key", "pe", "orig", "buffer", "work", "en", "loop", "y", "start", "close", "valid", " Read", "iter", "config"], "totRead": ["dotRead", "TotaDraw", "totDraw", "tottedFollow", "dottFind", "tottedWrite", " totalLink", "tottSearch", "totoConnect", "tollWrite", "tottUse", "totalLoad", "tottConnect", "totSearch", "totalBuild", "ntottLoad", "ntottReader", "totFind", "totoReading", "tcotLoad", "totiWrite", " totLink", "TotDraw", "tcotClose", "totWrite", "dottUse", "totingGet", "tcotBuild", "totoUse", "dottWrite", "dottReading", "dotUse", "towLength", "totingFollow", " totWrite", "notRead", "ntottRead", "tottLoad", "tntWrite", "octotReading", "towReading", "toyRead", "intottLoad", "TottReader", "tottClose", "tazonBuild", "tollRead", "totFollow", "totaReading", " totBuild", "tottDraw", "octotLength", "totalWrite", "TotConnect", "tetRead", "ntotRead", "TottFollow", "dotLoad", "octotWrite", "totoSearch", "ntotWrite", "tatRead", "tochReader", "notWrite", "tntLoad", "TottReading", "toyDraw", "tottReader", "totAccept", "tobyFind", "tottFollow", "tazonRead", "totiRead", "TottConnect", "notLoad", "tntRead", "TotaRead", "tatLoad", "TotLoad", "totoLoad", "totingRead", "ntotLoad", "TotFollow", "totaBuild", "tatReader", "TottSearch", "tcotRead", "tollLoad", "nottLoad", "totingConnect", "totaReader", "totReader", "toyLoad", "tazonClose", "totaLoad", "TotaWrite", "TotaLoad", "totaWrite", "totalRead", "totingWrite", "notAccept", "totoRead", "tottAccept", "tottLength", "towLoad", "octotRead", "totUse", "totLength", "tottReading", "totLink", "totiLink", "tetWrite", "tottFind", " totalWrite", "intotClose", "intottClose", "totLoad", "totReading", "tottWrite", "totaLink", "TotRead", "tetLoad", "intottRead", "nottAccept", "TottLoad", "nottRead", "tottBuild", "tottedGet", "tobyUse", "TotReader", " totalRead", "tobyLoad", "ntottWrite", "tochWrite", "ntotReader", "totoFind", "octotoLength", "dottRead", "totingSearch", "tochLoad", "tottRead", "dotWrite", "towRead", "TotReading", "intotRead", "totalLink", "octotoReading", "totBuild", "toyWrite", "TottWrite", "totGet", "tntReader", "dotReading", "totaRead", "totConnect", "dottReader", "TotGet", "towWrite", "totiBuild", "TotWrite", "totaDraw", "tollReading", "tatWrite", "TottGet", "tetReading", "totalAccept", "towAccept", " totalBuild", "TotSearch", "dotFind", "totClose", "TottRead", "tochRead", "tazonLoad", "nottWrite", "totoLength", "tottedRead", "dotReader", "tobyRead", "intotBuild", "octotoRead", "intottBuild", "octotoWrite", "intotLoad", "tottGet", "totoWrite", "dottLoad"], "out": ["err", "o", "outer", "w", "In", "net", "up", "exp", "sync", "output", "OUT", "l", "bin", "b", "conn", "writer", "c", "r", "g", "again", "t", "outs", "d", "plus", "p", "part", "conf", "io", "v", "x", "Out", "client", "off", "socket", "init", "ext", "a", "ac", "h", "file", "fn", "parent", "ex", "n", "connection", "inc", "exec", "obj", "s"], "i": ["z", "q", "current", "fi", "ui", "ri", "c", "ci", "p", "multi", "it", "v", "ji", "length", "name", "u", "m", "source", "ei", "j", "o", "input", "slice", "ik", "api", "b", "info", "pi", "r", "gi", "g", "ic", "k", "d", "io", "ni", "ip", "is", "init", "ti", "id", "iu", "zi", "ini", "mi", "yi", "hi", "phi", "ii", "ix", "l", "abi", "ind", "ie", "si", "xi", "eni", "x", "me", "data", "one", "di", "oi", "index", "chi", "key", "buffer", "li", "bi", "uri", "ai", "y", "start", "ori", "qi", "h", "my", "e", "I"]}}
{"id1": "3584508", "id2": "15799935", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "label": 1, "substitutes": {"copyResource": [" downloadResource", " downloadFile", " downloadUrl", " copyFile", "copyUrl", "transferFile", "transferResource", " copyresource", " copyUrl", "transferUrl", "transferresource", "copyFile", "copyresource", " downloadresource"], "url": ["re", "image", "URL", "base", "resource", "lr", "feed", "www", "stream", "Url", "download", "ls", "ref", "http", "src", "remote", "l", "object", "page", "string", "r", "bel", "path", "ource", "uri", "xml", "loader", "name", "ssl", "server", "data", "file", "host", "id", "sl", "connection", "loc", "source", "web", "f", "address"], "input": ["image", "index", "base", "in", "resource", "temp", "feed", "this", "stream", "current", "inner", "inf", "form", "audio", "open", "Input", "active", "accept", "parse", "http", "cache", "load", "l", "api", "bb", "bin", "element", "act", "ack", "buffer", "session", "plus", "progress", "upload", "out", "pull", "client", "context", "xml", "but", "socket", "ssl", "request", "data", "file", "binary", "qa", "instance", "error", "i", "reader", "get", "connection", "config", "source", "exec", "f", "inc", "address"], "output": ["image", "flow", "unit", "log", "ou", "resource", "outer", "other", "stream", "current", "production", "write", "target", "cache", "queue", "writer", "environment", "object", "application", "external", "buffer", "control", "result", "console", "out", "response", "layer", "network", "operation", "Output", "file", "data", "binary", "document", "put", "default", "connection", "config", "source", "web", "socket", "copy", "address"], "b": ["base", "nb", "br", "abs", "bit", "l", "bb", "bin", "cb", "buf", "c", "r", "buffer", "d", "k", "lb", "fb", "be", "p", "line", "bi", "sb", "v", "x", "B", "pb", "bar", "a", "h", "bs", "file", "ob", "binary", "e", "i", "rb", "mb", "n", "bc", "bf", "batch", "m", "db", "f", "ab"]}}
{"id1": "8000624", "id2": "530882", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"CopyTo": [" transferto", "copyto", "CopyFrom", " transferFrom", " copyTo", " copyFile", "copyFrom", "CopyFile", " copyFrom", "copyTo", " transferTo", "copyFile", " copyto", " transferFile", "Copyto"], "dest": ["folder", "wb", "die", " destination", "temp", "cont", "done", "content", "w", "transform", " Dest", "write", "target", "them", "src", "filename", "output", "later", "bin", "table", "object", "sup", "comb", "txt", "class", "orig", "exit", "dist", "path", "opt", "flat", "img", "rest", "tmp", "name", "test", "Dest", "data", "file", "desc", "delete", "destroy", "source", "obj"], "in": ["re", "image", "ini", "kin", "login", "wave", "fa", "inner", "inn", "gin", "input", "din", "In", "up", "l", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "plus", "source", "nin", "sin", "x", "cin", "issue", "pull", "ins", "as", "init", "inside", "ac", "thin", "h", "con", "ln", "rin", "ax", "isin", "id", "reader", "i", "win", "n", "vin", "lib", "connection", "m", "inc", "f", "lin", "s"], "out": ["err", "ou", "image", "o", "outer", "temp", "other", "this", "inner", "outside", "w", "net", "target", "our", "up", "or", "cache", "sync", "output", "OUT", "writer", "b", "conn", "bin", "object", "url", "pin", "external", "again", "outs", "not", "plus", "nin", "part", "io", "x", "Out", "client", "off", "app", "name", "ext", "data", "file", "vert", "user", "call", "ex", "i", "no", "timeout", "n", "one", "lib", "inc", "exec", "socket", "copy"], "c": ["enc", "lc", "esc", "o", "config", "dc", "content", "exc", "cl", "pc", "fc", "cu", "ca", "l", "ch", "cb", "arc", "C", "code", "cf", "r", "ct", "buffer", "rc", "t", "ic", "d", "ci", "p", "sc", "pointer", "v", "x", "ce", "cy", "xc", "cc", "oc", "cm", "col", "ac", "e", "char", "u", "comment", "i", "abc", "n", "uc", "bc", "ec", "m", "cr", "f"]}}
{"id1": "12066447", "id2": "18570190", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"truncate": ["autatenational", "autuncation", "truncator", "trunate", "autuncate", "autatenation", "autuncator", "trunation", "trrenation", "trrenator", "truncation", "tratenator", "trrenate", "trunational", "trrenational", "tratenate", "tratenational", "autuncational", "trunator", "autatenate", "truncational", "autatenator", "tratenation"], "file": ["File", "log", "image", "base", "folder", "resource", "model", "body", "address", "this", "stream", "current", "format", "function", "ile", "zip", "cache", "http", "local", "filename", "queue", "l", "info", "full", "object", "page", "string", "class", "future", "files", "path", "handler", "single", "plus", "type", "line", "io", "uri", " File", "it", "out", "fp", "FILE", "name", "archive", "data", "binary", "document", "e", "parent", "time", "one", "per", "get", "or", "connection", "source", "db", "f", "url", "directory"], "backupRoot": ["backbaseRoot", "backUpDir", "BackupRoot", "backbackDir", "backupsFolder", "backupHome", "frontupFolder", "backdownDirectory", "backdownFile", "backdownFolder", "backureDirectory", "Backuproot", "BackureRoot", "BackbackFile", "backupsPath", "backUpRoot", "backupsDir", "backdownRoot", "backflowRoot", "backdownroot", "backbackDirectory", "BackureDirectory", "backupDirectory", "BackbackRoot", "backupFolder", "backupsroot", "backbaseDirectory", "BackdownRoot", "BackdownPath", "backupsDirectory", "backflowFile", "backflowDir", "backupsRoot", "BackbackDir", "backupFile", "Backbackroot", "Backdownroot", "backureDir", "BackupDir", "BackureDir", "backbackroot", "frontdownFolder", "frontdownDir", "frontuproot", "frontupDir", "backUproot", "backureHome", "backUpFolder", "BackupHome", "backupPath", "BackupDirectory", "BackupPath", "backdownHome", "backbasePath", "backuproot", "backureRoot", "backbackFile", "backdownDir", "frontdownroot", "BackureHome", "BackdownDirectory", "frontdownRoot", "backbaseroot", "backbackHome", "backflowroot", "backupDir", "BackupFile", "frontupRoot", "backbackRoot", "backdownPath"], "df": ["dd", "DF", "flow", "de", "dp", "fr", "pdf", "func", "dc", "format", " def", "fe", "fc", "xf", "raf", "da", "cf", "def", "deb", "fd", "di", "d", "fb", "ds", "dt", "io", "CF", "fp", "fs", "dq", "md", "tf", "data", "fn", "af", "dn", "sf", "pd", "dm", "bf", "dl", "db", "f", "dict"], "date": ["re", "rule", "log", "fee", "j", "create", "module", "form", "dat", "format", "pre", "input", "D", "open", "version", "day", "age", "message", "back", "modified", "dose", "use", "output", "sync", "created", "update", "style", "string", "code", "updated", "atom", "days", "pe", "Date", "stage", "custom", "d", "work", "ate", "db", "type", "dt", "year", "x", "min", "out", "diff", "bug", "ale", "name", "ge", "data", "valid", "value", "str", "complete", " Date", "time", "m", "tag", "dates", "url"], "zipFile": ["zModel", " zipEntry", "ressModel", "zipModel", "sqlFile", "Zipfile", "ressSection", "sqlfile", "zFiles", "zSection", "zipFiles", "zFile", "ZipEntry", "zipEntry", "zipfile", "zipSection", "ressfile", "sqlModel", "sqlSection", "ZipFile", " zipfile", "zfile", "ressFile", "ZipFiles", " zipFiles", "zEntry"], "zos": ["z", "iffs", "her", "asio", "zes", "closure", "zx", "kos", "gz", "zb", "uz", "zar", "ops", "zzy", "cash", "ls", "dos", "bos", "osi", "lins", "zip", "nz", "liquid", "webkit", "zon", "nox", "zer", "js", "tz", "ZA", "zy", "exit", "zn", "inos", "outs", "zo", "forge", "eros", " sands", "zag", "bes", "ils", "settings", "chini", "ros", "ozo", "obb", "os", "bitcoin", "dylib", "css", "zl", "cos", "ses", "ssl", "proxy", "zan", "las", "zona", "han", "zik", "rez", "robe", "zen", "zero", "jas", "hess", "fits", "zh", "los", "budget", "zi", "address"], "fis": [" fits", "flisp", "rafris", "infiz", "flis", "rafis", "infids", "liss", "fisl", "flris", "fisp", "viz", "bos", "fias", "fids", "lis", "fils", "vis", " fos", "infits", "bisl", "fos", " fias", "lias", "infias", " fils", "vils", "Fisp", "infils", " fisp", "rafiss", " fiss", "Fisl", "Fos", "Fis", "fris", " fisl", "fiz", "bis", "Fiss", "fliss", "fiss", "lids", "infis", "vits", "flias", "biss", " fiz", "infiss", "flids", "Fias", "rafias", "fits", "Fris", " fris"], "entry": ["z", "lc", "her", "de", "image", "letter", "index", "feed", "ion", "offset", "event", "ry", "obj", "exp", "zip", "Entry", "add", "key", "info", "ui", "auto", "extra", "style", "element", "array", "so", "r", "cel", "ace", "next", "zo", "ie", "si", "record", "se", "uri", "it", "and", "row", " Entry", "term", "the", "archive", "ge", "server", "data", "ries", "cell", "e", "card", "comment", "reader", "per", "or", "address"], "buffer": ["shape", "wave", "feed", "sequence", "flush", "beta", "channel", "available", "cache", "slice", "queue", "b", "writer", "bytes", "bb", "device", "page", "pad", "null", "buf", "buff", "position", "border", "vector", "Buffer", "padding", "uffer", "result", "number", "row", "layer", "length", "FFER", "server", "data", "reference", "binary", "seed", "transfer", "comment", "reader", "iter", "batch", "memory", "header", "address"], "readed": ["intended", " Readable", "intized", "readered", "intED", " readable", " readered", "texted", "inputED", " Readed", "textended", "bootered", " Readled", " readned", "inputed", "textED", "inted", "bootable", " readED", " ReadED", "readable", " Readned", "readized", " readized", " readended", "inputled", "readled", "textized", "bootED", "booted", "readED", " readled", "readned", " Readered", "readended", "inputned"]}}
{"id1": "942693", "id2": "11933797", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"convert": ["oconversion", "CONversion", "oconverting", " deconverted", "CONverting", " deconvert", "conception", "CONception", " deconverting", "unverted", "subversion", "CONverted", "Conception", " deconversion", "oconvert", "unversion", "converted", "unception", "subvert", "conversion", "Convert", "unvert", "Converted", "subverted", "subverting", "converting", "oconverted", "Converting", "Conversion", "CONvert"], "src": ["video", "resource", "storage", "config", "stream", "Source", "impl", "gz", "RC", "input", "download", "feat", "req", "ref", "load", "back", "filename", "slice", "href", "cb", "prot", "url", "string", "code", "buf", "gb", "spec", "dist", "cpp", "rc", "stage", "sn", "path", "st", "sc", "cmp", "upload", "ource", "uri", "sb", "proc", "SourceFile", "sin", "img", "fp", "supp", "attr", "sit", "secure", "tmp", "name", "ssl", "Dest", "sel", "sys", "component", "file", "fn", "inst", "username", "sth", "reader", "rb", "rl", "ctx", "scene", "loc", "source", "obj", "s"], "dest": [" destination", "temp", "cont", "dc", "dat", "target", "bin", "home", "null", "txt", "class", "orig", "lib", "dist", "path", " dst", "img", "dir", "std", "tmp", "test", "Dest", "fn", "di", "source", "obj", "disk"], "in": ["ini", "err", "login", "stream", "inn", "inf", "val", "input", "In", "up", "bin", "pin", "r", "IN", "ps", "t", "pass", "d", "doc", "source", "io", "ins", "is", "as", "inas", "a", "data", "isin", "file", "ex", "i", "reader", "win", "n", "din", "f", "inc"], "p": ["np", "j", "o", "po", "pre", "py", "P", "pc", "cop", "parser", "l", "b", "jp", "pr", "bp", "lp", "pi", "pp", "sp", "pe", "c", "r", "wp", "g", "ps", "t", "pa", "d", "op", "pg", "part", "pm", "v", "fp", "pb", "h", "tp", "pd", "e", "i", "per", "cp", "m", "f", "s"], "ds": ["ths", "dp", "vals", "ls", "services", "ads", "ld", "lp", "groups", "dt", " ps", "os", "ins", "icks", "nas", "ts", "dates", "scripts", "s", "dc", "dat", "Ds", "points", "els", "sync", "tools", "ipes", "xs", "obs", "sts", "d", "ils", "dds", "hs", "gs", "docs", "sys", "pd", "dm", "ss", "dl", "des", "posts", " DS", "utils", "cons", "lines", "ns", "ges", "da", "tests", "ays", "dist", " props", "eps", "cs", "df", "uds", "gd", "qs", "ys", "data", "ded", "ks", "words", "di", "db", "parts", "dd", "ants", "vs", "amps", "ans", "DS", "dos", "plugins", "styles", "js", "ps", "rs", "ups", "models", "bs", " sd"], "format": ["letter", "model", "unit", "nat", "plugin", "prefix", "form", "function", "pattern", "at", "feat", "filter", "version", "parser", "atter", "filename", "sche", "api", "table", "Format", "struct", "style", "string", "class", "scale", "act", "spec", "t", "fd", "path", "handler", "ant", "template", "source", "type", "record", "part", "frame", "fp", "name", "language", "host", "data", "file", "layout", "fn", "magic", "config", "tag", "f", "url"], "hasPixelData": ["hasPixelStyle", "haspixeldata", "showsByteDATA", "hasByteStyle", " hasPixelSize", "hasByteDATA", "showsPixelDATA", "hasPixelDATA", "hasPictureSize", "hasPixeldata", "hasByteData", "hasPixelSize", "showsPixelData", "haspixelData", "hasPicturedata", "showsByteData", "hasByteSize", "showsByteStyle", "haspixelSize", "showsPixeldata", "showsBytedata", "showsPixelStyle", "hasBytedata", "hasPictureData", " hasPixeldata"], "inflate": ["inadequode", "infloation", "inadequATE", "InFlace", "infloace", "Inflation", "inflation", "InFlate", "Inflated", "inflode", "infolode", "insflating", "invenate", "insvenate", "infolate", "Inflate", "infolATE", "infolating", "InFlated", "insvenATE", "invenating", "inFlace", "inflace", "insflode", "invenode", "inadequating", "insvenating", "inffate", "InFlation", "insflate", "inffation", "invenATE", "infloated", "inffated", "inflating", "inFlate", "Inflace", "insflATE", "infface", "infloate", "inFlated", "inadequate", "insvenode", "inflated", "inflATE", "inFlation"], "pxlen": ["pxden", "pxdata", "mxlen", "campos", "pxln", "mxln", "pxlon", "camln", "mxcount", "pxlin", "pngsize", "xplength", "fxln", "xpsize", "pgden", "ppl", "pplen", "fxden", "pxsize", "pxcount", "fxpos", "axlin", "pclon", "ppLen", "pnglength", "txlon", "pnglen", "pxl", "mxlength", "xplen", "xpcount", "axlen", "txlin", "txln", "pxpos", "ppden", "mxdata", "pglen", "pgLen", "mxpos", "pxlength", "fxl", "pclen", "pgl", "camlen", "pclin", "camdata", "axln", "txlen", "pcln", "fxLen", "pxLen", "mxsize", "fxdata", "pngcount", "fxlen", "axlon"], "out": ["re", "err", "log", "point", "step", "cli", "inter", "up", "group", "cache", "output", "OUT", "list", "conn", "post", "page", "pad", "store", "session", "state", "again", "outs", "work", "query", "line", "io", "v", "Out", "co", "dump", "sys", "server", "user", "gen", "lock", "error", "lib", "parent", "obj", "copy"]}}
{"id1": "8953394", "id2": "22401746", "code1": "    private void update(String statement, SyrupConnection con, boolean do_log) throws Exception {\n        Statement s = null;\n        try {\n            s = con.createStatement();\n            s.executeUpdate(statement);\n            con.commit();\n        } catch (Throwable e) {\n            if (do_log) {\n                logger.log(Level.INFO, \"Update failed. Transaction is rolled back\", e);\n            }\n            con.rollback();\n        }\n    }\n", "code2": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "label": 0, "substitutes": {"update": ["create", "end", "write", "with", "edit", "up", "UPDATE", "run", "replace", "set", "sql", "updated", "apply", "Update", "query", "join", "select", "place", "build", "alter", "ite", "save", "database", "connection", "execute", "exec"], "statement": ["script", "storage", "ment", "sequence", "Statement", "usage", "text", "message", "use", "string", "status", "sql", "condition", "session", "state", "sn", "query", "join", "stat", "result", "commit", "mt", "response", "command", "expr", "expression", "name", "report", "data", "str", "value", "database", "timeout", "connection", "execute", "source"], "con": ["com", "log", "conv", "login", "ion", "can", "crit", "syn", "cons", "trans", "pc", "cur", "fc", "ca", "exec", "cache", "conn", "CON", "ran", "c", "cf", "cr", "rc", "m", "ci", "en", "container", "an", "commit", "xc", "client", "cc", "Con", "cas", "cm", "co", "tc", "ec", "cn", "connect", "lock", "mc", "Conn", "bc", "ctx", "connection", "uc", "db", "conf"], "do_log": ["Do_log", "do\u00b7put", "do_loc", "Do_print", "do_Log", "do_put", "do_print", "do\u00b7loc", " do_put", "do_bug", "do___put", "Do_bug", "do___log", " do_loc", "Do_Log", "do___loc", "do\u00b7log"], "s": ["j", "in", "o", "ans", "ops", "ls", "services", "ns", "l", "b", "js", "sql", "c", "r", "session", "g", "ps", "t", "d", "p", "ds", "conf", "si", "S", "os", "sb", "fs", "qs", "ins", "is", "ses", "hs", "es", "ssl", "a", "south", "h", "e", "ss", "u", "sl", "i", "n", "ks", "ts", "m", "f"]}}
{"id1": "9449064", "id2": "22977189", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"readExp": [" readEx", "loadExp", "writeExpl", "loadEx", "readEXP", "ReadEXP", "ReadExpl", "ReadExp", " readexp", " readEXP", " readExpl", "Readexp", "readExpl", "loadExpl", "readEx", "writeEx", "loadExt", " readExt", "readExt", "loadexp", "writeExt", "writeexp", "readexp", "loadEXP"], "writeExp": ["WriteExt", "writeExpl", " writeexp", "writingEx", "writingExp", " writeCom", "writingCom", "Writeexp", "writingexp", "WriteExpl", "readExpl", "readEx", "writeEx", " writeExpl", "readExt", "WriteExp", "writeExt", "writeexp", "WriteEx", "readexp", "writeCom", "WriteCom", " writeEx", " writeExt"], "expFile": ["EXPFile", "EXPfile", "ExpFile", " experimentPlace", "expSourceFile", "expLine", " expPlace", "ExpSourceFile", " expSourceFile", "EXPLine", "expressSourceFile", "expDir", "xpFile", " experimentLine", "xpfile", "expressLine", "expressDir", "xpDir", "expressfile", " experimentFiles", "EXPPlace", "xpFiles", "ExpLine", "ExpDir", "expPlace", "EXPSourceFile", "xpString", " experimentFile", "expressFile", "xpLine", "ExpPlace", "expressPlace", "expfile", "EXPString", "expString", "EXPDir", "Expfile", "xpPlace", " expFiles", " expLine", "ExpString", " expDir", "expFiles"], "exp": ["ef", "lc", "model", "expl", "vec", "serv", "inf", " experiment", "EXP", "prov", "form", "project", "rep", " expansion", "fe", "feat", "zip", "nz", "asm", "jp", "pr", "scope", "example", "act", "spec", "push", "query", "pl", " expanded", "p", "sc", "express", "div", "plus", "x", "dj", "Exp", "expr", "xp", "iz", " exam", "app", "test", "ext", "host", "inst", " expand", "str", "i", "ng", "acc", "imp", "f", "obj"], "fi": ["ini", "yi", "ifi", "sci", "fa", "isi", "Fi", "py", "lli", "ii", "fe", "osi", "fc", "ifa", "info", "pi", "cf", "abi", "fb", "li", "ci", "ani", "flo", "ffe", "si", "xi", "ni", "bi", "eni", "ji", "fp", "FI", "qi", "wi", "fy", "sf", "i", "afi", "zi"], "oi": ["ini", "ski", "ilo", "ahi", "cci", "isi", "oci", "lli", "ii", "osi", "ofi", "shi", "ui", "oni", "uci", "abi", "li", "avi", "ci", "flo", "ani", "si", "io", "ni", "bi", "eni", "oid", "eye", "ji", "ai", "odi", "obb", "omi", "agi", "eu", "ogi", "edi", "oxy", "ori", "ois", "qi", "ti", "oa", "i", "di", "asi", "ki", "obi"], "jf": ["Jfx", "djfm", "jjfx", " jfx", "Jfe", "jfp", " jfs", "ujfs", "jb", "jpb", "ujf", "je", "appfx", "JF", " jF", "ff", " jfp", " jtf", "fe", "djf", " jfe", "jcf", "jfs", "jfr", " jp", "jarf", "jjf", "xf", "appf", "jtf", "jp", "ujfp", "zcf", "jfm", "Jb", "pp", "jpcf", "jF", "ffp", "jjcf", "xcf", "xfp", "uje", "jfe", "appcf", "ztf", " jcf", "pf", " jfm", "zfp", "jjfm", "pfr", "jfx", "appfe", "jarp", "xtf", "pb", "Jf", " jb", " je", "jpfx", "Jcf", "jpf", "jarb", "zf", " jfr", "ffs", "djfx", "djcf", "jarfr", "jpF"], "sp": ["html", "service", "bsp", "serv", "spe", "sci", "sk", "ap", "py", "fe", "space", "ch", "jp", "mp", "js", "page", "bp", "sup", "pr", "so", "pp", "cf", "scope", "spec", "wp", "amp", "ps", "SP", "pl", "sc", "p", "esp", "vp", "osp", "si", "op", "se", "ep", "sb", "sh", "sv", "sm", "fp", "app", "Sp", "tp", "inst", "sf", "s", "ss", "sl", "str", "sw", "ctx", "cp", "imp", "gp"], "e": ["ef", "event", "w", "et", "fe", "events", "pe", "t", "ie", "en", "se", "ent", "ep", "v", "x", "ce", "es", "ception", "ext", "ae", "ev", "Event", "el", "ctx", "ec", "exc", "ee"], "fo": ["bo", "yo", "o", "foo", "osa", "fa", "FO", "po", "py", "fe", "mo", " lo", "info", "tto", "olo", "so", "oooo", "obo", "ato", "zo", "ph", "flo", "ao", "io", "ho", "os", "ooo", "la", "ko", "co", "jo", "vo", "lo", "wo", "ico", "f", "obj"], "oo": ["bo", "ou", "ilo", "o", "foo", "osa", "oh", "FO", "po", "loo", "elo", "ox", "mo", "argo", "oda", "que", "olo", "ollo", "so", "oooo", "aco", "obo", "oe", "ao", "flo", "io", "oid", "os", "oto", "ooo", "OO", "va", "obe", "la", "ko", "co", "goo", "bean", "oa", "lo", "wo", "qa", "ico", "oos", "cro"], "ex": ["com", "err", "re", "expl", "EX", "event", "aux", "cl", "except", "ignore", "ix", "Ex", "Exc", "sex", "pex", " Ex", " exc", "js", "null", "class", "act", "def", "exit", "tex", "ct", "ic", "fail", "Exception", "se", "su", "used", "x", "es", "ception", "ext", "con", "ass", "rex", "ax", "error", "nex", "tx", "res", "six", "lex", "exc", "obj", "inc"]}}
{"id1": "9081749", "id2": "12490144", "code1": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "code2": "    private void createJCoPluginProject(IProgressMonitor monitor, String sourceFileName, String pluginName) throws CoreException, IOException {\n        monitor.subTask(MessageFormat.format(Messages.ProjectGenerator_CreatePluginTaskDescription, pluginName));\n        final Map<String, byte[]> files = readArchiveFile(sourceFileName);\n        monitor.worked(10);\n        IProject project = workspaceRoot.getProject(pluginName);\n        if (project.exists()) {\n            project.delete(true, true, new SubProgressMonitor(monitor, 5));\n        } else {\n            monitor.worked(5);\n        }\n        project.create(new SubProgressMonitor(monitor, 5));\n        project.open(new SubProgressMonitor(monitor, 5));\n        IProjectDescription description = project.getDescription();\n        description.setNatureIds(new String[] { JavaCore.NATURE_ID, PLUGIN_NATURE_ID });\n        project.setDescription(description, new SubProgressMonitor(monitor, 5));\n        IJavaProject javaProject = JavaCore.create(project);\n        IFolder binDir = project.getFolder(\"bin\");\n        IPath binPath = binDir.getFullPath();\n        javaProject.setOutputLocation(binPath, new SubProgressMonitor(monitor, 5));\n        project.getFolder(\"jni\").create(true, true, new SubProgressMonitor(monitor, 5));\n        project.getFile(\"sapjco3.jar\").create(new ByteArrayInputStream(files.get(\"sapjco3.jar\")), true, new SubProgressMonitor(monitor, 10));\n        IFolder metaInfFolder = project.getFolder(\"META-INF\");\n        metaInfFolder.create(true, true, new SubProgressMonitor(monitor, 5));\n        StringBuilder manifest = new StringBuilder();\n        manifest.append(\"Manifest-Version: 1.0\\n\");\n        manifest.append(\"Bundle-ManifestVersion: 2\\n\");\n        manifest.append(\"Bundle-Name: SAP Java Connector v3\\n\");\n        manifest.append(MessageFormat.format(\"Bundle-SymbolicName: {0}\\n\", pluginName));\n        manifest.append(\"Bundle-Version: 7.11.0\\n\");\n        manifest.append(\"Bundle-ClassPath: bin/,\\n\");\n        manifest.append(\" sapjco3.jar,\\n\");\n        manifest.append(\" jni/\\n\");\n        manifest.append(\"Bundle-Vendor: SAP AG, Walldorf (packaged using RCER)\\n\");\n        manifest.append(\"Bundle-RequiredExecutionEnvironment: J2SE-1.5\\n\");\n        manifest.append(\"Export-Package: com.sap.conn.jco,\\n\");\n        manifest.append(\" com.sap.conn.jco.ext,\\n\");\n        manifest.append(\" com.sap.conn.jco.monitor,\\n\");\n        manifest.append(\" com.sap.conn.jco.rt,\\n\");\n        manifest.append(\" com.sap.conn.jco.server\\n\");\n        manifest.append(\"Bundle-ActivationPolicy: lazy\\n\");\n        writeTextFile(monitor, manifest, metaInfFolder.getFile(\"MANIFEST.MF\"));\n        final IPath jcoPath = new Path(MessageFormat.format(\"/{0}/sapjco3.jar\", pluginName));\n        IClasspathEntry jcoEntry = JavaCore.newLibraryEntry(jcoPath, Path.EMPTY, Path.EMPTY, true);\n        final IPath jniPath = new Path(MessageFormat.format(\"/{0}/jni\", pluginName));\n        IClasspathEntry jniEntry = JavaCore.newLibraryEntry(jniPath, Path.EMPTY, Path.EMPTY, true);\n        javaProject.setRawClasspath(new IClasspathEntry[] { jcoEntry, jniEntry }, new SubProgressMonitor(monitor, 5));\n        StringBuilder buildProperties = new StringBuilder();\n        buildProperties.append(\"bin.includes = META-INF/,\\\\\\n\");\n        buildProperties.append(\"               sapjco3.jar,\\\\\\n\");\n        buildProperties.append(\"               jni/,\\\\\\n\");\n        buildProperties.append(\"               .\\n\");\n        writeTextFile(monitor, buildProperties, project.getFile(\"build.properties\"));\n        exportableBundles.add(modelManager.findModel(project));\n    }\n", "label": 0, "substitutes": {"encrypt": ["decryption", "escrypt", "esccrypt", "encryption", "Enccrypt", "Encrypt", "decrypt", "Encryption", "encipher", "escipher", "escryption", "deccrypt", "decipher", "Encipher", "enccrypt"], "password": ["encrypted", "Password", "image", "email", "mask", "account", "prefix", "this", "root", " passwords", "pattern", "picture", "text", "message", "parser", "cache", "key", "wallet", "wd", "pad", "string", "array", "null", "params", "buffer", "pass", "crypt", "token", "padding", "strip", "phrase", "css", "secret", "command", "auth", "name", "PASS", "word", "data", "user", "seed", "parent", "username", "weight", "sword", "description", "database", "value", "words", "project", "python", "address"], "encryptType": ["encriptTypes", "encrupttype", "encryptionType", "encryptTyp", "eciphertype", "encPTtype", "encipherType", "acryptionTypes", "acryptTyp", "acryptTypes", "encryptiontype", "encipherClass", "ecryptClass", "encPTType", "encertKey", "encripttype", "encruptTypes", "ecrypttype", "encriptType", "encryptClass", "encPTKey", "encriptTyp", "enciphertype", "encPTClass", "encryptTypes", "acryptiontype", "acryptType", "ecipherKey", "encertType", "acrypttype", "encerttype", "encruptTyp", "encruptType", "ecipherClass", "encryptionTyp", "acryptionTyp", "encertClass", "ecryptType", "encryptionTypes", "ecipherType", "encryptKey", "acryptionType", "encipherKey", "encrypttype", "ecryptKey"], "md": ["dd", "nm", "cmd", "dig", "metadata", "amd", "um", " MD", "hd", "mm", "mad", "mo", "cd", "mp", "vd", "der", "grad", "mand", "d", "bd", "pm", "df", "mt", "mac", "gd", "od", "MD", "Cmd", "hed", "mod", "dh", "pd", "mag", "rm", "dm", "mc", "f", "mb", "hm", "di", "m", "rpm"], "hash": ["image", "her", "html", "sha", "log", "base", "index", "body", "ver", "hard", "hex", "check", "filter", "version", "cache", "message", "count", "bit", "how", "key", "full", "style", "fill", "array", "code", "flash", "print", "kh", "throw", "query", "part", "build", "len", "sh", "diff", "number", "mac", "handle", "ashes", "bug", "ash", "block", "Hash", "digit", "sum", "hed", "h", "search", "ha", "data", "id", "char", "chip", "str", "value", "error", "dot", "memory", "url", "header"], "hexString": [" hexstring", "hexLine", "pixelString", "pixelstring", "hashFile", "hexSet", "blackstring", "alphLine", "alphFile", "blackString", "squareField", "hashArray", "hashString", "blackFile", "squareSet", " hexSet", " hexLine", "hexFile", "pixelBuffer", "zipArray", "zipSet", "alphstring", "alphString", " hexFile", "zipString", "hexBuffer", "rawBuffer", " hexField", "rawstring", " hexArray", "hexstring", "hexArray", "squareArray", "rawString", "zipField", "hexField", " hexBuffer", "hashstring", "rawArray", "blackLine", "rawFile", "squareString", "pixelFile"], "i": ["ini", "index", "j", "o", "oi", "temp", "end", "phi", "ii", "ix", "count", "slice", "l", "b", "info", "ui", "ri", "pi", "c", "r", "gi", "abi", "li", "ci", "p", "ie", "multi", "si", "io", "xi", "bi", "uri", "v", "x", "ai", "it", "ji", "ip", "length", "start", "off", "h", "ti", "id", "data", "qi", "e", "u", "f", "n", "di", "I", "s"]}}
{"id1": "14688886", "id2": "20073619", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "label": 1, "substitutes": {"populateResources": ["populateResource", "poputeResources", "populateRelations", "popureFiles", "compureResources", "poputeRelations", "compulateRelations", "compureResource", "popractResources", "compureFiles", "popureResources", "popractFiles", "poputeFiles", "compulateResource", "compulateFiles", "popractResource", "compulateResources", "compureRelations", "popureResource", "poputeResource", "popractRelations", "populateFiles", "popureRelations"], "templates": ["temps", "prometers", "tempplate", "templateples", "tomplate", "templatepl", "temures", "templateps", "filens", "filpl", " temens", "Temens", " temures", " templ", "Temeters", "prompl", "typlate", "Template", "temeters", "filures", "Temps", "typl", "stemples", "promplate", "temens", "tomplates", "Templ", "Temples", "Templates", "templateplates", "tempps", "promplates", "temppl", "typlates", "stempl", "templ", "tometers", "tompl", "stemps", "Temures", "tempplates", "filplates", "temples", "stemplates", "template", "typs"], "url": ["image", "link", "html", "URL", "base", "resource", "service", "email", "feed", "config", "download", "Url", "pattern", "entry", "channel", "http", "filename", "l", "href", "object", "page", "string", " URL", "r", "route", "buffer", "path", "pl", "job", "fl", "uri", "il", "xml", "name", "ssl", "location", "server", "data", "file", "ob", "host", "e", "sl", "el", "connection", "template", "source", "f", "address"], "fileName": ["fileSync", "FileString", "fDir", "fileType", "filePath", "foldername", "filename", " filePart", "objectName", "stringDirectory", "FileDir", "fKey", "Filename", " filename", "FILESystem", "fileString", "resourceName", "FileFull", "FileKey", "filenameString", "fileKey", "folderPath", "FileDirectory", "fileTime", "folderName", " fileDirectory", "modelname", "modelName", "sourceInfo", "FileName", " fileType", " fileLocation", "FILEname", " fileKey", " fileInfo", "objectSync", "fileInfo", "stringName", "objectTime", "resourcename", "FILELocation", "fName", "stringType", " filePath", "fileSystem", " fileTime", "FILETime", "FileInfo", "filePart", "FILESync", "sourceName", "filenameFull", "fileLength", " fileSystem", "folderPart", "fileDir", " fileString", "filenameLength", "filenameName", "fname", "sourceString", "FILEName", "filenameType", "resourcePath", " fileSync", "resourcePart", " fileLength", "fileLocation", "sourceLength", "fileDirectory", "filenamename", "objectname", "FileType", " fileFull", "sourcename", "modelLocation", "modelSystem", "fileFull", " fileDir"], "templateResource": ["tempFile", "templateresource", "copyUrl", "tempResource", "layoutContent", "plateContainer", "templateReader", " templateType", "eventResource", "layoutContainer", "privateUrl", "layoutResource", " templateRole", "eventUrl", "eventresource", "translationContainer", " templateFile", "tempRole", "plateRing", "copyresource", "privateReader", "translationRing", "translationContent", "privateresource", "privateResource", "xmlFile", "xmlResource", "eventReader", "templateContainer", "xmlType", "templateRing", "templateContent", "copyResource", "plateContent", "templateRole", "layoutRing", "templateFile", "translationResource", "copyReader", "xmlRole", "templateUrl", "tempType", "plateResource", "templateType"], "is": ["ib", "its", "in", "serv", "isi", "abs", "src", "nis", "ir", "lis", "cms", "has", "api", "IS", "ri", "r", "irc", "was", "ris", "io", "os", "uri", "isl", "it", "isa", "out", "ip", "iss", "as", "iso", "app", "bis", "ori", "isc", "ios", "Is", "im", "ais", "rss", "ar", "iris", "s"], "strBuff": ["strBuffer", "brFlow", " strGrab", "StrBuffer", " strText", "stringBuffer", "brBuffer", "arrTab", "arrBuffer", "StrTab", "stringGrab", "StrBuff", "strGrab", "StrText", "Strbuff", "StrPref", "strFlow", "brGrab", "rBuff", "strText", "strbuff", "stringFlow", " strbuff", "rText", "brBuff", "strPref", "strTab", " strBuffer", "stringBuff", " strTab", "arrBuff", "rBuffer", "arrPref", " strPref", "rbuff", " strFlow"], "br": ["err", "dr", "fr", " reader", "stream", "bl", "arr", "text", "yr", "b", "ctr", "cb", "buf", "sp", "r", "ber", "gr", "tr", "bro", "er", "div", "io", "result", "Br", "BR", "nr", "mr", "orb", "hr", "bar", "ori", "sr", "data", "brush", "browser", "Reader", "reader", "rb", "res", "bc", "cr"], "str": ["enc", "err", "lc", "dr", "fr", "strike", "kr", "coll", "arr", "cl", "cur", "oct", "text", "sec", "key", "STR", "pr", "style", "string", "sp", "r", "spec", "t", "tr", "wr", "st", "er", "stri", "p", "line", "type", "div", "sc", "name", "hr", "sr", "data", "star", "char", "Str", "sl", "iter", "or", "cr", "f"], "images": ["image", "resources", "boxes", "versions", "objects", "types", "holes", "shows", "flows", "dates", "plugins", "picture", "services", "thumbnails", "frames", "rooms", "media", "events", "styles", "views", "files", "tests", "apps", "xs", "groups", "games", "videos", "quarters", "bands", "photos", "ions", "icons", "jobs", "gif", "tags", "people", "opens", "ins", "users", "models", "ups", "agents", "Images", "features", "gallery", "lights", "letters", "pages", "ips", "stars", "sites", "png", "classes", "assets", "inches", "ages", "words", "ims", "scripts", "pieces"], "i": ["z", "format", "fi", "ui", "ci", "p", "multi", "it", "v", "ji", "xml", "u", "f", "s", "lc", "j", "html", "in", "this", "cli", "add", "slice", "mu", "b", "info", "pi", "gi", "d", "uni", "ni", "io", "ip", "app", "ti", "id", "iu", "ini", "_", "mi", "yi", "hi", "phi", "ii", "ind", "ie", "si", "xi", "eni", "diff", "x", "gu", "ij", "di", "image", "index", "chi", "Url", "http", "key", "li", "bi", "uri", "ai", "y", "qi", "e", "n", "config", "I"], "img": ["image", "config", "fig", "bl", "input", "arr", "ff", "jpg", "aff", "exp", "src", "fw", "ch", "info", "cb", "att", "tif", "norm", "fb", "li", "ie", "p", "ani", "v", "aut", "gif", "small", "gd", "icon", "tmp", "app", "hr", "map", "ext", "gallery", "iframe", "data", "file", "inst", "sl", "png", "ng", "im", "bg", "lib", "abc", "m", "imp", "f"], "imgProperty": ["bgImage", "cacheProp", "imgImage", "bgProp", " imgPro", "cacheProperty", " imgProp", "bgProperty", "imgPro", "imgProp", "bgPro", "cacheImage", "cachePro", " imgImage"]}}
{"id1": "21348951", "id2": "22977189", "code1": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"processAddByURLSubmit": ["processAddByURLSubmission", "processAddByURLSummitted", "processAddByURlsubmission", "processAddByURLSummission", "processAddByURLSubmitter", "processAddByURLSUBmit", "processAddByURLSummitter", "processAddByURLSsubmitted", "processAddByURlsubmit", "processAddByURlsUBmission", "processAddByURlsUBmit", "processAddByURLSsubmitter", "processAddByURlsUBmitter", "processAddByURLSUBmitted", "processAddByURLSummit", "processAddByURLSUBmitter", "processAddByURLSUBmission", "processAddByURLSsubmission", "processAddByURLSsubmit", "processAddByURlsUBmitted", "processAddByURLSubmitted", "processAddByURlsubmitted", "processAddByURlsubmitter"], "url": ["image", "link", "log", "URL", "base", "email", "resource", "feed", "www", "stream", "Url", "ug", "entry", "ls", "ref", "http", "src", "l", "page", "string", "buffer", "route", "path", "io", "org", "uri", "secure", "xml", "ur", "ssl", "location", "server", "data", "file", "ll", "user", "e", "host", "ob", "str", "sl", "connection", "loc", "source", "address"], "invalidUrlMsg": ["inbadFileMessage", "invalidFileMsg", "invalidTimemsg", "invalidTimeMessage", "invalidStringUrl", "invalidURLUrl", "inInvalidUrlStr", "invalidFileUrl", "invalidFileMessage", "invalidUrlStr", "inInvalidURLMsg", "invalidUrlmsg", "invalidTimeStr", "inInvalidURLUrl", "invalidStringmsg", "inInvalidUrlMsg", "inInvalidURLStr", "invalidUrog", "inbadUrlog", "invalidUrMessage", "inInvalidUrlMessage", "invalidUrmsg", "invalidURLMessage", "invalidStringMessage", "invalidURLMsg", "invalidUrlMessage", "invalidURLmsg", "invalidStringMsg", "inbadFilemsg", "inInvalidUrlmsg", "invalidFilemsg", "invalidUrMsg", "inInvalidURLMessage", "invalidFileStr", "inbadFileog", "invalidFileog", "invalidURLStr", "invalidUrlUrl", "inInvalidURLmsg", "inbadUrlMessage", "invalidURLog", "inbadUrlmsg", "inbadFileMsg", "invalidUrlog", "inbadUrlMsg", "inInvalidUrlUrl", "invalidTimeMsg"], "xmlSourceWriter": [" xmlourceReader", " xmlSourceString", "jsonSourcewriter", "jsonStringWrite", "xmlInputWriter", "xmlSourceString", "xmlStrwriter", "xmlSourceReader", "xmlSourceWritten", " xmlourceWriter", " xmlSourceReader", "jsonStringReader", "jsonStringWriter", "xmlInputWritten", "jsonReaderWriter", "xmlourceWriter", "xmlStringwriter", "xmlServicewriter", "xmlStrWrite", "jsonReaderReader", "xmlResourceWriter", "xmlResourceReader", "jsonSourceWriter", "xmlStrWriter", " xmlourceWritten", "xmlServiceReader", "xmlSourceWrite", "jsonSourceReader", " xmlourceString", "jsonReaderWritten", "xmlReaderWritten", "xmlSourcewriter", " xmlSourceWritten", "xmlResourceString", "xmlServiceWrite", "xmlourceReader", "xmlStrReader", "xmlReaderWriter", "jsonSourceWrite", "xmlInputReader", "xmlourceString", "xmlStringReader", "xmlServiceWritten", "xmlResourceWritten", "jsonSourceWritten", "jsonReaderWrite", "xmlReaderReader", "xmlStringWriter", "xmlourceWritten", "xmlServiceWriter", "xmlInputString", "xmlInputWrite", "xmlStringWrite", "jsonStringwriter", "xmlReaderWrite"]}}
{"id1": "21824901", "id2": "9687813", "code1": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "code2": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"copyExternalResource": ["copyInternalURL", " copyExternalResources", " copyExternalURL", "copyExternalResources", "copyInternResources", " copyInternalResources", "copyApplicationSourceFile", " copyInternalResource", "copyExternalURL", "copyApplicationResource", " copyExternalSourceFile", "copyInternSourceFile", "copyInternURL", "copyInternalResources", "copyExternalSourceFile", "copyInternalSourceFile", "copyApplicationURL", "copyApplicationResources", " copyInternalURL", "copyInternResource", "copyInternalResource", " copyInternalSourceFile"], "sourceFile": ["sourceDirectory", "sourceStream", " sourcePage", "destStream", " sourceStream", "sourcePage", "inputfile", "srcDirectory", "inputStream", "sourcePath", " sourcefile", "destfile", "SourceDirectory", "destPage", "SourceFile", "srcPath", "sourcefile", "inputFile", "inputPage", "Sourcefile", "srcfile", "srcFile", "SourcePath", " sourcePath", " sourceDirectory"], "destFile": ["parentDir", "parentfile", "DestFile", "srcDir", "parentFiles", "sourceDir", "srcFiles", "srcDirectory", "destPoint", "targetDir", "destDirectory", " destPoint", "destfile", "destDir", "parentFile", " destFiles", "distfile", "distDirectory", "DestPoint", " destfile", "distFile", "DestFiles", "sourcefile", "targetfile", " destDir", "distDir", "targetFile", "destFiles", "DestDir", "srcfile", "sourcePoint", " destDirectory", "srcFile", "Destfile", "targetDirectory", "sourceFiles", "DestDirectory"], "source": ["image", "link", "unit", "slave", "service", "resource", "SOURCE", "this", "stream", "Source", "current", "inner", "input", "target", "channel", "src", "cache", "slice", "use", "output", "api", "table", "sync", "object", "scope", "url", "null", "status", "class", "from", "session", "core", "plus", "ource", "result", "si", "pointer", "uri", "sin", "dest", "ce", "client", "context", "size", "start", "proxy", "server", "id", "reference", "file", "reader", "get", "connection", "config", "parent"], "destination": ["destinator", " destruction", "origruction", "destribution", "Destination", "destruction", " destinator", "declruction", "originator", "Destinated", "declinated", "Destruction", "declination", "dependruction", "constribution", "Destinator", "construction", "originated", "dependination", "destinated", "constination", "declinator", "constinator", "dependinator", " destinated", "Destribution", "dependinated", " destribution", "origination"]}}
{"id1": "18731843", "id2": "5760649", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "label": 1, "substitutes": {"doBody": ["DoFile", "DoResponse", "handleBody", "doResponse", "DoBody", " doFile", "DoBytes", " doResponse", "handleResponse", "handleFile", "doFile", "handleBytes", "doBytes", " doBytes"], "req": ["err", "resource", "q", "rx", "fr", "crit", "this", "config", "serv", "download", "cgi", "obj", "ref", "src", "http", "qq", "rec", "respond", "conn", "jp", "info", "def", "r", "spec", "query", "sem", "Request", "rr", "proc", "rh", "comp", "report", "request", "data", "qt", "reader", "res", "reg", "requ", "rss"], "resp": ["re", "err", "html", "serv", "val", "exc", "Response", "respons", "download", "pre", "rep", "ref", "cache", "rev", "rec", "api", "respond", "bb", "jp", "cb", "b", "prot", "pos", "sp", "r", "job", "p", "part", "cmp", "result", "ret", "rr", "inv", "proc", "comp", "response", "Resp", "report", "request", "data", "res", "reply", "obj"], "bis": ["pins", "rots", "atis", "mis", "bits", "iris", "alis", "bid", "lins", "nis", "bas", "lis", "bin", "b", "bb", "usb", "ubis", "obs", "abi", "fb", "bes", "boot", "ris", "obb", "bi", "obos", "sb", "os", "uds", "phis", "sis", "iss", "is", "ses", "bian", "ori", "ois", "bs", "isin", "oris", "bps", "binary", "ios", "ais", "tis", "bh", "los", "sin", "obi"], "bos": ["bo", "lol", "zos", "osa", "ops", "bits", "osi", "lins", "mos", "bas", "bin", "oros", "bris", "bones", "obo", "ubis", "obs", "zo", "abi", "bes", "boot", "ros", "obb", "obos", "os", "oks", "bi", "uds", "phis", "antis", "bott", "oS", "las", "ois", "oops", "bs", "opus", "oses", "bps", "ios", "tis", "oos", "fits", "bh", "los", "aos", "obi"]}}
{"id1": "19494842", "id2": "10281203", "code1": "    private void callService() {\n        try {\n            URL url = new URL(baseUrl + servicePath + attributes);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            StringBuffer buf = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                buf.append(inputLine);\n            }\n            in.close();\n            answer = buf.toString();\n        } catch (MalformedURLException e) {\n            answer = \"Malformed Url:\" + e.getMessage();\n            return;\n        } catch (IOException e) {\n            answer = \"I/O exception: \" + e.getMessage();\n            return;\n        }\n    }\n", "code2": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 0, "substitutes": {"callService": [" callServices", "testService", "Callservice", "callProxy", "callServices", "CallService", "CallServices", " callProxy", "CallProxy", "testServices", "callservice", "testservice", "testProxy", " callservice"], "url": ["log", "URL", "base", "service", "resource", "feed", "this", "stream", "Url", "json", "open", "http", "queue", "l", "b", "conn", "string", "r", "path", "uri", "client", "blog", "ur", "ssl", "server", "user", "file", "ll", "host", "e", "sl", "i", "connection", "source", "web", "f", "socket", "address"], "in": ["re", "err", "kin", "ini", "image", "login", "impl", "stream", "gin", "inner", "inn", "input", "In", "bin", "b", "c", "r", "IN", "buffer", "again", "fb", "doc", "source", "line", "out", "client", "ins", "is", "into", "lin", "init", "ssl", "h", "data", "file", "id", "reader", "i", "win", "din", "f", "socket", "inc", "s"], "inputLine": ["InputLine", "streamFrame", "outputRow", "inputValue", "readline", "Inputline", "readLine", "requestString", "outputline", " inputL", "outputValue", "inputline", "readRow", " inputValue", "InputL", "InputFrame", " inputFrame", "streamLine", "inputFrame", "requestL", "inputRow", " inputRow", "outputLine", "inputString", " inputline", "inputL", "requestLine", "readValue", "InputString", "requestline", "streamString", " inputString", "streamline"], "buf": ["log", "wb", "base", "conv", "pool", " buffer", "nb", "coll", "fun", "abs", "exc", "aux", "ff", "cache", "queue", "bag", "uf", "b", "cb", "bb", "bh", "pad", "string", "builder", "array", "gb", "buff", "cf", "buffer", "Buffer", "fb", "result", "sb", "fp", "cas", "context", "pb", "bu", "data", "cv", "binary", "af", "ob", "header", "rb", "pkg", "bc", "bf", "ctx", "br", "db", "f", "append", "ab"], "answer": ["reply", "question", "site", "prefix", "side", "fix", "order", "entry", "blank", "cache", "message", "swers", "update", "status", "option", "array", "say", "session", "sn", "settings", "attribute", "result", "ask", "uri", "su", "issue", "response", "name", "word", "search", "server", "answered", "knowledge", "Answer", "username", "description", "empty", "stuff", "complete", "value", " answers", "install", "address"]}}
{"id1": "11475527", "id2": "11546108", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"addDataFromURL": ["addDataWithurl", "addTextfromUrl", "addDataForurl", "addDataWithURL", "addDataWithFile", "addTextFromUrl", "addTextFromURL", "addDatafromFile", "addTextfromURL", "addDataForURL", "addDataForFile", "addDataForUrl", "addDatafromUrl", "addDataFromFile", "addDataFromurl", "addTextFromFile", "addDatafromurl", "addDataWithUrl", "addTextFromurl", "addTextfromurl", "addDatafromURL", "addDataFromUrl", "addTextfromFile"], "theurl": [" thepublic", "testUrl", "thereuri", "myUrl", "youURL", "youlog", "theUrl", "testlog", "pythonuri", " TheURL", " Thepublic", "theURL", "theuri", "myURL", "youurl", "youUrl", "myurl", " theuri", "mypublic", "pythonurl", "thelog", " thelog", "testurl", " TheUrl", "thepublic", "pythonURL", " Theurl", "testURL", " theURL", " theUrl", "thereurl", "thereURL"], "line": ["link", "letter", "log", "model", "base", "unit", "feed", "nl", "write", "cl", "lines", "entry", "LINE", "text", "Line", "sync", "key", "l", "object", "ine", "string", "code", "url", "style", "pe", "buffer", "pass", "li", "part", "len", "out", "number", "row", "le", "block", "character", "name", "file", "id", "cell", "char", "el", "str", "i", "comment", "reader", "no", "connection", "source", "f", "lin"], "in": ["ini", "err", "image", "login", "serv", "fa", "inner", "inn", "stream", "arin", "input", "fin", "In", "inc", "l", "bin", "b", "info", "conn", "read", "pin", "IN", "r", "again", "pass", "oin", "source", "nin", "record", "io", "it", "cin", "out", "client", "ins", "is", "socket", "init", "a", "inside", "file", "rin", "isin", "i", "reader", "win", "or", "m", "din", "url", "lin", "s"], "data": ["body", "o", "end", "this", "stream", "default", "inner", "dat", "input", "open", "lines", "entry", "up", "output", "l", "writer", "info", "conn", "like", "da", "r", "buffer", "next", "d", "handler", "DATA", "er", "plus", "result", "out", "start", "la", "file", "reader", "i", "one", "iter", "di", "connection", "ata", "source", "f", "url"], "e": ["err", "ef", "de", "o", "eme", "event", "je", "et", "fe", "ue", "ne", "E", "ke", "element", "pe", "ise", "ace", "oe", "ze", "be", "ie", "er", "ea", "en", "se", "ep", "ce", "ede", "me", "eu", "edge", "es", "ale", "ception", "ae", "ge", "ev", "error", "f", "one", "or", "ec", "ade", "ele", "exc", "ee"]}}
{"id1": "23398710", "id2": "14464131", "code1": "    public String getUser() {\n        try {\n            HttpGet get = new HttpGet(\"http://api.linkedin.com/v1/people/~\");\n            consumer.sign(get);\n            HttpClient client = new DefaultHttpClient();\n            HttpResponse response = client.execute(get);\n            if (response != null) {\n                int statusCode = response.getStatusLine().getStatusCode();\n                if (statusCode != 200) {\n                    this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n                }\n                StringBuffer sBuf = new StringBuffer();\n                String linea;\n                BufferedReader reader = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), \"UTF-8\"));\n                while ((linea = reader.readLine()) != null) {\n                    sBuf.append(linea);\n                }\n                reader.close();\n                response.getEntity().consumeContent();\n                get.abort();\n                String salida = sBuf.toString();\n                String user_firstname = salida.split(\"</first-name>\")[0].split(\"<first-name>\")[1];\n                String user_lastname = salida.split(\"</last-name>\")[0].split(\"<last-name>\")[1];\n                return user_firstname + \" \" + user_lastname;\n            }\n        } catch (UnsupportedEncodingException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (IOException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthMessageSignerException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthExpectationFailedException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthCommunicationException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        }\n        return null;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://hostname:80\");\n            URLConnection conn = url.openConnection();\n            for (int i = 0; ; i++) {\n                String headerName = conn.getHeaderFieldKey(i);\n                String headerValue = conn.getHeaderField(i);\n                if (headerName == null && headerValue == null) {\n                    break;\n                }\n                if (headerName == null) {\n                }\n            }\n        } catch (Exception e) {\n        }\n    }\n", "label": 0, "substitutes": {"getUser": ["getAccount", "getProfile", " getProfile", "createProfile", "createAccount", "newAccount", "newUser", "createUser", "getPerson", "createPerson", " getPerson", " getAccount", "newPerson", "newProfile"], "get": ["body", "method", "give", "model", "service", "resource", "create", "send", "got", "this", "view", "check", "cli", "json", "google", "open", "consumer", "find", "parse", "http", "cache", "remote", "api", "post", "object", "show", "update", "read", "set", "status", "c", "g", "token", "query", "single", "GET", "p", "it", "build", "v", "entity", "sign", "pull", "handle", "Get", "start", "init", "request", "ge", "call", "put", "i", "like", "url", "invoke"], "client": ["method", "service", "resource", "send", "this", "Client", "cli", "open", "channel", "consumer", "http", "output", "bird", "api", "conn", "session", "handler", "p", "control", "io", "result", "https", "console", "secure", "manager", "app", "ssl", "request", "con", "server", "call", "php", "connect", "i", "per", "contact", "connection", "web", "url", "copy"], "response": ["body", "image", "index", "service", "resource", "wave", "send", "feed", "site", "serv", "view", "Response", "json", "version", "offer", "http", "message", "output", "queue", "api", "writer", "respond", "full", "object", "page", "status", "application", "collection", "resp", "subject", "relation", "success", "handler", "successful", "result", "uri", "generation", "report", "tree", "received", "request", "server", "data", "document", "error", "results", "connection", "reply"], "statusCode": ["StatusCode", "statusC", "StatusC", "Statuscode", " statusC", " statusType", "successCode", "statusType", "responseCode", " statuscode", "responseType", "successC", "successcode", "successType", "StatusType", "statuscode"], "sBuf": ["sBBumb", "sBbuf", "sFuf", "sAuff", "sBBbuff", " sBbuff", "sBBuff", "sFuff", "sFumb", "sQbuf", "sFbuff", " sBuff", " sBlu", "sQumb", "sBlu", "sBeruf", "sBerbuf", " sBBuf", "sPlbuf", "sBerumb", "sBuff", "sFbuf", " sAbuf", " sFumb", " sAuff", "sAbuf", "sBerlu", " sAbuff", " sFuf", " sFbuf", "sBumb", "sPluf", "sQuf", " sBbuf", "sFlu", "sBbuff", "sBBbuf", " sAuf", "sPlumb", " sBBumb", "sAbuff", "sAuf", " sFlu", "sPllu", " sBumb", " sBBbuf", "sBBuf"], "linea": ["Lineas", "ideA", "linA", "lineva", " lineva", "lineas", "ideas", "Linea", " lineas", "Lineva", " lineha", "linas", "ideva", "linha", "lina", "lineha", "linva", "Lineha", "lineA", "LineA", "idea", " lineA"], "reader": ["right", "feed", "rx", "stream", "rer", "inner", "input", "player", "worker", "reading", "ler", "rar", "parser", "bird", "l", "writer", "upper", "read", "ri", "driver", "builder", "r", "buffer", "oder", "handler", "er", "line", "result", "io", "pointer", "rr", "row", "layer", "ner", "loader", "cher", "wrapper", "server", "data", "e", "ser", "Reader", "per", "i", "keeper", "iter", "f", "editor"], "salida": ["salanda", " salidas", "bilida", " salara", "Salido", "Salanda", "Salida", "Salidas", "salara", " salanda", "salidas", "satida", "milido", "salido", "milida", " salido", "milidas", "milanda", "slanda", "bilicka", "salicka", " salicka", "slida", "bilido", "satido", "slara", "bilara", "saticka", "Salara", "slidas", "satara"], "user_firstname": ["user_headname", "user_headphone", "user_realName", "user_realname", "user_firstame", "user_lastphone", "user_firstName", "user_thirdname", "user_fullame", "user_realnames", "user_fullnames", "user_fullName", "user_lastName", "user_firstnames", "user_lastame", "user_headame", "user_thirdphone", "user_fullname", "user_thirdame", "user_realame", "user_lastnames", "user_firstphone"], "user_lastname": ["user_firstame", "user_fullame", "user_longaddress", "user_lastaddress", "user_fullnames", "user_fulladdress", "user_fullName", "user_lastName", "user_pastaddress", "user_firstnames", "user_lastame", "user_lastword", "user_longName", "user_longname", "user_fullword", "user_fullname", "user_longame", "user_pastame", "user_firstword", "user_lastnames", "user_pastname", "user_pastName"]}}
{"id1": "20019847", "id2": "15500892", "code1": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copiedSource", " copyFiles", " copyingFile", " copySource", "copySource", "copyBuffer", " copiedFiles", " copyingSource", " copiedBuffer", " copyingBuffer", " copyBuffer", "copyFiles", " copyingFiles", " copiedFile"], "source": ["origin", "unit", "slave", "base", "resource", "SOURCE", "service", "before", "site", "stream", "Source", "inner", "current", "input", "grade", "project", "channel", "src", "slice", "use", "connection", "object", "url", "string", "null", "from", "route", "ource", "se", "start", "size", "name", "archive", "server", "id", "file", "seed", "reader", "scene", "config", "sin", "parent", "copy"], "target": ["base", "resource", "temp", "end", "config", "point", "content", "to", "download", "Target", "net", "master", "src", "output", "remote", "conn", "object", "next", "path", "goal", "result", "pointer", "dest", "director", "that", "archive", "server", "file", "reference", "port", "parent", "compatible", "timeout", "arget", "connection", "template", "project", "socket"], "in": ["err", "login", "impl", "inner", "inn", "input", "In", "up", "src", "sync", "rec", "bin", "b", "conn", "url", "c", "pin", "IN", "r", "again", "ie", "nin", "io", "sin", "min", "pull", "ins", "is", "as", "init", "inside", "id", "rin", "file", "i", "win", "reader", "n", "m", "din", "f", "socket", "inc"], "out": ["err", "image", "o", "temp", "outer", "other", "point", "outside", "check", "w", "plain", "write", "net", "channel", "sync", "output", "OUT", "bin", "conn", "b", "extra", "writer", "c", "again", "t", "outs", "io", "v", "x", "Out", "client", "off", "init", "file", "parent", "ex", "i", "n", "lib", "connection", "exec", "obj", "inc", "copy"]}}
{"id1": "5760649", "id2": "5148212", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 1, "substitutes": {"createFile": [" createResource", "CreateContent", "CreateFolder", " createFolder", "CreateFile", "createContent", " createContent", "createResource", "createFolder", "saveContent", "CreateResource", "saveFile", "saveFolder", "saveResource"], "src": ["resources", "resource", "stream", "Source", "content", "input", "load", "slice", "href", "ruby", "cb", "url", "string", "txt", "buf", "gb", "files", "r", "rc", "path", "rob", "sc", "upload", "uri", "sb", "proc", "SourceFile", "dest", "img", "fp", "sit", "secure", "name", "ssl", "sel", "data", "file", "fn", "username", "rss", "sl", "rb", "loc", "source", "obj", "s"], "filename": ["wb", "resource", "prefix", "dll", "metadata", "acl", "which", "feat", "output", "l", "utf", "string", "txt", "ame", "files", "ames", "route", "path", "fil", "Filename", "source", "uri", "SourceFile", "fp", "ename", "FILE", "length", "loader", "name", "title", "nil", "file", "fn", "sf", "username", "s", "rl", "location", "f", "url", "directory"], "fis": ["sfos", "Fais", " fIS", "cfais", "cfris", " fbs", "cfis", "cfIS", "fais", "sfiss", " fiss", "Fbs", "Fos", "Fis", " fais", "cfos", "fris", "fIS", "Fiss", "sfris", "fiss", "sfis", "fbs", "FIS", "Fris", "cfbs", " fris"], "fos": ["fios", "sfios", "sfos", " fops", "fOS", "affis", "Fas", "Fbos", "bos", "Fios", " fios", "foras", "FOS", "bbos", "fbos", "foros", " fas", "Fos", "Fis", "affios", "bis", "sfis", "fops", "Fops", "affbos", "foris", "affos", "sfops", " fOS", "fas", "bios", "forOS"]}}
{"id1": "21092340", "id2": "8266672", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public static void updatePicInfo(Connection conn, int nr, int lock, DBPicInfo picInfo) throws SQLException {\n        String sql = \"\";\n        PreparedStatement pstmt = null;\n        try {\n            if (!picInfo.getName().equals(\"\")) {\n                sql = \"update DBPic set name=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setString(1, picInfo.getName());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            if (picInfo.getRate() != 0) {\n                sql = \"update DBPic set rate=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, picInfo.getRate());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            sql = \"update DBThumb set thumb_lock=? where bnr=?\";\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setInt(1, lock);\n            pstmt.setInt(2, nr);\n            pstmt.executeUpdate();\n            if (picInfo.getCategories() != null) {\n                sql = \"delete from Zuordnen where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInCategories(conn, nr, picInfo.getCategories());\n            }\n            if (picInfo.getKeywords() != null) {\n                sql = \"delete from Haben where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInKeywords(conn, nr, picInfo.getKeywords());\n            }\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            pstmt.close();\n        }\n    }\n", "label": 0, "substitutes": {"addToArchive": ["addToSlives", "addtoAsively", "addToAdaptive", "addtoAsives", "addToAdaptively", "addtoArchIVE", "addToAsives", "addToArchIVE", "addToAdaptives", "addToArchives", "addToAsIVE", "addtoAsIVE", "addtoAsive", "addToSlive", "addToAsively", "addToArchively", "addToAsive", "addtoArchive", "addToAdaptIVE", "addToSlively", "addtoArchives", "addToSlIVE", "addtoArchively"], "pod": ["module", "child", "po", "pc", "Pod", "zip", "cache", "table", "post", "object", "pad", "product", "pi", "pe", "node", "pl", "pid", "p", "ad", "part", "pot", "plug", "proc", "ce", "od", "tmp", "loader", "bean", "peer", "component", "ods", "host", "cer", "pkg", "per", "project", "plugin"], "podArchiveOutputStream": ["podArchivingOutputSteam", "podArchiveByteDirectory", "podArchiveWriteSteam", "podArchivingWriteFile", "podArchiveWriteStream", "podArchiveInputStream", "podArchiveFilePath", "podArchiveInputPath", "podArchiveByteSteam", "podArchiveOutputPath", "podArchivesOutputSteam", "podArchiveByteStream", "podArchiveOperationSteam", "podArchiveOutputDirectory", "podArchivesFileResource", "podArchiveFileFile", "podArchIVEInputFile", "podArchivingOutputFile", "podArchiveOperationStream", "podArchivesOutputStream", "podArchiveOperationResource", "podArchiveOutputSteam", "podArchIVEInputStream", "podArchiveFileDirectory", "podArchiveIOResource", "podArchiveWriteFile", "podArchIVEOutputStream", "podArchiveInputFile", "podArchiveInputDirectory", "podArchiveOperationFile", "podArchivesFileStream", "podArchivingWriteSteam", "podArchiveIOFile", "podArchIVEOutputDirectory", "podArchiveIOSteam", "podArchiveFileStream", "podArchiveFileResource", "podArchiveInputSteam", "podArchivingOutputStream", "podArchiveOutputResource", "podArchivesOutputFile", "podArchivesOutputResource", "podArchiveByteFile", "podArchivingOutputPath", "podArchIVEOutputFile", "podArchIVEInputSteam", "podArchivesFileFile", "podArchiveOutputFile", "podArchiveIODirectory", "podArchiveFileSteam", "podArchivesFileSteam", "podArchivingWritePath", "podArchIVEOutputSteam", "podArchivingWriteStream", "podArchiveIOStream", "podArchiveWritePath", "podArchIVEInputDirectory"], "filename": ["folder", "module", "prefix", "kn", "dll", "sequence", "alias", "download", "which", "property", "platform", "l", "label", "string", "application", "files", "subject", "route", "path", "kl", "fil", "Filename", "uri", "SourceFile", "named", "fp", "ename", "FILE", "il", "loader", "name", "location", "title", "nil", "word", "archive", "file", "fn", "binary", "username", "sf", "database", "f", "url", "ppa", "directory"], "source": ["image", "unit", "slave", "service", "resource", "SOURCE", "stream", "Source", "input", "target", "src", "text", "zip", "slice", "output", "stack", "use", "string", "driver", "path", "ource", "result", "uri", "loader", "proxy", "archive", "file", "document", "seed", "sl", "reader", "connection", "config", "parent", "url", "copy"], "entry": ["image", "letter", "index", "resource", "child", "feed", "this", "stream", "event", "obj", "zip", "Entry", "add", "post", "object", "auto", "string", "element", "r", "path", "ie", "line", "record", "result", "pointer", "it", "se", "row", "article", "ge", "archive", "data", "file", "e", "iterator", "reader", "or", "connection", "parent", "address"]}}
{"id1": "21368981", "id2": "19652200", "code1": "    public APIResponse create(Application application) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/application/create\").openConnection();\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n        connection.setUseCaches(false);\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\")));\n        connection.getOutputStream().flush();\n        connection.getOutputStream().close();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\")).readLine()));\n            response.setDone(true);\n            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));\n            connection.getInputStream().close();\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Create Application Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    @Before\n    public void init() throws IOException {\n        file = new File(LOCATION);\n        url = file.toURI().toURL();\n        stream = url.openStream();\n        byteArray = IOUtils.toByteArray(new FileInputStream(file));\n        content = FileUtils.readFileToString(file);\n    }\n", "label": 0, "substitutes": {"create": ["setup", "send", "write", "open", "message", "add", "process", "run", "api", "post", "update", "POST", "type", "creat", "start", "Create", "request", "construct", "make", "call", "complete", "delete", "get", "execute", "save"], "application": ["unit", "base", "service", "resource", "video", "system", "current", "audio", "version", "http", "message", "output", "api", "object", "page", "class", "array", "apply", "Application", "external", "attribute", "x", "layer", "apache", "xml", "expression", "app", "name", "android", "bean", "request", "a", "language", "component", "document", "instance", "database", "config", "project", "address"], "response": ["onse", "image", "model", "index", "service", "resource", "answer", "feed", "site", "view", "Response", "function", "json", "entry", "version", "offer", "http", "message", "output", "api", "respond", "writer", "object", "page", "status", "example", "position", "more", "collection", "resp", "session", "next", "success", "handler", "part", "result", "client", "manager", "report", "ception", "tree", "request", "ae", "esi", "server", "data", "user", "document", "reference", "error", "description", "value", "host", "reply", "dict"], "connection": ["current", "channel", "Connection", "collection", "query", "number", "command", "context", "expression", "communication", "component", "union", "source", "machine", "directory", "log", "graph", "ion", "function", "cli", "cache", "password", "conn", "builder", "creation", "engine", "session", "relation", "handler", "io", "network", "character", "operation", "server", "reference", "document", "connect", "error", "database", "timeout", "loc", "office", "inner", "event", "entry", "version", "text", "remote", "object", "position", "creator", "node", "translation", "entity", "client", "connected", "location", "socket", "image", "link", "section", "system", "message", "writer", "environment", "condition", "part", "uri", "bug", "manager", "statement", "proxy", "wrapper", "bc", "config", "url"], "obj": ["aj", "body", "j", "nb", "o", "objects", "coll", "po", "arr", "json", "art", "active", "rt", "ns", "output", "list", "b", "info", "conn", "object", "js", "code", "so", "txt", "act", "r", "obo", "cdn", "resp", "bj", "line", "part", "Obj", "result", "out", "tmp", "map", "co", "ass", "data", "oa", "ob", "adj", "n", "res", "ctx", "ose"]}}
{"id1": "6866575", "id2": "11645260", "code1": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"caml_md5_string": [" icl_md5_double", " icl_md512_string", " icl_md512_ring", " icl_md5_string", " icl_md5_ring", " icl_md512_String", " icl_md512_double", " icl_md5_String"], "ctxt": ["CTXT", "ntext", "nttx", "ceext", "ctext", "cttx", "ctXT", "CTxt", "cext", "ceXT", "ntXT", "ntxt", "cetx", "CTtx", "CText"], "str": ["enc", "err", "in", "dr", "fr", "self", "inner", "hex", "val", "format", "arr", "cur", "exp", "text", "exec", "STR", "ctr", "style", "string", "code", "hash", "sp", "r", "spec", "pass", "tr", "st", "er", "div", "prev", "name", "hr", "data", "char", "Str", "sl", "seq", "br", "strings", "cr", "f", "obj"], "ofs": ["Ofs", "dirs", "dirsets", " ofn", "OFsets", "dirstates", "ofsets", " OFs", "ofd", "OFs", "Ofstates", " OFills", " ofd", "ofills", " OFd", "Ofills", "Ofd", "OFd", " ofills", "OFstates", "ofstates", "dird", "Ofsets", "Ofn", " OFn", "ofn"], "len": ["enc", "in", "offset", "vec", "lit", "val", "lf", "bl", "ls", "count", "rev", "l", "ld", "pos", "sp", "buf", "lib", "fd", "split", "li", "en", "line", "Len", "le", "block", "length", "size", "ln", "lt", "ll", "span", "fn", "el", "mem", "sl", "n", "seq", "fin", "lin"], "md5": ["mand5", "shadown", "MD4", "digdown", "MD5", "md15", "md20", "sha55", "sha5", "dig8", "md8", "sha15", "dd2", "md2", "md4", "mddown", " md2", "dig55", "sha8", "dig15", "dd5", "md55", "mand55", " md8", "dd75", "sha3", " md3", "mand15", " md4", "md75", "MD2", "dig20", "dig3", "dig5", "MD75", "mand20", " mddown", " md75", "md3", "sha20", "dd4"]}}
{"id1": "3053403", "id2": "6840241", "code1": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 1, "substitutes": {"fc": ["enc", "lc", "FC", "feed", "rx", "circ", "fa", "fat", "dc", "lf", "fm", "cl", "ff", "nc", "pc", "fen", "fe", "fi", "hub", "exp", "fw", "exec", "ref", "xf", "full", "cb", "conn", "roc", "raf", "fact", "cf", "c", "vc", "ct", "hl", "rc", "fd", "irc", "fb", "dl", "pl", "sc", "flo", "fl", "io", "cs", "df", "console", "wk", "fp", "fs", "cc", "xc", "il", "central", "fx", "col", "ac", "co", "con", "ll", "fn", "af", "sf", " FC", "mc", "win", "bc", "bf", "ec", "loc", "inc", "uc", "f"], "buff": ["eb", "tab", "both", "ref", "prof", "bb", "utf", "cb", "agg", "fab", "null", "cf", "font", "abb", "cod", "boot", "p", "sb", "img", "lab", "rb", "mb", "bg", "f", "bo", "FF", "xb", "fw", "b", "info", "bed", "gg", "txt", "front", "uff", "bet", "obb", "Buff", "build", "comp", "app", "fam", "bh", "loc", "np", "cast", "bm", "form", "bl", "ff", "fe", "feat", "aff", "text", "comb", "home", "gb", "fb", "ind", "ph", "pb", "fx", "butt", "callback", "cp", "grab", "bu", "fo", "box", "feed", "gap", "load", "back", "bas", "bag", "uf", "now", "buf", "pp", "buffer", "pl", "bd", "loop", "bug", "hand", "ob", "cell", "ctx", "bf", "bc", "config"], "encoding": ["decoding", "decryption", "Encoding", "Encaging", "encryption", "encasing", "encording", "ecoding", "encoded", "Encasing", "encoder", " encryption", "Encoded", "Encryption", "encaging", "enryption", "Encoder", "Encording", "ecoded", "ecoder", " encasing", " encaging", " encoder", "decasing", "enoder", "decoder", "decording", "enaging", "decoded", " encording", "enoding", "ecryption"]}}
{"id1": "189963", "id2": "18974466", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewrites", "readAndRebwrite", "readandrewrite", "readAndSwwrite", "readAndRewwrite", "readAndSwrap", "readAndSwrite", "readandRewrite", "readAndrewrap", "readAndRewrap", "readAndRebrites", "readandrewwrite", "readAndRebrap", "readandRewrap", "readandRewrites", "readAndSwrites", "readandrewrites", "readAndrewrite", "readAndrewwrite", "readAndRebrite", "readandRewwrite", "readAndRewrites", "readandrewrap"], "inFile": ["inFilename", "loginFile", "outFilename", "inputfile", "InFiles", "InFile", " inFiles", "oldFile", "loginFilename", " inSourceFile", "outSourceFile", "InSourceFile", "inputFiles", "outFiles", "oldFiles", " inFilename", "loginFiles", "inputFile", "inSourceFile", "loginfile", "outfile", " infile", "inputFilename", "inFiles", "oldfile", "infile", "oldFilename", "Infile"], "outFile": [" outStream", "offPlace", "outFilename", " outDir", "outputPlace", "outFILE", "OutStream", "outputFilename", "newDir", " outfile", "thisFILE", "outputFile", "offFile", "outDir", "processFilename", "exfile", "exFILE", "newfile", "processPlace", "thisFile", "processFILE", "thisfile", "offFilename", "thisFilename", "outStream", "outPlace", "newFile", "exFile", "exFilename", "outfile", "outputfile", "OutFile", "outputFILE", "OutDir", "offFILE", "processFile", "newStream", "Outfile"], "iis": ["iniis", "Iiss", "iiIs", "iiIS", " iIS", " iIs", "iIs", "iniiss", "ciiss", "ciis", "Iis", "Iais", " iris", "IIS", "ciais", "ciIs", "iiss", "ciris", "iniIS", "iniIs", "iiris", "iiis", "iiiss", "ciIS", "iniris", "iais", " iiss", "iris", "iIS", " iais"], "dcmParser": ["dcmHelper", "dpmarser", "dmcPar", "dmoduleJar", "dmcJar", "dcmPar", "dbmPolicy", "dCMPlugin", "dmoduleParser", "dcmJar", "fcmHandler", "dcrPar", "fpmParser", "dmcarser", "dpmparser", "dbmHelper", "dmissionReader", "dpmLoader", " dpmLoader", "dcrReader", "dbmPlugin", "dCMParser", "dmoduleparser", "dpmPolicy", " dcrParser", "dmPlugin", "dkmHelper", "DcmInstallation", "dmmParser", "dcmparser", " dpmPolicy", " dcmPlugin", "dcmLoader", " dpmHelper", "dmLoader", "dhemReader", "dcmarser", "dpmHelper", "dbmParser", "fpmHandler", "dpmHandler", "dhemParser", "dcrJar", "dpmJar", " dcmLanguage", "fcmParser", "dcrarser", "dcmPolicy", "dkmParser", "dpmInstallation", " dpmJar", "dmodulePlugin", "dmmparser", "dcmLanguage", "dhemInstallation", "dcmInstallation", "fpmparser", "dpmParser", " dpmparser", " dcmPar", "dcmHandler", "dcrPlugin", "dmcParser", " dcmparser", "dcmReader", " dcrReader", "fcmReader", "DcmReader", " dpmPlugin", "dCMparser", "dpmLanguage", " dpmReader", "dmParser", "dmoduleReader", "dmissionPlugin", "dhemJar", " dpmPar", " dcrLoader", "dpmPar", "fpmReader", "dcrParser", "DcmJar", "dmissionParser", " dcmReader", "dCMHandler", "dpmPlugin", " dpmarser", " dpmLanguage", "dmmPlugin", " dcmarser", "dkmPolicy", " dcmHelper", " dcmLoader", "fcmparser", "dpmReader", " dpmParser", "dmReader", " dcmJar", " dcrPlugin", "dCMReader", "dmmLoader", "DcmParser", " dcmPolicy", "dkmPlugin", "dcmPlugin", "dCMLoader", "dcrLoader", "dmissionLanguage"], "ds": ["dd", "dr", "vals", "des", "ants", "os", "vs", "dc", "amps", "dat", "utils", "DS", "ls", "services", "details", "Ds", "ads", "src", "ns", "points", "sync", "ld", "conn", "js", "ws", "da", "ts", "ays", "cdn", "xs", "ps", "session", "d", "ils", "Db", "dt", "ros", "Os", "tes", "cs", "df", "uds", "dds", "ras", "eps", "gd", "ins", "iss", "qs", "is", "rs", "ys", "gs", "icks", "nas", "bs", "data", "sys", "pd", "ss", "tx", "ks", "di", "asi", "db", "parts", "drivers", "s"], "pdReader": ["ddRunner", "hdWriter", "hdLoader", "xdRead", "hdStream", "pcLoader", "pdStream", "pbLoader", "dsLoader", "pbReader", "ddLoader", "pcRead", "ddReader", "pdreader", "xdWriter", "hdReader", "hdRunner", "hdreader", "pbRunner", "ddStream", "pcWriter", "dsreader", "pdLoader", "pbStream", "dsReader", "xdReader", "hdRead", "pdRead", "pcReader", "dsRead", "xdreader", "pdRunner", "dsWriter"], "out": ["flow", "her", "model", "temp", "group", "list", "full", "page", "null", "again", "result", "img", "layer", "name", "file", "lib", "connection", "parent", "s", "device", "in", "o", "login", "outer", "child", "point", "to", "write", "cli", "over", "cache", "sync", "output", "OUT", "password", "conn", "auto", "builder", "code", "session", "pass", "outs", "doc", "io", "Out", "co", "sys", "user", "down", "copy", "err", "base", "inner", " in", "at", "exp", "later", "object", "array", "external", "line", "diff", "client", "ssl", "term", "ext", "data", "gen", "lock", "ex", "default", "inc", "db", "exec", "obj", "image", "dev", "w", "order", "with", "net", "up", "key", "writer", "store", "oder", "part", "director", "manager", "as", "word", "dot", "url"], "dcmEncParam": ["dcmEnParam", "dcmArchArg", "dcmEnPar", "dcmEnArg", "dcmDecParam", "dcmDecType", "dcmDecArg", "dcmElType", "dcmArchParameter", "dcmEncArg", "dcmEnPart", "dcmElPar", "dcmArchParam", "dcmEncType", "dcmSecParam", "dcmEnType", "dcmDecPar", "dcmEstParameter", "dcmDecParameter", "dcmEncPart", "dcmEncParameter", "dcmEstPar", "dcmEncPar", "dcmElParam", "dcmEnParameter", "dcmElParameter", "dcmEstParam", "dcmSecType", "dcmDecPart", "dcmSecPar", "dcmEstType", "dcmSecPart"], "pdWriter": ["htReader", "ddOutput", "htWriter", "hdWriter", "dpWriting", "htWrite", "dsOutput", "PDWrite", "PDWriter", "ddWrite", "ddReader", "hdReader", "pdOutput", "pdWrite", "dpReader", "dsWrite", "ddWriter", "PDReader", "PDWriting", "hdWrite", "dsReader", "pdWriting", "hdOutput", "dpWrite", "dpWriter", "dsWriter", "htWriting"]}}
{"id1": "15510198", "id2": "8330057", "code1": "    protected static Parser buildParser(URL url) throws IOException, ParserException {\n        Parser parser;\n        URLConnection connection = openConnection(url);\n        if (!(connection instanceof HttpURLConnection) || ((HttpURLConnection) connection).getResponseCode() == 200) {\n            parser = new Parser(connection);\n        } else {\n            parser = null;\n        }\n        return parser;\n    }\n", "code2": "    public void getHttpURL() throws Exception {\n        boolean display = true;\n        boolean allHeaders = false;\n        String url = null;\n        url = \"http://localhost/cubigraf2\";\n        url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\";\n        url = \"http://www.uni.pt/img/home-direito.gif\";\n        url = \"http://www.google.com\";\n        URLConnection uc = new URL(url).openConnection();\n        println(\"HEADERS:\");\n        if (allHeaders) {\n            Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator();\n            while (itHeaders.hasNext()) {\n                Map.Entry<String, List<String>> e = itHeaders.next();\n                Iterator<?> itValues = e.getValue().iterator();\n                while (itValues.hasNext()) {\n                    println(e.getKey() + \": \" + itValues.next());\n                }\n            }\n        } else {\n            showObjectProperty(uc, \"getContentEncoding\");\n            showObjectProperty(uc, \"getContentLength\");\n            showObjectProperty(uc, \"getContentType\");\n            showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP);\n        }\n        ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString());\n        if (display) {\n            println(\"BODY:\");\n            ExtendedReader reader = new ExtendedReader(in);\n            for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                println(s);\n            }\n        } else {\n            println(\"(BODY saved to a file)\");\n            String contentType = uc.getContentType();\n            StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\");\n            filename.append(\".\");\n            filename.append(contentType.substring(contentType.indexOf(\"/\") + 1));\n            File file = new File(filename.toString());\n            ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.getAbsolutePath());\n            Streams.copy(in, out);\n            out.close();\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"buildParser": ["newReader", "buildHandler", "makeWriter", "buildReader", "constructHandler", "newWriter", "makeHandler", "makeReader", "constructReader", "constructWriter", "makeParser", "newParser", "constructParser", "buildWriter", "newHandler"], "url": ["link", "image", "URL", "base", "resource", "service", "www", "config", "this", "Url", "open", "obj", "channel", "http", "l", "object", "page", " URL", "class", "null", "c", "path", "io", "uri", "bug", "loader", "name", "location", "ssl", "proxy", "server", "data", "file", "host", "str", "sl", "loc", "source", "address"], "ParserException": [" IOError", "IOExc", "ParserError", "IOError", "SSLError", " IOExc", "IOException", "SSLExc", " IOException", "SSLException", "ParserExc"], "parser": ["slave", "pool", "jack", "this", "arser", "root", "fruit", "pc", "worker", "parse", "http", "master", "ler", "cache", "api", "writer", "jp", "object", "style", "null", "class", "builder", "pe", "au", "handler", "er", "p", "type", "result", "se", "x", "Parser", "fp", "xml", "manager", "library", "loader", "test", "server", "data", "seed", "pd", "php", "instance", "angler", "reader", "pard", "config", "parent", "plugin", "processor"], "connection": ["lc", "image", "link", "j", "service", "resource", "section", "ion", "this", "event", "function", "open", "channel", "Connection", "http", "message", "conn", "object", "application", "class", "c", "position", "condition", "session", "collection", "relation", "handler", "io", "pointer", "uri", "response", "client", "character", "context", "socket", "communication", "proxy", "con", "loc", "server", "reference", "document", " Connection", "connect", "instance", "reader", "database", "bc", "connected", "config", "db", "directory"]}}
{"id1": "20751378", "id2": "7948308", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"hashPassword": ["hashPass", "cryptpassword", "signpassword", "hashWord", "cryptPass", "signPass", " hashPass", "cryptPassword", "hashpassword", " hashWord", "signWord", " hashpassword", "signPassword", "cryptWord"], "password": ["encrypted", "Password", "sha", " Password", "prefix", "content", "w", "input", "plain", " passwords", "pattern", "text", "message", "cache", "key", "wd", "pad", "string", "code", "pass", "crypt", "token", "path", "padding", "phrase", "p", "number", "mac", "secret", "command", "auth", "name", "PASS", "word", "user", "data", "seed", "username", "security", "sword", "description", "database", "words", "python", "address"], "hash": ["her", "sha", "height", "hex", "history", "format", "json", "proof", "result", "number", "ashes", "length", "Hash", "search", "call", "value", "pkg", "host", "memory", "log", "html", "pool", "oh", "check", "dig", "cache", "style", "string", "code", "math", "gh", "kh", "phrase", "uild", "build", "handle", "secret", "ssh", "mod", "id", "user", "error", "msg", "copy", "base", "match", "version", "text", "bolt", "replace", "ruby", "update", "array", "addr", "rh", "mac", "sum", "hed", "dump", "ha", "alt", "put", "security", "tag", "address", "index", "root", "square", "message", "key", "work", "sh", "ash", "auth", "h", "url"], "md": ["dd", "nd", "nm", "sha", "cmd", "am", "dig", "metadata", "ma", "amd", " MD", "hd", "mm", "mad", "xd", "ME", "ms", "wd", "vd", "km", "gb", "der", "grad", "mand", "d", "m", "kg", "bd", "pm", "df", "sm", "mg", "mac", "mt", "gd", "od", "sd", "MD", "Cmd", "mod", "dh", "pd", "mag", "dm", "mc", "f", "mb", "hm", "meta"]}}
{"id1": "3375724", "id2": "7296597", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    public void create() {\n        Connection conn = OrmHandler.getInstance().getSession().getConnection(this);\n        Statement stat = null;\n        StringBuilder sql = new StringBuilder(256);\n        try {\n            getRenderer().printCreateDatabase(this, sql);\n            conn = createConnection();\n            stat = conn.createStatement();\n            stat.executeUpdate(sql.toString());\n            conn.commit();\n            if (LOGGER.isLoggable(Level.INFO)) {\n                LOGGER.info(sql.toString());\n            }\n        } catch (Throwable e) {\n            if (conn != null) {\n                try {\n                    conn.rollback();\n                } catch (SQLException ex) {\n                    LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n                }\n            }\n            throw new IllegalArgumentException(\"Statement error:\\n\" + sql, e);\n        } finally {\n            try {\n                close(conn, stat, null, true);\n            } catch (IllegalStateException ex) {\n                LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" importarEmissoresDosTitulasf", " importarEmissoresDosTitulasFe", " importarEmissoresDosTitulosf", " importarEmissoresDosTitULosPF", " importarEmissoresDosTitularF", " importarEmissoresDosTitulosPF", " importarEmissoresDosTituloFe", " importarEmissoresDosTituloF", " importarEmissoresDosTitularFe", " importarEmissoresDosTitulasF", " importarEmissoresDosTitULoFe", " importarEmissoresDosTitularf", " importarEmissoresDosTitulosF", " importarEmissoresDosTitULoPF", " importarEmissoresDosTitularPF", " importarEmissoresDosTitulosFe", " importarEmissoresDosTituloPF", " importarEmissoresDosTitULosF", " importarEmissoresDosTitulof", " importarEmissoresDosTitULoF", " importarEmissoresDosTitULosf", " importarEmissoresDosTitULof", " importarEmissoresDosTitulasPF", " importarEmissoresDosTitULosFe"], "pArquivoTXT": ["pArquivoDXT", "pArquivaTxt", "pArquivoFEMP", "pArquivoTTP", "pArquivoFxt", "pArquivDBT", "pArquivDXT", "pArquivoOTEMP", "pArquivaTEXT", "pArquivoBxt", "pArquivoLBT", "pArquivaFEXT", "pArquivoBXT", "pArquivaFTP", "pArquivoBEMP", "pArquivoTLS", "pArquivoTEMP", "pArquivTLS", "pArquivaFxt", "pArquivoLXT", "pArquivoQxt", "pArquivoQXT", "pArquivaFEMP", "pArquivoOTTP", "pArquivoFTP", "pArquivoDEXT", "pArquivoLxt", "pArquivoOTxt", "pArquivoBLS", "pArquivoTBT", "pArquivDxt", "pArquivaTEMP", "pArquivoLLS", "pArquivaTTP", "pArquivoQEXT", "pArquivoDLS", "pArquivoFEXT", "pArquivoQBT", "pArquivoDBT", "pArquivoTxt", "pArquivoFBT", "pArquivoFXT", "pArquivaTBT", "pArquivoTEXT", "pArquivaFBT", "pArquivoDxt", "pArquivTXT", "pArquivoBTP", "pArquivTBT", "pArquivDLS", "pArquivTxt", "pArquivoOTXT", "pArquivaFXT", "pArquivaTXT", "pArquivoBBT"], "pAndamento": [" pOrementO", " pOrementos", " pAndmentO", " pOrementoo", " pAndemento", " pAndmentos", " pAndamentO", " pAndementO", " pAndentiono", " pAndementoo", " pAndamentos", " pOramentO", " pAndentionos", " pAndmentoo", " pAndementos", " pOremento", " pAndamentoo", " pOramento", " pAndmento", " pOramentoo", " pAndentionoo", " pAndentionO", " pOramentos"], "numeroDoRegistro": ["numeroDoRegestro", "numeroDoregistro", "numeroDoRegiftorno", "numeroDoRegestrano", "numeroDoRegpectros", "numeroDoregestros", "numeroDoRegiftros", "numeroDoRegestorno", "numeroDoRegpectrano", "numeroDoregistros", "numeroDoregestorno", "numeroDoRegiftrano", "numeroDoregistrano", "numeroDoRegpectro", "numeroDoRegestros", "numeroDoRegiftro", "numeroDoRegpectorno", "numeroDoregistorno", "numeroDoregestro", "numeroDoRegistrano", "numeroDoRegistorno", "numeroDoRegistros", "numeroDoregestrano"], "in": ["ini", "err", "kin", " out", "login", "config", "inn", "scan", "cl", "with", "In", "slice", "l", "b", "bin", "c", " IN", "r", "IN", "session", "g", "again", "t", "query", "nin", "part", "conf", "cin", "out", "ins", "is", "ner", "con", "ln", "span", "rin", "data", "ex", "reader", "i", "n", "connection", "m", "inc", "f", "url", "s"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicioDestaco", "stmtLimpezaInicialDestania", "stmtLimpezaInicioCombario", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialCombination", "stmtLimpezaInicialDestario", "stmtLimpezaInicialDesino", "stmtLimpezaInicioDestario", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialCombania", "stmtLimpezaInicialDesaco", "stmtLimpezaInicioDestao", "stmtLimpezaInicialdestaco", "stmtLimpezaInicioCombaco", "stmtLimpezaInicialDestination", "stmtLimpezaInicialCombino", "stmtLimpezaInicialCombaco", "stmtLimpezaInicialDesao", "stmtLimpezaInicioCombao", "stmtLimpezaInicialCombario", "stmtLimpezaInicialdestao", "stmtLimpezaInicioDestino", "stmtLimpezaInicialCombao", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialDestaco", "stmtLimpezaInicialDestao", "stmtLimpezaIniciaDestania", "stmtLimpezaInicialDesario", "stmtLimpezaInicialdestania", "stmtLimpezaInicialdestino", "stmtLimpezaInicialdestario", "stmtLimpezaInicialdestination", "stmtLimpezaInicioCombino"], "sql": ["err", "body", "log", "sol", "cmd", "setup", "html", "nl", "lua", "json", "ls", "SQL", "details", "zip", "http", "filename", "software", "liquid", "l", "shell", "csv", "string", "spec", " SQL", "params", "sn", "query", "kl", "select", "stat", "result", "ql", "sg", "sv", "sb", "eps", "sq", "expr", "where", "QL", "util", "statement", "ssl", "socket", "term", "sys", "search", "data", "id", "fn", "seed", "layout", "sf", "description", "sl", "comment", "rl", "el", "dl", "msg", "acl", "db", "install", "url", "s"], "stmtDestino": ["stmtCampino", "stmDestino", "stmtDistinos", "stmtDestinos", "stmCampaco", "stmdDestin", "stmtdestin", "stmCampania", "stmtDistino", "stmCampino", "stmdDestorno", "stmtDistaco", "stmtdestaco", "stmdDestino", "stmtDestin", "stmtDestaco", "stmCamporno", "stmtDestania", "stmtDestorno", "stmtDistorno", "stmtCampania", "stmdDestinos", "stmtCamporno", "stmtdestania", "stmtdestino", "stmDestaco", "stmDestania", "stmtDistin", "stmtdestinos", "stmtDistania", "stmDestorno", "stmtCampaco", "stmtdestorno"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABOCALSHOU", "TAMANHO_DO_CABECALCO", "TAMANHO_DO_CABECALSHOU", "TAMANHO_DO_CABECULHOU", "TAMANHO_DO_CABECALHOU", "TAMANHO_DO_CABOCALHO", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABECALSCO", "TAMANHO_DO_CABOCALCO", "TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABISCALHO", "TAMANHO_DO_CABECALLHOU", "TAMANHO_DO_CABISCALLHO", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABISCALLHI", "TAMANHO_DO_CABOCALSCO", "TAMANHO_DO_CABOCALSHO", "TAMANHO_DO_CABECALLCO", "TAMANHO_DO_CABECALSHO", "TAMANHO_DO_CABECARHOU", "TAMANHO_DO_CABOCALHOU", "TAMANHO_DO_CABISCALHI", "TAMANHO_DO_CABISCALLHOU", "TAMANHO_DO_CABISCALHOU", "TAMANHO_DO_CABECARCO", "TAMANHO_DO_CABECALSHI"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPE__DO", "TAMANHO_DO_RODAPJDO", "TAMANHO_DO_RODAPEECPO", "TAMANHO_DO_RODAPE_TO", "TAMANHO_DO_RODAPE__do", "TAMANHO_DO_RODAPJdo", "TAMANHO_DO_RODAP_TO", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAP_Do", "TAMANHO_DO_RODAPEJPO", "TAMANHO_DO_RODAPEJdo", "TAMANHO_DO_RODAPEECDO", "TAMANHO_DO_RODAPEJTO", "TAMANHO_DO_RODAPE_PO", "TAMANHO_DO_RODAP_PO", "TAMANHO_DO_RODAPEECDo", "TAMANHO_DO_RODAPJPO", "TAMANHO_DO_RODAPJDo", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAPE__TO", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAPE__Do", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAPJTO"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADANDOJ", "TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADADOPS_", "TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADADosAD", "TAMANHO_DOS_METADADIESJ", "TAMANHO_DOS_METADADOS___", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADADOAD", "TAMANHO_DOS_METADADOSJ", "TAMANHO_DOS_METADANDOAD", "TAMANHO_DOS_METADANDOS___", "TAMANHO_DOS_METADADOTSAD", "TAMANHO_DOS_METADANDO_", "TAMANHO_DOS_METADADOPS___", "TAMANHO_DOS_METADADIES_", "TAMANHO_DOS_METADADOJ", "TAMANHO_DOS_METADANDOS_", "TAMANHO_DOS_METADADOSAD", "TAMANHO_DOS_METADANDO___", "TAMANHO_DOS_METADADOTS_", "TAMANHO_DOS_METADADOPSJ", "TAMANHO_DOS_METADADO___", "TAMANHO_DOS_METADADIES___", "TAMANHO_DOS_METADANDOSJ", "TAMANHO_DOS_METADANDOSAD"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_PORPRECIES", "TAMANHO_MEDIO_PORPREGES", "TAMANHO_MEDIO_POR_RECAS", "TAMANHO_MEDIO_PORPREGIC", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_PORPRECAS", "TAMANHO_MEDIO_POR_GAS", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_PORPREGAS", "TAMANHO_MEDIO_PORPREGIT", "TAMANHO_MEDIO_POR_REGIT", "TAMANHO_MEDIO_PORPRegES", "TAMANHO_MEDIO_POR_GIES", "TAMANHO_MEDIO_POR_REGAS", "TAMANHO_MEDIO_PORPRegIT", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_POR_EGIS", "TAMANHO_MEDIO_POR_GIC", "TAMANHO_MEDIO_POR_GIS", "TAMANHO_MEDIO_POR_RegIT", "TAMANHO_MEDIO_POR_EGES", "TAMANHO_MEDIO_PORPRegIS", "TAMANHO_MEDIO_POR_EGIES", "TAMANHO_MEDIO_POR_REGIES", "TAMANHO_MEDIO_POR_RegIS", "TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_PORPRECIC", "TAMANHO_MEDIO_POR_RegIC", "TAMANHO_MEDIO_PORPREGIES", "TAMANHO_MEDIO_PORPRegIES", "TAMANHO_MEDIO_POR_EGIT", "TAMANHO_MEDIO_POR_RECIES", "TAMANHO_MEDIO_PORPRECIS", "TAMANHO_MEDIO_POR_RegAS", "TAMANHO_MEDIO_PORPREGIS", "TAMANHO_MEDIO_POR_RegIES"], "tamanhoDosArquivos": ["tamanhoDosArquivalo", "tamanhoDosArQUivlos", "tamanhoDosArquervlos", "tamanhoDosArqIVos", "tamanhoDosArquIVoes", "tamanhoDosArQUivo", "tamanhoDosArquievo", "tamanhoDosArqivos", "tamanhoDosArQUervo", "tamanhoDosArquervo", "tamanhoDosArquievOs", "tamanhoDosArquivo", "tamanhoDosArQUervOs", "tamanhoDosArquIVo", "tamanhoDosArquIVos", "tamanhoDosArqIVlos", "tamanhoDosArquivalos", "tamanhoDosArQUervlos", "tamanhoDosArquervos", "tamanhoDosArquivOs", "tamanhoDosArquievlos", "tamanhoDosArquivallos", "tamanhoDosArquievos", "tamanhoDosArquIVlos", "tamanhoDosArqIVoes", "tamanhoDosArquivlos", "tamanhoDosArQUervos", "tamanhoDosArqIVo", "tamanhoDosArQUivos", "tamanhoDosArqivo", "tamanhoDosArquervoes", "tamanhoDosArQUivOs", "tamanhoDosArquivoes", "tamanhoDosArqivoes", "tamanhoDosArquervOs", "tamanhoDosArquivaloes", "tamanhoDosArqivlos", "tamanhoDosArquIVOs"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimante", "quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstimmante", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstipante", "quantidadeDeRegistrosEstivante", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstivado"], "registro": [" registulo", "regestro", " regestro", " regestros", "registulo", "regastro", "regastration", " registros", " registration", "registration", " regestulo", " regestration", "regestros", "regestration", "registros", "regustros", "regustration", "regastulo", "regestulo", "regustro", "regustulo", "regastros"], "campos": [" campas", "CampOS", "campOS", " casos", "campas", "Campos", " caso", " casOS", "Campo", " campo", "campo", " casas", "Campas", " campOS"]}}
{"id1": "20717531", "id2": "812803", "code1": "    public static String encrypt(String plainText) {\n        if (TextUtils.isEmpty(plainText)) {\n            plainText = \"\";\n        }\n        StringBuilder text = new StringBuilder();\n        for (int i = plainText.length() - 1; i >= 0; i--) {\n            text.append(plainText.charAt(i));\n        }\n        plainText = text.toString();\n        MessageDigest mDigest;\n        try {\n            mDigest = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            return plainText;\n        }\n        mDigest.update(plainText.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": [" decipher", " deccrypt", "encress", "Enccrypt", " encipher", "Encrypt", "encipher", "Encress", " decress", " decrypt", " enccrypt", " encress", "Encipher", "enccrypt"], "plainText": ["protectedString", "flatTEXT", "publicTEXT", "protectedTextColor", " plainTarget", "binarytext", "batTEXT", "simpletext", "plainTextColor", "singletext", "binaryText", "externalText", "binaryPart", "externalString", "batText", "flatText", "batContent", "protectedContent", "battext", "simpleText", "flatTime", "singleString", "singlePart", " plainPart", "protectedtext", "publictext", " plainTextColor", "fullData", "plaintext", "originalTextColor", "externaltext", "flattext", "plainTarget", "fullTEXT", "plainTime", " plainData", "externalKey", " plainTEXT", "plainString", "fulltext", "originalText", " plainKey", "plainData", "binaryString", "publicTarget", "originalTEXT", "publicText", "plainContent", "simpleTime", "protectedKey", "flatContent", "protectedTEXT", " plainString", "plainKey", "originaltext", "flatData", "simpleTEXT", "plainTEXT", "singleText", "fullText", " plainContent", "plainPart", "flatTarget", "protectedText", "fullTime", " plaintext"], "text": ["image", "letter", "service", "feed", "null", "config", "event", "form", "input", "pattern", "message", "output", "key", "use", "b", "writer", "post", "object", "struct", "password", "print", "string", "txt", "builder", "code", "math", "contract", "font", "url", "buffer", "Text", "path", "source", "result", "width", "out", "length", "editor", "context", "off", "test", "ext", "word", "data", "id", "port", "str", "value", "tx", "TEXT", "append", "address"], "i": ["ini", "z", "mi", "index", "j", "o", "in", "chi", "temp", "io", "field", "hi", "phi", "ii", "ix", "fi", "slice", "mu", "key", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "t", "abi", "li", "ind", "k", "ci", "ie", "p", "multi", "si", "ni", "xi", "I", "bi", "v", "x", "ai", "ji", "uri", "eni", "it", "ip", "y", "ti", "h", "id", "qi", "e", "iu", "f", "u", "vi", "n", "di", "m", "oi", "s"], "mDigest": ["mDest", "mHashusher", " mDigester", "mDigusher", "mdigEST", "MDester", "MDex", "mHashester", "mEdest", "cmdigester", "cmDigester", " mDigEST", "MDest", "mHashest", "mDigse", "mDigEST", "mDigex", "MDigex", "cmdigest", "mdigex", "mdigester", "mDigger", " mHashusher", "mdigusher", "mdigse", "mDer", " mHashest", "mDigester", "mDester", " mDEST", "mDusher", "cmDigest", "mEdester", "mDger", " mDse", "mDigests", "mCompest", "mCompester", "mDested", " mDest", "mDiger", "mDex", "cmDiger", "mdigested", "mdiger", "mDests", "mEder", " mHashester", "mCompex", "mEdested", "mdigger", " mHashger", "MDigest", "mdigest", " mDigse", "MDigests", " mDester", "mHashse", "cmdigested", "cmdiger", " mDigger", "mDigested", "cmDigested", "mHashger", "mDse", "MDests", "mdigests", "mCompests", "mDEST", "mHashEST", " mDigusher", "MDigester"], "d": ["dd", "z", "dim", "dr", " D", "dc", "dat", "dig", "D", "dos", "l", "b", "bytes", "ld", "cd", "string", "da", "did", "c", " data", "t", "fd", "p", "ds", "dt", "v", "x", "sd", "md", "a", "h", "data", "id", "dh", "ded", "e", "dn", "str", "u", "n", "di", "dl", "m", "db", "f", "s"], "hash": ["image", "her", "sha", "html", "log", "base", "hex", "history", "square", "version", "message", "key", "output", "b", "bin", "print", "string", "code", "array", "kh", "buffer", "db", "result", "build", "v", "sh", "number", "ashes", "secret", "carry", "mac", "ash", "block", "size", "ssh", "Hash", "bar", "hed", "sum", "h", "ha", "shadow", "user", "header", "str", "dot", "memory", "f", "url", "cover"]}}
{"id1": "14191679", "id2": "5035872", "code1": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"EncodeReturn": ["EnodeReturn", "EnodedReturns", "EnodeData", "EncodeReturns", "EncodReturns", "EncodData", "EnccodeReturns", "EnccodeReturn", "EncodeResult", "EnodedReturn", "EncodResult", "EncodeData", "EncodReturn", "EnccodeResult", "EnodedData", "EnodedResult", "EnodeResult", "EnodeReturns", "EnccodeData"], "IOException": ["IPError", " IOError", "Downloadception", "IPception", "DownloadError", "IOError", "IOception", "IPException", "DownloadException", " IOception"], "c": ["enc", "lc", "conv", "dc", "nc", "pc", "cur", "fc", "cu", "cache", "l", "ch", "cd", "b", "C", "cf", "r", "cpp", "ct", "t", "d", "ci", "p", "sc", "cmp", "gc", "cs", "proc", "ce", "xc", "client", "cc", "y", "chain", "ac", "e", "mc", "u", "n", "uc", "cp", "ec", "m", "cr", "f"], "tmpf": ["zipF", "poraryfen", "tmpF", "zipfd", "vmF", " tmpfs", "tempF", " tmpcf", "poraryF", "empf", "tempfd", "tempfs", "empfd", "tempfen", "tmpfen", "vmfs", "vmf", "porarycf", "poraryf", "zipf", " tmpF", "tempf", "empfs", "empF", "zipfs", "tmpcf", "tmpfd", "vmcf", "tempcf", "tmpfs", " tmpfen"], "cw": [" cwe", "psw", "cwd", "Csw", "pwa", "rcw", " cwd", "cW", "lcwe", "fw", "cwe", "ffw", "rcwb", "rcwe", "cfw", "Cws", "lcwd", "fws", "fwa", " cwa", "lcw", " csw", " cws", " cW", "cws", "pw", "rcwd", " cwb", "Cw", "Cwa", "pW", "csw", "cwb", " cfw", "cwa", "lcwb", "CW", "Cfw"], "encdata": ["encdatabase", " encData", "Enckeys", "installdata", "encroot", "Encdata", "secdat", "envroot", "envreader", "inccache", "encdat", "envData", " encdat", " encreader", "extdatabase", "encreader", "envdata", "envdat", "incroot", "EncData", "enccache", "extData", "secdata", "extdata", "secData", " encroot", " encdatabase", "incdata", "installData", "envcache", "installdatabase", "seckeys", " enccache", "extdat", "increader", "encData", "installdat", "envkeys", "Encdat", "enckeys"], "pigdata": ["pigrdata", "pichla", "pocdata", "pippData", "Pigla", "pocresource", "pibdat", "Pigscache", "pigsdata", "Pigcache", "pichdata", "pocData", "pigrData", "Pibdat", "pagdata", "picdat", "Pigresults", "Pigsresults", "pigrresults", "pigscache", "pigsla", "PigsData", "pibresource", "PigData", "Pigdata", "pigresults", "pigsresults", "pichcache", "picdata", "Pigsla", "picresource", "pagdat", "pagresults", "pigresource", "PibData", "Pibdata", "pigrdat", "pippdata", "pigsData", "pigData", "pigdat", "pigla", "pibdata", "Pigsdata", "pigsdat", "pibData", "Pigdat", "Pigsdat", "picData", "Pibresource", "pippla", "pagData", "pippcache", "pichData", "pocdat", "Pigresource", "pigcache"], "pigroute": ["apibrouting", "pigrouter", "apibroute", "pigrroute", "fibroute", "apigroute", "pigrationroute", "apibrroute", "pirmouter", "figrote", "pipelouting", "figroute", "pigrationange", "pibrroute", "pigerote", "pirmoute", "migroute", "migrune", "piarouting", "miarune", "pigrouting", "pigerune", "pibrange", "pipelroute", "piarote", "pigerouting", "pibroute", "pigrationouting", "pipeloute", "pipelange", "pibrouting", "apigrouting", "figrroute", "fibrroute", "pibrote", "fibrange", "apigrouter", "miarote", "apibrouter", "pirmroute", "apigrroute", "piarune", "piaroute", "migrote", "miarouting", "pipelune", "miaroute", "figrange", "fibrote", "pigrationouter", "pigrune", "pigeroute", "pigrote", "pirmouting", "pibrouter", "pigrange", "migrouting", "pipelote", "pigrationote", "pigrationoute"], "fos": ["fo", " fops", "fOS", " foes", " fo", "to", "tos", "pOS", "Foc", "toes", "pos", "poes", "refos", "Foes", "refoes", "foes", "refops", "Fos", "fops", "refOS", " fOS", "toc", "pops", "Fo"], "foc": [" fec", "fac", "Fec", " focol", "Foc", "fec", "Fic", "infoc", "infocol", "infic", " fac", "Fac", "infac", "Focol", "focol", "infec"], "fis": ["cig", "fics", "fig", "Fi", "fi", " fi", "cics", "cic", "Fig", "Fic", " fics", "Fis", "infics", "infis", "infic", " fig", "Fics", "cis", "infi"], "fic": ["pic", "cfoc", "fics", "Fico", "fac", "pis", "rfic", " fisc", "fisc", "rfoc", "cfics", "cfis", "Foc", "cfic", "Fic", " fics", "infoc", "rfics", "Fis", "infics", "rfis", " fico", "infic", "fico", " fac", "cfico", "Fac", "Fics", "poc", "pac", "infisc", "Fisc"]}}
{"id1": "20623709", "id2": "6421904", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"split": ["share", "format", "open", "match", "parse", "add", "process", "run", "sync", "update", "set", "sort", "join", "part", "cmp", "build", "diff", "Split", "start", "init", "archive", "transfer", "delete", "execute", "exec", "append", "copy"], "targetDirectory": ["TargetDir", " targetPath", "basePath", "destFile", "baseFolder", "targetPath", "targetRoot", "TargetDirectory", "TargetDatabase", "outputFolder", "TargetFile", "currentFolder", "TargetRoot", "masterDirectory", "currentDirectory", "targetDatabase", "currentPath", "baseDatabase", "outputDir", "targetFolder", "baseDirectory", "destDirectory", "destFolder", " targetRoot", "TargetFolder", "destDir", "masterDir", "baseFile", " targetFolder", " targetFile", "targetFile", "currentRoot", "TargetPath", " targetDir", "currentDir", "outputDirectory", "masterDatabase", "baseDir", "targetDir", "outputFile", "masterPath"], "prefix": ["folder", "unit", "index", "base", "resource", "temp", "offset", "config", "root", "fix", "sequence", "format", "pre", "domain", "patch", "Pref", "pattern", "ix", "cache", "resolution", "filename", "queue", " suffix", "prot", "string", "txt", "padding", "path", "type", "fixed", "uri", "number", "fp", "first", "name", "FIX", "username", "timeout", "template", "append", "directory"], "maxUnitBases": ["maxunitBases", "maxUnitPlases", "maxunitAliaches", "maxUnitAliails", "maxUnitBasing", "maxUnitEase", "maxUnitQueues", "maxUnitEails", "maxUnitAliases", "maxUnitAliase", "maxunitBaches", "maxUnitQuease", "maxUnitBase", "maxunitBails", "maxunitAliails", "maxUnitQueasing", "maxUnitBues", "maxUnitBaches", "maxUnitAliaches", "maxUnitBails", "maxunitBasing", "maxunitBues", "maxUnitChase", "maxUnitChases", "maxUnitAliasing", "maxunitAliase", "maxunitAliases", "maxUnitPlaches", "maxUnitEaches", "maxUnitChasing", "maxunitAliasing", "maxUnitAliues", "maxUnitChues", "maxUnitPlase", "maxUnitQueases", "maxUnitEases", "maxUnitPlails", "maxunitBase", "maxunitAliues"], "maxUnitEntries": ["maxUnitInties", "maxUnitOrdresses", "maxLineOrdines", "maxLineOrdrations", "maxUnitCountrations", "maxUnitEntryures", "maxUnitAddry", "maxUnitOrdrys", "maxUnitOrdines", "maxunitEnties", "maxunitEntrys", "maxUnitEntryries", "maxUnitAddries", "maxUnitIntrys", "maxUnitEntrys", "maxUnitAddures", "maxUnitOrdries", "maxUnitAddresses", "maxunitEntryries", "maxUnitCountry", "maxUnitEntryresses", "maxunitEntries", "maxUnitEntines", "maxUnitErries", "maxUnitEntryrys", "maxUnitErry", "maxLineOrdry", "maxunitEntryies", "maxLineEntry", "maxUnitErrations", "maxLineOrdries", "maxUnitEntresses", "maxLineEntries", "maxUnitOrdry", "maxUnitOrdrations", "maxUnitEntryry", "maxUnitErines", "maxunitEntresses", "maxUnitEntry", "maxUnitCountines", "maxLineEntrations", "maxUnitOrdies", "maxUnitCountries", "maxunitEntryresses", "maxUnitIntries", "maxUnitEnties", "maxUnitEntryies", "maxUnitIntresses", "maxUnitEntures", "maxunitEntryrys", "maxUnitEntrations", "maxLineEntines"], "fis": ["vai", " fai", " fIs", " fris", " fisc", "fisc", "forisc", "vIs", "vis", "forris", "forIs", "visa", "fIs", "foriss", "forai", "forisa", " fiss", "Fis", "fris", "fisa", "Fiss", "fiss", "foris", "Fisc", "fai", " fisa", "Fris"], "fci": ["hcos", "vai", " fai", "hco", "hai", "efco", "vcos", "fii", "efcos", " fii", "doci", "efai", "dco", "vco", "hci", "bci", "Fii", "bai", "vci", "Fis", "Foci", "dci", " foci", "efci", "bis", "Fci", "Fai", "foci", "fcos", "dii", "Fco", "bco", "fai"], "fos": ["fios", "fo", " fo", "fsios", " fcos", "tos", " fios", "toes", "infoss", "infos", "fso", "Foes", "fscos", "ifios", "foes", "fsos", "infoes", "Fos", "toss", "Fis", "ifo", "Foss", "infis", "ifos", "fcos", "tis", "ifcos", "foss"], "fco": ["hcos", "hgo", " fgo", "Fico", "dcos", "fbo", "hco", "fgo", "fileco", " fcos", "fileico", " fbo", "lci", "lco", "hci", "dco", "fileci", "dro", " fro", "Fbo", "lgo", "lcos", "dci", " fico", "filebo", "fico", "Fci", "fro", "fcos", "Fco", "lro"], "buffer": ["image", "base", "resource", "feed", "offset", "capacity", "view", "flush", "input", "entry", "channel", "window", "cache", "message", "queue", "rate", "bin", "writer", "info", "texture", "pad", "null", "scale", "buf", "read", "buff", "border", "position", "Buffer", "uffer", "translation", "result", "counter", "response", "layer", "block", "length", "context", "size", "expression", "loader", "pause", "bar", "request", "server", "data", "reference", "binary", "document", "transfer", "header", "callback", "comment", "zero", "reader", "timeout", "iter", "bc", "batch", "source", "memory", "copy", "device"], "currentBasesCount": ["currentChasesCount", "currentBatchescount", "currentChaseCount", "currentBasingNum", "currentBasingCounter", "currentBasingcount", "currentBasesCounter", "currentBasingCount", "currentBatchesCounter", "currentBatchesCount", "currentBasesNum", "currentBasescount", "currentBaseNum", "currentBaseCount", "currentChasesCounter", "currentChaseCounter", "currentChasecount", "currentBatchesNum", "currentBaseCounter", "currentChasescount", "currentChaseNum", "currentChasesNum", "currentBasecount"], "currentEntriesCount": ["currentEntrasLimit", "currentEntursOffset", "currentEnturesCount", "currentAddriesSize", "currentAddriesOffset", "currentEnturesOffset", "currentEnturesLimit", "currentEntursCount", "currentAdduresSize", "currentEntursSize", "currentEntrasCount", "currentAdduresCount", "currentAdduresOffset", "currentEntrasSize", "currentEntrasOffset", "currentEnturesSize", "currentEntriesOffset", "currentEntriesLimit", "currentAdduresLimit", "currentAddriesLimit", "currentEntursLimit", "currentAddriesCount", "currentEntriesSize"], "targetCount": ["Targetcount", "patternSize", "argetSum", "argetCount", "patternSum", "targetcount", "TargetSum", "patterncount", "argetcount", "targetSize", "patternCount", "TargetSize", "TargetCount", "targetSum", "argetSize"], "fastaChannel": ["fastABuffer", "fastanChannel", "fastasConnection", "fastanBuffer", " fastaContext", "fastasContainer", "fastaqColumn", "fastAContainer", "fastAChannel", "fastAConnection", "fastaContainer", "fastasBuffer", "fastaColumn", " fastAChannel", "fastanContainer", " fastAColumn", "fastaqBuffer", " fastAConnection", "fastAColumn", "fastasColumn", "fastaContext", "fastasChannel", "fastanContext", " fastaContainer", "fastaqChannel", "fastAContext", "fastasContext", " fastAContainer", " fastaColumn", " fastaConnection", "fastaConnection", " fastAContext", " fastABuffer", "fastaqConnection"], "totalSeqCount": ["totalSeqCounter", "totalQueQcount", "totalSeuxNum", "totalQueQNum", "totalSeqscount", "totalSeuxCounter", "totalSeuxCount", "totalQueqCounter", "totalQueqcount", "totalQueQCounter", "totalQueQCount", "totalSeQCounter", "totalSeuxcount", "totalSeqNum", "totalQueqNum", "totalSeQCount", "totalSeqsNum", "totalSeQNum", "totalSeQcount", "totalSeqsCount", "totalSeqcount", "totalSeqsCounter", "totalQueqCount"], "totalResiduesCount": ["totalResiduingcount", "totalResqueurescount", "totalResiduationCount", "totalResiduationNum", "totalResiduingCount", "totalResqueuesNum", "totalResqueuresSize", "totalResiduresNum", "totalResidurescount", "totalResiduesSize", "totalResiduresSize", "totalResiduesNum", "totalResiduationSize", "totalResiduresCount", "totalResqueuresCount", "totalResqueuesSize", "totalResiduescount", "totalResiduingSize", "totalResqueuescount", "totalResiduingNum", "totalResqueuesCount", "totalResiduationcount", "totalResqueuresNum"], "prevTime": ["PrevSize", "PrevFile", "prevSize", " prevFile", "prevValue", " prevValue", "PrevValue", " prevSize", "prevFile", "commitValue", "commitFile", "PrevTime", "commitTime", "commitSize"], "fastaFileSize": ["fastasHeaderName", "fastaBlockLength", "fastaPageSize", "fastasFileName", "fastaHeaderSize", "fastaBlockSize", "fastasFileSize", "fastaFileAddress", "fastaFileCount", "fastABufferLength", "fastAFileAddress", "fastaBufferSize", "fastaFilesName", "fastaHeaderLength", "fastaFilesAddress", "fastaFilesSize", "fastaLineAddress", "fastaBufferAddress", "fastasHeaderAddress", "fastABufferSize", "fastaLineCount", "fastaPageLength", "fastABufferAddress", "fastaFilesLength", "fastasHeaderLength", "fastaHeaderAddress", "fastaLineSize", "fastaBufferCount", "fastaHeaderName", "fastAFileLength", "fastasFileAddress", "fastaFileName", "fastaBlockAddress", "fastaFileLength", "fastasFileLength", "fastaLineLength", "fastasHeaderSize", "fastAFileCount", "fastAFileSize", "fastaPageAddress", "fastaBlockCount", "fastABufferCount", "fastaPageName", "fastaBufferLength"], "fastaFileReadOffset": ["fastaDirectoryReadOff", "fastaBufferReadoffset", "fastaFileWriteAmount", "fastaFilesWriteoffset", "fastaFilesReadLength", "fastaDirectoryWriteEntry", "fastaFileLoadOffset", "fastaDirectoryWriteOffset", "fastaDirectoryReadoffset", "fastaFileLengthoffset", "fastaFilesWriteOff", "fastaFilereadLength", "fastaFileWriteEntry", "fastaFileStartOff", "fastaFilereadoffset", "fastaFileLoadLength", "fastaFileStartOffset", "fastaFileLengthLength", "fastaBufferReadAmount", "fastaFileReadAmount", "fastaFileRunOffset", "fastaFilereadOff", "fastaFileReadoffset", "fastaFileStartoffset", "fastaFileRunoffset", "fastaFileWriteLength", "fastaFileLengthOff", "fastaFileLoadoffset", "fastaFilesReadoffset", "fastaFileReadOff", "fastaFileStartEntry", "fastaFileRunEntry", "fastaFileRunOff", "fastaBufferReadOffset", "fastaFilereadOffset", "fastaFileLengthAmount", "fastaFileWriteOffset", "fastaDirectoryReadEntry", "fastaDirectoryReadOffset", "fastaFileLengthOffset", "fastaFileReadLength", "fastaBufferReadLength", "fastaDirectoryWriteOff", "fastaDirectoryWriteoffset", "fastaFileReadEntry", "fastaBufferWriteOffset", "fastaFileLoadAmount", "fastaFileWriteoffset", "fastaBufferWriteAmount", "fastaFilesReadOffset", "fastaBufferWriteLength", "fastaBufferWriteoffset", "fastaFilesWriteOffset", "fastaFileWriteOff", "fastaFilesReadOff", "fastaFilesWriteLength"], "partitionStartOffset": ["partitionStopOrder", "partitionsStartRange", "partitionEndOrder", "partitionBufferOrder", "partitionsEndRange", "partitionEndRange", "partitionStopOffset", "partitionStopRange", "partitionsEndOffset", "partitionsEndOrder", "partitionsStartOff", "partitionStartOrder", "partitionBufferRange", "partitionsStartOrder", "partitionsStartOffset", "partitionStartRange", "partitionBufferOffset", "partitionStartOff", "partitionEndOff", "partitionsEndOff", "partitionBufferOff", "partitionStopOff"], "bufferSize": ["BufferCount", "BufferType", "BufferSize", "processC", "bufferSIZE", " bufferType", " bufferC", "processSize", " bufferCount", "BufferSIZE", "bufferCount", "queueCount", "processType", " bufferSIZE", "bufferType", "BufferC", "bufferC", "processSIZE", "queueSize"], "fastaBuffer": ["fastaPtr", "fastABuffer", "fastaBuff", "fastaQueue", " fastasFile", "FastaStream", " fastAFile", " fastasChannel", "fastanChannel", "FastasBuffer", "fastasBuff", "fastanBuffer", " fastasBuffer", "fastAPtr", "fastanQueue", "fastasContainer", "FastaBuff", "fastABuff", "fastaceChannel", "fastAContainer", "fastAChannel", "fastaContainer", "fastasStream", "fastAFile", "FastasStream", " fastaQueue", "fastasBuffer", "fastanStream", "fastasPtr", "FastasBuff", " fastAQueue", "fastaaPtr", " fastAChannel", "FastasChannel", "FastaPtr", "fastanContainer", "FastaBuffer", "fastaceBuff", "fastAQueue", "fastacePtr", "fastaceBuffer", " fastaBuff", "fastasChannel", "FastaChannel", " fastaContainer", "fastaaStream", " fastasContainer", "fastasFile", "FastasPtr", "fastanBuff", "fastaStream", "fastaaBuff", "fastasQueue", " fastABuff", "fastanFile", "fastanPtr", "fastaFile", " fastaFile", "fastaaBuffer", " fastABuffer"], "fastaReadState": ["fastaReaderMode", "fastasReaderState", "fastaReadingMode", "fastaFileState", "fastaReaderState", "fastasReaderstate", "fastaReadingstate", "fastaReadstate", "fastaReaderType", "fastaReadingType", "fastaReadingState", "fastasReaderType", "fastaReaderstate", "fastaFileType", "fastasReadType", "fastasReadstate", "fastaReadType", "fastasReadState", "fastaFileMode", "fastasReadMode", "fastasReaderMode", "fastaFilestate", "fastaReadMode"], "nBytes": ["numFrames", "pByte", "oParts", "NByte", "Nbytes", "lenFrames", "lenbytes", "nFiles", "nFrames", "NParts", " nFrames", "lenFiles", "NFiles", "nbytes", "numbytes", "obytes", "lenBytes", "numBytes", " nFiles", " nbytes", "oFiles", "pbytes", "oBytes", "pParts", " nParts", "nByte", "nParts", "numFiles", " nByte", "pBytes", "NBytes"]}}
{"id1": "19944975", "id2": "4599372", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["saveConfig", "writeConfig", " writeConfig", " writeReport", "writeReport", "WriteReport", "WriteConfiguration", "WriteSection", " writeSection", "saveConfiguration", "saveSection", "saveReport", "WriteConfig", "writeSection"], "out": ["err", "pool", "resource", "base", "o", "temp", "prefix", "this", "inner", "flush", "w", "write", "plain", "project", "at", "obj", "window", "exp", "exec", "filename", "output", "OUT", "password", "writer", "conn", "list", "object", "key", "sync", "scope", "string", "c", "IN", "external", "again", "outs", "path", "m", "line", "io", "Out", "client", "xml", "report", "name", "init", "inas", "ext", "dump", "server", "user", "file", "ex", "reader", "res", "lib", "connection", "config", "parent"], "url": ["image", "URL", "base", "resource", "service", "feed", "stream", "Url", "open", "channel", "http", "l", "b", "api", "conn", "object", "page", "string", "r", "path", "io", "rel", "org", "uri", "xml", "location", "ssl", "server", "data", "file", "ll", "ob", "sl", "connection", "config", "source", "web", "f", "address"], "in": ["ini", "err", "kin", "resource", "login", "serv", "stream", "gin", "inner", "inn", "input", "In", "inc", "cms", "bin", "b", "conn", "c", "pin", "r", "IN", "again", "source", "nin", "cin", "min", "ins", "is", "xml", "as", "lin", "socket", "inas", "ssl", "a", "inside", "ac", "data", "rin", "isin", "file", "id", "i", "reader", "win", "n", "din", "f", "copy", "s"]}}
{"id1": "4398382", "id2": "12171364", "code1": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "code2": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "label": 0, "substitutes": {"digest": ["Digse", "mdested", "mdests", "mdest", "encse", "encester", "digester", "generests", " digse", " digests", "Digester", "generester", "generested", "digests", "digress", " digress", "mdester", "Digress", "encest", "encress", "digested", "generest", " digested", "digse", "Digest", " digester"], "algorithm": ["malgebra", "alignment", "malignment", " algebra", "algo", "aloding", "Alignment", "aroding", " algo", "algebra", "Algebra", "challenge", "Algo", "argebra", " alenge", "challgo", "argorithm", "alenge", "Algorithm", "malgorithm", "Alenge", "challgebra", "maloding", "arignment", "challgorithm", "Aloding"], "text": ["image", "letter", "feed", "config", "content", "sequence", "format", "input", "pattern", "message", "output", "password", "bytes", "object", "struct", "string", "txt", "code", "TEXT", "buffer", "Text", "token", "path", "attribute", "secret", "length", "name", "test", "ext", "word", "data", "username", "str", "value", "connection", "source", "url", "address"], "mDigest": ["mGest", " mGester", "mSignEST", "mGast", "MDiger", "amPostest", "mDester", "MDigEST", "MDigest", " mGge", "amPostested", "mDenge", "mDesigngest", "mDiggest", "mSignast", "mDEST", "mDgest", "mCodener", "mSignge", "mSignest", "mDer", "mGge", "MDigenge", "mDesignest", "mPostested", "mdiger", " mGast", " mDigast", "mdigener", "mDesigner", "mSignester", "MDer", "mDest", "mPostener", "mCodest", " mDigester", "MDester", "MDgest", "mEncge", "mDigener", "mDesignester", "amDigested", "mPostest", "mdigester", "mSignenge", "mDigester", "mDigenge", "mDiger", "mEncast", "mGester", "MDiggest", "mdiggest", "amDigest", " mGest", "MDest", "mDigEST", "mDigast", "mDigge", "mEncest", " mDigge", "mdigested", "mCodested", "mEncester", "mdigest", "mDigested", "amDigener", "amPostener", "MDigester"], "raw": ["image", "Raw", "enc", "feed", "hex", "content", "input", "json", "none", "serial", "message", "output", "full", "null", "array", "buf", "orig", "initial", "buffer", "original", "wrap", "result", "container", "row", "response", "unsigned", "clean", "internal", "data", "binary", "RAW", "instance", "default", "partial", "source"], "encoder": ["decoding", "deccode", "enccode", "Encoding", "eccode", " encoded", "ecoding", " encoding", "encoded", "Encoded", "encoding", "Encoder", "ecoded", "ecoder", "decode", "ecode", "encode", "enoder", "decoder", " encode", "enode", "Encode", "enoding"]}}
{"id1": "22536033", "id2": "1097147", "code1": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"setPayload": ["setPayContent", "parsePayContent", "parseShiploads", "parseShipLoad", "parsePayload", "setShipload", "setShipContent", "setMessageContent", "setWorkLoad", "parseShipload", "parsePayloads", "setWorkloads", "setMessageload", "setMessageLoad", "setPayloads", " setPayloads", "setRawload", " setPayLoad", "setPayLoad", "setShipLoad", " setPayContent", "setWorkContent", "setWorkload", "setShiploads", "parsePayLoad", "parseShipContent", "setRawloads", "setRawLoad", "setMessageloads", "setRawContent"], "fos": ["cfoc", "fics", "bos", "cfics", "cfis", "Foc", " fics", "bics", "Fos", "Fis", "cfos", "boc", "bis", "Fics"], "fis": ["fics", " fIS", "foric", "eIS", " fib", "Foc", "forics", "fib", "eis", "Fic", "forib", " fics", "eoc", "Fis", "fIS", "Fib", "eic", "foris", "Fics", "FIS"], "fic": ["fik", "cfoc", "infik", "fics", "ufoc", "fac", "firc", "ufic", "ufos", "fci", "cfics", "ufik", "Fik", "Foc", "elfik", " firc", "cfac", "cfic", "Fic", " fics", "infci", "Fos", "infics", "elfci", "cfirc", " fik", "infic", " fac", "Fci", "Fac", "Fics", "elfics", "elfic", "Firc"], "foc": ["infocon", "fac", " focol", "Foca", " fisc", "fisc", "tic", " froc", "Foc", "troc", "Froc", "froc", "infos", "foca", "Fic", "infoc", "Fos", "focon", "Focon", "infocol", " foca", "infic", " fac", "toca", "Fac", "infac", "toc", "infisc", "Focol", "Fisc", " focon", "focol"], "Index": ["Number", "index", "Num", "Content", "Width", "Link", "Path", "Stage", "Pull", "Body", "Client", "Loop", "Url", "Input", "Offset", "Length", "Value", " index", "Section", "Loc", "Entry", "Label", "Connection", "Order", "Insert", "Instance", "Version", "Array", "First", "Counter", "Row", "Depth", "Pos", "ID", "Code", "Start", "Position", "x", "Mass", "Weight", "Dim", "Len", "Exp", "Rank", "Element", "Flag", "X", "Page", "Level", "Size", "Header", "Location", "Count", "Interest", "Found", "Key", "Inf", "Address", "I"]}}
{"id1": "18891988", "id2": "12172485", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"getFile": ["getString", "loadString", "downloadString", "getFilename", "loadFilename", "GetFile", "loadfile", "getfile", "GetFilename", "downloadfile", "Getfile", "loadFile", "downloadFile", "downloadFilename", "GetString"], "serviceName": ["ServiceName", "ServicePath", "packagePath", "ServiceUrl", " serviceUrl", "packageUrl", "servicename", "serviceUrl", "projectPath", "ServiceType", " servicePath", " servicename", "servicePath", "projectName", "packagename", "serviceType", "packageName", " serviceType", "Servicename", "projectType", "projectUrl"], "wsdlLocation": ["wslDirectory", "awslLocation", "awsdlFile", "wsdlFolder", "wllFolder", "awslFile", "wdlAddress", "wsdlFile", "wsllUrl", "wdlDirectory", "awslDirectory", "wsllLocation", "wssdFolder", "wslUrl", "wslFile", "wdlFolder", "wsDLFile", "wslLocation", "wsdlUrl", "wsDLUrl", "wsllAddress", "wsDLDirectory", "awsdlLocation", "wddlFile", "wslFolder", "awsdlUrl", "wsslFolder", "wsslAddress", "wsllFolder", "wssdAddress", "wddlLocation", "awsdlDirectory", "wllLocation", "wdlFile", "wslpFolder", "wsdlDirectory", "wslpDirectory", "wllAddress", "wllFile", "wdlLocation", "wsllFile", "wsdlAddress", "wddlFolder", "wssdFile", "wsslFile", "wsDLLocation", "wsllDirectory", "wslpLocation", "wslpFile", "awslUrl", "wsslLocation", "wddlDirectory", "wssdLocation"], "endpoint": ["enpoint", "startpoint", " endocol", "endpointer", "ENDination", "Endination", "ENDpoint", "Endpoints", "Endpoint", "enPoint", "ENDpoints", " endword", "endspo", "endpoints", "startpointer", " endpo", "endaddress", "enination", "endocol", "Endpo", "startPoint", "endword", "Endocol", "endpo", "endPoint", " endpointer", "endination", "enaddress", "startaddress", "enpointer", "ENDPoint", "enpoints", "Endword", "EndPoint", " endPoint", "endsword", " endaddress", "endspoint", "endsocol"], "fileLocation": [" fileUrl", "FileURI", "FILELocation", " fileDirectory", "FileUrl", "FileLocation", "FileDirectory", " fileURI", "fileURI", "FILEDirectory", "fileDirectory", "fileUrl", "FILEUrl", "FILEURI"], "tempDir": ["tmpVer", "TempPath", "TempDir", " tempPath", "tmpDirectory", "TempDirectory", " temporaryVer", "tmpdir", " tempVer", "tmpDir", "tempdir", " tempDirectory", "tempVer", "Tempdir", "tempDirectory", "tempPath", "tmpPath", " temporaryDirectory", " tempdir", " temporaryDir", " temporaryPath"], "url": ["image", "log", "URL", "service", "base", "www", "stream", "coll", "ul", "download", "Url", "open", "ls", "channel", "http", "l", "conn", "string", "path", "fl", "source", "io", "uri", "pull", "client", "ur", "socket", "ssl", "server", "file", "ll", "el", "sl", "contact", "connection", "config", "host", "web", "f", "address"], "WSDLFile": ["WSDlfile", "WDDlSourceFile", "WSDELFile", "WSDDLSourceFile", "WSDELFiles", "WDDLPath", "WINDELFiles", "WSDLLBase", "WSDDLPath", "WSDlSourceFile", "WINDELFile", "WINDLFile", "WSDDLFiles", "WDDLFolder", "WSDlFolder", "WSDLBase", "WINDELPath", "WSDLFolder", "WSDlFile", "WSDDLFile", "WDDLFile", "WSDDLfile", "WSDLfile", "WSDELFolder", "WDDlPath", "WDDLSourceFile", "WDDLBase", "WSDLLFolder", "WINDLFiles", "WDDLfile", "WSDLFiles", "WSDELPath", "WDDlBase", "WSDDLBase", "WSDLLFiles", "WSDLLfile", "WSDLSourceFile", "WDDlfile", "WDDlFile", "WSDLLFile", "WSDLLPath", "WSDDLFolder", "WINDLFolder", "WDDlFolder", "WSDlBase", "WSDLPath", "WSDLLSourceFile", "WINDELFolder", "WSDlPath", "WINDLPath"], "tmpWSDLFile": ["tmpWSDLLUrl", "tmpWDDELFile", "tmpWSDlFile", "tmpWDDlUrl", "tmpWSDLFolder", "tmpWSDLLocation", "tmpWSDlFiles", "tmpWSDDLLocation", "tmpWSDLFiles", "tmpWSDLLFiles", "tmpWSDLLFolder", "tmpWDDLUrl", "tmpWDDlFiles", "tmpWSDlLocation", "tmpWSDDLUrl", "tmpWDDLFolder", "tmpWDDELLocation", "tmpWSDDLFile", "tmpWDDLLocation", "tmpWSDLLFile", "tmpWSDELLocation", "tmpWSDELFolder", "tmpWSDDLFiles", "tmpWDDELFiles", "tmpWDDlFolder", "tmpWSDELFile", "tmpWDDLFiles", "tmpWSDELFiles", "tmpWDDELUrl", "tmpWSDlFolder", "tmpWDDlFile", "tmpWSDLUrl", "tmpWSDELUrl", "tmpWSDlUrl", "tmpWDDLFile"], "inputFile": ["tempFile", " inputFiles", "tempPlace", "inputBuffer", "InputUrl", "tempfile", "InputPage", "inputBase", " inputUrl", "inputfile", "inputFactory", "requestfile", "requestFiles", "inFile", "InputFiles", "inputStream", "inputPlace", "InputFile", "outputDir", " inputStream", " inputDir", "inputDir", " inputPlace", "tempBuffer", "inPage", " inputfile", "inputFiles", " inputPage", "inputUrl", "tempPage", "inputPage", "InputBuffer", "InputDir", " inputFactory", "requestFile", "InputBase", " inputBase", "tempFactory", "tempBase", "outputFiles", "outputfile", "requestStream", "InputStream", "inDir", "InputFactory", "infile", "InputPlace", "tempUrl", " inputBuffer", "Inputfile", "outputFile"], "tmpFile": ["tempFile", "tmpFiles", "uploadDocument", "tempDocument", "TempPage", "tmpDirectory", "inputStream", "TempDirectory", " tmpPage", "inputDocument", " tmpFiles", "uploadStream", " tmpDirectory", "inputFiles", "uploadFiles", "tempFiles", "tempPage", "TempFile", "tempDirectory", "tempStream", "tmpStream", "uploadFile", "TempFiles", "tmpPage"], "in": ["image", "login", "impl", "inner", "inn", "gin", "input", "In", "up", "l", "bin", "conn", "c", "pin", "IN", "r", "again", "p", "source", "client", "ins", "is", "lin", "init", "ssl", "data", "file", "on", "id", "lock", "reader", "win", "connection", "m", "din", "f", "socket", "inc"], "out": ["image", "err", "log", "conv", "o", "outer", "can", "inner", "to", "input", "net", "In", "channel", "up", "group", "cache", "sync", "output", "OUT", "bin", "writer", "conn", "ch", "c", "IN", "again", "outs", "source", "line", "part", "io", "Out", "client", "name", "co", "server", "on", "file", "error", "timeout", "connection", "inc", "parent", "conf", "socket", "copy"], "con": ["kin", "com", "conv", "can", "inner", "gin", "plain", "nc", "open", "channel", "ctrl", "fc", "sync", "rec", "ch", "conn", "un", "CON", "ran", "c", "IN", "rc", "en", "client", "Con", "ins", "close", "cm", "ssl", "co", "thin", "cn", "connect", "Conn", "win", "bc", "uc", "connection", "inc", "conf", "socket"], "fileLength": ["Filelength", "FileWidth", "fileSize", "channelLength", "filelength", "channelWidth", "contentlength", " fileWidth", " fileSize", "contentLength", "channelLen", "contentSize", " filelength", " fileLen", "fileLen", "channelSize", "FileSize", "contentLen", "FileLen", "FileLength", "fileWidth"], "channelIn": ["connectionConn", "channelIN", " channelIN", "ChannelIN", "resourcein", "channelin", "resourceIn", "characterOut", "ChannelConn", "ChannelIn", " channelin", "connectionOut", "characterIN", "ChannelOut", "Channelin", " channelConn", "resourceIN", "characterIn", "resourceOut", "channelConn", "connectionIn", "characterin", "connectionin"], "channelOut": [" channelOutput", "chanIn", "ChannelOutside", "canOut", "connectionOutput", "connectionOutside", "ChannelIn", "connectionOut", "channelout", "Channelout", "canIn", "ChannelOut", "chanout", " channelout", "channelOutside", "channelOUT", "connectionout", "ChannelOUT", "canOUT", "connectionIn", "canOutside", "chanOUT", "channelOutput", "ChannelOutput", "chanOut", "chanOutside"], "tmpDocument": ["newDocument", "tmpdocument", "tempFile", "mpFile", "tempDocument", "tmpNode", "mpDoc", "tmDocument", "mpNode", "tempContent", " tmpContent", "tmFile", "tmpContent", "tempDoc", " tmpdocument", "newContent", " tmpDoc", " tmpNode", "newdocument", "newFile", "tmpDoc", "tmNode", "tempNode", "tempdocument", "tmdocument", "mpDocument"], "nl1": ["klFirst", "jlone", "klone", "nlone", "ln1", "NL0", "nn11", "nn0", "kl5", "jlFirst", "ln11", "jl1", "arl5", "nl0", "nn2", "nn1", "nl2", "arl1", "nl6", "nl5", "arlone", "NL2", "dl0", "nlFirst", "NL1", "dl1", "nn6", "kl1", "NL11", "ln2", "ln6", "arlFirst", "nl11", "NL6", "jl5", "dl2"], "i": ["ini", "z", "mi", "index", "j", "o", "oi", "chi", "yi", "uli", "hi", "phi", "ii", "ix", "fi", "slice", "mu", "l", "b", "info", "ui", "ri", "pi", "gi", "abi", "d", "li", "ci", "p", "ie", "part", "multi", "si", "ni", "xi", "uri", "bi", "v", "io", "ai", "ji", "eni", "y", "it", "ip", "qi", "ti", "id", "e", "iu", "f", "u", "n", "di", "m", "I"], "node1": ["n1", " node2", "nodeOne", "package1", "packageone", "Node0", "n0", "nodeone", "NodeOne", "shape1", " nodeOne", "Node2", "package91", "shape91", "node91", "node2", " nodeone", "n2", "layerOne", " node91", "Node91", "layer91", "node0", "layer1", "nOne", "layer2", " node0", "shapeone", "packageOne", "shapeOne", "Node1"], "tmpOut": ["tempWriter", "tempFile", " tmpOUT", "vmOUT", "tmpout", "cacheIn", "ptyIn", "tmpOutput", "ptyOutput", "txtOut", " tmpout", "tempOutput", "vmIn", "vmOut", "ptyout", "tempOUT", " tmpWriter", "txtWriter", "ptyOut", "tmpIn", " tmpIn", "cacheFile", "tempout", "txtout", "tempIn", " tmpOutput", "cacheOut", "tmpOUT", "tempOut", "tmpWriter", "vmout", "txtOutput", "cacheOUT"], "retVal": ["valRet", "retObj", "valObj", "RETval", "retRet", "retval", " retRet", "valVal", "RETRet", " retObj", " retval", "RETVal", "RETObj", "valval"]}}
{"id1": "3958807", "id2": "16590954", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadFbinaryStream", "loadFbinaryInput", "loadBatchFile", "loadBinaryContent", "loadFinaryFile", "loadBInputFile", "loadBInputInput", "loadBinaryFile", "loadBatchContent", "loadBinaryInput", "loadBbinaryInput", "loadFinaryStream", "loadBbinaryStream", "loadBatchInput", "loadBInputContent", "loadFinaryInput", "loadBatchStream", "loadBbinaryFile", "loadFinaryContent", "loadBInputStream", "loadFbinaryContent", "loadFbinaryFile", "loadBbinaryContent"], "streamName": ["streamname", "channelKey", "fileName", "fileType", "filePath", "filename", "resourcePath", "StreamPath", " streamname", "streamType", "Streamname", "channelName", "streamPath", "resourceType", "resourceName", "channelPath", " streamType", "streamKey", " streamKey", " streamPath", "StreamName", "resourcename", "fileKey"], "streamToLoad": ["channeltoload", "channelToLoad", "channelToload", "streamtoUpload", "streamWillUse", "objectToUse", " streamToUse", "streamTOLoad", "streamTOAdd", "streamToload", "streamWillUpload", "streamtoload", "streamtoRead", "streamtoLoad", "streamWithAdd", "streamToRead", "streamToAdd", "objectTOUse", "streamWithRead", "objectTOUpload", "objectToLoad", " streamtoRead", " streamtoUse", "streamTOUse", "streamtoAdd", " streamToAdd", "objectTOLoad", "streamWillLoad", "objectTORead", "objectToRead", " streamtoAdd", "streamTORead", "channeltoLoad", "streamtoUse", "channeltoAdd", "streamWillAdd", " streamtoLoad", "channelToAdd", "streamTOUpload", "streamWillRead", " streamToRead", "streamToUpload", "streamWithLoad", "streamTOload", "streamWithUse", "objectToUpload", "streamToUse"], "sz": ["sze", "ssze", "szes", " szip", "szi", "imszes", "szip", " sze", "ssiz", "wszip", "psze", "pszi", " szi", "imsze", "pszip", "siz", " siz", "wsz", "sszes", "wsze", "imsiz", "ssz", "psz", " szes", "imsz", "wszi"], "req": ["err", "q", "rx", "fr", "serv", "download", "input", "ref", "http", "src", "rec", "respond", "conn", "cb", "def", "r", "wx", "ok", "sem", "Request", "require", "progress", "rr", "inv", "proc", "rh", "response", "client", "Resp", "report", "request", "qt", "f", "rss", "rw", "pkg", "res", "ctx", "requ", "exec", "obj"], "resp": ["re", "err", "body", "html", "wb", "circ", "serv", "Response", "download", "rep", "ref", "http", "zip", "rev", "rec", "output", "respond", "conn", "bb", "jp", "par", "page", "remote", "api", "sp", "wp", "wx", "esp", "cmp", "cook", "ret", "proc", "df", "rh", "response", "prev", "client", "fp", "Resp", "comm", "report", "request", "rem", "server", "rup", "e", "rss", "res", "ctx", "rel", "exec", "reply", "obj"], "out": ["log", "base", "o", "in", "pool", "serv", "gz", "ops", "zip", "cache", "output", "OUT", "b", "bin", "conn", "auto", "object", "ws", "null", "buf", "buffer", "again", "outs", "op", "p", "boot", "io", "os", "response", "img", "Out", "tmp", "co", "data", "fn", "binary", "i", "res", "default", "aos", "exec", "copy", "s"], "bos": ["bo", "pins", "lol", "zos", "osa", "zb", "bot", "mis", "osi", "cro", "bas", "bin", "bb", "obo", "ubis", "obs", "biz", "zo", "abi", "bes", "bro", "rob", "boot", "flo", "ros", "obb", "os", "obos", "bi", "bott", "bis", "ko", "oops", "las", "bs", "bare", "bps", "ob", "lo", "ios", "oos", "fits", "bc", "bh", "los", "aos"]}}
{"id1": "16557837", "id2": "8069594", "code1": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFromTo": ["transferFromWith", "copyDirFrom", "transferFromFile", "copyFromWith", "copyFileFile", "copyFromFrom", "copyDirTo", "transferFromFrom", "copyfromTo", "copyDirWith", "copyDirFile", "copyfromFrom", "transferfromFrom", "copyfromFile", "transferfromWith", "copyFileFrom", "copyFileWith", "transferfromFile", "transferFromTo", "copyFileTo", "transferfromTo", "copyFromFile", "copyfromWith"], "srcFile": ["sourceClass", "destSourceFile", " srcPath", " srcSourceFile", "srcDir", " srcClass", "rcFiles", " srcPage", "rcFile", "sourceDir", "srcFiles", "rcPath", "sourcePath", "destfile", "sourceSourceFile", "destDir", " srcFiles", "rcDir", " srcDir", "destPage", "rcSourceFile", "sourceFile", " srcfile", "rcPage", "srcPath", "sourcefile", "srcSourceFile", "destFiles", "srcfile", "rcfile", "srcClass", "destClass", "srcPage", "sourceFiles"], "destFile": ["southFile", " destinationDir", "DestFile", "destSourceFile", "srcDir", "southDir", "targetPath", " destinationFiles", "destFilename", " destinationFile", "destroyFilename", "destPlace", "southFilename", "wbFile", "defaultDir", "DestPath", "destDir", "southPlace", "destfile", " destFilename", " destFiles", "defaultfile", "wbFiles", " destinationFine", " destfile", "destPage", "defaultFiles", "DestFiles", " destPlace", " destPath", "wbFilename", " destinationPage", "destroyPage", "srcPlace", " destDir", "targetFile", "destFine", " destPage", " destinationFilename", "destroyFine", "destroyFile", "destFiles", "targetFiles", "DestSourceFile", "DestDir", "destPath", " destFine", "defaultFile", "srcFilename", "Destfile", "wbSourceFile", " destinationfile", " destSourceFile", "targetDir", "DestFilename"], "in": ["ini", "err", "image", "index", "o", "login", "inner", "inn", "input", "In", "channel", "b", "bin", "url", "c", "pin", "IN", "r", "again", "ci", "p", "source", "part", "nin", "io", "cin", "x", "min", "pull", "Out", "ins", "is", "as", "lin", "init", "inside", "ac", "co", "h", "con", "id", "rin", "isin", "file", "i", "reader", "win", "n", "connection", "like", "din", "f", "socket", "inc"], "out": ["resource", "json", "In", "channel", "window", "group", "list", "ger", "page", "c", "state", "again", "query", "job", "name", "file", "call", "comment", "lib", "connection", "source", "parent", "ou", "log", "o", "cmd", "outer", "point", "this", "to", "cli", "write", "input", "cache", "sync", "output", "OUT", "bin", "conn", "auto", "string", "code", "session", "outs", "note", "doc", "io", "Out", "co", "sys", "server", "user", "down", "error", "no", "win", "copy", "err", "base", "prefix", "inner", "pre", "post", "extra", "IN", "line", "diff", "client", "off", "ext", "term", "dump", "gen", "lock", "ex", "inc", "exec", "socket", "obj", "image", "raw", "net", "up", "key", "writer", "store", "part", "ico", "url"], "fis": ["flios", "frris", "fios", "flis", "pis", "hi", " fIs", " foss", " fris", "cfris", "gais", "pIs", "fi", " fi", "hios", "lis", "fross", "lais", "cfis", "pos", "fais", "gi", "hos", "FIs", "pris", "li", "fIs", "flos", "his", "Fos", "Fis", "gos", " fais", "fris", "cfoss", "cfos", "cfios", "fli", "cfi", "fros", "foss", "gis", "los", "Fris"], "fos": ["flout", "fo", "eos", "eoss", "fics", "pis", "boes", " fout", " foes", " fo", "po", " fose", "bos", "lis", "tos", "toes", "pos", "infoss", "infos", "tics", "lose", "fose", "gose", "loss", "eis", "poes", "infose", "flo", "flos", "paos", " faos", "flose", "Foes", "faos", "gout", "foes", "bics", " fics", "Fos", "Fis", "gos", "eose", "fout", "bis", "infis", "Faos", "go", "tis", "foss", "Fo", "los"], "srcModified": ["srcXined", "srcVerified", "sourceModify", "srcmodIFIED", "srcModed", "sourceModification", "srcMinIFIED", "sourceMinification", "srcXed", "srcXification", "srcVerification", "srcXified", "srcmodification", " srcModed", "srcMinification", "srcModification", "srcModined", "sourceMinIFIED", " srcModIFIED", "srcModify", "srcMetressed", "srcVerined", "sourceMinified", "srcMetification", "sourceMinify", "srcVered", "sourceModified", "sourceModIFIED", "srcMinify", "srcmodified", " srcModressed", "srcMinified", "srcModIFIED", "srcmodify", "srcMetified", " srcModification", "srcModressed", "srcmodressed", "srcMetIFIED", " srcModined"]}}
{"id1": "14773782", "id2": "9857412", "code1": "    public void testJPEGRaster() throws MalformedURLException, IOException {\n        System.out.println(\"JPEGCodec RasterImage:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            JPEGImageDecoder dec = JPEGCodec.createJPEGDecoder(istream);\n            Raster raster = dec.decodeAsRaster();\n            int width = raster.getWidth();\n            int height = raster.getHeight();\n            istream.close();\n            System.out.println(\"w: \" + width + \" - h: \" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    @Override\n    public void writeData(byte[] data, byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        OutputStream os = urlc.getOutputStream();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        byte[] buffer = new byte[1024];\n        int br;\n        while ((br = bis.read(buffer)) > 0) {\n            os.write(buffer, 0, br);\n            if (!transferMetaData) {\n                transferredBytesNum += br;\n                elapsedTime = System.currentTimeMillis() - startTime;\n                fireOnProgressEvent(transferredBytesNum, elapsedTime);\n            }\n        }\n        bis.close();\n        os.close();\n    }\n", "label": 0, "substitutes": {"testJPEGRaster": [" testJPEGWatter", " testJPPGRasters", " testJPEGRotasters", " testJPEGRotast", " testJPPGrast", " testJPEGrasters", " testJPEGRotatter", " testJPEGratter", " testJPEGRasters", " testJPPGrasters", " testJPEGRast", " testJPPGraster", " testJPEGRatter", " testJPEGWasters", " testJPEGraster", " testJPEGrast", " testJPPGratter", " testJPPGRaster", " testJPEGWast", " testJPEGRotaster", " testJPPGRatter", " testJPEGWaster", " testJPPGRast"], "IOException": ["IPError", " IOError", "IPception", "OSception", "IOError", "OSException", "IOception", "OSError", "IPException", " IOception"], "start": ["base", "in", "end", "offset", "step", "pre", "art", "order", "load", "use", "info", "speed", "style", "left", "set", "scale", "pos", "starting", "from", "stage", "shift", "Start", "started", "diff", "ish", "min", "first", "length", "size", "init", "sum", "id", "data", "date", "get", "delay", "time", "source", "f"], "i": ["ini", "image", "mi", "index", "j", "oi", "yi", "hi", "inner", "phi", "ii", "ix", "fi", "slice", "key", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "abi", "li", "ci", "p", "ie", "uni", "si", "xi", "ni", "io", "multi", "v", "eni", "ai", "bi", "x", "ip", "qi", "ti", "id", "e", "iu", "f", "u", "di", "m", "I", "zi"], "url": ["image", "URL", "base", "in", "resource", "feed", "www", "download", "Url", "ls", "hub", "channel", "ref", "http", "src", "filename", "l", "href", "page", "string", "route", "album", "path", "fb", "source", "org", "uri", "img", "ur", "name", "id", "file", "data", "sl", "connection", "config", "location", "web", "f", "address"], "istream": ["ISTrib", "instep", "ISTstream", "stream", "step", "irstream", "istsore", "irstound", "ishream", "isep", "istsream", "istestream", "istep", "istsREAM", "istore", "instead", "stead", "istrib", "isagram", "stagram", "isead", "istound", "irstREAM", "ISTream", "istsep", "isream", "istsound", "isteream", "istsstream", "ishREAM", "iststream", "ISTep", "ishound", "instagram", "instream", "ishore", "istREAM", "irstore", "isterib", "isteep", "istagram", "istsrib", "istead"], "dec": ["enc", "de", " DEC", "des", "ode", "fr", "func", "vec", "dc", "cam", "draw", "dig", "exp", "sec", "rev", "rec", "DEC", "da", " decode", "c", "code", "r", "der", "oder", "next", "doc", "div", " Dec", "deg", "out", "img", "decl", "ra", "dir", "director", "neg", "data", "valid", "desc", "ec", "inc", "Dec", "s"], "raster": ["Raster", "arascal", "Roder", "rap", " rascal", "hatter", "araster", "Rap", "ratter", "eratter", "Rascal", "hap", "erasters", "eraster", "hasters", " rasters", "rascal", "rasters", " rap", "haster", " roder", "Ratter", "Rasters", "roder", "eroder", " ratter", "aroder", "arasters"], "width": ["z", "image", "flow", "ize", "dim", "wb", "shape", "Width", "density", "w", "duration", "write", "window", "age", "fw", "widget", "lon", "area", "full", "wd", "page", "left", "style", "scale", "wa", "d", "work", "en", "p", "gender", "frame", "x", "min", "img", "wn", "length", "wm", "size", "h", "layout", "weight", "west", "value", "n", "f"], "height": ["th", "dim", "right", "shape", "depth", "density", "deep", "w", "hd", "head", "window", "stroke", "dy", "pad", "rows", "padding", "work", "d", "k", "build", "v", "x", "rh", "img", "y", "length", "ady", "size", "crop", "thin", "h", "volume", "han", "angle", "inches", "Height", "max"], "stop": ["hide", "address", "shape", "change", "end", "step", "check", "ops", "skip", "output", "b", "speed", "hop", "page", "fill", "set", "summary", "cut", "exit", "drop", "clip", "sort", "remove", "snap", "sleep", "Stop", "number", "sign", "rest", "trip", "pop", "block", "pause", "keep", "spot", "roll", "limit", "comment", "zero", "wait", "delay", "save"]}}
{"id1": "8430178", "id2": "19109981", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", "transferFile", "CopyFile", "transferPath", " copyfile", "Copyfile", " copyPath", "copyfile", "copyFiles", "copyPath", "CopyPath", "CopyFiles"], "source_name": ["Source_file", "source_key", "source_uri", "source_Name", "src_name", "src_file", "source_names", "sourceCname", "sourceNtype", "source_size", "source_data", "Source_data", "src_alias", "source_alias", "sourceNname", " source_Name", "Source_name", "source_type", "src_uri", "sourceNalias", "src_size", "sourceNfile", "source_path", "sourceCfile", "sourceCtype", "sourceCalias", " source_path", " source_key", " source_names", "src_type"], "dest_name": ["dest_resource", "destappnames", "dest_id", " dest_path", "destFilename", "destFilenamed", " destination_resource", "dest_none", "dest_word", " destinationFresource", " dest_none", "destflabel", "source_Name", "destRdefinition", "target_names", "destJnames", "destPmodel", "destPtype", "source_names", "dest_definition", "Dest_id", "destPpath", "destPword", "target_type", "destapptype", " dest_type", "dest_names", " dest_names", "destRName", " dest_Name", " destinationFpath", "destRpath", "destRname", " destination_name", "dest_label", "destJname", "destJword", " dest_file", " destination_path", "dest_named", "destFname", " dest_named", "Dest_name", "destFpath", "target_model", "destJName", "destFilelabel", "destfnamed", "dest_model", " dest_word", "destffile", " destinationFinfo", "source_path", " dest_label", " dest_definition", "destPnames", "destPname", "destFilefile", "dest_file", "target_name", "Dest_path", "dest_Name", "dest_type", " destinationFname", "destappname", "dest_path", "destFresource", "dest_info", "destfname", "Dest_Name", "destPName", "destFinfo", "destappmodel", " destination_info"], "source_file": ["source_url", "source_File", "ource_line", "sourcefname", "src_name", "source_class", "src_file", " source_class", "source_files", "source_stream", "source__name", "source__class", "sourceffile", "source__base", "source_base", " source_url", "sourcefFile", "source__file", "ource_file", " source_base", " source_cache", "ource_files", " source_File", "src_files", " source_files", "src_stream", "source_line", "source_cache", "sourcefurl", "ource_name"], "destination_file": ["destention_name", "destination_files", "destination_page", "destination2file", "destation_name", "destention4file", "destinate_files", "destation_folder", "destination2name", "destinationablefile", "destination_path", "destention_source", "destination4file", "destinate_base", "destination4source", "destinationablebase", "destention_path", "destation_function", "destination_folder", "destination_name", "destination_source", "destention_file", "destention4source", "destation_file", "destinationablefiles", "destention4path", "destination2source", "destinate_file", "destination4path", "destinationablepage", "destention4name", "destation_files", "destination_function", "destination4name", "destinate_page", "destination2path", "destination_base"], "source": ["image", "resources", "unit", "slave", "ize", "service", "resource", "SOURCE", "index", "site", "storage", "view", "stream", "Source", "current", "inner", "input", "open", "target", "master", "src", "cache", "load", "local", "slice", "output", "remote", "object", "scope", "ources", "via", "class", "from", "spec", "core", "single", "ource", "result", "uri", "dest", "diff", "client", "secure", "ite", "start", "name", "proxy", "search", "server", "file", "reference", "reader", "get", "connection", "config", "parent", "copy"], "destination": ["Destension", "destension", "foreigninated", "constining", "targetinate", "destinator", " destina", "targetination", "destribution", "Destination", "variinator", " destinator", "testribution", "foreigninator", "Destinated", "destina", " destining", "validination", "dependinate", "variinate", "coordination", "foreigninate", "constribution", "descinated", "testinated", "variination", "Destinator", "identination", "validinator", "testinator", "variinated", "identribution", "identinated", "Destining", "coordinated", "dependination", "targetinator", "destinate", "destinated", "testination", "descination", "constination", "coordension", "identina", "dependinator", "foreignination", "constinator", "Destina", " destinated", "coordinator", "dependinated", "Destribution", " destribution", "descinator", "destining", "validinate", "targetinated", "descension", "validinated"], "buffer": ["image", "pool", "temp", "flush", "sequence", "input", "window", "channel", "text", "cache", "queue", "writer", "bin", "buf", "buff", "Buffer", "padding", "uffer", "block", "binary", "transfer", "limit", "reader", "timeout", "iter", "batch", "memory", "header"], "bytes_read": ["bytesUnRead", "Bytes_set", "bytesUnread", "bytes_set", "bytesUnset", "Bytes_found", "bytesUnfound", "bytes_found", "Bytes_read", "Bytes_Read", "bytes_Read"], "in": ["ini", "image", "re", "log", "resource", "login", "temp", "serv", "stream", "inner", "current", "inn", "val", "input", "din", "In", "fe", "rec", "l", "bin", "b", "read", "r", "IN", "session", "again", "token", "path", "p", "doc", "line", "nin", "container", "min", "out", "ins", "is", "as", "ssl", "a", "request", "con", "h", "data", "file", "id", "lock", "reader", "get", "n", "or", "connection", "f", "url", "inc", "s"], "response": ["re", "body", "onse", "image", "model", "answer", "resource", "feed", "question", "view", "sequence", "Response", "respons", "json", "version", "reason", "offer", "text", "message", "reset", "output", "api", "respond", "object", "update", "status", "example", "string", "application", "r", "resp", "next", "success", "line", "result", "uri", "su", "report", "received", "request", "server", "data", "true", "error", "description", "value", "res", "location", "reply", "dict", "header"], "parentdir": ["parentDir", "parentdict", "parentfile", "partlib", " parentdirectory", "rootdir", "parentsDir", "partdirectory", "Parentdir", "parentdiff", "hostdirectory", "rootfile", "partfile", " parentdict", " parentfile", " parentlib", "partdir", "parentlib", "parentsfile", "rootdirectory", "parentsdir", "rootlib", "homefile", "parentsdiff", "hostdir", "homeDir", "homediff", " parentDir", " parentdiff", "Parentdirectory", "homedir", "Parentdict", "hostdict", "parentdirectory"]}}
{"id1": "1954410", "id2": "8430178", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doExecute": ["submitexecuteRun", "doExecRun", "submitexecuteute", "doSendApply", "submitexecuteutes", "doSendute", "doExecutes", "submitExecute", "doexecuteRun", "submitExecRun", "doexecuteutes", "doexecuteApply", "doExecApply", "submitexecuteApply", "doSendutes", "doexecuteute", "doSendRun", "submitExecApply", "submitExecutes"], "mapping": ["finding", "minding", "amapping", "fapper", "mapper", " mapper", "amatching", "fapping", "matching", "amapper", "aminding", " matching", " minding", "fatching"], "form": ["flow", "method", "field", "Form", "formation", "feed", "submit", "config", "forms", "format", "transform", "pattern", "post", "object", "page", "builder", "definition", "dom", "control", "command", "xml", "app", "component", "FORM", " forms", "template", "url", "owner"], "request": ["re", "_", "method", "model", "resource", "q", "create", "ware", "submit", "this", "view", "self", "current", "format", "Response", "input", "json", "worker", "req", "message", "add", "queue", "use", "Reply", "object", "QUEST", "Bytes", "application", "Accept", "session", "route", "path", "query", "Request", "hello", "type", "result", "uri", "frame", "pull", "client", "context", "xml", "Upload", "report", "name", "server", "user", "data", "HTTP", "parent", "call", "instance", "s", "reader", "complete", "requ", "url", "address"], "response": ["model", "resource", "view", "Response", "json", "req", "message", "output", "object", "page", "application", "status", "resp", "handler", " responses", "result", "v", "client", "Resp", "xml", "report", "server", "data", " Response", "res", "reply"], "errors": [" calls", " logger", " management", " managers", " changes", " events", " replies", " Messages", " logs", " mess", " streams", " commands", " session", " this", " messaging", "mess", " responses", " payload", " failures", " messenger", " messages", " error", " translations", " status", " flashes", " problems", " updates", " acc", " warnings"], "isMultipart": ["isMultipost", "isMultippart", "isMultiipPart", "isMultippedart", "isMultIPound", "isMultitart", "isMultipated", "isMultitarts", "isMultiarts", "isMultitated", "isMultiIPound", "isMultiIPart", "isMultipound", "isMultiated", "isMultiipart", "isMultipage", "isMultIPart", "isMultiage", "isMultIPost", "isMultompPart", "isMultippedPart", "isMultippedost", "isMultippedound", "isMultIPPart", "isMultiparts", "isMultompound", "isMultitage", "isMultiipound", "isMultippage", "isMultompost", "isMultompart", "isMultipparts", "isMultiIPost", "isMultipPart", "isMultiipost", "isMultiIPPart", "isMultiart", "isMultippated"], "mailInstance": [" emailinstance", "mailManager", "fileManager", " emailInst", " emailInstance", "fileUsage", "mailUsage", "emailInst", " mailManager", "mailinstance", "emailinstance", " mailUsage", " mailinstance", "fileInstance", "fileInst", "emailManager", " mailInst", "mailInst", "emailInstance", " emailUsage", "fileinstance"], "fields": ["archives", "gets", "boxes", "field", "comments", "objects", "posts", "keys", "forms", "types", "locks", "changes", "utils", "input", "flows", "lines", "plugins", "links", "services", "maps", "details", "ments", "packs", "rules", "ids", "properties", "events", "views", "facts", "files", "uploads", "params", "groups", "headers", "rows", "atts", "lists", "cells", "acks", "holders", "checks", "tags", "states", "qs", "users", "members", "models", "features", "pages", "data", "forces", "classes", "loads", "words", "strings", "dates", "parts", "s"], "attachments": ["attachions", "attlements", " attachparts", "suppment", "extions", "exters", "supplements", "achresses", "attment", "attachers", "payresses", "Attachments", "attachps", "payment", " attachment", "attachparts", "payments", "achments", "suppments", "Attachlements", "attachlements", "payparts", "achparts", "attees", "suppees", "Attachps", "attions", "attachment", "extps", "attachresses", "attments", "atters", "achment", "Attachers", "attps", "Attachment", " attachresses", "attachees", "Attachions", "Attachees", "extments"], "items": ["its", "objects", "keys", "types", "locks", "phones", "ops", "children", "lines", "plugins", "links", "orders", "ids", "list", "events", "files", "apps", "groups", "rows", "Items", "lists", "apters", "qs", "ins", "reports", "models", "es", "alls", "ips", "pages", "data", "names", "results", "parts", "ers"], "iter": ["err", "ver", "outer", "end", "walker", "inner", "event", "coll", "ul", "order", "skip", "inter", "edit", "gener", "exp", "zip", "master", "ir", "http", "slice", "list", "finder", "page", "Iter", "li", "er", "itter", "izer", "it", "oper", "loop", "altern", "ip", "ner", "ite", "chain", "cher", "keep", "ter", "former", "file", "ser", "iterator", "el", "Iterator", "ator", "reader", "enter", "i", "loc", "inc", "upper"], "item": ["resource", "temp", "storage", "current", "full", "page", "hop", "element", "next", "result", "it", "layer", "name", "volume", "file", "source", "folder", "service", "slice", "api", "info", "example", "album", "token", "handler", "original", "Item", "issue", "all", "ip", "app", "server", "user", "instance", "reader", "get", "plugin", "base", "other", "inner", "event", "entry", "post", "object", "extra", "update", "atom", "custom", "er", "type", "attribute", "container", "entity", "data", "or", "anything", "obj", "image", "index", "section", "site", "coll", "val", "art", "order", "up", "load", "widget", "area", "more", "li", "missing", "i", "complete", "url"], "aux": ["aw", "lc", "ou", "des", "sub", "packages", "prefix", "aus", "ants", "offs", "abs", "alias", "except", " Aux", "anc", "aff", "ox", "axe", "uf", "extra", "sup", "array", "buf", "amp", "au", " auxiliary", "lang", "cmp", "ras", "etc", "cas", "off", "ups", "ext", "auc", "asc", "union", "data", "ux", "af", "abc", "pkg", "strings", "fax", "uc", "frac", "ru", "aos", "imp"], "part": ["action", "html", "field", "base", "plugin", "section", "change", "point", "step", "val", "po", "format", "pre", "art", "patch", "player", "obj", "group", "ref", "add", "back", "pair", "key", "area", "l", "ch", "b", "full", "object", "list", "info", "fact", "class", "pos", "act", "element", "pi", "join", "p", "type", "and", "diff", "comp", "layer", "block", "start", "but", "name", "joined", "partial", "co", "PART", "word", "component", "data", "user", "file", "on", "id", "instance", "Part", "f", "error", "per", "one", "no", "connection", "parent", " Part", "parts"], "baos": ["abaOs", "baOS", "baoss", " baOS", "BAoss", "bois", "bao", "bais", "boosh", "Bao", "BAos", "BAis", " baoS", "pao", "BAosh", "baot", "boOS", "hao", "BaOs", "Baos", "baosh", " baot", "haos", " bao", "abais", "Bais", "abaosi", "boot", "paos", "paosh", "BAoS", "BAOs", "boos", " bais", "baoS", "BAo", "BaoS", "baOs", "boo", "Baosi", "BAosi", "pais", "paot", "hais", "abaos", " baoss", "haoss", "paOS", "baosi"], "body": ["fee", "html", "resource", "options", "end", "Body", "content", "common", "json", "text", "message", "zip", "output", "shell", "b", "media", "full", "object", "string", "null", "summary", "flash", "params", "headers", "state", "pass", "query", "translation", "type", "parts", "length", "size", "name", "tree", "data", "document", "binary", "port", "description", "comment", "value", "connection", "template", "source", "reply", "url", "header"], "preferencesInstance": ["prefirmsClient", "prefiesInstance", "preffeesinstance", "prefferencesinstance", "prefirmsinstance", "preffeesClient", "prefferencesInstance", "prefiesinstance", "prefiesClient", "prefeesClient", "preffeesInstance", "preferencesinstance", "prefeesInstance", "preferencesClient", "prefirmsInstance", "prefferencesClient", "prefeesinstance"]}}
{"id1": "9099457", "id2": "13207437", "code1": "    public static String hash(String value) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] md5hash = new byte[32];\n            md.update(value.getBytes(\"iso-8859-1\"), 0, value.length());\n            md5hash = md.digest();\n            return Hex.encodeHexString(md5hash);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public Object sendRequestObjectResponse(java.lang.String servletName, java.lang.String request) {\n        String osRoot = OSRoot.getRoot();\n        String fname = \"\";\n        Object retobj = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (myport == null || myport.trim().equals(\"\")) {\n            myport = \"80\";\n        }\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            try {\n                java.io.FileOutputStream pw = new java.io.FileOutputStream(\"log.txt\");\n                pw.write(req1xml.getBytes());\n                pw.flush();\n                pw.close();\n            } catch (Exception exp) {\n                exp.printStackTrace();\n            }\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.io.File f1 = new java.io.File(osRoot + \"/localattachments/Reports\");\n            if (!f1.exists()) f1.mkdirs();\n            java.io.File file = null;\n            if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"application/vnd.oasis.opendocument.text\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".odt\");\n            } else if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"text/html\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".html\");\n            } else {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".xls\");\n            }\n            file = new java.io.File(file.getAbsolutePath());\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(file);\n            int c;\n            while ((c = ios.read()) != -1) fos.write(c);\n            fos.close();\n            ios.close();\n            fname = file.getAbsolutePath();\n            System.out.println(fname);\n            newgen.presentation.component.Utility.getInstance().showBrowser(\"file://\" + fname);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n            javax.swing.JOptionPane.showMessageDialog(null, \"<html>Could not establish connection with the server, <br>Please verify server name/IP adress, <br>Also check if NewGenLib server is running</html>\", \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        }\n        return fname;\n    }\n", "label": 0, "substitutes": {"hash": ["sha", "html", "hex", "check", "format", "match", "text", "key", "replace", "update", "print", "string", "code", "set", "cmp", "build", "number", "mac", "ash", "pack", "Hash", "sum", "dump", "h", "data", "str", "get"], "value": ["image", "this", "content", "val", "format", "input", "json", "entry", "property", "Value", "version", "text", "message", "key", "output", "password", "media", "object", "string", "null", "element", "initial", "buffer", "token", "VALUE", "hello", "type", "v", "number", "response", "values", "xml", "expression", "name", "language", "server", "data", "variable", "document", "description", "database", "source", "address"], "md": ["dd", "nm", "sha", "cmd", "bm", "meta", "metadata", "ma", "amd", " MD", "po", "mm", "mo", "message", "mu", "key", "ms", "wd", "mp", "vd", "code", "git", "d", "mand", "bd", "ad", "pm", "mt", "mg", "mac", "sm", "od", "editor", "cm", "MD", "mod", "pd", "mag", "rm", "dm", "mc", "mem", "mb", "hm", "bf", "m", "rpm", "f"], "md5hash": ["md4hex", "md2copy", "md5hex", "MD6hash", "md4hash", "MD5hex", "md6header", "mand55hash", "mand55Hash", "MD6header", "md4sha", "md4Hash", "mand5Hash", "MD6shadow", "md6shadow", "mddownhash", "md55copy", "MD6sha", "mdlesshash", "mdlessheader", "md6copy", "MD5shadow", "mand5copy", "md2Hash", "md55header", "mdlessHash", "mddownHash", "MD5hash", "md6hash", "MD5header", "md6hex", "md55Hash", "MD6hex", "md6Hash", "md55hash", "MD5Hash", "MD5sha", "mand55copy", "md5header", "md55shadow", "md5Hash", "MD6Hash", "md5copy", "mand5hash", "mddownsha", "md6sha", "md2hash", "md5shadow", "md5sha", "mdlessshadow", "mddownhex"]}}
{"id1": "19584877", "id2": "822452", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeString2File", "encodeFileFromStream", "encodeFileFromString", "encodeStringToStream", "encodeString2Files", "encodeFiletoStream", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFiles", "encodeFiletoFile", "encodeFileFromFiles", "encodeFileFromFile", "encodeString2Stream", "encodeStringToString", "encodeFileToString", "encodeFile2String", "encodeString2String", "encodeFile2File", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFile2Files", "encodeFileToStream"], "infile": [" infilename", "infiles", "Infilename", "outFile", "inputfile", "outfiles", "inFile", "InFile", "inputfilename", " infiles", " infp", "inputFile", "outfilename", "outfp", "Infiles", "inputfiles", "infp", "inputfp", "infilename", "Infile"], "outfile": ["newfolder", "outname", "outFile", " outFile", "outputfp", "outputfilename", " outfilename", "Outname", "outfolder", "outputfolder", " outfp", "Outfolder", "newfile", "newname", " outfolder", "infolder", "newFile", "outfilename", "outfp", "outputfile", "OutFile", "infp", " outname", "infilename", "Outfile"], "in": ["re", "err", "ini", "image", "base", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "vin", "m", "din", "socket", "inc", "s"], "out": ["err", "ou", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "In", "obj", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "outs", "work", "job", "source", "line", "io", "Out", "client", "off", "name", "co", "on", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "count", "cache", "slice", "queue", "b", "bytes", "bb", "null", "buf", "buff", "border", "padding", "fb", "split", "uffer", "type", "result", "len", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "input", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "close", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "model", "method", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "respons", "open", "better", "message", "growth", "modified", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "17724879", "id2": "7372311", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 1, "substitutes": {"getDigest": ["getdigests", "createDigests", "createdigHash", "getdigHash", "getDigests", "getSignest", "getMDests", "createdigester", "createDigester", "createdigests", "getdigester", "createdigest", "getSignHash", "createDigHash", "getDigester", "getDigHash", "getMDest", "getdigest", "getSignester", "getSignests", "getMDHash", "getMDester", "createDigest"], "attribute": ["ident", "image", "argument", "resource", "prefix", "directory", "event", "metadata", "audio", "function", "entry", "property", "message", "pair", "api", "object", "individual", "device", "att", "element", "class", "set", "ribute", "application", "definition", "subject", "route", "node", "type", "uri", "entity", "attr", "layer", "client", "character", "manager", "expression", "Attribute", "name", "operation", "component", "data", "reference", "document", "variable", "username", "instance", "value", "feature", "connection", "config", "plugin", "address"], "digestAlgorithm": ["digestAlgebra", "digestAlgo", "digESTAlger", "digESTAlg", "digesterAlgo", "digestElger", "digestALgebra", "digestalgorithm", "digesterAlgebra", "digestElgorithm", "digestElg", "digestAlgorith", "digESTAlgorithm", "digestalgo", "digESTAlgo", "digesterAlgorith", "digestElgo", "digestALgorith", "digestAlg", "digestalg", "digesterAlgorithm", "digestALgorithm", "digestalger", "digestALgo", "digestAlger", "digestalgebra", "digestalgorith"], "digest": ["Digtest", "dgest", " digtest", "multipluration", "longest", "labester", "diggest", "longester", "DigEST", "labtest", "digester", "diguration", "dester", "digtest", "signger", "Digester", "longested", "labest", "signgest", "dest", "Digested", "multiplest", "Diguration", "multiplEST", "dger", "signest", "signester", "bigester", "biggest", "longEST", "labEST", "multiplester", "digEST", " diguration", " digEST", "digested", " digested", "digger", "Digest", "bigest", "bigger", " digester"], "md": ["dd", "nd", "nm", "mi", "plugin", "cmd", "module", "dev", "meta", "amd", "ma", "metadata", " MD", "ht", "hd", "mm", "um", "po", "arm", "mad", "mo", "cd", "ms", "ld", "mp", "ui", "wd", "cb", "mn", "der", "d", "kg", "bd", "ad", "ds", "doc", "ml", "pm", "df", "mr", "mt", "sm", "mac", "od", "sd", "own", "manager", "editor", "app", "cm", "MD", "mid", "mod", "my", "id", "pd", "mag", "rm", "dm", "mc", "mb", "ng", "di", "m", "db"]}}
{"id1": "310182", "id2": "530882", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"convert": ["oconversion", "CONversion", "oconverting", " deconverted", "CONverting", " deconvert", "conception", "CONception", " deconverting", "unverted", "subversion", "CONverted", "Conception", " deconversion", "oconvert", "unversion", "converted", "unception", "subvert", "conversion", "Convert", "unvert", "Converted", "subverted", "subverting", "converting", "oconverted", "Converting", "Conversion", "CONvert"], "src": ["video", "resource", "storage", "config", "stream", "Source", "impl", "gz", "RC", "input", "download", "feat", "req", "ref", "load", "back", "filename", "slice", "href", "cb", "prot", "url", "string", "code", "buf", "gb", "spec", "dist", "cpp", "rc", "stage", "sn", "path", "st", "sc", "cmp", "upload", "ource", "uri", "sb", "proc", "SourceFile", "sin", "img", "fp", "supp", "attr", "sit", "secure", "tmp", "name", "ssl", "Dest", "sel", "sys", "component", "file", "fn", "inst", "username", "sth", "reader", "rb", "rl", "ctx", "scene", "loc", "source", "obj", "s"], "dest": [" destination", "temp", "cont", "dc", "dat", "target", "bin", "home", "null", "txt", "class", "orig", "lib", "dist", "path", " dst", "img", "dir", "std", "tmp", "test", "Dest", "fn", "di", "source", "obj", "disk"], "in": ["ini", "err", "login", "stream", "inn", "inf", "val", "input", "In", "up", "bin", "pin", "r", "IN", "ps", "t", "pass", "d", "doc", "source", "io", "ins", "is", "as", "inas", "a", "data", "isin", "file", "ex", "i", "reader", "win", "n", "din", "f", "inc"], "p": ["np", "j", "o", "po", "pre", "py", "P", "pc", "cop", "parser", "l", "b", "jp", "pr", "bp", "lp", "pi", "pp", "sp", "pe", "c", "r", "wp", "g", "ps", "t", "pa", "d", "op", "pg", "part", "pm", "v", "fp", "pb", "h", "tp", "pd", "e", "i", "per", "cp", "m", "f", "s"], "ds": ["ths", "dp", "vals", "ls", "services", "ads", "ld", "lp", "groups", "dt", " ps", "os", "ins", "icks", "nas", "ts", "dates", "scripts", "s", "dc", "dat", "Ds", "points", "els", "sync", "tools", "ipes", "xs", "obs", "sts", "d", "ils", "dds", "hs", "gs", "docs", "sys", "pd", "dm", "ss", "dl", "des", "posts", " DS", "utils", "cons", "lines", "ns", "ges", "da", "tests", "ays", "dist", " props", "eps", "cs", "df", "uds", "gd", "qs", "ys", "data", "ded", "ks", "words", "di", "db", "parts", "dd", "ants", "vs", "amps", "ans", "DS", "dos", "plugins", "styles", "js", "ps", "rs", "ups", "models", "bs", " sd"], "format": ["letter", "model", "unit", "nat", "plugin", "prefix", "form", "function", "pattern", "at", "feat", "filter", "version", "parser", "atter", "filename", "sche", "api", "table", "Format", "struct", "style", "string", "class", "scale", "act", "spec", "t", "fd", "path", "handler", "ant", "template", "source", "type", "record", "part", "frame", "fp", "name", "language", "host", "data", "file", "layout", "fn", "magic", "config", "tag", "f", "url"], "hasPixelData": ["hasPixelStyle", "haspixeldata", "showsByteDATA", "hasByteStyle", " hasPixelSize", "hasByteDATA", "showsPixelDATA", "hasPixelDATA", "hasPictureSize", "hasPixeldata", "hasByteData", "hasPixelSize", "showsPixelData", "haspixelData", "hasPicturedata", "showsByteData", "hasByteSize", "showsByteStyle", "haspixelSize", "showsPixeldata", "showsBytedata", "showsPixelStyle", "hasBytedata", "hasPictureData", " hasPixeldata"], "inflate": ["inadequode", "infloation", "inadequATE", "InFlace", "infloace", "Inflation", "inflation", "InFlate", "Inflated", "inflode", "infolode", "insflating", "invenate", "insvenate", "infolate", "Inflate", "infolATE", "infolating", "InFlated", "insvenATE", "invenating", "inFlace", "inflace", "insflode", "invenode", "inadequating", "insvenating", "inffate", "InFlation", "insflate", "inffation", "invenATE", "infloated", "inffated", "inflating", "inFlate", "Inflace", "insflATE", "infface", "infloate", "inFlated", "inadequate", "insvenode", "inflated", "inflATE", "inFlation"], "pxlen": ["pxden", "pxdata", "mxlen", "campos", "pxln", "mxln", "pxlon", "camln", "mxcount", "pxlin", "pngsize", "xplength", "fxln", "xpsize", "pgden", "ppl", "pplen", "fxden", "pxsize", "pxcount", "fxpos", "axlin", "pclon", "ppLen", "pnglength", "txlon", "pnglen", "pxl", "mxlength", "xplen", "xpcount", "axlen", "txlin", "txln", "pxpos", "ppden", "mxdata", "pglen", "pgLen", "mxpos", "pxlength", "fxl", "pclen", "pgl", "camlen", "pclin", "camdata", "axln", "txlen", "pcln", "fxLen", "pxLen", "mxsize", "fxdata", "pngcount", "fxlen", "axlon"], "out": ["re", "err", "log", "point", "step", "cli", "inter", "up", "group", "cache", "output", "OUT", "list", "conn", "post", "page", "pad", "store", "session", "state", "again", "outs", "work", "query", "line", "io", "v", "Out", "co", "dump", "sys", "server", "user", "gen", "lock", "error", "lib", "parent", "obj", "copy"]}}
{"id1": "6742637", "id2": "804637", "code1": "    private static List<Properties> findExtensions() {\n        URL url = null;\n        try {\n            List<Properties> extensions = new ArrayList<Properties>();\n            Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\");\n            while (res.hasMoreElements()) {\n                url = res.nextElement();\n                Properties prop = new Properties();\n                prop.load(url.openStream());\n                extensions.add(prop);\n            }\n            return extensions;\n        } catch (IOException ioe) {\n            String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm();\n            throw new RuntimeException(msg, ioe);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"findExtensions": ["findExtends", "findDistends", "getextensions", "findDistension", "findExtension", "findDistensions", "findAppensions", "findextensions", "getextension", "findextension", "getExtensions", "findAppends", "findextends", "getExtends", "getextends", "findAppension", "getExtension"], "url": ["re", "err", "image", "ver", "link", "URL", "service", "resource", "fr", "base", "lr", "feed", "html", "config", "impl", "coll", "ul", "cl", "Url", "ls", "entry", "http", "load", "zip", "src", "log", "remote", "l", "api", "ch", "bb", "page", "element", "r", "bel", "buffer", "rc", "path", "result", "io", "org", "uri", "rel", "pull", "bug", "il", "ur", "name", "location", "ssl", "server", "data", "file", "id", "gl", "sl", "rl", "connection", "loc", "source", "web", "f", "address"], "extensions": ["Extras", "exras", "extension", "intps", "xtps", "appencies", "exension", "xtension", "fends", "fension", "extras", "extencies", "appension", "appensions", "extps", "xtensions", "fps", "fensions", "intends", "exends", "appras", "exencies", "Extension", "xtends", "intensions", "Extensions", "exensions", "Extencies", "exps", "intension"], "res": ["re", "err", "RE", "ver", "resource", "vals", "raw", "fr", "req", "details", "http", "rev", "vers", "resolution", "ch", "js", "Rs", "r", "pres", "resp", "ps", "rc", "RES", "gr", "rows", "Res", "ris", "result", "ros", "ret", "rr", "os", "ras", "mr", "rh", "out", "response", "rest", "rus", "is", "rs", "es", "hr", "request", "rem", "rex", "rez", "ries", "RS", "ex", "results", "ress", "rss"], "prop": ["j", "base", "resource", "point", "lit", "val", "property", "Prop", "feat", "ref", "exp", "key", "properties", "api", "b", "info", "mp", "pr", "style", "class", "option", "def", "pos", "ps", "fb", "op", "p", "part", "result", "opt", "priv", "proc", "attr", "comp", "fp", "pb", "tmp", "app", "ext", "term", "data", "feature", "pac", "pro", "cp", "config", "project", "f", "obj"], "msg": ["err", "log", "cmd", "urg", "printf", "format", "reason", "req", "text", "message", "ms", "info", "agg", "string", "status", "cfg", "rag", "mn", "g", "gr", "tag", "eg", "kg", "sg", "mt", "mg", "me", "Msg", "comm", "title", "mid", "ext", "gs", "ko", "loc", "mag", "error", "str", "og", "mb", "bg", "bf", "m", "ug", "db", "gm", "s"]}}
{"id1": "6379126", "id2": "5723876", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"gerarTutorialPage": ["riartourpage", "riarTourDir", "riarTinyElement", "riarTourPage", "riarTinyPage", "riarTravispage", "riartutorialElement", "riarTourpage", "riartourPage", "riarTinypage", "riarTravisPage", "riartourDir", "riarTutorialDir", "riartourElement", "riartutorialpage", "riarTravisElement", "riarTravisDir", "riarTutorialElement", "riartutorialDir", "riarTutorialpage", "riarTourElement", "riarTinyDir", "riarTutorialPage", "riartutorialPage"], "indexDir": ["IndexJar", "IndexDir", "IndexTier", "indexJar", "includeDIR", "indexDIR", "includeTier", "zipDIR", "IndexDIR", "indexTier", "zipTier", "zipJar", "includeJar", "zipDir", "includeDir"], "cssDir": ["CSSLen", "CSSDirectory", "fontDIR", "catsDoc", "piecesD", "cssDb", "codesLen", "gzUrl", "ssUrl", "gzDirectory", "javascriptDIR", "cssDirectory", "CSSDir", "catsLen", "gzDIR", "cssDIR", "codesDoc", "codesDir", "ssDirectory", "CSSUrl", "CSSDIR", "cssLen", "ssDir", "piecesDie", "cssD", "javascriptDb", "piecesDIR", "gzDir", "fontD", "ssDb", "CSSDoc", "cssDar", "cssDoc", "catsDir", "ssDie", "fontDir", "piecesDir", "javascriptDir", "cssUrl", "ssDIR", "cssDie", "CSSDar", "javascriptDar", "ssD", "fontDie", "ssDar", "CSSDb"], "capDir": ["casDirectory", "apsVol", "casVol", "capdir", "apsdir", "casDir", "CapVol", "CapDir", "apsDirectory", "CapDirectory", "casdir", "apsDir", "capDirectory", "Capdir", "capVol"], "licDir": ["lifManager", "licDoc", "volDoc", "lifDir", "volManager", "libDoc", "libdir", "lifdir", "libManager", "voldir", "licManager", "lifDoc", "volDir", "licdir", "libDir"], "midDir": ["limDIR", "mindDir", "middir", "casDir", "midTier", "minddir", "limTier", "mindDIR", "casdir", "mindTier", "casDIR", "limDir", "midDIR", "casTier", "limdir"], "filesDir": ["filesFolder", "ballsDir", "ballsPos", "opensDir", "locksDur", "filesDur", "locksDir", "pagesVol", "opensDirectory", "videosFolder", "FilesDirectory", "FilesFolder", "ballsVol", "opensDIR", "filesDirectory", " filesVol", "locksDIR", "locksDirectory", "stylesDirectory", "stylesDir", "pagesDir", "FilesDir", "stylesDIR", "filesFile", "imagesDirectory", "filesPos", "pagesPos", "imagesFile", "videosFile", "opensDur", "filesVol", "filesDIR", "imagesDir", " filesPos", "imagesFolder", "videosDirectory", "FilesFile", "stylesDur"], "videosDir": [" videosDb", "viewsDirectory", "viewsUrl", "viewsFile", " videosUrl", "videoDb", " videosFile", "videoUrl", "imagesDb", "videoFile", "videoDirectory", "videosUrl", " videosDirectory", "viewsDir", "videosFile", "videoDir", "videosDb", "imagesDir", "videosDirectory"], "imagensDir": ["imagenciesDIR", "imagensDirectory", "imagenciesFile", "imgentsDirectory", "imagensJar", "imgentsDir", "imagentsDIR", " imagersDir", "imagentsDir", "imagenDirectory", "imgensDIR", "imagersJar", "imgensFile", "imagenciesDir", "imgentsFile", "imagenDir", "imagenJar", "imagersDir", "imgentsDIR", "imagensDIR", "imagentsDirectory", "imagersFile", "imagenciesDirectory", "imagensFile", "imagentsFile", "imagenFile", " imagensJar", "imagentsJar", "imgensDirectory", "imgensDir", "imagersDIR", " imagensFile", " imagersFile", " imagersJar", "imagersDirectory", " imagersDirectory", " imagensDirectory"], "local": [" Local", "log", "base", "temp", "localhost", "prefix", "self", "current", "global", "inner", "input", "json", "personal", "relative", "available", "serial", "active", "http", "standard", "back", "total", "remote", "l", "pal", "home", "initial", "safe", "Local", "state", "pass", "path", "d", "p", "part", "upload", "LOC", "small", "same", "specified", "dir", "util", "where", "managed", "tmp", "defined", "name", "present", "internal", "partial", "request", "basic", "data", "file", "user", "valid", "username", "lock", "Location", "shared", "loc", "location", "conf", "directory"], "srcCss1": ["srcPss4", "srcCpe4", "srcCass0", "srcCass2", "srcRcss2", "srcRcss81", "srcPcss2", "srcCrss11", "srcPcss1", "srcCfg2", "srcCass3", "srcCrss81", "srcCssPre", "srcRss2", "srcCse2", "srcCfgPre", "srcCcss81", "srcCcss4", "srcCpe2", "srcCrss1", "srcCss81", "srcPss2", "srcPcssPre", "srcCpe1", "srcRss0", "srcCss11", "srcCcss11", "srcCse1", "srcCse0", "srcPss3", "srcCass1", "srcCpePre", "srcRcss11", "srcRss81", "srcCcss3", "srcCcss2", "srcPss81", "srcCfg4", "srcCcss1", "srcCrss2", "srcRcss0", "srcCss0", "srcCcss0", "srcPss1", "srcCass81", "srcCse11", "srcPcss4", "srcCcssPre", "srcPcss81", "srcCfg1", "srcPssPre", "srcCrss3", "srcCass11", "srcRcss1", "srcRss11", "srcRss1", "srcPcss3"], "destCss1": ["destCxx2", "destCcss2", "destPss3", "destCass3", "destPcss1", "destCrss3", "destCrss1", "destPcss81", "destPcss3", "destPcssCard", "destPcss2", "destCxxCard", "destCcss1", "destCcss81", "destPss1", "destCfg1", "destCrss2", "destCrss0", "destPss81", "destCrss81", "destCxx3", "destCfg0", "destCcss3", "destCass2", "destCfg3", "destCssCard", "destCassCard", "destCss0", "destPss0", "destPss2", "destCass1", "destCfg2", "destPcss0", "destCxx1", "destCcss0", "destPssCard", "destCcssCard", "destCass81", "destCss81"], "srcCss2": ["srcCfgB", "srcUcssTwo", "srcCssL", "srcCass2", "srcCss27", "srcCcssL", "srcCrss27", "srcCass52", "srcPcss2", "srcCfgL", "srcPcss1", "srcCfg2", "srcCross2", "srcCng2", "srcChessTwo", "srcAccss52", "srcCng27", "srcChess1", "srcCcss4", "srcCrss1", "srcCng1", "srcCssB", "srcCross1", "srcPss2", "srcCcss27", "srcAccss4", "srcPssL", "srcUcss2", "srcUcssB", "srcChessB", "srcCcssTwo", "srcCssTwo", "srcPss3", "srcPcssL", "srcCass1", "srcAcss2", "srcUss1", "srcCss52", "srcCcss3", "srcCcss2", "srcCcss1", "srcChess2", "srcUssB", "srcCrss2", "srcCross52", "srcUssTwo", "srcPss1", "srcCrssL", "srcPss27", "srcAcss4", "srcCass4", "srcAccss1", "srcAccss2", "srcUss2", "srcCfg3", "srcCrss3", "srcCfg1", "srcUcss1", "srcAcss52", "srcCfgTwo", "srcPcss27", "srcAcss1", "srcCross4", "srcCcss52", "srcCcssB", "srcPcss3"], "destCss2": ["destNcss1", "destNcss3", "destCcss2", "destNss2", "destNss32", "destNcss72", "destCest3", "destNcss32", "destCss32", "destCestB", "destNcss4", "destCcss1", "destCfg72", "destNss1", "destCcss72", "destCest2", "destNss3", "destCess32", "destCfg1", "destNssB", "destCess2", "destCfgB", "destCess4", "destCss72", "destCssB", "destCess72", "destNcss2", "destCfg3", "destCcss3", "destNss72", "destCfg32", "destCest1", "destCcss32", "destCcssB", "destCfg4", "destCfg2", "destNss4", "destCess1", "destNcssB", "destCcss4"], "srcCss3": ["srcScstyle3", "srcCstyle15", "srcRss2", "srcCrssAND", "srcCrss6", "srcScstyle93", "srcCcss4", "srcCsl183", "srcCsh2", "srcPssAND", "srcCcss3", "srcCcss2", "srcRss3", "srcCsl2", "srcClass3", "srcClass93", "srcCfg3", "srcCcss6", "srcRcss1", "srcCstyle6", "srcRcss2", "srcPcss3", "srcCass2", "srcPss6", "srcCshThird", "srcRcss183", "srcCcss93", "srcRss4", "srcScstyle15", "srcRcssThird", "srcCcss183", "srcCrss3", "srcCss183", "srcRss1", "srcRcss3", "srcScss93", "srcCsh3", "srcPcss2", "srcCstyle93", "srcPss2", "srcCssThird", "srcPcss6", "srcCsl3", "srcCcssAND", "srcClass15", "srcClass2", "srcCrss2", "srcScss15", "srcCstyle3", "srcRssThird", "srcCfg1", "srcPcssAND", "srcCssAND", "srcRss183", "srcCslThird", "srcCass3", "srcCfg2", "srcCss15", "srcScss2", "srcScstyle2", "srcCsh183", "srcPss3", "srcCass1", "srcCstyleAND", "srcCstyle2", "srcCfg4", "srcCcss1", "srcCss93", "srcCass4", "srcCcssThird", "srcCcss15", "srcRcss4", "srcScss3"], "destCss3": ["destNcss3", "destCcss2", "destNss2", "destScrss3", "destPss3", "destPss03", "destCass3", "destCrss3", "destCross2", "destCcss53", "destScss3", "destPcss03", "destScrss183", "destScrss6", "destCss183", "destPcss3", "destPcss2", "destCja3", "destCass43", "destCcss6", "destCss03", "destNss3", "destCrss2", "destCja183", "destPss53", "destCstyle43", "destCross3", "destCcss43", "destCrss6", "destCstyle03", "destCrss183", "destCja2", "destCross03", "destCcss3", "destCstyle3", "destCass2", "destNcss2", "destCja6", "destScss183", "destCcss183", "destCcss03", "destCstyle53", "destScrss2", "destNcss43", "destNss43", "destPss2", "destPcss53", "destCss53", "destCss43", "destScss6", "destScss2", "destCstyle2", "destCross53"], "srcCss4": ["srcPss4", "srcCass2", "srcPcss2", "srcPcssFour", "srcPcss1", "srcCassFour", "srcCcss4", "srcCrss1", "srcCcssFour", "srcPss2", "srcCass1", "srcCcss2", "srcCcss1", "srcCrss2", "srcPss1", "srcCass4", "srcPssFour", "srcCrssFour", "srcPcss4", "srcCssFour", "srcCrss4"]}}
{"id1": "20991673", "id2": "4481712", "code1": "    public NodeId generateTopicId(String topicName) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"No SHA support!\");\n        }\n        if (m_ready) System.out.println(\"Scribe is ready at\" + getNodeId() + \" , topic is \" + topicName);\n        md.update(topicName.getBytes());\n        byte[] digest = md.digest();\n        NodeId newId = new NodeId(digest);\n        return newId;\n    }\n", "code2": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"generateTopicId": ["generateTopicID", "generatetopicId", "generateTopicInfo", "generatedTopicID", "generatedtopicName", "generateTopicName", "generateTopicsId", "generateTopicsInfo", "generatedtopicInfo", "generatetopicID", "generatetopicInfo", "generatedTopicName", "generatedTopicInfo", "generateTopicsName", "generatedtopicID", "generatetopicName", "generatedTopicId", "generatedtopicId", "generateTopicsID"], "topicName": ["TopicKey", "subjectId", " topicId", "TopicName", "channelKey", "TopicInfo", "topicType", " topicPath", " topicKey", "Topicname", "topicKey", "topicId", "topId", "topName", " topicNames", "TopicNames", "channelId", "TopicId", "topicname", "channelType", "channelName", "subjectName", "subjectType", " topicname", "channelPath", " topicType", " topicInfo", "topname", "topNames", "subjectPath", "topicNames", "topicInfo", "topicPath", "channelInfo"], "md": ["dd", "sha", "cmd", "dr", "meta", "ud", "dc", "am", "dig", "metadata", "ma", "amd", " MD", "po", "hd", "mm", "mo", "ms", "ld", "mp", "vd", "km", "hash", "d", "mand", "bd", "ad", "pm", "df", "sm", "mg", "mac", "mt", "gd", "od", "editor", "cm", "MD", "Cmd", "id", "dh", "pd", "mag", "rm", "dm", "mc", "pkg", "mb", "m"], "digest": ["dighed", "mdested", "dhed", "Diggest", "diggest", "DigEST", "mdest", " diggest", " dighed", "signEST", "digester", "Digests", "cdEST", "dester", "decest", "mdhed", "signests", "Digester", "decEST", "dest", "digests", "mdester", "signest", "cdgest", "digested", "digEST", " digEST", "dested", " digested", "decests", "cdest", "Digest", "cdester", " digester"], "newId": ["nextid", "NewId", " newID", "Newid", "nextId", " newid", "NewInfo", " newInfo", "newInfo", "nextID", "newID", "NewID", "nextInfo", "newid"]}}
{"id1": "12579075", "id2": "15351863", "code1": "    public static XMLConfigurator loadFromSystemProperty(String propertyName) throws IOException {\n        String urlStr = System.getProperty(propertyName);\n        if (urlStr == null || urlStr.length() == 0) {\n            return null;\n        }\n        InputStream in = null;\n        DOMRetriever xmlDoc = null;\n        try {\n            URL url = new URL(urlStr);\n            xmlDoc = new DOMRetriever(in = url.openStream());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (in != null) in.close();\n        }\n        return newInstance(xmlDoc);\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"loadFromSystemProperty": ["loadFromLocalperties", "loadFromLocalString", "loadFromSysProperty", "loadFromSystemperties", "loadFromSystemproperty", "loadFormSystemProperty", "loadFromsystemproperty", "loadFromSysproperty", "loadFromSysperties", "loadFormsystemperties", "loadFromLocalproperty", "loadFromSysString", "loadFormsystemProperty", "loadFormsystemproperty", "loadFormsystemString", "loadFromsystemProperty", "loadFormSystemproperty", "loadFormSystemperties", "loadFromLocalProperty", "loadFromsystemperties", "loadFormSystemString", "loadFromSystemString", "loadFromsystemString"], "propertyName": [" propertyStr", "fileNames", "propString", " propertyPath", "PropertyPath", "propName", " propertyValue", "fileName", "propertyValue", "propStr", " propertyPart", "propertyString", "propNames", "propPart", "filePart", "propPath", "PropertyName", "fileString", "propValue", "PropertyStr", "propertyPart", "propertyPath", "PropertyValue", "propertyStr", " propertyString", "propertyNames", " propertyNames"], "urlStr": ["UrlText", "uristr", "resourceSt", "UrlWr", "urlString", "Urlstr", "urlWr", "URLSt", "URLstr", "httpName", " urlstr", "urlSt", "UrlString", " urlText", "uriStr", "URLName", " urlWr", " urlSt", "URLWr", " urlString", "URLStr", "UrlSt", "UrlName", "httpText", "urlstr", "urlText", "resourceString", "resourceStr", " urlName", "uriWr", "URLString", "httpStr", "urlName", "httpstr", "uriName", "UrlStr"], "in": ["ini", "err", "image", "resource", "login", "fac", "serv", "stream", "inner", "inn", "gin", "input", "din", "In", "src", "l", "bin", "conn", "c", "cf", "r", "IN", "session", "again", "ic", "doc", "p", "source", "nin", "part", "cin", "min", "out", "client", "ins", "is", "as", "socket", "ssl", "init", "ac", "a", "con", "data", "file", "isin", "id", "reader", "i", "n", "m", "inc", "f"], "xmlDoc": ["webDocument", "webUrl", "mlDoc", "officeDom", "jsonStr", "xmlDom", "domDocument", "officeDocument", " xmlDom", " xmlDocument", "domStr", "xmlStr", "webDoc", "mlUrl", "xmlConfig", "mlConfig", "mlStr", "officeDoc", "domDoc", "externalDoc", " xmlConfig", "externalStr", "jsonDoc", "externalConfig", "jsonDom", "jsonDocument", "officeStr", "xmlDocument", "mlDocument", "webStr", "externalDocument", "xmlUrl", "domUrl", " xmlStr"], "url": ["image", "URL", "base", "fr", "www", "feed", "resource", "stream", "inf", "input", "Url", "download", "open", "ls", "src", "http", "l", "b", "string", "bel", "buffer", "io", "uri", "client", "socket", "ssl", "server", "data", "file", "ll", "inst", "user", "id", "gl", "instance", "str", "sl", "reader", "el", "browser", "connection", "config", "source", "web", "f"]}}
{"id1": "17296916", "id2": "3409084", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    protected String getRequestContent(String urlText) throws Exception {\n        URL url = new URL(urlText);\n        HttpURLConnection urlcon = (HttpURLConnection) url.openConnection();\n        urlcon.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream()));\n        String line = reader.readLine();\n        reader.close();\n        urlcon.disconnect();\n        return line;\n    }\n", "label": 0, "substitutes": {"logging": ["Loging", "Logging", "blogging", "Logger", "logger", "logting", "bloging", " logger", " logting", "loging", "Logting", "blogger", " loging", "blogting"], "wrap": ["image", "force", "wb", "box", "create", "rap", "stream", "self", "default", "w", "transform", "format", "parse", "message", "run", "process", "widget", "cache", "use", "bag", "api", "b", "ow", "now", "ws", "we", "flash", " wrapped", "wp", "wa", "work", "handler", "p", "div", "ad", "wire", "nw", "frame", "build", "handle", "util", " Wrap", "init", "word", "h", "wrapper", "wra", "war", "binary", "lock", "pipe", "sw", "get", "or", "web", "f", "cover"], "buffer": ["image", "log", "nb", "base", "bm", "feed", " buffers", "view", "board", "player", "ref", " buf", "cache", "message", "queue", "bridge", "shell", "b", "bb", "cb", "bin", "table", "uf", "print", "builder", "url", "buf", "code", "flash", "buff", "null", " receive", "fb", "uffer", "template", "result", "cover", "frame", "response", "layer", "manager", "pb", "loader", "report", "pause", "bar", "wrapper", "server", "reference", "binary", "ob", "transfer", "BU", "document", "header", "comment", "reader", "writer", "bc", "iter", "batch", "msg", "source", "Buffer", "reply", "surface", "copy"], "encoding": ["decoding", "decryption", "Encoding", "encryption", "coded", "ecoding", "unicode", "packoding", "encoded", "unicoded", "packet", "unicoder", "encoder", "Encoded", "coding", "cet", "Encryption", "unicoding", "Encoder", "coder", "ecoded", "packoded", "packoder", "ecoder", "decode", "encode", "Encet", "enoder", "decoder", "enoded", "enode", "decoded", "enoding", "encet", "ecryption"], "getEncoding": [" getEnoded", "getEnasing", "getEnocol", " getEnocol", "getencoded", "getEncoded", "getencocol", "getEnoder", "getCasing", " getEncoder", " getEnasing", "getencasing", "getCocol", "getencoder", " getEncoded", "getCoding", "getEncasing", "getEncocol", "getencoding", "getCoder", " getEnoder", "getCoded", " getEnoding", "getEncoder", "getEnoded", " getEncocol", "getEnoding", " getEncasing"], "headers": ["body", "ports", "vals", "options", "objects", "keys", "types", "content", "ppers", "heads", "head", "ints", "lines", "breaks", "plugins", "workers", "bits", "links", "details", "http", "ids", "frames", "properties", "blocks", "files", "params", "groups", "padding", "dict", "settings", "writers", "relations", "fields", "caps", "values", "rs", "ters", "features", "ings", "h", "wrapper", "host", "header", "names", "str", "strings", "parts", "ers", "s"], "is": ["its", "in", "isol", "isi", "abs", "ops", "mis", "http", "nis", "cms", "lis", "bas", "has", "api", "ms", "ui", "ws", "js", "IS", "so", "obs", "was", "ris", "io", "os", "isl", "oss", "isa", "out", "sis", "fs", "iss", "ins", "\u00eds", "as", "ses", "iso", "bis", "es", "are", "us", "ori", "ois", "las", "bs", "ists", "ios", "Is", "i", "tis", "ais", "or", "aos", "iris", "s"], "bos": ["bo", "pins", "beans", "zos", "mobi", "base", "osa", "bot", "mis", "bits", "ops", "osi", "bots", "lins", "cms", "mos", "bas", "bin", "ws", "home", "bones", "so", "obo", "ubis", "obs", "outs", "zo", "abi", "bes", "flo", "ros", "org", "obos", "os", "oks", "bi", "uds", "fs", "cos", "oes", "bott", "ses", "bis", "ubs", "ko", "ois", "oops", "las", "bs", "opus", "shadow", "oses", "ob", "ios", "tis", "oos", "fits", "bc", "bh", "los", "aos", "obi"], "e": ["re", "err", "de", "o", "je", "fe", "E", "ke", "l", "c", "pe", "ise", "oe", "ze", "d", "be", "ie", "er", "ea", "type", "p", "se", "x", "ce", "me", "ite", "ale", "ception", "a", "ae", "esi", "ev", "error", "f", "i", "one", "ec", "exc", "ee"]}}
{"id1": "9267602", "id2": "4168534", "code1": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "code2": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "label": 0, "substitutes": {"urltext": ["urlbr", "URLobject", "urlobject", "urlTEXT", "feedbr", "filebr", "urlfeed", "lltext", "llTEXT", "filename", "URLTEXT", " urlbr", "urlname", "feedtext", " urlobject", "feedname", " urlname", "URLtext", "feedfeed", "llobject", "filefeed", " urlTEXT", " urlfeed", "filetext"], "url": ["image", "log", "URL", "base", "resource", "service", "feed", "this", "Url", "ball", "open", "ref", "http", "zip", "queue", "l", "b", "page", "string", "r", "bel", "buffer", "db", "uri", "plug", "out", "blog", "name", "socket", "ssl", "server", "id", "file", "data", "user", "sl", "i", "lib", "connection", "jar", "source", "web", "f", "address"], "in": ["ini", "kin", "err", "login", "stream", "gin", "inn", "inner", "input", "In", "inc", "cms", "l", "bin", "b", "read", "r", "IN", "buffer", "source", "line", "nin", "min", "out", "client", "ins", "is", "into", "as", "loader", "init", "ssl", "inside", "data", "file", "id", "isin", "reader", "i", "din", "f", "lin", "s"], "inputLine": ["InputLine", "outputBlock", "execData", "InputByte", "outputL", "Inputline", "outputByte", "inputData", "execline", "inputStream", " inputStream", " inputByte", "outputline", " inputL", "inputByte", " inputData", "InputBlock", "inputline", "InputL", "execLine", "rawL", "outputLine", "inputString", " inputline", "inputL", " inputBlock", "rawLine", "inputBlock", "rawString", "outputStream", "InputString", "outputData", "rawline", " inputString", "execStream"]}}
{"id1": "5760649", "id2": "13886238", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"createFile": [" createResource", "CreateContent", "CreateFolder", " createFolder", "CreateFile", "createContent", " createContent", "createResource", "createFolder", "saveContent", "CreateResource", "saveFile", "saveFolder", "saveResource"], "src": ["resources", "resource", "stream", "Source", "content", "input", "load", "slice", "href", "ruby", "cb", "url", "string", "txt", "buf", "gb", "files", "r", "rc", "path", "rob", "sc", "upload", "uri", "sb", "proc", "SourceFile", "dest", "img", "fp", "sit", "secure", "name", "ssl", "sel", "data", "file", "fn", "username", "rss", "sl", "rb", "loc", "source", "obj", "s"], "filename": ["wb", "resource", "prefix", "dll", "metadata", "acl", "which", "feat", "output", "l", "utf", "string", "txt", "ame", "files", "ames", "route", "path", "fil", "Filename", "source", "uri", "SourceFile", "fp", "ename", "FILE", "length", "loader", "name", "title", "nil", "file", "fn", "sf", "username", "s", "rl", "location", "f", "url", "directory"], "fis": ["sfos", "Fais", " fIS", "cfais", "cfris", " fbs", "cfis", "cfIS", "fais", "sfiss", " fiss", "Fbs", "Fos", "Fis", " fais", "cfos", "fris", "fIS", "Fiss", "sfris", "fiss", "sfis", "fbs", "FIS", "Fris", "cfbs", " fris"], "fos": ["fios", "sfios", "sfos", " fops", "fOS", "affis", "Fas", "Fbos", "bos", "Fios", " fios", "foras", "FOS", "bbos", "fbos", "foros", " fas", "Fos", "Fis", "affios", "bis", "sfis", "fops", "Fops", "affbos", "foris", "affos", "sfops", " fOS", "fas", "bios", "forOS"]}}
{"id1": "6371607", "id2": "414258", "code1": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"removeRealm": ["removeLocalam", "removeBroadme", "removeRelam", "removeRelm", "deleterealM", "removeRealme", "removeRelM", "deleteRealms", "deleterealam", "removerealm", "removerealam", "removeRelms", "removeBroadm", "removerealms", "removeSchems", "removeRealms", "removeRealam", "deleterealms", "deleteRealM", "removeScheM", "delRealme", "removeLocalM", "delBroadms", "removeScheme", "removeBroadms", "delRealM", "removeLocalms", "delBroadme", "removeSchem", "removeRealM", "removerealM", "delRealms", "removeLocalm", "removeBroadM", "removerealme", "deleterealm", "delBroadM", "deleteRealam", "delRealm", "delBroadm", "deleteRealm"], "realmIds": ["realMPathids", "realMIdes", "realmRefList", "realmIntos", "realmRefes", "realmRefids", "realmByIdes", "realMPaths", "realMIdos", "realMPathes", "realmPathes", "realmRefls", "realmPathids", "realmIdls", "realmIDList", "realMByIdls", "realmIDes", "realmIDs", "realmRefos", "realMByIdList", "realmIdids", "realmByIds", "realmIntes", "realmRefs", "realmByIdls", "realmIdList", "realmIdes", "realMIdList", "realMIdls", "realMByIds", "realMByIdes", "realmPathos", "realmPaths", "realMPathos", "realmInts", "realmIdos", "realmIntids", "realMIdids", "realmByIdList", "realMIds", "realmIDls"], "psImpl": [" psimpl", "dsImpl", "epsIter", "psExpl", "cssIter", "psHelper", "epsHelper", "cssimpl", " psIter", "cssImpl", "psimpl", "qsimpl", "psIter", "cssExpl", "dsimpl", "csImpl", " psExpl", "dsHelper", "csimpl", "epsimpl", "qsHelper", "csHelper", "epsImpl", "qsImpl", " psHelper", "epsExpl"], "iter": ["err", "index", "in", "outer", "end", "walker", "coll", "inner", "gener", "inter", "entry", "parse", "ir", "ler", "list", "finder", "page", "Iter", "next", "sort", "er", "ie", "line", "itter", "izer", "it", "loop", "ner", "ite", "cher", "init", "ter", "former", "apper", "e", "limit", "iterator", "el", "cer", "ator", "i", "enter", "reader", "loc", "inc", "upper"], "realmId": ["realrmRef", "realmsID", "realmInt", "realmName", "workfId", "RealmsPath", " realmnConfig", "realamID", "RealmsName", "ironmId", "ironmInt", " realmOffset", "realmrHash", "realfNum", "workmid", "realmeName", "RealmID", "realmHash", "realmcInt", "realmeId", "realmcID", "realmsPath", "realmid", "realarmName", "realmcId", "RealmPath", "RealmId", "realarmId", "workfNum", "realarmID", "realdmOffset", "realmrId", "realfid", "realmaId", "realmeID", "realfID", "realmRef", "ironmaRef", "workmID", "realmrNum", "realmrid", "realrmID", "realmsId", "realmaInt", "realmnOffset", "realamId", "ironmID", "realmNum", "realmaRef", "workmId", " realmnId", "ironmRef", "realmrConfig", "realarmPath", "realmsName", "ironmaID", "realfId", "realmePath", "realrmId", "realmnConfig", "ironmaId", "RealmsID", "workfID", "realmPath", "realdmId", "realmrOffset", "realmrID", "RealmName", "realdmHash", "realmaID", "realamNum", "workmNum", "realmID", "realamid", "realdmConfig", " realmnHash", "realmnId", "realrmInt", "realmConfig", "realmOffset", " realmHash", "realmcRef", "ironmaInt", "RealmsId", " realmConfig", " realmnOffset", "realmnHash", "workfid"]}}
{"id1": "6871529", "id2": "12236729", "code1": "    private boolean readUrlFile(String fullUrl, PrintWriter out) {\n        try {\n            URL url = new URL(fullUrl);\n            String encoding = \"gbk\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), encoding));\n            return fileEditor.pushStream(out, in, fullUrl, false);\n        } catch (Exception e) {\n        }\n        return false;\n    }\n", "code2": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "label": 0, "substitutes": {"readUrlFile": ["openURLFiles", "openUrlStream", "readurlFile", "readurlfile", "readURLFile", "openURLFile", "openUrlfile", "openUrlFiles", "readURLFiles", "readurlFiles", "readFileStream", "readFilefile", "openURLfile", "readFileFiles", "readUrlStream", "readurlStream", "readURLStream", "readUrlFiles", "readFileFile", "readUrlfile", "readURLfile", "openURLStream", "openUrlFile"], "fullUrl": [" fullURL", "FullURL", " fullPage", "shortUrl", "fullURL", " fullUr", "shorturl", "completeUr", "FullUr", " fullPath", "shortURL", "FullPage", "rawURL", "completeurl", "FullPath", "Fullurl", "fullPage", "fullUr", " fullurl", "rawurl", "fullPath", "shortPath", "rawUrl", "completeURL", "FullUrl", "completePage", "rawPage", "completeUrl", "fullurl"], "out": ["err", "image", "log", "o", "raw", "temp", "login", "resource", "inner", "content", "flush", "w", "write", "cache", "filename", "output", "OUT", "writer", "bin", "string", "IN", "buffer", "again", "outs", "line", "io", "result", "Out", "client", "report", "name", "server", "data", "file", "user", "reader", "i", "connection", "source", "parent", "obj", "inc"], "url": ["image", "log", "URL", "base", "resource", "service", "www", "feed", "stream", "Url", "ball", "open", "ls", "up", "http", "zip", "l", "b", "bb", "page", "string", "bel", "buffer", "io", "uri", "blog", "xml", "ssl", "server", "user", "file", "ll", "browser", "sl", "rl", "connection", "source", "web", "f"], "encoding": ["Encoding", "encaching", "encasing", "coded", "enasing", "encoded", "Encasing", "caching", "Encaching", "encoder", "Encoded", "coding", "code", "Encoder", "coder", "enaching", " encasing", "encode", " encoder", " encode", "enoded", "Encode", "casing", "enoding"], "in": ["ini", "body", "err", "login", "resource", "serv", "stream", "inner", "inn", "input", "In", "rec", "bin", "b", "c", "r", "IN", "doc", "source", "part", "nin", "io", "client", "ins", "xml", "a", "con", "data", "rin", "file", "str", "reader", "i", "win", "n", "connection", "din", "f", "inc", "s"]}}
{"id1": "647224", "id2": "9449064", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"uploadFile": ["processFiles", "uploadFiles", "UploadFiles", "UploadFile", "UploadDir", " uploadFiles", " uploadfile", "processfile", "processFile", " uploadDir", "processDir", "Uploadfile", "uploadDir", "uploadfile"], "inputFile": [" inputFiles", " inputType", " inputFilename", " inputLog", "inputLog", "sourcePage", "InputType", "inputfile", "sourceLog", "targetFilename", "inputFolder", "InputFiles", "inputStream", "sourceType", "sourceFolder", "targetDir", "InputFile", "targetFolder", "initialFile", " inputStream", " inputDir", "inputDir", " inputFolder", " inputfile", "inputFiles", " inputPage", "targetStream", "initialFilename", "InputFolder", "sourceFile", "initialStream", "targetPage", "targetfile", "sourcefile", "InputDir", "inputPage", "targetFiles", "inputType", "initialFolder", "targetLog", "InputStream", "inputFilename", "Inputfile", "sourceStream"], "targetFile": ["TargetDir", " targetPath", "targetPath", "TargetName", " targetFiles", "externalName", "externalFile", "inputPath", "sourceDir", "TargetLine", " targetLine", "TargetFile", "externalPath", "inputPlace", "targetPlace", "Targetfile", "outputDir", "sourcePath", "inputDir", "outputName", "sourceFile", "targetfile", " targetName", "TargetPath", "outputLine", "targetFiles", " targetDir", "outputFiles", "outputPath", "externalfile", "sourcePlace", "targetLine", "TargetFiles", " targetfile", " targetPlace", "targetDir", "targetName"], "outputFile": ["outputPage", " outputDirectory", "OutputFolder", "targetPath", "outFolder", " targetFiles", " outputStream", "inputPath", "currentFile", "outFile", "outputFolder", "OutputFile", "outputPlace", "inputfile", "targetQueue", " outputFiles", "currentFolder", "inputFolder", "inputStream", "outputDir", " outputPlace", " outputPage", "writeStream", "inputDir", " outputPath", "inputQueue", "currentfile", "inputFiles", "writeFile", " outputfile", " outputDir", "inputUrl", " outputUrl", "outDirectory", "writePage", "outputUrl", "Outputfile", "targetfile", "inputPage", "outPlace", "targetFiles", "currentPlace", " outputFolder", "outputQueue", "outputFiles", "outfile", "outputfile", "outputPath", " targetDirectory", "outputStream", "outputDirectory", "targetDirectory", "outPath", " targetQueue", "OutputDir", "writeUrl", "inputDirectory"], "in": ["ini", "err", "kin", "login", "sub", "serv", "stream", "inner", "inn", "input", "In", "up", "rec", "bin", "read", "pin", "r", "IN", "again", "pass", "source", "nin", "io", "cin", "diff", "issue", "pull", "ins", "is", "lin", "init", "inside", "ac", "con", "id", "data", "isin", "rin", "i", "win", "reader", "din", "url", "inc", "s"], "out": ["err", "image", "log", "base", "cmd", "o", "outer", "point", "this", "inner", "to", "write", "plain", "net", "inter", "up", "cache", "sync", "output", "OUT", "table", "writer", "ger", "bin", "conn", "page", "print", "r", "state", "again", "outs", "source", "io", "by", "Out", "client", "off", "report", "ext", "co", "dump", "sys", "user", "file", "data", "lock", "error", "ex", "println", "one", "n", "console", "inc", "exec", "copy", "s"], "line": ["link", "rule", "log", "unit", "base", "lc", "lf", "write", "lines", "entry", "inline", "LINE", "Line", "sync", "page", "ine", "string", "code", "pe", "buffer", "pass", "split", "job", "type", "part", "frame", "row", "le", "block", "name", "word", "data", "file", "range", "cell", "e", "limit", "char", "header", "lock", "comment", "error", "url", "lin"], "bytes": ["comments", "odes", "codes", "seconds", "steps", "bits", "lines", "ls", "zip", "count", "reads", "cycles", "blocks", "units", "code", " lines", "pos", "files", "rows", "groups", "outs", "os", "tes", "len", "items", "number", "eps", "values", " cycles", "length", "ones", "size", "es", "ips", "pages", "les", "ines", "bs", "binary", "bps", "s", "classes", "i", "words", "Bytes"]}}
{"id1": "12869602", "id2": "17792212", "code1": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"test_validate_tag_getTopAlbums": ["test_validate_tag_getTopArtalbumes", "test_validate_tag_getTopAlalbumls", "test_validate_tag_getTopArtalbumls", "test_validate_tag_getTopAlggs", "test_validate_tag_getTopAlggo", "test_validate_tag_getTopAlbumo", "test_validate_tag_getTopAlbumls", "test_validate_tag_getTopAlggls", "test_validate_tag_getTopAlalbumes", "test_validate_tag_getTopAlanges", "test_validate_tag_getTopAlalbums", "test_validate_tag_getTopAlangs", "test_validate_tag_getTopAlalbumo", "test_validate_tag_getTopAlbumes", "test_validate_tag_getTopAlangls", "test_validate_tag_getTopArtbumes", "test_validate_tag_getTopArtalbums", "test_validate_tag_getTopAlgges", "test_validate_tag_getTopArtalbumo", "test_validate_tag_getTopArtbums", "test_validate_tag_getTopAlango", "test_validate_tag_getTopArtbumo", "test_validate_tag_getTopArtbumls"], "factory": ["fictionary", "newactory", "pinder", "facuture", "fuild", "affuild", "newault", "dactory", "facuild", "pictionary", "finder", "ifuture", "affactory", "fault", "ifuild", "future", "pactory", "facactory", "dictionary", "affuture", "newictionary", "facault", "ifactory", "pault", "newinder", "dinder", "affault", "ifault", "dault"], "schemaLocation": ["schebasePosition", "schebaselocation", "specbaseFile", "schebasePath", "schemllocation", "schemlLocation", "schemeFile", "specmaFile", "symlFile", "schemalocation", "symlLocation", "specmaPath", "specbasePath", "schemasFile", "specbaseLocation", "schemasPosition", "schemaFile", "symllocation", "schemePath", "schebaseFile", "specmaLocation", "schemaPath", "schebaseLocation", "schemeLocation", "symalocation", "symaLocation", "specmaPosition", "schemasPath", "schemePosition", "schemaPosition", "schemasLocation", "schemlFile", "symaFile", "specbasePosition", "schemaslocation"], "schema": ["mama", "cheml", "chege", "mage", "schege", "verml", "defme", "cheme", "defma", "masge", "scheme", "mamma", "verma", "chema", "schemma", "masmma", "mamas", "scheml", "verme", "defmas", "chemma", "schemas", "vermas", "masma", "chemas", "masmas", "defml"], "validator": [" invalider", "valater", "valider", "Validation", " valider", "Validator", " validoder", "valoder", "validoder", "validner", "Validater", "valator", "Validner", " invalidater", "Validoder", "validater", " validner", " validation", "Valider", " validater", " invalidner", "valation", " invalidator", "validation"], "url": ["image", "method", "URL", "resource", "email", "feed", "www", "config", "stream", "coll", "download", "Url", "channel", "http", "text", "l", "b", "api", "buffer", "path", "uri", "xml", "ssl", "location", "server", "host", "file", "user", "browser", "sl", "date", "connection", "loc", "web", "f", "address"], "inputStream": ["downSource", " inputPath", " inputSource", "inputSource", "responseFile", "inputPath", "downStream", "inputForm", "InputPath", "InputSteam", "InputFile", "responsePath", " inputForm", " inputSteam", "InputSource", "inputFile", "inputSteam", " inputFile", "downSteam", "responseSource", "responseStream", "InputStream", "downForm", "InputForm"], "source": ["image", "method", "model", "slave", "service", "resource", "SOURCE", "view", "stream", "Source", "format", "input", "target", "channel", "src", "text", "parser", "slice", "object", "ources", "string", "class", "from", "session", "path", "handler", "ource", "result", "uri", "scene", "out", "context", "proxy", "data", "file", "document", "level", "instance", "reader", "connection", "s"]}}
{"id1": "9796161", "id2": "2465747", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 0, "substitutes": {"getMD5": ["getMD512", "getMD4", " getSHA4", " getSHA512", "getSHAHash", " getSHA5", "getmd4", " getMD512", "getSHA512", "getSHA5", " getSHAHash", "getSHA4", " getMDHash", "getHTMLHash", "getMDHash", "getmdHash", "getHTML5", "getHTML4", "getmd5", " getMD4", "getmd512", "getHTML512"], "s": ["its", "in", "comments", "self", "abs", "input", "ls", "lines", "services", " fails", "ns", "ends", "sync", "als", "l", "b", "bytes", "styles", "ms", "js", "ws", "string", "c", "tests", "g", "ps", "ates", "ows", "p", "ds", "source", "si", "S", "os", "sb", "v", "cs", " ads", "is", "ses", "rs", "es", "ssl", "gs", "a", "ings", "ips", "bs", "data", "e", "sym", "str", "ss", "i", "n", "sets", "ts", "strings", "scripts", "f", "parts"], "m": ["nm", "mi", "bm", "ym", "module", "am", "um", "fm", "arm", "mm", "tm", "mu", "l", "ms", "c", "t", "d", "mand", "p", "om", "pm", "gm", "v", "mr", "sm", "mac", "me", "wm", "manager", "man", "cm", "md", "h", "M", "e", "rm", "dm", "mc", "vm", "i", "em", "im", "hm", "mut", "f", "machine"]}}
{"id1": "886783", "id2": "10158738", "code1": "    private static void doGet(LNISoapServlet lni, String itemHandle, String packager, String output, String endpoint) throws java.rmi.RemoteException, ProtocolException, IOException, FileNotFoundException {\n        String itemURI = doLookup(lni, itemHandle, null);\n        URL url = LNIClientUtils.makeDAVURL(endpoint, itemURI, packager);\n        System.err.println(\"DEBUG: GET from URL: \" + url.toString());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setDoInput(true);\n        fixBasicAuth(url, conn);\n        conn.connect();\n        int status = conn.getResponseCode();\n        if (status < 200 || status >= 300) {\n            die(status, \"HTTP error, status=\" + String.valueOf(status) + \", message=\" + conn.getResponseMessage());\n        }\n        InputStream in = conn.getInputStream();\n        OutputStream out = new FileOutputStream(output);\n        copyStream(in, out);\n        in.close();\n        out.close();\n        System.err.println(\"DEBUG: Created local file \" + output);\n        System.err.println(\"RESULT: Status=\" + String.valueOf(conn.getResponseCode()) + \" \" + conn.getResponseMessage());\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"doGet": ["DoPut", " doGET", " doPut", "DoGET", "toPut", "toGET", "Doget", "toGet", "toget", " doget", "doPut", "doget", "doGET", "DoGet"], "lni": ["rii", "ioldi", " lti", "iolii", "lti", "iolti", "Lii", " lii", "iolni", "Lni", "rti", "rdi", "rni", " ldi", "Lti", "Ldi", "ldi", "lii"], "itemHandle": ["ItemURI", "ItemHand", " itemAddress", "ItemHandle", "itemhandle", "itemHandler", "itemAddress", "itemsHandle", "pageURI", "itemsHandler", " itemhandle", "pageAddress", "ItemFile", "itemFile", "pagehandle", " itemFile", "itemsHand", "itemsFile", "pageHandle", "ItemHandler", " itemHand", "itemHand", "ItemAddress", "Itemhandle", " itemHandler"], "packager": ["paramagers", "installaging", "ackatter", "packaging", "paramenger", "installenger", "packageager", "ackager", "packagger", "Packatter", "installagers", "paramager", "importager", "Packagger", "packageagger", "importenger", "Packaging", "importaging", "packenger", "importagers", "ackagger", "packagers", "paramaging", "packageatter", "Packager", "installager", "ackaging", "packageaging", "packatter"], "output": ["image", "log", "model", "ilo", "generated", "resource", "module", "outer", "written", "office", "prefix", "debug", "format", "input", "write", "target", "profile", "version", "message", "filename", "queue", "environment", "connection", "page", "application", "string", "summary", "online", "null", "external", "buffer", "path", "control", "four", "response", "il", "xml", "Output", "file", "document", "reference", "console", "config", "source", "web", "header", "address"], "endpoint": [" endocol", " endpoints", "endedend", "Endbase", " endbase", "Endpoints", "Endpoint", "Endend", "endpoints", " Endbase", "endocol", "endend", "endedpoint", "Endocol", "endPoint", "Endpath", " Endpoints", "endedpath", "endpath", "restend", "endedPoint", " Endocol", " Endpoint", "EndPoint", "restpath", "restPoint", "endbase", "restpoint"], "ProtocolException": ["ProtportBase", "ProtoFailure", "InterportBase", "InterocolException", "ProtInterfaceFailure", "InterocolBase", "ProtoException", "ProtInterfaceException", "InterocolHandler", "ProtoHandler", "ProtportException", "ProtocolBase", "InterportHandler", "ProtportFailure", "InterportException", "ProtInterfaceBase", "InterocolFailure", "ProtInterfaceHandler", "ProtoBase", "ProtocolFailure", "InterportFailure", "ProtocolHandler", "ProtportHandler"], "IOException": ["RemoteEx", "SecurityEx", " IOEx", "RemoteError", " IOError", "IOError", "SecurityError", "RemoteException", "IOEx", "SecurityException"], "FileNotFoundException": ["FileNotAvailableError", "FileIsAvailableException", "FileIsAvailableExcept", "FileIsFoundExcept", "FileNotfoundException", "FileNotfoundExcept", "FileNotAvailableExcept", "FileIsFoundError", "FileIsFoundException", "FileNotFoundExcept", "FileIsAvailableError", "FileNotFoundError", "FileNotfoundError", "FileNotAvailableException"], "itemURI": ["ItemURI", "ItemRI", "containerURI", "containerRI", "Itemuri", "objecturi", "itemuri", "objectURI", "containerURL", "itemUrl", "containeruri", "ItemURL", "itemRI", " itemRI", "objectUrl", " itemUrl", " itemuri", "objectURL", "ItemUrl", " itemURL", "itemURL"], "url": ["image", "log", "method", "URL", "base", "resource", "www", "impl", "stream", "coll", "download", "Url", "ls", "channel", "entry", "hub", "http", "zip", "key", "l", "bb", "object", "page", "c", "path", "li", "job", "db", "source", "io", "org", "uri", "client", "il", "ur", "ssl", "server", "host", "file", "ll", "ob", "user", "id", "el", "sl", "rl", "i", "connection", "loc", "location", "web", "f", "address"], "conn": ["enc", "err", "conv", "nt", "serv", "config", "coll", "dc", "po", "cli", "nc", "pc", "open", "rt", "http", "Connection", "ca", "sync", "api", "ch", "cb", "ann", "connected", "act", "c", "cf", "sql", "ct", "orp", "rc", "core", "sn", "not", "db", "ci", "en", "io", "fail", "oss", "ai", "client", "auth", "close", "socket", "ssl", "cm", "col", "co", "con", "ec", "cn", "server", "oa", "fn", "dn", "connect", "adj", "error", "Conn", "n", "uc", "cp", "connection", "ctx", "exec", "conf"], "status": ["err", "ity", "method", "index", "login", "Status", "site", "prefix", "current", "content", "warning", "pre", "cli", "json", "grade", "ix", "active", "version", "reason", "zip", "message", "sex", "sync", "rate", "api", "code", "class", "state", "stage", "success", "type", "progress", "result", "stat", "si", "fail", "response", "xml", "size", "cm", "ssl", "received", "sr", "server", "id", "score", "level", "error", "str", "date", "msg", "source", "header"], "in": ["ini", "login", "o", "rx", "stream", "inner", "inn", "gin", "input", "In", "inc", "up", "bin", "pin", "r", "IN", "again", "source", "nin", "io", "cin", "min", "pull", "ins", "init", "socket", "a", "inside", "con", "data", "rin", "isin", "id", "reader", "win", "i", "n", "or", "din", "lin"], "out": ["err", "ou", "log", "o", "temp", "outer", "this", "self", "gin", "w", "plain", "net", "at", "up", "exp", "cache", "sync", "OUT", "bin", "writer", "ch", "extra", "again", "outs", "plus", "doc", "line", "io", "min", "img", "Out", "client", "off", "ext", "co", "user", "file", "on", "parent", "ex", "n", "lib", "inc", "exec", "obj", "copy"]}}
{"id1": "5607440", "id2": "13414771", "code1": "    public void updateShoppingBean(String userId) {\n        Connection connection = null;\n        PreparedStatement preparedStatement1 = null;\n        PreparedStatement preparedStatement2 = null;\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            connection = DriverManager.getConnection(this.jdbcURL);\n            connection.setAutoCommit(false);\n            String preparedQuery = \"INSERT INTO dbComputerShopping.order(name,product_id,quantity,date,status)VALUES(?,?,?,?,?)\";\n            preparedStatement1 = connection.prepareStatement(preparedQuery);\n            Date date = new Date();\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            String orderDate = format.format(date);\n            Iterator iterator = this.cart.iterator();\n            Object[] shoppingInfo = null;\n            while (iterator.hasNext()) {\n                shoppingInfo = (Object[]) iterator.next();\n                ProductBean product = (ProductBean) shoppingInfo[0];\n                int quantity = (Integer) shoppingInfo[1];\n                preparedStatement1.setString(1, userId);\n                preparedStatement1.setInt(2, product.getId());\n                preparedStatement1.setInt(3, quantity);\n                preparedStatement1.setString(4, orderDate);\n                preparedStatement1.setString(5, \"confirmed\");\n                preparedStatement1.executeUpdate();\n            }\n            Object[] cartInfo = null;\n            preparedQuery = \"UPDATE components SET quantity=quantity-? WHERE comp_id=?\";\n            preparedStatement2 = connection.prepareStatement(preparedQuery);\n            for (Iterator i = this.cart.iterator(); i.hasNext(); ) {\n                cartInfo = (Object[]) i.next();\n                ProductBean product = (ProductBean) cartInfo[0];\n                int quantity = (Integer) cartInfo[1];\n                ProductListBean productList = new ProductListBean(jdbcURL);\n                ArrayList components = productList.getComponents(product.getId());\n                for (Iterator j = components.iterator(); j.hasNext(); ) {\n                    ComponentBean component = (ComponentBean) j.next();\n                    preparedStatement2.setInt(1, quantity);\n                    preparedStatement2.setInt(2, component.getId());\n                    preparedStatement2.executeUpdate();\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n            }\n        } finally {\n            try {\n                connection.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement1.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement2.close();\n            } catch (SQLException ex) {\n            }\n        }\n    }\n", "code2": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"updateShoppingBean": ["updateShoppingBaning", "updateShippingBAN", "updateShoppingBeans", "updateShoppingBans", "updateShoppingBEans", "updateShippingBans", "updateShoppingBoAN", "updateShippingBeAN", "updateShoppingBeaning", "updateShoppingBEan", "updateShippingBeaning", "updateShippingBean", "updateShoppingBoan", "updateShippingBaning", "updateShippingBeans", "updateShoppingBeAN", "updateShoppingBEAN", "updateShoppingBoans", "updateShoppingBEaning", "updateShoppingBan", "updateShoppingBoaning", "updateShoppingBAN", "updateShippingBan"], "userId": ["userData", "clientName", " userID", "UserPath", "userName", " userName", " userData", " userType", "clientType", "clientPath", "UserName", "clientId", "UserData", "userID", "clientData", "UserID", "userPath", "userType", "clientID", " userPath", "UserId", "UserType"], "connection": ["log", "index", "pool", "service", "resource", "graph", "section", "ion", "function", "channel", "Connection", "cache", "table", "writer", "conn", "management", "driver", "class", "application", "engine", "c", "sql", "condition", "session", "collection", "state", "relation", "subject", "BC", "query", "handler", "result", "container", "client", "context", "manager", "name", "statement", "communication", "con", "server", "data", "document", " Connection", "connect", "lock", "general", "database", "bc", "connected", "config", "db", "machine", "directory"], "preparedStatement1": ["preppedStatl", "preparedStatementone", "preparedObject01", "preparedStatement9", "prearedStatement0", "preppedStatement3", "preparedObject1", "preakedStatement4", "preparedStatl", "preppedStatementl", "preparedStatone", "preakedQuery1", "preparedStatement4", "preparedEvent1", "preparedQueryB", "preparedState0", "prefixedStatement0", "preferredStatement2", "preparedTransaction0", "prearedStatement1", "preakedQuery2", "preparedMaterial17", "preparedObject1001", "preparedstatement01", "preparedContext31", "preparedDocument2", "prearedSession1", "preparedState31", "preparedState01", "preparedComment3", "preparedObjectone", "preparedContext4", "preparedQuery0", "preparedStruct1", "preparedStat1", "preparedTransaction31", "preppedStat1", "preparedstatementone", "preparedStatementB", "preparedQueryn", "preparedDocument4", "preparedStat31", "preakedQuery4", "preparedDatabase1", "preparedState1", "preparedStatement1001", "prefixedStruct31", "preferredStatement1", "preuredStat4", "preparedDocument1", "preparedQuery2", "preparedQuery1", "preparedstatement1001", "preparedTransaction1", "prefixedStatement9", "preparedEvent01", "preparedStatement3", "preculatedEvent1", "preparedStruct0", "preparedStruct9", "preparedState9", "preferredStatement17", "preparedDatabase17", "preparedDatabase2", "preasterStatementone", "prearedSession0", "prearedSessionB", "preparedSessionB", "preparedComment1001", "preferredQuery1", "preparedQueryl", "preparedStatement31", "preparedStatement0", "preparedSession0", "preakedStatementn", "preparedDocument31", "preparedMaterial2", "preparedstatement1", "prefixedStruct1", "prefixedStruct0", "prefixedStruct9", "preparedSession1", "preakedStatement1", "preakedQueryn", "preparedCommentone", "preppedStatement1", "preasterStatement1001", "preparedComment1", "preparedDocumentB", "preasterStatement1", "preuredStatement1", "preparedStatementl", "preculatedStatement1", "preculatedEvent01", "preakedStatement2", "preuredStatone", "preparedStat4", "preasterObject1", "prearedStatementB", "preasterObject1001", "preferredQuery2", "preuredStat1", "preparedStat3", "preparedStatement17", "preparedDocumentn", "preparedSession2", "preparedStruct31", "preuredStat31", "preferredQuery17", "preparedContext1", "preuredStatement4", "preppedStat3", "preparedComment01", "preasterObjectone", "preparedQuery3", "preparedTransaction9", "preuredStatementone", "prefixedStatement1", "preasterStatement01", "preparedDatabase4", "preparedStatementn", "preparedDocument0", "preparedMaterial1", "preasterObject01", "preparedQuery17", "preparedCommentl", "preparedStatement01", "prefixedStatement31", "preparedQuery4", "prearedStatement2", "preuredStatement31", "preparedDocumentone", "preparedDatabasen", "preparedContextone", "preculatedStatement01", "prearedSession2"], "preparedStatement2": ["prearedSession0", "preparedstatement2", "prearedSession1", "preparedScope8", "preuredStatement2", "preparedstatement8", "preparedSession2", "preparedResult2", "preparedstatement404", "prearedStatement0", "preparedStatement0", "preparedScope404", "preparedConditiontwo", "preparedSession0", "preparedSession52", "preparedstatementtwo", "preparedResult52", "preparedCondition2", "preparedConfiguration2", "preuredstatement8", "preparedConfiguration52", "preuredstatementtwo", "preparedConfiguration0", "preparedScopetwo", "preuredStatementtwo", "preparedConfiguration1", "preparedStatement52", "preparedCondition8", "preparedStatement8", "preuredStatement404", "preparedSession1", "preparedScope2", "preparedCondition404", "preuredStatement8", "preparedResult0", "prearedStatement52", "prearedStatement1", "preparedStatementtwo", "preparedResult1", "prearedSession52", "preparedStatement404", "preuredstatement2", "prearedStatement2", "preuredstatement404", "prearedSession2"], "preparedQuery": ["prearedCommand", "preparedquery", "PreparedStatement", "prevertedFunction", "prearedquery", "PrearedQuery", "PreppedStatement", "perparedBody", "precedStatement", "previsedStatement", "perppedQuery", "perparedquery", "PreparedInfo", "preppedQu", "PrearedQu", "peraredStatement", "prevertedQu", "preculatedQu", "PreparedFunction", "preparedInfo", "precedQuery", "precedCommand", "PreparedQuery", "preparedBody", "prearedInfo", "perppedquery", "PrearedInfo", "preparedCommand", "PreparedQu", "perparedQuery", "preculatedInfo", "prearedQuery", "prevertedBody", "preppedBody", "preplannedCommand", "prevertedInfo", "previsedQuery", "perparedCommand", "prevertedquery", "PreppedQuery", "previsedquery", "prevertedQuery", "peraredCommand", "preculatedFunction", "preplannedStatement", "preppedquery", "prevertedStatement", "peraredquery", "PrearedFunction", "preppedStatement", "perppedBody", "Preppedquery", "preppedQuery", "perparedStatement", "preparedFunction", "prearedStatement", "preparedStatement", "PreppedQu", "preplannedquery", "previsedBody", "peraredQuery", "perppedStatement", "preculatedQuery", "preplannedQuery", "prearedQu", "precedquery", "previsedQu", "Preparedquery", "prearedFunction", "preparedQu"], "date": ["log", "model", "index", "resource", "module", "change", "event", "form", "dat", "duration", "order", "grade", "open", "match", "version", "day", "age", "message", "use", "rate", "update", "style", "status", "string", "set", "Date", "stage", "d", "ate", "month", "type", "dt", "record", "year", "number", "bug", "start", "name", "data", "file", "document", "complete", "time", "tag", "db"], "format": ["letter", "unit", "html", "method", "printf", "prefix", "point", "prep", "form", "transform", "function", "pattern", "at", "filter", "parse", "atter", "parser", "process", "add", "table", "writer", "info", "replace", "Format", "struct", "style", "string", "scale", "class", "set", " formatted", "cut", "print", "export", "sort", "split", "handler", " Format", "join", "type", "wrap", "part", "and", "handle", "name", "report", "pretty", "term", " fmt", "data", "value", " formatting", "str", "dot", "time"], "orderDate": ["serverTime", "requestDat", "orderdate", " orderData", "OrderTime", "OrderDat", " orderDay", " orderDat", "requestDate", "OrderData", "orderTime", "orderDat", "OrderName", "serverdate", "orderName", "OrderDay", "requestDay", "serverDate", "requestName", "serverData", " orderTime", "orderData", "OrderDate", " orderName", "Orderdate", " orderdate", "orderDay"], "iterator": ["ident", "ski", "interstitial", "outer", "river", "walker", "storage", "stream", "inner", "done", "sequence", "step", "metadata", "atio", "gener", "entry", "inter", "ators", "parser", "slice", "random", "later", "writer", "finder", "consider", "driver", "set", "Iter", "selection", "engine", "collection", "creator", "vector", "path", "ater", "ie", "er", "adder", "pointer", "uri", "started", "oper", "it", "choice", "loop", "series", "context", "start", "loader", "runners", "init", "runner", "ter", "until", "wrapper", "former", "server", "header", "instance", "Iterator", "ator", "reader", "timer", "database", "iter", "enter", "you", "append", "starter", "holder", "processor"], "shoppingInfo": ["hoppingMeta", "hillingData", "shillingArea", "swopingArea", "shppingInf", "shopingInfo", "ShoppingInfo", "ShippingInfo", "shoppingArea", "shillingInf", "ShippingInf", "shppinginfo", "shoppingObj", "shoppingData", "hillinginfo", "hoppingId", "swopingInf", "shoutingInfo", "shoppingINFO", "hillingInfo", "shashingInfo", "shippingINFO", "shppingId", "swoppingObj", "shppingData", "swoppingInfo", "hillingInf", "shillingINFO", "ShoppingInf", "shppingMeta", "shillingInfo", "shashingId", "shppingInfo", "hoppingInf", "shopingInf", "hillingMeta", "shashinginfo", "shillinginfo", "shppingArea", "shopingData", "shopingArea", "shoutingInf", "shillingId", "ShippingINFO", "shopingObj", "shopingMeta", "shippingInf", "swopingObj", "swopingInfo", "shippingInfo", "shoppinginfo", "hillingId", "ShoppingINFO", "hoppingData", "shillingMeta", "shoppingMeta", "shppingObj", "shashingInf", "swoppingArea", "shoutingINFO", "swoppingInf", "shoppingId", "hoppinginfo", "shoppingInf", "hoppingInfo", "shillingObj", "shillingData"], "product": ["image", "model", "service", "resource", "module", "child", "production", "payment", "input", "order", "target", "property", "version", "filter", "process", "Product", "output", "object", "class", "pp", "pe", "position", "creator", "collection", "relation", "p", "type", "attribute", "company", "result", "client", "cart", "products", "user", "data", "seller", "band", "parent", "feature", "per", "contact", "config", "source", "project", "plugin", "copy", "processor"], "quantity": ["aquance", "compifier", "commentity", "authority", "authorality", "quantification", "primality", "compicity", "necessifier", "commentifier", "mentity", "quantifier", "primification", "aquality", "commentality", "necessation", "mentITY", "aquity", "necessity", "primation", "necessification", "aquicity", "primity", "compance", "mentifier", "compity", "quantality", "primifier", "quanticity", "compation", "authoricity", "authorance", "quantance", "commentITY", "quantation", "compification", "compality", "quantITY", "mentality", "primITY"], "cartInfo": ["cartInf", " cartSize", "frontInf", " cartData", "carInfo", "productObj", "carSize", "frontStyle", "carObj", " cartList", " cartStyle", " cartMeta", "frontObj", " cartInf", "cartMeta", "cartObj", "cartSize", "contactData", "productInfo", "carMeta", "contactInfo", "cartStyle", "productSize", "cartData", "productData", "frontMeta", "productInf", "cartList", " cartObj", "contactInf", "frontInfo", "carStyle", "contactList", "carInf"], "i": ["ini", "index", "oi", "chi", "hi", "phi", "cli", "ii", "list", "api", "info", "ui", "l", "ami", "ri", "pi", "c", "ic", "abi", "ati", "li", "ci", "p", "ie", "ani", "multi", "io", "si", "xi", "it", "uri", "v", "bi", "ai", "ip", "is", "init", "ori", "qi", "id", "e", "iu", "f", "vi", "n", "di", "I"], "productList": [" productSet", "resourceCollection", "pageGroup", "pageList", "configlist", "resourceSet", "cartlist", " productArray", "pageArray", "cartGroup", "productGroup", "resourceList", "productArray", "productCollection", "configCollection", "productlist", "cartArray", "configList", "configSet", "cartList", " productCollection", "resourcelist", "productSet", " productlist", " productGroup", "pagelist"], "components": ["comositories", "compategories", "supplements", "comparts", "compenses", "productonents", "commients", "pategories", "deponent", "comients", "depients", "commonent", "complements", "cproducts", " compenses", "carts", "comenses", "comonents", "conents", "ponents", "commonents", "supponents", "categories", "compositories", "productarts", " complements", "depositories", " compositories", "compients", "comlements", "suppenses", "comonent", "deponents", "productproducts", "compproducts", "pproducts", "suppositories", "commositories", "productategories", "parts"], "j": ["z", "_", "index", "jc", "o", "other", "Query", "this", "add", "area", "l", "b", "jp", "js", "update", "url", "Select", "sql", "Insert", "r", "Config", "k", "query", "ie", "p", "er", "v", "all", "ji", "where", "jj", "jo", " ii", "J", "id", "adj", "database", "ij", "n", "bj", "config", "f", "obj"]}}
{"id1": "17856064", "id2": "7122523", "code1": "    public static PersistencyParameters parse(String unitName) {\n        URL[] persistenceUnits;\n        try {\n            persistenceUnits = Classpath.search(\"META-INF/\", \"persistence.xml\");\n        } catch (IOException e) {\n            throw new Error(e);\n        }\n        Set classes = new HashSet();\n        for (int i = 0; i < persistenceUnits.length; i++) {\n            URL url = persistenceUnits[i];\n            try {\n                nu.xom.Builder b = new nu.xom.Builder(false);\n                Document d = b.build(url.openStream());\n                Nodes unitNodes = d.getRootElement().query(\"//p:persistence-unit\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                for (int j = 0; j < unitNodes.size(); j++) {\n                    Node unitNode = unitNodes.get(j);\n                    Element unitElt = ((Element) unitNode);\n                    String uName = unitElt.getAttributeValue(\"name\");\n                    if (!uName.equals(unitName)) continue;\n                    {\n                        PersistencyParameters parameters = new PersistencyParameters();\n                        Nodes classNodes = unitElt.query(\"//p:property\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                        for (int k = 0; k < classNodes.size(); k++) {\n                            Node classNode = classNodes.get(k);\n                            if (!(classNode instanceof Element)) continue;\n                            Element classElt = (Element) classNode;\n                            String elementName = classElt.getAttribute(\"name\").getValue();\n                            if (elementName.equals(\"eclipselink.jdbc.url\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setJdbcUrl(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.user\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBUserName(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.password\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBPassword(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.driver\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBDriverClassName(elementValue);\n                            }\n                        }\n                        return parameters;\n                    }\n                }\n            } catch (Exception x) {\n                x.printStackTrace();\n                throw new Error(x);\n            }\n        }\n        return null;\n    }\n", "code2": "    public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        InstanciaDelegate delegate = RegistroManager.recuperarInstancia(request);\n        if (delegate == null) {\n            ActionErrors errors = new ActionErrors();\n            errors.add(null, new ActionError(\"errors.session\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"fail\");\n        }\n        AyudaPantalla ayudaPantalla = delegate.obtenerAyudaPantalla();\n        TraAyudaPantalla traAyudaPantalla = (TraAyudaPantalla) ayudaPantalla.getTraduccion();\n        String urlSonido = traAyudaPantalla.getUrlSonido();\n        if (urlSonido == null) {\n            return null;\n        }\n        URL url = new URL(urlSonido);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.connect();\n        String tipoMime = urlConnection.getContentType();\n        log.debug(\"Tipo Mime: \" + tipoMime);\n        Map audioOptions = new HashMap();\n        if (tipoMime.indexOf(\"audio\") != -1 || tipoMime.indexOf(\"asf\") != -1 || tipoMime.equals(\"unknown/unknown\")) {\n            audioOptions.put(\"id\", \"MediaPlayer\");\n            audioOptions.put(\"codeBase\", \"http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,7,1112\");\n            audioOptions.put(\"classId\", \"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95\");\n            audioOptions.put(\"mimeType\", \"application/x-mplayer2\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/\");\n        } else if (tipoMime.indexOf(\"real\") != -1) {\n            audioOptions.put(\"id\", \"RVOCX\");\n            audioOptions.put(\"codeBase\", \"\");\n            audioOptions.put(\"classId\", \"clsid:CFCDAA03-8BE4-11cf-B84B-0020AFBBCCFA\");\n            audioOptions.put(\"mimeType\", \"audio/x-pn-realaudio-plugin\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"\");\n        }\n        request.setAttribute(\"audioOptions\", audioOptions);\n        log.debug(\"entra success\");\n        return mapping.findForward(\"success\");\n    }\n", "label": 0, "substitutes": {"parse": [" analyze", " params", " parsed", " assemble", " scan", " compile", " resolve", " execute", " test", " inspect", " analyse", " load", " ls", " validate", " parsing", " start", " read", " extract", " structure", " install", " parser", " check", " constructor", " process", " pars", " discover"], "unitName": ["uiType", "unitsNames", "unitsname", " unitname", "machineName", "machineType", " unit1", "uiName", "unitType", "units1", "UnitNames", "uiValue", " unitType", "unitValue", "unit1", " unitNames", " unitValue", "unitPath", "unitNames", "uiPath", "Unit1", "machineValue", "machinePath", "unitsName", " unitPath", "Unitname", "UnitName", "unitname"], "persistenceUnits": ["persistenceUnites", "persistenceClits", "persistanceUnites", "persistenceUNits", "persistanceUnit", "persistenceUNites", "persistenceLogits", "persistenceUnitits", "persistanceClites", "persistenceunites", "persistanceClits", "persistenceClites", "persistenceUNodes", "persistenceUnitodes", "persistanceUnitists", "persistenceUnitists", "persistenceOperit", "persistanceClITS", "persistenceUit", "persistenceUnitunits", "persistenceLogunits", "persistenceUnitITS", "persistenceunits", "persistanceUnodes", "persistenceOperites", "persistenceUnodes", "persistenceUnITS", "persistenceUNITS", "persistanceUnitites", "persistenceUnitions", "persistanceUnunits", "persistanceUnitITS", "persistenceUITS", "persistanceClitions", "persistanceUnitits", "persistenceUNitions", "persistenceUnunits", "persistenceUits", "persistenceLogists", "persistenceUnists", "persistanceUnitunits", "persistenceUnitites", "persistenceUnitit", "persistanceUnitit", "persistanceUnists", "persistenceClITS", "persistenceununits", "persistenceLogites", "persistenceOperodes", "persistenceUnit", "persistanceUnitodes", "persistanceUnits", "persistanceUnITS", "persistenceUites", "persistenceUnititions", "persistenceOperits", "persistenceUNit", "persistenceClitions", "persistenceunists", "persistanceUnitions"], "classes": ["resources", " protocols", "services", "properties", " constants", " assignments", "class", "set", " interfaces", "params", "groups", "ps", " tests", " groups", " suites", "result", " class", " Classes", " configurations", "Class", " formulas", "es", " models", " packages", "names", "results", " sources", " instances"], "i": ["z", "ini", "mi", "index", "in", "oi", "yi", "hi", "phi", "ii", "fi", "ix", "l", "info", "ui", "ri", "pi", "gi", "li", "ci", "p", "ie", "multi", "si", "ni", "xi", "bi", "uri", "v", "x", "ai", "ji", "eni", "y", "ip", "ori", "qi", "ti", "id", "iu", "u", "f", "n", "di", "I"], "url": ["image", "link", "plugin", "URL", "base", "resource", "in", "service", "Url", "ls", "entry", "up", "http", "filename", "href", "l", "api", "string", "element", "route", "path", "io", "uri", "xml", "ur", "name", "ssl", "location", "server", "data", "file", "user", "username", "sl", "connection", "config", "source", "web", "f", "address"], "b": ["wb", "base", "o", "br", "eb", "hub", "Builder", "l", "bb", "cb", "builder", "c", "gb", "lib", "r", "fb", "be", "bd", "p", "sb", "build", "v", "B", "bt", "pb", "bis", "a", "verb", "bs", "ob", "e", "rb", "n", "bc", "bh", "m", "db", "f", "obj", "ab", "library"], "d": ["dd", " D", "dc", "dat", "D", "dos", "l", "did", "c", "r", "g", "dom", "fd", "t", "ds", "p", "dt", "df", "director", "dir", "xml", "md", "data", "id", "pd", "e", "dm", "u", "dot", "n", "di", "dl", "m", "db", "f", "s"], "unitNodes": ["unitRenubes", "unitNoded", " unitNurs", "unitNeoded", "unitNobs", " unitNideos", "unitnoms", " unitnoms", "unitSnode", "unitnoded", " unitNoded", "unitDurs", " unitnurs", "unitnubes", "unitNeode", "unitSnodes", " unitnodes", "unitnideos", " unitnideos", "unitNurs", " unitNoms", "unitNeodes", "unitDodes", "unitSnoded", "unitnodes", " unitnode", "unitRenobs", "unitNoms", "unitRenodes", "unitnode", "unitNeoms", " unitNubes", "unitDideos", "unitRenoms", " unitNobs", "unitNubes", " unitnoded", "unitnobs", "unitNideos", "unitSnoms", "unitnurs"], "j": ["z", "aj", "jc", "fr", "q", "section", "kj", "syn", "jl", "jit", "je", "json", "ii", "obj", "key", "l", "ch", "jp", "js", "uj", "g", "job", "note", "p", "ie", "ni", "jen", "it", "ja", "v", "ji", "y", "dj", "jj", "qi", "h", "jet", "jo", "J", "u", "ij", "n", "bj", "br", "f"], "unitNode": ["UnitN", "unitsElement", "tunnode", "connectionPath", " unitElement", "unitsNode", "unitElement", "unitPath", "tunElement", " unitnode", "connectionNode", "tunNode", "connectionN", " unitN", "unitsName", "unitnode", "tunName", "connectionElement", " unitPath", "UnitNode", "UnitPath", "unitsnode", "UnitElement", "unitN"], "unitElt": ["unitNelt", "unitEslet", "unitEler", "unitOLT", "unitGeelt", " unitEelt", "unitEelt", "unitUlt", "unitELT", " unitELT", "unitIlt", "unitUlem", "unitGelt", "unitElem", "elementEslet", " unitUler", "unitext", "unitelem", "elementEslt", "unitelt", "unitGeLT", "unitOlt", " unitOld", " unitElem", "elementElt", "elementElet", "unitElet", "unitOelt", "unitGeld", "unitExt", " unitEld", "elementEelt", "uniteler", "unitNld", " unitOLT", "unitelet", "unitOlet", " unitUlem", "elementEld", "unitEsld", " unitExt", "unitNLT", "unitUler", " unitUlt", " unitOlt", "elementEselt", "elementEsld", "uniteld", " unitUxt", "unitUxt", " unitOelt", "unitIler", "uniteelt", "unitNlt", " unitEler", "unitEld", "unitEslt", "unitEselt", "unitIxt", "unitOld", "unitIlem"], "uName": ["uValue", " uValue", "duName", "suPath", "uPath", " uPath", " uNames", " uNode", "unitValue", "uNode", "duNames", "unitPath", "unitNames", "uname", "suname", "duValue", "duNode", "uNames", "suName", "unitname", " uname", "suValue"], "parameters": ["paramumers", "parels", "prometers", "arameter", "paramParameters", "paramseters", "paramsParameters", "peters", "persams", "pams", "persumers", "pareters", "promParameters", "paramams", "pumers", "params", "perseters", "aramels", "prometer", "arameters", "parumers", "paramseter", "promels", "parameter", "paramsels", "pels", "persels", "paramels", "aramParameters"], "classNodes": ["classNobs", "classVode", " classClements", "classCode", "classNeoded", "ClassNanks", "Classnoded", "classEoded", "Classnode", "fieldNode", "classNinode", "classNinobs", " classNoded", "classnoded", "classSnode", "classSnlements", "classSnoded", "fieldNODE", " classNlements", "classEode", "classNelements", "classNeode", "classVODE", "fieldNinobs", "Classnodes", "fieldNinodes", "Classnanks", "classnodes", "classNanks", "classNlements", "classNeodes", "ClassNodes", "classNinodes", "classEanks", "classnode", " classCodes", "ClassNode", "classSode", "fieldNinode", "fieldNinODE", "classEodes", "classCodes", "classVobs", "classVodes", "classSobs", "classClements", "classCoded", " classCoded", "classNinODE", "classnanks", "classSodes", "fieldNodes", "classNoded", "classSnodes", "fieldNobs", "classSODE", " classCode", "classNODE", "ClassNoded"], "k": ["z", "ek", "q", "kr", "kn", "unk", "ku", "ky", "sk", "w", "kat", "ik", "ke", "key", "ch", "km", "kk", "c", "r", "g", "ok", "work", "kick", "ck", "ad", "p", "v", "y", "kw", "K", "ko", "h", "dk", "id", "f", "ks", "n", "ki", "kid"], "classNode": ["busnode", " classSource", " classNs", "baseTree", "Classnode", "elementSource", " classFile", "elementTree", "classFile", "ClassFile", "fileTree", "fileRoot", "busNode", "elementRoot", "classRoot", " classElement", "configName", " className", "configSource", "elementElement", "classSource", "classNs", "elementNode", "ClassNs", "classnode", "fileNode", "ClassNode", " classnode", "busFile", "configNode", "baseNode", "busNs", "classElement", "baseElement", "configElement", "fileElement", "className", "baseRoot", "classTree"], "classElt": ["ClassOler", "elementeelt", "classXLT", "classYxt", "Classelt", "ClassOxt", "classXlt", "Classelem", "ClassEld", "Classeld", "classUelt", "classYelt", "elementeld", "classElem", "classUlem", "elementElt", "classUxt", "classeld", "elementEelt", "ClassXelt", "classEelt", "Classeelt", "classXxt", "ClassOld", "classeelt", "classYler", "classOld", "elementExt", "ClassOlt", "elementEld", "ClassEelt", "elementext", "classelem", "ClassExt", "classXld", "classExt", "classext", "ClassXLT", "ClassELT", "classELT", "ClassEler", "classOxt", "elementelt", "classXler", "classXelt", "ClassElt", "classelt", "classEler", "classOlt", "classEld", "classYlt", "classUlt", "ClassXlt", "ClassElem", "classYld", "classYlem", "classOler", "classUld", "ClassXld", "classeLT"], "elementName": ["articleName", " elementFamily", "layerApp", " elementname", "modulename", "typeFamily", "articleApp", "classValue", "articleFamily", "articleAnn", "elementFamily", "sectionFamily", "elementPath", "typeApp", "layerFamily", "elementname", "layerName", "elementAnn", "classname", "typeAnn", " elementFace", "layerAnn", "sectionName", "stringFace", "sectionFace", "moduleName", "classPath", "elementFace", "elementApp", "modulePath", "typeName", "stringName", "className", "stringFamily", " elementPath", "moduleValue"], "elementValue": ["objectvalue", "entryVALUE", "styleVALUE", " elementVal", " elementText", "objectValue", "optionString", "objectString", "optionVal", "stylevalue", "ElementVALUE", "memberValue", "entryvalue", "entryVal", "elementString", "optionvalue", "entryText", "objectVal", "optionValue", "memberVal", "elementVALUE", "Elementvalue", "ElementString", "ElementValue", "elementVal", "entryValue", "styleText", "elementvalue", "memberText", "ElementText", "styleValue", "elementText", "ElementVal", " elementVALUE", "memberVALUE"]}}
{"id1": "4599372", "id2": "8788371", "code1": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readFixString": ["readAdjustArray", "createFixedstring", "readfixContent", "readFixedString", "readfixstring", "readFixContent", "readFixedstring", "createFixArray", "createFixString", "createFixContent", "createFixedContent", "readfixString", "readFixedContent", "createFixstring", "readAdjustContent", "readAdjustString", "createFixedString", "readFixArray", "readAdjuststring", "readFixedArray", "createFixedArray", "readfixArray", "readFixstring"], "len": ["enc", "body", "lc", "base", "lit", "val", "lf", "count", "l", "list", "lp", "string", "code", "pos", "split", "li", "en", "line", "part", "Len", "le", "length", "size", "ln", "lt", "ll", "fn", "file", "e", "limit", "data", "str", "el", "i", "sl", "n", "loc", "f", "lin"], "sw": ["aw", "wb", "serv", "SW", "stream", "w", "sa", "WS", "fw", "zip", "wh", "writer", "ow", "bb", "ws", "null", "ew", "so", "sp", "wt", "wp", "wa", "sn", "wr", "wx", "iw", "sc", "fl", "io", "sb", "nw", "sh", "sv", "tw", "es", "ww", "sr", "lv", " SW", "wra", "sf", "Sw", "ss", "sl", "hw", "rw"]}}
{"id1": "3430784", "id2": "14038176", "code1": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"decodeBody": [" decodeFile", " decodedBody", "decodingFile", "decodePart", " decodedStream", "decodeFile", "decodesFile", " decodeStream", "decodeStream", "decodingBody", "decodedBody", "decodedPart", "decodesPart", " decodePart", " decodedFile", "decodesStream", "decodesBody", "decodedFile", " decodedPart", "decodingPart", "decodingStream", "decodedStream"], "in": ["ini", "image", "err", "body", "resource", "login", "config", "serv", "inner", "inn", "content", "gin", "input", "In", "version", "src", "load", "bin", "b", "conn", "url", "read", "c", "IN", "r", "session", "buffer", "again", "pass", "work", "source", "nin", "it", "cin", "min", "ins", "is", "into", "as", "loader", "init", "inas", "request", "ac", "inside", "con", "data", "id", "isin", "file", "ex", "i", "reader", "get", "win", "connection", "m", "din", "exec", "f", "socket", "inc"], "contentTransferEncoding": ["contentTransferEngearing", "contentTransferEcoding", "contentTransferEnearing", "contentTransferencording", "contentTransferCoding", "contentTransferAcosing", "contentTransferEngoded", "contentTransferEasing", "contentTransferEncearing", "contentTransferEnitting", "contentTransferEnording", "contentTransferEncryption", "contentTransferEcitting", "contentTransferCearing", "contentRestEnording", "contentPartEncoding", "contentTransferEnoded", "contentRestEncaming", "contentTransferEngoding", "contentTransferCasing", "contentPartEncoder", "contentTransferEnryption", "contentRestEncording", "contentTransferEncasing", "contentTransferEndasing", "contentTransferEncitting", "contentTransferCoded", "contentPartEasing", "contentTransferEncoded", "contentTransferCaming", "contentPartEryption", "contentPartEoder", "contentTransferEncording", "contentTransferCryption", "contentRestEnoder", "contentTransferCording", "contentRestEnaming", "contentTransferEoder", "contentTransferEnoding", "contentTransferEcaming", "contentTransferEndoded", "contentTransferEncosing", "contentTransferEosing", "contentTransferencoder", "contentTransferEnasing", "contentRestEncoding", "contentTransferEcoder", "contentPartEncasing", "contentTransferEngasing", "contentTransferEcording", "contentRestEnoding", "contentTransferAcasing", "contentTransferAcoding", "contentTransferEnoder", "contentTransferCoder", "contentTransferAcoder", "contentPartEncryption", "contentTransferEncoder", "contentTransferEoding", "contentTransferencoding", "contentTransferEnaming", "contentPartEoding", "contentTransferEndoding", "contentTransferEndoder", "contentTransferEnosing", "contentTransferencitting", "contentRestEncoder", "contentTransferEncaming", "contentTransferEryption"], "tempBody": ["tempFile", "outputLife", "tmpLife", "TempCore", "tempLife", " tempLife", "Tempbody", "tmpCore", "outputFile", "TempBody", " tempbody", "tmpBody", "tmpFile", "outputbody", "TempFile", " tempFile", " tempCore", "tempCore", "outputBody", "tempbody", "tmpbody"], "out": ["body", "err", "base", "o", "resource", "temp", "raw", "pool", "this", "inner", "channel", "cache", "sync", "output", "OUT", "bin", "writer", "conn", "object", "extra", "page", "null", "c", "again", "outs", "path", "line", "io", "Out", "client", "off", "app", "socket", "init", "ext", "a", "data", "file", "user", "parent", "ex", "i", "connection", "source", "exec", "obj", "copy"]}}
{"id1": "160739", "id2": "14390569", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createInputReader", "createInputStream", " createInputFile", "createOutputSteam", " createIOReader", "createInputFile", " createByteReader", " createByteStream", " createIOStream", " createOutputFile", " createIOFile", "createInputSteam", " createInputSteam", " createByteFile", " createIOSteam", " createOutputSteam", " createOutputReader", " createInputStream", "createInputReader", "createOutputReader", " createByteSteam", "createOutputFile"], "inFile": ["incFiles", "inputfile", "inStream", "inputStream", "insFiles", "outFiles", "inputFiles", "sourceFile", "sourcefile", "inputFile", "outStream", "insfile", "incfile", "incFile", "outfile", "insStream", "incStream", "inFiles", "infile", "insFile", "sourceFiles", "sourceStream"], "outFile": ["workingStream", "workTime", " outStream", "inputfile", " outDirectory", "outTime", "workfile", "workingfile", "inputDir", " outfile", "outDir", "workFile", "workingFile", "targetStream", "inTime", "outDirectory", "workingDirectory", "inputFile", "targetfile", "targetFile", "workDir", "outStream", "inputTime", "outfile", "targetDirectory", "inDir", "infile"], "k_blockSize": ["k_lockLength", "k_bitCount", "k_blockCode", "k_byteCount", "k_byteLength", "k_lockCode", "k_lockLen", "k_blocksSize", "k_blockLen", "k_BlockSize", "k_bitSize", "k_bitInfo", "k_lineSize", "k_lockCount", "k_BlockLength", "k_lineCount", "k_BlockCount", "k_byteLen", "k_blocksLength", "k_byteSize", "k_BlockCode", "k_blockInfo", "k_byteInfo", "k_blockLength", "k_blocksCount", "k_blockCount", "k_lockSize", "k_lineInfo", "k_blocksLen", "k_byteCode"], "byteCount": [" byteSum", " byteLen", "flushSize", "ByteSize", "ByteSum", "blockCount", " bytecount", "byteLen", "characterSize", "flushcount", "Bytecount", "byteLength", "flushLength", "blockLength", " byteSize", "byteSize", "characterLength", "byteSum", "bytecount", " byteLength", "characterCount", "ByteLen", "characterLen", "blockSum", "flushCount", "ByteLength", "blockSize", "ByteCount"], "buf": ["base", "cmd", "feed", "vec", "config", "flush", "feat", "src", "queue", "bag", "uf", "bytes", "b", "cb", "bh", "cap", "background", "font", "buff", "border", "buffer", "rc", "fd", "fb", "bf", "result", "Buff", "len", "img", "cas", "tmp", "alloc", "ucc", "la", "brace", "loc", "data", "cv", "rb", "ctx", "seq", "batch", "Buffer", "exc", "append"], "ofp": ["fort", "afl", "OFp", "OFnp", "OFl", "Oftp", "forp", "Ofc", "afnp", "Ofp", "OFtp", "ofl", "Ofnp", "OFt", "oft", "ofnp", "forc", "oftp", "afp", "Oft", "fortp", "afc", "ofc", "Ofl", "OFc"], "zos": ["z", "iffs", "zes", "zx", "ls", "lins", "oda", "liquid", "webkit", "zon", "tz", "zy", "nox", "forge", "bes", "os", "zers", "zl", "iframe", "rez", "modules", "zen", "fits", "los", "rons", "za", "kos", "gz", "uz", "zar", "ops", "zig", "bos", "hz", "nz", "packs", "ZA", "zn", "inos", "obs", "core", "outs", "zag", "ros", "ossus", "obb", "bitcoin", "dylib", "zona", "oses", "soon", "budget", "zi", "lol", "zb", "utils", "osi", "zip", "zyk", "ws", "ZI", "ogl", "zo", "abi", "ozo", "zik", "robe", "zh", "enos", "zer", "js", "cfg", "zin", "css", "cos", "ses", "owicz", "oS", "bs", "jas"], "osw": ["lswo", "eshell", "osy", "ossow", "osssw", "isnow", "osow", "ossww", "essw", "osswd", "oshell", "bwo", "isd", "eswd", "esow", "osnow", " osow", "osws", "ossfw", "esnow", "osd", " osfw", "issw", "esfw", "esy", "isw", "lsx", "osshell", "ossnow", "osfw", "esww", "esd", "bsws", " osww", "osx", "ossw", "ishell", "oswo", "oswd", "bws", "bsx", "iswd", "osww", "lsw", "bsw", "ossy", "lsws", "esw", "isy", "bx", "bswo", "ossd"], "bw": ["bbw", "Bw", "lw", "Bew", "lbsw", "bbwh", " bws", "bwe", "fr", "owa", "fbW", "bbaw", "oaw", "Bws", "bz", "fbw", "Bwa", "bbew", "abwe", "baw", "lbz", "abw", "fsw", "ebwe", "lbw", "owu", "fw", "fbwe", "bbz", " bew", "ow", "lbws", "ebW", "fwh", "fwa", "lbwh", "lx", "abwd", "ebw", " bwu", "lwa", "bwu", " bwa", "bew", " baw", "fx", "bws", "bwh", "fbwd", "bW", "bbwa", " bz", "lsw", "bwa", "lbwa", "bbwu", "bsw", "bwd", "ebwd", "bbws", "bx", "abW", "lbr", " bwh", "lbx"], "zot": ["zerott", "aziot", "jit", "zita", "zeros", "azor", "zerot", "zerori", "zerit", "azot", " ziot", "azott", "Zot", "zott", "Zott", "Zit", "ziot", "jot", "Zita", "jori", "Zor", "Ziot", "zor", "zori", "jos", "azit", " zori", "zerita", " zor", "azita"], "ifp": ["IFi", "ipb", " iff", "ifi", "Ifi", "ifb", "Ifc", " ifi", " ifl", "IFb", "IFf", "ipl", "IFl", "ifc", " ifb", "Iff", "ipc", "iff", "ifl", "ipp", "IFp", "IFc", "Ifp", " ifc"], "zis": ["jis", "zisi", " zib", "jisi", "jit", " zIS", "xits", " zisi", "zib", "zip", "xais", "xisi", " zits", "zenais", "zeis", "xit", "zenis", "Zis", "zenIS", "jits", "zipits", "zipiss", "xIS", "zeip", "Zits", "Ziss", "Zip", "zeiss", "xis", "zIS", "zeits", "xib", " zais", "zenib", "ziss", "zais", "zits", "zipip", "zipis"], "isr": ["irrc", "rispr", "iscr", "risr", "risrb", "ISrc", "ispr", "ISr", "isscr", " isrs", "issrs", "ISpr", "irr", " issr", "isrs", "irrb", "IScr", "isssr", "isrc", "ISrs", "isrb", "issr", "risrc", "irpr", " iscr", "ISsr", "ISrb"], "br": ["body", "err", "bsp", "lr", "fr", "kr", "HR", "bl", "arr", "cro", "ocr", "yr", " fr", "b", "ch", "ctr", "bp", "sp", "r", "ber", "gr", "tr", " dr", "ibl", "bro", "obl", "div", "Br", "ibr", "BR", "mr", "img", "rs", "hr", " BR", "bar", "sr", "rib", "ob", "browser", "str", "rb", " Br", "bc", "bh", "obi", "shr"], "zit": ["zith", "zite", "xic", "zeita", "zic", "jit", "zita", "zipith", "zipite", "zip", "zipIT", "zenits", "zenit", " zip", "zeIT", "jic", "jita", "zenith", " zits", "zitter", "jip", "zeitter", "xit", "jIT", "zipit", "zipita", "xi", "jite", " zi", " zic", " zite", "jits", "ji", "zipits", "zIT", "zipitter", "zenitter", "zeith", "zeits", "zeit", "xith", " zith", "jith", "zits", "zipip", "zi"]}}
{"id1": "7458833", "id2": "7908169", "code1": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"copyParseFileToCodeFile": [" copyParseFileToMapfile", " copyParseFiletoCodeClass", " copyParseFiletoOutputFile", " copyParseFileToOutputfile", " copyParseFiletoOutputfile", " copyParseFileTocodefile", " copyParseFileTocodeFile", " copyParseFileToOutputFile", " copyParseFiletoOutputFiles", " copyParseFiletoCodeFiles", " copyParseFileToMapFiles", " copyParseFileTocodeClass", " copyParseFileToOutputFiles", " copyParseFileToCodeFiles", " copyParseFileTocodeFiles", " copyParseFileToOutputClass", " copyParseFiletoCodeFile", " copyParseFileToCodefile", " copyParseFiletoOutputClass", " copyParseFiletoCodefile", " copyParseFileToCodeClass", " copyParseFileToMapClass", " copyParseFileToMapFile"], "in": ["ini", "err", "image", "kin", "login", "impl", "stream", "inner", "gin", "inn", "input", "In", "ls", "up", "bin", "read", "pin", "IN", "r", "again", "ic", "oin", "nin", "io", "cin", "min", "pull", "ins", "is", "lin", "as", "init", "inside", "con", "id", "rin", "i", "win", "reader", "n", "get", "m", "din", "f", "socket", "inc"], "out": ["err", "image", "log", "o", "outer", "other", "this", "inner", "w", "plain", "net", "up", "exp", "cache", "sync", "output", "OUT", "writer", "conn", "post", "bin", "again", "outs", "work", "source", "io", "Out", "client", "as", "ext", "server", "user", "file", "parent", "ex", "i", "one", "n", "inc", "exec", "socket"], "buffer": ["base", "shape", "wave", "feed", "raw", "capacity", "event", "sequence", "duration", "input", "channel", "available", "cache", "count", "total", "slice", "queue", "uf", "pad", "string", "read", "buf", "array", "null", "position", "buff", "padding", "fb", "uffer", "result", "number", "layer", "pause", "request", "server", "data", "reference", "document", "binary", "limit", "iter", "batch", "source", "Buffer", "address"], "length": ["repeat", "index", "shape", "feed", "end", "offset", "before", "point", "view", "sequence", "duration", "match", "Length", "load", "count", "total", "slice", "l", "full", "bb", "style", "string", "code", "position", "path", "line", "type", "part", "width", "len", "number", "row", "pull", "block", "character", "size", "start", "partial", "distance", "volume", "range", "id", "ob", "weight", "level", "limit", "lock", "value", "time", "ength", "url", "address"]}}
{"id1": "19050432", "id2": "17286898", "code1": "    private static InputStream openNamedResource(String name) throws java.io.IOException {\n        InputStream in = null;\n        boolean result = false;\n        boolean httpURL = true;\n        URL propsURL = null;\n        try {\n            propsURL = new URL(name);\n        } catch (MalformedURLException ex) {\n            httpURL = false;\n            propsURL = null;\n        }\n        if (propsURL == null) {\n            propsURL = UserProperties.class.getResource(name);\n        }\n        if (propsURL != null) {\n            URLConnection urlConn = propsURL.openConnection();\n            if (httpURL) {\n                String hdrVal = urlConn.getHeaderField(0);\n                if (hdrVal != null) {\n                    String code = HTTPUtilities.getResultCode(hdrVal);\n                    if (code != null) {\n                        if (!code.equals(\"200\")) {\n                            throw new java.io.IOException(\"status code = \" + code);\n                        }\n                    }\n                }\n            }\n            in = urlConn.getInputStream();\n        }\n        return in;\n    }\n", "code2": "                public void run() {\n                    BufferedReader reader = null;\n                    String message = null;\n                    int messageStyle = SWT.ICON_WARNING;\n                    try {\n                        URL url = new URL(Version.LATEST_VERSION_URL);\n                        URLConnection conn = url.openConnection();\n                        reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                        String latestVersion = reader.readLine();\n                        latestVersion = latestVersion.substring(latestVersion.indexOf(' ') + 1);\n                        if (!Version.getVersion().equals(latestVersion)) {\n                            message = Labels.getLabel(\"text.version.old\");\n                            message = message.replaceFirst(\"%LATEST\", latestVersion);\n                            message = message.replaceFirst(\"%VERSION\", Version.getVersion());\n                            messageStyle = SWT.ICON_QUESTION | SWT.YES | SWT.NO;\n                        } else {\n                            message = Labels.getLabel(\"text.version.latest\");\n                            messageStyle = SWT.ICON_INFORMATION;\n                        }\n                    } catch (Exception e) {\n                        message = Labels.getLabel(\"exception.UserErrorException.version.latestFailed\");\n                        Logger.getLogger(getClass().getName()).log(Level.WARNING, message, e);\n                    } finally {\n                        try {\n                            if (reader != null) reader.close();\n                        } catch (IOException e) {\n                        }\n                        final String messageToShow = message;\n                        final int messageStyleToShow = messageStyle;\n                        Display.getDefault().asyncExec(new Runnable() {\n\n                            public void run() {\n                                statusBar.setStatusText(null);\n                                MessageBox messageBox = new MessageBox(statusBar.getShell(), messageStyleToShow);\n                                messageBox.setText(Version.getFullName());\n                                messageBox.setMessage(messageToShow);\n                                if (messageBox.open() == SWT.YES) {\n                                    BrowserLauncher.openURL(Version.DOWNLOAD_URL);\n                                }\n                            }\n                        });\n                    }\n                }\n", "label": 0, "substitutes": {"openNamedResource": ["openNamedresource", "openNamingresource", "openParamedResources", "openNestedURI", "openNestedresource", "openParamedResource", "openNamingURI", "openNnamedresource", "openParamingResource", "openParamedURI", "openNamingResource", "openNamedURI", "openParamingresource", "openNamingResources", "openNamedResources", "openNnamedResources", "openNnamedResource", "openNestedResource", "openNestedResources", "openParamedresource", "openParamingResources", "openNnamedURI", "openParamingURI"], "name": ["base", "resource", "NAME", "prefix", "version", "filename", "key", "info", "full", "string", "class", "ame", "definition", "path", "Name", "type", "part", "uri", "named", "size", "word", "id", "file", "data", "sea", "username", "names", "str", "value", "old", "n", "source", "parent", "url", "address"], "in": ["kin", "err", "ini", "resource", "login", " out", "inner", "inn", "gin", "val", "input", "din", "In", "pc", "fc", "rec", "bin", "conn", "b", "pin", "r", "IN", "again", "token", "ic", "oin", "source", "nin", "edIn", "result", "cin", "out", "ins", "as", "socket", "ac", "thin", "con", "data", "rin", "i", "reader", "win", "get", "vin", "connection", "inc", "f", "url"], "propsURL": ["proopsURL", "probsUL", "perrsFile", "ProsUrl", "perrsurl", "prolsURI", "protsFile", "proopsUR", " propsurl", "PropsURL", "prodsURL", "propsURI", "propdsUrl", "perrsURL", "PropsUrl", "protsURL", "propsCL", "prosUL", "proppsLL", " propsUL", "prodsSSL", "proppsUR", "pronsLL", " prodsURL", "ProsSSL", "prorsUrl", "proppsUrl", "propsELF", "propsLL", "pronsUR", "proportsURL", "prolsurl", "propsFile", "probsUrl", "proportsurl", "prorsUR", "prorsurl", " propsSSL", " prodsurl", "progsurl", "protsurl", "progsURI", "propsurl", " propsURI", "prosUrl", "proportsURI", "prodsURI", "prorsURL", " prodsCL", " proportsUL", "propdsLL", " propsUR", "procsSSL", " proportsUrl", "procsURI", "perpsURL", "prosURI", "PropsSSL", " propsELF", "prorsFile", "propsSSL", "prodsLL", "PropsURI", "ProsURI", "proppsURL", " prolsURI", "proopsLL", "proportsLL", "prorsELF", " prolsURL", "prodsFile", "prodsCL", " propsLL", "probsLL", "perpsurl", "propsUrl", " proportsELF", " prolsurl", "prosURL", "prodsUrl", "procsurl", "prodsurl", "prolsURL", "proportsUrl", "propdsUR", "perpsFile", "procsURL", "proportsUL", "proopsUrl", "proportsELF", "pronsUrl", " prodsURI", "propsUL", "prodsUR", "prosLL", " proportsLL", "proopsURI", " propsUrl", "probsURL", "pronsURL", " proportsURL", "proportsUR", " proportsUR", "progsCL", "propsUR", "propdsURL", "proopsurl", "prolsSSL", "proopsELF", " prolsSSL", "proopsCL", "progsURL", "procsUrl", "prosSSL", " propsCL", "ProsURL", "proportsSSL"], "urlConn": [" urlCond", "sslCond", "urlconn", "URLContext", "URLConnect", "URLConn", "httpConf", "urlContext", "urlConf", "fileCmd", "urlCond", "sslConn", "fileConnect", "fileConn", "fileCond", "httpConn", "httpContext", "sslCod", "httpConnect", " urlCod", " urlConnect", "URLConf", "urlCmd", " urlContext", " urlConf", " urlconn", "sslCmd", " urlCmd", "urlConnect", "httpconn", "httpCod", "sslconn", "urlCod", "sslConnect"], "httpURL": ["HttpML", "httpsURI", " httpurl", "autoSSL", "HttpUR", "autoURL", "autourl", "apiUrl", "autoUrl", "HttpURI", "httpurl", "httpsUR", " httpUrl", "apiURL", "httpsSSL", " httpUR", " httpML", "httpsURL", "apiML", "httpURI", "httpsurl", "HttpUrl", "httpML", "apiUR", " httpSSL", "HttpURL", "httpUrl", " httpURI", "httpsUrl", "httpSSL", "httpUR"], "hdrVal": ["hheaderVol", "hndDef", "hdval", "hndVal", "hreqStr", "hrValue", "hdrval", "hheaderStr", "hdrStr", "hhrDef", "hhrBu", " hheaderStr", "HdrBu", "hreqVal", "hheaderVal", "HhrDef", "Hhrval", " hdrStr", " hheaderValue", "hDRValues", "hdrValue", "HdrDef", "hdVal", "hrStr", "hrcValue", "HdrVal", " hdrVol", "hrVol", "HhrValue", "hdrDef", "hhrval", "hdrValues", "hrcDef", "HhrVal", "hndValue", "hdrVol", "Hdrval", "hDRVal", "hdValues", "hreqVol", " hheaderVol", "hdValue", "hhrValues", "hrcBu", "hndBu", "hheaderValue", "HdrValue", "hdrBu", "hrcVal", " hheaderVal", "hhrValue", "hDRval", "hreqValue", "HdrValues", "hhrVal", "hDRValue", "HhrValues", "HhrBu", "hrVal", " hdrValue"], "code": ["rule", "index", "ode", "coded", "codes", "content", "check", "grade", "expected", "pc", "version", "reason", "age", "zip", "message", "count", "text", "mode", "key", "rate", "info", "charge", "cat", "status", "string", "c", "pe", "class", "ack", "state", "core", "rc", "cod", "success", "ie", "type", "line", "result", "fail", "Code", "number", "ce", "response", "xx", "cc", "see", "zone", "test", "co", "ge", "data", "id", "score", "const", "e", "category", "level", "go", "comment", "desc", "error", "one", "value", "no", "ec", "msg", "url", "header"]}}
{"id1": "5760649", "id2": "14785308", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"createFile": [" createResource", "CreateContent", "CreateFolder", " createFolder", "CreateFile", "createContent", " createContent", "createResource", "createFolder", "saveContent", "CreateResource", "saveFile", "saveFolder", "saveResource"], "src": ["resources", "resource", "stream", "Source", "content", "input", "load", "slice", "href", "ruby", "cb", "url", "string", "txt", "buf", "gb", "files", "r", "rc", "path", "rob", "sc", "upload", "uri", "sb", "proc", "SourceFile", "dest", "img", "fp", "sit", "secure", "name", "ssl", "sel", "data", "file", "fn", "username", "rss", "sl", "rb", "loc", "source", "obj", "s"], "filename": ["wb", "resource", "prefix", "dll", "metadata", "acl", "which", "feat", "output", "l", "utf", "string", "txt", "ame", "files", "ames", "route", "path", "fil", "Filename", "source", "uri", "SourceFile", "fp", "ename", "FILE", "length", "loader", "name", "title", "nil", "file", "fn", "sf", "username", "s", "rl", "location", "f", "url", "directory"], "fis": ["sfos", "Fais", " fIS", "cfais", "cfris", " fbs", "cfis", "cfIS", "fais", "sfiss", " fiss", "Fbs", "Fos", "Fis", " fais", "cfos", "fris", "fIS", "Fiss", "sfris", "fiss", "sfis", "fbs", "FIS", "Fris", "cfbs", " fris"], "fos": ["fios", "sfios", "sfos", " fops", "fOS", "affis", "Fas", "Fbos", "bos", "Fios", " fios", "foras", "FOS", "bbos", "fbos", "foros", " fas", "Fos", "Fis", "affios", "bis", "sfis", "fops", "Fops", "affbos", "foris", "affos", "sfops", " fOS", "fas", "bios", "forOS"]}}
{"id1": "19494842", "id2": "693636", "code1": "    private void callService() {\n        try {\n            URL url = new URL(baseUrl + servicePath + attributes);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            StringBuffer buf = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                buf.append(inputLine);\n            }\n            in.close();\n            answer = buf.toString();\n        } catch (MalformedURLException e) {\n            answer = \"Malformed Url:\" + e.getMessage();\n            return;\n        } catch (IOException e) {\n            answer = \"I/O exception: \" + e.getMessage();\n            return;\n        }\n    }\n", "code2": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "label": 0, "substitutes": {"callService": [" callServices", "testService", "Callservice", "callProxy", "callServices", "CallService", "CallServices", " callProxy", "CallProxy", "testServices", "callservice", "testservice", "testProxy", " callservice"], "url": ["log", "URL", "base", "service", "resource", "feed", "this", "stream", "Url", "json", "open", "http", "queue", "l", "b", "conn", "string", "r", "path", "uri", "client", "blog", "ur", "ssl", "server", "user", "file", "ll", "host", "e", "sl", "i", "connection", "source", "web", "f", "socket", "address"], "in": ["re", "err", "kin", "ini", "image", "login", "impl", "stream", "gin", "inner", "inn", "input", "In", "bin", "b", "c", "r", "IN", "buffer", "again", "fb", "doc", "source", "line", "out", "client", "ins", "is", "into", "lin", "init", "ssl", "h", "data", "file", "id", "reader", "i", "win", "din", "f", "socket", "inc", "s"], "inputLine": ["InputLine", "streamFrame", "outputRow", "inputValue", "readline", "Inputline", "readLine", "requestString", "outputline", " inputL", "outputValue", "inputline", "readRow", " inputValue", "InputL", "InputFrame", " inputFrame", "streamLine", "inputFrame", "requestL", "inputRow", " inputRow", "outputLine", "inputString", " inputline", "inputL", "requestLine", "readValue", "InputString", "requestline", "streamString", " inputString", "streamline"], "buf": ["log", "wb", "base", "conv", "pool", " buffer", "nb", "coll", "fun", "abs", "exc", "aux", "ff", "cache", "queue", "bag", "uf", "b", "cb", "bb", "bh", "pad", "string", "builder", "array", "gb", "buff", "cf", "buffer", "Buffer", "fb", "result", "sb", "fp", "cas", "context", "pb", "bu", "data", "cv", "binary", "af", "ob", "header", "rb", "pkg", "bc", "bf", "ctx", "br", "db", "f", "append", "ab"], "answer": ["reply", "question", "site", "prefix", "side", "fix", "order", "entry", "blank", "cache", "message", "swers", "update", "status", "option", "array", "say", "session", "sn", "settings", "attribute", "result", "ask", "uri", "su", "issue", "response", "name", "word", "search", "server", "answered", "knowledge", "Answer", "username", "description", "empty", "stuff", "complete", "value", " answers", "install", "address"]}}
{"id1": "3756429", "id2": "11645260", "code1": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"scramble": [" scrambler", "screamble", "scroubling", "scrouble", " scrambling", "scroubler", "scrambles", "screambling", " screamble", "scrambler", "screambles", " screambling", "scroubles", "screambler", " screambles", " scrambles", "scambler", "scamble", "scrambling", "scambles", "scambling", " screambler"], "text": ["body", "letter", "image", "in", "config", "content", "input", "pattern", "message", "output", "password", "bytes", "texture", "object", "struct", "string", "txt", "code", "class", "TEXT", "buffer", "Text", "token", "path", "out", "secret", "name", "test", "ext", "word", "data", "binary", "username", "str", "source", "obj", "editor"], "md": ["dd", "cmd", "bm", "am", "metadata", "amd", "ma", " MD", "um", "hd", "mm", "mad", "cd", "wd", "mp", "bb", "vd", "ms", "mn", "grad", "mand", "d", "ind", "bd", "ad", "pm", "df", "sm", "mt", "mac", "gd", "od", " Md", "cm", "MD", "mod", "dh", "pd", "mag", "rm", "dm", "mc", "f", "mb", "hm", "di", "m", "rpm", "db"], "sb": ["ib", "wb", "nb", "bsp", "kb", "bm", "eb", "SB", "ls", "sa", "xb", "src", "sync", "bb", "cb", "bh", "usb", "bp", "buf", "gb", "buffer", "fb", "lb", " SB", "bd", "obb", "su", "sg", " eb", "erb", "pb", "bt", "ssl", "sr", "bs", "binary", "ob", "sf", "rb", "mb", "bc", "bf", "BB", "db", "ab", "s"], "b": ["body", "base", "nb", "eb", "bot", "beta", "l", "bb", "cb", "object", "bytes", "bin", "c", "machine", "buffer", "d", "fb", "be", "boot", "p", "bd", "B", "block", "orb", "pb", "bis", "a", "bs", "binary", "ob", "i", "rb", "mb", "bf", "br", "db", "f", "obj", "ab"]}}
{"id1": "11183087", "id2": "8665649", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    private BufferedImage _getImage(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.connect();\n        InputStream in = null;\n        try {\n            in = conn.getInputStream();\n            return ImageIO.read(in);\n        } finally {\n            IOUtilities.close(in);\n        }\n    }\n", "label": 0, "substitutes": {"doPost": ["doPOST", "handleSearch", "doingPost", "handlePOST", "handlePost", "doingPOST", "handlePut", " doSearch", "doingPut", "doSearch", "doPut", " doPut", "doingSearch", " doPOST"], "request": ["image", "model", "right", "resource", "q", "create", "child", "view", "current", "event", "forward", "input", "order", "project", "req", "http", "message", "have", "use", "rate", "queue", "info", "post", "QUEST", "object", "remote", "application", "rf", "pe", "r", "initial", "route", "subject", "external", "state", "buffer", "query", "join", "Request", "er", "hello", "type", "result", "frame", "pull", "client", "context", "xml", "report", "the", "server", "user", "data", "e", "call", "parent", "instance", "error", "press", "web", "complete", "enter", "get", "config", "url"], "response": ["onse", "body", "model", "pool", "resource", "site", "view", "Response", "http", "message", "output", "api", "writer", "respond", "object", "page", "status", "application", "resp", "next", "result", "client", "report", "server", "document", "guide", "parent", "results", "res", "connection", "template", "web", "reply"], "senha": ["renha", "senwa", " senwa", "senlah", "zenha", "senhi", "tonHa", "zenca", " senca", "sanwa", "tonwa", "renaka", "zenhi", "sensha", "senla", "tonlah", "senaka", "suithi", " senaka", "sanha", "tonha", "snha", " senHa", "snsha", "suitsha", "zenHa", "zensha", "suitha", "zenaka", "sanHa", "sanlah", "suitla", "senca", "renca", "senHa", "zenla", "renHa", "snla", " senlah", "snhi"], "email": ["letter", "model", "mail", "service", "login", "office", "account", "Email", "mobile", "alias", "zip", "message", "label", "password", "environment", "home", "string", "example", "hello", "phrase", "line", "secret", "ip", "xml", "business", "name", "language", "server", "data", "file", "id", "user", "e", "username", "fax", "url", "address"], "messageDigest": ["messageDigher", "messageDest", "messageDigester", "messageMailester", " messagedigEST", "messageDher", "meDigEST", "messageDigEST", "messagedigend", "meDigester", "messageMailest", "medigEST", "messageMailEST", "medigher", "medigester", " messagedigester", " messageDigester", "meDigest", "medigest", " messageDend", " messageDest", "messageDend", "messageDester", "messagedigEST", "messagedigher", " messageDigend", " messageDEST", "meDigher", " messagedigest", "messagedigester", "messageDigend", "messageDEST", "messageMailend", " messageDester", "messagedigest", " messageDigEST"], "usuario": ["suuario", "usuarium", "ususariat", "usuillo", "ussuario", "ussuasio", "usueillo", " usuarium", " usuasio", "usguillo", "usituario", " usuiasio", "ususarius", "ussuarium", " usuiarium", "ususillo", "sulurio", "usuariat", " ususillo", " usuariat", "usueario", "usguarius", "usueariat", " usuarius", "usluario", "usuitario", "usuearius", " usuiario", "usuitasio", "usituarial", "usuitrio", "usguario", " usuirio", "uslurio", " ususariat", "usuarial", "suluasio", "usuarius", "usluasio", "usuiarium", "suuasio", " usuillo", "usuirio", "usuitarium", "usuiasio", "suurio", "usluarial", "usguariat", "suluarial", " usurio", "usuiario", "usurio", " ususario", "ussurio", "usuasio", "ususario", " ususarius", "suuarial", "usituasio", "ussuarial", "suluario", "usiturio"], "redirect": ["Redurl", "redrict", "predirection", "indirect", "predroute", " redition", "Redrict", "Redition", "predirect", "redirection", " redRECT", " redurl", "preduce", "Redroute", "Redirect", "RedRECT", " redirection", "induce", " reduce", "edurl", "indrict", " redrict", "reroute", "edirection", "predrict", "edition", "Redirection", "reirection", "redRECT", "rerict", "reirect", "reduce", "redroute", "predRECT", "edirect", "redition", "redurl", "indirection"], "session": ["image", "service", "child", "system", "site", "storage", "view", "event", "input", "group", "http", "message", "cache", "use", "info", "object", "page", "sp", "flash", "state", "query", "node", "result", "ession", "client", "cookie", "Session", "app", "sid", "ssl", "proxy", "server", "data", "user", "document", "browser", "comment", "sl", "person", "connection", "config"]}}
{"id1": "7872659", "id2": "9805906", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndmovieindexfile", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndmovieIndexfile", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndMovieIndexPath", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndMovieindexPath"], "completePath": [" completeCh", "iteCh", "completeCorp", "progressPath", "CompleteDir", "donePath", "completeLoader", " completepath", "doneVol", "CompleteHome", "execPath", "flatCorp", "flatPath", " CompletePath", " completeFile", "completeCh", " completeCorp", "correctRoot", "progressLoader", "completePoint", "correctPoint", " CompleteHome", "completeVol", "doneLoader", " completeHome", "completepath", "successMusic", " completeDir", "flatRoot", "successpath", "CompleteFile", " completePoint", "successCh", "completeHome", " CompleteFile", "execpath", "itepath", "completeMusic", "CompletePath", " completeRoot", "iteMusic", "successPath", " CompleteDir", "progressVol", "itePath", "execVol", "correctCorp", "donepath", "completeFile", "progresspath", " completeMusic", "completeRoot", "flatPoint", "completeDir", "execLoader", "correctPath"], "masterFile": [" masterPath", "mastersFILE", "MasterFiles", "MasterFILE", " masterFilename", "MasterFilename", "configFilename", "cacheFILE", "cacheFiles", "configName", "configPath", "MasterFile", "configFile", "MasterName", "cacheFile", "masterName", "masterFILE", "masterFilename", "mastersFiles", "masterFiles", "mastersFile", "mastersPath", "cachePath", " masterName", "masterPath", "MasterPath"], "CustRatingFileName": ["CustIndexFilesPath", "CustRatingFileDesc", "CustIndexFilesType", "CustRateFileName", "CustRatingFilesDesc", "CustRatingFileSize", "CustRateFilenameDesc", "CustRatingClassVersion", "CustRateFilenameName", "CustRatingFilenameName", "CustRatingFilesSize", "CustRatingFullSize", "CustIndexFileType", "CustRatingFilesType", "CustRatingClassType", "CustRateFileSize", "CustRatingFullName", "CustRateFilePath", "CustRatingLineType", "CustIndexFilesName", "CustRatingFullDesc", "CustRateFileDesc", "CustIndexFilesVersion", "CustRatingFilesVersion", "CustRatingFileVersion", "CustRatingFilenamePath", "CustIndexFilePath", "CustRatingLineVersion", "CustRatingFilesPath", "CustRatingFullPath", "CustRatingFilePath", "CustRatingFilenameSize", "CustIndexFileVersion", "CustRateFilenamePath", "CustIndexFileName", "CustRatingFileType", "CustRatingClassPath", "CustRatingLineName", "CustRatingLinePath", "CustRatingFilesName", "CustRatingClassName", "CustRatingFilenameDesc", "CustRateFilenameSize"], "MovieIndexFileName": ["MovieIndexFolderVersion", "MovieIndexFileUrl", "MovieIndexFilename", "MovieConfigFolderVersion", "MovieConfigFileName", "MovieIndexPlaceFile", "MovieEditFSize", "MovieIndexFname", "MovieIndexClassname", "MovieIndexClassName", "MovieIndexFileFile", "MovieIndexFUrl", "MovieEditFName", "MovieIndexFilesname", "MovieIndexClassUrl", "MovieIndexFileSize", "MovieIndexPlaceVersion", "MovieEditFilename", "MovieConfigFolderName", "MovieIndexFSize", "MovieConfigFileFile", "MovieIndexPlaceHandle", "MovieIndexFolderHandle", "MovieConfigFileVersion", "MovieConfigFileHandle", "MovieIndexFileHandle", "MovieEditFUrl", "MovieIndexFilesSize", "MovieIndexFilesName", "MovieIndexClassSize", "MovieEditFileName", "MovieIndexFILEVersion", "MovieIndexPlaceName", "MovieEditFname", "MovieIndexFolderName", "MovieConfigFolderFile", "MovieIndexFileVersion", "MovieIndexFolderFile", "MovieIndexFName", "MovieConfigFolderHandle", "MovieEditFileUrl", "MovieIndexFILEFile", "MovieEditFileSize", "MovieIndexFILEName", "MovieIndexFILEHandle", "MovieIndexFilesUrl"], "inFile": ["outFile", "inputfile", "incSourceFile", "InFile", "inputF", "InF", "inF", " inSourceFile", "outSourceFile", "InSourceFile", "outC", "inputFile", "inputSourceFile", "inSourceFile", "incfile", "incFile", "outfile", " infile", "infile", " inF", "incC", "Infile"], "inC": ["outCC", "innerC", "inCC", "outCL", "inputCC", " inCC", "InCI", "outFile", " inB", "InB", "inputC", "InFile", "inputF", "InF", "inF", "inB", "outC", "inputFile", "outCI", " inCL", "inCI", "InCC", "InCL", "InC", "inCL", "innerCC", "innerFile", "outB", "outF", " inF", "innerCI"], "outFile1": ["outFiles2", "outputfileId", "outPlace2", "outFId", "outputFileId", "outfile2", "outfileId", "outPlaceId", "againC1", "outF2", "outfileName", "outputfile2", "outFileName", "outPathFirst", "outCFirst", "outFiles3", "outputFile2", "outPath2", "againC3", "outfile1", "outFiles1", "outFilesFirst", "againFile1", "outFileId", "againFileFirst", "outF1", "outputFile1", "outPath3", "outC3", "outFile3", "outPath1", "outPlaceName", "againCFirst", "outputfileName", "outPlace1", "againFile3", "againC2", "outputFileName", "outFileFirst", "againFile2", "outputfile1", "outFName"], "outC1": ["outB8", "againC1", "outCOne", "newcOne", "outD2", "outF2", "againB2", "againC8", "outCFirst", "outD81", "outC81", "newCOne", "outF8", "outCF1", "againB8", "newc1", "outC8", "newC81", "outCF81", "outB2", "outF1", "outc1", "newcFirst", "outB1", "againB1", "outc81", "outCFFirst", "newc81", "againCOne", "againBOne", "outFOne", "outcFirst", "outD8", "againC2", "outCFOne", "outDOne", "outcOne", "outD1", "outBOne", "newCFirst", "outDFirst", "newC1"], "outFile2": ["outFiles2", "outputfileTwo", "againLine2", "outChannelTwo", "outfile2", "outFile6", "outfile5", "outDirectory5", "outputfile2", "outDirectory4", "againFileTwo", "outfile4", "againLineTwo", "outLineTwo", "againLine1", "outFiles5", "outputfile4", "outputFile2", "outputFile4", "outFile4", "outFile5", "againFile6", "outFiles1", "outputfile5", "outFilesTwo", "againFile1", "outfileTwo", "outChannel6", "outDirectory2", "outFiles4", "outputFileTwo", "outChannel1", "outChannel2", "outFileTwo", "outDirectoryTwo", "outLine1", "outLine2", "againLine6", "againFile2", "outputFile5", "outFiles6", "outLine6"], "outC2": ["againC1", "outCache2", "outCacheII", "outB4", "outF2", "againB2", "outCTwo", "OutF4", "outCache1", "outF4", "OutF1", "OutFII", "OutCII", "outFile4", "outFTwo", "OutC4", "outB2", "outFileII", "outF1", "outCache4", "OutC1", "againB4", "outB1", "againB1", "outC4", "againC4", "outFileTwo", "againBTwo", "outCII", "OutF2", "OutC2", "outFII", "outBTwo", "againC2", "againCTwo"], "fileSize": ["bufferSize", "resourceAddress", "bufferLength", "FileSIZE", "fileMode", "fileAddress", "imageLength", "FileAddress", "resourceSIZE", "bufferMode", "FileMode", "fileLength", " fileLength", " fileAddress", "resourceSize", "imageSIZE", " fileSIZE", "FileSize", "imageSize", "FileLength", " fileMode", "fileSIZE"], "totalNoDataRows": ["totalNoDataLows", "totalNoPageROWS", "totalNoDataChOWS", "totalNoDataLOWS", "totalNoDataCrows", "totalNoDataCows", "totalNoDataChows", "totalNoDataLrows", "totalNoDataChrows", "totalNoDataCOWS", "totalNoPageRrows", "totalNoDataChues", "totalNoDataCues", "totalNoPageLues", "totalNoPageLOWS", "totalNoDataRrows", "totalNoPageRues", "totalNoDataROWS", "totalNoDataRues", "totalNoPageLows", "totalNoPageLrows", "totalNoDataLues", "totalNoPageRows"], "mappedBuffer": ["Machedbuffer", "mppedBuffer", "mappedURL", "mactedbuffer", "mapedBuffer", "MappedBuffer", "MachedStream", "MachedBuffer", "mappingbuffer", "MappingBuffer", "mappingFile", "Mappedbuffer", "MachedFile", "mippedStream", "mashedFile", "mashedChannel", "machedFile", "mappingChannel", "mapedStream", "machedBuffer", "MachedChannel", "MappingFile", "MappingChannel", "MappedStream", "mactedBuff", "machedStream", "mashedBuffer", "MappedChannel", "MappingBuff", "mappingBuffer", "mippedURL", "mapedFile", "mappedStream", "mppedChannel", "mippedBuff", "mapedURL", "mashedBuff", "mppedBuff", "machedChannel", "machedbuffer", "mappedBuff", "MappedBuff", "MachedURL", "mppedStream", "mappingBuff", "mippedBuffer", "mappingStream", "mapedBuff", "mactedStream", "mappedChannel", "MappedURL", "mactedBuffer", "MappedFile", "mappedbuffer", "machedBuff", "MachedBuff", "mappedFile", "machedURL"], "startIndex": ["useindex", " startindex", "endRow", "stopindex", " startRow", " startPosition", "StartPosition", "endIndex", " startOffset", "useInfo", "stopCode", "startingPosition", "stopIndex", " startCode", "startSection", "startingPoint", "useIndex", "startPoint", "StartOffset", "stopRow", "StartIndex", "endPosition", "endPoint", "initOffset", "initIndex", "endindex", "endInfo", "startInfo", "usePosition", "endCode", "startOffset", "startindex", "startPosition", "Startindex", " startPoint", "StartInfo", " startInfo", "startingSection", " startSection", "startRow", "initindex", "startingIndex", "endSection", "startCode", "initInfo"], "count": ["force", "index", "pool", "child", "other", "depth", "found", "self", "coll", "current", "order", "find", "group", "cache", "add", "total", "key", "list", "code", "c", "more", "ind", "type", "part", "counter", "allow", "len", "all", "number", "loop", "first", "length", "start", "size", "close", "name", "test", "col", "sum", "keep", "id", "follow", "weight", "call", "limit", "thread", "i", "Count", "old", "time", "max"], "currentMovie": ["currentImage", "currentPicture", "currentlyMovie", "defaultFilm", "currentmovie", "CurrentTheme", "defaultImage", "parentPicture", " currentFilm", "validTheme", "reportedTheme", "CurrentFilm", "validFilm", "thisMovie", "Currentmovie", "parentFilm", "currentlyMusic", "defaultMusic", " currentMusic", "reportedMusic", "validmovie", "CurrentMovie", "currentMusic", "currentlyPicture", "reportedmovie", "thismovie", "currentFilm", "defaultMovie", "reportedMovie", " currentImage", "currentTheme", "thisFilm", " currentPicture", "thisPicture", "parentmovie", "reportedPicture", "validMovie", " currentmovie", "reportedFilm", "reportedImage", "parentMovie"], "movieName": ["filmname", "camName", "voiceInfo", "filmNumber", "movieId", "moneyName", " movieId", "MovieNumber", "voiceName", "voicename", " moviename", "Moviename", "filmName", "camFamily", "MovieId", "camname", "moviename", "moneyNumber", "movieNumber", "MovieFamily", " movieFamily", "MovieInfo", " movieInfo", "movieFamily", "voiceId", "MovieName", "movieInfo", "filmFamily", "moneyFamily"], "customer": ["ustomers", "customeri", "Customer", "mixer", "mixers", " customER", "Customor", "Customers", "ustomER", "customers", "mixor", "ustomer", "ustomor", "mixER", "CustomER", "customor", " customers", "Customeri", "customER", "ustomeri", " customeri"], "rating": ["writing", "resource", "rice", "ing", "RC", "rates", "alpha", "http", "reading", "rate", "writer", "info", "ruby", "packing", "including", "string", "setting", "r", "rc", "rage", "padding", "rated", "type", "attribute", "rr", "number", "Rating", "missing", "ring", "id", "data", "range", "score", "radius", "ranking", "value", "comment", "reader", "feature", "error", "rank", "rolling", "url"], "outBuf1": ["outFaf1", "outKbuffOne", "outBuf11", "outKbuf1", "outBbuff1", "outBum1", "outKuf8", "outBbufn", "outBafCloud", "outBum91", "outFuf01", "outDuff3", "outKbuff1", "outBalth3", "outBuf01", "outBuff8", "outFufOne", "outBuff2", "outKuf3", "outCuf1", "outKbuf3", "outDuf3", "outFufCloud", "outBuff3", "outBuff1", "outBiff91", "outBaftn", "outBuf91", "outDuf1", "outBuf0", "outFuf1", "outBuffCloud", "outDufn", "outBafOne", "outBuf8", "outBummerOne", "outFafCloud", "outKbuff8", "outBaf1", "outBufCloud", "outBbuff0", "outKuf2", "outBiff01", "outFbufOne", "outBbuff8", "outBaft3", "outCufOne", "outBum01", "outBuf3", "outBaf0", "outBufOne", "outBaft11", "outCuff1", "outBummerCloud", "outBuffOne", "outBbuf01", "outBbuffOne", "outBbufOne", "outKufOne", "outBiffOne", "outBummer1", "outBuff11", "outCuf0", "outFbuf01", "outBbuf3", "outCuff0", "outBbuf91", "outBiff1", "outBbuf1", "outBbuf11", "outBbuff3", "outKuf1", "outKbuff3", "outBaft1", "outBalth2", "outFuf91", "outBaf8", "outDuff1", "outKbuf2", "outCuffOne", "outDuffn", "outDuf11", "outBaf3", "outBalth1", "outBbuf2", "outBumOne", "outDuff11", "outBufn", "outBuffn", "outFbuf1", "outFafOne", "outBuff0", "outFbuf91"], "outBuf2": ["outFbuff4", "outBbuff1", "outWBuf0", "outBbuffTwo", "outFuf12", "outBbuff82", "outFuf20", "outBbufferB", "outWBuf200", "outBait4", "outBuff8", "outBuff2", "outBufB", "outBuff1", "outFufTwo", "outBoffTwo", "outBbuff4", "outBuber82", "outBbufTwo", "outBuff12", "outBuf0", "outFuf1", "outBait8", "outFbufB", "outWBuf4", "outBuf8", "outFbuff82", "outWBbuff2", "outFbuf4", "outFbuff20", "outWBufTwo", "outBbuff0", "outBbuff8", "outBuffTwo", "outBuf4", "outWBuff8", "outWBuf2", "outBaitTwo", "outWBbuff200", "outBbuff20", "outBbufB", "outBbuf4", "outFbuff8", "outBum82", "outWBuff4", "outBbuffer2", "outBuber8", "outWBuff2", "outBuf20", "outFuf82", "outBum8", "outBait0", "outBufTwo", "outBum2", "outFbuffTwo", "outWBbuff8", "outBbuff2", "outBum20", "outBuf82", "outBuf12", "outBbuffer12", "outFuf2", "outWBuf8", "outBuber2", "outBait2", "outFuf4", "outBuff4", "outBbuf1", "outBait200", "outBbuffer4", "outBoff200", "outBuffB", "outFbuff2", "outBuf200", "outFbuf2", "outBbuff200", "outBoff8", "outFbuff1", "outBoff2", "outBbuf12", "outFufB", "outWBuff0", "outBbuf2", "outFbuf12", "outWBbuffTwo", "outBuff0", "outBuber20", "outFuf8"], "endOfIndexFile": ["endofindexFiles", "endofIndexFiles", "endOfIndexfile", "endofindexFile", "endofLinkFiles", "endOfLinkFiles", "end\n", "endOfLinkTime", " endfile", "endofLinkTime", "endOfIndexDir", "endOfindexTime", "endOfIndexFolder", "endfile", "endOfDatafile", "Endfile", "endOfDataFile", "endOfLinkFile", "endOfDataTime", "endofLinkFile", "endOfDataDir", "End\n", "endOfindexfile", "endofIndexDir", "endOfClientDir", "endOfImageTime", "endedfile", "ended\n", "endofindexFolder", "endOfClientFile", "endOfindexDir", "endOfIndexFiles", "endOfClientTime", "endOfindexFolder", "endOfIndexTime", "endofIndexFolder", "endOfImageFolder", "endofindexTime", "endOfLinkDir", "endofIndexTime", "endOfImageFiles", "endofLinkDir", " end\n", "endOfClientFiles", "endOfLinkfile", "endofIndexFile", "endOfindexFiles", "endOfindexFile", "endOfImageFile"]}}
{"id1": "9096314", "id2": "4921631", "code1": "    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                log.warn(\"\\'\" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" ignored - table already  has an open record \");\n            } else {\n                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());\n                long outageID = -1;\n                ResultSet seqRS = getNextOutageIdStmt.executeQuery();\n                if (seqRS.next()) {\n                    outageID = seqRS.getLong(1);\n                }\n                seqRS.close();\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement newOutageWriter = null;\n                if (log.isDebugEnabled()) log.debug(\"handleNodeLostService: creating new outage entry...\");\n                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);\n                newOutageWriter.setLong(1, outageID);\n                newOutageWriter.setLong(2, eventID);\n                newOutageWriter.setLong(3, nodeID);\n                newOutageWriter.setString(4, ipAddr);\n                newOutageWriter.setLong(5, serviceID);\n                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));\n                newOutageWriter.executeUpdate();\n                newOutageWriter.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeLostService : \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" recorded in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            }\n        } catch (SQLException sqle) {\n            log.warn(\"SQL exception while handling \\'nodeLostService\\'\", sqle);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 1, "substitutes": {"handleNodeLostService": ["handleNodeUnknownService", "handleNodeUnknownServer", "handleNodeLostFunction", "handlenodelostService", "handleNodeErrorFunction", "handleNodeErrorService", "handlenodelostServer", "handlenodelostServices", "handlenodeLostServices", "handleNodelostService", "handlenodelostFunction", "handleNodeLostServices", "handleNodeErrorServer", "handlenodeLostFunction", "handleNodeUnknownServices", "handlenodeLostServer", "handleNodelostServices", "handleNodeUnknownFunction", "handlenodeLostService", "handleNodeErrorServices", "handleNodelostServer", "handleNodelostFunction", "handleNodeLostServer"], "eventID": ["eventid", "documentID", "nodeName", "EventName", "eventType", " eventId", " eventid", "sessionID", "documentId", " eventType", "nodeId", "resourceID", "sessionName", "EventID", "serviceId", "resourceid", "serviceName", "resourceName", " eventName", "eventId", "nodeType", "eventName", "EventId", "documentName", "resourceId", "sessionId", "nodeid", "EventType"], "nodeID": ["Nodeid", " nodeName", "eventid", "nodeName", "eventInfo", " nodeURL", " nodeInfo", " nodeId", "nodeURL", "objectName", "networkId", "nodeId", "resourceID", "networkID", "serviceId", "networkInfo", "serviceName", "resourceid", "resourceName", "objectid", "eventId", "NodeID", "objectId", " nodeid", "eventName", "NodeURL", "serviceid", "resourceId", "objectID", "eventURL", "nodeid", "nodeInfo", "NodeId"], "ipAddr": ["epaddr", "apiAddri", " ipAttrs", "apiAddrs", " ipAddri", "ipChl", "ipAddl", "apiAddr", "ipAddresso", "ipAtter", " ipChri", " ipAddrer", "epaddl", "apiAttr", "ipAttrs", "ipAttress", "ipAddrs", "apiAttrs", "ipAddressl", "ipAddresser", "ipAddp", "epAddl", " ipAddo", "ipAttrer", " ipAdder", "ipaddress", "ipChr", "ipaddri", "ipAttp", "ipAddressp", "ipAdder", "ipAtto", "ipAddressri", "ipChri", "apiAddp", "ipAttr", " ipAtter", "ipChrs", "ipaddl", "apiAttri", "epAddrs", "epAddrer", " ipAttr", "ipAddo", "ipaddr", " ipAtto", " ipAddrs", "ipAddressrs", "apiAttp", "ipAddrer", "epaddrer", "ipaddo", "ipAddress", "ipAddressr", " ipChrs", "ipAttri", "ipAddressrer", "epaddrs", "ipaddrer", "ipadder", " ipChrer", " ipChr", "ipChp", " ipAddress", "ipaddrs", "epAddr", "ipAddri", "ipChrer"], "serviceID": ["imageUID", "eventIDs", "ServiceId", "ServiceName", "networkid", "siteid", "roleIP", "eventid", "serviceIP", "featureID", "networkName", "roleId", "eventIP", "featureId", " serviceid", "eventType", "siteID", " serviceName", "ServiceType", "imageId", " serviceId", "siteIP", "networkId", "roleid", "serviceIDs", "roleID", "ServiceIDs", "networkID", "imageID", "ServiceIP", "featureUID", "serviceId", "serviceName", "ServiceID", "eventId", "serviceUID", " serviceIP", "eventName", "serviceType", " serviceType", "serviceid", "siteId", " serviceUID", " serviceIDs"], "eventTime": ["EventName", "serverName", " eventInfo", "EventInfo", "eventName", "EventTime", "serverInfo", "servertime", "serverTime", "eventtime", "Eventtime", " eventtime", " eventName", "eventInfo"], "log": ["model", "crit", "sec", "ger", "full", "class", "c", "job", "it", "Log", "ge", "call", "thread", "lex", "host", "f", "pool", "stop", "debug", "cl", "write", "cache", "output", "info", "cat", "contract", "where", "tool", "user", "lo", "error", "get", "reg", "pg", "base", "event", "entry", "exp", "use", "l", "LOG", "path", "type", "blog", "low", "gen", "level", "port", "lock", "put", "or", "tag", "guard", "db", "feed", "w", "net", "http", "key", "writer", "pe", "pl", "en", "stat", "plug", "sign", "loop", "bug", "proxy", "cell", "og", "config", "url"], "dbConn": [" dbSession", "DbDr", "databaseDr", "DBCs", "webCtrl", "sqlCo", "webNC", "Dbconn", "DBConn", "databaseConnection", "DBCt", " dbCt", "dbConnection", "dbColl", "dbCon", " dbConnection", "webCt", "logCtrl", " dbCo", "DbCt", "DbConn", "webConn", "DbCs", "DbSession", " dbconn", "dbconn", "databaseConn", "dbDr", "libconn", " dbCon", "libCon", "logColl", "DbCtrl", "dbSession", " dbDr", "DbConnection", " dbCs", "libConn", "DbConnect", "sqlConn", "DBConnect", "sqlSession", " dbNC", "DbCo", "dbCo", "sqlCtrl", "dbCtrl", "dbNC", " dbCtrl", "databaseconn", "libCt", "logConn", "DbColl", "sqlconn", " dbConnect", "sqlNC", "logConnect", "DbCon", "dbCt", "dbCs", " dbColl", "sqlCt", "dbConnect"], "getNextOutageIdStmt": ["getNextOutageIdCMT", "getNextOutageIdCnt", "getNextOutageIdSr", "getNextOutageIdRb", "getNextOutageIdstMT", "getNextOutageIdSnt", "getNextOutageIDStMT", "getNextOutageIdStr", "getNextOutageIdstr", "getNextOutageIdCmt", "getNextOutageIdstmt", "getNextOutageIdSMT", "getNextOutageIdstnt", "getNextOutageIdStnt", "getNextOutageIdSb", "getNextOutageIDSb", "getNextOutageIdRr", "getNextOutageIDStnt", "getNextOutageIDStb", "getNextOutageIdRmt", "getNextOutageIDSMT", "getNextOutageIdCr", "getNextOutageIDSnt", "getNextOutageIDStr", "getNextOutageIdRMT", "getNextOutageIDStmt", "getNextOutageIdCb", "getNextOutageIdStMT", "getNextOutageIdSmt", "getNextOutageIDSmt", "getNextOutageIDSr", "getNextOutageIdStb"], "outageID": ["outflowID", "inageId", "outagingName", "outrageID", "outrageHandle", "outagingId", "outagementName", "outAGEURL", "outAGEId", "outrageName", "outageId", "OutrageId", "inrageID", "outAGEName", "outageName", "inageURL", "OutageName", "outAGEID", "OutageId", "outAGESecret", "outrageId", "OutrageID", "outageHandle", "outageURL", "inrageURL", "outissueId", "inrageUID", "outageUID", "outagementId", "outagingSecret", "OutageHandle", "outrageSecret", "outagementHandle", "OutageSecret", "outissueURL", "outrageURL", "inrageId", "outissueUID", "outrageUID", "inageID", "inageUID", "OutrageName", "outflowId", "outagementID", "outagingID", "outflowName", "outflowHandle", "OutrageHandle", "OutrageSecret", "outageSecret", "outissueID", "OutageID", "outAGEUID"], "seqRS": ["structrs", "seqRC", "sqMR", "seqTS", "reqRL", "sequTS", "reqRR", " sequenceRS", "seqRT", " sequenceMR", " seqRT", "eqRR", "sequenceRS", "sequenceRs", "colRT", "seqMR", "colRR", "eqRs", "seqSR", "sequRL", "sqRC", "invRS", "sequRS", " sequenceRT", "invSR", "structRs", " seqMR", "reqTS", "reqRT", "seqRR", " seqTS", "seqrs", " sequenceRC", "reqRS", "seqRL", "sqRT", "structRS", "reqRs", "sequenceSR", " seqRL", "structSR", "eqRS", "invrs", "colRS", "sqRS", "invRs", "sequRC", "seqRs", "sequencers", "eqRT", "reqRC", " seqRC", "colRs"], "newOutageWriter": ["newOutpaceRW", "newOutagementWrit", "newOutpacewriter", "newExagewriter", "newoutageReader", "newOutflowWrit", "newOutlineReader", "newOutpointWrite", "newExlineReader", "newOutureInfo", "newOutageWrite", "newExageWrite", "newOutageWrit", "newOutrageRW", "newInageRW", "newOutageRW", "newOutissueWrite", "newExlineWriter", "newInflowWrite", "newoutureWriter", "newInageWriter", "newOutpaceWriter", "newOutlineWrite", "newInflowRW", "newoutageRW", "newOutrageWriter", "newoutageWriter", "newOutureWrite", "newOutagewriter", "newOutflowWriter", "newInageWrit", "newOutrageWrit", "newoutageInfo", "newOutagementRW", "newOutartWrite", "newoutageWrite", "newOutureReader", "newOutflowRW", "newOutartWriter", "newOutissueWriter", "newOutpointWriter", "newOutpointRW", "newOutflowInfo", "newOutageInfo", "newOutpaceReader", "newOutartInfo", "newExageReader", "newOutagementWrite", "newOutissuewriter", "newOutureRW", "newOutflowWrite", "newExageWriter", "newOutageReader", "newInageWrite", "newOutissueReader", "newOutartRW", "newoutureWrite", "newOuturewriter", "newOutflowReader", "newOutlineWriter", "newExlinewriter", "newOutrageWrite", "newouturewriter", "newExlineWrite", "newInflowWriter", "newOutagementWriter", "newOutflowwriter", "newoutureRW", "newoutureInfo", "newOutlinewriter", "newoutagewriter", "newOutureWriter", "newOutpointReader", "newoutureReader", "newInflowWrit"]}}
{"id1": "4973095", "id2": "942693", "code1": "    public Wget2(URL url, File f) throws IOException {\n        System.out.println(\"bajando: \" + url);\n        if (f == null) {\n            by = new ByteArrayOutputStream();\n        } else {\n            by = new FileOutputStream(f);\n        }\n        URLConnection uc = url.openConnection();\n        if (uc instanceof HttpURLConnection) {\n            leerHttp((HttpURLConnection) uc);\n        } else {\n            throw new IOException(\"solo se pueden descargar url http\");\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"url": ["link", "image", "URL", "base", "resource", "lr", "www", "service", "feed", " http", "config", " web", "download", "Url", "open", "bad", "http", "use", "l", "b", "conn", "api", "full", "string", "null", " URL", "c", "r", "buffer", "ado", "path", "not", "uri", "all", "rest", "client", "xml", "ur", "ssl", "server", "host", "file", "ll", "gl", "e", "user", "u", "sl", "str", "lib", "connection", "loc", "source", "web", "address"], "f": ["fo", "fr", "fa", "fat", "inf", "w", "F", "fen", "fi", "fe", "aff", "ref", "fc", "filename", "l", "b", "info", "c", "files", "rf", "g", "buffer", "fd", "t", "d", "fb", "p", "io", "v", "x", "df", "flat", "fp", "fs", "tf", "file", "fn", "e", "sf", "fed", "u", "i", "bf", "m"], "by": ["body", "re", "log", "html", "j", "service", "in", "feed", "serv", "content", "to", "with", "open", "BY", "via", "from", "r", "buffer", "it", "v", "out", "as", "report", "ssl", "server", "By", "browser", "reader", "or", "acc", "source", "web"], "uc": ["lc", "UC", "uu", "FC", "uh", "cci", "ud", "dc", "ub", "coll", "ul", "usc", "pc", "cur", "http", "fc", "cu", "conn", "ws", "uci", "contract", "soc", "c", "cf", "ct", "rc", "BC", "sc", "ci", "https", "SC", "su", "unc", "acc", "xc", "client", "cc", "cas", "cus", "ucc", "auc", "us", "ac", "tc", "ec", "con", "cv", "cca", "mc", "u", "ru", "bc", "connection", "loc"]}}
{"id1": "23532405", "id2": "949327", "code1": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"persist": ["persister", "plistence", " Persists", "plist", "Persistence", "persists", "plists", "Persist", " Persistence", " Persister", "plister", "Persists", "Persister", "persistence", " Persist"], "ffConfigurable": ["ffConfurer", "FFConfiguring", "ffGur", "ffFured", "ffFuring", "ffGuring", "ffSegured", "ffGurer", "ffLogure", "ffConfigured", "ffConfuring", "ffConfigurred", "ffFurable", "ffConfur", "uffLogure", "effConfural", "ffConfigure", "ffSegural", "uffConfigure", "FFConfigurer", "effConfigural", "ffPlur", "ffSegurable", "FFConfurred", "FFConfurable", "uffLogured", "ffConfigural", "ffLoguring", "ffconfigurable", "ffConfigur", "ffFure", "ffLogurable", "ffconfigural", "FFConfuring", "effConfigurable", "ffConfural", "ffSegurer", "effConfured", "FFConfigural", "ffConfured", "ffGurable", "ffPlurable", "FFConfigurred", "FFConfurer", "FFConfigurable", "ffConfigurer", "uffConfiguring", "FFConfural", "ffConfiguring", "ffConfure", "uffLoguring", "ffConfurable", "ffLogured", "FFConfur", "effConfigurer", "effConfurable", "effConfigured", "uffConfigurable", "ffLogurer", "ffConfurred", "uffLogurable", "ffPlurer", "FFConfigur", "effConfurer", "uffConfigured", "ffSegurred", "ffconfigurred", "ffconfigurer", "ffPluring", "ffLogural"], "relativePath": [" relativepath", "relativeFile", " relativePoint", " relativeUrl", "absolutePoint", "protectedFile", "absoluteUrl", " relativeName", "ativeLocation", "absoluteFile", "relativeName", "absoluteName", "relativeLocation", "relativeUrl", "ativePath", "ativeUrl", "absoluteLocation", " relativeFile", "protectedPoint", "ativeName", "absolutePath", "protectedPath", "absolutepath", "protectedpath", " relativeLocation", "relativePoint", "relativepath"], "file": ["File", "image", "log", "model", "base", "in", "unit", "folder", "temp", "module", "self", "stream", "form", "ile", "fe", "cache", "http", "zip", "local", "filename", "use", "l", "b", "full", "object", "show", "url", "class", "cf", "pe", "files", "store", "path", "work", "handler", "single", "part", "type", "io", "place", " File", "it", "out", "fp", "le", "FILE", "il", "dir", "name", "location", "data", "e", "sf", "php", "parent", "el", "get", "config", "source", "db", "f", "directory"], "is": ["gets", "in", "isi", "mis", "ii", "nis", "ir", "does", "api", "ms", "info", "ui", "ws", "IS", "ps", "was", "ris", "io", "si", "oss", "ai", "isa", "out", "fs", "iss", "ip", "as", "iso", "es", "bis", "us", "ios", "Is", "i", "ais", "iris", "ics"], "os": ["ou", "o", "ops", "osi", "bos", "ms", "obs", "outs", "ies", "ows", "ils", "io", "Os", "oid", "oss", "fs", "cos", "oes", "as", "iso", "oS", "rs", "ens", "us", "ori", "ips", "oa", "oses", "uns", " bos", "ol", "ios", "OS", "ais", "oos", "los", "aos", "s"]}}
{"id1": "21979714", "id2": "12034046", "code1": "    @ActionMethod\n    public void list() throws IOException {\n        final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/list?version=1000\");\n        final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n        con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n        final InputStream in = con.getInputStream();\n        final byte[] buf = new byte[4096];\n        textArea.setText(\"\");\n        for (int bytesRead; (bytesRead = in.read(buf)) != -1; ) {\n            textArea.append(new String(buf, 0, bytesRead));\n        }\n    }\n", "code2": "    private InputStream openRemoteStream(String remoteURL, String pathSuffix) {\n        URL url;\n        InputStream in = null;\n        try {\n            url = new URL(remoteURL + pathSuffix);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            in = connection.getInputStream();\n        } catch (Exception e) {\n        }\n        return in;\n    }\n", "label": 0, "substitutes": {"list": ["index", "stop", "LIST", "check", "download", "ls", "find", "parse", "load", "ping", "sync", "info", "show", "print", "read", "export", "sort", "query", "split", "pull", "start", "test", "request", "search", "get", "delete"], "url": ["log", "URL", "base", "resource", "www", "ul", "cl", "Url", "ls", "entry", "http", "l", "api", "bb", "conn", "page", "string", " URL", "path", "fl", "org", "uri", "build", "pull", "client", "blog", "bug", "ur", "ssl", "server", "file", "ll", "ob", "lock", "sl", "rl", "connection", "config", "host", "web", "f"], "con": ["com", "lc", "ver", "conv", "login", "sub", "func", "can", "fac", "fa", "cl", "cons", "open", "cur", "pc", "ctrl", "fc", "run", "ca", "http", "ch", "conn", "un", "ann", "CON", "ran", "c", "cf", "rc", "en", "part", "an", "xc", "client", "Con", "close", "cm", "cp", "co", "ec", "ln", "cn", "on", "fn", "connect", "f", "ex", "Conn", "bc", "uc", "connection", "ctx", "exec", "conf"], "in": ["ini", "re", "login", "sub", "this", "stream", "inner", "inn", "input", "In", "rec", "bin", "conn", "b", "c", "r", "IN", "again", "conf", "min", "out", "client", "ins", "is", "as", "socket", "a", "data", "rin", "file", "ex", "reader", "i", "win", "n", "vin", "m", "inc", "f", "lin"], "buf": ["wb", "base", "conv", "func", "vec", "abs", "ff", "cur", "aka", "src", "bag", "uf", "bytes", "bin", "b", "cb", "bp", "bb", "fab", "utf", "orig", "buff", "buffer", "rc", "Buffer", "fb", "bf", "bd", "grab", "seq", "Buff", "sb", "cas", "pb", "tmp", "la", "bu", "data", "cv", "rb", "bc", "bh", "batch", "br", "uc", "db", "exc", "ab"], "bytesRead": ["wordsRead", "byteWrite", "bytesread", "BytesLength", "tesread", "bytesFound", "tesLength", "BytesRead", " bytesLoad", " bytesLength", "wordsFound", "stringsRead", "tesRead", "bytesFind", "byteLength", " bytesWritten", "BytesWritten", "BytesWrite", "stringsWritten", "byteRead", "wordsLength", " bytesWrite", "wordsread", " bytesFound", "byteWritten", " bytesFind", "tesFound", "bytesWrite", "stringsFind", "bytesWritten", "stringsLoad", "bytesLength", "bytesLoad", "BytesLoad", " bytesread", "BytesFind"]}}
{"id1": "12766394", "id2": "8079516", "code1": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"testReadHelloWorldTxt": ["testReadHelloWorldTXT", "testReadHelloWordTtxt", "testReadHelloWorldMXT", "testReadHelloWorldFext", "testReadHelloWorldText", "testReadHelloWordText", "testReadHelloWordMtxt", "testReadHelloWorldMtxt", "testReadHelloWordTxt", "testReadHelloWorldFtxt", "testReadHelloWordMxt", "testReadHelloWorldMext", "testReadHelloWorldMxt", "testReadHelloWorldTtxt", "testReadHelloWorldFXT", "testReadHelloWordMXT", "testReadHelloWordTXT", "testReadHelloWordMext", "testReadHelloWorldFxt"], "helloWorldIS": ["helloCommunityIs", "helloWorldIDE", " helloCityIS", " helloWorldIs", "helloCityIS", "helloCommunityIDE", "helloWestAS", "helloCityIR", "helloWestIS", "helloWestIR", "helloWorldis", "helloCityIs", " helloWorldIR", " helloCityIs", "helloCommunityIS", " helloCityIR", " helloWorldAS", " helloWorldIDE", "helloWestIs", "helloCityAS", " helloCityAS", "helloWorldIR", "helloWorldIs", "helloCityIDE", "helloCityis", "helloWorldAS", " helloWorldis"], "helloWorldPath": [" helloWorldDir", "helloworldPATH", "officeCommunityLocation", "helloWebUrl", "officeCommunityCorp", "helloWallName", "helloWorldName", "helloCommunityName", "hiWebpath", "helloWebpath", "helloWallPath", "helloWorldDir", "officeWorldPath", "hiWorldpath", "officeWorldLocation", "helloWallDir", "helloWebFile", "helloworldPath", "officeCommunityPath", " helloWorldName", " helloWorldpath", "officeWorldCorp", "officeCommunityPATH", "helloCommunityLocation", "helloWebPath", "helloCommunityCorp", "hiWorldUrl", "helloWorldUrl", "hiWebUrl", "helloWallpath", "helloworldLocation", "helloCommunityPATH", "helloCommunityPath", "hiWebFile", "helloWorldpath", "hiWebPath", "helloWorldCorp", "hiWorldPath", "helloworldCorp", "helloWorldPATH", "helloCommunityDir", "helloWorldLocation", "officeWorldPATH", "hiWorldFile", "helloCommunitypath", "helloWorldFile"], "fileOutputStream": ["fileWriteStream", "FileOutputstream", "fileOutputFile", "fileInputStream", "fileOutFile", "resourceInputSteam", "resourceOutputFile", "resourceOutputSteam", "resourceOutputPath", "fileWriteSteam", "resourceInputFile", "FileInputSteam", "resourceInputPath", "FileOutputHandler", "FileOutputSteam", "fileInputHandler", "FileOutputStream", "fileOutSteam", "fileInputPath", "fileoutputSteam", "fileWritePath", "fileOutputSteam", "FileInputStream", "FileInputstream", "fileoutputstream", "fileOutputHandler", "resourceOutputStream", "fileWritestream", "fileoutputStream", "fileoutputHandler", "FileInputFile", "fileInputFile", "fileOutPath", "fileWriteFile", "fileInputSteam", "FileOutputFile", "fileInputstream", "fileOutputstream", "fileOutStream", "FileInputHandler", "resourceInputStream", "fileOutputPath"], "contentResolver": [" contentresolver", "contentRoser", " contentresolution", "messageResultolver", "resourceResolve", "contentRevolve", "resourceResolver", "contentRolution", "contentresolver", "contentResponseolver", "resourceRolver", "contentRolving", "ContentRolver", "contentRlier", "contentResponseistor", "contentResistor", "contentRevolved", "messageResolver", "contentresolution", "contentRolve", " contentResolved", "contentResolves", "ContentRolution", " contentRevolve", "contentAbsolver", "contentResponseolve", "contentResultolve", "contentResponseolved", " contentRevistor", "contentAbsolution", "ContentResoser", "messageResultolution", "ContentResolution", "contentReslier", "ContentResolver", "contentResolve", "ContentResolving", "contentResolution", "resourceResolution", "contentResultlier", "messageResolution", "contentResoser", "contentRevolver", " contentResolution", "contentreslier", "contentAbsolve", "contentRolver", "messageReslier", "ContentResolve", "contentRevistor", "contentresolve", "contentResultistor", "contentAbsoser", " contentResolves", "contentresolving", "resourceRolution", "contentresolved", " contentRevolved", " contentResistor", "ContentRoser", "contentResolving", "contentRolves", "messageResultlier", "contentResultolver", "contentRevolution", "contentresolves", " contentresolves", "resourceResolved", "contentResolved", "contentRolved", "contentResultolved", "ContentRolve", "resourceRolve", "contentResultolution", "messageResultolve", " contentRevolver", " contentResolve", "ContentRolving", "contentRevolves", "resourceRolved", " contentresolve", "messageResolve"], "content": ["body", "image", "model", "lc", "html", "draft", "resource", "Content", "feed", "script", "child", "cont", "temp", "current", "write", "json", "children", "version", "text", "message", "cache", "load", "play", "output", "java", "password", "media", "conn", "full", "column", "page", "update", "string", "code", "read", "example", "fill", "status", "core", "path", "work", "next", "job", "result", "css", "response", "layer", "handle", "xml", "ontent", "size", "any", "name", "title", "ext", "word", "server", "data", "file", "valid", "document", "header", "value", "comment", "activity", "complete", "empty", "default", "connection", "config", "parent", "url", "copy", "address"]}}
{"id1": "23370621", "id2": "3495460", "code1": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "code2": "    public boolean actEstadoEnBD(int idRonda) {\n        int intResult = 0;\n        String sql = \"UPDATE ronda \" + \" SET estado = 1\" + \" WHERE numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"downloadFile": ["downloadDir", " downloadDir", "transferFiles", "transferfile", "DownloadFile", "transferFile", " downloadFiles", "downloadFiles", "transferDir", " downloadfile", "Downloadfile", "downloadfile", "DownloadDir", "DownloadFiles"], "target": ["base", "resource", "module", "nt", "site", "config", "point", "current", "content", "to", "metadata", "download", "input", "Target", "blank", "master", "cache", "filename", "output", "key", "remote", "gt", "object", "string", "driver", "tail", "store", "buffer", "t", "token", "path", "next", "goal", "pointer", "dest", "task", "out", "client", "manager", "tmp", "tool", "location", "test", "archive", "data", "file", "parent", "iter", "arget", "connection", "template", "source", "project", "plugin", "socket"], "s3key": ["sdkKey", "s3Key", " sdksecret", "sprivatekey", "sprivatesecret", " sdkKEY", " s3secret", "s2key", "s3KEY", "sdkKEY", "sdksecret", " s3Key", "svckey", " sdkKey", "sprivateKey", "sndKEY", " s3KEY", "svcsecret", "s2secret", "S2secret", "sndkey", "svcKey", " sdkkey", "sndsecret", "S2key", "S3Key", "s3secret", "s2KEY", "sndKey", "sdkkey", "S3key", "S2Key", "S3secret", "s2Key"], "in": ["ini", "err", "image", "login", "this", "fa", "gin", "inn", "inner", "arin", "input", "cgi", "In", "rec", "bin", "b", "conn", "copy", "url", "read", "like", "c", "pin", "IN", "r", "vin", "again", "doc", "source", "nin", "en", "io", "it", "cin", "min", "out", "ins", "is", "as", "lin", "init", "inside", "a", "h", "con", "data", "isin", "file", "include", "id", "ex", "i", "win", "reader", "n", "get", "ctx", "connection", "m", "din", "exec", "f", "socket", "inc", "s"], "temp": ["base", "stable", "storage", "prefix", "current", "form", "input", "zip", "cache", " temporary", "local", "sync", "output", "now", "full", "cat", "null", "txt", "store", "path", "p", "Temp", "dest", "flat", "out", "fp", "tmp", "init", "emp", "clean", "test", "tc", "data", "file", "porary", "parent", "lock", "fake", "empty", "ex", "tem", "iter", "ctx", "template", "source", "exec", "copy"], "fout": ["flout", " fcopy", "pout", "pOut", "fcopy", " fagain", "cfin", "sfouts", "fOut", "fuser", "flagain", "Fin", " fin", " fone", "Fagain", " fuser", "pin", "puser", "fagain", "Fone", "pouts", "sfOUT", "cfouts", "fouts", "Fouts", "cfOut", "sfout", "fone", "Fout", "sfcopy", "flin", "sfin", "fOUT", "sfuser", " fouts", "pOUT", "Fcopy", "FOut", "cfout", "fin", " fOUT", "flone"]}}
{"id1": "9954926", "id2": "6171406", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 1, "substitutes": {"simulate": ["Simulate", "simulator", "Simulation", "imure", "imulator", "Simulator", "simure", "animure", "animulation", "animulate", "imulation", "animulator", "Simure", "simulation", "imulate"], "out": ["flow", "resource", "temp", "window", "group", "list", "full", "page", "null", "state", "again", "result", "report", "name", "comment", "lib", "parent", "log", "pool", "in", "o", "outer", "point", "flush", "write", "cli", "cache", "output", "OUT", "table", "bin", "conn", "info", "string", "session", "outs", "io", "Out", "tmp", "co", "sys", "server", "user", "down", "error", "copy", "err", "base", "prefix", "pre", "exp", "post", "object", "exit", "external", "line", "client", "dump", "data", "gen", "lock", "ex", "db", "obj", "raw", "view", "w", "plain", "net", "up", "key", "writer", "now", "store", "buffer", "part", "word", "con"], "file": ["File", "rule", "log", "unit", "base", "in", "resource", "feed", "stream", "ile", "fe", "cache", "message", "filename", "output", "queue", "l", "b", "full", "page", "url", "files", "pe", "collection", "buffer", "path", "handler", "line", "fp", "book", "le", "FILE", "loader", "name", "report", "socket", "data", "port", "connection", "source", "f", "address"], "obtainUserReputationRequest": ["obtainUserRepentionGrant", "obtainUserReputableResponse", "obtainUserRepurityInput", "obtainUserRepigrationRequest", "obtainUserReputionRequest", "obtainUserReputeInfo", "obtainUserRelutationRequest", "obtainUserRepurationResponse", "obtainUserRepulationResponse", "obtainUserComputationResponse", "obtainUserReputedrequest", "obtainUserReputeResponse", "obtainUserReputeGrant", "obtainUserReputedGrant", "obtainUserRepurationRequest", "obtainUserRelutationResponse", "obtainUserReputionGrant", "obtainUserReputeInput", "obtainUserAnnigrationRequest", "obtainUserAnnigrationQuery", "obtainUserRepentionRequest", "obtainUserRepulationRequest", "obtainUserRepositoryInfo", "obtainUserRepigrationInfo", "obtainUserComputationInfo", "obtainUserAnnigrationGrant", "obtainUserRepurityResponse", "obtainUserRepulationEntry", "obtainUserRepigrationGrant", "obtainUserReputationGrant", "obtainUserRepurityRequest", "obtainUserComputeRequest", "obtainUserReputationEntry", "obtainUserReputationrequest", "obtainUserReputedRequest", "obtainUserReputeEntry", "obtainUserRelentionResponse", "obtainUserComputerequest", "obtainUserComputeInfo", "obtainUserRepigrationQuery", "obtainUserComputationEntry", "obtainUserAnnutationRequest", "obtainUserComputationrequest", "obtainUserRepurationGrant", "obtainUserRelentionrequest", "obtainUserReputableRequest", "obtainUserRepigrationrequest", "obtainUserComputationRequest", "obtainUserRepurationQuery", "obtainUserRelentionRequest", "obtainUserReputeRequest", "obtainUserAnnutationResponse", "obtainUserRepentionResponse", "obtainUserRepentionrequest", "obtainUserRepositoryRequest", "obtainUserRelutationGrant", "obtainUserComputeInput", "obtainUserRepositoryResponse", "obtainUserRepurityEntry", "obtainUserReputionResponse", "obtainUserReputedResponse", "obtainUserReputionrequest", "obtainUserReputationInput", "obtainUserComputeResponse", "obtainUserReputerequest", "obtainUserAnnigrationResponse", "obtainUserAnnutationQuery", "obtainUserRepulationInput", "obtainUserComputeEntry", "obtainUserAnnutationGrant", "obtainUserRepositoryrequest", "obtainUserReputeQuery", "obtainUserReputationQuery", "obtainUserComputationInput", "obtainUserRepigrationResponse", "obtainUserReputationInfo", "obtainUserRelentionGrant", "obtainUserReputablerequest", "obtainUserRelutationrequest"], "obtainUserReputationResponse": ["obtainUserExpositoryResponse", "obtainUserReputeResp", "obtainUserRepurationResponse", "obtainUserExputationRequest", "obtainUserRepurationResp", "obtainUserExpositoryRequest", "obtainUserReputeRequest", "obtainUserExpositoryResp", "obtainUserReputeResponse", "obtainUserRepositoryRequest", "obtainUserExputationResp", "obtainUserRepurationRequest", "obtainUserRepositoryResp", "obtainUserRepositoryResponse", "obtainUserReputationResp", "obtainUserExputationResponse"], "rateUserRequest": ["rateClientGrant", "rateUQUEST", "rateuserRequest", "rateClientRequest", "ratePostQUEST", "rateLineQUEST", "rateFileUser", " rateUserQUEST", "ratedUsageRequest", "rateUserQuery", "issueUserRequest", "rateLineCustomer", "rateUserFunction", "rateFileResult", "rateLinerequest", "gradeLineRequest", "rateUCommand", "rateCustomerForce", "RateFileQUEST", "rateServiceQuery", "rateFileCommand", "issueUserForce", "rateUserError", " rateClientGrant", "rateUserForce", "rateUsReturn", "rateUserVersion", "rateHumanrequest", "rateCustomerRequest", " rateUserUser", "ratedUsageQUEST", " rateuserQUEST", "rateuserrequest", " rateClientRequest", "rateLineResponse", "ratedUsagerequest", " rateApplicationRequest", "ratePostRequest", "gradeLineError", "rateUSERRequest", "ratedUserQUEST", "rateCustomerReturn", "rateHumanRequest", "RateUserQUEST", "featureMachineResult", "rateuserQUEST", "gradeLinerequest", "featureMachinerequest", "rateUserrequest", "ratedUserCommand", "rateWordCustomer", "rateCustomerQUEST", "ratedFileRequest", "featureUserVersion", "rateServiceFunction", "rateHumanVersion", "rateUrequest", "rateLineGrant", " rateClientrequest", "ratedUserFunction", "rateUsageRequest", "rateApplicationQuery", "rateLineRequest", " rateApplicationQuery", "rateUsageQuery", "rateUsageQUEST", "rateMachinerequest", "rateClientrequest", "rateUserQUEST", "rateUsageGrant", "rateUsagerequest", "rateFileRequest", "rateUserReturn", "ratedUsageForce", "rateUserCustomer", "rateUsageResponse", "ratedFileFunction", "rateUQuery", "rateUsageUser", "ratedFileQuery", "ratedUsageQuery", "gradeLineCustomer", "rateWordrequest", "featureUserRequest", "featureMachineRequest", "rateuserResponse", " rateuserrequest", "rateUSERForce", "rateUCustomer", "gradeUserError", "rateUserCommand", "rateUsageReturn", " rateUserrequest", " rateuserRequest", "RateFileRequest", "issueCustomerForce", "issueCustomerReturn", "rateUserResult", "rateLineQuery", "rateApplicationUser", "issueUserReturn", "rateFilerequest", "rateUFunction", "ratedUserQuery", "rateFileFunction", "rateFileResponse", "rateFileVersion", "ratedFileCommand", "rateUResponse", "RateUserRequest", "gradeUserRequest", "rateServiceRequest", " rateUserGrant", "rateHumanResult", "rateUserGrant", " rateApplicationUser", "ratePostResponse", "ratePostrequest", "rateServiceCommand", "featureUserResult", "ratedUserForce", "gradeUserCustomer", "RateUserResponse", "rateUserUser", "rateMachineRequest", "rateURequest", "ratedUserrequest", "RateUserrequest", "rateWordRequest", "rateUSERrequest", "rateFileQUEST", "issueUserQUEST", "rateUsRequest", "featureMachineVersion", "gradeUserrequest", "issueCustomerRequest", "rateUError", " rateUserQuery", "rateWordError", "rateUsageForce", "rateApplicationResponse", "RateFileResponse", "featureUserrequest", "ratedUserRequest", "rateLineError", "rateUsQUEST", "rateMachineResult", "rateUsForce", "rateApplicationRequest", "rateFileQuery", " rateuserResponse", "rateUSERQUEST", "issueCustomerQUEST", " rateApplicationResponse", "rateUForce", "rateMachineVersion", "RateFilerequest", "rateWordQuery"], "rateUserResponse": ["rateFileStatus", "rateUserresponse", "rateApplicationReference", "rateCustomStatus", "RateTimeResponse", "rateApplicationResp", "rateUserReply", "rateUResp", "rateFileResult", " rateUserStatus", "rateUsersResp", "rateTimeStatus", "rateUserResp", " rateApplicationData", " rateUResp", "rateFileResp", "RateTimeStatus", "rateCustomerRequest", "rateCustomerResponse", "rateUsersStatus", " rateFileStatus", " rateUResponse", "rateTimeCustomer", " rateFileResult", " rateUReply", "RateTimeCustomer", "rateClientResp", " rateUserReply", " rateUserData", " rateUserReference", " rateUserResult", "rateUserCustomer", "rateTimeResponse", "rateuserResult", "rateFileresponse", "rateCustomerResp", "rateUReply", "rateuserResponse", " rateUserResp", "RateUserResource", "rateUserResult", "rateClientResponse", "rateUserData", "rateUserReference", " rateApplicationResp", "rateUsersRequest", "RateUserResp", "rateFileResponse", "rateUserResource", "rateUResponse", "RateUserRequest", "rateUsersResource", "rateuserStatus", "rateCustomResp", "rateCustomerData", "rateApplicationData", "rateUresponse", "RateUserResponse", "rateuserReply", "rateUserStatus", "rateFileReply", "rateuserResp", " rateApplicationReference", " rateFileResp", " rateUresponse", "rateUsersResult", "rateClientCustomer", " rateUserresponse", "rateCustomCustomer", "rateTimeResp", "rateCustomResponse", "rateApplicationResponse", "RateUserCustomer", "rateCustomerReference", "rateCustomerResource", " rateFileResponse", "rateClientStatus", "rateuserReference", "RateUserStatus", " rateApplicationResponse", "rateuserresponse", "RateTimeResp", "rateUsersResponse", "rateuserData"], "fis": [" fIs", "bris", "FIs", "fIs", "bIs", "sfIs", "sfiss", " fiss", "Fis", "fris", "bis", "Fiss", "sfris", "fiss", "biss", "sfis", "Fris", " fris"], "br": ["err", "body", "dr", "lr", "fr", "bl", "arr", "fin", " tr", "ref", "ler", " fr", "bridge", "b", "ch", "pr", "bp", "bed", "buf", "sp", "r", "ber", "buffer", "gr", "tr", "wr", "bro", "result", "io", "Br", "BR", " bio", "hr", "bs", "ob", "brush", "browser", "str", "Reader", "reader", "rb", "res", "bc", "sw", "cr"], "call": ["body", "flow", "create", "check", "input", "cl", "phone", "load", "message", "text", "cu", "Line", "play", "output", "use", "voice", "info", "charge", "cat", "invoke", "string", "code", "c", "ack", "buffer", "ell", "cod", "push", "query", "work", "throw", "sc", "doc", "ck", "line", "type", "Call", "result", "called", "calling", "response", "xml", "name", "request", "co", "loc", "data", "user", "roll", "e", "cell", "callback", "str", "comment", "fax", "contact", "msg", "claim", "f", "url", "address"]}}
{"id1": "14783950", "id2": "19549489", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressInZip", "compressUsingSax", "compresswithSax", "compressedWithSax", "compressWithSax", "compresswithJar", "compressedUsingJar", "compresswithZip", "compressedWithJar", "compressedUsingSax", "compressUsingZip", "compressUsingJar", "compressInJar", "compressWithJar", "compressedUsingZip", "compressedWithZip", "compressInSax"], "fileList": ["fileEx", "FileString", "wordString", "modelEx", "fileStream", "modelCollection", "stringChain", "fileChain", " fileSet", "Filelist", "inputList", " fileCollection", "inputStream", " fileEx", "stringlist", "zipSet", " fileChain", "wordStream", "stringList", "wordList", "ziplist", "FileName", "zipName", "filelist", "zipList", "FileList", "FileChain", "fileString", "modelList", " fileStream", "fileCollection", " filelist", "FileStream", " fileString", "fileSet", "stringName", "wordName", "inputEx", "modelStream", "FileSet", "inputCollection"], "zipFileName": ["zipFilePath", "folderFilename", "zipGlobalPath", "zipFilename", "folderFilePath", "archiveDirPath", "folderGlobalPath", "zipFileNames", "zipDirname", "zipFullname", "zipPackageName", "zipFullDir", "folderFileName", "zipDirPath", "zipDirDir", "folderGlobalNames", "archiveDirName", "zipPackageDir", "zipPackagePath", "zipFullNames", "archiveFileDir", "zipDirName", "archiveFileName", "folderGlobalname", "zipDirNames", "zipFileDir", "folderFileNames", "zipGlobalNames", "zipFullPath", "zipFullName", "archiveDirDir", "archiveFilePath", "folderGlobalName", "zipGlobalName", "zipGlobalname"], "fos": ["flis", "infaos", "afis", "afos", "infos", "flosh", "flos", " fosh", "afaos", "faos", "Fos", "Fis", "Fosh", "afoS", "infis", "foS", "Faos", "FoS", "infoS", "fosh"], "zos": ["z", "lol", "onz", "zes", "closure", "zx", "kos", "seconds", "gz", "zb", "uz", "phi", "zar", "zzy", "LOS", "osi", "bos", "dos", "fi", "lins", "zip", "nz", "packs", "webkit", "zon", "bag", "zer", "tz", "ZA", "ZI", "zy", "spin", "inos", "outs", "zo", "abi", "bes", "zag", "zz", "chini", "ros", "ozo", "obb", "os", "css", "jobs", "loop", "zers", "zl", "cos", "ses", "es", "bis", "iframe", "zan", "rez", "oses", "zik", "zen", "jas", "fits", "budget", "zi"], "iter": ["err", "index", "fr", "outer", "end", "walker", "inner", "coll", "order", "ener", "gener", "inter", "fer", "inse", "http", "parse", "ir", "slice", "list", "upper", "finder", "set", "Iter", "next", "sort", "er", "ie", "itter", "izer", "it", "oper", "ip", "is", "ner", "iz", "iner", "ite", "cher", "chain", "test", "ter", "keep", "former", "file", "e", "ser", "iterator", "el", "Iterator", "ator", "i", "enter", "liter", "loc", "inc", "f"], "fileName": ["pageString", "fPart", "localPart", " fileOpen", "fileOpen", "FileString", "fName", "FileUrl", "fname", " filePath", "fileLine", "fileType", "filePath", "FileData", "currentName", "simpleOpen", "fullOpen", "localPath", "fileData", "filename", " filePart", "FileInfo", "filenameInfo", "FilePart", "FilePath", "currentData", "filePart", "pagename", "FileName", "localname", "Filename", " fileType", " fileUrl", "filenameFull", " filename", " fileData", "currentUrl", "fileString", "currentname", " fileString", " fileLine", "filenamename", " fileInfo", "fileUrl", "fullPath", "FileFull", "pageName", "simplePath", "fileInfo", "FileType", "fullName", "FileLine", " fileFull", "pageType", "simpleName", "filenameName", "fLine", "fileFull", "localName"], "ind": ["z", "nd", "index", "j", "in", "fr", "end", "pt", "mind", "bind", "inn", "val", "ix", "ii", "count", "ld", "ord", "pos", "d", "ci", "ad", "div", "len", "x", "eff", "wind", "pull", "dir", "length", "start", "mid", "pend", "rib", "id", "ded", "vert", "Ind", "cond", "i", "IND", "loc", "inc"], "shortName": ["ShortPart", "ShortPath", " shortLine", "longname", "Shortname", "longLine", "longPath", " shortPath", "fullLine", "smallPart", "longName", "fullname", "shortPart", "smallPath", "smallName", "shortString", "ShortName", "fullString", "fullPath", "shortPath", "smallname", "ShortString", "fullName", "longPart", "shortname", "shortLine", " shortString", " shortname"], "fis": ["fios", " fs", "pis", "afiss", "gisa", "cfris", "afis", "afos", "afris", " fios", "cfis", "cfiss", "pris", " fiss", "gios", "Fos", "fs", "Fis", "fris", "cfos", "fisa", "pisa", "cfs", "Fiss", "fiss", "gris", "pios", "Fs", "gis", " fisa", " fris"], "buf": ["wb", "box", "vec", "done", "ba", "bl", "ff", "cur", "feat", "queue", "bag", "uf", "bytes", "cb", "b", "bh", "bb", "bin", "bp", "buff", "buffer", "rc", "fd", "fb", "lb", "bf", "bd", "grab", "Buff", "v", "lim", "pb", "tmp", "la", "bu", "loc", "data", "cv", "rb", "bc", "seq", "batch", "br", "uc"], "bytesRead": [" bytesSkip", "wordsRead", "flowsLength", "bitsWrite", " bytesUse", "flowsRead", "bytesUse", " bytesLoad", "bitsUse", " bytesLength", "tesWrite", "tesRead", "wordsWrite", "bitsLoad", " bytesNeed", "secondsWrite", "bitsRead", "tesLoad", "flowsNeed", "bitsSkip", "flowsWrite", "secondsRead", "wordsLength", " bytesWrite", "bitsLength", "wordsUse", "tesSkip", "bytesWrite", "bytesLength", "bytesNeed", "secondsLength", "bytesLoad", "bytesSkip", "secondsNeed"]}}
{"id1": "21979462", "id2": "7166270", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "label": 1, "substitutes": {"downloadURLtoString": [" downloadUrlasLong", " downloadURLtoLong", " downloadURLintoLong", " downloadURL2string", " downloadURL2Long", " downloadUrltoStr", " downloadUrltostring", " downloadURLtoStr", " downloadUrltoString", " downloadURLintoStr", " downloadURLasString", " downloadURLintostring", " downloadURLasLong", " downloadUrltoLong", " downloadURLasstring", " downloadUrlasstring", " downloadUrlasString", " downloadURLtostring", " downloadURL2Str", " downloadURLintoString", " downloadURL2String", " downloadUrlasStr", " downloadURLasStr"], "url": ["image", "link", "rule", "URL", "service", "resource", "lr", "base", "Url", "ref", "http", "remote", "l", "b", "page", "bel", "buffer", "path", "job", "uri", "loader", "name", "ssl", "loc", "server", "data", "file", "user", "gl", "sl", "el", "connection", "config", "source", "f", "address"], "in": ["ini", "re", "err", "ilo", "login", "fr", "rx", "impl", "gin", "inn", "inner", "input", "In", "inc", "at", "cms", "bin", "b", "read", "r", "IN", "buffer", "again", "ic", "fb", "source", "nin", "it", "min", "out", "ins", "is", "into", "as", "init", "ssl", "ac", "h", "ln", "isin", "data", "af", "reader", "i", "n", "din", "db", "f", "lin", "s"], "sb": ["ib", "wb", "nb", "bsp", "kb", "bm", "lr", "eb", "ub", "zb", "SB", "ls", "sa", "xb", "src", "amb", "b", "bb", "Bs", "cb", "bh", "usb", "bp", "buf", "gb", "buff", "abb", "buffer", "fb", "lb", " SB", "bd", "si", "obb", "sg", "sv", " eb", "B", "erb", "pb", "bt", "lab", "bs", "sf", "sth", "rb", "mb", "bc", "bf", "BB", "db", "s"], "str": ["enc", "err", "lc", "dr", "fr", "coll", "bl", "cl", "arr", "cur", "obj", "exp", "text", "key", "l", "b", "list", "STR", "pr", "string", "txt", "read", "sp", "r", "spec", "ct", "pass", "tr", "wr", "st", "stri", "doc", "line", "div", "result", "name", "sr", "data", "char", "Str", "sl", "i", "n", "iter", "br", "cr", "f", "s"]}}
{"id1": "947406", "id2": "23510383", "code1": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 1, "substitutes": {"copy": ["log", "clone", "download", "write", " Copy", "paste", "cop", "zip", "sync", "replace", "Cop", "cat", "csv", "clip", "split", "p", "cmp", "it", "dump", "Copy", "file", "transfer", "put", "get", "cp", " transfer", " cp"], "src": ["resource", "sub", "config", "stream", "input", "cur", "filename", "use", "href", "js", "string", "txt", "gb", "files", "dist", "rc", "stab", "rob", "sc", "source", "ource", "uri", "sb", "img", "ins", "sq", "sit", "rs", "name", "sel", "id", "data", "fn", "inst", "sl", "rb", "bh", "loc", "sin", "url", "s"], "dest": ["folder", "de", "wb", "die", "des", "temp", "done", "dat", " Dest", "target", "output", "later", "bin", "replace", "wd", "sup", "home", "comb", "txt", "class", "orig", "dist", "d", "st", "result", "opt", "flat", "img", "prop", "rest", "dir", "tmp", "name", "test", "Dest", "thin", "const", "desc", "delete", "destroy", "source", "obj"], "in": ["ini", "err", "kin", "base", "login", "this", "inner", "inn", "gin", "input", "download", "trans", "din", "In", "up", "bin", "b", "conn", "info", "url", "cf", "pin", "r", "IN", "again", "pass", "work", "nin", "it", "cin", "diff", "issue", "pull", "ins", "is", "as", "lin", "init", "a", "thin", "con", "id", "data", "rin", "isin", "lock", "i", "reader", "win", "vin", "lib", "m", "source", "socket", "inc", "s"], "out": ["ou", "err", "log", "index", "image", "o", "outer", "pool", "this", "inner", "w", "write", "plain", "net", "inc", "at", "obj", "our", "up", "exp", "cache", "or", "sync", "output", "OUT", "writer", "conn", "bin", "exit", "again", "outs", "source", "nin", "part", "io", "os", "x", "img", "Out", "client", "off", "app", "init", "ext", "data", "file", "vert", "user", "id", "call", "ex", "no", "timeout", "one", "lib", "aos", "exec", "socket"], "buf": ["num", "nb", "box", "raw", "br", "ff", "cur", "feat", "ref", "count", "queue", "bag", "uf", "b", "bytes", "bin", "cb", "pad", "cap", "bh", "bp", "c", "orig", "buff", "pos", "fab", "buffer", "rc", "fd", "fb", "bf", "bd", "p", "fl", "result", "v", "len", "block", "off", "bn", "data", "cv", "rb", "ctx", "seq", "batch", "loc", "uc", "bc", "f", "ab"], "n": ["z", "nd", "num", "index", "nb", "o", "j", "nt", "N", "w", "write", "nc", "ns", "count", "ne", "l", "b", "un", "c", "sn", "t", "d", "ind", "k", "p", "en", "nin", "v", "x", "number", "len", "nn", "nr", "length", "na", "size", "rn", "dn", "u", "no", "i", "ng", "m", "f", "max"]}}
{"id1": "1169642", "id2": "7468827", "code1": "    @Override\n    public void run() {\n        String key = getKey();\n        synchronized (this.lauchedHTTPRequests) {\n            if (this.lauchedHTTPRequests.contains(key)) return;\n            this.lauchedHTTPRequests.add(key);\n        }\n        String st = this.dataSource.getTileURL(this.x, this.y, this.z);\n        URL url;\n        try {\n            url = new URL(st);\n        } catch (MalformedURLException e1) {\n            logger.warning(\"Error in URL: \" + st);\n            return;\n        }\n        String geoJSON = \"\";\n        try {\n            InputStream is;\n            if (\"file\".equals(url.getProtocol())) is = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) is = url.openStream(); else {\n                logger.warning(\"Impossible to load settings from \" + url + \". Unsupported protocol \" + url.getProtocol());\n                return;\n            }\n            BufferedReader in = new BufferedReader(new InputStreamReader(is));\n            String line;\n            while ((line = in.readLine()) != null) geoJSON += line;\n            in.close();\n        } catch (FileNotFoundException e) {\n            return;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n        VectorTile tile = new VectorTile(geoJSON, x, y, z);\n        Geometry[] geoms = new Geometry[tile.getPieces().size()];\n        int i = 0;\n        for (MfGeo geo : tile.getPieces()) {\n            if (geo.getGeoType() == GeoType.GEOMETRY) {\n                geoms[i++] = ((MfGeometry) geo).getInternalGeometry();\n            } else if (geo.getGeoType() == GeoType.FEATURE) {\n                MfFeature mf = (MfFeature) geo;\n                geoms[i++] = mf.getMfGeometry().getInternalGeometry();\n            }\n        }\n        GeometryCollection gc = new GeometryFactory().createGeometryCollection(geoms);\n        this.dataSource.getDataLoader().add(new OpenCartoFeature(this.dataSource.getLayer(), new Rep(gc), this.z));\n        this.dataSource.getLayer().getDisplayCacheLoader().coin();\n        synchronized (this.lauchedHTTPRequests) {\n            this.lauchedHTTPRequests.remove(key);\n        }\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"run": ["register", "submit", "func", "download", "load", "process", " deploy", " work", "update", " runs", "apply", "running", "work", "sleep", "build", "loop", "start", "init", "request", " solve", "call", " evaluate", "get", "Run", "execute", "exec"], "key": ["rule", "link", "fee", "base", "service", "q", "temp", "change", "prefix", "this", "self", "keys", "check", "ry", "KEY", "req", "cache", "pair", "play", "cert", "ke", "use", "connection", "string", "code", "pe", "ace", "k", "work", "ie", "type", "v", "x", "wk", "ce", "y", "secret", "cy", "client", "sign", "name", "request", "my", "id", "e", "lease", "lock", "value", "Key", "source", "parent", "kid", "ee"], "st": ["nd", "fr", "www", "tt", "pt", "stream", "est", "bl", "fe", "ut", "l", "ld", "struct", "ST", "string", "rd", "contract", "sp", "pe", "sn", "sts", "d", "pl", "sc", "stri", "se", "sb", "ste", "sv", "rest", "std", "sd", "start", "ost", "ur", "St", "sr", "ft", "sta", "inst", "u", "sl", "ss", "str", "ist", "sth", "ast", "s"], "url": ["image", "link", "log", "rule", "URL", "base", "resource", "fr", "lr", "feed", "www", "service", "impl", "config", "email", "stream", "event", "ul", "download", "Url", "ls", "http", "use", "l", "api", "bb", "href", "object", "page", "string", "null", "bel", "buffer", "path", "li", "fl", "rel", "uri", "build", "pull", "layer", "blog", "bug", "il", "secure", "ur", "tool", "ssl", "request", "server", "host", "file", "ll", "ob", "gl", "user", "id", "e", "el", "sl", "rl", "iter", "connection", "loc", "source", "web", "f", "address"], "geoJSON": ["geographicURL", "geoPackage", " geoJ", "geometryPackage", "geographicString", " geometryJSON", "geographicJSON", "gameoURL", "geoInfo", "gameoZip", "geoJ", "geometryJSON", "geographicPackage", "cheoURL", "gepoJSON", "gepoInfo", "geyoJSON", " geometryInfo", "gameometryURL", "cheoString", "cheographicString", "cheographicPackage", "geometryString", " geoInfo", "geoaJSON", "geoString", "gameometryJSON", "geyoJ", "geoURL", "cheoPackage", "geoaPackage", "gepoJ", " geometryURL", "geometryZip", " geoURL", "geometryJ", "gepoURL", "geometryURL", "geographicZip", "cheoJSON", " geometryJ", "geoZip", "geyoInfo", "geoaZip", "geoaURL", "gameometryString", "geyoURL", "cheographicJSON", "geometryInfo", "gameoString", "cheographicURL", "gameometryZip", "gameoJSON", "geoaString"], "is": ["ib", "index", "its", "serv", "stream", "isi", "abs", "mis", "ir", "lis", "has", "api", "l", "info", "ui", "IS", "iv", "ri", "r", "ie", "p", "ris", "it", "os", "uri", "x", "ai", "out", "isl", "isa", "iss", "ip", "ins", "il", "as", "iz", "iso", "bis", "us", "id", "isc", "ios", "Is", "im", "get", "ais", "or", "ar", "s"], "in": ["ini", "kin", "err", "getting", "create", "login", "serv", "stream", "inner", "inn", "arin", "download", "with", "input", "open", "In", "inc", "trans", "parse", "load", "reading", "l", "b", "bin", "update", "read", "ri", "pin", "from", "IN", "r", "again", " In", "ic", "finding", "p", "nin", "io", "it", "loading", "x", "min", "by", "out", "ins", "working", "as", "correct", "init", "adding", "h", "on", "data", "rin", "isin", "e", "el", "ex", "reader", "get", "per", "iter", "ar", "din", "f", "lin", "s"], "line": ["look", "link", "letter", "log", "lc", "end", "val", "lf", "cl", "lines", "entry", "inline", "LINE", "up", "parse", "text", "zip", "ne", "Line", "l", "object", "page", "ine", "string", "code", "style", "pe", "r", "pin", "pass", "li", "part", "record", "frame", "row", "number", "le", "block", "character", "me", "name", "ge", "data", "file", "id", "cell", "e", "lo", "char", "str", "sl", "el", "no", "profile", "source", "cr", "lin"], "tile": ["coord", "image", "model", "fo", "ilo", "shape", "stone", "game", "plane", "tle", "match", "fe", "square", "lore", "info", "texture", "fill", "class", "scale", "cf", "pe", "future", "collection", "t", "pole", "type", "xy", "grid", "lat", "flat", "figure", "league", "layer", "pixel", "edge", "size", "pie", "fit", "tool", "crop", "zone", "map", "ge", "server", "artist", "file", "te", "face", "Tile", "e", "feature", "profile", "project", "f", "surface", "cover"], "geoms": ["gelas", "GEometry", "telements", "elas", " geodes", "Geoms", "neomes", "Geomes", "teodes", "gelements", "geomes", "eoms", "nelements", " geomes", "GEoms", "geodes", "eomes", "GEodes", "geometry", "GElements", "teometry", "Geometry", "teoms", "eometry", "Gelas", "neodes", " geometry", "nelas", "neoms", "neometry", "Geodes"], "i": ["z", "j", "index", "o", "hi", "inner", "phi", "ii", "fi", "mini", "slice", "b", "info", "ui", "ri", "pi", "c", "gi", "d", "li", "ci", "p", "shift", "multi", "si", "io", "xi", "bi", "uri", "eni", "x", "ai", "y", "init", "qi", "ti", "id", "e", "limit", "u", "f", "n", "di", "I", "zi"], "geo": ["GEometry", "aleometry", "gaographic", "geographic", "neo", " topom", "seometry", "geou", "teo", "Geolo", "GEo", "gaometry", "GEou", "gepo", "Geom", "gesom", "geon", " geom", "geson", "gao", "aleou", "gebo", " gepo", "gateometry", "seo", "zeou", "neou", " geon", "geom", " geou", "zepo", "seom", "geolo", "geometry", "alebo", "GEbo", "geoco", "teoco", "seoco", "gateo", "seou", "teometry", "Geometry", "gespo", "Geoco", "zeo", "gateographic", "Geographic", "Geo", " geometry", "geso", " topo", "aleo", "sebo", "zeometry", "teom", "neometry", "gaolo", " topon", "nepo", " toppo", "gateolo"], "mf": ["smf", "Mcf", "rtf", " mfi", "smfs", "pc", "imcf", " mfa", "rfs", "smc", "rf", "rc", "Mf", "ptf", " mcf", "Mfa", "pf", "mfa", "Mfi", "smtf", "imfi", "mfi", "mfs", "imf", "mc", "imfa", "mtf", "mcf", "pfs"], "gc": ["ga", " dc", "GC", "cl", "pc", "ls", " cc", "gt", " rc", "gg", "gb", "gi", "gr", "ct", "collection", " GC", " ic", " ac", "cs", "xc", "cc", "gd", "co", "gs", "GB", "bc", " bc", "vg", "gp"]}}
{"id1": "7764011", "id2": "16798376", "code1": "    public void readScalarpvviewerDocument(URL url) {\n        try {\n            String xmlData = \"\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            boolean cont = true;\n            while (cont) {\n                line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '%') {\n                    xmlData = xmlData + line + System.getProperty(\"line.separator\");\n                }\n                if (line.length() > 1 && line.charAt(0) == '%' && line.charAt(1) == '=') {\n                    cont = false;\n                }\n            }\n            XmlDataAdaptor readAdp = null;\n            readAdp = XmlDataAdaptor.adaptorForString(xmlData, false);\n            if (readAdp != null) {\n                XmlDataAdaptor scalarpvviewerData_Adaptor = readAdp.childAdaptor(dataRootName);\n                if (scalarpvviewerData_Adaptor != null) {\n                    cleanUp();\n                    setTitle(scalarpvviewerData_Adaptor.stringValue(\"title\"));\n                    XmlDataAdaptor params_font = scalarpvviewerData_Adaptor.childAdaptor(\"font\");\n                    int font_size = params_font.intValue(\"size\");\n                    int style = params_font.intValue(\"style\");\n                    String font_Family = params_font.stringValue(\"name\");\n                    globalFont = new Font(font_Family, style, font_size);\n                    fontSize_PrefPanel_Spinner.setValue(new Integer(font_size));\n                    setFontForAll(globalFont);\n                    XmlDataAdaptor params_pts = scalarpvviewerData_Adaptor.childAdaptor(\"Panels_titles\");\n                    viewValuesPanel.setTitle(params_pts.stringValue(\"values_panel_title\"));\n                    viewChartsPanel.setTitle(params_pts.stringValue(\"charts_panel_title\"));\n                    XmlDataAdaptor params_data = scalarpvviewerData_Adaptor.childAdaptor(\"PARAMETERS\");\n                    if (params_data != null) {\n                        viewValuesPanel.setLastMemorizingTime(params_data.stringValue(\"lastMemorizingTime\"));\n                    } else {\n                        viewValuesPanel.setLastMemorizingTime(\"No Info. See time of file modification.\");\n                    }\n                    XmlDataAdaptor params_uc = scalarpvviewerData_Adaptor.childAdaptor(\"UpdateController\");\n                    double updateTime = params_uc.doubleValue(\"updateTime\");\n                    updatingController.setUpdateTime(updateTime);\n                    double chartUpdateTime = params_uc.doubleValue(\"ChartUpdateTime\");\n                    viewChartsPanel.setTimeStep(chartUpdateTime);\n                    viewValuesPanel.listenModeOn(params_uc.booleanValue(\"listenToEPICS\"));\n                    viewChartsPanel.recordOn(params_uc.booleanValue(\"recordChartFromEPICS\"));\n                    java.util.Iterator<XmlDataAdaptor> pvIt = scalarpvviewerData_Adaptor.childAdaptorIterator(\"ScalarPV\");\n                    while (pvIt.hasNext()) {\n                        XmlDataAdaptor pvDA = pvIt.next();\n                        String pvName = pvDA.stringValue(\"pvName\");\n                        double refVal = pvDA.doubleValue(\"referenceValue\");\n                        double val = 0.;\n                        if (pvDA.hasAttribute(\"value\")) {\n                            val = pvDA.doubleValue(\"value\");\n                        }\n                        spvs.addScalarPV(pvName, refVal);\n                        ScalarPV spv = spvs.getScalarPV(spvs.getSize() - 1);\n                        spv.setValue(val);\n                        spv.showValueChart(pvDA.booleanValue(\"showValueChart\"));\n                        spv.showRefChart(pvDA.booleanValue(\"showRefChart\"));\n                        spv.showDifChart(pvDA.booleanValue(\"showDifChart\"));\n                        spv.showDif(pvDA.booleanValue(\"showDif\"));\n                        spv.showValue(pvDA.booleanValue(\"showValue\"));\n                        spv.showRef(pvDA.booleanValue(\"showRef\"));\n                    }\n                }\n            }\n            spvs.readChart(in);\n            in.close();\n            updatingController.setStop(false);\n            viewValuesPanel.updateGraph();\n            viewChartsPanel.updateGraph();\n        } catch (IOException exception) {\n            messageTextLocal.setText(null);\n            messageTextLocal.setText(\"Fatal error. Something wrong with input file. Stop.\");\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            FTPClient ftp = new FTPClient();\n            try {\n                ftp.connect(\"localhost\", 21);\n                ftp.login(\"ftpuser\", \"ftpuser123\");\n                System.out.println(\"Current: \" + ftp.printWorkingDirectory());\n                System.out.println(\"Dir status: \" + ftp.makeDirectory(DIR));\n                ftp.changeWorkingDirectory(DIR);\n                System.out.println(\"File status: \" + ftp.storeFile(FILE_PREFIX + this.getName(), getByteInputStream()));\n            } finally {\n                ftp.disconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"readScalarpvviewerDocument": ["readScalarpvviewedocument", "readScalarpvviewerdocument", "readScalarpvvieweString", "readScalarpvViewersDocument", "readScalarpvviewerData", "readScalarpvviewedDocument", "readScalarpvViewerData", "readScalarpvvieweData", "readScalarpvvieweDocument", "readScalarpvViewersData", "readScalarpvviewersData", "readScalarpvViewerdocument", "readScalarpvViewerDocument", "readScalarpvViewersdocument", "readScalarpvviewerString", "readScalarpvviewersdocument", "readScalarpvViewerString", "readScalarpvviewedData", "readScalarpvViewersString", "readScalarpvviewedString", "readScalarpvvieweddocument", "readScalarpvviewersDocument", "readScalarpvviewersString"], "url": ["image", "link", "URL", "base", "resource", "service", "stream", "input", "Url", "entry", "http", "filename", "remote", "l", "href", "object", "page", "string", "bel", "buffer", "path", "job", "io", "uri", "xml", "name", "location", "ssl", "server", "data", "file", "user", "host", "sl", "reader", "connection", "config", "source", "address"], "xmlData": ["phpDATA", "wsString", " xmlPart", "phpData", "parseData", "rssString", "rssDATA", "mldata", "phpPart", "xmlText", "mlDATA", " xmlContent", "parseCode", "rssdata", "xmlDATA", " xmlCode", "textPart", "mlData", "xmlPart", " xmlDATA", "mlText", "mlContent", "phpContent", "xfData", " xmlString", "parseText", "wsdata", "xmlCode", "textData", " xmlText", "textContent", " xmldata", "xfContent", "rssData", "xmlString", "wsData", "xfDATA", "mlCode", "textDATA", "wsDATA", "parsedata", "xmlContent", "xmldata", "xfText"], "in": ["ini", "kin", "login", "serv", "this", "stream", "inner", "inn", "input", "In", "inc", "rec", "l", "b", "bin", "c", "r", "IN", "buffer", "again", "doc", "source", "nin", "min", "out", "ins", "socket", "ssl", "a", "h", "con", "data", "file", "reader", "i", "win", "connection", "m", "din", "f", "lin", "s"], "line": ["unit", "page", "c", "strip", "job", "single", "block", "chain", "name", "file", "el", "str", "comment", "value", "lin", "lc", "log", "point", "content", "cl", "write", "inline", "sync", "auto", "string", "code", "pass", "phrase", "le", "ip", "character", "user", "error", "no", "non", "plugin", "base", "lf", "none", "lines", "entry", "parse", "text", "l", "object", "row", "data", "on", "one", "rule", "link", "letter", "section", "end", "nl", "LINE", "message", "Line", "ine", "pe", "item", "split", "part", "edge", "word", "range", "cell", "e", "sl"], "cont": ["com", "err", "lc", "ident", "expl", "sect", "circ", "feed", "det", "continue", "coll", "content", "form", " continuous", "match", "feat", "text", "count", "full", "ctr", "ent", " cond", "comb", "contract", "left", " Cont", "ct", "resp", "contin", "tr", "ci", "result", " cur", "multi", "CONT", "progress", " CONT", "dest", "cor", "Cont", "out", "rest", "prev", "comp", "cart", "ont", "collect", "close", "clean", "ext", "mult", "keep", "const", "char", "cell", "cond", "str", "complete", "acc", "parent"], "readAdp": [" readAbr", " readAblp", "readAxc", "readAdps", "readAxs", "readEllpi", "readadpi", "loadAdp", " readAds", "readAbb", "readADb", " readadP", "readEdps", "loadAdlp", "loadADlp", "loadADp", "readadp", "ReadAxpi", " readads", "ReadAdps", "loadAdb", "readads", "readADs", "readAxps", "readEllp", " readAdr", "readElllp", "readADp", "readPromlp", " readAdpi", "loadADpi", "readEllr", "readADr", "readAdb", "readAdlp", "readAdr", "readadc", " readAdlp", "readAds", "readEdc", "readAdpi", "loadAdpi", "readADlp", "readAdP", "readAxP", "readadP", " readadpi", "readPromp", "readPrompi", "ReadAxc", "readEdpi", " readAbpi", "readAbp", " readadp", "readadps", "ReadAdpi", "readAxpi", "readEdp", " readAbp", "readADP", "ReadAxp", "ReadAxps", "readAbr", "readPromb", "readAxp", "ReadAdp", "readAblp", "ReadAdc", "readAdc", " readAdP", "readADpi", "readAbpi", "loadADb"], "scalarpvviewerData_Adaptor": ["scalarpvviewerDataerAdaptutor", "scalarpvviewerData_Collectractor", "scalarpvviewerData_Connector", "scalarpvviewerDataerAdaptor", "scalarpvviewerDataeradaptutor", "scalarpvviewerData_Uploadator", "scalarpvviewerDataLocalAdaptor", "scalarpvviewerData_Collectutor", "scalarpvviewerData_Adapter", "scalarpvviewerData_Creater", "scalarpvviewerData_Uploadive", "scalarpvviewerData_Selector", "scalarpvviewerData_Adaptive", "scalarpvviewerData_Selecter", "scalarpvviewerData_adaptator", "scalarpvviewerDataeradaptator", "scalarpvviewerDataLocaladaptor", "scalarpvviewerData_Collectator", "scalarpvviewerDataLocalAdaptors", "scalarpvviewerData_adaptutor", "scalarpvviewerDataerAdapter", "scalarpvviewerData_adaptors", "scalarpvviewerDataeradapter", "scalarpvviewerData_adaptractor", "scalarpvviewerData_Creatator", "scalarpvviewerData_Adaptator", "scalarpvviewerData_Connecter", "scalarpvviewerDataerAdaptator", "scalarpvviewerData_Connectors", "scalarpvviewerData_AdaptOR", "scalarpvviewerData_Creator", "scalarpvviewerData_Connectator", "scalarpvviewerDataLocalAdaptator", "scalarpvviewerData_Uploador", "scalarpvviewerData_Connectutor", "scalarpvviewerData_Adaptutor", "scalarpvviewerData_adaptive", "scalarpvviewerData_Creators", "scalarpvviewerDataeradaptors", "scalarpvviewerData_CollectOR", "scalarpvviewerData_Adaptors", "scalarpvviewerData_adapter", "scalarpvviewerData_adaptOR", "scalarpvviewerDataeradaptor", "scalarpvviewerDataerAdaptors", "scalarpvviewerData_Collector", "scalarpvviewerData_Adaptractor", "scalarpvviewerData_Creatutor", "scalarpvviewerDataLocaladaptator", "scalarpvviewerData_Selectator", "scalarpvviewerDataLocaladaptors", "scalarpvviewerData_Selectors", "scalarpvviewerDataerAdaptractor", "scalarpvviewerData_Collectors", "scalarpvviewerData_ConnectOR", "scalarpvviewerData_Uploadors", "scalarpvviewerData_adaptor", "scalarpvviewerDataLocaladaptOR", "scalarpvviewerDataeradaptractor", "scalarpvviewerData_Creative", "scalarpvviewerDataLocalAdaptOR"], "params_font": ["paramsinglarge", "params_shadow", "ams_chart", "ams_font", "params_text", " params_Font", "pins_password", "params_theme", "ams_large", "pins_text", "params_Font", "paramsingpen", "params_large", "ams_pen", "ams_fat", "ams_theme", "params_fat", "params_layout", "pins_fat", "paramsingfont", " params_layout", "paramsingfat", "params_password", "params_pen", "pins_font", " params_shadow", "params_chart"], "font_size": ["font_scale", "font_align", "font_handle", "fontBlocksize", " font_handle", " font_scale", "font_type", "font\u00b7handle", "text_size", "font\u00b7number", "text_Size", "font_number", " font_Size", "font_Size", "text_align", "fontBlocktype", "font\u00b7size", " font_number", "fontBlockalign", "text_type", "fontBlockSize"], "style": [" size", "force", "letter", "shape", "height", "depth", "offset", "format", "grade", "order", "pattern", "count", "styles", "pad", "scale", "class", "font", "position", "family", "padding", "type", "width", "css", "length", "color", "size", "Style", "estyle", "name", "thin", "margin", "shadow", "layout", "weight", "level", "theme", " Style", "profile"], "font_Family": ["font_family", "fontNameStyle", "fontNamefamily", "style_family", "fontNameFamily", "style_Style", " font_fam", "fontingStyle", "font_fam", "fontingFamily", "font_Format", " font_Format", "fontingfamily", " font_family", "style_Family", "font_Style"], "globalFont": ["generalText", "GlobalText", "globalfont", "Globalfont", "parentFont", "generalFontSize", "localFontSize", "parentFontSize", " globalfont", "GlobalFont", " globalText", "parentfont", " globalFontSize", "generalFont", "parentText", "globalText", "localText", "localFont", "GlobalFontSize", "globalFontSize"], "params_pts": ["params_cts", "params_ptss", "params_epts", "params_ptn", "params__ctm", "params_PTp", "params_ptm", "params_PTn", "params__ctn", "params_PTs", "params_rtm", "params_eptp", "params_PTss", "params_tda", "params_ptp", "params_fontn", "params_tde", "params_PTa", "params_tds", "params_fontp", "params_pta", "params_PTm", "params__ptm", "params__pts", "params_rtn", "params_fontss", "params__ptn", "params_pte", "params_ctm", "params_erts", "params_fonts", "params_ctn", "params__cts", "params_PTe", "params_erte", "params_rts", "params_eptn", "params_eptss", "params_erta"], "params_data": ["param\n", "Parametersname", "params\n", " paramsname", "Parameters\n", "paramsname", " params\n", "paramname"]}}
{"id1": "15018553", "id2": "13595251", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["decryption", "encryption", "Enccrypt", "secipher", "Encrypt", "secrypt", "secryption", "decrypt", "Encryption", "encipher", "seccrypt", "deccrypt", "decipher", "Encipher", "enccrypt"], "text": ["image", "letter", "method", " Text", "hex", "content", "sequence", "input", "pattern", "message", "key", "output", "password", "bytes", "object", "struct", "string", "txt", "code", "class", "font", "contract", "buffer", "Text", "token", "path", "template", "source", "number", "secret", "length", "name", "test", "ext", "word", "data", "binary", "seed", "transfer", "str", "connection", "config", "TEXT", "address"], "md": ["dd", "mi", "sha", "cmd", "dr", "am", "dig", "metadata", "ma", "amd", " MD", "hd", "mm", "mo", "message", "ms", "ld", "wd", "mp", "hash", "gb", "mn", "mand", "d", "m", "bd", "pg", "ad", "cmp", "pm", "df", "mt", "mg", "mac", "sm", "od", "me", "mk", "cm", "MD", "Cmd", "mod", "data", "pd", "mag", "rm", "dm", "mc", "em", "mb", "pkg", "hm", "meta", "db"], "md5hash": ["md256hex", " md4block", "md2block", "md7sum", "md5hex", "MD5hex", "md512key", " md4hash", "md4hash", "md4Hash", "md4log", "md25log", " md5log", " md5sum", "md256hash", "md4sum", "md5block", "md2Hash", "md7hash", "md4block", "md5key", "MD5hash", "MD512hex", "md7Hash", "md6hash", " md4sum", "md2sum", "md5sum", "md6hex", "md6Hash", " md5block", "md25Hash", " md4Hash", "md25hash", "md6log", "md512hash", "MD512key", "md5Hash", "md6key", "md7block", "MD512hash", "md2hash", " md4log", "md512hex", "MD5key", "md6sum", "md256key", "md25sum", "md5log", " md5Hash"]}}
{"id1": "9267602", "id2": "18164929", "code1": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"urltext": ["urlbr", "URLobject", "urlobject", "urlTEXT", "feedbr", "filebr", "urlfeed", "lltext", "llTEXT", "filename", "URLTEXT", " urlbr", "urlname", "feedtext", " urlobject", "feedname", " urlname", "URLtext", "feedfeed", "llobject", "filefeed", " urlTEXT", " urlfeed", "filetext"], "url": ["image", "log", "URL", "base", "resource", "service", "feed", "this", "Url", "ball", "open", "ref", "http", "zip", "queue", "l", "b", "page", "string", "r", "bel", "buffer", "db", "uri", "plug", "out", "blog", "name", "socket", "ssl", "server", "id", "file", "data", "user", "sl", "i", "lib", "connection", "jar", "source", "web", "f", "address"], "in": ["ini", "kin", "err", "login", "stream", "gin", "inn", "inner", "input", "In", "inc", "cms", "l", "bin", "b", "read", "r", "IN", "buffer", "source", "line", "nin", "min", "out", "client", "ins", "is", "into", "as", "loader", "init", "ssl", "inside", "data", "file", "id", "isin", "reader", "i", "din", "f", "lin", "s"], "inputLine": ["InputLine", "outputBlock", "execData", "InputByte", "outputL", "Inputline", "outputByte", "inputData", "execline", "inputStream", " inputStream", " inputByte", "outputline", " inputL", "inputByte", " inputData", "InputBlock", "inputline", "InputL", "execLine", "rawL", "outputLine", "inputString", " inputline", "inputL", " inputBlock", "rawLine", "inputBlock", "rawString", "outputStream", "InputString", "outputData", "rawline", " inputString", "execStream"]}}
{"id1": "4602568", "id2": "22503685", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "label": 0, "substitutes": {"storeImage": ["processIcon", "processVideo", "storeMedia", " storeVideo", "processImage", " storeMedia", "storeVideo", "processMedia", " storeIcon", " transferIcon", "storeIcon", " transferMedia", " transferImage", " transferVideo"], "inStream": [" inReader", "winStream", "winSteam", "winVideo", "inputPath", "inputstream", "inSteam", "inputStream", "winReader", "INStream", "inCh", " instream", "inPath", " inVideo", "INPath", "INCh", " inPath", "inReader", " inSteam", " inCh", "inputSteam", "INstream", "inputReader", "instream", "inputVideo", "inVideo", "inputCh"], "fileName": ["httpname", "fileNames", " filePath", "imageName", "httpName", "filePath", "FILEName", "resourceInfo", "filename", "imageNames", "FileInfo", " fileNames", " filePart", " fileNode", "FILEPath", "FilePart", "FilePath", "fileInstance", "filePart", "imagename", "FILEInstance", "FileName", "FileInstance", "Filename", " fileInstance", " filename", "FileNames", "fileNode", "FILEname", "resourceName", " fileInfo", "httpPath", "resourceNode", "fileInfo", "httpPart", "imagePath", "FILENode", "resourcename", "FILEInfo"], "resize": [" Resized", " Resizes", "resizes", " Resizer", " resizer", " Resize", "resized", "Resize", " resizes", "Resizer", "resizer", " resized", "Resizes", "Resized"], "rightNow": ["thirdThen", "straightAccount", "thirdnow", "thirdCurrent", "dayNOW", "thirdNOW", " rightnow", "thirdNow", "thirdToday", "dayNow", "dayToday", " rightAccount", "RightAccount", "rightNOW", "rightAccount", "straightToday", "dayCurrent", "RightToday", "rightnow", " rightToday", "straightNow", " rightThen", " rightNOW", " rightCurrent", "Rightnow", "RightNow", "rightToday", "straightnow", "RightCurrent", "RightNOW", "rightCurrent", "rightThen"], "dayNamedFolderName": ["dayNestedDirectoryname", "dayNamedFoldername", "dayNamedFolderPath", "dayNamedAreaSize", "dayNamedFolderInfo", "dayNamedfolderName", "dayNamedFolderSize", "dayNestedFolderSize", "dayNestedFolderName", "dayNamedFileKey", "dayNamedFileInfo", "dayNamingFolderName", "dayNamedfolderInfo", "dayNestedDirectorySize", "dayNnamedFolderInfo", "dayNestedDirectoryName", "dayNestedDirectoryPath", "dayNamedDirName", "dayNamingFolderKey", "dayNamedDirInfo", "dayNamingFolderSize", "dayNamedAreaname", "dayNamedAreaName", "dayNnamedFolderSize", "dayNamedDirectoryName", "dayNnamedFolderName", "dayNestedFoldername", "dayNamedFilePath", "dayNamedDirSize", "dayNamedfoldername", "dayNnamedFolderPath", "dayNamedDirectoryname", "dayNamedfolderPath", "dayNamedDirectorySize", "dayNamingFolderInfo", "dayNamedfolderSize", "dayNestedFolderPath", "dayNamedFolderKey", "dayNamedDirectoryPath", "dayNamedFileName", "dayNamedFileSize", "dayNamedAreaPath", "dayNamedDirKey"], "uploadDirRoot": [" uploadFileRoot", "uploadFolderroot", "inputDirName", " uploadDirroot", " uploadDirHome", "uploadFolderBase", "uploadFilePath", "uploadDirectoryBase", "inputDirRoot", "UploadFolderRoot", "uploaddirroot", "uploadBaseroot", "uploadBaseRoot", "uploadDbHome", "UploadDirroot", "uploadBasePath", "inputDirectoryName", "UploadFolderroot", "uploadDirPath", "UploadFolderBase", "uploadFileRoot", "uploadDirectoryPath", "uploadDbRoot", "uploadDirroot", "inputDirectoryHome", "UploadDirPath", "uploadDirectoryRoot", "uploadFolderRoot", "uploadFileHome", "uploadDirHome", "inputDirPath", "inputDirectoryPath", "UploadDirRoot", "uploadDirBase", "uploadDbName", "inputDirHome", "uploaddirHome", "inputDirectoryRoot", "uploadDirectoryHome", "uploadDirName", "uploadBaseBase", "UploadFolderPath", "uploadDbPath", "uploadFileroot", "uploadDirectoryName", "uploadDirectoryroot", "uploaddirRoot", " uploadFileHome", "uploadFolderPath", "uploadFileName", "UploadDirBase", " uploadFileroot"], "file": ["File", "image", "folder", "log", "base", "flow", "unit", "service", "child", "model", "force", "view", "rule", "function", "ile", "entry", "fe", "up", "http", "zip", "local", "b", "full", "object", "auto", "page", "home", "url", "class", "pe", "files", "path", "work", "handler", "p", "line", "part", "out", "fp", "book", "dir", "FILE", "name", "user", "document", "e", "comment", "per", "lib", "connection", "parent", "f", "directory"], "extension": ["exversion", "exion", "extend", "exension", "intension", "xtend", "ExtION", "intION", "EXTdivision", "Extend", "intend", "xtion", "interion", "interension", "exdivision", "EXTversion", "xtION", "extdivision", "extversion", "extION", "interdivision", "Extension", "EXTension", "Extion", "intion", "interversion", "xtension", "extion", "EXTion"], "outFileName": ["outLineLocation", " outFileSystem", "inLinePath", "outPathType", "inFilePath", "inFileKey", "OutDirInfo", "OutFileInfo", "outFileKey", "outPathPath", "outfileLocation", " outFilename", "outDirInfo", "outFileType", "inFileInfo", "outLinePart", "outFolderLine", "outPlaceAddress", "outPlaceSystem", "OutDirLength", "outLinename", "outFileLength", "inLineInfo", " outPlaceLine", "outFieldSystem", " outFilePath", "outFolderInfo", "OutDirName", "outLineSize", "outLineName", "outfileLength", "outPathName", "outFileInfo", "outDirName", "outLineType", "outfileName", "outFolderPath", "inLinePart", " outFileAddress", "outFileLine", "outDirPart", "outPlaceLocation", " outPlaceAddress", "outfileSize", "outFullKey", "OutFileName", "outPlaceSize", "inLineName", "outLinePath", "outLineKey", "outFullPart", "outPathname", "outLineLength", " outPlaceLocation", "outFilePart", "outFieldLine", " outPlacePath", "outFieldAddress", "outfilePath", " outFileSize", "outFilePath", "outFilename", "outDirLength", "outFileSize", "outFileLocation", "OutDirPath", " outFileLine", "inLineKey", " outPlacename", " outPlaceSystem", "outLineInfo", "outPlaceLine", "outFolderName", "inFileLine", "outPlaceName", " outFileType", "outfileInfo", "outFieldName", " outPlaceName", " outPlaceSize", "outPlaceType", "OutFileLength", "outPlacename", "outDirLine", "outDirKey", "outFullPath", "outFolderAddress", "OutFilePath", "inFileName", "inLineLine", "outFolderSystem", "outPlacePath", "outDirPath", "outFileAddress", " outFileLocation", " outPlaceType", "outFileSystem", "inFilePart", "outFullName", "outLineLine"], "outPathAndName": ["outPathANDPath", "outNameOrAddress", "outPathOrRam", "outpathAndTime", "outNameOrName", "outpathOrPath", "outPathANDRam", "outNameOrPath", "outPathandNames", "outPathANDNames", "outPathOrPath", "outNameOrRam", "outpathOrNames", "outPathANDAddress", "outpathAndname", "outPathOrname", "outPathOrTime", "outNameAndRam", "outpathAndName", "outPathANDTime", "outNameAndPath", "outNameAndAddress", "outPathandPath", "outPathOrNames", "outPathOrAddress", "outPathAndPath", "outPathandName", "outPathAndRam", "outPathAndname", "outpathAndNames", "outpathAndPath", "outPathAndNames", "outPathOrName", "outNameAndName", "outPathAndAddress", "outPathAndTime", "outPathANDname", "outPathANDName", "outpathOrName"], "uploadedFile": ["uploadenedFile", "UploadpedFiles", "uploadendedPath", "uploadatedFiles", "UploadedImage", "uploadedImage", "uploadizedImage", "uploadedFull", "uploadededFull", "uploadchedF", "processedF", "uploadedF", "processedPath", "UploadedFolder", "uploadizedFull", "uploadenedFiles", "processchedF", "uploadedfile", "UploadedFull", "UploadpedImage", "uploadendedF", "uploadedFolder", "uploadratedfile", "uploadededImage", "processchedPath", "uploadratedPath", "UploadpedFull", "uploadchedFile", "processedfile", "uploadatedfile", "uploadpedfile", "uploadratedFile", "uploadchedPath", "uploadedPath", "UploadpedFile", "uploadatedFolder", "UploadpedFolder", "processedFile", "UploadedFile", "uploadpedFull", "processchedfile", "Uploadpedfile", "uploadendedfile", "uploadizedFiles", "processchedFile", "uploadedFiles", "uploadpedFile", "uploadenedfile", "uploadatedFile", "uploadededFiles", "uploadededFile", "uploadizedFile", "uploadratedF", "uploadpedFolder", "Uploadedfile", "uploadpedImage", "uploadendedFile", "uploadchedfile", "uploadpedFiles", "UploadedFiles", "uploadenedFolder"], "outStream": ["_", "tempFile", "URL", "format", "outFile", " outFile", "Url", "tempSteam", "inFile", "inSteam", "Type", "Bytes", "Directory", "tempBuffer", "New", "inBuffer", " outBuffer", "outSteam", "tempStream", "Copy", "s", " outSteam", "url", "outBuffer"]}}
{"id1": "10759917", "id2": "20310134", "code1": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"delete": ["link", "de", "register", "create", "del", "flush", "write", "load", "sync", " deleting", "post", "update", " deletion", " Delete", "drop", "remove", "dump", "execute", "id", " destroy", "Delete", "database", "get", "connection", "destroy", "exec", "save"], "name": ["link", "action", "model", "base", "resource", "create", "NAME", "prefix", "alias", "none", "active", "version", "filename", "key", "label", "table", "info", "now", "object", "space", "style", "string", "class", "ame", "null", "code", "definition", "pass", "path", "Name", "type", "part", "named", "client", "size", "missing", "word", "id", "data", "on", "true", "e", "false", "names", "no", "comment", "old", "database", "n", "value", "default", "time", "like", "one", "parent", "url", "address"], "CannotDeleteSystemLinkException": ["CannotDeleteSysLinkception", "CannotDeleteSystemLinkError", "CannotDeleteSysLinkException", "CannotDeleteClassLinkInformation", "CannotDeleteSystemLinksException", "CannotDeleteSystemLinksInformation", "CannotDeleteSysLinkError", "CannotDeleteSystemRelception", "CannotDeleteSystemReferenceception", "CannotDeleteSystemlinkception", "CannotDeleteSystemLinkApplication", "CannotDeleteSystemlinkException", "CannotDeleteClassLinkException", "CannotDeleteSystemLinksception", "CannotDeleteSystemRelException", "CannotDeleteSystemLinkception", "CannotDeleteClassLinkception", "CannotDeleteSystemLinksApplication", "CannotDeleteSystemReferenceException", "CannotDeleteSystemlinkApplication", "CannotDeleteSystemReferenceError", "CannotDeleteSystemLinkInformation", "CannotDeleteSysLinkEx", "CannotDeleteSystemRelEx", "CannotDeleteSystemLinkEx", "CannotDeleteSystemReferenceEx", "CannotDeleteSystemRelError", "CannotDeleteClassLinkApplication", "CannotDeleteSystemlinkInformation"], "ClassLinkTypeNotFoundException": ["ClassLinkTypeNotfoundException", "ClassLinkTypeNotFoundError", "ClassLinkTypeNotSourceRequest", "ClassLinkTypeNotfoundError", "ClassLinkTypeNotFoundRequest", "ClassLinkTypeNotSourceException", "ClassLinkTypeNotSourceError", "ClassLinkTypeNotfoundRequest"], "conn": ["enc", "ou", "lc", "ver", "nt", "config", "serv", "coll", "dc", "po", "cli", "oci", "nc", "pc", "cur", "open", "rt", "Connection", "ns", "cache", "ca", "exec", "sync", "ch", "bb", "cat", "ann", "pr", "cb", "c", "act", "session", "ct", "orp", "core", "query", "ci", "p", "conf", "org", "oss", "client", "cc", "util", "pub", "close", "cm", "ssl", "ac", "co", "con", "h", "cn", "server", "ec", "ob", "dn", "cond", "connect", "lock", "mc", "Conn", "error", "n", "ctx", "cp", "connection", "loc", "uc", "db", "pg"], "stmt": ["stob", "Stdt", " stmm", "ctmd", "stlt", "strsql", "Stmm", "Stmt", "estmt", "istdt", "strmd", "Stmn", "rdmt", "rdsql", "ctmt", "sthmt", "stmp", "rddd", "sthmd", "Stdb", "stmd", "STsql", " stsql", "Stnt", "stsql", "playdt", "Stmp", "estlt", "sthdb", " stmn", "stnt", "stmn", "sthmn", "strlt", "playmt", "STlt", " stob", "estdd", " stmd", "stmm", "strnt", " stdd", "Stmd", "Stob", "stdd", "estsql", " stmb", "strmp", "stm", " stmp", "strmm", "strmt", "rdmd", "istmt", "istmd", "strmb", "strob", "STdd", "ctmb", "strdd", " stnt", "Stm", " stm", "stdt", "istnt", "stmb", " stdb", "stdb", "playnt", "playmd", "Stmb", "ctm", "STmt", "strm"], "prepTable": ["supable", "Preptable", "prepType", "initTable", "inittable", " prepCol", "PrepType", " prepable", "parCol", "partable", "prepable", "PrepTable", "prepCol", "initType", "supTable", "preptable", "Prepable", " preptable", "supType", "parType", " prepType", "suptable", "initCol", "parTable"], "objectLinkTable": ["objLinkStore", "objectLinkFile", "objlinkTable", "objectlinkTable", "objectLineTable", "objectLinkType", "ObjectLinkFile", "objectTypeFile", "objectlinkTab", "objectLineSource", "objLinkType", "objectlinkFile", "objectlinkSource", "objLinkChain", "objectRelStore", "objectlinkChain", "objectLinkChain", "ObjectLineTable", "ObjectLinkTab", "objectRelType", "objectSyncStore", "objectlinkType", "objectSyncChain", "objectLinkStore", "objlinkStore", "objectSyncType", "objectLineTab", "objectlinkStore", "objlinkType", "objectTypeSource", "objectLinkSource", "objlinkChain", "ObjectLineTab", "ObjectLinkTable", "objectTypeTab", "objectRelChain", "objectTypeTable", "objectLinkTab", "ObjectLineSource", "objectRelTable", "ObjectLineFile", "objLinkTable", "objectLineFile", "objectSyncTable", "ObjectLinkSource"], "sql": ["log", "cmd", "function", "ls", "SQL", "zip", "shell", "csv", "pr", "update", "string", "summary", "spec", "params", " SQL", "query", "join", "result", "ql", "sg", "sb", "sv", "su", "insert", "sq", "expression", "statement", "ssl", "term", "id", "sf", "general", "description", "comment", "str", "sl", "dl", "select", "db", "url", "s"]}}
{"id1": "17716716", "id2": "160705", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    public static boolean downloadFile(String url, String destination) throws Exception {\n        BufferedInputStream bi = null;\n        BufferedOutputStream bo = null;\n        File destfile;\n        byte BUFFER[] = new byte[100];\n        java.net.URL fileurl;\n        URLConnection conn;\n        fileurl = new java.net.URL(url);\n        conn = fileurl.openConnection();\n        long fullsize = conn.getContentLength();\n        long onepercent = fullsize / 100;\n        MessageFrame.setTotalDownloadSize(fullsize);\n        bi = new BufferedInputStream(conn.getInputStream());\n        destfile = new File(destination);\n        if (!destfile.createNewFile()) {\n            destfile.delete();\n            destfile.createNewFile();\n        }\n        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n        int read = 0;\n        int sum = 0;\n        long i = 0;\n        while ((read = bi.read(BUFFER)) != -1) {\n            bo.write(BUFFER, 0, read);\n            sum += read;\n            i += read;\n            if (i > onepercent) {\n                i = 0;\n                MessageFrame.setDownloadProgress(sum);\n            }\n        }\n        bi.close();\n        bo.close();\n        MessageFrame.setDownloadProgress(fullsize);\n        return true;\n    }\n", "label": 0, "substitutes": {"plainToMD": [" string2Hash", " string2String", " string2DER", " input2MD", " stringtoMD", " stringTODER", " string2MD", " input2String", " stringToString", " stringtoDER", " inputToDER", " stringTOHash", " inputToMD", " input2DER", " stringTOMD", " input2Hash", " stringTOString", " stringToMD", " stringToDER", " stringtoHash", " inputToHash", " stringToHash", " inputToString", " stringtoString"], "loggerCol": ["loggeCol", "loglercol", "loggingColumn", "loggerCollection", "progercol", "loggeeDr", "loggingCol", "pluggercol", "loggingCollection", "progingColumn", "logorerCol", "loglerCol", "loggeeCol", "progerColumn", "loggerDr", "loggeCor", "progingCol", "loggecol", "pluggingCor", "loggingDr", "loggeeCor", "loggingCor", "progerCol", "logorercol", "loggerCor", "loggercol", "progerCollection", "pluggingCol", "loggingcol", "pluggingcol", "progingcol", "pluggerDr", "loglerColumn", "loggeDr", "pluggerCol", "loggerColumn", "pluggingDr", "loglerCollection", "logorerCollection", "logorerColumn", "progingCollection", "loggeecol", "pluggerCor"], "input": ["image", "model", "base", "in", "cmd", "raw", "temp", "form", "inf", "format", "audio", "Input", "alpha", "text", "output", "list", "password", "url", "string", "null", "IN", "buffer", "state", "path", "plus", "container", "context", "xml", "ssl", "request", "data", "file", "instance", "str", "empty", "reader", "connection", "config", "source", "dict"], "byteHash": [" byteSum", "wordArray", " byteArray", "Bytehash", "bitSum", "blockHash", "byteSalt", "byteBlock", "stringHash", "stringSalt", "wordSum", "ByteSum", " byteBlock", "blockhash", "byteArray", "bithash", "bytesSalt", "bitBlock", "bitHash", " byteSalt", "bitArray", "blockBlock", "wordhash", "byteshash", "byteSum", " bytehash", "ByteHash", "ByteBlock", "wordHash", "bytesArray", "blockSum", "stringArray", "stringhash", "bytesHash", "bytehash"], "md": ["dd", "nm", "cmd", "dr", "meta", "am", "dig", "metadata", "ma", "amd", " MD", "um", "mm", "mo", "mu", "ms", "cd", "mp", "hash", "mn", "mand", "d", "ph", "bd", "ad", "doc", "pm", "df", "mg", "mt", "sm", "mac", "cc", "Msg", "cm", "MD", "Cmd", "mod", "msg", "dh", "pd", "mag", "rm", "dm", "mc", "pkg", "mb", "hm", "di", "m", "rpm", "f"], "md5result": [" md5Result", "md6package", "md7report", " md25result", "md5report", " md7Result", "md4response", " md305runner", "md53result", "md512Result", " md5report", "md512result", " md305results", "md6data", "mddownpackage", " md25data", "md5Result", "md5package", "md4results", "md4runner", "md5runner", "mddownResult", "md305results", "md305runner", "md6report", " md5data", "md7Result", " md305response", "md7result", " md7result", "md5results", "md7results", " md25Result", "md53runner", " md5results", "md25result", "md512report", " md25package", "md6results", " md5runner", "md305result", "md5response", "mddowndata", "md53response", "md53results", " md5response", "md25data", "md305response", " md7report", "md6result", "md512results", "md5data", " md305result", "md25package", " md7results", "md25Result", "mddownresult", " md5package", "md6Result", "md4result"], "i": ["z", "index", "j", "o", "oi", "hi", "ii", "fi", "key", "mu", "l", "b", "ui", "ri", "pi", "c", "r", "gi", "d", "li", "ci", "p", "multi", "si", "xi", "io", "I", "bi", "v", "x", "ai", "uri", "ji", "length", "ti", "h", "id", "qi", "e", "u", "n", "di", "f", "zi", "s"]}}
{"id1": "15202804", "id2": "4852691", "code1": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"getDigest": ["getPedest", "getdigests", "getSignex", "createDigests", "getPedester", "getDigests", "getSignest", "createdigester", "createDigester", "createDigex", "getdigex", "createdigests", "createdigex", "getdigester", "createdigest", "getDigester", "getdigest", "getSignester", "getSignests", "getPedests", "getPedex", "getDigex", "createDigest"], "user": ["force", "mail", "login", "account", "root", "up", "human", "use", "key", "User", "full", "replace", "uid", "home", "string", "class", "usr", "USER", "creator", "pass", "job", "author", "client", "bug", "users", "manager", "name", "server", "id", "parent", "username", "date", "profile", "host", "project", "plugin", "url", "owner", "address"], "realm": ["realme", "schem", "realmd", "calms", "runmid", "realms", "scheme", "runmon", "runme", "runm", "Realmid", "calm", "calmd", "Realm", "Realme", "Realmd", "rootmid", "rootme", "calme", "Realms", "rootmon", "schems", "rootm", "realmid", "Realmon", "realmon", "schemd"], "password": ["Password", "login", "email", "account", "function", "pattern", "channel", "mode", "text", "key", "wd", "pad", "string", "params", "pass", "crypt", "token", "path", "padding", "phrase", "sudo", "priv", "secret", "client", "manager", "auth", "ssh", "name", "PASS", "word", "username", "sword", "host", "address"], "method": ["mail", "resource", "module", "prefix", "function", "METHOD", "version", "mode", "text", "message", "http", "use", "string", "hash", "class", "session", "route", "pass", "path", "sort", "type", "secret", "Method", "dir", "manager", "auth", "name", "id", "range", "username", "hod", "time", "host", "project", "md", "url", "address"], "uri": ["origin", "image", "unit", "base", "resource", "prefix", "directory", " URI", "direction", "cli", "text", "message", "http", "filename", "remote", "environment", "api", "ui", "ri", "subject", "route", "path", "query", "type", "secret", "URI", "manager", "name", "proxy", "verb", "archive", "server", "id", "file", "range", "username", "i", "database", "host", "url", "address"], "nonce": ["nface", "nCE", "Nonce", "nancer", " nonces", " noncode", "nance", "nances", "nancode", " noncer", "Nonface", " nonCE", "ncer", "noncode", " nonface", "nce", "noncer", "nonces", "nonCE", "boncer", "bonce", "nonface", "boncode", "NonCE", "Noncer", "bonces"], "digest1": ["DigestOne", "Digestone", "digengeOne", "digenge2", "Digester2", "Digesterone", "digested2", "digESTPre", "digEST2", "digengeone", "digESTone", "digested1", "DigestPre", "DigesterPre", "Digest2", "DigesterOne", "digestedPre", "digester2", "digESTOne", "digestone", "digestPre", "digester1", "digestedOne", "digesterOne", "digEST1", "Digest1", "digesterone", "Digester1", "digesterPre", "digenge1"], "digest2": ["digesterTwo", "digest5", "digESTTwo", "digenge2", "Digester2", "digessBoth", "Digester5", "DigesterTwo", "digEST5", "DigesterSecond", "DigestBoth", "digestBoth", "digesterSecond", "digEST2", "digests2", "Digest2", "digengeBoth", "digestSecond", "digester2", "digesterBoth", "digESTSecond", "DigestTwo", "digessTwo", "digester5", "digester1", "DigestSecond", "digengeTwo", "Digest1", "digess1", "DigesterBoth", "digestsSecond", "digests5", "Digest5", "digess2", "Digester1", "digestsTwo", "digenge1"], "digestOne": ["DigestOne", "digesterTwo", "digestAnd", "digertOne", "DigestSingle", "Digestone", "digertONE", "digengeOne", "digastNine", "Digesterone", "digesterNine", "digastTwo", "digestSingle", "digestedTwo", "DigesterTwo", "digast1", "DigesterONE", "DigestNine", "digengeone", "DigesterSingle", "digESTone", "digested1", "digessONE", "DigestONE", "digesterSingle", "DigesterAnd", "DigesterOne", "digestedNine", "digesterONE", "digengeAnd", "digert1", "digesterAnd", "DigestTwo", "digESTOne", "digessSingle", "digestONE", "digestone", "digestNine", "digester1", "digestedOne", "digertSingle", "digesterOne", "Digest1", "digess1", "digEST1", "digastOne", "DigestAnd", "digesterone", "digESTAnd", "Digester1", "DigesterNine", "digessOne", "digenge1"], "hexDigestOne": ["hexdigestTwo", "hexDigess1", "hexDigessone", "hexDigested1", "hexDigesting1", "hexDigestSingle", "hexDigestedSingle", "hexDigestedOne", "hexDigest1", "hexDigessOne", "hexDigesterTwo", "hexdigesterOne", "hexDigesterOne", "hexDigesterone", "hexdigestSingle", "hexdigest1", "hexdigesterone", "hexDigessSingle", "hexDigestedone", "hexDigestingTwo", "hexDigestingOne", "hexDigester1", "hexDigestedTwo", "hexDigestingone", "hexdigestOne", "hexdigesterTwo", "hexdigesterSingle", "hexDigestone", "hexdigester1", "hexDigesterSingle", "hexdigestone"], "digestTwo": ["digesterFive", "digestFour", "digesterTwo", "digestedFour", "DigestFour", "digaceFive", "Digester2", "digested2", "digestedMany", "DigesterTwo", "digestedTwo", "DigesterSecond", "digaceFour", "digestedtwo", "digerFour", "DigesterMany", "digesterSecond", "DigestFive", "digesttwo", "Digestertwo", "digist2", "digesterFour", "Digest2", "digistFive", "diger2", "digistFour", "Digesttwo", "digestSecond", "digester2", "DigestMany", "DigestTwo", "digertwo", "digistTwo", "digerTwo", "digestertwo", "DigestSecond", "DigesterFive", "digestFive", "digestMany", "digaceTwo", "DigesterFour", "digesterMany", "digace2", "digestedSecond"], "hexDigestTwo": ["hexDiggestTwo", "hexDigestedHalf", "hexDiggest2", "hexDigestedOne", "hexDigestedtwo", "hexDigestertwo", "hexDigesterTwo", "hexDigest2", "hexDigests2", "hexDigesterOne", "hexDigesterHalf", "hexDiggestHalf", "hexDigested2", "hexDiggestOne", "hexDigestedTwo", "hexDigestsOne", "hexDigester2", "hexDigestHalf", "hexDigesttwo", "hexDigestsTwo", "hexDigeststwo"], "digest3": ["digESTThree", "digestThird", "DigestThird", "digenge3", "digEST53", "digEST03", "digestedThree", "digester3", "digesterThree", "DigestThree", "Digester03", "digested03", "digested3", "Digester3", "digestedThird", "digengeThree", "Digest3", "digESTThird", "Digest03", "Digester53", "digenge53", "DigesterThree", "DigesterThird", "digester03", "digesterThird", "digest03", "digengeThird", "Digest53", "digester53", "digest53", "digEST3"], "digestThree": ["digseEight", "diggest3", "digessEight", "digesterTwo", "digestThird", "DigestThird", "digESTThree", "diggest103", "digester3", "digesterThree", "Digest103", "DigesterTwo", "DigestThree", "Digester103", "dighestThree", "digerThree", "dighest3", "Digester3", "Digest3", "digestEight", "digess3", "DigesterEight", "digest103", "DigestEight", "digerThird", "digESTThird", "DigesterThree", "digseThird", "diggestThree", "dighest103", "DigesterThird", "DigestTwo", "digse3", "diger3", "digesterThird", "digEST3", "digester103", "diggestTwo", "digseThree", "digESTEight", "digerEight", "digessThird", "dighestTwo", "digesterEight", "digessThree"], "hexDigestThree": ["hexDigested183", "hexdigesterThird", "hexDigesterThird", "hexDigester183", "hexDigestThird", "hexDigesterThree", "hexDigest3", "hexDigestthree", "hexdigesterThree", "hexdigestThird", "hexDigestedThird", "hexDigeststhree", "hexdigester3", "hexDigesting3", "hexdigest183", "hexDigests3", "hexDigestingthree", "hexDigess3", "hexDigestsThird", "hexDigestingThird", "hexDigestedThree", "hexDigessThree", "hexdigestThree", "hexDigest183", "hexDigessThird", "hexDigested3", "hexDigester3", "hexDigestsThree", "hexDigesterthree", "hexdigest3", "hexDigestingThree", "hexDigess183", "hexdigester183"]}}
{"id1": "442381", "id2": "6682825", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    KeyStore getKeyStore() throws JarSignerException {\n        if (keyStore == null) {\n            KeyStore store = null;\n            if (providerName == null) {\n                try {\n                    store = KeyStore.getInstance(this.storeType);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                try {\n                    store = KeyStore.getInstance(storeType, providerName);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                } catch (NoSuchProviderException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (storeURI == null) {\n                throw new JarSignerException(\"Cannot load the keystore \" + \" error con el keystore\");\n            }\n            try {\n                storeURI = storeURI.replace(File.separatorChar, '/');\n                URL url = null;\n                try {\n                    url = new URL(storeURI);\n                } catch (java.net.MalformedURLException e) {\n                    url = new File(storeURI).toURI().toURL();\n                }\n                InputStream is = null;\n                try {\n                    is = url.openStream();\n                    store.load(is, storePass);\n                } finally {\n                    if (is != null) {\n                        is.close();\n                    }\n                }\n            } catch (Exception e) {\n                throw new JarSignerException(\"Cannot load the keystore \" + storeURI, e);\n            }\n            keyStore = store;\n        }\n        return keyStore;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVERSIONWork", "doversionTest", "doVersionTest", "doBuildCheck", " doReleaseTest", "doReleasecheck", " doVersionWork", " doBuildTest", "doBuildcheck", "doVERSIONTest", " doBuildWork", "doBuildWork", "doversionCheck", "doReleaseWork", " doBuildcheck", "doVersionWork", " doBuildCheck", "doReleaseCheck", "doBuildTest", "doVERSIONcheck", " doVersioncheck", " doReleasecheck", "doVERSIONCheck", " doVersionTest", "doVersioncheck", " doReleaseCheck", "doReleaseTest", "doversioncheck"], "view": ["body", "image", "model", "html", "box", "q", "change", "can", "this", "self", "event", "form", "input", "edit", "window", "accept", "http", "cache", "widget", "vis", "use", "l", "full", "ui", "object", "page", "show", "views", "update", "display", "style", "session", "buffer", "gui", "div", "v", "row", "out", "client", "block", "see", "gu", "app", "View", "request", "sel", "server", "layout", "cell", "port", "e", "VIEW", "comment", "lock", "reader", "el", "config", "screen"], "url": ["image", "log", "URL", "base", "resource", "service", "stream", "input", "Url", "open", "hub", "channel", "http", "zip", "l", "bb", "string", "bel", "buffer", "path", "uri", "build", "client", "blog", "loader", "ssl", "server", "user", "file", "ll", "ob", "host", "browser", "sl", "lib", "connection", "source", "web", "f", "socket", "address"], "in": ["ini", "resource", "login", "stream", "gin", "inn", "inner", "input", "In", "inc", "b", "IN", "buffer", "source", "nin", "sin", "cin", "out", "ins", "is", "as", "init", "bis", "ac", "con", "data", "file", "binary", "rin", "isin", "reader", "win", "i", "n", "din", "socket", "lin", "s"], "bin": ["kin", "body", "log", "nb", "gin", "inn", "inner", "input", "bot", "din", "inline", "run", "b", "bb", "ruby", "spin", "pin", "IN", "border", "buffer", "abi", "oin", "part", "record", "bi", "cin", "out", "loader", "init", "bn", "con", "ln", "data", "file", "binary", "browser", "lock", "reader", "win", "lib", "fin", "sin", "socket", "lin"], "line": ["look", "link", "lc", "log", "unit", "base", "rule", "letter", "model", "end", "site", "nl", "lf", "cl", "lines", "inline", "entry", "LINE", "up", "day", "text", "message", "parse", "load", "Line", "key", "l", "b", "object", "page", "ine", "string", "code", "style", "home", "definition", "pe", "pass", "split", "job", "part", "row", "layer", "le", "block", "ip", "name", "word", "ge", "data", "file", "valid", "cell", "e", "band", "lo", "id", "str", "el", "i", "no", "comment", "non", "source", "lin"], "develBuild": ["DEVELBuild", "DEvelbuild", "devenBuilt", "desvenBuilt", "dewardBuilder", "deelBuilder", "desvelBuilder", "deployBuilt", "devenbuild", "deviousBuilt", "DEVELBuilt", "deVELBuilder", "DEVELBuilder", "devenRun", "DEvelBuilder", "develRun", "devenBuilder", "DEvelBuild", "dewardbuild", "DEVELbuild", "desvelBuilt", "desvenRelease", "deVELbuild", "deployRun", "deVELBuilt", "dewardBuild", "deelRun", "deelRelease", "desvelRelease", "devenBuild", "deelBuild", "desvelRun", "desvelBuild", "deployBuild", "desvelbuild", "dellRelease", "deVELBuild", "devenRelease", "desvenBuilder", "DEvelBuilt", "develbuild", "dellRun", "develBuilder", "deploybuild", "dewardBuilt", "dellBuild", "desvenRun", "deVELRun", "desvenbuild", "desvenBuild", "deployBuilder", "deviousBuild", "dellBuilder", "deviousbuild", "develBuilt", "develRelease"], "stableBuild": ["stableBuilder", "compatibleBuild", "prettyBuild", "secureBuild", "validbuild", "compatiblebuild", "compatibleBuilder", "staticBuild", "baseBuild", "stablebuild", "stableVersion", "secureBuilder", " stableBuilder", "validBuild", "securebuild", "prettyBuilder", "latestBuilder", "latestbuild", "staticBuilder", "staticbuild", "prettyVersion", "baseBuilder", "latestBuild", "basebuild", " stableVersion", "prettybuild", "baseVersion", "validBuilder", " stablebuild"]}}
{"id1": "310182", "id2": "21656668", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["oconversion", "CONversion", "oconverting", " deconverted", "CONverting", " deconvert", "conception", "CONception", " deconverting", "unverted", "subversion", "CONverted", "Conception", " deconversion", "oconvert", "unversion", "converted", "unception", "subvert", "conversion", "Convert", "unvert", "Converted", "subverted", "subverting", "converting", "oconverted", "Converting", "Conversion", "CONvert"], "src": ["video", "resource", "storage", "config", "stream", "Source", "impl", "gz", "RC", "input", "download", "feat", "req", "ref", "load", "back", "filename", "slice", "href", "cb", "prot", "url", "string", "code", "buf", "gb", "spec", "dist", "cpp", "rc", "stage", "sn", "path", "st", "sc", "cmp", "upload", "ource", "uri", "sb", "proc", "SourceFile", "sin", "img", "fp", "supp", "attr", "sit", "secure", "tmp", "name", "ssl", "Dest", "sel", "sys", "component", "file", "fn", "inst", "username", "sth", "reader", "rb", "rl", "ctx", "scene", "loc", "source", "obj", "s"], "dest": [" destination", "temp", "cont", "dc", "dat", "target", "bin", "home", "null", "txt", "class", "orig", "lib", "dist", "path", " dst", "img", "dir", "std", "tmp", "test", "Dest", "fn", "di", "source", "obj", "disk"], "in": ["ini", "err", "login", "stream", "inn", "inf", "val", "input", "In", "up", "bin", "pin", "r", "IN", "ps", "t", "pass", "d", "doc", "source", "io", "ins", "is", "as", "inas", "a", "data", "isin", "file", "ex", "i", "reader", "win", "n", "din", "f", "inc"], "p": ["np", "j", "o", "po", "pre", "py", "P", "pc", "cop", "parser", "l", "b", "jp", "pr", "bp", "lp", "pi", "pp", "sp", "pe", "c", "r", "wp", "g", "ps", "t", "pa", "d", "op", "pg", "part", "pm", "v", "fp", "pb", "h", "tp", "pd", "e", "i", "per", "cp", "m", "f", "s"], "ds": ["ths", "dp", "vals", "ls", "services", "ads", "ld", "lp", "groups", "dt", " ps", "os", "ins", "icks", "nas", "ts", "dates", "scripts", "s", "dc", "dat", "Ds", "points", "els", "sync", "tools", "ipes", "xs", "obs", "sts", "d", "ils", "dds", "hs", "gs", "docs", "sys", "pd", "dm", "ss", "dl", "des", "posts", " DS", "utils", "cons", "lines", "ns", "ges", "da", "tests", "ays", "dist", " props", "eps", "cs", "df", "uds", "gd", "qs", "ys", "data", "ded", "ks", "words", "di", "db", "parts", "dd", "ants", "vs", "amps", "ans", "DS", "dos", "plugins", "styles", "js", "ps", "rs", "ups", "models", "bs", " sd"], "format": ["letter", "model", "unit", "nat", "plugin", "prefix", "form", "function", "pattern", "at", "feat", "filter", "version", "parser", "atter", "filename", "sche", "api", "table", "Format", "struct", "style", "string", "class", "scale", "act", "spec", "t", "fd", "path", "handler", "ant", "template", "source", "type", "record", "part", "frame", "fp", "name", "language", "host", "data", "file", "layout", "fn", "magic", "config", "tag", "f", "url"], "hasPixelData": ["hasPixelStyle", "haspixeldata", "showsByteDATA", "hasByteStyle", " hasPixelSize", "hasByteDATA", "showsPixelDATA", "hasPixelDATA", "hasPictureSize", "hasPixeldata", "hasByteData", "hasPixelSize", "showsPixelData", "haspixelData", "hasPicturedata", "showsByteData", "hasByteSize", "showsByteStyle", "haspixelSize", "showsPixeldata", "showsBytedata", "showsPixelStyle", "hasBytedata", "hasPictureData", " hasPixeldata"], "inflate": ["inadequode", "infloation", "inadequATE", "InFlace", "infloace", "Inflation", "inflation", "InFlate", "Inflated", "inflode", "infolode", "insflating", "invenate", "insvenate", "infolate", "Inflate", "infolATE", "infolating", "InFlated", "insvenATE", "invenating", "inFlace", "inflace", "insflode", "invenode", "inadequating", "insvenating", "inffate", "InFlation", "insflate", "inffation", "invenATE", "infloated", "inffated", "inflating", "inFlate", "Inflace", "insflATE", "infface", "infloate", "inFlated", "inadequate", "insvenode", "inflated", "inflATE", "inFlation"], "pxlen": ["pxden", "pxdata", "mxlen", "campos", "pxln", "mxln", "pxlon", "camln", "mxcount", "pxlin", "pngsize", "xplength", "fxln", "xpsize", "pgden", "ppl", "pplen", "fxden", "pxsize", "pxcount", "fxpos", "axlin", "pclon", "ppLen", "pnglength", "txlon", "pnglen", "pxl", "mxlength", "xplen", "xpcount", "axlen", "txlin", "txln", "pxpos", "ppden", "mxdata", "pglen", "pgLen", "mxpos", "pxlength", "fxl", "pclen", "pgl", "camlen", "pclin", "camdata", "axln", "txlen", "pcln", "fxLen", "pxLen", "mxsize", "fxdata", "pngcount", "fxlen", "axlon"], "out": ["re", "err", "log", "point", "step", "cli", "inter", "up", "group", "cache", "output", "OUT", "list", "conn", "post", "page", "pad", "store", "session", "state", "again", "outs", "work", "query", "line", "io", "v", "Out", "co", "dump", "sys", "server", "user", "gen", "lock", "error", "lib", "parent", "obj", "copy"]}}
{"id1": "20310134", "id2": "16142024", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", "CopyChannel", "transferFile", "CopyFile", " copyfile", "Copyfile", " copyChannel", "copyFiles", "copyfile", "CopyFiles", "transferChannel", "copyChannel"], "in": ["image", "index", "base", "login", "config", "inner", "inn", "input", "In", "l", "bin", "c", "IN", "buffer", "again", "ic", "work", "query", "source", "io", "diff", "min", "ins", "as", "name", "id", "file", "data", "lock", "ex", "i", "reader", "m", "inc", "url", "lin"], "out": ["image", "base", "o", "resource", "prefix", "point", "w", "write", "plain", "cache", "output", "OUT", "b", "conn", "writer", "page", "string", "c", "external", "again", "outs", "p", "io", "v", "x", "img", "Out", "off", "name", "ext", "server", "user", "file", "call", "ex", "dot", "n", "default", "connection", "exec"], "inChannel": ["inConnection", "outchannel", "binChan", "loginChan", "insChan", "loginStream", "inChan", "inStream", "inGate", " inchannel", "InChan", "inputStream", "binChannel", "iniGate", "binGate", "INStream", "inputChannel", "inQueue", "loginChannel", "loginchannel", "inputConnection", " inChan", "outChan", "iniChannel", "iniStream", "InQueue", " inQueue", "inputChan", "INchannel", "INConnection", "iniChan", "outStream", "Inchannel", "InGate", "binchannel", "InStream", "INChan", "outQueue", "insStream", "InChannel", "insConnection", "INChannel", "inchannel", "binStream", "insChannel"], "outChannel": ["inConnection", " outChar", " outStream", "netChan", "outchannel", "outChar", "netStream", "OutConnection", "outputchannel", "netChannel", "inChan", "inStream", "netGate", "inGate", " outchannel", "outputGate", "ouChannel", "ouGate", "Outchannel", "outputChan", "outGate", "outChan", "outputChannel", " outChan", "outStream", "outputChar", "OutChannel", " outGate", "inChar", "ouChan", "outputStream", "ouchannel", " outConnection", "inchannel", "OutChan", "outConnection"]}}
{"id1": "16557837", "id2": "7149578", "code1": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"copyFromTo": ["transferFromWith", "copyDirFrom", "transferFromFile", "copyFromWith", "copyFileFile", "copyFromFrom", "copyDirTo", "transferFromFrom", "copyfromTo", "copyDirWith", "copyDirFile", "copyfromFrom", "transferfromFrom", "copyfromFile", "transferfromWith", "copyFileFrom", "copyFileWith", "transferfromFile", "transferFromTo", "copyFileTo", "transferfromTo", "copyFromFile", "copyfromWith"], "srcFile": ["sourceClass", "destSourceFile", " srcPath", " srcSourceFile", "srcDir", " srcClass", "rcFiles", " srcPage", "rcFile", "sourceDir", "srcFiles", "rcPath", "sourcePath", "destfile", "sourceSourceFile", "destDir", " srcFiles", "rcDir", " srcDir", "destPage", "rcSourceFile", "sourceFile", " srcfile", "rcPage", "srcPath", "sourcefile", "srcSourceFile", "destFiles", "srcfile", "rcfile", "srcClass", "destClass", "srcPage", "sourceFiles"], "destFile": ["southFile", " destinationDir", "DestFile", "destSourceFile", "srcDir", "southDir", "targetPath", " destinationFiles", "destFilename", " destinationFile", "destroyFilename", "destPlace", "southFilename", "wbFile", "defaultDir", "DestPath", "destDir", "southPlace", "destfile", " destFilename", " destFiles", "defaultfile", "wbFiles", " destinationFine", " destfile", "destPage", "defaultFiles", "DestFiles", " destPlace", " destPath", "wbFilename", " destinationPage", "destroyPage", "srcPlace", " destDir", "targetFile", "destFine", " destPage", " destinationFilename", "destroyFine", "destroyFile", "destFiles", "targetFiles", "DestSourceFile", "DestDir", "destPath", " destFine", "defaultFile", "srcFilename", "Destfile", "wbSourceFile", " destinationfile", " destSourceFile", "targetDir", "DestFilename"], "in": ["ini", "err", "image", "index", "o", "login", "inner", "inn", "input", "In", "channel", "b", "bin", "url", "c", "pin", "IN", "r", "again", "ci", "p", "source", "part", "nin", "io", "cin", "x", "min", "pull", "Out", "ins", "is", "as", "lin", "init", "inside", "ac", "co", "h", "con", "id", "rin", "isin", "file", "i", "reader", "win", "n", "connection", "like", "din", "f", "socket", "inc"], "out": ["resource", "json", "In", "channel", "window", "group", "list", "ger", "page", "c", "state", "again", "query", "job", "name", "file", "call", "comment", "lib", "connection", "source", "parent", "ou", "log", "o", "cmd", "outer", "point", "this", "to", "cli", "write", "input", "cache", "sync", "output", "OUT", "bin", "conn", "auto", "string", "code", "session", "outs", "note", "doc", "io", "Out", "co", "sys", "server", "user", "down", "error", "no", "win", "copy", "err", "base", "prefix", "inner", "pre", "post", "extra", "IN", "line", "diff", "client", "off", "ext", "term", "dump", "gen", "lock", "ex", "inc", "exec", "socket", "obj", "image", "raw", "net", "up", "key", "writer", "store", "part", "ico", "url"], "fis": ["flios", "frris", "fios", "flis", "pis", "hi", " fIs", " foss", " fris", "cfris", "gais", "pIs", "fi", " fi", "hios", "lis", "fross", "lais", "cfis", "pos", "fais", "gi", "hos", "FIs", "pris", "li", "fIs", "flos", "his", "Fos", "Fis", "gos", " fais", "fris", "cfoss", "cfos", "cfios", "fli", "cfi", "fros", "foss", "gis", "los", "Fris"], "fos": ["flout", "fo", "eos", "eoss", "fics", "pis", "boes", " fout", " foes", " fo", "po", " fose", "bos", "lis", "tos", "toes", "pos", "infoss", "infos", "tics", "lose", "fose", "gose", "loss", "eis", "poes", "infose", "flo", "flos", "paos", " faos", "flose", "Foes", "faos", "gout", "foes", "bics", " fics", "Fos", "Fis", "gos", "eose", "fout", "bis", "infis", "Faos", "go", "tis", "foss", "Fo", "los"], "srcModified": ["srcXined", "srcVerified", "sourceModify", "srcmodIFIED", "srcModed", "sourceModification", "srcMinIFIED", "sourceMinification", "srcXed", "srcXification", "srcVerification", "srcXified", "srcmodification", " srcModed", "srcMinification", "srcModification", "srcModined", "sourceMinIFIED", " srcModIFIED", "srcModify", "srcMetressed", "srcVerined", "sourceMinified", "srcMetification", "sourceMinify", "srcVered", "sourceModified", "sourceModIFIED", "srcMinify", "srcmodified", " srcModressed", "srcMinified", "srcModIFIED", "srcmodify", "srcMetified", " srcModification", "srcModressed", "srcmodressed", "srcMetIFIED", " srcModined"]}}
{"id1": "4398382", "id2": "21930714", "code1": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "code2": "    @Test\n    public void testSpeedyShareUpload() throws Exception {\n        request.setUrl(\"http://www.speedyshare.com/upload.php\");\n        request.setFile(\"fileup0\", file);\n        HttpResponse response = httpClient.execute(request);\n        assertTrue(response.is2xxSuccess());\n        assertTrue(response.getResponseHeaders().size() > 0);\n        String body = IOUtils.toString(response.getResponseBody());\n        assertTrue(body.contains(\"Download link\"));\n        assertTrue(body.contains(\"Delete password\"));\n        response.close();\n    }\n", "label": 0, "substitutes": {"digest": ["Digse", "mdested", "mdests", "mdest", "encse", "encester", "digester", "generests", " digse", " digests", "Digester", "generester", "generested", "digests", "digress", " digress", "mdester", "Digress", "encest", "encress", "digested", "generest", " digested", "digse", "Digest", " digester"], "algorithm": ["malgebra", "alignment", "malignment", " algebra", "algo", "aloding", "Alignment", "aroding", " algo", "algebra", "Algebra", "challenge", "Algo", "argebra", " alenge", "challgo", "argorithm", "alenge", "Algorithm", "malgorithm", "Alenge", "challgebra", "maloding", "arignment", "challgorithm", "Aloding"], "text": ["image", "letter", "feed", "config", "content", "sequence", "format", "input", "pattern", "message", "output", "password", "bytes", "object", "struct", "string", "txt", "code", "TEXT", "buffer", "Text", "token", "path", "attribute", "secret", "length", "name", "test", "ext", "word", "data", "username", "str", "value", "connection", "source", "url", "address"], "mDigest": ["mGest", " mGester", "mSignEST", "mGast", "MDiger", "amPostest", "mDester", "MDigEST", "MDigest", " mGge", "amPostested", "mDenge", "mDesigngest", "mDiggest", "mSignast", "mDEST", "mDgest", "mCodener", "mSignge", "mSignest", "mDer", "mGge", "MDigenge", "mDesignest", "mPostested", "mdiger", " mGast", " mDigast", "mdigener", "mDesigner", "mSignester", "MDer", "mDest", "mPostener", "mCodest", " mDigester", "MDester", "MDgest", "mEncge", "mDigener", "mDesignester", "amDigested", "mPostest", "mdigester", "mSignenge", "mDigester", "mDigenge", "mDiger", "mEncast", "mGester", "MDiggest", "mdiggest", "amDigest", " mGest", "MDest", "mDigEST", "mDigast", "mDigge", "mEncest", " mDigge", "mdigested", "mCodested", "mEncester", "mdigest", "mDigested", "amDigener", "amPostener", "MDigester"], "raw": ["image", "Raw", "enc", "feed", "hex", "content", "input", "json", "none", "serial", "message", "output", "full", "null", "array", "buf", "orig", "initial", "buffer", "original", "wrap", "result", "container", "row", "response", "unsigned", "clean", "internal", "data", "binary", "RAW", "instance", "default", "partial", "source"], "encoder": ["decoding", "deccode", "enccode", "Encoding", "eccode", " encoded", "ecoding", " encoding", "encoded", "Encoded", "encoding", "Encoder", "ecoded", "ecoder", "decode", "ecode", "encode", "enoder", "decoder", " encode", "enode", "Encode", "enoding"]}}
{"id1": "3584508", "id2": "7396682", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "label": 1, "substitutes": {"copyResource": [" downloadResource", " downloadFile", " downloadUrl", " copyFile", "copyUrl", "transferFile", "transferResource", " copyresource", " copyUrl", "transferUrl", "transferresource", "copyFile", "copyresource", " downloadresource"], "url": ["re", "image", "URL", "base", "resource", "lr", "feed", "www", "stream", "Url", "download", "ls", "ref", "http", "src", "remote", "l", "object", "page", "string", "r", "bel", "path", "ource", "uri", "xml", "loader", "name", "ssl", "server", "data", "file", "host", "id", "sl", "connection", "loc", "source", "web", "f", "address"], "input": ["image", "index", "base", "in", "resource", "temp", "feed", "this", "stream", "current", "inner", "inf", "form", "audio", "open", "Input", "active", "accept", "parse", "http", "cache", "load", "l", "api", "bb", "bin", "element", "act", "ack", "buffer", "session", "plus", "progress", "upload", "out", "pull", "client", "context", "xml", "but", "socket", "ssl", "request", "data", "file", "binary", "qa", "instance", "error", "i", "reader", "get", "connection", "config", "source", "exec", "f", "inc", "address"], "output": ["image", "flow", "unit", "log", "ou", "resource", "outer", "other", "stream", "current", "production", "write", "target", "cache", "queue", "writer", "environment", "object", "application", "external", "buffer", "control", "result", "console", "out", "response", "layer", "network", "operation", "Output", "file", "data", "binary", "document", "put", "default", "connection", "config", "source", "web", "socket", "copy", "address"], "b": ["base", "nb", "br", "abs", "bit", "l", "bb", "bin", "cb", "buf", "c", "r", "buffer", "d", "k", "lb", "fb", "be", "p", "line", "bi", "sb", "v", "x", "B", "pb", "bar", "a", "h", "bs", "file", "ob", "binary", "e", "i", "rb", "mb", "n", "bc", "bf", "batch", "m", "db", "f", "ab"]}}
{"id1": "1180878", "id2": "16825994", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["frieveUrldata", "fetchURLDATA", "frieveURLDATA", "fetchJSONData", "frieveUrlDATA", "fetchHTTPDATA", "fetchUrldata", "fetchURLdata", "fetchUrlDATA", "frieveURLdata", "fetchHTTPdata", "fetchUrlData", "frieveURLData", "fetchHTTPData", "fetchJSONdata", "fetchJSONDATA", "frieveUrlData"], "url": ["image", "html", "URL", "base", "resource", "feed", "www", "view", "download", "Url", "ls", "http", "text", "src", "filename", "l", "href", "api", "page", "string", "path", "fl", "source", "uri", "xml", "ur", "name", "location", "ssl", "server", "data", "file", "user", "gl", "username", "sl", "el", "connection", "loc", "host", "f", "address"], "proxyHost": ["cacheHost", " proxyServer", "serverAddress", "serverPath", " proxyAddress", "baseHost", "baseDomain", "remoteAddress", "proxyHead", "baseAddress", "ProxyHead", "remoteDomain", "ProxyHost", " proxyPath", "proxyhost", "serverServer", " proxyhost", "proxyDomain", "baseHead", "ProxyDomain", "ProxyServer", "cachePort", "proxyPath", "remoteHead", "ProxyPath", "proxyAddress", "proxyServer", "cachehost", "cacheAddress", "ProxyPort", "ProxyAddress", "remoteHost", "Proxyhost", "serverHost"], "proxyPort": ["cacheHost", " proxyServer", " proxyport", " proxyAddress", "httpPort", "ProxyHost", "httpServer", "httpAddress", "cachePort", "Proxyport", "ProxyServer", "cacheport", "proxyAddress", "proxyServer", "proxyport", "cacheAddress", "ProxyPort", "ProxyAddress", "httpHost"], "con": ["com", "fa", "ls", "rec", "ch", "c", "cf", "rc", "ci", "per", "uc", "connection", "cr", "f", "login", "cl", "pc", "cur", "ca", "cache", "run", "sync", "conn", "CON", "ran", "co", "ocon", "cone", "connect", "go", "win", "re", "conv", "change", "sub", "fac", "fun", "don", "common", "pre", "cons", "fc", "remote", "un", "an", "x", "out", "xc", "Con", "pub", "cn", "on", "gen", "mc", "cp", "ec", "inc", "exec", "conf", "socket", "ver", "canon", "func", "can", "syn", "open", "pen", "ctrl", "http", "act", "pin", "fl", "en", "part", "ai", "min", "cc", "cas", "close", "cm", "ac", "n", "bc", "fan"], "is": ["ib", "its", "in", "can", "serv", "isi", "vs", "abs", "ops", "mis", "cms", "ir", "lis", "has", "does", "api", "info", "conn", "isu", "ws", "IS", "js", "ri", "act", "sp", "state", "ps", "was", "ie", "p", "ci", "ris", "si", "os", "it", "cs", "oss", "ai", "out", "isa", "isl", "fs", "iss", "cos", "il", "as", "es", "iso", "are", "bis", "us", "ori", "bs", "isin", "id", "isc", "ios", "Is", "i", "im", "get", "ais", "or", "ar", "iris", "ics", "s"], "u": ["ou", "o", "q", "U", "ul", "up", "ue", "http", "cu", "ut", "l", "un", "b", "ui", "uv", "api", "conn", "uci", "c", "m", "p", "io", "su", "uri", "os", "v", "client", "hu", "fu", "ur", "nu", "us", "h", "user", "file", "yu", "tu", "iu", "i", "uc", "ru", "lu", "f"], "proxy": ["force", "pool", "resource", "create", "clone", "phone", "pc", "fe", "http", "zip", "cache", "cop", " Proxy", "l", "api", "remote", "prot", "XY", "c", "pe", "pin", "Proxy", "pa", "plus", "p", "type", "xy", "uri", "x", "roxy", "ip", "client", "pse", "ssl", "bean", "wrapper", "server", "shadow", "port", "timeout", " proxies", "lib", "connection", "config", "host", "web", "f", "socket", "copy", "address"], "baos": ["abis", "baOS", "caas", "caos", "haOS", "bao", "bais", "BAOS", "BAos", "BAis", "pao", "boOS", "hao", "BaOs", "Baos", "boas", "haos", "calos", "caOS", "paOS", "Bais", "balos", "paos", "baas", "boos", "abOs", "abros", "BAo", "baOs", "aas", "bolos", "Baros", "pais", "hais", "alos", "baros", "BAOs", "aos", "aOS", "abos", "BAros"]}}
{"id1": "17999474", "id2": "18974466", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipAtFile", "getZipAtfile", "getZipAsDir", "getZipasFile", "getTempAsDir", "getZipasPlace", "getTempAsfile", "getTempAsFile", "getZipAtDir", "getZipasDir", "getZipAsPlace", "getZipAtPlace", "getZipasfile", "getZipAsfile", "getTempAsPlace"], "digOb": ["signObject", "DigObject", "signob", " digObject", "digob", "dimObj", "DigOb", " digOl", "signOB", "dimObject", "digObject", " digob", "digObj", "DigOl", "digOB", " digObj", "signObj", "ditOb", "signOb", "ditOB", " digOB", "ditob", "ditObject", "dimOb", "digOl", "dimOl", "DigObj", "Digob"], "folderName": ["folderPath", "FolderPath", "packagePath", "fileName", " folderDir", "filePath", "FolderInfo", "foldername", "filename", "foldInfo", "folderDir", "packageDir", " folderPath", "foldname", "foldPath", "foldName", "packagename", "fileInfo", "Foldername", "packageName", "folderInfo", "FolderName", "FolderDir", " foldername"], "tmpFolder": [" tmpManager", "tempFolder", "mpDirectory", " temporaryManager", "tempManager", " tmpDir", "tmpManager", "tmpDirectory", "mpfolder", "mpFolder", "tempDir", " tmpDirectory", "tmpDir", " tmpfolder", "mpDir", "tmpfolder", " temporaryFolder", "tempDirectory", "tempfolder", " temporaryDirectory", " temporaryfolder"], "zip": ["z", "flow", "folder", "ulp", " ZIP", "temp", "feed", "gz", "download", "install", "py", "json", "ignore", "cop", "slice", "bag", "cf", "ze", "clip", "job", "ie", "p", "wrap", "upload", "io", "flat", "ce", "fp", "ip", "lex", "xml", "tmp", "zone", "pack", "proxy", "archive", "Zip", " zipper", "file", "seed", "lock", "sl", "ipped", "pkg", "pipe", "ress", "lib", "jar", "source", "f", "url", "copy"], "out": ["z", "flow", "err", "log", "base", "in", "o", "temp", "child", "box", "this", "gz", "flush", "write", "cli", "download", "plain", "cache", "sync", "output", "OUT", "writer", "info", "conn", "object", "page", "url", "null", "again", "outs", "path", "line", "upload", "io", "result", "os", "Out", "client", "is", "loader", "socket", "a", "user", "file", "gen", "ex", "connection", "source", "parent", "f", "obj", "copy"]}}
{"id1": "19006212", "id2": "19276022", "code1": "    public void Load(String fname) throws Exception {\n        File f = null;\n        try {\n            if (\"\".equals(fname) || fname == null) throw new Exception();\n            System.out.println(\"Loading mapfile \" + fname);\n        } catch (Exception e) {\n            throw new Exception(\"File not found\");\n        }\n        aType = null;\n        fieldtype.clear();\n        creatures.clear();\n        aElement = new String(\"\");\n        content = null;\n        Ax = -1;\n        Ay = -1;\n        aTemplate = -1;\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        data_read = 0;\n        URL url = this.game.mainClass.getClassLoader().getResource(fname);\n        if (url == null) {\n            throw new Exception(\"Can't load map from : \" + fname);\n        }\n        try {\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(url.openStream(), this);\n        } catch (Exception e) {\n            System.out.println(\"Can't open XML : \" + e);\n        }\n        for (int i = 0; i < fieldtype.size(); i++) {\n            System.out.println((MapField) fieldtype.get(i));\n        }\n        game.player.setpos(start_x, start_y);\n        System.out.println(\"Player starting position set\");\n        start_x = -1;\n        start_y = -1;\n        System.out.println(\"Map \\\"\" + fname + \"\\\" loaded\");\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 0, "substitutes": {"Load": ["File", "Play", "download", "load", "add", "Read", "loaded", "New", "LOAD", "Loader", "Game", "Add", "upload", "Start", "loading", "Init", "Class", "Get", "Upload", "loader", "pack", "Process", "oad", "Create", "Import", "Loading", "Open"], "fname": ["ffname", "filenames", " fsource", "Fname", "fnames", "cnames", "cpath", "fnamed", "Ftype", "Fpath", "fName", "fcpath", " fsize", "filefile", "pfile", "Fbase", " fbase", "fileName", "xtype", "ffile", " fName", "fullsize", "filetype", "ttype", "fsource", "filename", "Fnamed", "fullename", "pbase", "tname", "fbase", "fullname", "fcnamed", "xname", "fsize", "fcname", "filesource", "tpath", "cname", "fpath", "FName", " fnamed", "xName", " fpath", "xpath", "fename", "ppath", "tName", "Fnames", "cName", "ffsize", "pName", "pnames", "filepath", "ffName", "fullName", "ftype", "psource", "fcName", " fename", " fnames", " ffile", "ffename", "pname"], "f": ["image", "base", "form", "fm", "F", "ref", "fc", "cache", "area", "l", "b", "object", "c", "cf", "buffer", "fd", "d", "p", "pointer", "frame", "fp", "fs", "fn", "e", "sf", "n", "m", "conf"], "aType": ["aVersion", "audioClass", " aSource", " aVersion", "aaVersion", "aaClass", " aClass", "audioSource", "aClass", "aaSource", "aaType", "audioVersion", "aSource", "audioType"], "aElement": ["anFile", "anElement", " aObject", "aFile", "oElement", "oDocument", " aDocument", "oFile", "aObject", "anObject", "anDocument", "oObject", " aFile", "aDocument"], "content": ["body", "model", "video", "resource", "Content", "script", "meta", "stream", "metadata", "transform", "entry", "version", "load", "text", "message", "media", "code", "path", "title", "data", "layout", "document", "comment", "description", "activity", "value", "config", "source"], "Ax": ["aw", "dec", "Num", "Content", "Width", "Index", "dx", "Pages", "ix", "Length", "AX", "A", "ord", "au", "Pos", "orient", "Code", "Id", "xx", "Title", "xp", "title", "ww", "Page", "axis", "ax", "Key"], "Ay": ["Az", "Key", "Sep", "Series", "Pi", "Loc", "XY", "Va", "Year", "Vert", "Unit", "Rev", "Py", "Ext", "Row", "Ws", "Desc", "Cy", "Dir", "Exp", "Ry", "Col", "Lo", "Yu", "By", "Vol", "Dim", "Sy", "Dec"], "aTemplate": ["aTitle", "aRepeat", "activeTitle", " aTitle", " atemplate", "titleRepeat", "activeRepeat", "atemplate", "activeTemplate", "titletemplate", "titleTitle", "titleTemplate", " aRepeat", "activetemplate"], "factory": ["Factory", "refiller", "spactory", "FFactory", "Fault", "refundle", "firm", "fiFactory", "refactory", "sfault", "fault", "fundle", "fiactory", "fiault", "fiddle", "sfFactory", "tactory", "fFactory", "spundle", "fiirm", "tiddle", "tiller", "refiddle", "filler", "spiddle", "spiller", "tundle", "Firm", "sfactory", "sfirm"], "data_read": ["buffer_received", "data__reads", "buffer_ready", "buffer_reads", "data_reads", "data__ready", "data_received", "data_ready", "buffer_read", "data__received", "data__read"], "url": ["image", "log", "URL", "base", "resource", "lr", "www", "feed", "fr", "impl", "stream", "coll", "ul", "Url", "ls", "http", "zip", "api", "l", "b", "page", "string", "r", "bel", "buffer", "path", "fl", "io", "rel", "uri", "layer", "il", "xml", "ur", "loader", "location", "ssl", "server", "data", "file", "ob", "browser", "el", "sl", "rl", "loc", "source", "address"], "parser": ["pool", " soup", "jack", " reader", " module", " parsed", "arser", " input", "function", "player", " xml", "worker", "parse", " builder", "http", " processor", "writer", "page", "builder", "driver", " parent", "oder", " scanner", "handler", "er", "p", " sys", "type", "se", " library", "Parser", "layer", "xml", "manager", "library", "loader", " plugin", " protocol", "server", "file", "document", "umper", "reader", " grammar", " pars", "plugin", " file", "processor"], "i": ["z", "ini", "index", "field", "j", "oi", "chi", "yi", "hi", "inner", "phi", "ii", "ix", "fi", "slice", "mu", "b", "info", "ui", "ri", "pi", "c", "gi", "abi", "d", "li", "ci", "ie", "p", "multi", "si", "ni", "xi", "uri", "io", "v", "x", "ai", "ji", "bi", "eni", "it", "ip", "ori", "ti", "qi", "id", "e", "iu", "u", "n", "di", "I", "zi"], "start_x": ["start___y", " start_xi", "start_X", "startNewy", "startNewx", "start_xi", "startNewxy", "startNewcross", "start___X", "start___xi", " start_X", " start_cross", "start_xy", " start_xy", "start___x", "start_cross"], "start_y": ["start_Y", "start_dy", " start_z", "start_vy", " start_Y", " start_vy", " start_dy", "start_z"]}}
{"id1": "1421557", "id2": "8328527", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void insertJobLog(String userId, String[] checkId, String checkType, String objType) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preStm = null;\n        String sql = \"insert into COFFICE_JOBLOG_CHECKAUTH (USER_ID,CHECK_ID,CHECK_TYPE,OBJ_TYPE) values (?,?,?,?)\";\n        String cleanSql = \"delete from COFFICE_JOBLOG_CHECKAUTH where \" + \"user_id = '\" + userId + \"' and check_type = '\" + checkType + \"' and obj_type = '\" + objType + \"'\";\n        try {\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            preStm = connection.prepareStatement(cleanSql);\n            int dCount = preStm.executeUpdate();\n            String sHaveIns = \",\";\n            preStm = connection.prepareStatement(sql);\n            for (int j = 0; j < checkId.length; j++) {\n                if (sHaveIns.indexOf(\",\" + checkId[j] + \",\") < 0) {\n                    preStm.setInt(1, Integer.parseInt(userId));\n                    preStm.setInt(2, Integer.parseInt(checkId[j]));\n                    preStm.setInt(3, Integer.parseInt(checkType));\n                    preStm.setInt(4, Integer.parseInt(objType));\n                    preStm.executeUpdate();\n                    sHaveIns += checkId[j] + \",\";\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            log.debug((new Date().toString()) + \" \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0228\ufffd\ufffd\u02a7\ufffd\ufffd! \");\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n                throw e;\n            }\n            throw ex;\n        } finally {\n            close(null, null, preStm, connection, dbo);\n        }\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeString2File", "encodeFileFromStream", "encodeFileFromString", "encodeStringToStream", "encodeString2Files", "encodeFiletoStream", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFiles", "encodeFiletoFile", "encodeFileFromFiles", "encodeFileFromFile", "encodeString2Stream", "encodeStringToString", "encodeFileToString", "encodeFile2String", "encodeString2String", "encodeFile2File", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFile2Files", "encodeFileToStream"], "infile": [" infilename", "infiles", "Infilename", "outFile", "inputfile", "outfiles", "inFile", "InFile", "inputfilename", " infiles", " infp", "inputFile", "outfilename", "outfp", "Infiles", "inputfiles", "infp", "inputfp", "infilename", "Infile"], "outfile": ["newfolder", "outname", "outFile", " outFile", "outputfp", "outputfilename", " outfilename", "Outname", "outfolder", "outputfolder", " outfp", "Outfolder", "newfile", "newname", " outfolder", "infolder", "newFile", "outfilename", "outfp", "outputfile", "OutFile", "infp", " outname", "infilename", "Outfile"], "in": ["re", "err", "ini", "image", "base", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "vin", "m", "din", "socket", "inc", "s"], "out": ["err", "ou", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "In", "obj", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "outs", "work", "job", "source", "line", "io", "Out", "client", "off", "name", "co", "on", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "count", "cache", "slice", "queue", "b", "bytes", "bb", "null", "buf", "buff", "border", "padding", "fb", "split", "uffer", "type", "result", "len", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "input", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "close", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "model", "method", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "respons", "open", "better", "message", "growth", "modified", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "21491791", "id2": "338852", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public static void sort(float norm_abst[]) {\n        float temp;\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 7; j++) {\n                if (norm_abst[j] > norm_abst[j + 1]) {\n                    temp = norm_abst[j];\n                    norm_abst[j] = norm_abst[j + 1];\n                    norm_abst[j + 1] = temp;\n                }\n            }\n        }\n        printFixed(norm_abst[0]);\n        print(\" \");\n        printFixed(norm_abst[1]);\n        print(\" \");\n        printFixed(norm_abst[2]);\n        print(\" \");\n        printFixed(norm_abst[3]);\n        print(\" \");\n        printFixed(norm_abst[4]);\n        print(\" \");\n        printFixed(norm_abst[5]);\n        print(\" \");\n        printFixed(norm_abst[6]);\n        print(\" \");\n        printFixed(norm_abst[7]);\n        print(\"\\n\");\n    }\n", "label": 0, "substitutes": {"run": ["unit", "log", "create", "func", "worker", "process", "code", "apply", "running", "fork", "work", "job", "build", "all", "loop", "command", "start", "app", "spawn", "test", "runner", "call", "Run", "execute", "exec", "invoke"], "input": ["image", "flow", "index", "in", "resource", "raw", "feed", "storage", "view", "stream", "inner", "form", "audio", "Input", "worker", "active", "entry", "up", "text", "reading", "parser", "conn", "read", "driver", "initial", "state", "readable", "work", "control", "io", "out", "client", "context", "loader", "internal", "request", "data", "file", "user", "iterator", "instance", "connection", "config", "source", "address"], "output": ["writing", "image", "letter", "log", "written", "unit", "generated", "resource", "index", "temp", "outer", "end", "office", "write", "target", "text", "cache", "filename", "queue", "later", "environment", "object", "page", "application", "exit", "path", "job", "writers", "control", "console", "out", "response", "network", "Writer", "operation", "Output", "file", "data", "document", "user", "put", "web", "connection", "config", "source", "parent"], "reader": ["image", "slave", "in", "resource", "system", "view", "stream", "rer", "inner", "audio", "entry", "worker", "parser", "reading", "read", "driver", "builder", "ri", "r", "oder", "handler", "er", "author", "io", "row", "client", "context", "ner", "manager", "riter", "loader", "request", "peer", "wrapper", "server", "Reader", "source", "book", "owner", "rator"], "writer": ["writing", "her", "written", "wb", "outer", "office", "inner", "w", "write", "player", "wan", "entry", "worker", "wer", "ws", "engine", "builder", "driver", "ew", "r", "creator", "wa", "wr", "work", "er", "writers", "author", "wire", "nw", "out", "ner", "manager", "riter", "Writer", "word", "request", "ter", "wrapper", "data", "war", "maker", "rw", "writ", "or", "connection", "editor"], "pump": ["pamp", "prump", "Pumper", "camp", "ppump", "Pump", "dmp", "pdump", "ppumps", "humper", "dumps", "prdump", "pram", "Pdump", " pumping", " pam", "mump", "Pam", "prumper", "Pmp", " pmp", "Pumps", "hprint", " pamp", " pdump", "cumper", "pam", "Pprint", "Pumping", "pumping", "hump", "cump", "pumper", "dump", "pmp", "Pamp", "mprint", "ppumping", "mumps", " pumps", " pumper", "ppumper", "mumper", "pumps", "cumping", "humps", "pprint", "dumper"], "counter": ["num", "repeat", "index", "ver", "lr", "outer", "walker", "offset", "continue", "current", "inner", "step", "sequence", "order", "meter", "ener", "entry", "worker", "inter", "consumer", "version", "master", "count", "ger", "now", "race", "page", "builder", "code", "clock", "starter", "r", "collection", "rew", "author", "er", "hello", "Counter", "result", "pointer", "progress", "currency", "number", "row", "loop", "layer", "ner", "cookie", "loader", "trace", "ception", "runner", "keep", "ter", "server", "seed", "const", "instance", "second", "keeper", "center", "timer", "zero", "comment", "enter", "parent", "url", "processor"], "buffer": ["base", "resource", "entry", "channel", "text", "message", "queue", "uf", "page", "buf", "position", "buff", "uffer", "layer", "length", "loader", "server", "data", "file", "document", "reference", "port", "limit", "binary", "iter", "batch", "source", "Buffer", "url", "header", "address"], "off": ["flow", "o", "offs", "end", "offset", "of", "inner", "art", "head", "open", "ff", "Offset", "offer", "ref", "less", "area", "info", "ui", "now", "auto", "left", "set", "ord", "pos", "OFF", "fail", "opt", "addr", "out", "own", "start", "low", "on", "down", "oa", "unknown", "Off", "eno"], "len": ["body", "log", "lc", "in", "end", "lit", "val", "lf", "fin", "lan", "ref", "count", "ler", "lon", "den", "l", "bin", "ld", "pos", "fd", "li", "fl", "en", "line", "Len", "width", "lim", "all", "elt", "layer", "length", "size", "name", "ln", "on", "ll", "lt", "gen", "limit", "lock", "el", "n", "lib", "loc", "url", "lin"], "rd": ["dd", "nd", "dr", "lr", "fr", "rx", "ud", "val", "rid", "xd", "rt", "RD", "RR", "adr", "ld", " prod", " r", "rod", "ord", "rf", "r", "rc", "fd", "d", "ind", "db", "rob", "ds", "rand", "red", "rr", "nr", "rh", "raid", "ra", "rs", "hr", "rn", "rm", "rss", "rb", "rw", "rl", "ru", "cr", "dra"]}}
{"id1": "1586662", "id2": "4168534", "code1": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "code2": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "label": 1, "substitutes": {"doOne": ["DoSync", "goOne", "goone", "Doone", "Do1", "go1", "loOne", "DoOne", "do1", "goSync", "lo1", "doone", "doSync", "loone", "loSync"], "bid": ["wid", "vid", "paid", "sha", "base", "bm", "ud", "aud", "rid", "mad", "ban", "ref", "bon", "bas", "bit", "b", "bb", "bh", "cb", "bed", "ld", "aba", "uid", "ed", "abi", "pid", "ad", "year", "lay", "oid", "bi", "auth", "bt", "hid", "sid", "mid", "la", "chid", "bn", "du", "received", "id", "seed", "rb", "bc", "bf", "batch", "ast"], "tid": ["paid", " taid", "ptaid", "tiden", "tids", "pids", " tbase", " tids", "ptid", "Tbase", "timID", "trid", "tID", "timbid", "pbase", "tide", "trID", "ptinfo", "trids", "tbase", "trbid", "pid", "ptiden", "pide", " tide", "timid", "Tid", "Tids", "pinfo", "taid", "tbid", "Tbid", "TID", "piden", "Tide", " tiden", "tinfo", " tinfo", "timids"], "aid": ["paid", "dd", "sha", "ga", "said", "ay", "aud", "alias", "order", "lan", "lied", "mad", "ase", "anc", "ca", "ada", "bas", "acid", "aida", "sat", "idd", "da", "aa", "ays", "ed", "aned", "pa", "d", "au", "Aid", "ad", "lay", "oid", "ai", "cas", "sd", "na", "ady", "auth", "aim", "man", "sid", "du", "ased", "ac", "a", "ara", "id", "af", "az", "aed", "ding", "added", "delay", "ab", "ast", "ia"], "delta": ["Dota", "ddDelta", "edetime", "ddelta", "sdelta", "sdelt", "dta", "dada", "dDelta", " dada", "ndDelta", "ndta", "Delta", "lelta", "lada", "adelt", "dota", "d\n", "edDelta", "sdta", "adota", "ldelt", "sdDelta", "D\n", "edelta", "adDelta", "adada", "ndelta", "ldota", "d_", "lelt", " delt", "Dada", "sdota", "ndota", "ddota", " d_", "ndelt", "DDelta", "edta", "sdetime", "ndata", "lota", " dota", "detime", " d\n", " dDelta", "D_", "data", "sdata", "delt", "ddelt", "ldDelta", "ldelta", "Delt", "adelta", "ndetime"], "aBalance": ["sabalance", "aaHalf", "aCost", "bHalf", "aaWeight", "saBalance", "eaBalance", " aCredit", " abalance", "aaBalance", "eabalance", "eaBal", "abalance", "bAmount", "aBal", "aWeight", " aWeight", "aaCredit", "bBalance", " aAmount", "eaCost", "pBalance", "aabalance", " aCost", "pbalance", "aHalf", "saBal", "saCost", " aBal", "pWeight", "pCredit", "bCredit", "aCredit", " aHalf", "aAmount", "aaAmount"], "RS": ["RE", "JS", "RN", "VS", "SW", "RC", "DS", "DR", "FS", "KR", "NRS", "RD", "RR", "RT", "KS", "SS", "RO", "RW", "Rs", "LS", "IS", "CL", "TS", "SH", "MC", "RB", "RL", "POST", "Res", "Vs", "VR", "US", "BS", "IR", "MR", "MS", "rs", "CD", "LL", "OSS", "RM", "Ms", "AR", "RI", "OS", "PS", "GR", "JR", "TR", "HS", "CS", "RP", "SR"], "Stmt": ["LMT", "stbl", "Stut", "Cmn", "Strau", "Stmn", "stMT", "Stp", "stmp", " StMT", "Strmp", "Cmt", " Stmp", "STut", "Stgr", "Stmp", " Stpr", "Lmp", "Cut", " Sttm", " Stau", "STTr", " StTr", "STp", "Stau", "Cmp", "STMT", " Stbl", "Stpr", "stp", "CMT", "Firstmt", "STbl", "StMT", " stmp", "Firstpr", "Firstmb", " Stmn", "Cau", "StTr", "stmt", " Stmb", " Stut", " stMT", "stgr", " Stp", " stmt", "Lgr", "Sttm", "STmn", " stgr", "stmb", "Firsttm", "sttm", "stpr", "Strmt", "Stmb", "Stbl", "STmt", "StrMT", "Lmt", "stTr"], "Query": ["File", "Time", "Check", "Raw", "Factory", "Command", "Form", "Database", "Model", "Stage", "Driver", "Body", "Source", "Route", "Statement", "Report", "Url", "Range", "Table", "Force", "SQL", "Connection", "Qu", "Display", "Line", "Function", "Comment", "Format", "Update", "query", "Array", "Request", "Do", "This", "Db", "Service", "Row", "Cache", "Common", "Code", "Server", "Scan", "Method", "Exp", "Test", "Script", "Option", "Document", "URI", "Filter", "Init", "Msg", "Fixed", "Style", "Previous", "Rule", "Module", "Join", "Info", "Flow", "Str", "Conn", "Q", "Error", " query", "Key", "Condition", "ERY", "QL"], "res": ["re", "RE", "ES", "vals", "resh", "Gr", "Response", "runs", "js", "gr", "resp", "rows", "RES", "Resources", "Res", "ches", "Results", "lets", "ras", "rest", "Resp", "Ret", "rem", "PS", "results", "reg", "Cons", "obj"]}}
{"id1": "841724", "id2": "11952735", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewrites", "readAndRebwrite", "readandrewrite", "readAndSwwrite", "readAndRewwrite", "readAndSwrap", "readAndSwrite", "readandRewrite", "readAndrewrap", "readAndRewrap", "readAndRebrites", "readandrewwrite", "readAndRebrap", "readandRewrap", "readandRewrites", "readAndSwrites", "readandrewrites", "readAndrewrite", "readAndrewwrite", "readAndRebrite", "readandRewwrite", "readAndRewrites", "readandrewrap"], "inFile": ["inFilename", "loginFile", "outFilename", "inputfile", "InFiles", "InFile", " inFiles", "oldFile", "loginFilename", " inSourceFile", "outSourceFile", "InSourceFile", "inputFiles", "outFiles", "oldFiles", " inFilename", "loginFiles", "inputFile", "inSourceFile", "loginfile", "outfile", " infile", "inputFilename", "inFiles", "oldfile", "infile", "oldFilename", "Infile"], "outFile": [" outStream", "offPlace", "outFilename", " outDir", "outputPlace", "outFILE", "OutStream", "outputFilename", "newDir", " outfile", "thisFILE", "outputFile", "offFile", "outDir", "processFilename", "exfile", "exFILE", "newfile", "processPlace", "thisFile", "processFILE", "thisfile", "offFilename", "thisFilename", "outStream", "outPlace", "newFile", "exFile", "exFilename", "outfile", "outputfile", "OutFile", "outputFILE", "OutDir", "offFILE", "processFile", "newStream", "Outfile"], "iis": ["iniis", "Iiss", "iiIs", "iiIS", " iIS", " iIs", "iIs", "iniiss", "ciiss", "ciis", "Iis", "Iais", " iris", "IIS", "ciais", "ciIs", "iiss", "ciris", "iniIS", "iniIs", "iiris", "iiis", "iiiss", "ciIS", "iniris", "iais", " iiss", "iris", "iIS", " iais"], "dcmParser": ["dcmHelper", "dpmarser", "dmcPar", "dmoduleJar", "dmcJar", "dcmPar", "dbmPolicy", "dCMPlugin", "dmoduleParser", "dcmJar", "fcmHandler", "dcrPar", "fpmParser", "dmcarser", "dpmparser", "dbmHelper", "dmissionReader", "dpmLoader", " dpmLoader", "dcrReader", "dbmPlugin", "dCMParser", "dmoduleparser", "dpmPolicy", " dcrParser", "dmPlugin", "dkmHelper", "DcmInstallation", "dmmParser", "dcmparser", " dpmPolicy", " dcmPlugin", "dcmLoader", " dpmHelper", "dmLoader", "dhemReader", "dcmarser", "dpmHelper", "dbmParser", "fpmHandler", "dpmHandler", "dhemParser", "dcrJar", "dpmJar", " dcmLanguage", "fcmParser", "dcrarser", "dcmPolicy", "dkmParser", "dpmInstallation", " dpmJar", "dmodulePlugin", "dmmparser", "dcmLanguage", "dhemInstallation", "dcmInstallation", "fpmparser", "dpmParser", " dpmparser", " dcmPar", "dcmHandler", "dcrPlugin", "dmcParser", " dcmparser", "dcmReader", " dcrReader", "fcmReader", "DcmReader", " dpmPlugin", "dCMparser", "dpmLanguage", " dpmReader", "dmParser", "dmoduleReader", "dmissionPlugin", "dhemJar", " dpmPar", " dcrLoader", "dpmPar", "fpmReader", "dcrParser", "DcmJar", "dmissionParser", " dcmReader", "dCMHandler", "dpmPlugin", " dpmarser", " dpmLanguage", "dmmPlugin", " dcmarser", "dkmPolicy", " dcmHelper", " dcmLoader", "fcmparser", "dpmReader", " dpmParser", "dmReader", " dcmJar", " dcrPlugin", "dCMReader", "dmmLoader", "DcmParser", " dcmPolicy", "dkmPlugin", "dcmPlugin", "dCMLoader", "dcrLoader", "dmissionLanguage"], "ds": ["dd", "dr", "vals", "des", "ants", "os", "vs", "dc", "amps", "dat", "utils", "DS", "ls", "services", "details", "Ds", "ads", "src", "ns", "points", "sync", "ld", "conn", "js", "ws", "da", "ts", "ays", "cdn", "xs", "ps", "session", "d", "ils", "Db", "dt", "ros", "Os", "tes", "cs", "df", "uds", "dds", "ras", "eps", "gd", "ins", "iss", "qs", "is", "rs", "ys", "gs", "icks", "nas", "bs", "data", "sys", "pd", "ss", "tx", "ks", "di", "asi", "db", "parts", "drivers", "s"], "pdReader": ["ddRunner", "hdWriter", "hdLoader", "xdRead", "hdStream", "pcLoader", "pdStream", "pbLoader", "dsLoader", "pbReader", "ddLoader", "pcRead", "ddReader", "pdreader", "xdWriter", "hdReader", "hdRunner", "hdreader", "pbRunner", "ddStream", "pcWriter", "dsreader", "pdLoader", "pbStream", "dsReader", "xdReader", "hdRead", "pdRead", "pcReader", "dsRead", "xdreader", "pdRunner", "dsWriter"], "out": ["flow", "her", "model", "temp", "group", "list", "full", "page", "null", "again", "result", "img", "layer", "name", "file", "lib", "connection", "parent", "s", "device", "in", "o", "login", "outer", "child", "point", "to", "write", "cli", "over", "cache", "sync", "output", "OUT", "password", "conn", "auto", "builder", "code", "session", "pass", "outs", "doc", "io", "Out", "co", "sys", "user", "down", "copy", "err", "base", "inner", " in", "at", "exp", "later", "object", "array", "external", "line", "diff", "client", "ssl", "term", "ext", "data", "gen", "lock", "ex", "default", "inc", "db", "exec", "obj", "image", "dev", "w", "order", "with", "net", "up", "key", "writer", "store", "oder", "part", "director", "manager", "as", "word", "dot", "url"], "dcmEncParam": ["dcmEnParam", "dcmArchArg", "dcmEnPar", "dcmEnArg", "dcmDecParam", "dcmDecType", "dcmDecArg", "dcmElType", "dcmArchParameter", "dcmEncArg", "dcmEnPart", "dcmElPar", "dcmArchParam", "dcmEncType", "dcmSecParam", "dcmEnType", "dcmDecPar", "dcmEstParameter", "dcmDecParameter", "dcmEncPart", "dcmEncParameter", "dcmEstPar", "dcmEncPar", "dcmElParam", "dcmEnParameter", "dcmElParameter", "dcmEstParam", "dcmSecType", "dcmDecPart", "dcmSecPar", "dcmEstType", "dcmSecPart"], "pdWriter": ["htReader", "ddOutput", "htWriter", "hdWriter", "dpWriting", "htWrite", "dsOutput", "PDWrite", "PDWriter", "ddWrite", "ddReader", "hdReader", "pdOutput", "pdWrite", "dpReader", "dsWrite", "ddWriter", "PDReader", "PDWriting", "hdWrite", "dsReader", "pdWriting", "hdOutput", "dpWrite", "dpWriter", "dsWriter", "htWriting"]}}
{"id1": "14865947", "id2": "8024375", "code1": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"execute": ["action", "create", "send", "submit", "launch", "open", "ute", "load", "message", "run", "process", "exit", " executing", "task", "evaluate", "loop", "command", "start", "Submit", "test", "transfer", "call", "complete", "exec", "invoke"], "event": ["image", "other", " Event", "message", " events", "events", "object", "ents", "g", "t", " EVENT", "vent", "ent", "v", "x", "context", "test", "ext", "ev", "te", "Event", "f", "ex", "ctx", "ec", "exec", "exc"], "shell": ["log", "model", "pool", "cmd", "mail", "sol", "system", "child", "o", "site", "nl", "dll", "cli", "cl", "bot", "edit", "window", "sync", "Shell", "l", "ui", "environment", "tools", "prof", "home", "null", "sql", "math", "cel", "session", "tty", "bash", "gui", "ml", "sb", "build", "sh", "loop", "hell", "il", "xml", "tool", "pty", "kernel", " Shell", "live", "search", "server", "ll", "layout", "cell", "sole", "lock", "el", "sl", "lib", "console", "lex", "exec", "help"], "view": ["flow", "image", "model", "plugin", "pool", "service", "visual", "window", "version", "widget", "list", "l", "ui", "object", "page", "show", "views", "summary", "display", "url", "session", " preview", "gui", " overview", "control", "iew", "container", "v", "row", "book", "tree", "View", "sel", "user", "layout", "review", "VIEW", "lock", "console", "screen", "web", "f", " layout"], "rootFolder": ["RootWindow", " rootFile", "RootDirectory", "rootFile", "rootArea", "rootDir", "Rootfolder", " rootfolder", "parentDirectory", " rootWindow", "rootOrg", " rootDir", "bottomDirectory", "rootfolder", "mainFolder", " rootCenter", "parentFile", " rootZip", "parentFlow", "parentZip", " rootDirectory", "bottomFolder", "rootWindow", "shellDir", "shellFolder", " rootArea", "RootCenter", "shellArea", "mainfolder", "RootFolder", "mainOrg", "rootCenter", "RootDir", "homeCenter", "bottomFlow", "RootFile", "RootOrg", "parentFolder", "homeDirectory", " rootOrg", "RootArea", "rootZip", "shellWindow", " rootFlow", "RootZip", "rootFlow", "mainFile", "bottomFile", "rootDirectory", "homeFolder"], "dialog": ["challDialog", "logDialog", "logog", "clogging", "challogue", "protogg", "protogging", "logogg", "dialogg", "protect", "clog", "dialogue", "diffog", "challock", "dialect", "clOG", "challogs", "dialogs", "logogue", "dialOG", "logock", "challogging", "logOG", "dialock", "diffock", "challog", "challect", "clect", "diffogue", "challOG", "clogg", "logogs", "protog", "dialDialog", "diffDialog", "challogg", "dialogging", "clogs"], "password": ["encrypted", "Password", "cmd", "email", "resource", "account", "prefix", "directory", "root", "content", "patch", "pattern", "picture", "channel", "mode", "text", "message", "key", "column", "wd", "wallet", "device", "pad", "page", "string", "hash", "definition", "params", "session", "pass", "crypt", "token", "padding", "path", "confirmed", "handler", "pg", "phrase", "p", "diff", "mac", "command", "secret", "auth", "size", "name", "PASS", "word", "sum", "volume", "language", "data", "username", "sword", "description", "database", "value", "words", "connection", "config", "source", "address"], "md5": ["mand5", "MD4", "MD512", "MD5", "md15", "mg2", "md512", "dd2", " md512", "cmd5", "md2", "md4", "mddown", " md2", "manddown", "dd40", "mg40", "MD50", "dd5", "MD15", "MDdown", "dd50", "cmd2", "mand15", "md50", "mg5", " md4", "MD2", "mand2", "md40", "mg50", "mand512", "cmd512", " mddown", "MD40", "cmd4", " md15"], "md": ["dd", "nm", "nd", "sha", "html", "cmd", "meta", "dig", "metadata", "ma", "amd", " MD", "mm", "mode", "mo", " mm", " dd", "cd", "ms", "mp", "wd", " ma", "hash", "mand", "d", "kg", "bd", "ad", " cmd", "pm", "df", "mg", "sm", "mac", "od", "sd", " Md", "MD", "sum", "mod", "msg", "M", "pd", " digest", "mag", "dm", "mc", "pkg", " sd", "mb", "bf", "m"]}}
{"id1": "2396191", "id2": "15166511", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksFromURLSafe", "getLinksfromURLfast", "getLinksFromStringSafe", "getLinksFromUrlfast", "getLinksfromURLSafe", "getLinksFromStringfast", "getLinksfromUrlSafe", "getLinksFromUrlSlow", "getLinksfromURLFast", "getLinksFromSSLfast", "getLinksFromSSLSlow", "getLinksfromUrlSlow", "getLinksfromUrlfast", "getLinksFromStringFast", "getLinksFromURLSlow", "getLinksFromUrlSafe", "getLinksFromStringSlow", "getLinksFromUrlFast", "getLinksfromUrlFast", "getLinksfromURLSlow", "getLinksFromURLfast", "getLinksFromSSLFast", "getLinksFromSSLSafe"], "p_url": ["pkurl", "pklink", "p_file", "e_layer", "pffile", "tp24link", "pfroot", "pxurl", "p25link", "pfpath", "p64path", "p_link", "tp24url", "ekhtml", "p9domain", "p9url", "pe_line", "piproot", "x_resource", "p__url", "x_domain", "p_page", "ekurl", " p_path", "tp24root", "p24file", "pfline", "p_root", " p_resource", "p_service", "p64line", "pe_url", "eklink", "pkhtml", "tp24file", "pamurl", "pfurl", "p25url", "p__name", "pxconfig", "p_resource", "tp_link", "pxroot", "p24url", "pe_config", "p64url", "e_html", "p__path", "pflink", "p__resource", "p_html", "p_path", "p6url", " p_name", "pfpage", " p_page", "p_layer", "pamlayer", "piplink", "p9resource", "p6config", "p_line", "eklayer", "p25html", "tp_url", "p_config", "p24link", " p_line", "pe_root", "p9service", "p_domain", "p_name", "p24root", "e_url", "tp_root", "pklayer", "p6root", "e_link", "p6line", "pxline", "x_service", "tp_file", "p64page", "pipurl", "pamhtml", "p25layer", "pamlink", "pipfile"], "x_url": ["x_host", " x_ssl", " x_log", "x_ssl", "p_loc", "p_host", "x_log", "x_loc", "p_conn", " x_resource", "x_resource"], "x_conn": ["x_conv", "x___con", "wx_cat", "x_db", "wx_conv", "x_client", "x___db", "x___conn", "x_cat", "x_con", "p_db", "p_conn", "wx_con", "wx_conn", "x___client", "p_client", "p_con"], "x_is_reader": ["x_is_writer", "x_ismldraft", "x_is_resource", "x_is_stream", "x_ismlmanager", "x_is_draft", "x_ismlstream", "x_is_manager", "x_ismlreader", "x_is_pointer"], "x_reader": ["x8reader", "x67reader", "x_stream", "cross_root", "X_result", "x24stream", "x8root", "cross8url", "X_parser", "x8url", "x8parser", "cross8reader", "cross8root", "cross_url", "x24parser", "cross8parser", "X_reader", "x67root", "cross_reader", "x67url", "x67parser", "x24result", "x24reader", "x_parser", "X_stream", "cross_parser"], "x_line": ["p_page", "x__page", "x__url", "xx_link", "xx_line", "x_comment", "x24line", "x24link", "xingcell", "xingrecord", "p_link", "xx_comment", "x_record", "x_lin", "xx_lin", "x24comment", "x_cell", "ex_record", "x__line", "ex_page", "x24lin", "ex_line", "ex_cell", "xingpage", "p_line", "x__link", "xingline"], "e": ["re", "body", "o", "eb", "end", "event", "je", "match", "entry", "fe", "ue", "exec", "ne", "E", " E", "b", "eur", "l", "engine", "code", "element", "c", "pe", "r", "driver", "ace", "g", "oe", "ze", "t", "d", "ie", "p", "ea", "line", "er", "en", "se", "eps", "v", "entity", "ce", "y", "le", "me", "eu", "edge", "es", "he", "ae", "esi", "ge", "ev", "file", "te", "ente", "el", "error", "n", "ec", "m", "ele", "f", "eve", "ee"], "x_match": ["xlgroup", "xlpattern", "ext_pattern", "ax_link", "x_tag", "x__pattern", "x5info", "xJmatch", "ax5case", " x_tag", "x_pattern", "extJpattern", "xlmember", "ax5match", "x_info", "x_member", "p_matched", "x_slice", " x_slice", "ax5link", " x__replace", "xldate", "ax_info", "e___matched", " x_replace", "xJpattern", "e_check", "x_date", "p__url", "x_matched", "e___check", "xjmatched", "x___check", "x_replace", "x__replace", "xlmatch", "p__match", "x_case", "x__match", "x__matched", "x5link", "xammatch", "x5match", "xJmember", "extJmatch", "xJsearch", "p__pattern", "xjpattern", "ax_case", "extJmember", "x_group", "xamcase", "p__matched", "x__url", "ext_member", "xamslice", "e___match", " x__case", "xlsearch", "x__case", "x__slice", " x_date", "ext_search", "x___matched", " x__slice", "e_match", "ax_match", "x_check", "xltag", "x5case", "p_match", "xjmatch", "p_pattern", " x_group", "e_matched", "e___meet", "xamreplace", "extJsearch", "x_search", "x___match", "x_meet", "x___meet", " x_case", " x__match", "ext_match", "ax5info", "e_meet", "xjurl"], "x_dir": ["x6dir", "x_file", "xnetfile", "x6group", "x6url", "xnetdir", "x6file", "x_group", "xnetgroup", " x_file", "xneturl", " x_group"], "x_root": ["x7alias", "x7directory", "x_alias", "xml_root", "xml_alias", "x7root", "xml_path", "x_directory", "x7path", "xml_directory", "x_path"], "x_links": ["x_ids", "x_lines", "x_points", "x67points", "x67ids", "x67lines", " x_ids", "x67links", " x_points", " x_lines"], "x_texts": ["x_urlls", "x_pathes", "x_urlches", "x_textes", "x_urles", "x_pathches", "x_logls", "x_paths", "x_textls", "x_logches", "x_urls", "x_pathls", "x_logs", "x_loges", "x_textches"], "x_buf": ["y__buf", "y__rc", "x__rc", "X_wb", "y_bag", "ex_buf", "y_uf", "x_wb", "X_buf", "x_buff", "x__wb", "X_buffer", "x_bag", "x___buf", "ex__tmp", "x1buf", "x__cb", "ex_tmp", "x64rc", "ex__cb", "x___uf", "X_buff", "y_rc", "x1cb", "x64bag", "x1buff", "x__buf", "x__buffer", "x_tmp", "x_cb", "ex_cb", "ex__buff", "x_rc", "x___bag", "x__uf", "x1tmp", "y_buf", "y__bag", "x64buf", "x__tmp", "y__uf", "x__buff", "x64uf", "ex_buff", "x__bag", "x_uf", "ex__buf", "x___rc", "x_buffer"], "x_matches": ["x__matures", "x_pathes", "x_attches", "x_calhes", "x_batches", "x_morched", "x_Matches", "x_patched", "x_morting", "x_calches", "x_textoms", "xKmathes", "x_locches", "x_Mathes", "x_matched", "x_matchchers", "x_batures", "x_batchers", "x_Matcher", "x_locched", "x_attcks", "x_morhes", "x_Matchers", "xKtextoms", "x__mathes", "xKmatches", "x_patches", "x_loches", "x_attched", "x_matcher", "xKtextches", "x_matcks", "x_texthes", "x_matchches", "x_matchcher", "x_matchcks", "x_Matures", "x_patcks", "x_matchched", "x_matchers", "x_matchoms", "x_caloms", "x_textings", "x_matchhes", "xKtextings", "x_locting", "x_calings", "x_matings", "x_matchings", "x_patcher", "xKtexthes", "x_atthes", "x_matting", "x_matoms", "xKmatings", "x__matchers", "x_matchting", "x_mathes", "x_bathes", "x_morches", "x__matches", "x_textches", "x_matures", "xKmatoms", "x_patchers"], "x_page": ["ex_loc", "X_page", "tx_feed", "X_path", "x_file", "X_url", "xerpage", "x67file", "xerfeed", "tx_link", "ex_file", "xerline", "tx_line", "x_feed", "tx_page", "x67page", "x67link", "ex_page", "ex_link", "x_loc", "X_line", "xerlink", "x67loc", "x_path"], "x_link": [" x_target", "xpubloc", "xpubline", "xpubtarget", "ex_page", "ex_line", "ex_link", "x_loc", " x_loc", "ex_url", "x_target", "xpublink"], "i": ["ini", "z", "index", "j", "o", "in", "oi", "chi", "hi", "phi", "ii", "ix", "count", "key", "b", "info", "ui", "iv", "ri", "pi", "c", "r", "gi", "k", "li", "ci", "p", "ie", "multi", "si", "xi", "io", "uri", "bi", "v", "x", "ai", "ji", "it", "y", "eni", "a", "ori", "ti", "qi", "id", "iu", "u", "f", "n", "di", "I", "zi"]}}
{"id1": "19584877", "id2": "255765", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeString2File", "encodeFileFromStream", "encodeFileFromString", "encodeStringToStream", "encodeString2Files", "encodeFiletoStream", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFiles", "encodeFiletoFile", "encodeFileFromFiles", "encodeFileFromFile", "encodeString2Stream", "encodeStringToString", "encodeFileToString", "encodeFile2String", "encodeString2String", "encodeFile2File", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFile2Files", "encodeFileToStream"], "infile": [" infilename", "infiles", "Infilename", "outFile", "inputfile", "outfiles", "inFile", "InFile", "inputfilename", " infiles", " infp", "inputFile", "outfilename", "outfp", "Infiles", "inputfiles", "infp", "inputfp", "infilename", "Infile"], "outfile": ["newfolder", "outname", "outFile", " outFile", "outputfp", "outputfilename", " outfilename", "Outname", "outfolder", "outputfolder", " outfp", "Outfolder", "newfile", "newname", " outfolder", "infolder", "newFile", "outfilename", "outfp", "outputfile", "OutFile", "infp", " outname", "infilename", "Outfile"], "in": ["re", "err", "ini", "image", "base", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "vin", "m", "din", "socket", "inc", "s"], "out": ["err", "ou", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "In", "obj", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "outs", "work", "job", "source", "line", "io", "Out", "client", "off", "name", "co", "on", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "count", "cache", "slice", "queue", "b", "bytes", "bb", "null", "buf", "buff", "border", "padding", "fb", "split", "uffer", "type", "result", "len", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "input", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "close", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "model", "method", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "respons", "open", "better", "message", "growth", "modified", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "20028790", "id2": "2736184", "code1": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public static String getURLContent(String urlPath, String requestData, String charset) {\n        BufferedReader reader = null;\n        HttpURLConnection conn = null;\n        StringBuffer buffer = new StringBuffer();\n        OutputStreamWriter out = null;\n        try {\n            URL url = new URL(urlPath);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            conn.setDefaultUseCaches(false);\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(60000);\n            out = new OutputStreamWriter(conn.getOutputStream(), charset);\n            out.write(requestData);\n            out.flush();\n            int repCode = conn.getResponseCode();\n            if (repCode == 200) {\n                int count = 0;\n                char[] chBuffer = new char[1024];\n                BufferedReader input = new BufferedReader(new InputStreamReader(conn.getInputStream(), charset));\n                while ((count = input.read(chBuffer)) != -1) {\n                    buffer.append(chBuffer, 0, count);\n                }\n            }\n        } catch (Exception ex) {\n            logger.error(\"\", ex);\n        } finally {\n            try {\n                if (out != null) {\n                    out.close();\n                }\n                if (reader != null) {\n                    reader.close();\n                }\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            } catch (Exception ex) {\n            }\n        }\n        return buffer.toString();\n    }\n", "label": 0, "substitutes": {"setBundleInfoName": ["setBundleIdPart", "setBindingIdList", "setBundleIdList", "setBindingIdPart", "setBundleInfoDefault", "setBundleDirPart", "setBindingInfoName", "setBundleInfoPart", "setBundleInformationPart", "setBindingInfoPart", "setBindingIdName", "setBindingInfoList", "setBundleIdName", "setBundleInformationDefault", "setBundleInfoList", "setBindingInfoDefault", "setBundleDirList", "setBundleIdDefault", "setBundleInformationName", "setBundleDirDefault", "setBundleInformationList", "setBindingIdDefault", "setBundleDirName"], "location": ["link", "folder", "URL", "base", "resource", "localhost", "site", "point", "directory", "content", "message", "filename", "area", "href", "l", "remote", "string", "selection", "position", "path", "node", "type", "uri", "LOC", "region", "xml", "library", "loader", "language", "server", "data", "file", "layout", "Location", "description", "station", "database", "loc", "address"], "list": ["detail", "coll", "sequence", "LIST", "cl", "cli", "entry", "group", "load", "stack", "queue", "pair", "table", "l", "object", "later", "we", "string", "set", "array", "collection", "li", "listed", "lists", "part", "record", "result", "all", "see", "chain", "name", "tree", "keep", "the", "data", "range", "there", "i", "mentioned", "batch", "parent"], "url": ["err", "URL", "base", "resource", "fr", "lr", "service", "stream", "Url", "open", "http", "l", "b", "bb", "string", "r", "bel", "buffer", "source", "io", "org", "uri", "plug", "orb", "socket", "ssl", "loc", "server", "data", "file", "user", "jar", "browser", "sl", "reader", "connection", "f", "address"], "br": ["body", "err", "dr", "fr", "stream", "bl", "arr", "obj", "ler", "yr", "bridge", "b", "bb", "ch", "buf", "sp", "r", "ber", "gr", "tr", "bro", "er", "io", "result", "Br", "BR", "mr", "img", "handle", "hr", "bar", "sr", "data", "ob", "brush", "jar", "browser", "str", "reader", "rb", "i", "res", "bc", "bh", "ar", "cr"], "line": ["look", "link", "letter", "log", "lc", "rule", "lr", "section", "nl", "lf", "cl", "lines", "entry", "inline", "LINE", "license", "parse", "text", "zip", "up", "Line", "sync", "l", "b", "shell", "page", "style", "string", "status", "code", "pass", "strip", "split", "job", "part", "result", "row", "response", "le", "block", "character", "lin", "name", "word", "data", "file", "lo", "cell", "e", "band", "lock", "str", "error", "non", "connection", "phase", "source", "header"], "pos1": ["index1", "part1", "index0", "posN", "PosN", "POS3", "position2", " posOne", "part3", " pos3", "posOne", "pos3", "part2", "Pos0", "POS1", "PosOne", "Pos1", " posN", "indexOne", "Pos2", "index2", "pos2", "position1", "Pos3", "pos0", "position3", "POSOne", "position0", "POSN", " pos2", "positionOne"], "bundleSymbolicName": ["bundleSymbicallyWord", "bundleSymbolicname", "bundleSymbicallyName", "bundleSymbolicString", "bundleSymbriticalName", "bundleSyembolicKey", "bundleSymbicKey", "bundleSysembuousWord", "bundleSymbicalModule", "bundleSymbriticalUrl", "bundleSymbillyName", "bundleSymbularPath", "bundleSymbularString", "bundleSyMBolicPart", "bundleSymbolicInfo", "bundleSysembolicName", "bundleSyMBicalString", "bundleSyembolicInfo", "bundleSysembolicWord", "bundleSysembuousUrl", "bundleSyMBolicString", "bundleSymbicalKey", "bundleSymbuousWord", "bundleSysembuousname", "bundleSymbriticalWord", "bundleSymbolicUrl", "bundleSymbicName", "bundleSymbolicModule", "bundleSymbularPart", "bundleSymbicalInfo", "bundleSymbillyInfo", "bundleSymbularName", "bundleSysembolicname", "bundleSyMBicalName", "bundleSymbolicWord", "bundleSymbillyKey", "bundleSymbuousname", "bundleSymbigiousPath", "bundleSyembicInfo", "bundleSymbolicPart", "bundleSymbillyModule", "bundleSymbigiousPart", "bundleSymbicModule", "bundleSymbolicKey", "bundleSymbigiousName", "bundleSyMBicalPart", "bundleSyMBolicName", "bundleSyembolicName", "bundleSyembicName", "bundleSymbicalPath", "bundleSymbicallyUrl", "bundleSymbicalString", "bundleSymbriticalname", "bundleSyMBolicPath", "bundleSyembicModule", "bundleSymbolicPath", "bundleSymbicalPart", "bundleSyMBicalPath", "bundleSymbuousUrl", "bundleSymbicallyname", "bundleSysembolicUrl", "bundleSysembuousName", "bundleSymbicInfo", "bundleSymbicalName", "bundleSyembolicModule", "bundleSyembicKey", "bundleSymbigiousString", "bundleSymbuousName"], "bundleName": ["bblInfo", "rbpluginInfo", "babiInfo", "BundleID", "BendorInfo", "bpackageDesc", "bridgeDesc", "rbpluginname", "bridgeInfo", "babiName", "babiDesc", "BendorName", "Bendorname", "boodleID", "bendorName", "bendorInfo", "Bundlename", "rbpluginType", "bblname", "BpackageName", "rbundlename", "boodlename", "bpluginType", "bpackagename", "bundleDesc", "bendorname", "BpackageInfo", "baffleType", "bundleID", "bridgeName", "babiname", "rbpluginName", "bundleType", "bendorID", "rbundleType", "BundleDesc", "bpluginName", "BundleInfo", "boodleName", "bpackageInfo", "bblID", "bpluginname", "bendorType", "bblName", "bpackageName", "bridgename", "rbundleName", "BpackageDesc", "bundlename", "BendorID", "BundleName", "baffleInfo", "rbundleInfo", "Bpackagename", "bafflename", "bundleInfo", "bpluginInfo", "boodleInfo", "baffleName"], "info": ["link", "image", "fo", "index", "base", "child", "end", "of", "inf", "check", "alias", "py", "ignore", "entry", "available", "filter", "parse", "zip", "fw", "key", "b", "api", "object", "extra", "string", "def", "gi", "next", "li", "handler", "op", "type", "part", "result", "diff", "by", "bug", "start", "off", "name", "tf", "archive", "data", "file", "INFO", "id", "Info", "error", "comment", "i", "f", "obj"]}}
{"id1": "14567939", "id2": "9081749", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 1, "substitutes": {"baseHash": ["BaseHash", " generateFile", " generateSecret", "baseSecret", "Basehash", "baseFile", " generatehash", " generateHash", " chainHash", "BaseFile", " chainSecret", "basehash", "BaseSecret", " chainFile", " chainhash"], "name": ["image", "base", "resource", "create", "account", "NAME", "prefix", "alias", "key", "member", "object", "style", "string", "class", "ame", "hash", "definition", "Name", "path", "hello", "part", "type", "named", "secret", "word", "id", "file", "user", "data", "names", "n", "normal", "host", "parent", "address"], "password": ["Password", "account", "prefix", "input", "pattern", "stroke", "paste", "text", "key", "wd", "wallet", "string", "hash", "code", "pass", "crypt", "token", "path", "padding", "phrase", "attribute", "priv", "diff", "secret", "auth", "PASS", "word", "data", "seed", "username", "security", "sword", "value", "words", "profile", "source", "device"], "digest": [" digger", "modester", "Diger", "decr", "digr", "DigEST", "mdest", "mdEST", "mdr", "digester", "modest", "decest", "signger", "decester", "Digester", "modested", "decEST", "Digested", "diger", " diger", "moder", "mdester", "signer", "signest", "signester", "digusher", " digusher", "Digger", "digested", "digEST", "signusher", "Digr", " digested", "digger", "Digest", "Digusher", " digester"]}}
{"id1": "5142039", "id2": "16590954", "code1": "    public static String uncompress(String readPath, boolean mkdir) throws Exception {\n        ZipArchiveInputStream arcInputStream = new ZipArchiveInputStream(new FileInputStream(readPath));\n        BufferedInputStream bis = new BufferedInputStream(arcInputStream);\n        File baseDir = new File(readPath).getParentFile();\n        String basePath = baseDir.getPath() + \"/\";\n        if (mkdir) {\n            String[] schema = readPath.split(\"/\");\n            String baseName = schema[schema.length - 1].replaceAll(\".zip\", \"\");\n            FileUtils.forceMkdir(new File(basePath + baseName));\n            basePath = basePath + baseName + \"/\";\n        }\n        ArchiveEntry entry;\n        while ((entry = arcInputStream.getNextEntry()) != null) {\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(basePath + entry.getName()));\n            } else {\n                String writePath = basePath + entry.getName();\n                String dirName = FilenameUtils.getPath(writePath);\n                FileUtils.forceMkdir(new File(dirName));\n                BufferedOutputStream bos = new BufferedOutputStream(FileUtils.openOutputStream(new File(writePath)));\n                int i = 0;\n                while ((i = bis.read()) != -1) {\n                    bos.write(i);\n                }\n                IOUtils.closeQuietly(bos);\n            }\n        }\n        IOUtils.closeQuietly(bis);\n        return basePath;\n    }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"uncompress": ["uncompressed", "uncompzip", "uncopzip", " unompzip", " uncompression", "unompressed", " uncompressed", " unompress", "uncopression", "uncompression", " unompressed", "unCompress", " unompression", "uncopressed", "unompzip", "unompression", "unCompressed", "unCompression", "unompress", "uncopress", " uncompzip", "unCompzip"], "readPath": ["writeCase", "baseTree", "readTree", " readFile", "loadpath", "writePo", "loadPo", "loadWith", "loadFile", "loadDir", "scanDir", "checkPo", "workTree", "loadCase", "readerPath", "baseWith", "loadPath", "checkPath", "readWith", "writeDir", "readPo", " readWith", "writeFile", "workFile", "readCase", "scanPath", "readDir", "baseFile", "scanCase", "scanpath", "workpath", "readerpath", "basepath", "checkDir", "checkFile", "readpath", "readFile", "workPath", "writepath", "readerTree", "readerFile", " readpath"], "mkdir": ["MKdir", "MKDir", "kkrel", "kkdir", "ckDir", " mkDir", "muturl", "mkrel", " mkdb", " mkrel", "MKrel", "mkDir", "ckurl", "mutdir", "kkzip", "MKzip", "mutDir", " mkurl", "ckdb", "ckdir", "mkdb", "mutdb", "mkzip", " mkzip", "mkurl", "kkDir"], "arcInputStream": ["ancInputFile", "ancOutputFile", "arcFileStream", "arcReadStream", "cInputStream", "cOutputSync", "arcHttpStream", "arcReaderChannel", "arcOutputChannel", "arcImportChannel", "arcReadstream", "arcOutputFile", "arcHttpForm", "arcInputFile", "ancOutputStream", "arcOutputSt", "arcOutputstream", "ancInputChannel", "arcOutputForm", "arcFileSteam", "arcReaderStream", "cInputSteam", "arcFileSt", "ancInputstream", "arcInputChannel", "arcReadSync", "ancInputForm", "cInputSt", "ancOutputChannel", "cOutputStream", "ancInputStream", "arcHttpstream", "arcFileSync", "arcReadSteam", "arcOutputStream", "arcHttpSteam", "arcInputstream", "cOutputSt", "arcInputSt", "cOutputSteam", "arcOutputSync", "arcInputSteam", "arcInputForm", "arcInputSync", "arcImportstream", "arcReaderFile", "arcReaderstream", "arcReadForm", "arcImportFile", "arcImportStream", "ancOutputstream", "cInputSync", "ancOutputSteam", "ancInputSteam", "arcOutputSteam", "arcReadSt", "ancOutputForm"], "bis": ["pins", "ours", "kos", "lus", "vs", "abs", "mis", "bits", "ls", "alis", "bid", "lins", "bb", "cb", "raf", "usb", "idis", "ubis", "obs", "abi", "fb", "boot", "onis", "ris", "ros", "obb", "bi", "os", "ras", "oss", "uds", "phis", "banks", "sis", "ins", "is", "cos", "ses", "ubs", "phys", "ois", "bs", "isin", "oris", "binary", "bps", "ios", "BUS", "bus", "parts"], "baseDir": ["BaseDir", "baseFolder", " baseDirectory", "rootDir", "basedir", "BaseDirectory", "baseDirectory", "Basedir", "fileFolder", " baseFolder", "BasePath", "BaseFolder", "rootFolder", "fileDir", "filedir", "fileDirectory", " basedir", "rootPath", "rootDirectory"], "basePath": ["basicCondition", "BaseName", "BaseDir", "baseCondition", "baseStream", "buildType", "baseHost", " baseStream", "BaseFile", " baseUrl", "fileName", "resourcepath", "parentUrl", "filePath", "resourceDir", "BaseInfo", "basicPath", "viewPath", "basicInfo", "basedPath", "BaseUrl", "writeHome", "buildPath", "basedType", "resourcePath", "writeStream", "viewStream", " baseHost", "baseInfo", "parentFile", "basedDir", " baseOrder", " baseType", "parentName", "buildHost", "outDir", "viewHome", "BasePath", "basedHost", "baseOrder", "writeOrder", "readDir", "buildDir", "baseFile", "readUrl", "BaseCondition", "baseHome", "outUrl", "parentPath", "fileDir", "resourceName", " baseFile", "fileUrl", "basepath", "readName", " basepath", "outName", "readCondition", "Basepath", "outPath", "basicDir", "readInfo", " baseHome", "viewOrder", "baseType", "baseUrl"], "schema": ["mama", "Schema", " scheme", "cheaga", "mame", "cheme", "scheme", "syaga", "Scheme", "syme", "mapa", "chema", "issma", "issmas", "mamas", "issme", "Schemas", "schepa", "chemar", "syma", "schemar", "Schemar", " schemas", "schemas", "Schepa", "chemas", "scheaga", "symas", "isspa", " schemar", "Scheaga"], "baseName": ["BaseName", "basDir", "basicKey", "basInfo", "basName", "areaName", "areaPath", "BaseKey", "normalTitle", "basicName", " baseKey", "coreInfo", "normalPath", "areaKey", "baseInfo", " baseTitle", "normalKey", " baseInfo", "BasePath", "baseTitle", "BaseTitle", "coreDir", "normalName", "coreName", "baseKey", "corePath", "basPath", "basicPath"], "entry": ["lc", "her", "de", "index", "base", "letter", "service", "nt", "system", "feed", "office", "section", "child", "inner", "je", "ry", "parse", "zip", "Entry", "exp", "add", "journal", "key", "info", "post", "object", "extra", "style", "element", "pe", "cel", "ace", "next", "path", "ie", "part", "line", "record", "result", "se", "ent", "uri", "it", "entity", "si", "row", "le", "article", "name", "la", "ae", "ge", "archive", "server", "data", "ries", "sea", "e", "valid", "card", "iterator", "comment", "no", "reader", "enter", "or", "connection", "inc", "install", "obj", "editor"], "writePath": ["writeCase", "baseStream", " writeCase", "WriteDir", "writtenPath", " writeDir", "WritePath", "writeCh", "writtenStream", "writtenName", "writeStream", "writerEx", "writeName", "writerPath", "writeDir", "readPoint", "basePoint", "readCase", "readDir", "writeEx", " writeCh", "writerDir", "writingPoint", "writePoint", "writtenPoint", "readStream", "readName", "WriteEx", " writePoint", "writerCh", "writingCase", "WriteCh", "writingDir", "writingPath", " writeEx"], "dirName": ["orderUrl", "Dirname", "ordername", "DirDef", "DirName", "DIRAlias", " dirDef", "dirname", " dirAlias", "dirDef", " dirname", "DirUrl", " dirPath", "DIRName", "orderName", "DIRPath", "dirPath", "DirAlias", " dirUrl", "dirAlias", "DIRDef", "DirPath", "dirUrl"], "bos": ["bo", "rots", "asio", "zos", "osa", "kos", "atis", "dies", "osi", "lins", "bas", "bb", "boards", "bones", "gb", "obo", "ubis", "obs", "bies", "zo", "bes", "boot", "ros", "obb", "obos", "os", "bi", "oids", "uds", "oks", "banks", "bott", "ubs", "las", "ois", "ko", "nas", "bs", "opus", "ios", "oos", "fits", "bc", "los", "aos", "obi"], "i": ["ini", "z", "index", "j", "o", "batch", "chi", "in", "hi", "inner", "phi", "ii", "mini", "slice", "l", "b", "info", "ui", "ri", "pi", "c", "r", "abi", "li", "ci", "p", "multi", "si", "xi", "ni", "bi", "io", "v", "uri", "ai", "ji", "it", "x", "ip", "is", "length", "start", "a", "qi", "id", "e", "limit", "f", "di", "you", "exec", "I", "zi", "s"]}}
{"id1": "21491791", "id2": "16572931", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"run": ["unit", "log", "create", "func", "worker", "process", "code", "apply", "running", "fork", "work", "job", "build", "all", "loop", "command", "start", "app", "spawn", "test", "runner", "call", "Run", "execute", "exec", "invoke"], "input": ["image", "flow", "index", "in", "resource", "raw", "feed", "storage", "view", "stream", "inner", "form", "audio", "Input", "worker", "active", "entry", "up", "text", "reading", "parser", "conn", "read", "driver", "initial", "state", "readable", "work", "control", "io", "out", "client", "context", "loader", "internal", "request", "data", "file", "user", "iterator", "instance", "connection", "config", "source", "address"], "output": ["writing", "image", "letter", "log", "written", "unit", "generated", "resource", "index", "temp", "outer", "end", "office", "write", "target", "text", "cache", "filename", "queue", "later", "environment", "object", "page", "application", "exit", "path", "job", "writers", "control", "console", "out", "response", "network", "Writer", "operation", "Output", "file", "data", "document", "user", "put", "web", "connection", "config", "source", "parent"], "reader": ["image", "slave", "in", "resource", "system", "view", "stream", "rer", "inner", "audio", "entry", "worker", "parser", "reading", "read", "driver", "builder", "ri", "r", "oder", "handler", "er", "author", "io", "row", "client", "context", "ner", "manager", "riter", "loader", "request", "peer", "wrapper", "server", "Reader", "source", "book", "owner", "rator"], "writer": ["writing", "her", "written", "wb", "outer", "office", "inner", "w", "write", "player", "wan", "entry", "worker", "wer", "ws", "engine", "builder", "driver", "ew", "r", "creator", "wa", "wr", "work", "er", "writers", "author", "wire", "nw", "out", "ner", "manager", "riter", "Writer", "word", "request", "ter", "wrapper", "data", "war", "maker", "rw", "writ", "or", "connection", "editor"], "pump": ["pamp", "prump", "Pumper", "camp", "ppump", "Pump", "dmp", "pdump", "ppumps", "humper", "dumps", "prdump", "pram", "Pdump", " pumping", " pam", "mump", "Pam", "prumper", "Pmp", " pmp", "Pumps", "hprint", " pamp", " pdump", "cumper", "pam", "Pprint", "Pumping", "pumping", "hump", "cump", "pumper", "dump", "pmp", "Pamp", "mprint", "ppumping", "mumps", " pumps", " pumper", "ppumper", "mumper", "pumps", "cumping", "humps", "pprint", "dumper"], "counter": ["num", "repeat", "index", "ver", "lr", "outer", "walker", "offset", "continue", "current", "inner", "step", "sequence", "order", "meter", "ener", "entry", "worker", "inter", "consumer", "version", "master", "count", "ger", "now", "race", "page", "builder", "code", "clock", "starter", "r", "collection", "rew", "author", "er", "hello", "Counter", "result", "pointer", "progress", "currency", "number", "row", "loop", "layer", "ner", "cookie", "loader", "trace", "ception", "runner", "keep", "ter", "server", "seed", "const", "instance", "second", "keeper", "center", "timer", "zero", "comment", "enter", "parent", "url", "processor"], "buffer": ["base", "resource", "entry", "channel", "text", "message", "queue", "uf", "page", "buf", "position", "buff", "uffer", "layer", "length", "loader", "server", "data", "file", "document", "reference", "port", "limit", "binary", "iter", "batch", "source", "Buffer", "url", "header", "address"], "off": ["flow", "o", "offs", "end", "offset", "of", "inner", "art", "head", "open", "ff", "Offset", "offer", "ref", "less", "area", "info", "ui", "now", "auto", "left", "set", "ord", "pos", "OFF", "fail", "opt", "addr", "out", "own", "start", "low", "on", "down", "oa", "unknown", "Off", "eno"], "len": ["body", "log", "lc", "in", "end", "lit", "val", "lf", "fin", "lan", "ref", "count", "ler", "lon", "den", "l", "bin", "ld", "pos", "fd", "li", "fl", "en", "line", "Len", "width", "lim", "all", "elt", "layer", "length", "size", "name", "ln", "on", "ll", "lt", "gen", "limit", "lock", "el", "n", "lib", "loc", "url", "lin"], "rd": ["dd", "nd", "dr", "lr", "fr", "rx", "ud", "val", "rid", "xd", "rt", "RD", "RR", "adr", "ld", " prod", " r", "rod", "ord", "rf", "r", "rc", "fd", "d", "ind", "db", "rob", "ds", "rand", "red", "rr", "nr", "rh", "raid", "ra", "rs", "hr", "rn", "rm", "rss", "rb", "rw", "rl", "ru", "cr", "dra"]}}
{"id1": "10214218", "id2": "10547671", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 0, "substitutes": {"encrypt": ["encress", " encipher", " enccrypt", "enrypt", "decrypt", "encipher", "decress", "enress", "deccrypt", "decipher", " encress", "enipher", "enccrypt"], "plaintext": ["battxt", "plainText", "batsource", " plainstruct", "battext", "batText", " plainsource", "maintext", "anytxt", "plaintxt", " plainText", "mainsource", "mainstruct", "anystruct", "plainstruct", "plainsource", "mainText", "batstruct", "anytext", "anyText", " plaintxt"], "md": ["dd", "nm", "sha", "cmd", "dr", "meta", "mage", "am", "dig", "metadata", "amd", "ma", " MD", "arm", "mm", "mad", "mo", "message", "mu", "key", "ms", "ld", "wd", "mp", "mand", "d", "kg", "bd", "ad", "pg", "pm", "mg", "mt", "mac", "sm", "od", "cm", "MD", "Cmd", "mod", "data", "dh", "pd", "mag", "dm", "mc", "em", "mb", "hm", "m", "db"], "raw": ["enc", "Raw", "image", "dec", "wave", "feed", "hex", "content", "input", "none", "serial", "text", "message", "load", "bytes", "full", "null", "array", "buf", "initial", "ack", "buffer", "rc", "good", "rew", "original", " RAW", "row", "block", "pack", "clean", "unsigned", "wrapper", "data", "binary", "RAW", "unknown", "instance", "ng", "words"], "hash": ["image", "her", "sha", "base", "log", "html", "hex", "version", "alpha", "message", "cache", "key", " hex", "ruby", "code", "array", "kh", "abi", "sh", "rh", "response", "mac", "ashes", "secret", "block", "ash", "Hash", "sum", "hed", "h", "ha", "id", "data", "url", "header"]}}
{"id1": "9371421", "id2": "15018553", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"eventHash": ["messageKey", "messageDig", "byteDig", " eventKey", "eventKey", "messagehash", "byteHash", "messageHash", "byteKey", "bytehash", "eventhash", " eventhash", "eventDig", " eventDig"], "eventstr": [" eventsource", " eventdict", "errorsource", "Eventsource", "exdict", "errorstring", "exstr", "errorStr", "eventdict", "eventsource", "Eventstring", "exstring", "Eventdict", "EventStr", " eventstring", "Eventstr", " eventStr", "errorstr", "eventstring", "eventStr", "exStr"], "md": ["dd", "sha", "cmd", "dr", "dig", "metadata", "ma", "amd", " MD", "hd", "mm", "mo", "mu", "key", "ke", "ms", "ld", "wd", "mp", "vd", "hash", "mn", "d", "m", "mand", "bd", "doc", "ad", "pm", "mt", "sm", "mac", "mg", "od", "cm", "MD", "map", "mod", "id", "data", "dh", "mag", "dm", "mc", "mem", "em", "ng", "hm", "mb", "di", "meta", "rpm"], "theDigest": ["Thedigester", "Thedigest", " theSignest", " theSignhest", "theSignEST", "thedigEST", "ThedigEST", "thedigest", " theDighest", "theHashester", " theDigester", "TheDigEST", "thedighest", "TheDigester", "TheDigest", " theSignester", "theDighest", "theHashest", "theDigEST", "theHashEST", "thedigester", " theSignEST", "theSignhest", "theSignester", "theSignest", " theDigEST", "theDigester"]}}
{"id1": "9872346", "id2": "20210699", "code1": "    public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException {\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\");\n        Document document = null;\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            factory.setCoalescing(true);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDefaultUseCaches(false);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"User-Agent\", \"eXchaNGeR/\" + System.getProperty(\"xngr.version\") + \" (http://xngr.org/)\");\n            connection.connect();\n            InputStream stream = connection.getInputStream();\n            document = factory.newDocumentBuilder().parse(stream);\n            stream.close();\n            connection.disconnect();\n        } catch (SAXException e) {\n            if (e instanceof SAXParseException) {\n                throw (SAXParseException) e;\n            }\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \") [\" + document + \"]\");\n        return document;\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"readRemoteDocument": ["readLocaldocument", "readLocalDocuments", "readExternalDocument", "loadRemoteDocument", "readServerDocuments", "readServerDocument", "loadLocalDocuments", "loadRemoteDocuments", "readRemoteDocuments", "readLocalDocument", "loadLocalDocument", "loadLocaldocument", "readServerdocument", "readExternaldocument", "readExternalDocuments", "readRemotedocument", "loadRemotedocument"], "url": ["link", "image", "lc", "URL", "base", "service", "email", "feed", "resource", "www", "config", "download", "Url", "entry", "channel", "version", "http", "load", "filename", "remote", "l", "page", "string", " URL", "position", "store", "path", "org", "uri", "layer", "client", "xml", "ur", "socket", "ssl", "location", "name", "server", "host", "file", "ll", "user", "username", "sl", "rl", "loc", "source", "f", "address"], "validate": ["verated", "validated", "validation", " validating", " validated", "verating", "Valated", "Valating", "verate", "validating", "veration", "Valate", "Valation", " validation"], "document": ["image", "video", "index", "model", "graph", "resource", "service", "system", "office", "ocument", "view", "content", "metadata", "project", "function", "text", "message", "output", "media", "object", "page", "application", "null", " documentation", "degree", "collection", "session", "node", "doc", "record", "result", "container", "df", "response", "design", "xml", "Document", "expression", "location", "word", "request", "material", "language", "data", "valid", "port", "value", "database", "source", "parent", "f", "dict"], "factory": ["Factory", "folver", "infiller", "infuture", "FFactory", "fixture", "bactory", "hactory", "infactory", "dactory", " filler", "fade", "sfault", "dade", "affluent", "fsiller", "affactory", "future", " fFactory", "fault", "pactory", "efluent", "fsolver", "efixture", "pixture", "bluent", "hiller", "efactory", "fsactory", "sfixture", "fFactory", " folver", "duture", "sfluent", "biller", "infade", "efiller", "piller", "diller", "pault", "Folver", "affault", "pluent", "filler", "hade", "fluent", "huture", "bixture", "sfactory", "Filler", "fsFactory", "affixture"], "connection": ["image", "link", "index", "service", "resource", "system", "section", "default", "current", "common", "function", "open", "channel", "version", "Connection", "http", "cache", "use", "password", "writer", "conn", "info", "application", "builder", "driver", "c", "position", "condition", "session", "creator", "collection", "relation", "handler", "translation", "io", "container", "uri", "out", "response", "client", "character", "context", "socket", "communication", "proxy", "con", "wrapper", "server", "union", "user", "port", "connect", "error", "database", "reader", "connected", "config"], "stream": ["body", "image", "video", "model", "resource", "system", "raw", "feed", "cont", "view", "coll", "form", "transform", "input", "trans", "entry", "channel", "version", "load", "stack", "output", "media", "writer", "object", "string", "path", "handler", "sc", "translation", "upload", "result", "io", "container", "v", "out", "response", "row", "client", "context", "loader", "server", "data", "file", "sl", "reader", "per", "sw", "Stream", "or", "source", "f"]}}
{"id1": "19549489", "id2": "8588992", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public ActionForward perform(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String status = null;\n        HttpSession session = request.getSession();\n        ReportingBean reportingBean = null;\n        NewConceptBean conceptBean = null;\n        String conceptName = null;\n        String primitive = null;\n        MessageResources errorMessages = MessageResources.getMessageResources(\"com.apelon.apps.dts.treebrowser.resources.error_messages\");\n        LogonUtilities logonUtilities = new LogonUtilities();\n        if (logonUtilities.checkSession(session, status, reportingBean, errorMessages)) {\n            reportingBean = (ReportingBean) session.getAttribute(\"reportingBean\");\n            if ((reportingBean.getMessageHtml().indexOf(\"Classify\")) == -1) {\n                reportingBean.setReportingHtml(\"\");\n            }\n            conceptBean = (NewConceptBean) session.getAttribute(\"newConceptEntity\");\n            conceptName = request.getParameter(\"conceptName\");\n            primitive = request.getParameter(\"primitive\");\n            if (primitive == null) {\n                primitive = \"false\";\n            }\n            conceptBean.setConceptName(conceptName);\n            conceptBean.setPrimitive(primitive);\n            String namespace = conceptBean.getConceptNamespace();\n            if (namespace == null) {\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_3\"));\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n                return (mapping.findForward(status));\n            }\n            String[] roleMods = request.getParameterValues(\"some_or_all\");\n            String[] roleGrps = request.getParameterValues(\"role_group\");\n            Vector roles = conceptBean.getRoles();\n            RoleBean[] roleCons = new RoleBean[roles.size()];\n            roles.copyInto(roleCons);\n            if (roleMods != null && roleGrps != null && roleCons != null) {\n                if (roleCons.length == roleMods.length && roleCons.length == roleGrps.length) {\n                    for (int i = 0; i < roleCons.length; i++) {\n                        roleCons[i].setSomeOrAll(roleMods[i]);\n                        roleCons[i].setRoleGroup(roleGrps[i]);\n                    }\n                }\n            }\n            session.setAttribute(\"newConceptEntity\", conceptBean);\n            NewConceptXMLDisplayBean xmlBean = new NewConceptXMLDisplayBean();\n            xmlBean.setNewConceptXml(conceptBean);\n            String data = BrowserUtilities.encodeUrl(\"conceptXml\") + \"=\" + BrowserUtilities.encodeUrl(xmlBean.getNewConceptXml()) + \"&\" + BrowserUtilities.encodeUrl(\"nameSpace\") + \"=\" + BrowserUtilities.encodeUrl(namespace);\n            XMLPropertyHandler configPh = new XMLPropertyHandler(\"dtsbrowserclassify.xml\");\n            Properties configProps = configPh.getProps();\n            String urlString = configProps.getProperty(\"url\");\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuffer buf = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                buf.append(line);\n            }\n            String resultXml = buf.toString();\n            wr.close();\n            rd.close();\n            ClassifiedConceptBean ccBean = new ClassifiedConceptBean();\n            ClassifyResultParser parser = new ClassifyResultParser(resultXml);\n            ResultBuilder rbuilder = new ResultBuilder();\n            rbuilder.setConceptBean(ccBean);\n            rbuilder.setParser(parser);\n            rbuilder.setNamespace(namespace);\n            try {\n                rbuilder.buildResult();\n                ccBean = rbuilder.getConceptBean();\n                ClassifiedConceptDisplayBean displayBean = new ClassifiedConceptDisplayBean();\n                displayBean.setNewConceptHtml(ccBean);\n                session.setAttribute(\"classifyResult\", ccBean);\n                session.setAttribute(\"classifyDisplayResult\", displayBean);\n                status = \"success\";\n            } catch (Exception e) {\n                Categories.dataServer().error(StackTracePrinter.getStackTrace(e));\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_1\") + e.getMessage());\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n            }\n        }\n        return (mapping.findForward(status));\n    }\n", "label": 0, "substitutes": {"copy": ["create", "clone", " copies", "download", "write", " copying", " copied", " Copy", "paste", "cop", "zip", "Transfer", "sync", " move", "Cop", "split", "p", "upload", "io", "all", "Copy", "file", "transfer", "move", "delete", "source", " transfer"], "sourceFile": ["resourceFile", "sourceDirectory", "searchfile", "SourceFILE", "resourceFiles", "searchFile", "resourcefile", "sourceFilename", "serviceFile", " sourcefile", "SourceDirectory", " sourceFiles", "serviceFilename", "siteFILE", "siteDirectory", "sourceFILE", "searchFilename", "SourceFile", "sourcefile", "resourceDirectory", "Sourcefile", "sourceFiles", "serviceFiles", " sourceFILE", "siteFiles", "servicefile", "siteFile", " sourceFilename", "SourceFiles", "searchFiles", " sourceDirectory"], "destinationFile": ["distinationFiles", "distinationFile", "DestinationFile", "DestinationFiles", "destinationImage", "destinatedDirectory", "destinatedFiles", "destationDirectory", "Destinationfile", "destationFiles", "destinatorDirectory", "destinatorfile", "distinatedFiles", "destinatedImage", "distinatedFile", "distinationDirectory", "DestinatorFiles", "DestinatorFile", "distinatedDirectory", "destationFile", "distinatedImage", "destinatorFile", "destinatedDir", "DestinatorDir", "destationImage", "destinatorDir", "destinatorImage", "destinatedfile", "destinationDir", "distinationImage", "destinationfile", "destationfile", "destinationDirectory", "destinatorFiles", "DestinationDir", "Destinatorfile", "destinationFiles", "destinatedFile", "destationDir"], "sourceFileChannel": ["sourceStreamStream", " sourceFileContext", "sourceDirStream", "sourceLibraryChannel", "sourceLibrarySocket", "sourceStreamChan", "sourceStreamChannel", "sourceFilesService", "targetLibraryChan", "ourceFilechannel", "sourceFileClient", "targetFileChannel", " sourceFileService", "sourceFileConnection", " sourceFilesConnection", "sourceFileSocket", "sourceStreamConnection", "ourceStreamchannel", "sourceDirectoryChannel", "ourceFileStream", "sourceFunctionChannel", "sourceLineClient", "sourceFileChan", "sourceDirChan", "sourceLineChan", "sourceFunctionService", "sourceFilesChannel", "sourceStreamchannel", "sourceFileService", "ourceFileChannel", "sourceLineStream", "sourceFileContext", "targetLibraryChannel", "sourceLibraryClient", "targetFileSocket", " sourceFilesChannel", "sourceLineChannel", "targetFileChan", " sourceFilesService", "ourceStreamChan", "sourceDirectoryClient", "sourceFilesContext", "sourceStreamContext", "sourceFunctionConnection", " sourceFilesContext", "ourceStreamStream", "sourceLinechannel", "targetFileClient", "sourceLineSocket", "targetLibrarySocket", "sourceDirectoryChan", "sourceLibraryChan", "sourceStreamService", "targetLibraryClient", "ourceFileChan", "sourceDirchannel", "sourceFilesConnection", " sourceFileConnection", "ourceStreamChannel", "sourceFileStream", "sourceDirChannel", "sourceFunctionContext", "sourceDirectorySocket", "sourceFilechannel"], "destinationFileChannel": ["destinationFileService", "destinationFileHandler", "destinatorFileChan", "destinationDirectoryHandler", "destinatorFilesChannel", "destinationFilesCache", "destinatorFileCache", "destinationDirectoryClient", "destinatorFileClient", "destinatorFilesCache", "destinatorFileHandler", "destinationDirectoryChannel", "destinationFilesConnection", "destinationLineChannel", "destinationLineHandler", "destinatorFileConnection", "destinationDirectoryConnection", "destinationLineChan", "destinationFileConnection", "destinationFileChan", "destinationFileCache", "destinatorFileChannel", "destinationFilesService", "destinationDirectoryCache", "destinationFileClient", "destinationFilesClient", "destinationIOService", "destinationDirectoryService", "destinationLineConnection", "destinationFilesHandler", "destinatorFilesChan", "destinationIOClient", "destinatorFilesHandler", "destinationFilesChannel", "destinationDirectoryChan", "destinatorFileService", "destinationIOChannel", "destinationLineClient", "destinationLineService", "destinationFilesChan", "destinatorFilesService", "destinatorFilesConnection", "destinationIOCache", "destinatorFilesClient"]}}
{"id1": "5872038", "id2": "9033639", "code1": "    public void parse() throws ParserConfigurationException, SAXException, IOException {\n        DefaultHttpClient httpclient = initialise();\n        HttpResponse result = httpclient.execute(new HttpGet(urlString));\n        SAXParserFactory spf = SAXParserFactory.newInstance();\n        if (spf != null) {\n            SAXParser sp = spf.newSAXParser();\n            sp.parse(result.getEntity().getContent(), this);\n        }\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"parse": [" explode", "send", "create", "feed", " assemble", "format", "transform", "scan", "patch", "write", "load", "parser", "process", "post", "print", "read", "set", "apply", "throw", " load", "split", " parsing", "se", "build", "Parser", "handle", " serve", "xml", "report", "pack", "request", " parser", "eval", " service", " scrape", "delete", " process", "arse", "execute", "exec", " analyse", "save"], "SAXException": ["SAXYEX", "SAXEX", "SAXXException", "IAFXException", "IAFXWarning", "SAXWarning", "SAXXEX", "SAFXException", "SAXXWarning", "IAFXEX", "IAXEX", "SAXYWarning", "SAFXEX", "IAXException", "SAXYException", "SAFXWarning", "IAXWarning"], "IOException": ["APIception", "APIException", "SecurityExcept", "APIExcept", "IOExcept", "IOception", " IOExcept", "Securityception", "SecurityException", " IOception"], "httpclient": ["httpsserver", "Httpconnection", " httpserver", "httpsclient", "Httpclient", " httpClient", "httpapi", "httpconnection", "httpsClient", "httpsconnection", "Httpserver", "httpClient", " httpconnection", "Httpapi", "httpsapi", "httpserver", "HttpClient", " httpapi"], "result": ["err", "resource", "Result", "found", "this", "json", "match", "obj", "http", "message", "output", "api", "page", "status", "product", "r", "session", "rc", "success", "plus", "record", "ret", "out", "response", "client", "report", "sr", "request", "server", "data", "document", "instance", "results", "res", "default", "source", "url"], "spf": ["Spcf", "prf", "SPsf", " spcf", "espf", " spfx", "SPfx", "prcf", " spfc", "SPcf", "Spfp", "Spf", "SPfc", "espfs", "spfp", "spfs", "scf", " spsf", "spfc", "prF", "scsf", "SPf", "prfp", "spF", "spfx", " spfp", "sccf", "SpF", "espfc", "spsf", " spfs", "spcf", "scfp", " spF", "SPfs", "SPfp", "espfx"], "sp": ["html", "service", "bsp", "serv", "pt", "ap", "pc", "parser", "asp", "spl", "par", "bp", "pr", "so", "pp", "pe", "wp", "ps", "SP", "pl", "sc", "p", "esp", "op", "si", "se", "sh", "app", "sr", "Sp", "span", "tp", "inst", "sf", "ss", "sl", "str", "sw", "br", "f", "obj", "gp"]}}
{"id1": "14303294", "id2": "2936678", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"getServerHash": ["getSecureAddress", " getSecureSHA", " getServerAddress", " getSecureSalt", "getServerSalt", "getSessionSHA", "getSessionHash", " getServerSHA", "getServerAddress", "getserverAddress", "getSecureSalt", "getSecureHash", "getserverSalt", "getserverSHA", "getSecureSHA", " getSecureHash", "getSessionAddress", "getServerSHA", " getSecureAddress", " getServerSalt", "getserverHash", "getSessionSalt"], "passwordHash": [" PasswordHash", " PasswordCode", "privatePassword", "passwordCode", "privatehash", "passwordhash", "PasswordHash", " passwordhash", "PasswordPass", "passwordSalt", "privateSalt", "privateHash", "Passwordhash", " passwordCode", "PasswordPassword", "passwordPassword", " passwordPassword", "passwordPass", " passwordSalt", "PasswordCode", " PasswordPass", " passwordPass"], "PasswordSalt": [" PasswordHash", "PASSPassword", "PasswordHash", " passwordSecret", "passwordSalt", "passwordSecret", "PASS256", "PASSHash", "PasswordSecret", "password256", " Password256", " PasswordPassword", "PasswordPassword", "passwordPassword", " passwordPassword", "Password256", " passwordSalt", " PasswordSecret", "PASSSalt"], "hash": ["image", "her", "sha", "base", "html", "pool", "log", "change", "hex", "content", "check", "dig", "message", "cache", "key", "password", "update", "string", "array", "code", "kh", "buffer", "crypt", "work", "result", "build", "sh", "number", "row", "response", "mac", "block", "ash", "size", "auth", "Hash", "sum", "h", "search", "ha", "data", "user", "value", "error", "url", "copy", "address"], "digest": ["digher", "Digher", "integall", "mdested", " digall", " digger", "Digusher", "Diger", "signher", "digall", "integester", "mdest", "digener", " digher", "hashester", "digester", "signger", "Digester", "integested", "integest", "generester", "generested", "hasher", "Digested", "diger", "Digener", " diger", "hashener", "mdusher", "mdester", "signer", "signest", "signester", "digusher", " digusher", "generall", " digener", "Digger", "digested", " digested", "generest", "digger", "Digest", "hashest", " digester"]}}
{"id1": "12782570", "id2": "12380475", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"logging": ["Loging", "Logging", "Logger", "logger", "configging", "loguring", " loging", " logger", "configger", "loging", "configuring", "configing", "Loguring", " loguring"], "wrap": ["image", "force", "wb", "html", "box", "create", "rap", "stream", "self", "w", "transform", "format", "parse", "zip", "message", "run", "process", "widget", "cache", "use", "bag", "api", "b", "ow", "now", "ws", "we", "builder", "flash", " wrapped", "wp", "wa", "core", "work", "handler", "p", "div", "ad", "wire", "nw", "frame", "build", "handle", "util", " Wrap", "init", "word", "h", "wrapper", "wra", "war", "binary", "lock", "pipe", "sw", "get", "or", "web", "f", "cover"], "buffer": ["log", "nb", "base", "bm", "feed", " buffers", "view", "board", "table", "player", "ref", " buf", "cache", "http", "message", "queue", "bridge", "shell", "b", "bb", "cb", "object", "bin", "pad", "print", "builder", "writer", "buf", "flash", "buff", "fb", "template", "result", "cover", "frame", "response", "layer", "manager", "pb", "loader", "report", "pause", "bar", "wrapper", "server", "reference", "binary", "BU", "transfer", "reader", "iter", "batch", "msg", "source", "Buffer", "reply", "surface", "header", "copy"], "encoding": ["decoding", "decryption", "decaching", "Encoding", "encryption", "encaching", "enording", "challoding", "coded", "encording", "ecoding", "encoded", "challoder", "encoder", "Encoded", "coding", "Encryption", "Encoder", "ecoded", "coder", "challaching", "ecoder", "enaching", "enoder", "decoder", "enoded", "decoded", "challoded", "ecording", "enoding", "cording", "ecryption"], "getEncoding": [" getEnoded", "getCompoder", "getEnasing", " getEnression", "getEnression", "getEnocol", " getEnocol", "getEncoded", "getencocol", "getEnoder", "getCasing", "getCression", " getEncoder", " getEnasing", "getencasing", "getCocol", "getencoder", "getCompression", " getEncoded", "getEncression", "getCompoded", "getCoding", "getEncasing", "getEncocol", "getencoding", "getCoder", " getEnoder", "getCompoding", " getEncression", "getCoded", " getEnoding", "getEncoder", "getEnoded", " getEncocol", "getEnoding", " getEncasing"], "headers": ["body", "ports", "vals", "options", "objects", "keys", "types", "ppers", "heads", "head", "ints", "lines", "breaks", "plugins", "workers", "bits", "links", "ids", "http", "details", "frames", "properties", "blocks", "events", "files", "params", "groups", "padding", "writers", "settings", "relations", "dict", "fields", "caps", "values", "rs", "features", "ings", "h", "wrapper", "header", "names", "str", "strings", "host", "parts", "ers", "s"], "is": ["its", "in", "isol", "isi", "abs", "ops", "mis", "http", "nis", "cms", "lis", "bas", "has", "api", "ms", "ui", "ws", "js", "IS", "so", "obs", "was", "ris", "os", "isl", "oss", "isa", "out", "sis", "fs", "iss", "ins", "as", "ses", "iso", "bis", "es", "are", "us", "ois", "ori", "las", "bs", "ists", "ios", "Is", "i", "tis", "ais", "or", "aos", "iris", "s"], "bos": ["bo", "pins", "beans", "zos", "mobi", "kb", "osa", "abs", " Bos", "bot", "mis", "bits", "ops", "osi", "bots", "lins", "cms", "mos", "bas", "ws", "js", "home", "bones", "so", "obo", "ubis", "obs", "was", "outs", "zo", "abi", "bes", "ros", "org", "obos", "os", "oks", "bi", "uds", "fs", "cos", "oes", "ses", "bott", "bis", "ubs", "ko", "ois", "oops", "android", "proxy", "bs", "opus", "shadow", "oses", "ob", "bps", "ios", "tis", "oos", "fits", "bc", "bh", "los", "aos", "obi"], "e": ["re", "err", "de", "die", "o", "je", "fe", "ne", "E", "ke", "element", "c", "pe", "oe", "ze", "d", "be", "ie", "ea", "er", "type", "p", "se", "x", "ce", "ite", "ale", "ception", "a", "ae", "esi", "ev", "error", "f", "i", "one", "ec", "ele", "exc", "ee"]}}
{"id1": "23199071", "id2": "22338097", "code1": "            @Override\n            public InputStream getInputStream() {\n                try {\n                    String url = webBrowserObject.resourcePath;\n                    File file = Utils.getLocalFile(url);\n                    if (file != null) {\n                        url = webBrowserObject.getLocalFileURL(file);\n                    }\n                    url = url.substring(0, url.lastIndexOf('/')) + \"/\" + resource;\n                    return new URL(url).openStream();\n                } catch (Exception e) {\n                }\n                return null;\n            }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 0, "substitutes": {"getInputStream": ["getInputSteam", "newInputSteam", "getInputChannel", "getInputstream", "getReadStream", "newContentStream", "newContentChannel", "getStreamSteam", "newInputChannel", "getStreamstream", "getReadstream", "getContentstream", "newContentstream", "getContentSteam", "getStreamChannel", "getReadSteam", "getContentStream", "getStreamStream", "newInputstream", "newContentSteam", "getReadChannel", "getContentChannel", "newInputStream"], "url": ["image", "resources", "log", "html", "URL", "base", "resource", "in", "email", "feed", "lr", "service", "www", "q", "fr", "coll", "rule", "ul", "cl", "Url", "download", "ref", "http", "remote", "l", "api", "full", "href", "page", "left", "string", "class", "null", "link", "r", "bel", "route", "buffer", "path", "fl", "type", "rel", "uri", "build", "pull", "dir", "secure", "ur", "name", "location", "ssl", "tool", "loc", "host", "id", "data", "server", "ll", "ob", "gl", "user", "str", "sl", "i", "el", "rl", "default", "jar", "source", "web", "f", "address"], "file": ["File", "log", "folder", "base", "letter", "resource", "unit", "feed", "image", "child", "model", "rule", "plain", "fe", "http", "cache", "zip", "local", "play", "use", "l", "b", "info", "full", "object", "page", "class", "files", "route", "path", "work", "able", "job", "line", "part", "place", "uri", "fp", "dir", "FILE", "name", "live", "data", "id", "e", "money", "lib", "connection", "loc", "source", "db", "f"]}}
{"id1": "7764011", "id2": "22625683", "code1": "    public void readScalarpvviewerDocument(URL url) {\n        try {\n            String xmlData = \"\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            boolean cont = true;\n            while (cont) {\n                line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '%') {\n                    xmlData = xmlData + line + System.getProperty(\"line.separator\");\n                }\n                if (line.length() > 1 && line.charAt(0) == '%' && line.charAt(1) == '=') {\n                    cont = false;\n                }\n            }\n            XmlDataAdaptor readAdp = null;\n            readAdp = XmlDataAdaptor.adaptorForString(xmlData, false);\n            if (readAdp != null) {\n                XmlDataAdaptor scalarpvviewerData_Adaptor = readAdp.childAdaptor(dataRootName);\n                if (scalarpvviewerData_Adaptor != null) {\n                    cleanUp();\n                    setTitle(scalarpvviewerData_Adaptor.stringValue(\"title\"));\n                    XmlDataAdaptor params_font = scalarpvviewerData_Adaptor.childAdaptor(\"font\");\n                    int font_size = params_font.intValue(\"size\");\n                    int style = params_font.intValue(\"style\");\n                    String font_Family = params_font.stringValue(\"name\");\n                    globalFont = new Font(font_Family, style, font_size);\n                    fontSize_PrefPanel_Spinner.setValue(new Integer(font_size));\n                    setFontForAll(globalFont);\n                    XmlDataAdaptor params_pts = scalarpvviewerData_Adaptor.childAdaptor(\"Panels_titles\");\n                    viewValuesPanel.setTitle(params_pts.stringValue(\"values_panel_title\"));\n                    viewChartsPanel.setTitle(params_pts.stringValue(\"charts_panel_title\"));\n                    XmlDataAdaptor params_data = scalarpvviewerData_Adaptor.childAdaptor(\"PARAMETERS\");\n                    if (params_data != null) {\n                        viewValuesPanel.setLastMemorizingTime(params_data.stringValue(\"lastMemorizingTime\"));\n                    } else {\n                        viewValuesPanel.setLastMemorizingTime(\"No Info. See time of file modification.\");\n                    }\n                    XmlDataAdaptor params_uc = scalarpvviewerData_Adaptor.childAdaptor(\"UpdateController\");\n                    double updateTime = params_uc.doubleValue(\"updateTime\");\n                    updatingController.setUpdateTime(updateTime);\n                    double chartUpdateTime = params_uc.doubleValue(\"ChartUpdateTime\");\n                    viewChartsPanel.setTimeStep(chartUpdateTime);\n                    viewValuesPanel.listenModeOn(params_uc.booleanValue(\"listenToEPICS\"));\n                    viewChartsPanel.recordOn(params_uc.booleanValue(\"recordChartFromEPICS\"));\n                    java.util.Iterator<XmlDataAdaptor> pvIt = scalarpvviewerData_Adaptor.childAdaptorIterator(\"ScalarPV\");\n                    while (pvIt.hasNext()) {\n                        XmlDataAdaptor pvDA = pvIt.next();\n                        String pvName = pvDA.stringValue(\"pvName\");\n                        double refVal = pvDA.doubleValue(\"referenceValue\");\n                        double val = 0.;\n                        if (pvDA.hasAttribute(\"value\")) {\n                            val = pvDA.doubleValue(\"value\");\n                        }\n                        spvs.addScalarPV(pvName, refVal);\n                        ScalarPV spv = spvs.getScalarPV(spvs.getSize() - 1);\n                        spv.setValue(val);\n                        spv.showValueChart(pvDA.booleanValue(\"showValueChart\"));\n                        spv.showRefChart(pvDA.booleanValue(\"showRefChart\"));\n                        spv.showDifChart(pvDA.booleanValue(\"showDifChart\"));\n                        spv.showDif(pvDA.booleanValue(\"showDif\"));\n                        spv.showValue(pvDA.booleanValue(\"showValue\"));\n                        spv.showRef(pvDA.booleanValue(\"showRef\"));\n                    }\n                }\n            }\n            spvs.readChart(in);\n            in.close();\n            updatingController.setStop(false);\n            viewValuesPanel.updateGraph();\n            viewChartsPanel.updateGraph();\n        } catch (IOException exception) {\n            messageTextLocal.setText(null);\n            messageTextLocal.setText(\"Fatal error. Something wrong with input file. Stop.\");\n        }\n    }\n", "code2": "    public static Model downloadModel(String url) {\n        Model model = ModelFactory.createDefaultModel();\n        try {\n            URLConnection connection = new URL(url).openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestProperty(\"Accept\", \"application/rdf+xml, */*;q=.1\");\n                httpConnection.setRequestProperty(\"Accept-Language\", \"en\");\n            }\n            InputStream in = connection.getInputStream();\n            model.read(in, url);\n            in.close();\n            return model;\n        } catch (MalformedURLException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"readScalarpvviewerDocument": ["readScalarpvviewedocument", "readScalarpvviewerdocument", "readScalarpvvieweString", "readScalarpvViewersDocument", "readScalarpvviewerData", "readScalarpvviewedDocument", "readScalarpvViewerData", "readScalarpvvieweData", "readScalarpvvieweDocument", "readScalarpvViewersData", "readScalarpvviewersData", "readScalarpvViewerdocument", "readScalarpvViewerDocument", "readScalarpvViewersdocument", "readScalarpvviewerString", "readScalarpvviewersdocument", "readScalarpvViewerString", "readScalarpvviewedData", "readScalarpvViewersString", "readScalarpvviewedString", "readScalarpvvieweddocument", "readScalarpvviewersDocument", "readScalarpvviewersString"], "url": ["image", "link", "URL", "base", "resource", "service", "stream", "input", "Url", "entry", "http", "filename", "remote", "l", "href", "object", "page", "string", "bel", "buffer", "path", "job", "io", "uri", "xml", "name", "location", "ssl", "server", "data", "file", "user", "host", "sl", "reader", "connection", "config", "source", "address"], "xmlData": ["phpDATA", "wsString", " xmlPart", "phpData", "parseData", "rssString", "rssDATA", "mldata", "phpPart", "xmlText", "mlDATA", " xmlContent", "parseCode", "rssdata", "xmlDATA", " xmlCode", "textPart", "mlData", "xmlPart", " xmlDATA", "mlText", "mlContent", "phpContent", "xfData", " xmlString", "parseText", "wsdata", "xmlCode", "textData", " xmlText", "textContent", " xmldata", "xfContent", "rssData", "xmlString", "wsData", "xfDATA", "mlCode", "textDATA", "wsDATA", "parsedata", "xmlContent", "xmldata", "xfText"], "in": ["ini", "kin", "login", "serv", "this", "stream", "inner", "inn", "input", "In", "inc", "rec", "l", "b", "bin", "c", "r", "IN", "buffer", "again", "doc", "source", "nin", "min", "out", "ins", "socket", "ssl", "a", "h", "con", "data", "file", "reader", "i", "win", "connection", "m", "din", "f", "lin", "s"], "line": ["unit", "page", "c", "strip", "job", "single", "block", "chain", "name", "file", "el", "str", "comment", "value", "lin", "lc", "log", "point", "content", "cl", "write", "inline", "sync", "auto", "string", "code", "pass", "phrase", "le", "ip", "character", "user", "error", "no", "non", "plugin", "base", "lf", "none", "lines", "entry", "parse", "text", "l", "object", "row", "data", "on", "one", "rule", "link", "letter", "section", "end", "nl", "LINE", "message", "Line", "ine", "pe", "item", "split", "part", "edge", "word", "range", "cell", "e", "sl"], "cont": ["com", "err", "lc", "ident", "expl", "sect", "circ", "feed", "det", "continue", "coll", "content", "form", " continuous", "match", "feat", "text", "count", "full", "ctr", "ent", " cond", "comb", "contract", "left", " Cont", "ct", "resp", "contin", "tr", "ci", "result", " cur", "multi", "CONT", "progress", " CONT", "dest", "cor", "Cont", "out", "rest", "prev", "comp", "cart", "ont", "collect", "close", "clean", "ext", "mult", "keep", "const", "char", "cell", "cond", "str", "complete", "acc", "parent"], "readAdp": [" readAbr", " readAblp", "readAxc", "readAdps", "readAxs", "readEllpi", "readadpi", "loadAdp", " readAds", "readAbb", "readADb", " readadP", "readEdps", "loadAdlp", "loadADlp", "loadADp", "readadp", "ReadAxpi", " readads", "ReadAdps", "loadAdb", "readads", "readADs", "readAxps", "readEllp", " readAdr", "readElllp", "readADp", "readPromlp", " readAdpi", "loadADpi", "readEllr", "readADr", "readAdb", "readAdlp", "readAdr", "readadc", " readAdlp", "readAds", "readEdc", "readAdpi", "loadAdpi", "readADlp", "readAdP", "readAxP", "readadP", " readadpi", "readPromp", "readPrompi", "ReadAxc", "readEdpi", " readAbpi", "readAbp", " readadp", "readadps", "ReadAdpi", "readAxpi", "readEdp", " readAbp", "readADP", "ReadAxp", "ReadAxps", "readAbr", "readPromb", "readAxp", "ReadAdp", "readAblp", "ReadAdc", "readAdc", " readAdP", "readADpi", "readAbpi", "loadADb"], "scalarpvviewerData_Adaptor": ["scalarpvviewerDataerAdaptutor", "scalarpvviewerData_Collectractor", "scalarpvviewerData_Connector", "scalarpvviewerDataerAdaptor", "scalarpvviewerDataeradaptutor", "scalarpvviewerData_Uploadator", "scalarpvviewerDataLocalAdaptor", "scalarpvviewerData_Collectutor", "scalarpvviewerData_Adapter", "scalarpvviewerData_Creater", "scalarpvviewerData_Uploadive", "scalarpvviewerData_Selector", "scalarpvviewerData_Adaptive", "scalarpvviewerData_Selecter", "scalarpvviewerData_adaptator", "scalarpvviewerDataeradaptator", "scalarpvviewerDataLocaladaptor", "scalarpvviewerData_Collectator", "scalarpvviewerDataLocalAdaptors", "scalarpvviewerData_adaptutor", "scalarpvviewerDataerAdapter", "scalarpvviewerData_adaptors", "scalarpvviewerDataeradapter", "scalarpvviewerData_adaptractor", "scalarpvviewerData_Creatator", "scalarpvviewerData_Adaptator", "scalarpvviewerData_Connecter", "scalarpvviewerDataerAdaptator", "scalarpvviewerData_Connectors", "scalarpvviewerData_AdaptOR", "scalarpvviewerData_Creator", "scalarpvviewerData_Connectator", "scalarpvviewerDataLocalAdaptator", "scalarpvviewerData_Uploador", "scalarpvviewerData_Connectutor", "scalarpvviewerData_Adaptutor", "scalarpvviewerData_adaptive", "scalarpvviewerData_Creators", "scalarpvviewerDataeradaptors", "scalarpvviewerData_CollectOR", "scalarpvviewerData_Adaptors", "scalarpvviewerData_adapter", "scalarpvviewerData_adaptOR", "scalarpvviewerDataeradaptor", "scalarpvviewerDataerAdaptors", "scalarpvviewerData_Collector", "scalarpvviewerData_Adaptractor", "scalarpvviewerData_Creatutor", "scalarpvviewerDataLocaladaptator", "scalarpvviewerData_Selectator", "scalarpvviewerDataLocaladaptors", "scalarpvviewerData_Selectors", "scalarpvviewerDataerAdaptractor", "scalarpvviewerData_Collectors", "scalarpvviewerData_ConnectOR", "scalarpvviewerData_Uploadors", "scalarpvviewerData_adaptor", "scalarpvviewerDataLocaladaptOR", "scalarpvviewerDataeradaptractor", "scalarpvviewerData_Creative", "scalarpvviewerDataLocalAdaptOR"], "params_font": ["paramsinglarge", "params_shadow", "ams_chart", "ams_font", "params_text", " params_Font", "pins_password", "params_theme", "ams_large", "pins_text", "params_Font", "paramsingpen", "params_large", "ams_pen", "ams_fat", "ams_theme", "params_fat", "params_layout", "pins_fat", "paramsingfont", " params_layout", "paramsingfat", "params_password", "params_pen", "pins_font", " params_shadow", "params_chart"], "font_size": ["font_scale", "font_align", "font_handle", "fontBlocksize", " font_handle", " font_scale", "font_type", "font\u00b7handle", "text_size", "font\u00b7number", "text_Size", "font_number", " font_Size", "font_Size", "text_align", "fontBlocktype", "font\u00b7size", " font_number", "fontBlockalign", "text_type", "fontBlockSize"], "style": [" size", "force", "letter", "shape", "height", "depth", "offset", "format", "grade", "order", "pattern", "count", "styles", "pad", "scale", "class", "font", "position", "family", "padding", "type", "width", "css", "length", "color", "size", "Style", "estyle", "name", "thin", "margin", "shadow", "layout", "weight", "level", "theme", " Style", "profile"], "font_Family": ["font_family", "fontNameStyle", "fontNamefamily", "style_family", "fontNameFamily", "style_Style", " font_fam", "fontingStyle", "font_fam", "fontingFamily", "font_Format", " font_Format", "fontingfamily", " font_family", "style_Family", "font_Style"], "globalFont": ["generalText", "GlobalText", "globalfont", "Globalfont", "parentFont", "generalFontSize", "localFontSize", "parentFontSize", " globalfont", "GlobalFont", " globalText", "parentfont", " globalFontSize", "generalFont", "parentText", "globalText", "localText", "localFont", "GlobalFontSize", "globalFontSize"], "params_pts": ["params_cts", "params_ptss", "params_epts", "params_ptn", "params__ctm", "params_PTp", "params_ptm", "params_PTn", "params__ctn", "params_PTs", "params_rtm", "params_eptp", "params_PTss", "params_tda", "params_ptp", "params_fontn", "params_tde", "params_PTa", "params_tds", "params_fontp", "params_pta", "params_PTm", "params__ptm", "params__pts", "params_rtn", "params_fontss", "params__ptn", "params_pte", "params_ctm", "params_erts", "params_fonts", "params_ctn", "params__cts", "params_PTe", "params_erte", "params_rts", "params_eptn", "params_eptss", "params_erta"], "params_data": ["param\n", "Parametersname", "params\n", " paramsname", "Parameters\n", "paramsname", " params\n", "paramname"]}}
{"id1": "15757836", "id2": "6501291", "code1": "    private int[] sort(int n) {\n        int[] mas = new int[n];\n        Random rand = new Random();\n        for (int i = 0; i < n; i++) {\n            mas[i] = rand.nextInt(10) + 1;\n        }\n        boolean t = true;\n        int tmp = 0;\n        while (t) {\n            t = false;\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    tmp = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = tmp;\n                    t = true;\n                }\n            }\n        }\n        return mas;\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"sort": ["num", "index", "order", "ordered", "parse", "round", "slice", "random", "list", "after", "array", "pos", "position", "tr", "split", "ind", "ort", "cmp", "part", "Sort", "min", "comp", "first", "gen", "desc", "rank", "iter"], "n": ["z", "num", "j", "nb", "o", "nat", "nt", "N", "w", "net", "ns", "count", "ne", "l", "b", "c", "r", "g", " N", "sn", "k", "d", "p", "len", "x", "number", "nn", "network", "y", "size", "a", "cn", "fn", "e", "u", "m", "f"], "mas": ["vals", "mask", "amas", "fa", "ima", "amps", "ans", "phi", "forms", "ma", "ama", "arr", "sa", "mm", "mad", "ls", "alpha", "master", "ns", "mos", "bas", "ias", "Las", "ams", "mu", "ms", "asa", "mat", " ma", "pos", "astics", "xs", "params", "pa", "images", "lists", "asia", "mes", "ras", "nos", "os", "mr", "ums", "cas", "as", "la", "las", "features", "lab", "a", "nas", "bs", "faces", "data", "s", "phas", "ta", "ks", "mins", "m", "mast", "parts", "ia"], "rand": ["z", "err", "nd", "right", "dr", "rx", " random", "pick", "cur", "rar", "round", "random", "bird", "rd", "r", "dist", "g", "rc", "grad", "ind", "p", "Rand", "rr", "x", "rh", "wind", "ra", "rest", "start", "init", "clean", "mid", "R", "range", "data", "seed", "gen", "go", "win", "ng", "rot", "res", "reg", "max"], "i": ["ini", "z", "mi", "j", "index", "o", "oi", "chi", "module", "uli", "anti", "hi", "phi", "cli", "ii", "ix", "fi", "mini", "mu", "api", "b", "info", "ui", "ami", "ri", "pi", "gi", "it", "d", "li", "k", "ci", "p", "ie", "si", "ni", "xi", "I", "bi", "v", "x", "ai", "eni", "io", "y", "uri", "ip", "ji", "adi", "init", "ori", "a", "qi", "ti", "id", "e", "iu", "u", "vi", "di", "m", "f"], "tmp": ["z", "j", "temp", "nt", "tt", "offset", "vt", "phi", "beta", "mm", "mini", "alpha", "ref", "xt", "l", "b", "api", "mp", "sup", "pad", "txt", "pos", "c", "sp", "front", "amp", "max", "st", "p", "cmp", "part", "v", "x", "diff", "start", "mist", "test", "emp", "a", "ta", "stuff", "m", "f"], "t": ["z", "j", "o", "nt", "tt", "temp", "pt", "w", "T", "et", "art", "at", "rt", " p", "l", "b", "c", "r", "wt", "ct", "k", "st", "d", "ant", "p", "template", "type", "part", " m", "v", "x", "out", "y", "tw", "bt", "unt", "test", "a", "tf", "tc", "h", "te", "e", "ot", "u", "ta", "qt", "m", " b", "f"]}}
{"id1": "8320469", "id2": "21827619", "code1": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"md5": [" md6", "md2", "mp5", "mp2", "mp512", " md512", " md2", "md6", "MD6", "MD512", "MD5", "mp6", "md512", "MD2"], "text": ["body", "letter", "image", "config", "this", "prefix", "content", "format", "input", "pattern", "target", "message", "output", "key", "password", "bytes", "required", "object", "struct", "string", "txt", "code", "class", "TEXT", "contract", "driver", "buffer", "Text", "path", "out", "secret", "name", "test", "ext", "word", "data", "str", "or", "connection", "source", "obj", "editor"], "encrypted": ["enc", "body", "enabled", "ryption", "temp", "content", "plain", "ordered", " secured", "message", " encrypt", "modified", "cert", "packed", "password", "assembled", "bytes", " encryption", "key", "string", "updated", "checked", "broken", "ed", "confirmed", "phrase", "locked", "used", "finished", "rypted", "selected", "secret", "secure", "ted", "unsigned", "ext", "hed", "initialized", "data", "binary", "ob", "signed", "emb", "rypt", "str", "empty", "shared", "normal", "config"], "md": ["dd", "nm", "cmd", "ym", "meta", "dc", "dig", "metadata", "ma", "amd", " MD", "hd", "mm", "mo", "cd", "wd", "mp", "rod", "km", "code", "mand", "d", "ind", "bd", "ad", "pg", "ds", "pm", "mt", "sm", "mac", "od", "me", "editor", "MD", "Cmd", "mod", "dh", "pd", "mag", "rm", "dm", "mc", "mb", "di", "m", "rpm", "db"]}}
{"id1": "18891988", "id2": "8135072", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["getString", "loadString", "downloadString", "getFilename", "loadFilename", "GetFile", "loadfile", "getfile", "GetFilename", "downloadfile", "Getfile", "loadFile", "downloadFile", "downloadFilename", "GetString"], "serviceName": ["ServiceName", "ServicePath", "packagePath", "ServiceUrl", " serviceUrl", "packageUrl", "servicename", "serviceUrl", "projectPath", "ServiceType", " servicePath", " servicename", "servicePath", "projectName", "packagename", "serviceType", "packageName", " serviceType", "Servicename", "projectType", "projectUrl"], "wsdlLocation": ["wslDirectory", "awslLocation", "awsdlFile", "wsdlFolder", "wllFolder", "awslFile", "wdlAddress", "wsdlFile", "wsllUrl", "wdlDirectory", "awslDirectory", "wsllLocation", "wssdFolder", "wslUrl", "wslFile", "wdlFolder", "wsDLFile", "wslLocation", "wsdlUrl", "wsDLUrl", "wsllAddress", "wsDLDirectory", "awsdlLocation", "wddlFile", "wslFolder", "awsdlUrl", "wsslFolder", "wsslAddress", "wsllFolder", "wssdAddress", "wddlLocation", "awsdlDirectory", "wllLocation", "wdlFile", "wslpFolder", "wsdlDirectory", "wslpDirectory", "wllAddress", "wllFile", "wdlLocation", "wsllFile", "wsdlAddress", "wddlFolder", "wssdFile", "wsslFile", "wsDLLocation", "wsllDirectory", "wslpLocation", "wslpFile", "awslUrl", "wsslLocation", "wddlDirectory", "wssdLocation"], "endpoint": ["enpoint", "startpoint", " endocol", "endpointer", "ENDination", "Endination", "ENDpoint", "Endpoints", "Endpoint", "enPoint", "ENDpoints", " endword", "endspo", "endpoints", "startpointer", " endpo", "endaddress", "enination", "endocol", "Endpo", "startPoint", "endword", "Endocol", "endpo", "endPoint", " endpointer", "endination", "enaddress", "startaddress", "enpointer", "ENDPoint", "enpoints", "Endword", "EndPoint", " endPoint", "endsword", " endaddress", "endspoint", "endsocol"], "fileLocation": [" fileUrl", "FileURI", "FILELocation", " fileDirectory", "FileUrl", "FileLocation", "FileDirectory", " fileURI", "fileURI", "FILEDirectory", "fileDirectory", "fileUrl", "FILEUrl", "FILEURI"], "tempDir": ["tmpVer", "TempPath", "TempDir", " tempPath", "tmpDirectory", "TempDirectory", " temporaryVer", "tmpdir", " tempVer", "tmpDir", "tempdir", " tempDirectory", "tempVer", "Tempdir", "tempDirectory", "tempPath", "tmpPath", " temporaryDirectory", " tempdir", " temporaryDir", " temporaryPath"], "url": ["image", "log", "URL", "service", "base", "www", "stream", "coll", "ul", "download", "Url", "open", "ls", "channel", "http", "l", "conn", "string", "path", "fl", "source", "io", "uri", "pull", "client", "ur", "socket", "ssl", "server", "file", "ll", "el", "sl", "contact", "connection", "config", "host", "web", "f", "address"], "WSDLFile": ["WSDlfile", "WDDlSourceFile", "WSDELFile", "WSDDLSourceFile", "WSDELFiles", "WDDLPath", "WINDELFiles", "WSDLLBase", "WSDDLPath", "WSDlSourceFile", "WINDELFile", "WINDLFile", "WSDDLFiles", "WDDLFolder", "WSDlFolder", "WSDLBase", "WINDELPath", "WSDLFolder", "WSDlFile", "WSDDLFile", "WDDLFile", "WSDDLfile", "WSDLfile", "WSDELFolder", "WDDlPath", "WDDLSourceFile", "WDDLBase", "WSDLLFolder", "WINDLFiles", "WDDLfile", "WSDLFiles", "WSDELPath", "WDDlBase", "WSDDLBase", "WSDLLFiles", "WSDLLfile", "WSDLSourceFile", "WDDlfile", "WDDlFile", "WSDLLFile", "WSDLLPath", "WSDDLFolder", "WINDLFolder", "WDDlFolder", "WSDlBase", "WSDLPath", "WSDLLSourceFile", "WINDELFolder", "WSDlPath", "WINDLPath"], "tmpWSDLFile": ["tmpWSDLLUrl", "tmpWDDELFile", "tmpWSDlFile", "tmpWDDlUrl", "tmpWSDLFolder", "tmpWSDLLocation", "tmpWSDlFiles", "tmpWSDDLLocation", "tmpWSDLFiles", "tmpWSDLLFiles", "tmpWSDLLFolder", "tmpWDDLUrl", "tmpWDDlFiles", "tmpWSDlLocation", "tmpWSDDLUrl", "tmpWDDLFolder", "tmpWDDELLocation", "tmpWSDDLFile", "tmpWDDLLocation", "tmpWSDLLFile", "tmpWSDELLocation", "tmpWSDELFolder", "tmpWSDDLFiles", "tmpWDDELFiles", "tmpWDDlFolder", "tmpWSDELFile", "tmpWDDLFiles", "tmpWSDELFiles", "tmpWDDELUrl", "tmpWSDlFolder", "tmpWDDlFile", "tmpWSDLUrl", "tmpWSDELUrl", "tmpWSDlUrl", "tmpWDDLFile"], "inputFile": ["tempFile", " inputFiles", "tempPlace", "inputBuffer", "InputUrl", "tempfile", "InputPage", "inputBase", " inputUrl", "inputfile", "inputFactory", "requestfile", "requestFiles", "inFile", "InputFiles", "inputStream", "inputPlace", "InputFile", "outputDir", " inputStream", " inputDir", "inputDir", " inputPlace", "tempBuffer", "inPage", " inputfile", "inputFiles", " inputPage", "inputUrl", "tempPage", "inputPage", "InputBuffer", "InputDir", " inputFactory", "requestFile", "InputBase", " inputBase", "tempFactory", "tempBase", "outputFiles", "outputfile", "requestStream", "InputStream", "inDir", "InputFactory", "infile", "InputPlace", "tempUrl", " inputBuffer", "Inputfile", "outputFile"], "tmpFile": ["tempFile", "tmpFiles", "uploadDocument", "tempDocument", "TempPage", "tmpDirectory", "inputStream", "TempDirectory", " tmpPage", "inputDocument", " tmpFiles", "uploadStream", " tmpDirectory", "inputFiles", "uploadFiles", "tempFiles", "tempPage", "TempFile", "tempDirectory", "tempStream", "tmpStream", "uploadFile", "TempFiles", "tmpPage"], "in": ["image", "login", "impl", "inner", "inn", "gin", "input", "In", "up", "l", "bin", "conn", "c", "pin", "IN", "r", "again", "p", "source", "client", "ins", "is", "lin", "init", "ssl", "data", "file", "on", "id", "lock", "reader", "win", "connection", "m", "din", "f", "socket", "inc"], "out": ["image", "err", "log", "conv", "o", "outer", "can", "inner", "to", "input", "net", "In", "channel", "up", "group", "cache", "sync", "output", "OUT", "bin", "writer", "conn", "ch", "c", "IN", "again", "outs", "source", "line", "part", "io", "Out", "client", "name", "co", "server", "on", "file", "error", "timeout", "connection", "inc", "parent", "conf", "socket", "copy"], "con": ["kin", "com", "conv", "can", "inner", "gin", "plain", "nc", "open", "channel", "ctrl", "fc", "sync", "rec", "ch", "conn", "un", "CON", "ran", "c", "IN", "rc", "en", "client", "Con", "ins", "close", "cm", "ssl", "co", "thin", "cn", "connect", "Conn", "win", "bc", "uc", "connection", "inc", "conf", "socket"], "fileLength": ["Filelength", "FileWidth", "fileSize", "channelLength", "filelength", "channelWidth", "contentlength", " fileWidth", " fileSize", "contentLength", "channelLen", "contentSize", " filelength", " fileLen", "fileLen", "channelSize", "FileSize", "contentLen", "FileLen", "FileLength", "fileWidth"], "channelIn": ["connectionConn", "channelIN", " channelIN", "ChannelIN", "resourcein", "channelin", "resourceIn", "characterOut", "ChannelConn", "ChannelIn", " channelin", "connectionOut", "characterIN", "ChannelOut", "Channelin", " channelConn", "resourceIN", "characterIn", "resourceOut", "channelConn", "connectionIn", "characterin", "connectionin"], "channelOut": [" channelOutput", "chanIn", "ChannelOutside", "canOut", "connectionOutput", "connectionOutside", "ChannelIn", "connectionOut", "channelout", "Channelout", "canIn", "ChannelOut", "chanout", " channelout", "channelOutside", "channelOUT", "connectionout", "ChannelOUT", "canOUT", "connectionIn", "canOutside", "chanOUT", "channelOutput", "ChannelOutput", "chanOut", "chanOutside"], "tmpDocument": ["newDocument", "tmpdocument", "tempFile", "mpFile", "tempDocument", "tmpNode", "mpDoc", "tmDocument", "mpNode", "tempContent", " tmpContent", "tmFile", "tmpContent", "tempDoc", " tmpdocument", "newContent", " tmpDoc", " tmpNode", "newdocument", "newFile", "tmpDoc", "tmNode", "tempNode", "tempdocument", "tmdocument", "mpDocument"], "nl1": ["klFirst", "jlone", "klone", "nlone", "ln1", "NL0", "nn11", "nn0", "kl5", "jlFirst", "ln11", "jl1", "arl5", "nl0", "nn2", "nn1", "nl2", "arl1", "nl6", "nl5", "arlone", "NL2", "dl0", "nlFirst", "NL1", "dl1", "nn6", "kl1", "NL11", "ln2", "ln6", "arlFirst", "nl11", "NL6", "jl5", "dl2"], "i": ["ini", "z", "mi", "index", "j", "o", "oi", "chi", "yi", "uli", "hi", "phi", "ii", "ix", "fi", "slice", "mu", "l", "b", "info", "ui", "ri", "pi", "gi", "abi", "d", "li", "ci", "p", "ie", "part", "multi", "si", "ni", "xi", "uri", "bi", "v", "io", "ai", "ji", "eni", "y", "it", "ip", "qi", "ti", "id", "e", "iu", "f", "u", "n", "di", "m", "I"], "node1": ["n1", " node2", "nodeOne", "package1", "packageone", "Node0", "n0", "nodeone", "NodeOne", "shape1", " nodeOne", "Node2", "package91", "shape91", "node91", "node2", " nodeone", "n2", "layerOne", " node91", "Node91", "layer91", "node0", "layer1", "nOne", "layer2", " node0", "shapeone", "packageOne", "shapeOne", "Node1"], "tmpOut": ["tempWriter", "tempFile", " tmpOUT", "vmOUT", "tmpout", "cacheIn", "ptyIn", "tmpOutput", "ptyOutput", "txtOut", " tmpout", "tempOutput", "vmIn", "vmOut", "ptyout", "tempOUT", " tmpWriter", "txtWriter", "ptyOut", "tmpIn", " tmpIn", "cacheFile", "tempout", "txtout", "tempIn", " tmpOutput", "cacheOut", "tmpOUT", "tempOut", "tmpWriter", "vmout", "txtOutput", "cacheOUT"], "retVal": ["valRet", "retObj", "valObj", "RETval", "retRet", "retval", " retRet", "valVal", "RETRet", " retObj", " retval", "RETVal", "RETObj", "valval"]}}
{"id1": "17202158", "id2": "539195", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"readZoneIDs": ["readCodeIDS", "loadzoneIDS", "loadZoneNames", "loadzoneNames", "readLocationIDs", "readCodeIDs", "readZoneNames", "readLocationIDS", "loadZoneIDs", "readZoneIDS", "readCodeNames", "readzoneIDS", "loadZoneIDS", "readzoneNames", "loadzoneIDs", "readCodeID", "loadzoneID", "readZoneID", "readLocationID", "readzoneID", "readzoneIDs", "loadZoneID", "readLocationNames"], "zoneFileName": ["Zonefilename", "zoneFullname", "zoneFilename", "ZoneFileName", "zoneFullUrl", "zoneClassName", "zonefileName", " zoneFilePath", "zonefilePath", "zoneClassUrl", "ZoneFilename", "ZoneFileUrl", " zoneFileUrl", "zoneFilesName", " zoneDirName", "zonefilename", "zonefileUrl", "zoneFullPath", "ZonefilePath", "zoneDirPath", "zoneFilesname", "zoneClassname", "zoneFilesUrl", "zoneFilePath", "zoneFullName", "zoneDirUrl", "zoneLinePath", "zoneFileUrl", "zoneClassPath", "zoneLineName", "ZonefileUrl", "zoneLineUrl", " zoneDirPath", "ZonefileName", " zoneDirUrl", "zoneFilesPath", "zoneDirName", "ZoneFilePath"], "zoneids": ["zipid", "typeids", "zoneints", "zonelines", "pofiles", "zonefiles", "zoneips", "zipids", " zoneid", "poids", "Zoneids", " zonelines", "ZoneIDs", " zonefiles", "zoneid", "sizeints", "typeips", "Zonefiles", "sizeips", "poIDs", "typeid", "typeints", "zipIDs", "poid", " zoneips", "sizeids", " zoneIDs", "zoneIDs", "ziplines", "sizeid", " zoneints", "Zoneid", "polines"], "url": ["re", "URL", "base", "resource", "service", "feed", "this", "stream", "Url", "ball", "hub", "channel", "http", "l", "b", "api", "page", "string", "class", "bel", "r", "buffer", "path", "job", "io", "uri", "client", "ur", "loader", "name", "location", "ssl", "server", "data", "file", "user", "sl", "reader", "connection", "source", "f", "address"], "lnr": ["lnn", "lenr", "slrb", "nlb", "nlr", "rlb", "slr", "linn", "linr", "lnrb", "rlrb", "slb", "lenp", "lenw", "linrb", "linp", "sln", "rlr", "lnw", "linw", "rln", "linb", "lnb", "lenb", "nlp", "lnp", "nlw"], "line": ["look", "link", "rule", "log", "letter", "base", "unit", "lc", "nl", "lf", "cl", "lines", "entry", "inline", "LINE", "parse", "message", "ne", "Line", "key", "column", "l", "page", "string", "code", "c", "part", "row", "response", "number", "le", "block", "name", "col", "word", "sel", "ge", "id", "data", "file", "cell", "char", "jo", "header", "str", "sl", "comment", "no", "el", "lin"]}}
{"id1": "8046691", "id2": "13886238", "code1": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 0, "substitutes": {"retrieveFile": ["retireUrl", "retriveUrl", "retireFile", "retrieveUrl", "retrievefile", "RetrievingFiles", "RetrieveUrl", "retriveFiles", "RetrieveFiles", "retrievingfile", "RetrievingFile", "retriveFile", "retrieveFiles", "retrievingUrl", "RetrieveFile", "Retrievingfile", "retirefile", "RetrievingUrl", "Retrievefile", "retrivefile", "retireFiles", "retrievingFile", "retrievingFiles"], "url": ["image", "log", "html", "URL", "base", "resource", "service", "feed", "email", "www", "config", "stream", "download", "Url", "channel", "http", "src", "l", "object", "page", "string", "buffer", "path", "source", "io", "org", "uri", "ur", "loader", "socket", "ssl", "proxy", "server", "host", "file", "gl", "ll", "user", "sl", "contact", "connection", "loc", "location", "address"], "link": ["linked", "model", "skip", "links", "ref", "list", "layer", "block", "name", "file", "call", "light", "comment", "connection", "source", "machine", "lc", "log", "service", "check", "inline", "cache", "add", "local", "slice", "sync", "info", "auto", "style", "code", "build", "pull", "LI", "loader", "user", "error", "loc", "plugin", "base", "Link", "ink", "self", "match", "entry", "parse", "remote", "l", "post", "object", "set", "path", "line", "type", "pack", "low", "data", "lock", "or", "location", "address", "image", "feed", "download", "open", "http", "load", "message", "tail", "route", "li", "uri", "task", "bug", "config"], "httpConn": [" httpLoc", "buildconn", "phpConnection", "transConn", "HttpConfig", "httpLoc", "userConn", "workConnection", " httpCon", "workCon", "httpsConnection", "perConnect", "phpCur", "httpCon", "httpsCon", "httpsConnect", " httpconn", "urlConnection", "urlConn", "httpsConf", "HttpConn", "perConn", "baseCan", " httpCan", "perConf", "transConnect", "serverconn", "userConnection", "buildConnection", "webConnection", "HttpConnection", "buildCmd", "userConnect", "HttpLoc", "webConnect", "perCon", "httpCmd", " httpConnection", "urlCon", " httpConnect", "webconn", "httpconn", "serverMC", "buildCon", "webConfig", "pubConn", "httpConf", "buildConn", "transConnection", "phpCon", "serverConn", "serverConnect", "pubCon", "perconn", " httpMC", "webLoc", "httpsConn", "baseConn", "httpConnect", "baseConnection", " httpCur", "workConn", "phpConnect", "urlConnect", "pubConnection", "phpConn", " httpConf", "HttpMC", "HttpCur", "httpConnection", "baseConf", "HttpConnect", "pubCmd", "perConnection", "transCon", "webConn", " httpCmd", "userConf", "httpMC", "httpsCan", "httpConfig", "httpCan", "workconn", "httpCur", "serverConnection", " httpConfig"], "outs": ["pins", "gets", "ports", "boxes", "its", "in", " out", "locks", "errors", "abs", "utils", "ops", "steps", "flows", "lines", "plugins", "runs", "ls", "bits", "services", "ns", "cache", "rules", "INS", "output", "OUT", "blocks", "bytes", "conn", "ws", "limits", "events", "files", "groups", "again", "works", "io", "lets", "css", "out", "opens", "Out", "ins", "reports", "qs", "cos", "states", "ups", "overs", "bs", "data", "ios", "strings", "timeout", "sets", "results", "fits", "aos", "socket"], "bins": ["pins", "Bins", " bin", "sbouts", " bas", "cbains", "cbouts", "cbas", "Bains", "pints", "bas", " bannels", "bin", "cbins", "bains", "Bints", "pin", "wbas", "bints", "Bin", "bkins", "sbkins", "wbains", "sbins", " bains", "wbouts", " bkins", "sbains", "Bannels", " bints", "wbins", "Bouts", "pannels", "bannels", "Bkins"], "bouts": ["Bins", "bbouts", "Bboxes", "dbout", "Borders", " buss", "bboxes", "wbout", " bgets", "bgets", "Bout", "bbout", "Buss", "bbins", "borders", "dbouts", "wbouts", "dbuss", " bboxes", " borders", "dbboxes", "bout", "bbgets", "wbins", "bborders", "Bouts", "wbgets", " bout", "buss"], "postData": ["ostBody", "ostDATA", "POSTDATA", "Postdata", " postBytes", "POSTBody", "postUrl", "PostData", "readData", "POSTBytes", "readdata", "PostString", "ostData", " postDATA", "postString", "POSTString", " postBody", "postDATA", "postdata", "readUrl", "objectBody", "formBody", "objectData", "objectDATA", "POSTdata", "postBody", "formData", "postBytes", "formdata", "ostdata", "objectBytes", "POSTData", "PostUrl", "formDATA", "POSTUrl", "readString"], "mimePattern": ["Mimespattern", "mIMEModel", "MIMEpattern", "mIMEPattern", "mimesString", "milePattern", "mimeFilter", "mIMEpattern", "Mimepattern", "mimeString", "mimesFilter", "MimeString", "MimesString", "mengeString", "mIMEString", "mimeModel", "mengepattern", "mIMEFilter", "mimesPattern", "MimesFilter", "mengePattern", "MimePattern", "MIMEModel", "mimepattern", "mimespattern", "milepattern", "mengeFilter", "MimeModel", "mileModel", "mimesModel", "MimeFilter", "MimesPattern", "MIMEPattern"], "matcher": [" matche", "patmatch", "mather", "matchers", " matchers", "Matches", "earchers", "earches", "Matcher", "earmatch", " matches", "patcher", "Mather", "patches", "matches", "Matmatch", "earcher", "Matchers", "pather", "matmatch", "matche", "patchers", "Matche", "patche", " mather"], "byteBuffer": [" byteArray", "byteHandler", "ByteBuff", "doubleBuffer", "byteArray", "byteLength", "doubleBuff", "doubleArray", "ByteHandler", " byteHandler", "bitArray", " byteBuff", "ByteLayer", " byteQueue", "byteLayer", " byteLength", " byteLayer", "bitBuff", "doubleQueue", "dataBuffer", "dataLength", "bitBuffer", "ByteBuffer", "bitHandler", "ByteLength", "dataLayer", "ByteArray", "dataBuff", "byteBuff", "byteQueue", "ByteQueue"], "count": ["num", "index", "base", "pool", "child", "depth", "offset", "found", "current", "coll", "val", "match", "group", "cache", "key", "list", "b", "label", "ch", "now", "string", "code", "c", "more", "core", "path", "ind", "type", "part", "allow", "build", "len", "all", "number", "min", "length", "size", "start", "name", "col", "sum", "keep", "low", "id", "file", "weight", "e", "level", "limit", "cond", "call", "i", "Count", "old", "n", "parent", "f", "max"]}}
{"id1": "22235113", "id2": "19113613", "code1": "    protected Object unmarshallXml(final Unmarshaller unmarshaller, final String accessUrl, final String nameSpace, final String replace, final String with) throws Exception {\n        final URL url = new URL(accessUrl);\n        final BufferedReader inputStream = new BufferedReader(new InputStreamReader(url.openStream()));\n        String xmlContent = readWithStringBuffer(inputStream);\n        if (replace != null) {\n            xmlContent = xmlContent.replace(replace, with);\n        }\n        LOGGER.info(\"Calls \" + accessUrl);\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"\\nXml:\" + accessUrl + \"\\n\" + xmlContent);\n        }\n        if (LOGGER.isDebugEnabled()) {\n            final BufferedWriter out = new BufferedWriter(new FileWriter(\"target/XmlAgentLog\" + xmlRequestNumber++ + \".txt\"));\n            out.write(xmlContent);\n            out.close();\n        }\n        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xmlContent.getBytes());\n        Source source;\n        if (nameSpace != null) {\n            source = setNameSpaceOnXmlStream(byteArrayInputStream, nameSpace);\n        } else {\n            source = new StreamSource(byteArrayInputStream);\n        }\n        return unmarshaller.unmarshal(source);\n    }\n", "code2": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"unmarshallXml": ["unmarshalXil", "unmarshallXson", "unmarshalExson", "unmarshallExil", "unmarshallxil", "unmarshalExml", "unmarshallExson", "unmarshalExML", "unmarshallYML", "unmarshallxson", "unmarshallExml", "unmarshallYml", "unmarshalExil", "unmarshallXil", "unmarshallxML", "unmarshallYil", "unmarshalXml", "unmarshallxml", "unmarshalXson", "unmarshallExML", "unmarshallXML", "unmarshallYson", "unmarshalXML"], "unmarshaller": ["unmashalleder", "unmarshaler", "unmashalleders", "unmarshalledor", "unmarshiller", "unmarshillers", "unmarshalor", "unmarshalingers", "unmashaller", "unmockalling", "unmashallor", "unmarshallingers", "unmarshallable", "unmarshalleders", "unmarshalable", "unmarshalinging", "unmarshallor", "unmarshaling", "unmarshillable", "unmarshallers", "unmockallers", "unmashalledable", "unmockallinging", "unmockallingers", "unmarshalleder", "unmashallers", "unmarshalling", "unmarshalledable", "unmarshallinging", "unmashalledor", "unmarshallinger", "unmarshalers", "unmockallinger", "unmarshalinger", "unmockaller", "unmarshillor", "unmashallable"], "accessUrl": ["requestURL", "accessLine", "inputUr", "accessUr", "accessURL", " accessLog", " accessStream", "serviceLink", "requestUrl", "requestPath", "AccessUrl", "serviceUrl", " accessFile", " accessPath", " accessUr", " accessLine", "AccessLog", "accessPath", "accessFile", "requestUr", "requestLog", "execUrl", "inputURL", "AccessStream", "execUr", "inputUrl", "execURL", "requestLink", "requestFile", "AccessURL", "requestLine", "AccessLine", "requestStream", "execFile", " accessURL", "AccessPath", "inputLink", "accessLog", "accessStream", "accessLink", "serviceURL", "serviceUr"], "nameSpace": [" nameSp", "namesspace", " nameFrame", " nameString", "nameFrame", "NamePath", "resourceFrame", "resourcePath", "NameFrame", "nameName", "namesSpace", "nameSp", "Namespace", "NameString", "NameName", "namesName", "namesSp", "resourceSpace", " nameName", " namespace", "namePath", "NameSpace", "namespace", "resourceString", "resourceSp", "resourcespace", "NameSp", "nameString", " namePath"], "replace": ["re", "force", "repeat", "address", "change", "br", "sub", "escape", "prefix", "quote", "section", "fix", "alias", "format", "write", "patch", "over", "match", "find", "parse", "group", "add", "pair", "repl", "use", "space", "update", "string", "fill", "apply", "r", "protect", "store", "flash", "strip", "remove", "join", "align", "be", "settings", "placed", "place", "insert", "same", "where", "see", "name", "places", "operation", "search", "comment", "complete", "get", "like", "tag", "reply", "append", "cover", "save"], "with": [" With", "resource", "other", "before", "prefix", "some", "format", "none", "at", "message", "add", "properties", " without", "around", "style", "flash", "from", "apply", "spec", "params", "tag", "work", "join", "then", "settings", "With", "place", "and", "x", "by", "context", "xml", "name", "search", "id", "include", "layout", "document", "get", "partial", "host", "claim", "plugin", "without"], "url": ["image", "log", "URL", "base", "resource", "service", "feed", "stream", "Url", "channel", "window", "http", "zip", "l", "api", "conn", "page", "string", "buffer", "path", "fl", "uri", "client", "blog", "xml", "socket", "ssl", "server", "host", "file", "ll", "user", "browser", "sl", "rl", "connection", "address"], "inputStream": ["outputstream", "inputBuffer", "inputContent", "inputstream", "xmlStream", "InputReader", "InputSteam", "xmlSteam", " inputContent", "outputReader", " inputSteam", "InputBuffer", "inputSteam", " inputReader", "xmlReader", "InputContent", "inputReader", "outputStream", "InputStream", " inputstream", " inputBuffer", "Inputstream", "outputBuffer"], "xmlContent": ["xmlMessage", "xmlAddress", "phpData", "xmlContents", "eventContents", "broadMessage", "broadDocument", "xmlText", "eventContent", "eventFile", "fileMessage", "jsonReader", " xmlDocument", "txtContent", " xmlMessage", " xmlHeader", "txtContents", "mlData", "txtAddress", "jsonMessage", "xmlHeader", "mlText", "mlContent", "phpContent", "jsonContent", "xmlFile", " xmlString", "broadText", "mlString", "fileString", " xmlText", " xmlFile", "mlFile", "txtFile", "xmlString", "xmlReader", "eventAddress", "phpString", "mlHeader", "mlReader", "jsonHeader", "fileContent", " xmlReader", " xmlData", "xmlDocument", "mlDocument", "broadContent", " xmlAddress", "fileDocument", "xmlData", "phpFile", "mlMessage", " xmlContents"], "out": ["err", "log", "in", "temp", "outer", "prefix", "stream", "flush", "w", "write", "plain", "window", "up", "exp", "group", "cache", "sync", "output", "OUT", "password", "writer", "b", "key", "object", "full", "page", "extra", "builder", "array", "again", "outs", "path", "doc", "io", "result", "response", "Out", "report", "name", "ext", "word", "data", "file", "user", "gen", "ex", "project", "f", "copy"], "xmlRequestNumber": ["httpRequestCounter", "httpRequestNumber", "xmlResponseCounter", "xmlResponsenumber", "httpResponseNum", "xmlVersionNum", "xmlFileCounter", "xmlResponseNum", "xmlRequestNum", "httpRequestnumber", "xmlRequestnumber", "httpResponseCounter", "xmlFileNum", "xmlRequestCounter", "xmlVersionNumber", "xmlFileNumber", "xmlResponseNumber", "xmlVersionCounter", "xmlVersionnumber", "xmlFilenumber", "httpResponsenumber", "httpRequestNum", "httpResponseNumber"], "byteArrayInputStream": ["byteStreamInputstream", "byteStreamInputArray", "byteArrayTextFile", "byteStringInputStream", "byteArrayByteSteam", "byteStreamInputStream", "byteArrayTextStream", "byteStringInputSteam", "byteArrayInputstream", "byteStringOutputstream", "byteStringOutputSteam", "byteArrayReadStream", "byteArrayOutputStyle", "byteArrayOutputStream", "byteArrayOutputstream", "byteStreamOutputStream", "byteStreamOutputArray", "byteStreamInputStyle", "byteArrayBytestream", "byteArrayReadArray", "byteStreamInputFile", "byteArrayTextArray", "byteArrayReadstream", "byteArrayReadSteam", "byteStreamInputSteam", "byteStringOutputStream", "byteArrayInputFile", "byteArrayByteStyle", "byteArrayInputSteam", "byteArrayTextstream", "byteStringInputstream", "byteStreamOutputStyle", "byteArrayReadFile", "byteStreamOutputFile", "byteArrayInputArray", "byteArrayOutputFile", "byteArrayOutputArray", "byteArrayOutputSteam", "byteStreamOutputstream", "byteArrayByteStream", "byteStreamOutputSteam", "byteArrayInputStyle"], "source": ["kin", "rule", "unit", "slave", "model", "service", "resource", "SOURCE", "view", "stream", "Source", "content", "event", "inner", "input", "target", "src", "text", "zip", "slice", "use", "rate", "info", "speed", "object", "scope", "style", "string", "class", "null", "sp", "position", "spec", "session", "g", "core", "node", "plus", "type", "ource", "result", "uri", "scene", "ce", "secure", "size", "proxy", "ge", "wrapper", "component", "data", "id", "str", "sl", "reader", "get", "iter", "connection", "config", "copy"]}}
{"id1": "7809093", "id2": "8417584", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    private String getResultFromHttpUrl(String href) {\n        String result = null;\n        try {\n            URL url = new URL(href);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Object o = conn.getContent();\n            log.debug(\"Opened \" + href + \" and got class \" + o.getClass().getName());\n            StringBuffer version = new StringBuffer();\n            String inputLine;\n            DataInputStream dis = new DataInputStream(conn.getInputStream());\n            while ((inputLine = dis.readLine()) != null) {\n                version.append(inputLine + \"\\n\");\n            }\n            result = version.toString();\n            log.debug(\"Read from URL:\\n\" + result);\n            dis.close();\n        } catch (Exception e) {\n            log.debug(\"Caught exception \" + e + \" whilst attempting to query URL \" + href);\n            e.printStackTrace();\n        } finally {\n            return result;\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["requestContent", "responseOutput", "GetBody", "getOutput", " getEntity", "setContent", " getBody", "requestOutput", "responseContent", "GetContent", "requestEntity", "getData", "responseBody", "GetOutput", "setBody", "setData", "responseEntity", "requestBody", "GetEntity", "getEntity", "getBody", "GetData", " getData", "setEntity"], "request": ["method", "resource", "q", "current", "input", "req", "http", "message", "queue", "object", "QUEST", "application", "string", "r", "position", "route", "path", "query", "handler", "Request", "type", "result", "uri", "xml", "report", "name", "operation", "server", "data", "user", "reference", "e", "instance", "connection", "url", "address"], "sb": ["ib", "wb", "nb", "bsp", "bm", "eb", "zb", "sk", "SB", "ls", "sa", "xb", "src", "amb", "b", "bb", "cb", "sup", "bp", "lp", "usb", "gb", "abb", "buffer", "abi", "fb", "lb", "bf", "bd", "bj", "obb", "su", "sg", "fp", "pb", "bt", "lab", "bs", "binary", "sf", "vm", "rb", "bc", "bh", "bg", "BB", "db", "ab"], "client": ["force", "service", "resource", "current", "Client", "cl", "cli", "project", "net", "channel", "http", "cache", "output", "remote", "api", "bird", "conn", "queue", "application", "builder", "c", "session", "handler", "p", "https", "container", "uri", "console", "ce", "util", "context", "apache", "app", "ssl", "proxy", "tc", "con", "server", "host", "call", "connect", "per", "contact", "default", "connection", "config", "web", "plugin", "url"], "httpParams": ["httpPparams", "HTTPParam", "httpAram", "HTTPPoams", "HTTPPARam", "HTTPPARams", "HttpParparams", "httpParcs", "HTTPPoamer", "httpPerams", "HTTPParams", "httpPams", "HTTPPARcs", "httpParam", "HttpParams", "httpPoams", "httpPrams", "httpPareters", "httpPramer", "httpPeters", "httpPeramas", "httpPARparams", "httpPARums", "HttpParamas", "HTTPPARums", "HTTPParums", "HTTPParparams", "httpArcs", "httpPerparams", "httpPeram", "httpPoparams", "httpArums", "httpParparams", "httpPARams", "httpPoeters", "HTTPParamer", "httpPARcs", "HTTPPoeters", "httpArams", "httpPrparams", "httpPARam", "HTTPPoparams", "HTTPParcs", "httpPamer", "httpParamas", "httpPreters", "httpParums", "httpParamer", "httpPARamas", "httpPoamer", "HttpParam", "HTTPPareters"], "response": ["body", "onse", "model", "resource", "feed", "view", "Response", "json", "http", "message", "output", "api", "respond", "object", "page", "application", "status", "collection", "resp", "relation", "success", "successful", "result", "report", "received", "server", "data", "document", "error", "results", "connection", "reply"], "entity": ["body", "model", "resource", "agent", "coll", "event", "content", "json", "entry", "channel", "http", "output", "api", "media", "conn", "environment", "object", "writer", "application", "element", "pe", "collection", "creator", "node", "translation", "type", "result", "company", "ent", "ce", "xml", "article", "server", "data", "file", "document", "component", "e", "instance", "person", "em", "Entity", "connection", "source", "address"], "reader": ["in", "rx", "feed", "stream", "rer", "inner", "input", "ry", "worker", "parser", "ler", "reading", "rar", "bird", "writer", "read", "ri", "driver", "r", "buffer", "oder", "handler", "er", "io", "rr", "row", "ner", "loader", "server", "ser", "iterator", "Reader", "i", "per", "iter", "source", "editor"], "line": ["link", "lc", "unit", "model", "base", "feed", "end", "content", "val", "lf", "cl", "lines", "entry", "inline", "LINE", "message", "Line", "sync", "key", "l", "page", "string", "code", "definition", "r", "pass", "li", "job", "len", "row", "layer", "ip", "character", "le", "block", "name", "word", "sel", "ge", "data", "id", "user", "cell", "char", "header", "str", "sl", "comment", "el", "no", "iter", "non", "source", "url", "lin"]}}
{"id1": "13421722", "id2": "16092702", "code1": "    public static long getFileSize(String address) {\n        URL url = null;\n        try {\n            url = new URL(address);\n            System.err.println(\"Indirizzo valido - \" + url.toString().substring(0, 10) + \"...\");\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Indirizzo non valido!\");\n        }\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=0-\");\n            connection.connect();\n            return connection.getContentLength();\n        } catch (IOException ioe) {\n            System.err.println(\"I/O error!\");\n            return 0;\n        }\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"getFileSize": ["getByteSize", "getFileLength", "getfileBytes", "getFileInfo", " getfileInfo", " getfileBytes", "getfileInfo", "getFileBytes", " getFileLength", "getByteBytes", " getfileSize", "getfileLength", "getFilesLength", " getfileLength", "getFilesBytes", "getFilesInfo", "getFilesSize", "getByteInfo", "getByteLength", " getFileInfo", "getfileSize", " getFileBytes"], "address": ["base", "email", "resource", "localhost", "offset", "prefix", "point", "content", "format", "target", "message", "output", "object", "string", "code", "array", "position", "route", "path", "source", "type", "attribute", "uri", "addr", "number", "network", "ip", "Address", "size", "name", "location", "report", "request", "server", "data", "reference", "port", "str", "config", "host"], "url": ["image", "log", "html", "URL", "base", "lr", "resource", "www", "feed", "service", "impl", "found", "Url", "channel", "http", "l", "api", "conn", "object", "page", "string", "session", "path", "job", "result", "io", "org", "uri", "build", "client", "bug", "orb", "xml", "ur", "socket", "ssl", "proxy", "loc", "server", "host", "file", "ll", "ob", "e", "user", "str", "sl", "lib", "config", "location", "web", "f"], "connection": ["service", "resource", "section", "current", "event", "to", "function", "open", "entry", "channel", "or", "version", "Connection", "http", "use", "environment", "conn", "info", "object", "application", "c", "position", "condition", "collection", "session", "relation", "handler", "control", "io", "uri", "out", "response", "client", "character", "context", "socket", "communication", "proxy", "request", "con", "wrapper", "server", "reference", "connect", "database", "bc", "connected", "config"]}}
{"id1": "21821404", "id2": "6908537", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    public String login() {\n        System.out.println(\"Logging in to LOLA\");\n        try {\n            String data = URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_email(), \"UTF-8\");\n            data += \"&\" + URLEncoder.encode(\"pw\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_pw(), \"UTF-8\");\n            URL url = new URL(URL_LOLA + FILE_LOGIN);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line, sessid;\n            line = rd.readLine();\n            sessid = get_sessid(line);\n            this.set_session(sessid);\n            wr.close();\n            rd.close();\n            return sessid;\n        } catch (Exception e) {\n            System.out.println(\"Login Error\");\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"getWebPage": ["getVirtualpages", "getVirtualPage", "parseWebpage", "getWebpages", "parsewebpage", "parsewebpages", "getwebpages", "getwebpage", "parseWebpages", "getWebpage", "getVirtualpage", "parsewebPage", "parseWebPage", "getwebPage"], "urlObj": ["URLObj", "blogObject", "urlObject", " urlOb", "strObject", "URLobj", " urlObject", "urlobj", "resourceExt", "URLExt", "UrlObj", "urlExt", "httpobj", " urlExt", "UrlOb", "resourceObject", " urlInst", "httpOb", "strobj", "resourceobj", " urlobj", "httpObj", "strObj", "Urlobj", "blogObj", "blogInst", "urlOb", "blogobj", "resourceObj", "URLObject", "strInst", "urlInst"], "content": ["body", "model", "html", "resource", "Content", "feed", "raw", "section", "cont", "comments", "continue", "coll", "write", "json", "lines", "load", "message", "text", "output", "java", "object", "page", "string", "code", "array", "c", "online", "buffer", "core", "work", "result", "css", "out", "response", "report", "clean", "server", "data", "file", "document", "value", "empty", "comment", "source", "url", "header", "address"], "is": ["its", "in", "site", "isi", "stream", "est", "abs", "ops", "mis", "cms", "nis", "ir", "lis", "does", "problem", "info", "ui", "ires", "IS", "ri", "r", "ise", "you", "ps", "irc", "was", "be", "ie", "ris", "io", "isp", "os", "it", "isl", "x", "isa", "ai", "out", "rest", "fs", "iss", "ip", "ins", "il", "as", "any", "iso", "bis", "es", "us", "ois", "al", "id", "isc", "ser", "ios", "Is", "i", "im", "ais", "or", "ar", "iris", "s"], "reader": ["in", "rx", "stream", "rer", "inner", "worker", "parser", "ler", "reading", "rar", "bird", "l", "writer", " Reader", "read", "ri", "driver", "r", "buffer", "ro", "rc", "oder", "handler", "er", "io", "rr", "x", "row", "director", "actor", "ner", "loader", "h", "server", "e", "ser", "Reader", "i", "iter", "or", "editor"], "line": ["link", "body", "lc", "cle", "section", "lf", "cl", "lines", "entry", "inline", "LINE", "text", "message", "Line", "column", "key", "l", "object", "page", "ine", "string", "code", "buffer", "pass", "item", "strip", "part", "row", "out", "response", "character", "block", "name", "col", "word", " inline", "server", "data", "file", "user", "cell", "char", "str", "comment", "connection", "source", "cr", "f", "url", "lin"]}}
{"id1": "7981642", "id2": "2936678", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"update": ["register", "setup", "address", "create", "change", "send", "login", "end", "check", "write", "edit", "up", "text", "UPDATE", "add", "key", "replace", "password", "post", "set", "updated", "apply", "Update", "push", "build", "and", "insert", "sign", "auth", "init", "sum", "h", "user", "data", "put", "append", "u", "delete", "config", "exec", "url", "copy", "save"], "mail": ["folder", "model", "html", "login", "office", "who", "Email", "view", "ul", "phone", "group", "text", "message", "zip", "local", "password", "label", "string", "mails", "front", "m", "hello", "gmail", "source", "company", "uri", "gal", "ip", "dir", "xml", "name", "proxy", "dial", "ge", "server", "user", "file", "id", "alt", "username", "lock", "value", "Mail", "date", "contact", "fax", "old", "msg", "host", "md", "url", "address"], "email": ["folder", "log", "model", "login", "inet", "office", "Email", "phone", "text", "message", "zip", "nick", "password", "info", "wd", "home", "class", "element", "online", "mails", "ail", "cdn", "li", "note", "en", "gmail", "line", "hello", "uri", "addr", "dir", "ip", "xml", "eu", "name", "archive", "cn", "server", "id", "file", "alt", "dn", "username", "description", "el", "Mail", "old", "fax", "n", "enter", "host", "md", "url", "address"], "pwd": ["Pwt", "Pws", " pws", "ppwh", "Ppass", "pwa", "cpws", "pWD", "Pwa", "cpWD", "pppassword", "Pwh", "Ppassword", "pws", "ppass", "PWD", "ppassword", "hpass", "pwh", "pwt", "hwa", " pwh", " pwa", "hWD", "Pwd", "pppass", "cpwt", " pWD", " pwt", "hwd", "ppwd", " ppass", " ppassword", "cpwd"], "firstname": [" firstkey", "hostName", "hostkey", " firstemail", "lastkey", "firstemail", " firstnames", "firstuser", "caseName", "caseemail", " firstuser", " firstpass", "casename", "hostname", "hostemail", " firstName", "firstName", "newname", "newnames", "casepass", "lastnames", "firstkey", "lastpass", "firstnames", "lastemail", "newuser", "firstpass", "lastuser", "lastName"], "lastname": ["fulln", "lastaddress", "firstday", " lastnames", "secondkey", " lastaddress", " lastkey", "lastkey", "lastday", "firstn", " lastn", "fullnames", "lastn", "fullname", " lastday", "firstName", "lastnames", " lastName", "secondName", "firstkey", "secondaddress", "fullName", "firstnames", "fullday", "firstaddress", "secondname", "lastName"], "connection": ["lc", "index", "graph", "pool", "system", "ion", "this", "function", "nc", "Connection", "ca", "b", "conn", "object", "connected", "management", "application", "c", "cf", "condition", "session", "creator", "relation", "di", "m", "handler", "sc", "response", "client", "cc", "context", "manager", "communication", "con", "h", "server", "document", " Connection", "connect", "Conn", "database", "bc", "config", "db", "directory"], "attrs": ["Attps", " attRS", "Attrs", "atributes", "atars", " attars", " attr", "addras", " attRs", "AttRs", "addks", "matars", "attRS", "addps", "addrs", " attributes", "atacts", "attars", "Attr", "attks", "Attras", "addars", "attributes", "addRs", "attacts", "addr", "attr", "matrs", " attks", "Attars", "atRS", "atr", "attps", " attacts", "atps", "atks", "attRs", "Attacts", "attras", " attps", "addributes", "matps", "atrs", "matributes", "addRS", "Attributes", "atras"], "sha": ["ka", "base", "ga", "lambda", "ema", "ya", "hi", "alias", "ma", "eta", "sa", "mm", "alpha", "ua", "ca", "sche", "shi", "password", "asha", "ami", "SHA", "da", "pi", "wa", "pa", "pg", "si", " SHA", "sh", "sm", "mac", "va", "na", "la", "sum", "a", "volume", "h", "ha", "meta", "acl", "md", "HA"], "digest": ["tagcode", "mdested", "mdgest", "Diggest", "Diged", "diggest", "moded", "DigEST", "tagest", " diggest", "mdest", " digcode", "digester", "Digests", "modest", " digests", "digcode", "Digester", "tagester", "tagested", "modEST", "diged", "digests", "Digested", "Digcode", "mdester", "modests", "digested", "digEST", " digEST", " digested", "Digest", " diged", " digester"], "hash": ["enc", "body", "her", "base", "image", "html", "raw", "hex", "dig", "ag", "json", "match", "version", "message", "key", "password", "bin", "code", "array", "kh", "build", "sh", "rh", "mac", "secret", "block", "ash", "auth", "Hash", "sum", "hed", "h", "ha", "user", "value", "bh", "url", "cover"], "ctx": ["lc", "conv", " context", "cci", "cl", "pc", "ctrl", "anc", "fw", "ca", "cu", " conn", "conn", "cb", " rc", "jp", "c", "cf", "vc", "ct", "rc", " cx", "ci", "ck", "sc", "cmp", "cs", "xc", "client", "cc", "cas", "context", "sq", " cs", " c", "cm", "cp", "tc", "loc", "cn", "cv", "cca", "Context", "qa", "hw", "mc", "tx", "pkg", "bc", "config", "cr"], "newName": ["newEmail", "Newname", "oldAddress", "oldname", " newEmail", "newAddress", " newAddress", "NewName", "NewAddress", "oldEmail", "newname", "NewEmail", " newname"], "oldName": ["OldHome", "newAddress", " oldPath", "oldEmail", "origPath", "OldName", "origName", "origname", "OldAddress", "Oldname", "OldPath", "oldAddress", "oldname", " oldname", "newHome", " oldAddress", "oldPath", "oldHome", "OldEmail", "newEmail", " oldHome", "origEmail", " oldEmail"]}}
{"id1": "16378239", "id2": "21824901", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"byReference": ["ofLink", "ofReference", "orReference", "orExternal", "Byref", "toExternal", "ByExternal", "ofref", "orLink", "toLink", "ofExternal", "ByReference", "orref", "toref", "toReference", "ByLink"], "inputStream": ["outputstream", "inputObject", "tempSteam", "inputstream", "inStream", "inSteam", "InputSteam", "InputFile", "InputReader", "outputSteam", "tempstream", "inReader", "tempReader", "inputFile", "inputSteam", "inputString", " inputObject", "tempStream", "inputReader", "InputObject", "outputStream", "InputStream", "instream", "InputString", "outputString", "outputObject", " inputstream", " inputString", "Inputstream", "outputFile"], "tempFile": ["tmpFiles", "tmpF", "tempfile", " tempfile", " tempContent", "tempF", "fakeF", " tempPage", "Tempfile", "tempContent", "tmpfile", " tempF", "tempDir", "tmpContent", "tmpDir", " tempStream", "tmpFile", "fakeStream", "tempFiles", "tempPage", "TempFile", "fakePage", "fakeDir", " tempDir", " tempFiles", "tempStream", "fakeFile", "TempContent", "fakeFiles", "fakefile", "tmpStream", "TempFiles", "tmpPage"], "out": ["err", "image", "base", "in", "o", "temp", "resource", "pool", "outer", "this", "flush", "to", "write", "plain", " in", "sync", "output", "OUT", "later", "writer", "conn", "object", "extra", "url", "null", "array", "again", "outs", "path", "line", "part", "io", "result", "Out", "client", "init", "ext", "a", "server", "data", "file", "user", "instance", "ex", "connection", "source", "exec", "f", "obj", "copy"]}}
{"id1": "1985677", "id2": "8788371", "code1": "    public SRWGuiClient(String initialURL) {\n        super(\"Simple Swing Browser\");\n        this.initialURL = initialURL;\n        addWindowListener(new ExitListener());\n        WindowUtilities.setNativeLookAndFeel();\n        JPanel topPanel = new JPanel();\n        topPanel.setBackground(Color.lightGray);\n        homeButton = new JIconButton(\"home.gif\");\n        homeButton.addActionListener(this);\n        JLabel urlLabel = new JLabel(\"URL:\");\n        urlField = new JTextField(30);\n        urlField.setText(initialURL);\n        urlField.addActionListener(this);\n        topPanel.add(homeButton);\n        topPanel.add(urlLabel);\n        topPanel.add(urlField);\n        getContentPane().add(topPanel, BorderLayout.NORTH);\n        try {\n            URL url = new URL(initialURL);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            boolean xml = true;\n            String inputLine;\n            StringBuffer content = new StringBuffer(), stylesheet = null;\n            Transformer transformer = null;\n            inputLine = in.readLine();\n            if (inputLine == null) {\n                System.out.println(\"No input read from URL: \" + initialURL);\n                return;\n            }\n            if (!inputLine.startsWith(\"<?xml \")) {\n                xml = false;\n                content.append(inputLine);\n            }\n            if (xml) {\n                inputLine = in.readLine();\n                if (inputLine.startsWith(\"<?xml-stylesheet \")) {\n                    int offset = inputLine.indexOf(\"href=\");\n                    String href = (inputLine.substring(inputLine.indexOf(\"href=\") + 6));\n                    href = href.substring(0, href.indexOf('\"'));\n                    System.out.println(\"href=\" + href);\n                    url = new URL(url, href);\n                    String stylesheetURL = url.toString();\n                    System.out.println(\"stylesheet URL=\" + url.toString());\n                    transformer = (Transformer) transformers.get(stylesheetURL);\n                    if (transformer == null) {\n                        BufferedReader sheetIn = new BufferedReader(new InputStreamReader(url.openStream()));\n                        sheetIn.readLine();\n                        stylesheet = new StringBuffer();\n                        while ((inputLine = sheetIn.readLine()) != null) stylesheet.append(inputLine).append('\\n');\n                        System.out.println(stylesheet.toString());\n                        TransformerFactory tFactory = TransformerFactory.newInstance();\n                        StreamSource xslSource = new StreamSource(new StringReader(stylesheet.toString()));\n                        transformer = tFactory.newTransformer(xslSource);\n                        transformers.put(stylesheetURL, transformer);\n                    }\n                }\n            }\n            while ((inputLine = in.readLine()) != null) content.append(inputLine).append('\\n');\n            htmlPane = new JEditorPane();\n            if (transformer != null) {\n                StringReader stringRecordReader = new StringReader(content.toString());\n                StringWriter xmlRecordWriter = new StringWriter();\n                StreamSource streamXMLRecord = new StreamSource(stringRecordReader);\n                transformer.transform(streamXMLRecord, new StreamResult(xmlRecordWriter));\n                String html = xmlRecordWriter.toString();\n                int i = html.indexOf('>');\n                html = \"<html>\" + html.substring(html.indexOf('>') + 1);\n                System.out.println(html);\n                htmlPane.setContentType(\"text/html\");\n                htmlPane.setText(\"<html><head><META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"><title>GSAFD Thesaurus</title></head><body><center><h2>GSAFD Thesaurus</h2></center><p>A thesaurus of genre terms to support the \\\"Guidelines on Subject Access to Individual Works of Fiction , Drama\\\" (GSAFD)</p><table cellspacing=\\\"5\\\" width=\\\"100%\\\"><tr><td><h3>Search</h3><p></p></td><td valign=\\\"top\\\"><h3>Browse</h3></td></tr></table></body></html>\");\n            } else htmlPane.setText(content.toString());\n            htmlPane.setEditable(false);\n            htmlPane.addHyperlinkListener(this);\n            JScrollPane scrollPane = new JScrollPane(htmlPane);\n            getContentPane().add(scrollPane, BorderLayout.CENTER);\n        } catch (IOException ioe) {\n            warnUser(\"Can't build HTML pane for \" + initialURL + \": \" + ioe);\n        } catch (TransformerException e) {\n        }\n        Dimension screenSize = getToolkit().getScreenSize();\n        int width = screenSize.width * 8 / 10;\n        int height = screenSize.height * 8 / 10;\n        setBounds(width / 8, height / 8, width, height);\n        setVisible(true);\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"initialURL": ["InitialURL", "maximumUrl", "InitialHTML", "originalUrl", " initialUR", "newSSL", "currentUR", "originalUR", "currentSSL", "InitialUR", "InitialUrl", " initialSSL", " initialHTML", "currentURL", "initialURI", "currentURI", "newURL", "newURI", "initialHTML", " initialUrl", "initialUR", "currentUrl", "maximumURI", "newUrl", "originalHTML", "originalURL", "InitialURI", "initialUrl", "maximumUR", "maximumURL", " initialURI", "initialSSL", "newUR", "InitialSSL"], "topPanel": ["topLabel", "bottomMenu", "TopButton", "TopPool", "topColumn", "topProvider", " topPool", "TopProvider", "firstProvider", " topBar", " topButton", "topContainer", " topMenu", " toppanel", "homeContainer", "TopBar", "topButton", "TopLabel", " topLabel", "firstpanel", "Toppanel", "TopColumn", " topProvider", "bottompanel", "homePool", "bottomLabel", "TopPanel", "bottomPanel", "topPool", "bottomColumn", "homeLabel", "firstPanel", " topContainer", "TopContainer", "TopMenu", "topMenu", "firstButton", "topBar", "bottomButton", "toppanel", "homeBar", "homePanel", " topColumn"], "homeButton": ["projectButton", " homeField", "HomeLink", "backButton", "HomeField", "backField", "backPanel", "projectLabel", " homeLink", "backLabel", "homeLink", "urlPanel", "HomeButton", "urlButton", "homeLabel", "projectLink", " homeLabel", "projectPanel", "HomePanel", " homePanel", "HomeLabel", "homeField", "homePanel"], "urlLabel": [" urllabel", " urlButton", "pageField", "homelabel", "imageLabel", "pageLabel", "pageButton", "webField", "pageLink", "homeLink", "urlButton", "webButton", "webLink", "homeLabel", "imagelabel", "urllabel", "imageButton", "imageField", "urlLink", "homeField", "webLabel"], "urlField": [" urlButton", "textLabel", "UrlLayer", "userField", "resourceLabel", "textPanel", "imageLabel", "urlTab", "userLabel", " urlLayer", " urlPanel", "resourceLayer", "UrlLabel", "userButton", "imageLayer", "UrlPanel", "UrlTab", "resourceButton", "urlPanel", "textLayer", "urlLayer", "textButton", "urlButton", "homeLabel", "imageButton", "addressLabel", "resourcePanel", "textField", "addressField", "userPanel", "imageField", " urlTab", "UrlField", "homeField", "addressLayer", "resourceField", "homePanel", "resourceTab"], "url": ["image", "link", "log", "URL", "base", "resource", "feed", "www", "fr", "service", "impl", "stream", "ul", "input", "Url", "download", "json", "cl", "channel", "ref", "http", "src", "text", "l", "bb", "api", "err", "page", "string", "bel", "buffer", "path", "fl", "rel", "org", "uri", "out", "pull", "layer", "ur", "socket", "location", "ssl", "search", "server", "data", "file", "ll", "user", "host", "document", "gl", "loc", "el", "sl", "rl", "connection", "config", "source", "f", "address"], "in": ["ini", "image", "err", "resource", "login", "serv", "stream", "inner", "inn", "input", "din", "In", "load", "l", "b", "bin", "c", "r", "IN", "from", "buffer", "again", "path", "er", "source", "line", "part", "io", "it", "out", "ins", "socket", "init", "ssl", "data", "file", "lock", "str", "reader", "connection", "inc", "f", "lin", "s"], "inputLine": ["httpline", "outputBlock", "Inputline", "InputPage", "execline", " inputCell", "imageLine", "emptyline", "InputFile", "outputline", "entityLine", "emptyLine", " inputPage", "requestL", "execLine", "inputL", "inputLINE", "requestline", "rawFile", "execLin", "InputLine", " inputPass", "execL", "inputCell", "searchline", "searchLine", "requestCell", "imageLink", "InputLink", " inputLink", "outputLine", "requestLink", "requestLine", "inputPass", "inputBlock", "execFile", "searchPage", "outputFile", "entityline", "emptyFile", "searchLINE", " inputLINE", "requestPage", "inputline", "inputLin", "submitLin", "httpL", "inputFile", "inputPage", " inputFile", "imageFile", "httpLine", "requestLINE", "httpCell", "submitPass", "submitLine", "execLink", " inputL", "InputBlock", "InputLINE", " inputLin", "emptyLINE", "submitL", "rawLine", " inputline", " inputBlock", "rawPage", "inputLink", "rawline", "imageline", "execPass", "entityL"], "content": ["image", "resources", "body", "resource", "Content", "feed", "child", "input", "json", "text", "message", "load", "output", "media", "full", "page", "style", "string", "code", "status", "buffer", "path", "result", "container", "response", "context", "data", "document", "value", "comment", "config", "source", "parent"], "stylesheet": ["stylesource", "styleheet", " styleshett", " stylesafe", " Stylesource", "styleshett", "styleafe", " Stylesafe", " Styleshett", " stylesource", " Stylesheet", "stylehett", "stylesafe", "styleource"], "transformer": ["perform", "peractor", "tralator", "Transformation", "performer", "butformer", "toolformer", "transform", "toolporter", "transformation", "Transactor", "handformation", " transformation", "transiter", "butiter", " transactor", "transactor", "Translator", "Transformer", "Transform", "tooliter", "transporter", "handformer", "toolformation", "handform", " translator", "traformer", "butporter", "traactor", "performation", "Transporter", "translator", "Transiter", "butformation", "handactor", "traformation"], "xml": ["image", "pic", "log", "mail", "model", "expl", "www", "feed", "stream", "event", "format", "audio", "write", "json", "cgi", "parse", "http", "text", "zip", "ir", "xf", "output", "github", "full", "auto", "print", "string", "txt", "cloud", "doc", "wrap", "ml", "wire", "x", "layer", "close", "ssl", "request", "id", "file", "document", "binary", "php", "rss", "println", "complete", "fake", "empty", "complex", "python", "header"], "offset": ["num", "o", "et", "skip", "Offset", "ref", "count", " offsets", "auto", "left", "style", "set", "pos", "align", "shift", "ptr", "uri", " off", "len", "addr", "attr", "off", "start", " num", "data", "error", "loc"], "href": ["image", "link", "URL", "base", "resource", "www", "br", "alias", "iri", "format", "download", "json", "target", "facebook", "blank", "ref", "src", "http", "text", "filename", "area", "string", "hash", "route", "path", "type", "source", "result", "https", "rel", "uri", "css", "dest", "attr", "gif", "img", "missing", "hr", "title", "ssl", "archive", "loc", "ha", "id", "reference", "data", "alt", "absolute", "af", "value", "rss", "meta", "location", "header"], "stylesheetURL": [" stylesetUR", " stylesheetURI", "stylesetSSL", "stylescheURL", "worksheetURL", "stylesfileUR", "stylesheetURI", "worksfileUR", "styleshettUR", "worksheetUR", "stylesheetUR", "stylesfileURI", "stylespaceURL", "stylessheetURI", "worksfileUrl", "stylesetURI", " stylesetURI", "stylessheetUR", "worksfileURL", "worksheetURI", "stylespaceUR", "stylespaceURI", "worksheetUrl", "stylesfileURL", "styleshettURL", "stylessheetSSL", "stylesetUR", "styleshettURI", "stylesheetSSL", " stylesetSSL", " stylesetURL", "stylespaceUrl", " stylesheetSSL", "stylesheetUrl", "stylesetURL", "stylesfileUrl", "worksfileURI", "stylessheetURL", "styleshettSSL", "stylescheUR", "stylescheURI", " stylesheetUR", "stylescheUrl"], "sheetIn": ["sheetReader", "bookAs", " sheetsOut", "sheetOut", " sheetsIn", " sheetReader", " sheetOut", " sheetsAs", "sheetAs", " sheetsReader", " sheetAs", "bookIn", "bookReader", "bookOut"]}}
{"id1": "21491791", "id2": "7499186", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"run": ["unit", "log", "create", "func", "worker", "process", "code", "apply", "running", "fork", "work", "job", "build", "all", "loop", "command", "start", "app", "spawn", "test", "runner", "call", "Run", "execute", "exec", "invoke"], "input": ["image", "flow", "index", "in", "resource", "raw", "feed", "storage", "view", "stream", "inner", "form", "audio", "Input", "worker", "active", "entry", "up", "text", "reading", "parser", "conn", "read", "driver", "initial", "state", "readable", "work", "control", "io", "out", "client", "context", "loader", "internal", "request", "data", "file", "user", "iterator", "instance", "connection", "config", "source", "address"], "output": ["writing", "image", "letter", "log", "written", "unit", "generated", "resource", "index", "temp", "outer", "end", "office", "write", "target", "text", "cache", "filename", "queue", "later", "environment", "object", "page", "application", "exit", "path", "job", "writers", "control", "console", "out", "response", "network", "Writer", "operation", "Output", "file", "data", "document", "user", "put", "web", "connection", "config", "source", "parent"], "reader": ["image", "slave", "in", "resource", "system", "view", "stream", "rer", "inner", "audio", "entry", "worker", "parser", "reading", "read", "driver", "builder", "ri", "r", "oder", "handler", "er", "author", "io", "row", "client", "context", "ner", "manager", "riter", "loader", "request", "peer", "wrapper", "server", "Reader", "source", "book", "owner", "rator"], "writer": ["writing", "her", "written", "wb", "outer", "office", "inner", "w", "write", "player", "wan", "entry", "worker", "wer", "ws", "engine", "builder", "driver", "ew", "r", "creator", "wa", "wr", "work", "er", "writers", "author", "wire", "nw", "out", "ner", "manager", "riter", "Writer", "word", "request", "ter", "wrapper", "data", "war", "maker", "rw", "writ", "or", "connection", "editor"], "pump": ["pamp", "prump", "Pumper", "camp", "ppump", "Pump", "dmp", "pdump", "ppumps", "humper", "dumps", "prdump", "pram", "Pdump", " pumping", " pam", "mump", "Pam", "prumper", "Pmp", " pmp", "Pumps", "hprint", " pamp", " pdump", "cumper", "pam", "Pprint", "Pumping", "pumping", "hump", "cump", "pumper", "dump", "pmp", "Pamp", "mprint", "ppumping", "mumps", " pumps", " pumper", "ppumper", "mumper", "pumps", "cumping", "humps", "pprint", "dumper"], "counter": ["num", "repeat", "index", "ver", "lr", "outer", "walker", "offset", "continue", "current", "inner", "step", "sequence", "order", "meter", "ener", "entry", "worker", "inter", "consumer", "version", "master", "count", "ger", "now", "race", "page", "builder", "code", "clock", "starter", "r", "collection", "rew", "author", "er", "hello", "Counter", "result", "pointer", "progress", "currency", "number", "row", "loop", "layer", "ner", "cookie", "loader", "trace", "ception", "runner", "keep", "ter", "server", "seed", "const", "instance", "second", "keeper", "center", "timer", "zero", "comment", "enter", "parent", "url", "processor"], "buffer": ["base", "resource", "entry", "channel", "text", "message", "queue", "uf", "page", "buf", "position", "buff", "uffer", "layer", "length", "loader", "server", "data", "file", "document", "reference", "port", "limit", "binary", "iter", "batch", "source", "Buffer", "url", "header", "address"], "off": ["flow", "o", "offs", "end", "offset", "of", "inner", "art", "head", "open", "ff", "Offset", "offer", "ref", "less", "area", "info", "ui", "now", "auto", "left", "set", "ord", "pos", "OFF", "fail", "opt", "addr", "out", "own", "start", "low", "on", "down", "oa", "unknown", "Off", "eno"], "len": ["body", "log", "lc", "in", "end", "lit", "val", "lf", "fin", "lan", "ref", "count", "ler", "lon", "den", "l", "bin", "ld", "pos", "fd", "li", "fl", "en", "line", "Len", "width", "lim", "all", "elt", "layer", "length", "size", "name", "ln", "on", "ll", "lt", "gen", "limit", "lock", "el", "n", "lib", "loc", "url", "lin"], "rd": ["dd", "nd", "dr", "lr", "fr", "rx", "ud", "val", "rid", "xd", "rt", "RD", "RR", "adr", "ld", " prod", " r", "rod", "ord", "rf", "r", "rc", "fd", "d", "ind", "db", "rob", "ds", "rand", "red", "rr", "nr", "rh", "raid", "ra", "rs", "hr", "rn", "rm", "rss", "rb", "rw", "rl", "ru", "cr", "dra"]}}
{"id1": "21010945", "id2": "16825994", "code1": "    private static List runITQLQuery(String itqlQuery) throws Exception {\n        String escapedItqlQuery = URLEncoder.encode(itqlQuery, \"UTF-8\");\n        String url = \"http://\" + Config.getProperty(\"FEDORA_SOAP_HOST\") + \":\" + Config.getProperty(\"FEDORA_SOAP_ACCESS_PORT\") + \"/fedora/risearch?type=tuples\" + \"&lang=iTQL\" + \"&format=CSV\" + \"&distinct=on\" + \"&stream=on\" + \"&query=\" + escapedItqlQuery;\n        logger.debug(\"url for risearch query: \" + url);\n        URL urlObject = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) urlObject.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        logger.debug(\"response code: \" + con.getResponseCode());\n        if (con.getResponseCode() != 200 && con.getResponseCode() != 302) {\n            throw new FedoraAccessException(\"Could not access the risearch service at url: \" + url);\n        }\n        ArrayList arrayList = new ArrayList();\n        String inputLine;\n        int counter = 0;\n        while ((inputLine = br.readLine()) != null) {\n            logger.debug(\"reading line:\" + inputLine);\n            if (inputLine.indexOf(\"<html>\") >= 0) {\n                logger.error(\"problem quering the relationship\");\n                throw new Exception(\"Problem querying relationships; probably a bad ITQL query:\" + itqlQuery);\n            }\n            if (counter >= 1 && inputLine.indexOf(\"/\") >= 0 && inputLine.trim().length() > 0) {\n                logger.debug(\"adding line:\" + inputLine);\n                inputLine = inputLine.substring(inputLine.indexOf(\"/\") + 1);\n                arrayList.add(inputLine);\n                logger.debug(\"found relationship to item: \" + inputLine);\n            }\n            counter++;\n        }\n        br.close();\n        logger.debug(\"num relationships found: \" + arrayList.size());\n        return arrayList;\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"runITQLQuery": ["runITqlQuery", "runItqlQuery", "runITqlRequest", "runITQquery", "runItqlRequest", "runITSQLRequest", "runITQQuery", "runITSQLQuery", "runITQString", "runITqlString", "runItQLString", "runITQRequest", "runITSQLString", "runItqlString", "runITQLRequest", "runItQLquery", "runItQLRequest", "runITSQLquery", "runItqlquery", "runITqlquery", "runITQLString", "runItQLQuery", "runITQLquery"], "itqlQuery": ["pitqlString", "pitqlQuery", "ItsqlStatement", "ItsqlRequest", "itqlStatement", "itqlString", "pitSQLquery", "ItqlCommand", "itSQLquery", "itqlCommand", "itSQLQu", "ItsqlQuery", "itsqlRequest", "itQLStatement", "itQLquery", "itwlCommand", "ItqlQuery", "itQLQu", "itqlquery", "itQLQuery", "pitSQLString", "itqlQu", "ItqlRequest", "itsqlStatement", "pitqlquery", "itwlRequest", "itSQLStatement", "itwlquery", "ItsqlCommand", "Itqlquery", "itQLString", "Itsqlquery", "itsqlCommand", "ItsqlString", "itQLCommand", "itqlRequest", "itsqlquery", "itsqlString", "pitSQLQu", "ItqlString", "itQLRequest", "itSQLString", "pitqlQu", "itsqlQu", "pitSQLQuery", "ItqlStatement", "itSQLQuery", "itwlQuery", "itsqlQuery"], "escapedItqlQuery": ["escapedItqQuery", "escapedItqString", "escapedItqlRequest", "escapedITqlQuery", "escapeditqlRequest", "escapedItsqlQuery", "escapedITsqlRequest", "escapedItqlString", "escapeditQLquery", "escapedItQLQu", "escapedItsqlQu", "escapedItqRequest", "escapeditqlquery", "escapedItsqlRequest", "escapeditqlQuery", "escapeditQLRequest", "escapeditqlString", "escapedItsqlString", "escapedItQLQuery", "escapedITsqlQu", "escapedItQLquery", "escapedITsqlQuery", "escapedITqlQu", "escapedItqlQu", "escapedItqQu", "escapeditQLString", "escapedItQLString", "escapedITqlRequest", "escapedItsqlquery", "escapedITsqlquery", "escapedItqlquery", "escapedITqlquery", "escapeditQLQuery", "escapedItQLRequest", "escapedItqquery"], "url": ["rule", "image", "method", "html", "URL", "service", "resource", "base", "email", "lr", "www", "feed", "impl", "q", "coll", "download", "Url", "pattern", "obj", "http", "href", "l", "page", "string", " URL", "route", "buffer", "path", "large", "org", "uri", "build", "response", "xml", "ur", "name", "location", "ssl", "request", "loc", "server", "id", "file", "ll", "lc", "el", "sl", "rl", "connection", "config", "host", "f", "address"], "urlObject": ["urlObj", " urlOb", " urlNumber", "urlNumber", "URLobject", "urlobject", "UrlNumber", " urlObj", "httpURL", "UrlObj", "urlURL", "UrlOb", "UrlObject", "Urlobject", " urlobject", "httpNumber", "httpObj", "UrlURL", "urlOb", " urlURL", "URLObject", "httpObject", "URLOb"], "con": ["enc", "dec", "ver", "conv", "sub", "func", "can", "fac", "syn", "coll", "inner", "cl", "cons", "nc", "pc", "open", "ctrl", "Connection", " conn", "fc", "http", "exec", "ch", "conn", "un", " CON", "CON", "ran", "c", "cf", "ct", "rc", "core", "en", "part", "min", "xc", "client", "Con", "close", "cm", "co", " connection", "bn", "acon", "cn", "ec", "ocon", "connect", "Conn", "res", "bc", "Connect", "connection", "uc", "inc", "cr", "conf", "obj", "non"], "br": ["err", "ver", "dr", "lr", "fr", " reader", "fac", "stream", "form", "bl", "arr", "fin", "http", "cro", "output", "bridge", "ch", "b", "ctr", "conn", "buf", "r", "buffer", "gr", "rc", "tr", "bro", "er", "p", "result", "io", "Br", "BR", "mr", "response", "hr", "cm", "bar", "sr", "runner", "fore", "data", "ob", "browser", "str", "Reader", "reader", "rb", "res", "bc", "bh", "grab", "cr", "obj"], "arrayList": ["inputArray", "arrayClient", "areaList", "elementTree", "arrayTree", "inputGroup", "inputList", "areaChain", "elementChain", "areaClient", "arrayChain", " arrayClient", "inputClient", " arrayTree", "elementArray", "arrayGroup", " arrayGroup", "areaTree", " arrayArray", "arrayArray", " arrayChain", "elementList", "areaArray", "areaGroup"], "inputLine": ["outputPage", "Inputline", "InputPage", "currentFile", "imageLine", "issueLINE", "imageLINE", "InputFile", "outputline", "inL", "workFile", " inputPage", "InputLu", "interfaceLu", "rawL", "inputString", "inputL", "inputLINE", "workLine", "interfaceFile", " inputList", "inLine", " inputString", "qaL", "InputLine", "inputLetter", "interfaceLine", "uploadline", "qaFile", "inline", "inFile", "qaLine", "InputL", "uploadLine", "imageLin", "imageBlock", "imageList", "outputLine", "currentline", "inputBlock", "imageL", "issueList", "interfaceline", "currentL", "workline", "inputDir", "inputLu", " inputLu", " inputLINE", "inputline", "inputLin", "qaLetter", "inputFile", "inputPage", " inputFile", "InputDir", "uploadPage", "rawLin", "outputLin", "inputList", "issueBlock", " inputDir", " inputL", "imageDir", "InputBlock", " inputLin", "InputLetter", "currentBlock", "rawLine", " inputline", " inputBlock", " inputLetter", "currentString", "InputString", "rawBlock", "rawPage", "rawline", "currentLine", "imageline", "uploadLin", "issueLine"], "counter": ["lc", "num", "repeat", "index", "ver", "field", "child", "outer", "offset", "continue", "inner", "stop", "step", "function", "pattern", "cur", "entry", "inter", "ctrl", "count", "cre", "cache", "stack", "key", "info", "ctr", "race", "page", "code", "c", "handler", "rew", "type", "Counter", "result", "cmp", "currency", "number", "nr", "loop", "controller", "loader", "trace", "name", "sum", "ter", "server", "instance", "second", "i", "center", "default", "time", "parent", "cover", "processor"]}}
{"id1": "10759917", "id2": "9824814", "code1": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    public void run() {\n        if (status == COMPLETE) {\n            return;\n        }\n        waitRandom();\n        RandomAccessFile file = null;\n        InputStream inputStream = null;\n        boolean success = false;\n        URL url = null;\n        try {\n            BeatportAccessor beatportAccessor = new BeatportAccessor();\n            if (sessionCookies == null) {\n                sessionCookies = beatportAccessor.getSessionCookies(user, password);\n            }\n            url = new URL(new BeatportAccessor().getTrackDownloadUrl(downloadId, sessionCookies));\n            log.info(\"Open (DownloadWorker.run): \" + url);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", BeatportAccessor.userAgent);\n            connection.setRequestProperty(\"Cookie\", sessionCookies);\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                log.error(\"Unexpected response from server: \" + connection.getResponseCode());\n                error();\n                return;\n            }\n            if (connection.getContentType().indexOf(\"text\") >= 0) {\n                log.error(\"Tried to request: \" + url.toString());\n                log.error(\"Unexpected file content type from server: \" + connection.getContentType());\n                log.error(\"Server replied:\\n\" + getContentAsString(connection));\n                error();\n                return;\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                log.error(\"Invalid content length: \" + connection.getContentLength());\n                error();\n                return;\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            } else if (size != contentLength) {\n                changeTotal(0, contentLength - size);\n            }\n            if (new File(tmpFileName(fileName)).exists()) {\n                if (!new File(tmpFileName(fileName)).delete()) {\n                    throw new Exception(\"Could not delete file: \" + tmpFileName(fileName));\n                }\n            }\n            file = new RandomAccessFile(tmpFileName(fileName), \"rw\");\n            file.seek(downloaded);\n            inputStream = connection.getInputStream();\n            if (started == 0) {\n                started = System.currentTimeMillis();\n                time = started;\n            }\n            statusChangedObserver.statusChanged(status);\n            byte buffer[] = new byte[MAX_BUFFER_SIZE];\n            while (status == DOWNLOADING) {\n                if (size - downloaded < MAX_BUFFER_SIZE) {\n                    buffer = new byte[(int) (size - downloaded)];\n                }\n                int read = inputStream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                changeTotal(read, 0);\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                stopped = System.currentTimeMillis();\n                status = COMPLETE;\n            }\n            statusChangedObserver.statusChanged(status);\n            stateChanged();\n            success = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            error();\n        } finally {\n            try {\n                file.close();\n            } catch (Exception e) {\n            }\n            if (success) {\n                try {\n                    if (!new File(tmpFileName(fileName)).renameTo(new File(fileName))) {\n                        throw new Exception(\"Rename Failed\");\n                    }\n                } catch (Exception e) {\n                    log.error(\"Error moving temp file \" + tmpFileName(fileName) + \" file: \" + fileName, e);\n                }\n            } else {\n                try {\n                    new File(tmpFileName(fileName)).delete();\n                } catch (Exception e) {\n                    log.error(\"Error deleting erroneous temp file: \" + tmpFileName(fileName), e);\n                }\n            }\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                log.error(\"Error closing input stream of: \" + url + \" / \" + fileName, e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"delete": ["link", "de", "register", "create", "del", "flush", "write", "load", "sync", " deleting", "post", "update", " deletion", " Delete", "drop", "remove", "dump", "execute", "id", " destroy", "Delete", "database", "get", "connection", "destroy", "exec", "save"], "name": ["link", "action", "model", "base", "resource", "create", "NAME", "prefix", "alias", "none", "active", "version", "filename", "key", "label", "table", "info", "now", "object", "space", "style", "string", "class", "ame", "null", "code", "definition", "pass", "path", "Name", "type", "part", "named", "client", "size", "missing", "word", "id", "data", "on", "true", "e", "false", "names", "no", "comment", "old", "database", "n", "value", "default", "time", "like", "one", "parent", "url", "address"], "CannotDeleteSystemLinkException": ["CannotDeleteSysLinkception", "CannotDeleteSystemLinkError", "CannotDeleteSysLinkException", "CannotDeleteClassLinkInformation", "CannotDeleteSystemLinksException", "CannotDeleteSystemLinksInformation", "CannotDeleteSysLinkError", "CannotDeleteSystemRelception", "CannotDeleteSystemReferenceception", "CannotDeleteSystemlinkception", "CannotDeleteSystemLinkApplication", "CannotDeleteSystemlinkException", "CannotDeleteClassLinkException", "CannotDeleteSystemLinksception", "CannotDeleteSystemRelException", "CannotDeleteSystemLinkception", "CannotDeleteClassLinkception", "CannotDeleteSystemLinksApplication", "CannotDeleteSystemReferenceException", "CannotDeleteSystemlinkApplication", "CannotDeleteSystemReferenceError", "CannotDeleteSystemLinkInformation", "CannotDeleteSysLinkEx", "CannotDeleteSystemRelEx", "CannotDeleteSystemLinkEx", "CannotDeleteSystemReferenceEx", "CannotDeleteSystemRelError", "CannotDeleteClassLinkApplication", "CannotDeleteSystemlinkInformation"], "ClassLinkTypeNotFoundException": ["ClassLinkTypeNotfoundException", "ClassLinkTypeNotFoundError", "ClassLinkTypeNotSourceRequest", "ClassLinkTypeNotfoundError", "ClassLinkTypeNotFoundRequest", "ClassLinkTypeNotSourceException", "ClassLinkTypeNotSourceError", "ClassLinkTypeNotfoundRequest"], "conn": ["enc", "ou", "lc", "ver", "nt", "config", "serv", "coll", "dc", "po", "cli", "oci", "nc", "pc", "cur", "open", "rt", "Connection", "ns", "cache", "ca", "exec", "sync", "ch", "bb", "cat", "ann", "pr", "cb", "c", "act", "session", "ct", "orp", "core", "query", "ci", "p", "conf", "org", "oss", "client", "cc", "util", "pub", "close", "cm", "ssl", "ac", "co", "con", "h", "cn", "server", "ec", "ob", "dn", "cond", "connect", "lock", "mc", "Conn", "error", "n", "ctx", "cp", "connection", "loc", "uc", "db", "pg"], "stmt": ["stob", "Stdt", " stmm", "ctmd", "stlt", "strsql", "Stmm", "Stmt", "estmt", "istdt", "strmd", "Stmn", "rdmt", "rdsql", "ctmt", "sthmt", "stmp", "rddd", "sthmd", "Stdb", "stmd", "STsql", " stsql", "Stnt", "stsql", "playdt", "Stmp", "estlt", "sthdb", " stmn", "stnt", "stmn", "sthmn", "strlt", "playmt", "STlt", " stob", "estdd", " stmd", "stmm", "strnt", " stdd", "Stmd", "Stob", "stdd", "estsql", " stmb", "strmp", "stm", " stmp", "strmm", "strmt", "rdmd", "istmt", "istmd", "strmb", "strob", "STdd", "ctmb", "strdd", " stnt", "Stm", " stm", "stdt", "istnt", "stmb", " stdb", "stdb", "playnt", "playmd", "Stmb", "ctm", "STmt", "strm"], "prepTable": ["supable", "Preptable", "prepType", "initTable", "inittable", " prepCol", "PrepType", " prepable", "parCol", "partable", "prepable", "PrepTable", "prepCol", "initType", "supTable", "preptable", "Prepable", " preptable", "supType", "parType", " prepType", "suptable", "initCol", "parTable"], "objectLinkTable": ["objLinkStore", "objectLinkFile", "objlinkTable", "objectlinkTable", "objectLineTable", "objectLinkType", "ObjectLinkFile", "objectTypeFile", "objectlinkTab", "objectLineSource", "objLinkType", "objectlinkFile", "objectlinkSource", "objLinkChain", "objectRelStore", "objectlinkChain", "objectLinkChain", "ObjectLineTable", "ObjectLinkTab", "objectRelType", "objectSyncStore", "objectlinkType", "objectSyncChain", "objectLinkStore", "objlinkStore", "objectSyncType", "objectLineTab", "objectlinkStore", "objlinkType", "objectTypeSource", "objectLinkSource", "objlinkChain", "ObjectLineTab", "ObjectLinkTable", "objectTypeTab", "objectRelChain", "objectTypeTable", "objectLinkTab", "ObjectLineSource", "objectRelTable", "ObjectLineFile", "objLinkTable", "objectLineFile", "objectSyncTable", "ObjectLinkSource"], "sql": ["log", "cmd", "function", "ls", "SQL", "zip", "shell", "csv", "pr", "update", "string", "summary", "spec", "params", " SQL", "query", "join", "result", "ql", "sg", "sb", "sv", "su", "insert", "sq", "expression", "statement", "ssl", "term", "id", "sf", "general", "description", "comment", "str", "sl", "dl", "select", "db", "url", "s"]}}
{"id1": "14819747", "id2": "13981689", "code1": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "code2": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"debug": ["enabled", "err", "log", "die", "module", "dev", "depth", " debugger", "root", "production", " Debug", "active", "DEBUG", "details", "cache", "play", "remote", "ger", "enable", " DEBUG", "github", "show", "print", "status", "display", "export", "Debug", "store", "admin", "quiet", "doc", "progress", "real", "build", "bug", "development", " debugging", "trace", "test", "reg", "dump", "develop", "file", "error", "comment", "date", "console", "config", "tag", "db", "plugin", "help"], "prologFile": ["proLogHeader", "proconfigString", " prologSourceFile", "proversionPath", "proLogPath", "prologStream", "prolangSourceFile", " proLogStream", "defblogSourceFile", " prologfile", " proLogFiles", "prologModule", "rologFile", "prolangFull", "prologDir", "propathFile", "probaseFile", "procatSource", "proLogfile", " prologStream", "ProLogModule", "prolexString", "probaseStream", "roLogfile", " prologFiles", "problogFull", "proversionFILE", "roLogFile", "PrologString", "defblogfile", "proflowSourceFile", "prollFile", "proLogString", " proLogFile", "rologPath", "prologFILE", "problogStream", "prologString", "defLogFile", " problogFile", "prologFull", "propathSourceFile", "prologFiles", "proflowFile", "proLogStream", "propathDir", "proLogFull", "problogFiles", "defLogPath", " problogFull", "propathfile", "deflogFILE", "probaseHeader", "deflogSourceFile", " problogSourceFile", "prologSource", "Prologfile", "roLogSource", "problogSourceFile", "defblogDir", " prologFull", "proLogModule", "proconfigfile", "ProLogfile", "defblogFile", "deflogPath", "prolexfile", "problogDir", "ProLogString", " proLogHeader", "defLogFILE", "proLogFiles", "ProLogFile", "proversionFile", "proflowfile", "roLogPath", "proconfigPath", "deflogfile", "problogHeader", "prolexModule", "deflogDir", "proconfigFile", "prollPath", "rologfile", "rologSource", "prolexFile", "proLogFILE", "proversionSourceFile", "prologfile", "proLogFile", "proflowDir", "prolangFile", "prollfile", "proLogSourceFile", "prologHeader", "prologSourceFile", "problogFile", "prologPath", "proLogSource", "PrologFile", "PrologModule", "prollSource", "deflogFile", "problogfile", "proconfigSourceFile", "proconfigModule", "procatFile", "prolangfile", "procatPath", "procatfile", " problogfile", "defLogSourceFile", "proconfigFILE", " prologHeader", "probaseFiles"], "targetFile": ["TargetDir", "sourceDirectory", "targetPath", "TargetDirectory", " targetFiles", "sourceDir", "TargetFile", "Targetfile", "outputDir", "sourcePath", "sourceFile", "sourcefile", "targetfile", "TargetPath", "targetFiles", "outputfile", "outputPath", " targetDirectory", "targetDirectory", "TargetFiles", " targetfile", "sourceFiles", "targetDir", "outputFile"], "source": ["body", "unit", "model", "service", "resource", "options", "SOURCE", "config", "view", "Source", "content", "format", "input", "json", "target", "parse", "src", "message", "text", "zip", "slice", "stack", "use", "scope", "style", "string", "class", "position", "session", "buffer", "type", "ource", "result", "uri", "name", "term", "proxy", "language", "data", "file", "id", "str", "sl", "i", "comment", "description", "template"], "myParser": [" myReader", "myJar", "MyProgram", " myJar", "MyParser", "yourProgram", "myReader", "MyJar", "yourJar", "yourReader", "yourParser", "MyReader"], "myProgram": ["MYProgram", "myprogram", " myPlan", "myPlan", " myMath", "yourprogram", "yourPlan", "yourParser", "MyPlan", "theprogram", "Myprogram", "MYprogram", " myprogram", "yourProgram", "MyParser", "theProgram", "theParser", "theMath", "yourMath", "MyProgram", "MYParser", "myMath"], "myVisitor": ["MyVisiter", "myExitors", "myVISIT", " myvisIT", "myExitor", " myVisitable", "myvisiter", "Myvisulator", " myVisit", "myvisitor", "myExiter", "myAudit", "myVisulator", "myvisitors", "myVISitable", "myAuditors", "myDesignIT", "myAuditor", "myVisIT", " myvisitors", "myVISit", "myVisititable", "mySignitor", " myvisitable", "myvisulator", " myvisit", "myVISitor", " myvisitor", "Myvisitor", "myVisiter", " myVisitors", " myVisIT", "MyVisitors", "Myvisiter", "myVisititors", "myvisitable", "myDesignitor", "myExulator", "myVisitors", "Myvisitors", "myVisititor", "myDesignit", "myvisit", "mySignulator", "myVisitable", "MyVisitor", "myVisit", "mySigniter", "myvisIT", "mySignitors", "MyVisulator", "myAuditable", "myVisitit", "myDesignitable"], "adapterLayer": ["acaptersContainer", "acapterLanguage", "adapterContainer", "acapterInfo", "acaptersLayer", "adaptersBuffer", "adaptersLayer", "adviceLayer", "acaptersLanguage", "adviceFactory", "adaptersInfo", "admissionLanguage", "adptionLayer", "acaptersFactory", "acapterContainer", "adptionBuffer", "adviceInfo", "adptionFactory", "adaptersContainer", "adaptersLanguage", "acapterBuffer", "acapterFactory", "adaptersFactory", "adptionInfo", "adapterInfo", "adviceBuffer", "adviceLanguage", "adapterLanguage", "acaptersBuffer", "adviceContainer", "acapterLayer", "admissionLayer", "acaptersInfo", "adapterBuffer", "adapterFactory", "admissionContainer"], "classLoader": ["Classloader", "classPath", "staticloader", "ClassPath", "classDir", "classloader", "staticPath", " classloader", "staticLoader", " classPath", " classDir", "staticDir", "ClassDir", "ClassLoader"], "adapterWriter": ["adAdapterWriter", "attapterwriter", "adAdapterwriter", "attapterWrite", "admissionWriter", "attaptersReader", "adaptersWrite", "attapterswriter", "adapterReader", "attapterWriter", "adAdapterReader", "attapterReader", "adapterwriter", "attaptersWrite", "adapterWrite", "adaptersReader", "admissionWrite", "admissionReader", "adapterswriter", "adaptersWriter", "attaptersWriter", "adAdapterWrite", "admissionwriter"], "annotationGenerator": ["annnotationGencer", "annotationgenators", "annnotationGenators", "annotationGenerators", "annotationGenercer", "annotationGator", "annnotationGeneroder", "annotationGeneroder", "annotationGators", "annotationGoder", "annotationgenator", "annotationGenator", "annnotationGenercer", "annotationGenoder", "annotationGencer", "annotationGenators", "annotationGcer", "annotationgenoder", "annotationgencer", "annnotationGenoder", "annnotationGenerator", "annnotationGenator", "annnotationGenerators"], "out": ["err", "flow", "log", "in", "cmd", "outer", "raw", "temp", "prefix", "point", "pre", "cli", "net", "up", "group", "cache", "sync", "output", "OUT", "list", "conn", "post", "page", "print", "code", "array", "store", "state", "again", "outs", "query", "line", "io", "v", "diff", "Out", "chain", "bar", "dump", "server", "user", "down", "sys", "gen", "lock", "error", "n", "parent", "obj", "copy"]}}
{"id1": "14390569", "id2": "1357662", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 1, "substitutes": {"title": ["image", "body", "html", "resource", "section", "prefix", "itle", " Title", "content", "format", "itles", "version", "alpha", "license", "text", "message", "details", "filename", "label", "page", "string", "summary", "heading", "subject", "phrase", "type", "part", "notes", "ppa", "Title", "size", "name", "term", "TIT", "chapter", "data", "id", "layout", "description", "theme", "desc", "msg", "url", "header"], "imageURL": [" imageurl", "mediaUrl", "ImageUrl", "pictureURI", "filePath", "imgPath", "ImagePath", "pictureUrl", "mediaURI", "imgURL", "ImageURI", "imgUrl", "fileURI", "imageURI", "mediaURL", "ImageURL", " imageUrl", " imageURI", "imageurl", "imageUrl", "fileURL", "fileurl", "fileUrl", "pictureurl", "imgURI", "pictureURL", "imagePath"], "jd": [" jdl", "je", "ajD", "qdh", " jdd", "Jb", "jjdh", "jds", "zl", "ajdos", "Jdos", "Je", "jjdo", "jackb", "jackf", "ajdl", "jdom", "ssdo", "Jdo", "jdi", "ajdh", "jobdo", "ssdi", " jdo", "jsdh", "jD", "jjb", "Jds", "adjdos", "qb", "ajdo", "zf", "jsdo", "jsb", "jobD", "zb", "ajdi", "zd", " jdh", "jf", "ajd", "qd", " jds", "jackdd", "jjd", "argdo", "qdo", "Jf", "argf", " je", "zdo", "jsd", " jdi", " jf", "adjdo", "qdom", "JD", "jdos", "zdd", "zds", "jobb", "jdd", "Jl", "Jdom", "jdh", "adjb", "jdo", " jdom", "ze", "ssd", "ajb", "jobd", "argd", "jdl", "Jd", "ajf", "argdl", "jackd", " jD", "ssD", "adjd"], "jl": ["j", "jc", "eb", "nl", "kn", "wl", "kj", "syn", "lf", "bl", "cli", "Label", "l", "label", "ld", "vd", "lp", "NJ", "uj", "hl", "chal", "kl", "li", "dl", "iji", "lb", "ja", "JM", "elly", "ji", "jon", "elt", "dj", "fp", "zl", "il", "jj", "oji", "iol", "bn", "lv", "kel", "ll", "adj", "el", "bj", "lu", "igl"], "icon": ["image", "pic", "action", "resource", "ion", "content", " Icon", "alias", "picture", "text", "fc", "iao", "label", "info", "ui", "ann", "Icon", "core", "token", "ic", "note", "uni", "io", "eye", "uri", "icons", "cha", "css", "img", "size", "bn", " image", "cn", "on", "gn", "artist", "png", "ico", "n", "plugin", "url", "header"], "chooser": ["Chooses", "Choosen", " choressor", "closer", "boosen", " choosen", " chooses", "clressor", "Chooder", "boressor", "choose", " choose", "chooses", "chooder", "choressor", "Choose", " chooder", "choosen", "dialoser", "joose", "boose", "booser", "Chooser", "close", "cler", "dialosen", "jooses", "closen", "dialer", "jooder", "choer", "jooser", "dialose", "Choer"], "jp": ["j", "JP", " pa", " dock", " JM", " cm", " gp", " ax", " pane", " app", " j", " bridge", " dj", "bj", " tmp", "ja", " bar", "ji", " robot", " np", " js", " je", " plugin", "Panel", " pic", " mp", " obj", " sp", " cp"], "jb": ["ajsb", " jcb", "jbb", "djcb", "qf", "jscb", "djb", "jf", " jbb", "ajcb", "ajb", " jsb", "djd", "qsb", "jsbb", "ajf", "qb", "qcb", "jsd", "djbb", " jf", "jcb", "jsb"], "e": ["de", " ate", "in", " fe", "event", "exc", " Event", "je", "et", "E", " E", "c", "pe", "t", "ie", "v", "x", "ce", "ception", "a", "ae", "ev", "te", "ctx", "ec", "f", "ee"], "returnVal": ["Returnval", "returnNum", "resultNum", "ReturnVal", " returnVAL", "ReturnVAL", "resultVal", "returnValue", "ReturnValue", "replyVAL", " returnNum", " returnValue", "replyVal", "resultval", " returnval", "resultValue", "replyval", "replyValue", "returnVAL", "ReturnNum", "returnval"], "file": ["model", "force", "unit", "ban", "filename", "queue", "full", "page", "show", "future", "single", "dir", "name", "binary", "comment", "lib", "parent", "f", "directory", "body", "folder", "log", "pool", "po", "function", "local", "play", "b", "info", "auto", "files", "core", "handler", "io", "build", "fp", "FILE", "il", "user", "document", "get", "book", "File", "base", "module", "ile", "parse", "zip", "use", "l", "object", "home", "path", "line", "type", "out", "data", "lock", "db", "image", "letter", "rule", "die", "picture", "load", "http", "message", "pe", "buffer", "work", "part", "live", "url"], "fileName": ["singlePath", " filePath", "imageName", "binaryPath", "fileType", "filePath", "singleType", "resourceInfo", "FileInfo", "filename", "resourcePath", "binaryUrl", "FilePath", "imagename", "imageInfo", "FileName", " fileUrl", "Filename", " fileType", " filename", "imageUrl", "resourceName", "singleName", "fileUrl", " fileInfo", "singlename", "binaryName", "fileInfo", "FileType", "imagePath", "singleInfo", "resourcename"], "ext": ["enc", "format", "eng", "ension", "feat", "version", "oct", "exp", "sec", "xt", "ch", "extra", "txt", "class", "pe", "orig", "ct", "ace", "t", " Ext", "path", "fb", "p", "Ext", "type", "phrase", "alg", "v", "xp", "name", "EXT", "word", "ax", " extension", "qt", "ex", "desc", "abc", "lib", "f", "obj"], "i": ["z", "ini", "mi", "j", "o", "ion", "ment", "phi", "cli", "ii", "mini", "api", "b", "info", "ui", "ri", "pi", "c", "gi", "li", "ci", "p", "multi", "si", "ni", "io", "xi", "bi", "v", "uri", "ai", "y", "ip", "is", "bis", "a", "ti", "id", "iu", "u", "di", "m", "I"], "doIt": ["DOIt", "DOIT", "DOWhich", " doIT", "doYou", "poIt", "poit", "diIts", "addIt", " doNot", "doNot", "doit", "hoit", "diIT", "diIt", "skipit", "odoIt", "poIT", "poYou", "skipIts", "hoIT", "addIT", "doIts", "doWhich", "doIT", "skipIT", "odoNot", "odoWhich", " doYou", "odoit", " doit", "addit", " doIts", "skipIt", "DOit", " doWhich", "odoIT", "hoIt", "diit", "addNot", "hoYou"], "src": ["conv", "rx", "sub", "impl", "storage", "stream", "gz", "RC", "input", "ff", "cur", "target", "fi", "fc", "slice", "sync", "b", "bb", "cb", "sup", "ources", "buf", "gb", "r", "dist", "cdn", "rc", "sn", "path", "split", "st", "sc", "cmp", "ource", "upload", "rel", "sb", "attr", "img", "pull", "rest", "sq", "secure", "cos", "rs", "tmp", "socket", "ssl", "us", "sel", "Dest", "inst", "sth", "sl", "desc", "rb", "ctx", "uc", "bc", "loc", "source", "url"], "dest": ["wb", "die", "dev", "cont", "config", "done", "dc", "dat", " Dest", "trans", "target", "output", "later", "ctr", "uv", "wd", "sup", "home", "comb", "usr", "exit", "dist", "cdn", "route", "st", "proc", "prop", "destroy", "rest", "img", "gd", "std", "dir", "tmp", "Dest", "dep", "inst", "gen", "desc", "uc", "di", "loc", "source"]}}
{"id1": "2217889", "id2": "23152865", "code1": "    public static InputStream getResourceAsStreamIfAny(String resPath) {\n        URL url = findResource(resPath);\n        try {\n            return url == null ? null : url.openStream();\n        } catch (IOException e) {\n            ZMLog.warn(e, \" URL open Connection got an exception!\");\n            return null;\n        }\n    }\n", "code2": "    protected JavaFileObject open(String className) throws IOException {\n        JavaFileObject fo = getClassFileObject(className);\n        if (fo != null) return fo;\n        String cn = className;\n        int lastDot;\n        while ((lastDot = cn.lastIndexOf(\".\")) != -1) {\n            cn = cn.substring(0, lastDot) + \"$\" + cn.substring(lastDot + 1);\n            fo = getClassFileObject(cn);\n            if (fo != null) return fo;\n        }\n        if (!className.endsWith(\".class\")) return null;\n        if (fileManager instanceof StandardJavaFileManager) {\n            StandardJavaFileManager sfm = (StandardJavaFileManager) fileManager;\n            fo = sfm.getJavaFileObjects(className).iterator().next();\n            if (fo != null && fo.getLastModified() != 0) {\n                return fo;\n            }\n        }\n        if (className.matches(\"^[A-Za-z]+:.*\")) {\n            try {\n                final URI uri = new URI(className);\n                final URL url = uri.toURL();\n                final URLConnection conn = url.openConnection();\n                return new JavaFileObject() {\n\n                    public Kind getKind() {\n                        return JavaFileObject.Kind.CLASS;\n                    }\n\n                    public boolean isNameCompatible(String simpleName, Kind kind) {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public NestingKind getNestingKind() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Modifier getAccessLevel() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public URI toUri() {\n                        return uri;\n                    }\n\n                    public String getName() {\n                        return url.toString();\n                    }\n\n                    public InputStream openInputStream() throws IOException {\n                        return conn.getInputStream();\n                    }\n\n                    public OutputStream openOutputStream() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Writer openWriter() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public long getLastModified() {\n                        return conn.getLastModified();\n                    }\n\n                    public boolean delete() {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            } catch (URISyntaxException ignore) {\n            } catch (IOException ignore) {\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"getResourceAsStreamIfAny": ["getResourceAsStreamIFAnything", "getResourceAsStreamifAnything", "getResourceAsStreamIFANY", "getResourceAsStreamOrANY", "getResourceAsStreamIFany", "getResourceAsStreamIfANY", "getResourceAsStreamifAny", "getResourceAsStreamifany", "getResourceAsStreamOrany", "getResourceAsStreamifANY", "getResourceAsSteamIfAny", "getResourceAsSteamifANY", "getResourceAsStreamIfany", "getResourceAsSteamIfAnything", "getResourceAsSteamifany", "getResourceAsSteamIfANY", "getResourceAsSteamifAny", "getResourceAsSteamifAnything", "getResourceAsStreamOrAny", "getResourceAsStreamIFAny", "getResourceAsStreamOrAnything", "getResourceAsStreamIfAnything", "getResourceAsSteamIfany"], "resPath": ["resolutionUrl", "resourcepath", "resUrl", "resLocation", "ResLocation", "resourcePath", "ResUrl", "ResPath", "respath", "resolutionLocation", " resUrl", "Respath", " resLocation", "resolutionpath", "resourceUrl", "resolutionPath", " respath", "resourceLocation"], "url": ["image", "err", "log", "URL", "base", "resource", "lr", "service", "feed", "config", "impl", "stream", "event", "Url", "open", "entry", "ref", "http", "src", "l", "api", "bb", "object", "page", "string", "element", "path", "job", "source", "rel", "uri", "blog", "xml", "loader", "ssl", "server", "data", "file", "host", "ob", "ll", "instance", "browser", "sl", "rl", "connection", "loc", "location", "f", "address"]}}
{"id1": "7149578", "id2": "13783549", "code1": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"parseContent": ["parseDescription", "parserContent", "parserContents", "seDescription", "parseData", "seContents", "parseContents", "seContent", " parseContents", "parserDescription", " parseDescription", " parseData", "parserData", "seData"], "streamLimiter": ["streamGrabitter", "streamLimited", " streamLimitter", "streamGrabiler", " streamLimititor", "streamLimitited", "urlLimite", "streamVisitter", "streamLimite", "urlLimitation", "streamLimititter", " streamLimititter", "streamlimitter", " streamLimitor", "streamLimitite", "urllimite", "streamGrabiser", " streamLimiler", "urllimited", "streamLimer", " streamLimititer", "streamGrabiter", "streamLimiler", " streamLimizer", "streamlimiter", "streamVisizer", "streamlimizer", "streamLimititation", "streamLimitation", "streamLimitter", "streamlimitor", "streamLimititor", " streamLimitite", "streamlimited", " streamLimiser", "streamlimer", "streamLimizer", "streamLimiser", "urlLimited", "streamLimitor", "streamVisiter", "streamlimite", "urllimitation", "urllimiter", "urlLimiter", "streamlimitation", "streamLimititer", "streamViser", " streamLimer", " streamLimite"], "forcedLang": [" sourceSiang", " sourceFlang", " sourceLph", " sourceLamp", " sourceSamp", " requestedFliang", " requestedFlamp", " requestedLph", " sourceLevelph", " sourceSph", " requestedLiang", " requestedFlph", " sourceLiang", " requestedLang", " sourceFliang", " requestedFlang", " sourceLang", " sourceLeveliang", " sourceSang", " sourceFlamp", " sourceLevelang", " sourceLevelamp", " sourceFlph", " requestedLamp"], "charset": ["hasespace", "chapset", "chearset", "chaptersET", "chearsetting", " Charsets", "chARSeter", "chARSet", "charARSset", "chARSetter", " Charset", "haseset", "cheARSetter", "chapsets", "chacterset", "chasesET", "charseter", "chansset", "charARSET", "chaptersets", "chararset", "Charspace", "chapseter", "chearsets", "chasesets", "CharsET", "ChansET", "charARSett", "chapterset", "chansET", "charanset", "charansetting", "chanset", "chasespace", "cheaseter", "harsET", "charansET", "Chaset", "chaseset", "Charsetter", "harspace", "chearsetter", "chararsET", "charsett", "hasesET", "ChARSett", "chARSset", "cheARSetting", "chaseter", "chasets", "chARSett", "charsET", "cheaset", "chasett", "charARSet", "charARSeter", "chararsetting", "Chaspace", "chARSET", "chararsett", "Charsett", "chardsset", "ChARSet", "charsetting", "chararsets", "charARSetting", "charsetter", "Charset", "chardset", "charsset", "harset", "cheARSett", "chardsetting", "chanspace", "cheasets", " Chanset", "Charsetting", "chararsset", "chansets", "chansetter", "chARSpace", "Chansetter", "chaptersett", "chARSets", "Chanset", "chardsET", "chasET", "chARSetting", "chearsett", "cheasetting", "chapsetting", "chearseter", "cheARSet", "chaset", "chansetting", "chansett", "ChARSets", "chacterseter", "Charsets", " CharsET", "charARSets", "charsets", "chaptersetting", " Chansets", "Chasets", "charansett", " ChansET", "chasetting", "chasetter", "chactersetting", "charspace", "harsets", "cheARSets", " Chansett", "ChasET", "Chansets", "chararseter", "hasesets", "chaspace", "ChARSetting", "chactersET", " Charsett", "chanseter"], "sourceDocument": ["sourceDirectory", " sourcedocument", "siteDocuments", "searchFile", "inputContent", "searchDocument", "Sourcedocument", "siteDoc", "SourceContent", "srcDirectory", "SourceDoc", "srcDocument", "inputDocument", " sourceFile", "searchDocuments", "searchdocument", "sourcedocument", "siteDirectory", "inputdocument", "siteDocument", "SourceDocument", "sourceDocuments", "sourceFile", "SourceFile", "SourceDocuments", "sourceContent", " sourceDocuments", "siteContent", "srcdocument", "srcContent", " sourceDoc", " sourceContent", "sourceDoc", "inputDirectory", " sourceDirectory"], "fieldValueItem": ["fieldValueElement", "servervalueitem", "FieldValueItem", "FieldFamilyItems", "FieldNameItems", "fieldValue2", "servervalueIt", "fieldItemItem", "FieldFamilyItem", "fieldNamePart", "stringName1", " fieldNameElement", " fieldValueElement", "fieldPathItem", "fieldvalueItems", "fieldValueAct", " fieldNameItems", "fieldValuePart", "fieldTypeItems", "memberProcessitem", "stringNameElement", "fieldvalueIt", "servervalueItem", "fieldNameitem", "fieldItemParser", "fieldTextFile", "fieldNameParser", " fieldName2", "fieldTextItem", "fieldKeyItems", "serverValueIt", "fieldName2", "fieldNameElement", "fieldFamilyPart", "servervalueAct", "memberValueFile", "fieldTextElement", "fieldContentItems", "fieldTypeIt", "fieldValueitem", " fieldValueItems", "memberProcessElement", "fieldTextitem", "serverValueAct", "FieldValuePart", "fieldProcessElement", "fieldTypeSource", "memberProcessItem", "FieldFamilyParser", "stringValueItem", "memberProcessFile", "fieldNameItem", "memberValueItem", "FieldNameItem", "fieldTypeAct", "fieldFamilyItem", "fieldPathitem", "fieldProcessitem", "fieldProcessItem", "fieldFamilyParser", "stringNameItem", "fieldvalueAct", "FieldValueItems", "fieldTypeitem", "serverValueitem", "fieldContent1", "fieldNameFile", "FieldValueSource", "fieldNameSource", "fieldTypeItem", "fieldItemPart", "fieldKeyItem", "fieldType2", "fieldContentElement", "fieldValue1", "fieldValueParser", " fieldValue2", "memberValueElement", "fieldvalueElement", "stringNameItems", "fieldKeySource", "fieldItemItems", "fieldName1", "fieldTypeElement", "FieldValueParser", "fieldValueFile", "fieldFamilyItems", "fieldPathIt", "stringValueItems", "fieldValueIt", "fieldvalueItem", "fieldvalueitem", " fieldNameItem", "fieldType1", "serverValueItem", "fieldNameItems", "stringValue1", "FieldNameSource", "fieldValueSource", "fieldValueItems", "stringValueElement", "fieldProcessFile", "memberValueitem", "fieldvalue2", "fieldPathAct", "fieldContentItem", "FieldFamilyPart"], "charsetWasNull": ["charsetIsNone", "charsetWasConstruct", "charsetWasNone", "charsettingWasNull", "charsetPreviouslyNULL", "charsetWasNULL", "charsettingIsNULL", "charsetwasNull", "charsetPreviouslyNone", "charsettWasFound", "charsetWasFound", "charsetISnull", "charsetIsEmpty", "charsetsWasNull", "charsetwasnull", "charsetWasEmpty", "charsettingWasEmpty", "charsetsWasnull", "charsetIsNull", "charsetWereNULL", "charsettingWasNone", "charsettWasNULL", "charsettingIsEmpty", "charsetISNull", "charsetIsConstruct", "charsettingIsnull", "charsetsWasNULL", "charsetWereNull", "charsetIsFound", "charsetwasNULL", "charsetIsnull", "charsettingWasConstruct", "charsetIsNULL", "charsetPreviouslyConstruct", "charsetWasnull", "charsetPreviouslyNull", "charsettingIsConstruct", "charsettingIsNull", "charsettingIsNone", "charsettWasNull", "charsettingWasnull", "charsetISEmpty", "charsetISNULL", "charsetWereFound", "charsettingWasNULL", "charsetwasEmpty"], "writer": ["writing", "written", "wrote", "wb", "temp", "outer", "office", "walker", "w", "format", "write", "worker", "text", "parser", "ler", "widget", "output", "later", "ws", "string", "builder", "driver", "engine", "r", "creator", "buffer", "wa", "external", "wr", "handler", "rew", "author", "writers", "wrap", "type", "wire", "pointer", "build", "out", "director", "xml", "riter", "Writer", "loader", "word", "wrapper", "former", "data", "document", "value", "WR", "reader", "rw", "writ", "words", "source", "editor"], "htmlProvider": ["tmlLocation", "tmlider", "tmlProvider", "browserPool", " htmlLocation", "contentProv", "browserProvider", "htmlPool", "externalProvider", "contentProvider", "htmlReader", "contentManager", "htmlContext", "phpProv", "HTMLLocation", " htmlider", "tmlReader", " htmlFactory", " htmlContext", " htmlReader", "externalider", "contentReader", "tmlFactory", " htmlManager", " htmlProv", "phpProvider", "HTMLContext", "HTMLProvider", "apiReader", "httpider", "tmlContext", "htmlProv", "htmlider", " htmlPool", "browserider", "htmlManager", "htmlLocation", "httpProv", "tmlManager", "phpFactory", "HTMLProv", "apiProv", "phpManager", "HTMLManager", "httpProvider", "apiProvider", "tmlPool", "HTMLReader", "htmlFactory", "tmlProv"], "contentType": ["changeType", "modelType", "nextBody", "contenttype", "nextType", "ContentBody", "modelTime", "characterTypes", "contentTyp", "contentTime", "contentBody", "nexttype", "characterType", "contentName", "contentTy", "changeTime", "nextName", "characterTy", " contentTime", " contentTypes", " contentTy", "ContentTy", "changeTyp", "characterName", " contentName", "ContentName", "ContentTypes", " contentTyp", "ContentType", "changetype", "contentTypes", " contenttype", "Contenttype", "modeltype", "modelTyp", " contentBody"], "contentTypeCharset": ["contentTypeChasetting", "contentTypeEarset", "contentTypeChaptersSet", "contentTypeChansetting", "contentTypeEARSant", "contentTypeEARSet", "contentTypeCurARSet", "contentTypeChapesets", "contentTypeChARSant", "contentTypeChARSET", "contentTypeEARSets", "contentTypeClarsets", "contentTypeCangSet", "contentTypeChanset", "contentTypeChARSets", "contentTypeCasets", "contentTypeCarsSet", "contentTypeEarsets", "contentTypeCurarset", "contentTypeCharsetter", "contentTypeCangetter", "contentTypeChardsant", "contentTypeCarsetter", "contentTypeChardset", "contentTypeChardsetting", "contentTypeChARSet", "contentTypeCurarsetting", "contentTypeChARSetting", "contentTypeChangetter", "contentTypeChasant", "contentTypeEarsant", "contentTypeCurARSetting", "contentTypeChansets", "contentTypeCurarsets", "contentTypeClarset", "contentTypeCharsSet", "contentTypeChangSet", "contentTypeChansant", "contentTypeCarset", "contentTypeChapterset", "contentTypeCharsant", "contentTypeCurARSET", "contentTypeChaset", "contentTypeCharsET", "contentTypeChasET", "contentTypeChaptersets", "contentTypeChasetter", "contentTypeCarsett", "contentTypeChapesette", "contentTypeChapesant", "contentTypeCurarsET", "contentTypeChasette", "contentTypeCanget", "contentTypeChanget", "contentTypeCaset", "contentTypeCasetter", "contentTypeCharsett", "contentTypeChasets", "contentTypeChansET", "contentTypeChasett", "contentTypeCangets", "contentTypeCharsetting", "contentTypeChapesET", "contentTypeCasett", "contentTypeEarsET", "contentTypeChARSetter", "contentTypeChapeset", "contentTypeChansett", "contentTypeChARSett", "contentTypeChangets", "contentTypeEARSET", "contentTypeCurARSets", "contentTypeCarsets", "contentTypeClarsetting", "contentTypeChaptersetter", "contentTypeChangett", "contentTypeChARSSet", "contentTypeChapesetting", "contentTypeChardsets", "contentTypeCharsette", "contentTypeClarsette", "contentTypeCharsets"]}}
{"id1": "3801655", "id2": "9267602", "code1": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"helper": ["helpHelper", "harpherd", "scheler", "helHelper", "heler", "helppherd", "worker", "shper", "Helmer", "harHelper", "harler", "Helper", "workmer", "helpper", "Help", "workper", "schepherd", "sher", "Heler", "harper", "scheHelper", "workp", "shmer", "shp", "heller", "helmer", "scheper", "helpherd", "helpler", "help"], "dataset": [" DatASET", "datapsheet", "metasset", "DatASeter", "datasert", "datasET", "datastet", "Dataset", "datrasets", "datrasET", " DatasET", "datAset", "DatasET", "datasets", "datastets", "datasteter", "datAsET", "datacET", "metassheet", " DatASet", "datapsert", "datASets", "datassET", "metasert", "datapset", " DatASheet", "Dataseter", "datASeter", "metassET", "datassheet", "datacert", "datASet", "datacet", "datacheet", "datasset", "datAsets", "datraseter", "Datasets", "metasheet", "DatASET", " DatASets", " Datasets", "datasheet", "datapsET", "metassert", " Datasheet", "datassert", " Dataset", "datraset", "metaset", "datASET", "metasET", "datAsheet", "datassets", "datASheet", "datastET", "DatASets", "dataseter", "DatASet"], "zip": ["z", "folder", "plugin", "service", "tar", "pdf", "system", "gz", "py", "window", "parse", "slice", "bag", "java", "code", "git", "split", "handler", "p", "wrap", "io", "se", "flat", "out", "loop", "ip", "dir", "secure", "xml", "bug", "zone", "pack", "ssl", "archive", "Zip", "data", "file", "binary", "sea", "lock", "sl", "pkg", "pipe", "jar", "source", "f", "copy", "directory"], "entries": ["entryries", "deries", "contries", "intities", "entents", "entrants", "infities", "iterents", "inflines", "contrys", "iterlements", "ENTrants", "ENTrees", "itents", "intries", "entslections", "deents", " entities", "contry", "infrees", "ntries", "entrys", "itrys", "delements", "entlines", "ENTries", "contents", "inflections", "itries", "inflements", "intlements", "infries", "entities", "entlements", "entsries", "entsrees", "ntrys", "iterries", "entrylements", "itry", " entlements", "entlections", "entryents", "ENTlections", " entlines", "intlines", "entrees", "entsrants", "infrants", "ntry", "ntents"], "performance": [" writers", "unit", "slave", "its", " result", "U", "ul", " u", "units", "ui", " group", " split", "Unit", " output", "work", "it", "book", "util", "each", "runner", "union", " suite", " ratio", " units", "rank", "stats", " unit", "exec", " Unit", " Units"], "index": ["unit", "num", "depth", "offset", "Index", "write", "order", "head", "count", "key", "page", "pos", "position", "path", "type", "x", "number", "length", "name", "id", "level", "limit", "value", "i", "iter"], "entry": ["lc", "her", "folder", "in", "service", "nt", "child", "section", "office", "feed", "stream", "inner", "write", "input", "pattern", "ry", "parse", "Entry", "add", "key", "info", "post", "style", "element", "pe", "r", "cel", "export", "route", "ie", "part", "record", "result", "se", "it", "si", "uri", "row", "xml", "archive", "server", "data", "file", "cell", "e", "or", "connection", "install", "obj"], "temp": ["folder", "base", "stable", "office", "storage", "config", "w", "input", "cache", " temporary", "http", "local", "output", "table", "full", "txt", "store", "cel", "session", "path", "single", "p", "original", "Temp", "part", "wrap", "io", "dest", "flat", "out", "context", "tmp", "clean", "emp", "test", "tc", "archive", "data", "file", "porary", "binary", "valid", "layout", "lock", "fake", "empty", "thread", "tem", "pipe", "iter", "ctx", "partial", "template", "parent", "f", "copy", "directory"], "writer": ["writing", "log", "written", "wave", "feed", "outer", "stream", "inner", "w", "write", "player", "worker", "or", "ler", "wer", "output", "key", "ws", "engine", "driver", "builder", "element", "r", "wr", "handler", "er", "writers", "author", "io", "wire", "out", "layer", "manager", "riter", "Writer", "loader", "wrapper", "server", "file", "war", "rw", "sw", "per", "iter", "holder", "editor"], "reader": ["feed", "stream", "rer", "inner", "input", "write", "ry", "worker", "http", "ler", "rar", "reading", "upper", "ri", "driver", "builder", "element", "r", "oder", "handler", "er", "io", "rr", "ner", "loader", "ter", "wrapper", "server", "file", "ser", "iterator", "Reader", "per", "i", "iter", "or", "f", "editor"], "buffer": ["resource", "wave", "feed", "offset", "capacity", "sequence", "flush", "input", "write", "channel", "message", "slice", "queue", "table", "bytes", "device", "null", "buf", "position", "buff", "initial", "Buffer", "uffer", "result", "row", "layer", "character", "length", "size", "server", "data", "reference", "binary", "seed", "document", "limit", "transfer", "iter", "batch", "source", "memory", "header", "address"], "read": ["create", "feed", "send", "end", "child", "raw", "view", "default", "current", "check", "download", "write", "input", "open", "skip", "available", "find", "parse", "load", "reads", "reading", "Read", "process", "run", "play", "use", "add", "count", "sync", "ride", "print", "fill", "g", "pass", "readable", "work", "ind", "next", "k", "text", "ad", "type", "select", "sleep", "allow", "se", "build", "x", "length", "start", "size", "close", "report", "data", "id", "READ", "eval", "connect", "old", "get", "wait", "seek", "iter", "config", "exec", "book", "max", "copy", "save"], "outfile": ["logdata", "againline", "outline", "indir", "Outdir", "outf", "Outf", "outdir", "Outstream", "inf", "outFile", " outFile", "inline", "inFile", " outfilename", "againdir", "outstream", "againfile", "indata", "againstream", " outstream", "logFile", "logfilename", " outf", "logfile", "outfilename", " outline", "instream", "outdata", "Outline", "infile", " outdata", "infilename", "Outfile"], "line": ["look", "letter", "log", "link", "cle", "section", "end", "side", "val", "lf", "lines", "inline", "filter", "LINE", "parse", "text", "Line", "sync", "column", "l", "object", "page", "ine", "string", "code", "status", "style", "pass", "item", "strip", "split", "job", "type", "frame", "row", "ip", "block", "le", "lin", "name", "word", "sel", "data", "range", "file", "cell", "band", "on", "error", "comment", "str", "el", "url", "header"], "parser": ["pool", "system", "arser", "function", "pattern", "plan", "worker", "parse", "ler", "par", "lp", "string", "class", "builder", "driver", "r", "params", "oder", "handler", "er", "p", "type", "Parser", "book", "xml", "manager", "loader", "cher", "test", "wrapper", "server", "data", "umper", "per", "angler", "plugin", "processor"], "list": ["pool", "right", "base", "other", "can", "LIST", "val", "plan", "match", "filter", "group", "l", "table", "info", "member", "lp", "left", "set", "array", "r", "collection", "li", "join", "er", "p", "lists", "listed", "result", "part", "type", "v", "all", "and", "out", "chain", "map", "test", "data", "best", "get", "parent"], "rule": ["model", "base", "field", "lr", "service", "event", "val", "ul", "function", "match", "group", "parse", "rules", "rate", "table", "style", "class", "ri", "pe", "r", "item", "li", "er", "dict", "record", "row", "ule", "layer", "tree", "Rule", "data", "range", "header", "str", "rl", "per", "rol", "plugin", "ee"], "measure": ["speasure", "measures", "speasuring", "measuring", "measured", "feasures", "Measures", "Measure", "feasured", "Measured", "Measuring", "speasures", "speasured", "feasure", "feasuring"]}}
{"id1": "20011285", "id2": "21348951", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "label": 1, "substitutes": {"copy": ["link", "log", "create", "change", "clone", "share", "download", "write", "py", "paste", "cop", "load", "zip", "sync", "replace", "cat", "update", "apply", "clip", "split", "type", "upload", "opy", "Copy", "file", "transfer", "rm", "move", "delete", "get", "cp", " cp", "save"], "sourceFile": ["sourceDirectory", "sourceBook", "ourcePage", " sourcePlace", "apiFilename", " sourcePage", "ourceDirectory", "apiFile", " sourceSourceFile", "SourceDir", "sourceDir", "sourcePage", "apiFiles", "sourceFilename", "SourceBook", " sourceDirectory", "sampleFile", "ourceFiles", "sourceFolder", "sampleFilename", "ourceTime", "targetFolder", " sourceBook", " sourcefile", "sourceSourceFile", "SourcePlace", "SourceDirectory", "sampleFiles", " sourceFiles", "siteFILE", " sourceDir", "slaveFile", "sourceFILE", "slaveFILE", "SourceTime", "ourcefile", "targetPage", "SourceFile", "sourcefile", "apiFILE", "targetFile", "slaveFiles", "Sourcefile", "ourceFolder", "targetFiles", "sourceFiles", "ourceBook", "sampleFILE", "ourcePlace", "sourcePlace", " sourceFILE", "sourceTime", "siteFiles", "targetDirectory", "siteFile", " sourceFilename", "siteFilename", "slaveFilename", "SourceFiles", "SourceSourceFile", "targetDir", " sourceTime", "ourceFile", "ourceSourceFile", " sourceFolder"], "destinationFile": ["destinationFolder", "dominatorFile", "destwayFILE", "destinatefile", "targetinatedFiles", "targetinationFile", "targetinationfile", "destuationFile", "dominationFILE", "destructionfile", "destuationfile", "destinatorSourceFile", "destructionFILE", "destinatedfile", "dominatorfile", "destinationDirectory", "dominatorFILE", "destuationFILE", "dominationfile", "distructionFile", "destinatedFile", "DestinatingFile", "targetinatedFile", "distructionfile", "destinateFolder", "destinatingFiles", "distructionFILE", "desturationFiles", "destwayfile", "desturationSourceFile", "destinatingFile", "DestinationSourceFile", "DestinatingDirectory", "destinatorFile", "destinatorFILE", " destinationfile", " destinatingFolder", "destinateFile", "destinatingDirectory", "destinationFiles", "dominatorPath", " destinatingFile", "desturationDirectory", "distinationFile", "destinatorPath", "destwayFiles", "distinationfile", "destinatorFolder", "dominationPath", "destinatingPath", "DestinatingSourceFile", "destinatorDirectory", "dominatorFiles", "destinatingfile", "targetinatedFolder", "distructionFolder", "targetinationFiles", "destuationFolder", "destinationSourceFile", "destinatingFolder", "destinationfile", "destinatedFolder", "destructionFile", "destinatingSourceFile", "destinationPath", " destinationFiles", " destinatingFiles", "DestinationFile", "DestinationFiles", "destructionFolder", "destinatePath", "targetinatedfile", "dominationFile", "destinatedFiles", " destinatingfile", "destinatingFILE", "targetinationFolder", "destinatorfile", "distinationFolder", "dominationFiles", "destinateFiles", "destwayFile", "desturationFile", " destinationFolder", "DestinatingFiles", "destinatorFiles", "DestinationDirectory", "destinationFILE", "distinationFILE"], "tmp": ["np", "folder", "nb", "temp", "storage", "tab", "current", "dat", "po", "py", "mm", "zip", "cache", "mo", "slice", "area", "list", "media", "api", "bb", "mp", "sup", "page", "csv", "txt", "array", "pp", "files", "apps", "sp", "buf", "pos", "amp", "params", "t", "fb", "st", "handler", "split", "p", "cmp", "upload", "part", "v", "diff", "flat", "dest", "img", "ip", "dir", "pty", "data", "tp", "e", "rm", "vm", "stuff", "rb", "mb", "meta", "db", "obj", "ppa"], "f": ["fo", "j", "o", "fr", "this", "fa", "inf", "lf", "F", "ff", "fe", "fi", "fc", "xf", "l", "b", "info", "full", "uf", "c", "cf", "r", "rf", "g", "t", "fd", "d", "fb", "handler", "fl", "p", "conf", "io", "v", "x", "df", "fp", "fs", "fx", "tf", "file", "fn", "af", "e", "u", "bf", "m"], "i": ["lc", "j", "index", "o", "in", "oi", "hi", "ii", "fi", "ix", "key", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "d", "li", "ci", "p", "ie", "multi", "si", "xi", "io", "uri", "bi", "v", "x", "ai", "ji", "y", "ip", "start", "name", "h", "ti", "id", "qi", "e", "iu", "u", "vi", "ij", "n", "di", "m", "I", "s"], "source": ["force", "slave", "base", "service", "resource", "SOURCE", "site", "storage", "view", "stream", "Source", "current", "this", "input", "grade", "target", "src", "cache", "back", "slice", "use", "scope", "null", "from", "core", "ie", "ource", "si", "result", "io", "uri", "diff", "ce", "client", "secure", "start", "proxy", "ge", "wrapper", "server", "id", "component", "e", "sl", "reader", "get", "connection", "parent"], "destination": ["estinate", "partinator", "combination", "destinator", "Destation", "destinating", "Destination", "Destinating", " destinator", "combinating", "Destinated", "combinated", " destation", "Destinator", "generinator", "generination", "Destinate", "combinator", "generinated", "partinated", "generinate", "estinator", "estinating", "estination", "destinate", "destinated", "combinate", " destinated", "partination", "destation", "partation"]}}
{"id1": "1421557", "id2": "17557289", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeString2File", "encodeFileFromStream", "encodeFileFromString", "encodeStringToStream", "encodeString2Files", "encodeFiletoStream", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFiles", "encodeFiletoFile", "encodeFileFromFiles", "encodeFileFromFile", "encodeString2Stream", "encodeStringToString", "encodeFileToString", "encodeFile2String", "encodeString2String", "encodeFile2File", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFile2Files", "encodeFileToStream"], "infile": [" infilename", "infiles", "Infilename", "outFile", "inputfile", "outfiles", "inFile", "InFile", "inputfilename", " infiles", " infp", "inputFile", "outfilename", "outfp", "Infiles", "inputfiles", "infp", "inputfp", "infilename", "Infile"], "outfile": ["newfolder", "outname", "outFile", " outFile", "outputfp", "outputfilename", " outfilename", "Outname", "outfolder", "outputfolder", " outfp", "Outfolder", "newfile", "newname", " outfolder", "infolder", "newFile", "outfilename", "outfp", "outputfile", "OutFile", "infp", " outname", "infilename", "Outfile"], "in": ["re", "err", "ini", "image", "base", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "vin", "m", "din", "socket", "inc", "s"], "out": ["err", "ou", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "In", "obj", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "outs", "work", "job", "source", "line", "io", "Out", "client", "off", "name", "co", "on", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "count", "cache", "slice", "queue", "b", "bytes", "bb", "null", "buf", "buff", "border", "padding", "fb", "split", "uffer", "type", "result", "len", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "input", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "close", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "model", "method", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "respons", "open", "better", "message", "growth", "modified", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "12066447", "id2": "7911686", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"truncate": ["autatenational", "autuncation", "truncator", "trunate", "autuncate", "autatenation", "autuncator", "trunation", "trrenation", "trrenator", "truncation", "tratenator", "trrenate", "trunational", "trrenational", "tratenate", "tratenational", "autuncational", "trunator", "autatenate", "truncational", "autatenator", "tratenation"], "file": ["File", "log", "image", "base", "folder", "resource", "model", "body", "address", "this", "stream", "current", "format", "function", "ile", "zip", "cache", "http", "local", "filename", "queue", "l", "info", "full", "object", "page", "string", "class", "future", "files", "path", "handler", "single", "plus", "type", "line", "io", "uri", " File", "it", "out", "fp", "FILE", "name", "archive", "data", "binary", "document", "e", "parent", "time", "one", "per", "get", "or", "connection", "source", "db", "f", "url", "directory"], "backupRoot": ["backbaseRoot", "backUpDir", "BackupRoot", "backbackDir", "backupsFolder", "backupHome", "frontupFolder", "backdownDirectory", "backdownFile", "backdownFolder", "backureDirectory", "Backuproot", "BackureRoot", "BackbackFile", "backupsPath", "backUpRoot", "backupsDir", "backdownRoot", "backflowRoot", "backdownroot", "backbackDirectory", "BackureDirectory", "backupDirectory", "BackbackRoot", "backupFolder", "backupsroot", "backbaseDirectory", "BackdownRoot", "BackdownPath", "backupsDirectory", "backflowFile", "backflowDir", "backupsRoot", "BackbackDir", "backupFile", "Backbackroot", "Backdownroot", "backureDir", "BackupDir", "BackureDir", "backbackroot", "frontdownFolder", "frontdownDir", "frontuproot", "frontupDir", "backUproot", "backureHome", "backUpFolder", "BackupHome", "backupPath", "BackupDirectory", "BackupPath", "backdownHome", "backbasePath", "backuproot", "backureRoot", "backbackFile", "backdownDir", "frontdownroot", "BackureHome", "BackdownDirectory", "frontdownRoot", "backbaseroot", "backbackHome", "backflowroot", "backupDir", "BackupFile", "frontupRoot", "backbackRoot", "backdownPath"], "df": ["dd", "DF", "flow", "de", "dp", "fr", "pdf", "func", "dc", "format", " def", "fe", "fc", "xf", "raf", "da", "cf", "def", "deb", "fd", "di", "d", "fb", "ds", "dt", "io", "CF", "fp", "fs", "dq", "md", "tf", "data", "fn", "af", "dn", "sf", "pd", "dm", "bf", "dl", "db", "f", "dict"], "date": ["re", "rule", "log", "fee", "j", "create", "module", "form", "dat", "format", "pre", "input", "D", "open", "version", "day", "age", "message", "back", "modified", "dose", "use", "output", "sync", "created", "update", "style", "string", "code", "updated", "atom", "days", "pe", "Date", "stage", "custom", "d", "work", "ate", "db", "type", "dt", "year", "x", "min", "out", "diff", "bug", "ale", "name", "ge", "data", "valid", "value", "str", "complete", " Date", "time", "m", "tag", "dates", "url"], "zipFile": ["zModel", " zipEntry", "ressModel", "zipModel", "sqlFile", "Zipfile", "ressSection", "sqlfile", "zFiles", "zSection", "zipFiles", "zFile", "ZipEntry", "zipEntry", "zipfile", "zipSection", "ressfile", "sqlModel", "sqlSection", "ZipFile", " zipfile", "zfile", "ressFile", "ZipFiles", " zipFiles", "zEntry"], "zos": ["z", "iffs", "her", "asio", "zes", "closure", "zx", "kos", "gz", "zb", "uz", "zar", "ops", "zzy", "cash", "ls", "dos", "bos", "osi", "lins", "zip", "nz", "liquid", "webkit", "zon", "nox", "zer", "js", "tz", "ZA", "zy", "exit", "zn", "inos", "outs", "zo", "forge", "eros", " sands", "zag", "bes", "ils", "settings", "chini", "ros", "ozo", "obb", "os", "bitcoin", "dylib", "css", "zl", "cos", "ses", "ssl", "proxy", "zan", "las", "zona", "han", "zik", "rez", "robe", "zen", "zero", "jas", "hess", "fits", "zh", "los", "budget", "zi", "address"], "fis": [" fits", "flisp", "rafris", "infiz", "flis", "rafis", "infids", "liss", "fisl", "flris", "fisp", "viz", "bos", "fias", "fids", "lis", "fils", "vis", " fos", "infits", "bisl", "fos", " fias", "lias", "infias", " fils", "vils", "Fisp", "infils", " fisp", "rafiss", " fiss", "Fisl", "Fos", "Fis", "fris", " fisl", "fiz", "bis", "Fiss", "fliss", "fiss", "lids", "infis", "vits", "flias", "biss", " fiz", "infiss", "flids", "Fias", "rafias", "fits", "Fris", " fris"], "entry": ["z", "lc", "her", "de", "image", "letter", "index", "feed", "ion", "offset", "event", "ry", "obj", "exp", "zip", "Entry", "add", "key", "info", "ui", "auto", "extra", "style", "element", "array", "so", "r", "cel", "ace", "next", "zo", "ie", "si", "record", "se", "uri", "it", "and", "row", " Entry", "term", "the", "archive", "ge", "server", "data", "ries", "cell", "e", "card", "comment", "reader", "per", "or", "address"], "buffer": ["shape", "wave", "feed", "sequence", "flush", "beta", "channel", "available", "cache", "slice", "queue", "b", "writer", "bytes", "bb", "device", "page", "pad", "null", "buf", "buff", "position", "border", "vector", "Buffer", "padding", "uffer", "result", "number", "row", "layer", "length", "FFER", "server", "data", "reference", "binary", "seed", "transfer", "comment", "reader", "iter", "batch", "memory", "header", "address"], "readed": ["intended", " Readable", "intized", "readered", "intED", " readable", " readered", "texted", "inputED", " Readed", "textended", "bootered", " Readled", " readned", "inputed", "textED", "inted", "bootable", " readED", " ReadED", "readable", " Readned", "readized", " readized", " readended", "inputled", "readled", "textized", "bootED", "booted", "readED", " readled", "readned", " Readered", "readended", "inputned"]}}
{"id1": "15797402", "id2": "22611968", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"parse": ["service", "raw", "view", "transform", "scan", "patch", "pc", "worker", "load", "http", "parser", "process", "processing", "rate", "replace", "print", "read", "set", "apply", " rewrite", " split", "fork", "split", " dispatch", " parsing", "wrap", "se", "Parser", "handle", " serve", " convert", "xml", " transform", "report", "pack", "request", " parser", "php", " process", "arse", " analyse", "cover", "save"], "stream": ["image", "video", "in", "resource", "feed", "raw", "temp", "view", "inner", "sample", "content", "form", "draw", "input", "download", "channel", "load", "message", "http", "src", "stack", "remote", "writer", "through", "read", "upload", "response", "handle", "client", "loader", "server", "data", "down", "document", "file", "iterator", "reader", "Stream", "source", "url"], "handler": ["base", "service", "default", "event", "format", "function", "channel", "Handler", "parser", "writer", "info", "application", "driver", "collection", "handled", "monitor", "pointer", "response", "layer", "handle", "client", "controller", "hand", "manager", "loader", "h", "wrapper", "server", "data", "reader", "ctx", "di", "connection", "phase", "host", "parent", "processor"], "metadata": ["mi", "plugin", "met", "resource", "module", "meta", "config", "storage", "content", "runtime", "json", "property", "message", "parser", "properties", "info", "management", "mon", "mx", "params", "state", "collection", "subject", "template", "attribute", "monitor", "metry", "uri", "processor", "mt", "managed", "manager", "xml", "map", "material", "adata", "component", "data", "document", "database", "ctx", "di", "connection", "m", "source", "md", "header", "directory"], "context": ["method", "resource", "system", "event", "content", "entry", "text", "message", "environment", "concept", "object", "scope", "txt", "element", "collection", "subject", " contexts", "translation", "cmp", "command", "xml", "manager", "request", "proxy", "kernel", " Context", "data", "component", "document", "Context", "instance", "mc", "reader", "tx", "ctx", "connection", "config", "parent", "processor"], "name": ["image", "action", "model", "base", "in", "resource", "child", "NAME", "prefix", "common", "alias", "none", "active", "version", "message", "filename", "key", "sync", "label", "api", "full", "object", "string", "class", "ame", "code", "null", "route", "path", "Name", "work", "large", "job", "type", "part", "named", "size", "missing", "word", "search", "id", "data", "on", "file", "call", "time", "names", "no", "comment", "old", "n", "default", "connection", "m", "source", "url", "address"], "out": ["err", "image", "pool", "in", "o", "resource", "child", "temp", "flush", "plain", "window", "channel", "exp", "sync", "output", "OUT", "writer", "bin", "conn", "object", "extra", "page", "url", "null", "builder", "again", "outs", "path", "line", "io", "result", "Out", "client", "cos", "manager", "socket", "ext", "ray", "server", "data", "file", "user", "instance", "ex", "lib", "connection", "source", "obj", "copy"]}}
{"id1": "6304373", "id2": "701029", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL url;\n        try {\n            url = getClass().getResource(filename);\n            is = url.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \\n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaOrTemplatepl", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrtemFiles", "uploadOrDeleteMediaOrMemplates", "uploadOrDeleteMediaOrTemplateFiles", "uploadOrDeleteMediaOrTemFiles", "uploadOrDeleteMediaOrMemFiles", "uploadOrDeleteMediaOrtempl", "uploadOrDeleteMediaOrMemporary", "uploadOrDeleteMediaOrMempl", "uploadOrDeleteMediaOrtemporary", "uploadOrDeleteMediaOrTemplateplates", "uploadOrDeleteMediaOrTemplateporary", "uploadOrDeleteMediaOrTemporary", "uploadOrDeleteMediaOrtemplates"], "action": ["flow", "method", "service", "resource", "module", "section", "change", "site", "view", "event", "step", "format", "effect", "function", "active", "version", "ction", "api", "environment", "now", "style", "status", "element", "act", "flash", "state", "item", "next", "type", "activation", "part", "actions", "commit", "controller", "Action", "name", "test", "operation", "ACTION", "call", "lock", "error", "activity", "what", "parent", "plugin", "url"], "object": ["image", "letter", "model", "o", "resource", "email", "system", "module", "objects", "office", "service", "directory", "current", "event", "self", "function", "none", "target", "obj", "edit", "version", "mode", "group", "environment", "now", "full", "auto", "string", "element", "class", "subject", "not", "node", "ject", "part", "oid", "number", "article", "zone", "request", "document", "parent", "lock", "instance", "thread", "host", "project", "url", "address"], "numElements": [" numElem", " numelement", " numelements", "numElodes", " numEodes", " numeodes", "numeodes", "numGelem", "numGeodes", "numEodes", "numelement", "numEllements", "numEllem", "numEllement", " numelem", "numelements", "numGelement", "numGelements", "numElem", "numelem"], "req": ["err", "log", "html", "base", "module", "load", "use", "update", "builder", "usr", "r", "params", "g", "resp", "gr", "ro", "next", "mr", "util", "xml", "report", "verb", "res", "ctx", "msg", "parent", "conf", "obj"], "session": ["image", "ESSION", "service", "resource", "temp", "system", "site", "event", "global", "sa", "http", "cache", "local", "use", "scope", "sp", "flash", "state", "subject", "token", "result", "container", "ession", "response", "client", "context", "manager", "Session", "test", "request", "h", "document", "instance", "security", "browser", "thread", "person", "lock", "shared", "ctx", "connection"], "ftp": ["ftP", "ftc", "FTp", "ttp", "ttcp", " ftcp", "FTc", "FTP", "ttc", " ftP", "FTcp", "ttP", "ftcp", " ftc"], "user": ["rule", "image", "log", "ver", "base", "html", "mail", "module", "other", "system", "account", "this", "view", "self", "current", "project", "usa", "match", "profile", "facebook", "group", "use", "User", "info", "full", "member", "page", "home", "string", "hash", "class", "usr", "post", "admin", "pass", "creator", "custom", "path", "state", "db", "er", "author", "type", "result", "record", "used", "by", "client", "bug", "users", "auth", "name", "data", "e", "username", "parent", "person", "lock", "browser", "error", "per", "shared", "comment", "connection", "config", "USER", "url", "ee"], "links": ["link", "linked", "log", "html", "base", "mail", "image", "email", "Link", "posts", "lines", "details", "ids", "styles", "url", "mails", "flash", "headers", "groups", "images", "Links", "actions", "items", "members", "tree", "pages", "results", "menu"], "folders": ["anchors", "filries", "anchries", "handers", "foldages", "foldries", "handors", "anchages", "handages", "filors", "anchers", "handries", "filages", "foldors", "filers"], "folder": ["letter", "email", "resource", "directory", "sample", "Folder", "ignore", "picture", "menu", "license", "zip", "filename", "slice", "area", "device", "scope", "home", "element", "future", "path", "two", "source", "division", "upload", "uri", "flat", "network", "layer", "command", "dir", "region", "editor", "zone", "volume", "archive", "fold", "id", "layout", "document", "level", "append", "database", "theme", "enter", "connection", "location", "project", "plugin", "url", "address"], "server": ["erver", "slave", "service", "resource", "email", "localhost", "outer", "site", "account", "system", "address", "inner", "version", "master", "filename", "remote", "device", "page", "string", "status", "engine", "scale", "token", "node", "type", "uri", "network", "Server", "client", "manager", "socket", "location", "ssl", "peer", "host", "seed", "port", "username", "ser", "value", "database", "reader", "enter", "connection", "source", "url", "directory"], "login": ["log", "mail", "service", "email", "resource", "account", "site", "picture", "profile", "consumer", "group", "blank", "journal", "filename", "bridge", "shell", "info", "label", "status", "string", "pin", "pass", "access", "path", "Login", "network", "blog", "secret", "users", "cookie", "auth", "name", "socket", "ssl", "layout", "skin", "basic", "username", "lock", "database", "connection", "config", "sudo", "plugin", "url", "machine"], "password": ["Password", "slave", "email", "mask", "account", "alias", " passwords", "pattern", "picture", "worker", "filename", "column", "device", "string", "pass", "access", "token", "padding", "strip", "division", "phrase", "secret", "cookie", "manager", "auth", "photo", "name", "PASS", "word", "volume", "language", "ass", "basic", "username", "security", "sword", "database", "timeout", "connection", "profile", "sudo", "plugin", "directory"], "fileTransferFolder": ["fileImportDirectory", "fileAccessFolder", "fileTransformTheme", "mediaTransferfolder", "FileTransferTheme", "fileUploadPath", "fileTransformfolder", "fileTransferDirectory", "fileUploadDirectory", "FileTransferPath", "fileAccessPath", "fileTransferServer", "FileUploadfolder", "mediaTransferDirectory", "fileAccessTheme", "fileUploadfolder", "fileTransformFolder", "fileTransferPath", "mediaTransferFolder", "fileImportServer", "FileTransferFolder", "fileTransferTheme", "fileTransformPath", "fileAccessfolder", "fileTransferfolder", "fileImportFolder", "fileUploadServer", "FileUploadTheme", "FileUploadPath", "mediaUploadFolder", "mediaUploadServer", "fileUploadTheme", "mediaUploadfolder", "fileUploadFolder", "fileImportfolder", "mediaUploadDirectory", "FileTransferfolder", "mediaTransferServer", "FileUploadFolder"], "liveFolder": ["Livefolder", " liveDirectory", "liveDirectory", "PreviewLocation", " livefolder", "PreviewFolder", "LiveFolder", "livefolder", "LiveLocation", "PreviewDirectory", " liveLocation", "Previewfolder", "liveLocation", "LiveDirectory"], "servers": ["servvers", "servls", "Serls", " serations", "serServer", "Servers", "Serations", " serls", "SerServer", "serations", "serls", "servServer", "servations", " serServer"], "message": ["body", "image", "log", "mail", "resource", "email", "module", "content", "menu", "details", "member", "update", "page", "status", "application", "summary", "string", "element", "flash", "array", "buffer", "path", "mess", " messages", "response", "manager", "Message", "request", "document", "error", "description", "msg", "url", "header", "address"]}}
{"id1": "23152865", "id2": "10540676", "code1": "    protected JavaFileObject open(String className) throws IOException {\n        JavaFileObject fo = getClassFileObject(className);\n        if (fo != null) return fo;\n        String cn = className;\n        int lastDot;\n        while ((lastDot = cn.lastIndexOf(\".\")) != -1) {\n            cn = cn.substring(0, lastDot) + \"$\" + cn.substring(lastDot + 1);\n            fo = getClassFileObject(cn);\n            if (fo != null) return fo;\n        }\n        if (!className.endsWith(\".class\")) return null;\n        if (fileManager instanceof StandardJavaFileManager) {\n            StandardJavaFileManager sfm = (StandardJavaFileManager) fileManager;\n            fo = sfm.getJavaFileObjects(className).iterator().next();\n            if (fo != null && fo.getLastModified() != 0) {\n                return fo;\n            }\n        }\n        if (className.matches(\"^[A-Za-z]+:.*\")) {\n            try {\n                final URI uri = new URI(className);\n                final URL url = uri.toURL();\n                final URLConnection conn = url.openConnection();\n                return new JavaFileObject() {\n\n                    public Kind getKind() {\n                        return JavaFileObject.Kind.CLASS;\n                    }\n\n                    public boolean isNameCompatible(String simpleName, Kind kind) {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public NestingKind getNestingKind() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Modifier getAccessLevel() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public URI toUri() {\n                        return uri;\n                    }\n\n                    public String getName() {\n                        return url.toString();\n                    }\n\n                    public InputStream openInputStream() throws IOException {\n                        return conn.getInputStream();\n                    }\n\n                    public OutputStream openOutputStream() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Writer openWriter() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public long getLastModified() {\n                        return conn.getLastModified();\n                    }\n\n                    public boolean delete() {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            } catch (URISyntaxException ignore) {\n            } catch (IOException ignore) {\n            }\n        }\n        return null;\n    }\n", "code2": "    public static void checkForUpgrade(Event event) throws Exception {\n        ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"applyUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(false);\n        new Command(\"DELETE FROM TBLINSTALLATION WHERE STATUS<>'APPLIED'\").executeNonQuery();\n        String clientAppliedVersion = new Command(\"SELECT MAX(VERSION) FROM TBLINSTALLATION WHERE STATUS='APPLIED'\").executeScalarAsString();\n        if (NullStatus.isNull(clientAppliedVersion)) {\n            clientAppliedVersion = \"20050101\";\n        }\n        String macquery = \"\";\n        String clientMAC = \"\";\n        String clientUNITID = UiUtil.getUNITUID();\n        ArrayList<String> macList = getMacList();\n        for (int i = 0; i < macList.size(); i++) {\n            clientMAC += macList.get(i) + \",\";\n            macquery += \"'\" + macList.get(i) + \"'\";\n            if (i < macList.size() - 1) {\n                macquery += \",\";\n            }\n        }\n        URL urlLICENSEQUERY = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC + \"&tegsoftCOMMAND=LICENSEQUERY\");\n        URLConnection urlConnection = urlLICENSEQUERY.openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String commingList = \"\";\n        String line;\n        while ((line = in.readLine()) != null) {\n            commingList += line;\n        }\n        in.close();\n        String licenseArray[] = commingList.split(\"</ROW>\");\n        if (licenseArray.length > 0) {\n            String fields[] = licenseArray[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        Dataset TBLLICENSE = new Dataset(\"TBLLICENSE\", \"TBLLICENSE\");\n        Command command = new Command(\"DELETE FROM TBLLICENSE WHERE UNITUID={UNITUID} AND (NOTES IN (\");\n        command.append(macquery);\n        command.append(\") OR NOTES IS NULL) \");\n        command.executeNonQuery();\n        for (int i = 1; i < licenseArray.length; i++) {\n            String fields[] = licenseArray[i].split(\"</FLD>\");\n            String LICTYPE = fields[0];\n            String UNIQUEKEY = fields[1];\n            String LICKEY = fields[2];\n            DataRow dataRow = TBLLICENSE.addNewDataRow();\n            dataRow.set(\"LICENSENAME\", LICTYPE);\n            dataRow.set(\"LICENSE\", LICKEY);\n            dataRow.set(\"NOTES\", UNIQUEKEY);\n            TBLLICENSE.save();\n        }\n        URL url = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC);\n        urlConnection = url.openConnection();\n        in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String upgradeList = \"\";\n        while ((line = in.readLine()) != null) {\n            upgradeList += line;\n        }\n        in.close();\n        Dataset TBLINSTALLATION = new Dataset(\"TBLINSTALLATION\", \"TBLINSTALLATION\");\n        String upgrades[] = upgradeList.split(\"</ROW>\");\n        if (upgrades.length > 0) {\n            String fields[] = upgrades[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        boolean restartRequired = false;\n        boolean updateAvailable = false;\n        for (int i = 1; i < upgrades.length; i++) {\n            String fields[] = upgrades[i].split(\"</FLD>\");\n            String VERSION = fields[0];\n            String ORDERID = fields[1];\n            String UPGRADETYPE = fields[2];\n            String DESCRIPTION = fields[3];\n            String STATUS = \"UNAPPLIED\";\n            String PRDNAME = \"TegsoftCC\";\n            if (\"TEGSOFTJARS\".equals(UPGRADETYPE) || \"TOBEJARS\".equals(UPGRADETYPE) || \"ALLJARS\".equals(UPGRADETYPE) || \"CONFIGASTERISK\".equals(UPGRADETYPE)) {\n                restartRequired = true;\n            }\n            DataRow dataRow = TBLINSTALLATION.addNewDataRow();\n            dataRow.set(\"ORDERID\", ORDERID);\n            dataRow.set(\"PRDNAME\", PRDNAME);\n            dataRow.set(\"UPGRADETYPE\", UPGRADETYPE);\n            dataRow.set(\"VERSION\", VERSION);\n            dataRow.set(\"STATUS\", STATUS);\n            dataRow.set(\"DESCRIPTION\", DESCRIPTION);\n            TBLINSTALLATION.save();\n            updateAvailable = true;\n        }\n        UiUtil.getDataset(\"TBLINSTALLATION\").reFill();\n        if (restartRequired) {\n            ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(true);\n            ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(true);\n        }\n        if (updateAvailable) {\n            ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(true);\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_4));\n        } else {\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_5));\n        }\n    }\n", "label": 0, "substitutes": {"open": ["link", "opened", "resource", "create", " Open", "to", "write", "load", "java", "info", "object", "read", "class", "next", "op", "type", "opens", "start", "close", "name", "map", "file", "document", "config", "Open", "append", "copy"], "className": ["CLASSFile", "ClassType", "instancename", "instancePath", " classLine", " classFile", "packagePath", "fileName", "fileType", "filePath", "classNAME", "classFile", " classString", "ClassFile", "objectType", "CLASSname", "ClassPath", "filename", "instanceNAME", "instanceName", "objectName", "classType", "classLine", " classname", "packageLine", "classString", "classname", "ClassName", "fileString", "objectPath", "ClassNAME", "ClassString", "fileFile", "CLASSName", "objectname", " classNAME", "classPath", "packagename", "Classname", "packageName", "CLASSType", "ClassLine", " classType", " classPath"], "fo": ["who", "fa", "fi", "odo", "xf", "prof", "olo", "cf", "ato", "wx", "flo", "Obj", "os", "Info", "eno", "f", "bo", "o", "za", "foo", "osa", "oh", "to", "po", "fw", "mo", "local", "info", "tto", "txt", "so", "gh", "gi", "gor", "io", "ho", "co", "ko", "jo", "vo", "lo", "fam", "tu", "go", "inf", "ma", "fe", "wh", "object", "ws", "aco", "oo", "zo", "ph", "fb", "ao", "oss", "fs", "abo", "fn", "af", "wo", "php", "bj", "ki", "conf", "obj", "FO", "shi", "buff", "zz", "ott", "tw", "kw", "oso", "umo"], "cn": ["enc", "lc", "Ns", "kn", "fa", "coll", "dc", "hn", "ain", "cl", "nc", "net", "anc", "rt", "ns", "ca", "fc", "rev", "wcs", "cb", "cat", "csv", "ann", "cot", "act", "c", "cf", "vc", "mn", "aa", "ct", "cdn", "core", "sn", "Name", "CN", "cs", "cin", "css", "cy", "cc", "cas", "name", "cm", "cp", "col", "bn", "con", "ln", "cv", "gn", "fn", "dn", "rn", "abc", "n", "ctx", "bh", "cr"], "lastDot": ["nextDot", "lastDigott", "lastDotted", "lastDigot", "lastFot", "lastDoOT", "lastMidash", "lastDigollar", "lastFott", "latestDaot", " lastDotted", "lastMidotted", "nextDollar", " lastDitive", "lastFOT", " lastFot", "latestDaou", "nextDigOT", "lastDoou", " lastDott", "lastMidot", "lastDitive", "lastMiditive", "lastDootted", "lastDaou", "lastSlot", "lastSlash", "nextDigash", " lastNot", "latestDot", "lastNotted", "lastDaash", "lastDoash", "latestDash", "lastNitive", "lastDaot", "lastDigOT", "latestDaash", "lastDou", "lastNash", "lastMidOT", "nextDOT", "latestDou", "lastDoot", "lastDominot", "lastDaOT", "lastDOT", "lastSlou", "lastDollar", "lastDash", " lastNotted", " lastFOT", "lastRadash", " lastNash", "lastRadot", " lastFott", "lastDigash", "lastDominOT", "lastDominotted", "nextDash", "nextDigot", "lastDigotted", " lastNitive", "lastRadollar", "lastMidollar", "lastDominott", " lastDOT", "lastNot", " lastFotted", "lastFotted", "lastDoitive", "lastDott", "lastRadOT", "latestDaOT", "lastSlOT", "latestDOT", " lastDash", "nextDigollar"], "sfm": ["rfM", "fmm", "rfm", "fm", "tfmm", "SFm", "tffm", "sfmm", "sfM", "tfbm", "rfmm", "sfbm", "SFbm", "tfm", "rffm", "SFM", "fbm", "SFfm", "sffm", "SFmm", "fM", "tfM"], "uri": ["link", "mi", "URL", "base", "resource", "service", "prefix", "directory", " URI", "iri", "cli", "Url", "domain", "hub", "http", "api", "l", "ui", "string", "ri", "pi", "gi", "route", "path", "query", "li", "ci", "source", "uni", "io", "ni", "attribute", "client", "dir", "URI", "manager", "name", "server", "id", "range", "i", "timeout", "connection", "loc", "location", "address"], "url": ["link", "image", "URL", "base", "resource", "service", "config", "impl", "cli", "Url", "http", "text", "src", "filename", "l", "ui", "object", "string", "ri", "class", "route", "path", "li", "source", "client", "dir", "xml", "manager", "ur", "name", "ssl", "location", "server", "id", "file", "data", "browser", "str", "sl", "i", "connection", "loc", "host", "f", "address"], "conn": ["enc", "conv", "nt", "coll", " con", "cli", "nc", "net", "obj", "req", "http", "Connection", "remote", "ch", "ann", "c", "r", "session", "path", "ci", "addr", "ai", "out", "client", "manager", "socket", "ssl", "reg", " connection", "con", "server", "connect", "Conn", "timeout", "n", "ctx", "cp", "connection", "loc", "conf"], "simpleName": [" classNames", "simplePath", "fullName", "fullType", " simpleNames", " simpleType", "simpleType", "fullNames", "simpleNames", " simplePath", "fullPath", " classType", " classPath"], "kind": ["ance", "method", "resource", " Kind", "inner", "cost", "expected", "version", "mode", "ke", "info", " kinds", "style", "iv", "spec", "state", "path", "k", "ind", "weak", "type", "part", "Kind", "dir", "id", "instance", "str", "kid"], "ignoreEncodingErrors": ["ignoreEncodingErors", "ignoreEncachingErrs", "ignoreEncodingMirrs", "ignoreEncodingTererrors", "ignoreEncodingEror", "ignoreEncodingMirrors", "ignoreEncapingErrs", "ignoreEncodingPhror", "ignoreEncodingError", "ignoreEncapingMirrors", "ignoreEncapingMirerrors", "ignoreEncachingMirror", "ignoreEncapingMiraces", "ignoreEncodingTerrors", "ignoreEncodingErerrors", "ignoreEncapingErrors", "ignoreEncachingMirerrors", "ignoreEncodingErrs", "ignoreEncodingEerrors", "ignoreEncodingERerrors", "ignoreEncodingMirerrors", "ignoreEncodingTerrs", "ignoreEncodingERrors", "ignoreEncachingErrors", "ignoreEncapingErerrors", "ignoreEncachingMirrors", "ignoreEncodingPherrors", "ignoreEncachingError", "ignoreEncodingTeraces", "ignoreEncapingMirrs", "ignoreEncodingErs", "ignoreEncodingERrs", "ignoreEncapingEraces", "ignoreEncodingEraces", "ignoreEncachingMirrs", "ignoreEncodingERaces", "ignoreEncodingPhrs", "ignoreEncodingMirror", "ignoreEncodingMiraces", "ignoreEncachingErerrors", "ignoreEncodingPhrors"]}}
{"id1": "2221297", "id2": "12055086", "code1": "    public static String getURLContent(String urlToSearchString) throws IOException {\n        URL url = new URL(urlToSearchString);\n        URLConnection conn = url.openConnection();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) encoding = \"ISO-8859-1\";\n        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        StringBuilder sb = new StringBuilder(16384);\n        try {\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line);\n                sb.append('\\n');\n            }\n        } finally {\n            br.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"getURLContent": ["getPageBody", "geturlContents", "parseURLBody", "getStringBody", "getStringContent", "getURLBody", "getURLContents", "getStringContents", "getURLcontent", "getPageContent", "getPageContents", "geturlcontent", "parseURLContent", "getPagecontent", "getStringcontent", "geturlBody", "parseurlContents", "geturlContent", "parseURLContents", "parseurlcontent", "parseurlBody", "parseurlContent", "parseURLcontent"], "urlToSearchString": ["urlToSearchArray", "urlToFindStr", "urltoSearchStr", "urlToFindSection", "urlTOFindSection", "urlTosearchSection", "urlTOFindArray", "urlToCreateSection", "urltoSearchSection", "urltosearchArray", "urlTOSearchArray", "urlTOFindStr", "urltosearchStr", "urltosearchString", "urltoSearchArray", "urlToCreateArray", "urlTOSearchString", "urlTosearchStr", "urlToFindString", "urltoSearchString", "urlToFindArray", "urlToSearchSection", "urlTOSearchSection", "urlTosearchString", "urlTOFindString", "urltosearchSection", "urlToCreateString", "urlToSearchStr", "urlTosearchArray", "urlTOSearchStr", "urlToCreateStr"], "url": ["lc", "log", "URL", "base", "resource", "www", "download", "Url", "open", "ls", "cur", "http", "zip", "l", "b", "bb", "ch", "cb", "page", "c", "job", "org", "uri", "blog", "client", "ur", "ssl", "server", "file", "ll", "jar", "str", "sl", "rl", "web", "connection", "host", "db", "f"], "conn": ["enc", "err", "conv", "nt", "dc", "cli", "nc", "open", "cur", "rt", "Connection", "http", "exec", "sync", "api", "ch", "cb", "connected", "act", "c", "Config", "ct", "g", "rc", "io", "client", "auth", "socket", "ssl", "con", "loc", "cn", "connect", "Conn", "n", "ctx", "cp", "connection", "config", "host", "db", "conf"], "encoding": ["decoding", "engoder", "enccode", "loccode", "Encoding", "Encatin", "acoded", " encoded", "engcode", "encoded", "Encale", "encoring", "acoding", "locoder", "encoder", "Encoded", "noding", " encoring", " encatin", "Encoder", "engoring", "engoding", "encale", "decoring", "enale", "encode", " encoder", "nale", "acatin", "locoding", "enoder", "decoder", "engoded", "enoded", "encatin", "decoded", "noded", "locoded", "enoding", "noder", "acoder"], "br": ["err", "dr", "lr", "fr", "stream", "bl", "arr", "ref", "src", "cro", "http", "bridge", "ch", "bb", "cb", "b", "buf", "sp", "r", "ber", "tr", "fb", "bro", "db", "result", "Br", "BR", "mr", "img", "orb", "hr", "bar", "sr", "ob", "jar", "browser", "str", "reader", "rb", "bc", "bh", "grab", "cr", "ab"], "sb": ["ib", "wb", "nb", "bsp", "kb", "bm", "eb", "SB", "bot", "ls", "sa", "xb", "src", "amb", "b", "bb", "cb", "bh", "ruby", "bp", "lp", "builder", "gb", "buff", "abb", "sn", "fb", "lb", " SB", "bd", "si", "obb", "sg", "erb", "pb", "bt", "ssl", "lab", "bs", "binary", "bps", "ob", "sf", "rb", "mb", "bc", "bf", "bj", "BB", "db", "ab"], "line": ["link", "body", "err", "letter", "base", "lc", "feed", "end", "content", "lf", "cl", "lines", "inline", "LINE", "text", "Line", "key", "l", "b", "page", "string", "code", "pos", "c", "r", "buffer", "next", "part", "len", "row", "response", "number", "out", "character", "name", "word", "data", "cell", "char", "e", "str", "sl", "i", "reader", "comment", "n", "source", "f", "lin"]}}
{"id1": "22135199", "id2": "19810820", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testCodingEmptyFile": ["testCodingOfStream", "testCodingOfFile", "testCodingNoFile", "testCodingZeroSourceFile", "testCachingOfStream", "testCodingEmptyFiles", "testCodingNoFiles", "testCachingEmptyFile", "testCachingEmptyFiles", "testCodingOfFiles", "testCodingNoSourceFile", "testCodingNoStream", "testCachingEmptySourceFile", "testCachingOfSourceFile", "testCodingEmptyStream", "testCachingEmptyStream", "testCodingOfSourceFile", "testCodingZeroStream", "testCodingZeroFiles", "testCodingEmptySourceFile", "testCachingOfFiles", "testCodingZeroFile", "testCachingOfFile"], "baos": ["waoS", "baOS", "kaos", "kaOS", "aaaaoS", "bao", " baoS", "bioS", "pao", "BaOs", "Baos", "waos", "buoa", "buo", "Baoes", "kao", "buOS", "paos", " baotes", "waOS", "aaaaos", "baoS", "biotes", "BaoS", "baOs", "aaaaOs", "baotes", "BaOS", " baoes", "Baotes", "waOs", "aaaaOS", "bioes", "baoes", "bios", "kaoa", "paOS", "paoa", "baoa", "buos"], "channel": ["flow", "log", "video", "service", "system", "feed", "can", "stream", "self", "cam", "group", "camera", "queue", "ch", "conn", "url", "c", "annels", "handler", "sc", "io", "an", "container", "console", "out", "client", "Channel", "context", "chan", "socket", "cho", "bean", "server", "data", "sea", "reader", "connection", "config", "source", "parent"], "params": ["options", "Par", " parameters", "ops", "param", "mm", "http", "cms", "parser", "ams", "api", "conn", "par", "null", " param", "ps", "settings", "Parameters", "cmp", "stats", "processor", "proc", "css", "size", "Param", "tx", "ctx", "cpu", "config"], "outbuf": ["outbuff", "Outbuf", " outbuff", "outbuffer", "outputbag", " outqueue", " outbuffer", "inputqueue", "outbag", "Outbuff", "inputbag", "inputbuf", "outputcb", "outputbuffer", "outputbuf", "Outcb", "outcb", "outputqueue", "outputbuff", " outbag", "outqueue", "Outbuffer", "inputbuff", " outcb"], "metrics": [" metals", "Metrics", "metics", "metrix", "monics", "metras", "matrics", "Metric", "monrics", "Metics", "monras", "matric", "matrix", "Metras", " metric", "metric", "metals", " metics", "matals", "Metals", " metras", "monric", " metrix", "Metrix"], "encoder": ["ecler", "enccode", "ecressor", "Encoding", "eccode", " encoded", "ecoding", " encoding", "encoded", "encressor", "Encipher", "enressor", "Encoser", "Encoded", "encoser", "encoding", "Encoder", "ecoded", "ecoder", " encoser", "ecode", "encode", "ecoser", "encipher", " encressor", "enoder", "encler", " encler", "Encler", " encode", " encipher", "enode", "enoded", "Encode", " enccode", "enoser", "ecipher"], "tmpFile": ["tempFolder", "mpFilename", "tempFile", "mpFile", "tmpFiles", " tmpFolder", "tempfile", "mpFunction", "mpPath", "mpFiles", " tmpDir", "txtfile", "tmpFunction", "poraryFunction", "vtFilename", " tmpPath", "tmpfile", "mpfile", "poraryFile", "vtFile", "testFiles", " tmpFiles", "tmpFilename", " tmpFilename", "tmpDir", "testfile", "mpDir", "testFile", "tmpFolder", "tempFiles", "testFolder", "txtFile", "mpPage", "tempPath", "tmpPath", "txtFunction", "poraryfile", "vtfile", "txtPage", "vtDir", "tmpPage", "poraryPage", " tmpfile"], "fout": ["flout", "fio", "fdagain", "ffile", "Fio", "fdout", "sfio", " fio", "frout", "flagain", "frurl", "furl", "fagain", "flwrite", "frwrite", "Fchannel", "sffile", "fdwrite", "sfout", "flurl", "Fout", "fdurl", "fragain", "sfchannel", "Ffile", "fwrite", " ffile"], "wrtout": ["wRTwriter", "wadrin", "Wrtwriter", " wrtouter", "wRTouter", "WRTin", "WrtOut", "wrin", "wrdouter", "wrdin", "WRTwriter", "Wrtin", "wadrouter", "WRTouter", "wrcagain", "wrOut", "wrcouter", "wrtouter", "WRTout", "Wrtouter", "wrcin", "wrn", "wrcn", "wRTout", "wrtagain", " wrcout", "wadragain", "wrcOut", "Wrtn", " wrcagain", "wadrwriter", "wrtin", " wrtagain", " wrtin", "wrdout", "wrtwriter", "wadrout", "wRTin", "wRTn", "wrout", "WRTn", " wrcouter", "WRTOut", " wrcin", "Wrtout", "wrtOut", "wrdwriter", "wrtn", "wRTagain", "wrcout", "wRTOut"], "fchannel": ["fqueue", "fenresource", "pconn", " fcontainer", "fconn", "fstream", "bconn", "bchannel", "fenqueue", "pchannel", "pstream", "presource", "pchan", " fchan", "fresource", "pqueue", "hstream", "fchan", "hchannel", "fenchannel", "bcontainer", "pcontainer", "fenstream", "fcontainer", "hqueue", "hresource", "bchan", " fconn"], "s": ["o", "abs", "ls", "services", "ns", "l", "b", "ms", "js", "string", "c", "r", "g", "ps", "t", "p", "settings", "S", "su", "os", "v", "states", "qs", "ins", "ses", "es", "gs", "ings", "e", "u", "ss", "i", "n", "ts", "m", "strings", "f"]}}
{"id1": "17522011", "id2": "3631989", "code1": "    public static String read(ClassLoader classLoader, String name, boolean all) throws IOException {\n        if (all) {\n            StringMaker sm = new StringMaker();\n            Enumeration enu = classLoader.getResources(name);\n            while (enu.hasMoreElements()) {\n                URL url = (URL) enu.nextElement();\n                InputStream is = url.openStream();\n                String s = read(is);\n                if (s != null) {\n                    sm.append(s);\n                    sm.append(StringPool.NEW_LINE);\n                }\n                is.close();\n            }\n            return sm.toString().trim();\n        } else {\n            InputStream is = classLoader.getResourceAsStream(name);\n            String s = read(is);\n            is.close();\n            return s;\n        }\n    }\n", "code2": "    public void run() {\n        URL url;\n        try {\n            url = new URL(\"http://localhost:8080/glowaxes/dailytrend.jsp\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((str = in.readLine()) != null) {\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"read": ["resources", "resource", "create", "feed", "send", "check", "input", "write", "open", "find", "parse", "load", "reads", "reading", "Read", "process", "add", "run", "use", "play", "print", "class", "readable", "work", "type", "build", "start", "report", "data", "include", "READ", "eval", "connect", "reader", "get", "default", "select", "exec", "invoke"], "classLoader": ["resourceReader", " classPath", " classLoad", "filePath", "ClassDir", "ClassPath", "ClassLoad", "classloader", "classLoading", "ClassLoading", "ClassReader", " classloader", " classLoading", "resourceloader", "Classloader", "fileDir", "classLoad", "classDir", "fileloader", "classPath", "resourceLoading", "classReader", "resourceLoader", "fileLoader", " classDir", " classReader", "fileLoad", "ClassLoader"], "name": ["image", "base", "resource", "child", "NAME", "prefix", "root", "alias", "none", "active", "filename", "key", "connection", "home", "string", "class", "ame", "code", "null", "pass", "path", "Name", "large", "type", "part", "named", "x", "size", "word", "search", "id", "file", "data", "names", "str", "comment", "old", "no", "n", "value", "default", "time", "parent", "address"], "all": ["batch", "this", "am", "global", "both", "with", "none", "at", "active", "alpha", "process", "local", "total", "sync", "list", "l", "full", "auto", "ann", "left", "array", "apply", "pass", "sort", "not", "part", "attribute", "ALL", "allow", "and", "named", "All", "any", "only", "app", "each", "alls", "al", "call", "one", "partial", "f"], "sm": ["nm", "service", "ym", "bm", "imm", "serv", "spe", "sk", "fm", "ama", "mm", "sa", "sim", "tm", "asm", "mo", "zip", "api", "ms", "km", "so", "sp", "sam", "sn", "Sm", "smith", "si", "om", "su", "sv", "SM", "sb", "sh", "wm", "cm", "sr", "sum", "sym", "sf", "rm", "ss", "sl", "im", "em", "hm", "sw", "vm", "m", "source", "gm", "sy"], "enu": ["ennu", "anus", "enc", "enncu", "Enou", "enun", "encu", " enus", "enou", "ENu", "Ennu", " ennu", "ennnu", "ENus", "venc", "munU", "anun", "anU", "munu", "enus", "venu", "Enc", "ennus", "EnU", "Enus", "ENou", "munun", "anu", "Enun", "enU", "munus", " encu", "venus", "Enu", "venou", "Encu", "ENc"], "url": ["image", "URL", "base", "resource", "in", "impl", "download", "Url", "ls", "http", "zip", "key", "l", "page", "string", "r", "path", "li", "job", "rel", "uri", "plug", "pull", "layer", "ur", "loader", "ssl", "server", "id", "file", "ll", "browser", "str", "sl", "i", "connection", "loc", "source", "web", "f", "address"], "is": ["image", "its", "in", "serv", "isi", "vs", "inner", "abs", "ops", "mis", "ls", "ii", "ignore", "http", "cms", "ir", "lis", "has", "api", "info", "js", "IS", "ri", "act", "was", "ic", "ie", "p", "ris", "io", "si", "os", "it", "uri", "isl", "isa", "iss", "ip", "ins", "il", "as", "close", "app", "iso", "are", "es", "init", "ori", "esi", "us", "ois", "bis", "id", "isc", "ios", "Is", "i", "ais", "im", "web", "or", "ar", "iris"], "s": ["its", "o", "comments", "storage", "ans", "abs", "w", "ls", "lines", "services", "details", "ns", "ments", "als", "l", "ms", "ws", "js", "string", "c", "r", "spec", "session", "g", "ps", "rows", "outs", "d", "ies", "ows", "sc", "ds", "p", "ions", "ches", "si", "S", "su", "os", "sb", "sv", "sg", "se", "cs", "ins", "ses", "rs", "es", "ssl", "gs", "ings", "h", "ips", "les", "e", "sf", "ss", "sl", "u", "i", "results", "n", "sets", "ts", "ks", "m", "strings", "f"]}}
{"id1": "22879400", "id2": "300397", "code1": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"loadAllProperties": ["loadAllProtproperties", "loadAllAllperties", "loadallProResources", "loadallProtperties", "loadAllAllResources", "loadAllAllps", "loadAllproResources", "loadallProps", "loadAllProResources", "loadAllProtps", "loadallProtps", "loadallProproperties", "loadAllproproperties", "loadAllAllproperties", "loadallProtproperties", "loadAllProps", "loadallProtResources", "loadAllProtperties", "loadAllproperties", "loadAllprops", "loadallProperties", "loadAllProtResources", "loadAllProproperties"], "resourceName": ["collectionInfo", " resourceInfo", "collectionname", "collectionName", "stringInfo", "fileName", "attributename", "attributeName", " resourceNAME", "resourceInfo", "Resourcename", "filename", " resourceFull", "fileNAME", "resourceNAME", "ResourceName", " resourcename", "collectionTitle", "ResourceInfo", "stringFull", "fileUrl", "ResourceTitle", "resourceUrl", "resourcename", "attributeNAME", "fileInfo", "resourceFull", "stringName", " resourceUrl", "attributeUrl", "stringname", "fileFull", " resourceTitle", "resourceTitle"], "classLoader": [" classRing", "ClassPath", "resourcePath", "ClassRing", "classloader", "classLoading", "projectRing", "ClassLoading", " classloader", "resourceloader", " classLoading", "projectLoading", "Classloader", "projectloader", "ClassLoader", "classPath", "resourceLoading", "projectLoader", "resourceLoader", "classRing", " classPath"], "clToUse": ["clOfUse", "cltoUser", "cltoUse", "classToUser", "classToUSE", "clFromUser", "clToUser", "classTOUSE", "clOfUSE", "classtoUse", "clCoUSE", "CLToUser", "clCouse", "CLtoUSE", "CLtouse", "CLtoUsing", "clFromUSE", "cltoUsing", "clTOUSE", "CLToUsing", "clFromUsing", "CLTouse", "clToUsing", "clTOUse", "classTOuse", "CLToUSE", "clOfuse", "clCoUse", "classTOUser", "cltouse", "classtouse", "classTouse", "CLToUse", "classtoUSE", "CLtoUse", "cltoUSE", "clFromuse", "classtoUser", "CLtoUser", "clTouse", "classToUse", "clTOUser", "classTOUse", "clTOuse", "clCoUsing", "clOfUser", "clToUSE", "clFromUse"], "properties": ["resources", "books", "ports", "vals", "options", "objects", "this", "types", "keys", "posts", "metadata", "json", "lines", "property", "details", "rules", "tops", "api", "info", "styles", "bytes", "files", "tests", "params", "groups", "ps", " props", "p", "settings", "result", "fields", "articles", "items", "prop", "values", "parts", "xml", "reports", "pb", "loader", "features", "les", "perties", "data", "classes", "results", "pro", "obj"], "urls": ["urlins", "sllines", " urlls", "urlls", "Urllines", "URLls", "logches", "logworks", "Urls", "Urlrows", "urllines", "URLis", "URLins", "urlworks", "Urlls", "cls", "clls", "URLworks", "URLrows", "logls", " urlins", "Urlins", "urlrows", "URLches", "logs", "URLlines", "URLs", " urlis", "urlis", "slls", "clworks", "urlches", "clches", "sls", "slrows", "Urlis"], "url": ["URL", "base", "resource", "impl", "event", "ul", "cl", "Url", "open", "ls", "cur", "http", "key", "l", "b", "conn", "class", "c", "r", "path", "job", "fl", "uri", "client", "il", "ur", "socket", "ssl", "name", "server", "id", "file", "ll", "connect", "sl", "uc", "connection", "loc", "source", "f"], "is": ["err", "its", "in", "serv", "isol", "isi", "est", "abs", "internet", "ls", "src", "nis", "lis", "does", "api", "ms", "info", "ui", "js", "IS", "act", "bel", "ps", "was", "ils", "ci", "ris", "si", "os", "uri", "it", "isl", "isa", "out", "and", "fs", "ip", "iss", "ins", "il", "close", "as", "iso", "es", "bis", "are", "us", "ori", "ois", "id", "isc", "ios", "Is", "i", "ais", "or", "ar", "iris", "ab", "s"], "con": ["com", "ver", "conv", "resource", "can", "coll", "syn", "cons", "open", "pc", "cur", "http", "ca", "cache", "fc", "ch", "conn", "un", "ann", "CON", "ran", "act", "c", "bel", "rc", "client", "Con", "cos", "close", "init", "co", "cn", "on", "ocon", "const", "connect", "Conn", "uc", "bc", "connection", "inc", "cr", "conf", "cover"]}}
{"id1": "22338097", "id2": "14691829", "code1": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 1, "substitutes": {"createMD5": [" createMD256", "createMAC2", "createSHA256", "createSHA5", "createMAC512", "createMD256", " createSHA2", "createmd2", " createSHA5", "createmd256", "createSHA2", "createmd5", "createMD512", " createSHA256", " createMD2", " createMD512", "createmd512", "createMAC256", "createMD2", "createSHA512", "createMAC5", " createSHA512"], "pwd": ["cwd", " pwm", "pWD", "Ppassword", "PWD", "ppassword", " pw", "cpassword", "pw", "hWD", "Pwd", " pWD", "hwd", "cw", "Pw", "hw", "Pwm", "pwm", "cWD", "hwm", " ppassword"], "md": ["dd", "de", "cmd", "meta", "am", "dig", "amd", "metadata", "um", "py", " MD", "hd", "mm", "po", "mo", "cd", "wd", "mp", "vd", "mand", "d", "ind", "bf", "bd", "ad", "pm", "df", "mg", "mt", "mac", "gd", "od", "tmp", "mk", "cm", "MD", "mod", "mag", "rm", "dm", "mc", "pkg", "mb", "hm", "di", "m"], "pd": ["dd", "pins", "np", "td", "pat", "dp", "PD", "po", "py", "hd", "pc", "xd", "cd", "ld", "wd", "vd", "lp", "da", "pi", "pp", "pe", "wp", "ps", "fd", "d", "pid", "bd", "ds", "p", "pg", "ped", "pm", "sv", "gd", "od", "sd", "std", "pb", "ppo", "tp", "cp", "dl", "ppa"], "app": ["html", "fac", "form", "ap", "py", "arr", "cache", "ang", "api", "b", "ch", "bb", "mp", "pad", "page", "application", "string", "array", "pp", "apps", "sp", "App", "apply", "amp", "APP", "g", "buff", "fb", "buffer", "p", "aa", "cmp", "ask", "allow", "container", "sb", "ce", "mac", "ip", "pack", "test", "ac", "keep", "data", "cap", "cell", "instance", "bc", "ape", "acc", "msg", "host", "db", "conf", "append", "ab", "s"], "i": ["z", "ini", "index", "j", "o", "oi", "chi", "end", "uli", "hi", "inner", "ii", "ix", "fi", "slice", "key", "mu", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "t", "abi", "d", "li", "ci", "p", "multi", "si", "xi", "io", "bi", "uri", "v", "x", "ai", "ni", "ji", "ip", "ori", "ti", "qi", "id", "data", "e", "u", "f", "n", "di", "I", "zi", "s"], "s2": ["pass2", "pass1", "p182", "ptwo", " s1", "ds6", "ses6", "sl2", "p1", "p12", "salt", " s12", " s3", "ds2", " stwo", "ses2", "p3", "s6", " s6", "s182", " s182", "sestwo", "palt", "sl1", "sl182", "stwo", " salt", "s3", "dstwo", "s1", "passtwo", "s12", "p2", "pass12"]}}
{"id1": "10936821", "id2": "9824814", "code1": "    @Override\n    public void doIt() {\n        try {\n            Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\");\n            if (mode.equals(\"FTP\")) {\n                FTPClient client = new FTPClient();\n                client.connect(Constants.ftpHost);\n                client.login(Constants.ftpUser, Constants.ftpPass);\n                client.changeDirectory(Constants.ftpDir);\n                File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName);\n                client.download(\"GT99_A09.rar\", ff);\n                client.disconnect(false);\n                Shared.prepareMovements(ff);\n            } else if (mode.equals(\"File\")) {\n                JFileChooser jfc = new JFileChooser();\n                FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\");\n                jfc.setFileFilter(f);\n                int selection = jfc.showOpenDialog(Shared.getMyMainWindows());\n                if (selection == JFileChooser.APPROVE_OPTION) {\n                    Shared.prepareMovements(jfc.getSelectedFile());\n                } else {\n                    return;\n                }\n            }\n            Shared.updateMovements();\n            if (Shared.isHadMovements()) {\n                MessageBox msg = new MessageBox(MessageBox.SGN_SUCCESS, \"Fue cargado el nuevo inventario satisfactoriamente!\");\n                msg.show(Shared.getMyMainWindows());\n            } else {\n                MessageBox msg = new MessageBox(MessageBox.SGN_WARNING, \"La tienda no tuvo ningun movimiento asociado.\");\n                msg.show(Shared.getMyMainWindows());\n            }\n        } catch (Exception ex) {\n            MessageBox msg = new MessageBox(MessageBox.SGN_DANGER, \"Ha ocurrido un error.\", ex);\n            msg.show(Shared.getMyMainWindows());\n        }\n    }\n", "code2": "    public void run() {\n        if (status == COMPLETE) {\n            return;\n        }\n        waitRandom();\n        RandomAccessFile file = null;\n        InputStream inputStream = null;\n        boolean success = false;\n        URL url = null;\n        try {\n            BeatportAccessor beatportAccessor = new BeatportAccessor();\n            if (sessionCookies == null) {\n                sessionCookies = beatportAccessor.getSessionCookies(user, password);\n            }\n            url = new URL(new BeatportAccessor().getTrackDownloadUrl(downloadId, sessionCookies));\n            log.info(\"Open (DownloadWorker.run): \" + url);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", BeatportAccessor.userAgent);\n            connection.setRequestProperty(\"Cookie\", sessionCookies);\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                log.error(\"Unexpected response from server: \" + connection.getResponseCode());\n                error();\n                return;\n            }\n            if (connection.getContentType().indexOf(\"text\") >= 0) {\n                log.error(\"Tried to request: \" + url.toString());\n                log.error(\"Unexpected file content type from server: \" + connection.getContentType());\n                log.error(\"Server replied:\\n\" + getContentAsString(connection));\n                error();\n                return;\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                log.error(\"Invalid content length: \" + connection.getContentLength());\n                error();\n                return;\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            } else if (size != contentLength) {\n                changeTotal(0, contentLength - size);\n            }\n            if (new File(tmpFileName(fileName)).exists()) {\n                if (!new File(tmpFileName(fileName)).delete()) {\n                    throw new Exception(\"Could not delete file: \" + tmpFileName(fileName));\n                }\n            }\n            file = new RandomAccessFile(tmpFileName(fileName), \"rw\");\n            file.seek(downloaded);\n            inputStream = connection.getInputStream();\n            if (started == 0) {\n                started = System.currentTimeMillis();\n                time = started;\n            }\n            statusChangedObserver.statusChanged(status);\n            byte buffer[] = new byte[MAX_BUFFER_SIZE];\n            while (status == DOWNLOADING) {\n                if (size - downloaded < MAX_BUFFER_SIZE) {\n                    buffer = new byte[(int) (size - downloaded)];\n                }\n                int read = inputStream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                changeTotal(read, 0);\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                stopped = System.currentTimeMillis();\n                status = COMPLETE;\n            }\n            statusChangedObserver.statusChanged(status);\n            stateChanged();\n            success = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            error();\n        } finally {\n            try {\n                file.close();\n            } catch (Exception e) {\n            }\n            if (success) {\n                try {\n                    if (!new File(tmpFileName(fileName)).renameTo(new File(fileName))) {\n                        throw new Exception(\"Rename Failed\");\n                    }\n                } catch (Exception e) {\n                    log.error(\"Error moving temp file \" + tmpFileName(fileName) + \" file: \" + fileName, e);\n                }\n            } else {\n                try {\n                    new File(tmpFileName(fileName)).delete();\n                } catch (Exception e) {\n                    log.error(\"Error deleting erroneous temp file: \" + tmpFileName(fileName), e);\n                }\n            }\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                log.error(\"Error closing input stream of: \" + url + \" / \" + fileName, e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doIt": [" doSomething", "runit", " doInit", "Doit", "doit", " doit", "DoInit", "runIt", "runSomething", "doSomething", "runInit", "DoIt", "DoSomething", "doInit"], "client": ["force", "resource", "API", "class", "ci", "p", "file", "call", "per", "connection", "host", "parent", "pool", "cl", "cli", "cache", "local", "bird", "api", "conn", "session", "clip", "ip", "app", "co", "server", "user", "connect", "get", "contact", "console", "pg", "plugin", "help", "conv", "Client", "remote", "simple", "grid", "https", "ce", "util", "secure", "ssl", "request", "port", "default", "cp", "web", "socket", "end", "open", "net", "http", "act", "cloud", "and", "close", "cm", "clean", "con", "cell", "i", "config", "project", "url"], "ff": ["ef", "nd", "flow", "feed", "eb", "FF", "lf", "cl", "fe", "fi", "aff", "back", "uf", "bb", "cb", "cd", "buf", "cf", "pp", "buff", "fff", "abb", "cpp", "uff", "kk", "fd", "front", "upp", "fb", "ph", "fl", "bd", "df", "eff", "fp", "fx", "cp", "eph", "ft", "ob", "af", "iff", "sf", "mb", "bf", "url"], "jfc": ["dfc", "jetpc", "jFC", "Jfe", "jetxf", "Jpc", " jbc", "jscf", "jcf", "lfc", "Jbc", "jxf", "fcf", "lcf", "lpc", "jbc", "fbc", "jetfc", "jfe", "lFC", "dfe", "dcf", "jsfc", " jcf", "Jxf", "jpc", " jpc", "fFC", "ffc", "jsfe", "Jcf", "Jfc", "jspc", " jxf", "jetFC", " jFC", "dpc", "JFC"], "f": ["fo", "j", "fac", "self", "lf", "w", "F", "fe", "filter", "fc", "xf", "l", "b", "info", "raf", "c", "cf", "r", "rf", "g", "fd", "t", "fb", "d", "handler", "p", "io", "v", "df", "fp", "fs", "h", "orf", "file", "e", "sf", "i", "n", "m", "s"], "selection": [" selecting", "index", "slot", " selected", "cl", "match", "entry", "which", "slice", "random", "shell", "info", "management", " Selection", "option", "position", " selections", "sc", "select", "si", "sb", "choice", "selected", "ling", "ses", "lection", "election", "expression", "ssl", "Se", "sel", "language", "edition", "SELECT", "qua", "sl", "desc", "delete", "connection", "loc", "location", "url", "directory"], "msg": ["err", "log", "html", "mail", "cmd", "plugin", "module", "send", "link", "view", "global", "exc", "game", "bot", "message", "generic", "mu", "help", "mit", "ms", "list", "cat", "body", "g", "m", "kg", "ck", "mess", "doc", "arg", "conf", "lang", "sg", "gm", "mg", "img", "bug", "Message", "Msg", "comm", "cm", "gs", "live", "gl", "file", "e", "gen", "dm", "error", "og", "pkg", "ng", "bg", "get", "console", "db", "md", "dict", "s"]}}
{"id1": "4973095", "id2": "15904772", "code1": "    public Wget2(URL url, File f) throws IOException {\n        System.out.println(\"bajando: \" + url);\n        if (f == null) {\n            by = new ByteArrayOutputStream();\n        } else {\n            by = new FileOutputStream(f);\n        }\n        URLConnection uc = url.openConnection();\n        if (uc instanceof HttpURLConnection) {\n            leerHttp((HttpURLConnection) uc);\n        } else {\n            throw new IOException(\"solo se pueden descargar url http\");\n        }\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 0, "substitutes": {"url": ["link", "image", "URL", "base", "resource", "lr", "www", "service", "feed", " http", "config", " web", "download", "Url", "open", "bad", "http", "use", "l", "b", "conn", "api", "full", "string", "null", " URL", "c", "r", "buffer", "ado", "path", "not", "uri", "all", "rest", "client", "xml", "ur", "ssl", "server", "host", "file", "ll", "gl", "e", "user", "u", "sl", "str", "lib", "connection", "loc", "source", "web", "address"], "f": ["fo", "fr", "fa", "fat", "inf", "w", "F", "fen", "fi", "fe", "aff", "ref", "fc", "filename", "l", "b", "info", "c", "files", "rf", "g", "buffer", "fd", "t", "d", "fb", "p", "io", "v", "x", "df", "flat", "fp", "fs", "tf", "file", "fn", "e", "sf", "fed", "u", "i", "bf", "m"], "by": ["body", "re", "log", "html", "j", "service", "in", "feed", "serv", "content", "to", "with", "open", "BY", "via", "from", "r", "buffer", "it", "v", "out", "as", "report", "ssl", "server", "By", "browser", "reader", "or", "acc", "source", "web"], "uc": ["lc", "UC", "uu", "FC", "uh", "cci", "ud", "dc", "ub", "coll", "ul", "usc", "pc", "cur", "http", "fc", "cu", "conn", "ws", "uci", "contract", "soc", "c", "cf", "ct", "rc", "BC", "sc", "ci", "https", "SC", "su", "unc", "acc", "xc", "client", "cc", "cas", "cus", "ucc", "auc", "us", "ac", "tc", "ec", "con", "cv", "cca", "mc", "u", "ru", "bc", "connection", "loc"]}}
{"id1": "9371421", "id2": "14785308", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"eventHash": ["messageKey", "messageDig", "byteDig", " eventKey", "eventKey", "messagehash", "byteHash", "messageHash", "byteKey", "bytehash", "eventhash", " eventhash", "eventDig", " eventDig"], "eventstr": [" eventsource", " eventdict", "errorsource", "Eventsource", "exdict", "errorstring", "exstr", "errorStr", "eventdict", "eventsource", "Eventstring", "exstring", "Eventdict", "EventStr", " eventstring", "Eventstr", " eventStr", "errorstr", "eventstring", "eventStr", "exStr"], "md": ["dd", "sha", "cmd", "dr", "dig", "metadata", "ma", "amd", " MD", "hd", "mm", "mo", "mu", "key", "ke", "ms", "ld", "wd", "mp", "vd", "hash", "mn", "d", "m", "mand", "bd", "doc", "ad", "pm", "mt", "sm", "mac", "mg", "od", "cm", "MD", "map", "mod", "id", "data", "dh", "mag", "dm", "mc", "mem", "em", "ng", "hm", "mb", "di", "meta", "rpm"], "theDigest": ["Thedigester", "Thedigest", " theSignest", " theSignhest", "theSignEST", "thedigEST", "ThedigEST", "thedigest", " theDighest", "theHashester", " theDigester", "TheDigEST", "thedighest", "TheDigester", "TheDigest", " theSignester", "theDighest", "theHashest", "theDigEST", "theHashEST", "thedigester", " theSignEST", "theSignhest", "theSignester", "theSignest", " theDigEST", "theDigester"]}}
{"id1": "21092340", "id2": "19096138", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addToSlives", "addtoAsively", "addToAdaptive", "addtoAsives", "addToAdaptively", "addtoArchIVE", "addToAsives", "addToArchIVE", "addToAdaptives", "addToArchives", "addToAsIVE", "addtoAsIVE", "addtoAsive", "addToSlive", "addToAsively", "addToArchively", "addToAsive", "addtoArchive", "addToAdaptIVE", "addToSlively", "addtoArchives", "addToSlIVE", "addtoArchively"], "pod": ["module", "child", "po", "pc", "Pod", "zip", "cache", "table", "post", "object", "pad", "product", "pi", "pe", "node", "pl", "pid", "p", "ad", "part", "pot", "plug", "proc", "ce", "od", "tmp", "loader", "bean", "peer", "component", "ods", "host", "cer", "pkg", "per", "project", "plugin"], "podArchiveOutputStream": ["podArchivingOutputSteam", "podArchiveByteDirectory", "podArchiveWriteSteam", "podArchivingWriteFile", "podArchiveWriteStream", "podArchiveInputStream", "podArchiveFilePath", "podArchiveInputPath", "podArchiveByteSteam", "podArchiveOutputPath", "podArchivesOutputSteam", "podArchiveByteStream", "podArchiveOperationSteam", "podArchiveOutputDirectory", "podArchivesFileResource", "podArchiveFileFile", "podArchIVEInputFile", "podArchivingOutputFile", "podArchiveOperationStream", "podArchivesOutputStream", "podArchiveOperationResource", "podArchiveOutputSteam", "podArchIVEInputStream", "podArchiveFileDirectory", "podArchiveIOResource", "podArchiveWriteFile", "podArchIVEOutputStream", "podArchiveInputFile", "podArchiveInputDirectory", "podArchiveOperationFile", "podArchivesFileStream", "podArchivingWriteSteam", "podArchiveIOFile", "podArchIVEOutputDirectory", "podArchiveIOSteam", "podArchiveFileStream", "podArchiveFileResource", "podArchiveInputSteam", "podArchivingOutputStream", "podArchiveOutputResource", "podArchivesOutputFile", "podArchivesOutputResource", "podArchiveByteFile", "podArchivingOutputPath", "podArchIVEOutputFile", "podArchIVEInputSteam", "podArchivesFileFile", "podArchiveOutputFile", "podArchiveIODirectory", "podArchiveFileSteam", "podArchivesFileSteam", "podArchivingWritePath", "podArchIVEOutputSteam", "podArchivingWriteStream", "podArchiveIOStream", "podArchiveWritePath", "podArchIVEInputDirectory"], "filename": ["folder", "module", "prefix", "kn", "dll", "sequence", "alias", "download", "which", "property", "platform", "l", "label", "string", "application", "files", "subject", "route", "path", "kl", "fil", "Filename", "uri", "SourceFile", "named", "fp", "ename", "FILE", "il", "loader", "name", "location", "title", "nil", "word", "archive", "file", "fn", "binary", "username", "sf", "database", "f", "url", "ppa", "directory"], "source": ["image", "unit", "slave", "service", "resource", "SOURCE", "stream", "Source", "input", "target", "src", "text", "zip", "slice", "output", "stack", "use", "string", "driver", "path", "ource", "result", "uri", "loader", "proxy", "archive", "file", "document", "seed", "sl", "reader", "connection", "config", "parent", "url", "copy"], "entry": ["image", "letter", "index", "resource", "child", "feed", "this", "stream", "event", "obj", "zip", "Entry", "add", "post", "object", "auto", "string", "element", "r", "path", "ie", "line", "record", "result", "pointer", "it", "se", "row", "article", "ge", "archive", "data", "file", "e", "iterator", "reader", "or", "connection", "parent", "address"]}}
{"id1": "20247400", "id2": "11865906", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"in": ["image", "login", "this", "stream", "gin", "inn", "inner", "input", "In", "l", "bin", "b", "c", "IN", "r", "again", "pass", "token", "p", "source", "part", "nin", "diff", "client", "ins", "a", "con", "h", "data", "isin", "i", "reader", "win", "n", "connection", "config", "din", "parent", "f", "socket", "inc", "s"], "out": ["err", "image", "log", "flow", "pool", "o", "temp", "outer", "prefix", "inner", "debug", "w", "write", "window", "channel", "group", "up", "exp", "cache", "output", "OUT", "list", "writer", "connection", "conn", "page", "print", "style", "r", "again", "line", "io", "v", "Out", "client", "off", "name", "socket", "ext", "word", "dump", "sys", "server", "user", "file", "call", "lock", "error", "str", "comment", "ex", "i", "console", "msg", "source", "exec", "obj", "inc"], "buffer": ["flow", "slave", "base", "wave", "feed", "offset", "flush", "input", "channel", "window", "cache", "count", "slice", "output", "queue", "b", "bin", "writer", "pad", "null", "read", "buf", "buff", "border", "abi", "fb", "uffer", "result", "layer", "length", "context", "size", "loader", "pause", "bar", "server", "data", "reference", "binary", "document", "transfer", "limit", "reader", "iter", "batch", "config", "source", "Buffer", "f", "header"]}}
{"id1": "8430178", "id2": "18613870", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", "transferFile", "CopyFile", "transferPath", " copyfile", "Copyfile", " copyPath", "copyfile", "copyFiles", "copyPath", "CopyPath", "CopyFiles"], "source_name": ["Source_file", "source_key", "source_uri", "source_Name", "src_name", "src_file", "source_names", "sourceCname", "sourceNtype", "source_size", "source_data", "Source_data", "src_alias", "source_alias", "sourceNname", " source_Name", "Source_name", "source_type", "src_uri", "sourceNalias", "src_size", "sourceNfile", "source_path", "sourceCfile", "sourceCtype", "sourceCalias", " source_path", " source_key", " source_names", "src_type"], "dest_name": ["dest_resource", "destappnames", "dest_id", " dest_path", "destFilename", "destFilenamed", " destination_resource", "dest_none", "dest_word", " destinationFresource", " dest_none", "destflabel", "source_Name", "destRdefinition", "target_names", "destJnames", "destPmodel", "destPtype", "source_names", "dest_definition", "Dest_id", "destPpath", "destPword", "target_type", "destapptype", " dest_type", "dest_names", " dest_names", "destRName", " dest_Name", " destinationFpath", "destRpath", "destRname", " destination_name", "dest_label", "destJname", "destJword", " dest_file", " destination_path", "dest_named", "destFname", " dest_named", "Dest_name", "destFpath", "target_model", "destJName", "destFilelabel", "destfnamed", "dest_model", " dest_word", "destffile", " destinationFinfo", "source_path", " dest_label", " dest_definition", "destPnames", "destPname", "destFilefile", "dest_file", "target_name", "Dest_path", "dest_Name", "dest_type", " destinationFname", "destappname", "dest_path", "destFresource", "dest_info", "destfname", "Dest_Name", "destPName", "destFinfo", "destappmodel", " destination_info"], "source_file": ["source_url", "source_File", "ource_line", "sourcefname", "src_name", "source_class", "src_file", " source_class", "source_files", "source_stream", "source__name", "source__class", "sourceffile", "source__base", "source_base", " source_url", "sourcefFile", "source__file", "ource_file", " source_base", " source_cache", "ource_files", " source_File", "src_files", " source_files", "src_stream", "source_line", "source_cache", "sourcefurl", "ource_name"], "destination_file": ["destention_name", "destination_files", "destination_page", "destination2file", "destation_name", "destention4file", "destinate_files", "destation_folder", "destination2name", "destinationablefile", "destination_path", "destention_source", "destination4file", "destinate_base", "destination4source", "destinationablebase", "destention_path", "destation_function", "destination_folder", "destination_name", "destination_source", "destention_file", "destention4source", "destation_file", "destinationablefiles", "destention4path", "destination2source", "destinate_file", "destination4path", "destinationablepage", "destention4name", "destation_files", "destination_function", "destination4name", "destinate_page", "destination2path", "destination_base"], "source": ["image", "resources", "unit", "slave", "ize", "service", "resource", "SOURCE", "index", "site", "storage", "view", "stream", "Source", "current", "inner", "input", "open", "target", "master", "src", "cache", "load", "local", "slice", "output", "remote", "object", "scope", "ources", "via", "class", "from", "spec", "core", "single", "ource", "result", "uri", "dest", "diff", "client", "secure", "ite", "start", "name", "proxy", "search", "server", "file", "reference", "reader", "get", "connection", "config", "parent", "copy"], "destination": ["Destension", "destension", "foreigninated", "constining", "targetinate", "destinator", " destina", "targetination", "destribution", "Destination", "variinator", " destinator", "testribution", "foreigninator", "Destinated", "destina", " destining", "validination", "dependinate", "variinate", "coordination", "foreigninate", "constribution", "descinated", "testinated", "variination", "Destinator", "identination", "validinator", "testinator", "variinated", "identribution", "identinated", "Destining", "coordinated", "dependination", "targetinator", "destinate", "destinated", "testination", "descination", "constination", "coordension", "identina", "dependinator", "foreignination", "constinator", "Destina", " destinated", "coordinator", "dependinated", "Destribution", " destribution", "descinator", "destining", "validinate", "targetinated", "descension", "validinated"], "buffer": ["image", "pool", "temp", "flush", "sequence", "input", "window", "channel", "text", "cache", "queue", "writer", "bin", "buf", "buff", "Buffer", "padding", "uffer", "block", "binary", "transfer", "limit", "reader", "timeout", "iter", "batch", "memory", "header"], "bytes_read": ["bytesUnRead", "Bytes_set", "bytesUnread", "bytes_set", "bytesUnset", "Bytes_found", "bytesUnfound", "bytes_found", "Bytes_read", "Bytes_Read", "bytes_Read"], "in": ["ini", "image", "re", "log", "resource", "login", "temp", "serv", "stream", "inner", "current", "inn", "val", "input", "din", "In", "fe", "rec", "l", "bin", "b", "read", "r", "IN", "session", "again", "token", "path", "p", "doc", "line", "nin", "container", "min", "out", "ins", "is", "as", "ssl", "a", "request", "con", "h", "data", "file", "id", "lock", "reader", "get", "n", "or", "connection", "f", "url", "inc", "s"], "response": ["re", "body", "onse", "image", "model", "answer", "resource", "feed", "question", "view", "sequence", "Response", "respons", "json", "version", "reason", "offer", "text", "message", "reset", "output", "api", "respond", "object", "update", "status", "example", "string", "application", "r", "resp", "next", "success", "line", "result", "uri", "su", "report", "received", "request", "server", "data", "true", "error", "description", "value", "res", "location", "reply", "dict", "header"], "parentdir": ["parentDir", "parentdict", "parentfile", "partlib", " parentdirectory", "rootdir", "parentsDir", "partdirectory", "Parentdir", "parentdiff", "hostdirectory", "rootfile", "partfile", " parentdict", " parentfile", " parentlib", "partdir", "parentlib", "parentsfile", "rootdirectory", "parentsdir", "rootlib", "homefile", "parentsdiff", "hostdir", "homeDir", "homediff", " parentDir", " parentdiff", "Parentdirectory", "homedir", "Parentdict", "hostdict", "parentdirectory"]}}
{"id1": "14794404", "id2": "9033639", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["EncipherSecret", "encressSecret", "encipherString", "EncryptPassword", "encresspassword", "EncryptSecret", "encryptedpassword", "encressString", "encipherpassword", "EncipherPassword", "encryptedString", "encryptedSecret", "encressPassword", "encryptpassword", "encipherPassword", "encryptSecret", "encipherSecret", "encryptString", "Encryptpassword", "Encipherpassword", "EncryptString", "EncipherString"], "password": ["enc", "Password", "resource", "email", "prefix", "content", "input", " passwords", "pattern", "channel", "text", "message", "cache", "wd", "object", "device", "string", "definition", "array", "params", "buffer", "pass", "crypt", "token", "path", "padding", "phrase", "p", "attribute", "secret", "name", "PASS", "word", "data", "username", "sword", "description", "database", "words", "connection", "address"], "encryptedPassword": ["protectedString", "encryptedCode", "lockedString", " encryptedString", "protectedPass", " encryptedpassword", "encryptedPass", "lockedpassword", "encryptedpassword", "protectedCode", "protectedpassword", "ryptedString", "protectedPassword", "ryptedCode", "encryptedString", " encryptedPass", "ryptedpassword", "lockedPassword", "ryptedPass", "ryptedPassword", "lockedPass", " encryptedCode"], "md5": ["MD4", "digdown", "md6", "MD512", "MD5", " md6", "md512", " MD2", "MD45", " md512", "dig45", "md2", "md4", "mddown", " md2", " MD512", "MD6", "dig2", " MD5", "MDdown", "dig4", " md3", "amd4", " md4", "MD2", "MD3", "amd6", "dig3", "dig5", "amd2", " MD3", " mddown", "md45", " md45", "amd5", "md3"], "digest": ["digher", "Digher", "mdested", "Digenge", "digment", "digash", "mdests", "mdest", "mdash", " digher", "mdace", "encester", "digester", "Digests", "mdher", " digash", " digests", "signests", "Digester", " digment", "digenge", " digenge", " digace", "digests", "Digested", "Digace", "mdester", "mdenge", "encest", "signest", "signester", "digace", "encash", "digested", "signested", "Digest", " digester", "mdment", "encment"], "i": ["index", "j", "o", "oi", "hi", "phi", "ii", "ix", "l", "b", "ui", "ri", "pi", "c", "r", "gi", "t", "d", "li", "k", "ci", "p", "ie", "multi", "si", "io", "xi", "bi", "I", "v", "x", "ai", "it", "uri", "ip", "length", "ti", "h", "id", "qi", "e", "u", "di", "f", "zi", "s"], "hex": ["enc", "coord", "letter", "num", "temp", "prefix", "closure", "lit", "check", "mix", "none", "bits", "stick", "ix", "pattern", "serial", "oct", "alpha", "exp", "text", "zip", "bit", "sex", "slice", "bin", "pex", "utf", "ctr", "string", "hash", "null", "buff", "shift", "rh", "comp", "sign", "ip", "pixel", "length", "pack", "digit", "ext", "rex", "data", "id", "nexus", "binary", "char", "str", "ex", "di"]}}
{"id1": "9857412", "id2": "732800", "code1": "    @Override\n    public void writeData(byte[] data, byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        OutputStream os = urlc.getOutputStream();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        byte[] buffer = new byte[1024];\n        int br;\n        while ((br = bis.read(buffer)) > 0) {\n            os.write(buffer, 0, br);\n            if (!transferMetaData) {\n                transferredBytesNum += br;\n                elapsedTime = System.currentTimeMillis() - startTime;\n                fireOnProgressEvent(transferredBytesNum, elapsedTime);\n            }\n        }\n        bis.close();\n        os.close();\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 0, "substitutes": {"writeData": [" writeDATA", "sendDATA", "outputDATA", "outputData", "writeBytes", "sendBytes", "sendData", "writePart", "outputBytes", "writeDATA", "outputPart", "sendPart", " writeBytes", " writePart"], "data": ["body", "image", "video", "resources", "resource", "content", "sample", "dat", "sequence", "input", "json", "text", "cache", "load", "queue", "media", "bytes", "connection", "array", "buf", "DATA", "multi", "result", "response", "memory", "binary", "value", "database", "reader", "timeout", "batch", "config", "source", "address"], "options": ["resources", "vals", "resource", "meta", "keys", "ops", "json", "bits", "details", "cache", "times", "Options", "properties", "table", "bytes", "object", "info", "scope", "style", "option", "files", "params", "headers", "groups", "settings", "io", "opt", "values", "parts", "flags", "results", "ts", "config", "obj", "address"], "transferMetaData": ["transferMetLast", "transferMetaDATA", "transferDataName", "transfermetaData", "sendMetaScript", "transferMetaLast", "transferMediaDATA", "sendMetaDATA", "transferDataHash", " transferMetLeft", "ferDataHash", "ferMetaData", "transferMediaData", "transfermetaDATA", "transfermetaLeft", " transferMetLast", "transferDataScript", " transferMetData", "ferDataScript", "sendMetaData", "transfermetaHash", " transferMetaBreak", "transferMetaHash", "transferMetLeft", "transferMetaBreak", "transferMediaBreak", "transferMetData", "transferMetaName", "transfermetaLast", "transferMetBreak", "transferMediaScript", "ferDataData", " transferMetaLast", "transferDataData", "transfermetaName", " transferMetaLeft", "ferMetaScript", "transfermetaScript", "transfermetaBreak", "transferMetaLeft", "ferMetaHash", " transferMetBreak", "sendMetaBreak", "transferMetaScript", "ferDataName", "ferMetaName"], "startTime": ["initTim", "StartLine", "StartTim", "startedTime", "startedPoint", "StartPoint", "startTim", "startPoint", "startLine", "StartStream", " startLine", "initStream", "StartTime", "initLine", "startedLine", " startPoint", " startTim", "startStream", "initTime", " startStream"], "transferredBytesNum": ["transferredByteChan", "transendedBytesMon", "transferredBytesLen", "translatedbytesSum", "transferredBytesVal", "transferredBytesSum", "transferredSharesSum", "transferredFilesMon", "transendedByteNum", "transendedByteSum", "transendedByteMon", "transferredFilesNum", "transferredbytesMon", "translatedPagesLen", "transferredbytesBu", "translatedbytesVal", "translatedbytesNum", "transferredByteVal", "translatedBytesLen", "transferredPagesMon", "transferredFramesMon", "transferredBytesMon", "transferredTokensMon", "transferredSharesVal", "translatedPagesMon", "transferredByteMon", "transferredByteSum", "transendedBytesChan", "transferredbytesLen", "transferredbytesSum", "transferredTokensSum", "transferredPagesBu", "transferredByteNum", "transferredFilesBu", "transferredPagesLen", "translatedBytesVal", "translatedBytesNum", "translatedPagesNum", "translatedBytesSum", "translatedPagesBu", "transferredSharesNum", "transferredFramesNum", "transferredBytesChan", "translatedBytesMon", "transendedBytesNum", "transferredFilesLen", "transferredBytesBu", "transferredbytesNum", "transferredTokensNum", "translatedBytesBu", "transferredFramesSum", "transferredFramesChan", "transferredPagesNum", "transendedByteChan", "transendedBytesSum", "transferredTokensChan", "transferredbytesVal"], "elapsedTime": ["elocatedTimes", "elayedTime", "elroredForce", "elapsedTimes", " elavedValue", "ElapsedDuration", "ElapseValue", "elapseTimes", "elapseTime", "elavedForce", "elivedTime", "elroredTimes", "ElapseTimes", "elivedtime", "elocatedValue", " elavedTime", " elapsedValue", "elapsedtime", "elayedDuration", "elayedtime", "elivedDuration", "ElapseTime", "ElapsedTime", "elapsedValue", "elavedValue", "elavedTime", "ElapsedValue", " elapsedForce", "elapsedForce", "Elapsedtime", "ElapseDuration", "elapseValue", "elocatedTime", "Elapsetime", "elapsedDuration", "ElapsedTimes", "elapsetime", " elavedForce", "elapseForce", "elroredValue", "elapseDuration", "elroredTime"], "opts": ["optments", "otts", "prefs", "OPty", " oprs", "opters", "obTS", "optte", "copTS", "coprs", "OPte", "obtr", "OPTS", "optts", "opments", "OPters", "OPtt", "opter", "optr", " opte", "copments", " optfs", " opty", " optters", "oprs", "OPps", " optts", "opttt", "opty", "opps", " optt", " opps", " optte", "otter", "copts", "otTS", "prets", "opTS", "opte", "optt", "obter", " opments", "optty", " opTS", "OPter", "OPts", "preters", "optTS", "optrs", "optps", "OPtr", "obts", "ottr", "OPfs", "prete", "opfs"], "server": ["folder", "erver", "service", "resource", "email", "system", "localhost", "site", "serv", "prefix", "domain", "version", "http", "string", "path", "type", "uri", "Server", "client", "secret", "socket", "name", "ssl", "sys", "peer", "user", "port", "ser", "value", "database", "host", "address"], "username": ["method", "login", "email", "account", "prefix", "mobile", "profile", "property", "nick", "filename", "key", "info", "ui", "uid", "string", "ame", "usr", "subject", "family", "token", "path", "attribute", "uri", "client", "character", "users", "manager", "auth", "name", "staff", "ername", "user", "dn", "port", "header", "person", "sword", "database", "config", "USER", "machine", "address"], "password": ["Password", "resource", "mask", "account", "prefix", " passwords", "channel", "nick", "key", "column", "wallet", "wd", "pad", "session", "params", "pass", "token", "padding", "path", "phrase", "attribute", "priv", "uri", "secret", "client", "auth", "name", "PASS", "word", "user", "port", "sword", "fax", "profile", "sudo", "device"], "filePath": ["FILEParent", "basePath", "singlePath", "Filepath", " filePoint", "FileUrl", "resourcepath", "fileType", "FILEUrl", "FILEName", "resourceInfo", "baseName", "workName", "resourcePath", "FILEHandler", "FILEPath", "FilePath", "fileParent", "workType", "FILEPoint", "FileName", "fileHandler", " fileUrl", " fileType", "singlepath", "workpath", "FileParent", "singleUrl", "resourceName", "singleName", "fileUrl", " fileInfo", "basepath", "resourceType", "resourceUrl", "filepath", "fileInfo", "filePoint", "workPath", "FileHandler", " filepath", "FILEpath", " fileParent", "singleInfo", "FilePoint", " fileHandler", "baseUrl"], "idx": ["IDx", " idv", "pidX", "Idxc", "IdX", "indxc", "idc", "Idx", "intv", "indxs", " idy", "idy", "indn", "intx", "IDX", "indX", "idxs", "Idy", " idX", "pidx", " idn", "indv", "intX", "idn", "indc", "idxc", "idX", " idc", "Idn", "indy", "intxs", " idxs", "idv", "IDy", "IDn", "pidn", " idxc", "indx", "pidc"], "fileName": ["resourceInfo", "FileInfo", " filePart", "filename", "resourcePath", "sourcePath", "FilePart", "FilePath", "filePart", "FileName", "resourcePart", "Filename", "sourceName", " filename", "sourcePart", "resourceName", " fileInfo", "fileInfo", "sourcename"], "url": ["z", "URL", "base", "resource", "o", "service", "www", "impl", "Url", "json", "open", "http", "l", "b", "bb", "api", "object", "page", "bel", "g", "t", "li", "fl", "p", "io", "org", "uri", "build", "v", "client", "ssl", "proxy", "user", "gl", "browser", "str", "sl", "i", "connection", "config", "host", "web", "f"], "urlc": ["slc", "servercode", "httpci", "webac", "webf", "httpcf", "urlcode", "webfc", "downloadfc", "downloadc", "httpp", " urlC", "urlcf", "slci", "urlC", "httpf", "urlp", "urlfc", " urlfc", "slp", "downloadC", "urlf", "URLfc", "downloadci", "httpc", " urlci", "serverfc", "urlac", "URLci", "serverf", " urlp", " urlcf", "urlci", " urlf", "URLc", " urlac", " urlcode", "serverc", "webp", "webc", "webcode", "URLC", "httpac", "slcf"], "os": ["o", "ops", "bits", "osi", "bos", "dos", "http", "mos", "conn", "so", "pos", "obs", "ors", "ps", "boot", "io", "ros", "Os", "oid", "oss", "out", "fs", "is", "cos", "iso", "oS", "socket", "us", "ori", "las", "bs", "oa", "oses", "ob", "ot", "OS", "ios", "i", "oos", "fits", "los", "aos", "oi", "obj", "s"], "bis": ["pins", "rots", " Bis", "abs", "bits", "ls", "dos", "bos", "alis", "lins", "nis", "cache", "lis", "b", "bytes", "bb", "cb", "usb", "ri", "buff", "ubis", "obs", "abi", "fb", "bes", "boot", "ris", "obb", "bi", "sb", "oss", "uds", "sis", "fs", "ins", "is", "cos", "ses", "ori", "ois", "phys", "co", "bs", "opus", " bos", "bps", "ob", " cis", "ios", "ais", "los", "aos", "oi", "obj"], "buffer": ["resource", "button", "feed", "this", "flush", "sequence", "channel", "available", "window", "message", "cache", "queue", "table", "b", "bb", "texture", "string", "buf", "position", "buff", "border", "vector", "Buffer", "padding", "uffer", "layer", "block", "length", "FFER", "pause", "reference", "binary", "document", "value", "reader", "timeout", "iter", "batch", "source", "memory", "header", "device"], "br": ["err", "ver", "j", "dr", "lr", "fr", "bal", "bl", "arr", "pre", "gap", "ler", "yr", "bridge", "b", "ctr", "cb", "bh", "ch", "bp", "buf", "ber", "r", "aa", "gr", "tr", "wr", "next", "li", "bro", "bf", "bd", "p", "line", "div", "Br", "width", "bi", "BR", "nr", "bre", "mr", "img", "block", "length", "hr", "cm", "bar", "bn", "rib", "span", "char", "str", "el", "i", " Br", "bc", "or", "ele", "cr", "shr", "obj"]}}
{"id1": "5142039", "id2": "18631594", "code1": "    public static String uncompress(String readPath, boolean mkdir) throws Exception {\n        ZipArchiveInputStream arcInputStream = new ZipArchiveInputStream(new FileInputStream(readPath));\n        BufferedInputStream bis = new BufferedInputStream(arcInputStream);\n        File baseDir = new File(readPath).getParentFile();\n        String basePath = baseDir.getPath() + \"/\";\n        if (mkdir) {\n            String[] schema = readPath.split(\"/\");\n            String baseName = schema[schema.length - 1].replaceAll(\".zip\", \"\");\n            FileUtils.forceMkdir(new File(basePath + baseName));\n            basePath = basePath + baseName + \"/\";\n        }\n        ArchiveEntry entry;\n        while ((entry = arcInputStream.getNextEntry()) != null) {\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(basePath + entry.getName()));\n            } else {\n                String writePath = basePath + entry.getName();\n                String dirName = FilenameUtils.getPath(writePath);\n                FileUtils.forceMkdir(new File(dirName));\n                BufferedOutputStream bos = new BufferedOutputStream(FileUtils.openOutputStream(new File(writePath)));\n                int i = 0;\n                while ((i = bis.read()) != -1) {\n                    bos.write(i);\n                }\n                IOUtils.closeQuietly(bos);\n            }\n        }\n        IOUtils.closeQuietly(bis);\n        return basePath;\n    }\n", "code2": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "label": 0, "substitutes": {"uncompress": ["uncompressed", "uncompzip", "uncopzip", " unompzip", " uncompression", "unompressed", " uncompressed", " unompress", "uncopression", "uncompression", " unompressed", "unCompress", " unompression", "uncopressed", "unompzip", "unompression", "unCompressed", "unCompression", "unompress", "uncopress", " uncompzip", "unCompzip"], "readPath": ["writeCase", "baseTree", "readTree", " readFile", "loadpath", "writePo", "loadPo", "loadWith", "loadFile", "loadDir", "scanDir", "checkPo", "workTree", "loadCase", "readerPath", "baseWith", "loadPath", "checkPath", "readWith", "writeDir", "readPo", " readWith", "writeFile", "workFile", "readCase", "scanPath", "readDir", "baseFile", "scanCase", "scanpath", "workpath", "readerpath", "basepath", "checkDir", "checkFile", "readpath", "readFile", "workPath", "writepath", "readerTree", "readerFile", " readpath"], "mkdir": ["MKdir", "MKDir", "kkrel", "kkdir", "ckDir", " mkDir", "muturl", "mkrel", " mkdb", " mkrel", "MKrel", "mkDir", "ckurl", "mutdir", "kkzip", "MKzip", "mutDir", " mkurl", "ckdb", "ckdir", "mkdb", "mutdb", "mkzip", " mkzip", "mkurl", "kkDir"], "arcInputStream": ["ancInputFile", "ancOutputFile", "arcFileStream", "arcReadStream", "cInputStream", "cOutputSync", "arcHttpStream", "arcReaderChannel", "arcOutputChannel", "arcImportChannel", "arcReadstream", "arcOutputFile", "arcHttpForm", "arcInputFile", "ancOutputStream", "arcOutputSt", "arcOutputstream", "ancInputChannel", "arcOutputForm", "arcFileSteam", "arcReaderStream", "cInputSteam", "arcFileSt", "ancInputstream", "arcInputChannel", "arcReadSync", "ancInputForm", "cInputSt", "ancOutputChannel", "cOutputStream", "ancInputStream", "arcHttpstream", "arcFileSync", "arcReadSteam", "arcOutputStream", "arcHttpSteam", "arcInputstream", "cOutputSt", "arcInputSt", "cOutputSteam", "arcOutputSync", "arcInputSteam", "arcInputForm", "arcInputSync", "arcImportstream", "arcReaderFile", "arcReaderstream", "arcReadForm", "arcImportFile", "arcImportStream", "ancOutputstream", "cInputSync", "ancOutputSteam", "ancInputSteam", "arcOutputSteam", "arcReadSt", "ancOutputForm"], "bis": ["pins", "ours", "kos", "lus", "vs", "abs", "mis", "bits", "ls", "alis", "bid", "lins", "bb", "cb", "raf", "usb", "idis", "ubis", "obs", "abi", "fb", "boot", "onis", "ris", "ros", "obb", "bi", "os", "ras", "oss", "uds", "phis", "banks", "sis", "ins", "is", "cos", "ses", "ubs", "phys", "ois", "bs", "isin", "oris", "binary", "bps", "ios", "BUS", "bus", "parts"], "baseDir": ["BaseDir", "baseFolder", " baseDirectory", "rootDir", "basedir", "BaseDirectory", "baseDirectory", "Basedir", "fileFolder", " baseFolder", "BasePath", "BaseFolder", "rootFolder", "fileDir", "filedir", "fileDirectory", " basedir", "rootPath", "rootDirectory"], "basePath": ["basicCondition", "BaseName", "BaseDir", "baseCondition", "baseStream", "buildType", "baseHost", " baseStream", "BaseFile", " baseUrl", "fileName", "resourcepath", "parentUrl", "filePath", "resourceDir", "BaseInfo", "basicPath", "viewPath", "basicInfo", "basedPath", "BaseUrl", "writeHome", "buildPath", "basedType", "resourcePath", "writeStream", "viewStream", " baseHost", "baseInfo", "parentFile", "basedDir", " baseOrder", " baseType", "parentName", "buildHost", "outDir", "viewHome", "BasePath", "basedHost", "baseOrder", "writeOrder", "readDir", "buildDir", "baseFile", "readUrl", "BaseCondition", "baseHome", "outUrl", "parentPath", "fileDir", "resourceName", " baseFile", "fileUrl", "basepath", "readName", " basepath", "outName", "readCondition", "Basepath", "outPath", "basicDir", "readInfo", " baseHome", "viewOrder", "baseType", "baseUrl"], "schema": ["mama", "Schema", " scheme", "cheaga", "mame", "cheme", "scheme", "syaga", "Scheme", "syme", "mapa", "chema", "issma", "issmas", "mamas", "issme", "Schemas", "schepa", "chemar", "syma", "schemar", "Schemar", " schemas", "schemas", "Schepa", "chemas", "scheaga", "symas", "isspa", " schemar", "Scheaga"], "baseName": ["BaseName", "basDir", "basicKey", "basInfo", "basName", "areaName", "areaPath", "BaseKey", "normalTitle", "basicName", " baseKey", "coreInfo", "normalPath", "areaKey", "baseInfo", " baseTitle", "normalKey", " baseInfo", "BasePath", "baseTitle", "BaseTitle", "coreDir", "normalName", "coreName", "baseKey", "corePath", "basPath", "basicPath"], "entry": ["lc", "her", "de", "index", "base", "letter", "service", "nt", "system", "feed", "office", "section", "child", "inner", "je", "ry", "parse", "zip", "Entry", "exp", "add", "journal", "key", "info", "post", "object", "extra", "style", "element", "pe", "cel", "ace", "next", "path", "ie", "part", "line", "record", "result", "se", "ent", "uri", "it", "entity", "si", "row", "le", "article", "name", "la", "ae", "ge", "archive", "server", "data", "ries", "sea", "e", "valid", "card", "iterator", "comment", "no", "reader", "enter", "or", "connection", "inc", "install", "obj", "editor"], "writePath": ["writeCase", "baseStream", " writeCase", "WriteDir", "writtenPath", " writeDir", "WritePath", "writeCh", "writtenStream", "writtenName", "writeStream", "writerEx", "writeName", "writerPath", "writeDir", "readPoint", "basePoint", "readCase", "readDir", "writeEx", " writeCh", "writerDir", "writingPoint", "writePoint", "writtenPoint", "readStream", "readName", "WriteEx", " writePoint", "writerCh", "writingCase", "WriteCh", "writingDir", "writingPath", " writeEx"], "dirName": ["orderUrl", "Dirname", "ordername", "DirDef", "DirName", "DIRAlias", " dirDef", "dirname", " dirAlias", "dirDef", " dirname", "DirUrl", " dirPath", "DIRName", "orderName", "DIRPath", "dirPath", "DirAlias", " dirUrl", "dirAlias", "DIRDef", "DirPath", "dirUrl"], "bos": ["bo", "rots", "asio", "zos", "osa", "kos", "atis", "dies", "osi", "lins", "bas", "bb", "boards", "bones", "gb", "obo", "ubis", "obs", "bies", "zo", "bes", "boot", "ros", "obb", "obos", "os", "bi", "oids", "uds", "oks", "banks", "bott", "ubs", "las", "ois", "ko", "nas", "bs", "opus", "ios", "oos", "fits", "bc", "los", "aos", "obi"], "i": ["ini", "z", "index", "j", "o", "batch", "chi", "in", "hi", "inner", "phi", "ii", "mini", "slice", "l", "b", "info", "ui", "ri", "pi", "c", "r", "abi", "li", "ci", "p", "multi", "si", "xi", "ni", "bi", "io", "v", "uri", "ai", "ji", "it", "x", "ip", "is", "length", "start", "a", "qi", "id", "e", "limit", "f", "di", "you", "exec", "I", "zi", "s"]}}
{"id1": "16048516", "id2": "18097962", "code1": "    public static SVNConfiguracion load(URL urlConfiguracion) {\n        SVNConfiguracion configuracion = null;\n        try {\n            XMLDecoder xenc = new XMLDecoder(urlConfiguracion.openStream());\n            configuracion = (SVNConfiguracion) xenc.readObject();\n            configuracion.setFicheroConfiguracion(urlConfiguracion);\n            xenc.close();\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        }\n        return configuracion;\n    }\n", "code2": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "label": 0, "substitutes": {"load": ["create", "content", "check", "transform", "download", "open", "parse", "add", "process", "update", "show", "read", "set", "loaded", "LOAD", "upload", "build", "start", "loader", "init", "oad", "dump", "Load", "loads", "get", "install", "save"], "urlConfiguracion": ["urlconfigaurator", "urlConfigureacion", "urlConfigurateator", "urlConfuration", "urlConfigureaci", "urlConfigureator", "urlConfigurateaci", "urlConfiguration", "urlconfigauraci", "urlConfigauracion", "urlconfiguraton", "urlconfiguracion", "urlConfigureado", "urlConfigurator", "urlConfigauraton", "urlConfigurerator", "urlConfureator", "urlConfigURacion", "urlConfigURator", "urlConfigurateacion", "urlConfigutabet", "urlConfigURaton", "urlConfiguraton", "urlConfigureation", "urlConfigurado", "urlConfuraci", "urlconfigurator", "urlConfigutado", "urlConfigutator", "urlConfigureaton", "urlConfurator", "urlConfureation", "urlConfiguraci", "urlconfiguraci", "urlConfuracion", "urlconfigauraton", "urlConfigURaci", "urlconfigauracion", "urlConfigurateation", "urlConfigauraci", "urlConfigaurator", "urlConfigureabet", "urlConfigurabet", "urlConfigurerado", "urlConfureacion", "urlConfureaci", "urlConfigutacion", "urlConfigURation", "urlConfigurerabet", "urlConfigureracion"], "configuracion": ["configuralaton", "calureaci", "configuralant", "Configurator", "configauration", "Configuracion", "Configurateur", "configureab", "configureaton", "configaurab", "configutaci", "configauraton", "Configuration", "Configureation", "configurab", "configureacion", "Configurant", "caluraton", "configoracion", "configutacion", "configureation", "configaurateur", "configuralaci", "configuration", "Configurab", "configureateur", "calureation", "calureacion", "configutaton", "Configureateur", "Configureab", "configureator", "caluraci", "Configureator", "configoraci", "Configuraci", "configurant", "configureaci", "configutant", "configurator", "configurateur", "configuralation", "configuralacion", "configuralator", "Configureacion", "Configureaci", "configauracion", "configoraton", "configureant", "Configureaton", "configuraab", "configuraton", "configauraci", "Configureant", "calureaton", "caluration", "Configuraton", "configaurator", "configuraator", "configuraacion", "caluracion", "configoration", "configuraateur", "configuraci"], "xenc": ["exstream", "xstream", "fxenc", "exenc", "xmlens", "fxEnc", "xsen", "xmlEnc", "Xens", "xens", "XEnc", " xEnc", "Xenz", "ixsen", "Xenv", "fxens", " xenv", "ixec", "xec", " xens", "xmlenc", "ixenc", "xenv", " xsen", "xmlenv", " xstream", "xenz", " xenz", "ixstream", " xec", "xEnc", "fxenz", "exsen", "Xenc", "exec"]}}
{"id1": "20091126", "id2": "7911686", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["download", "write", "over", "open", "paste", "up", "cop", "zip", "process", "output", "Cop", "cat", "join", "p", "type", "upload", "io", "cmp", "proxy", "archive", "Copy", "file", "transfer", "call", "put", "cp", "source", "exec"], "in": ["image", "index", "base", "login", "config", "inner", "input", "In", "l", "bin", "b", "IN", "buffer", "again", "ic", "work", "query", "source", "part", "diff", "min", "ins", "name", "a", "ac", "id", "file", "data", "i", "reader", "old", "or", "connection", "m", "inc", "f", "url", "lin"], "out": ["image", "err", "base", "o", "temp", "prefix", "point", "content", "plain", "write", "target", "channel", "exp", "cache", "output", "OUT", "object", "page", "string", "array", "c", "external", "buffer", "again", "outs", "p", "result", "io", "v", "x", "Out", "off", "name", "ext", "a", "server", "data", "file", "parent", "call", "comment", "ex", "value", "i", "dot", "default", "source", "exec", "url"], "inChannel": ["inputButton", "winStream", "outchannel", "winchannel", "INClient", "inputchannel", "insChan", "inChan", "inStream", " inchannel", "inGate", "inputStream", "iniGate", "INStream", "inClient", "inputChannel", "winChannel", " inChan", "outButton", " inButton", "winChan", "inButton", "outChan", "iniChannel", "iniStream", "inputChan", "INchannel", " inStream", "iniChan", "INButton", " inClient", "outStream", "INChan", "insStream", "INChannel", "insClient", "inchannel", "INGate", "inputGate", "insChannel"], "outChannel": ["inConnection", " outStream", "outContext", "outchannel", "outputchannel", "inChan", "inStream", " outchannel", "outsChan", "OutStream", "inClient", "Outchannel", "inContext", "outputChan", "outClient", "outsConnection", "outChan", " outContext", "outputChannel", " outChan", "outStream", "outsStream", "OutChannel", "outsChannel", "OutContext", "outputStream", "outputClient", "OutClient", " outConnection", "inchannel", "OutChan", "outConnection"]}}
{"id1": "12197169", "id2": "8665321", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"read": ["create", "end", "continue", "stream", "check", "download", "write", "open", "parse", "load", "reading", "Read", "process", "run", "replace", "print", "readable", "work", "loop", "start", "report", "init", "ready", "request", "reader", "println", "get"], "in": ["ini", "err", "image", "log", "index", "login", "fr", "o", "of", "ing", "stream", "inner", "inn", "input", "scan", "In", "at", "cms", "l", "bin", "b", "conn", "info", "c", "r", "IN", "from", "buffer", "again", "token", "path", "er", "doc", "source", "nin", "io", "it", "min", "out", "by", "ins", "is", "ssl", "a", "con", "server", "data", "file", "isin", "id", "e", "on", "error", "ex", "reader", "n", "connection", "din", "f", "url", "inc", "s"], "line": ["link", "lc", "log", "unit", "end", "val", "lf", "lines", "inline", "entry", "LINE", "parse", "text", "message", "ne", "Line", "key", "L", "l", "b", "object", "page", "ine", "string", "code", "status", "buffer", "record", "se", "frame", "row", "le", "block", "name", "col", "ge", "data", "file", "id", "cell", "e", "el", "str", "sl", "comment", "value", "reader", "source", "f", "url", "lin"], "i": ["ini", "ski", "index", "j", "o", "oi", "phi", "ii", "fi", "ix", "slice", "l", "b", "info", "ui", "ri", "pi", "gi", "abi", "li", "ci", "p", "ie", "uni", "si", "io", "ni", "bi", "eni", "xi", "x", "ai", "ip", "is", "ori", "qi", "ti", "e", "u", "f", "n", "di", "I", "zi"], "logDatum": ["logdata", "logDum", "logDsatum", "logDatam", "logDsata", "Logdict", "LogDict", "logDictionary", "LogDum", "logDam", "exDDatum", "exDam", "logDatatum", "logDDam", "exDDictionary", "exDictionary", "logdict", "logDsict", "LogData", "logdatum", "logFictionary", "logDatictionary", "exDDam", "logDDictionary", "exData", "logDatata", "logFam", "LogDatum", "logFata", "logFatum", "logData", "logDict", "Logdatum", "logdum", "Logdum", "logDsum", "exDData", "exDatum", "Logdata", "logDDatum", "logDData", "logDatict"]}}
{"id1": "16851955", "id2": "22993368", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"testTrainingBackprop": ["testTrainBackpointer", "testTrainBackdrop", "testTrainingFrontpressure", "testTrainingFrontdrop", "testTrainBACKdrop", "testTrainingBACKpressure", "testTrainingBackpressure", "testTrainingBackpointer", "testTrainBACKpressure", "testTrainingBACKprop", "testTrainBackpressure", "testTrainBACKprop", "testTrainingBACKpointer", "testTrainBackprop", "testTrainingFrontpointer", "testTrainingBackdrop", "testTrainingFrontprop", "testTrainingBACKdrop", "testTrainBACKpointer"], "temp": ["folder", "model", "base", "stable", "pdf", "storage", "this", "current", "form", "dat", "input", "zip", "cache", "http", "local", "output", "writer", "full", "txt", "font", "cel", "session", "buffer", "path", "template", "Temp", "wrap", "io", "container", "v", "dest", "flat", "out", "tmp", "save", "test", "emp", "clean", "archive", "data", "file", "porary", "parent", "lock", "fake", "empty", "ex", "tem", "pipe", "config", "mount", "f", "copy", "directory"], "layers": ["licagers", "gobs", " lients", "nlayers", "blasses", "dlasks", "lasses", " lasses", "lasks", "slayers", "bays", "bllements", "dlayers", "flanguages", "liayers", "Lients", "liores", "gients", "lobs", "players", "dlacks", "gayers", "lagers", "licibraries", " libraries", "placks", "planguages", " lays", "Lobs", "nlibraries", "lowers", "slowers", "licayers", " lowers", " lasks", " llements", "blayers", "liibraries", "flayers", "bayers", "flasses", " likes", " lagers", "blanguages", "lays", "lients", "dlores", "llements", "likes", "nlagers", "slacks", "Layers", "dlanguages", "libraries", "nlikes", "slays", " lores", "plasks", "languages", "dlibraries", "bowers", " lobs", "fllements", " languages", "lacks", "lores", "liacks", " lacks", "backs", "licikes"], "fann": ["lnn", "lann", "elfann", "xfanny", "xfann", "fnn", "sfanny", "farn", "fana", "fain", "elfarn", "xfannon", "fannon", "Fain", "gann", "lana", "garn", "Fann", "sfannon", "elfnn", "Fanny", "gana", "xfain", "fanny", "sfain", "Fannon", "larn", "elfana", "gnn", "sfann"], "trainer": ["rainer", "retacer", "trayer", "tacer", "striner", "Tracer", " tracker", "retainer", "Trrain", "strain", "traacer", "tainer", "Trayer", "triner", "Trainer", "retiner", "stracer", "trrain", "rain", " tracer", "Triner", "strainer", "stracker", "strayer", "racer", "traacker", "retayer", "tacker", "traainer", "Tracker", "tracer", "trarain", "racker", "tracker", "train", " train"], "desiredError": ["desiredSize", "reservedError", "DesireSize", "resiredError", "despectedError", "desireError", "deservedEvent", "resiredEvent", "desirableEvent", "desiringError", "designedOrder", "desirableSize", "designedError", "despectederror", "DesiredSize", "desirederror", "designedSize", "desidedFailure", "desciredFailure", "desidederror", "desivedSize", "resiredSize", "DesireException", "deservedOrder", "desizedSize", "desirableOrder", "desciredError", "despectedProblem", "resiredOrder", "despectedFailure", "DesiredException", "reservedOrder", "desiringFailure", "desiredFailure", "desivedException", "DesiredError", "desciredProblem", "desizedError", "reservedEvent", "DesireError", "descidedProblem", "desiringerror", "desiredOrder", "desiringProblem", "desidedError", "desiredException", "reservedSize", "desireException", "deservedSize", "descidederror", "descidedError", "deservedError", "desirableError", "desiredProblem", "desizedException", "designedEvent", "desidedProblem", "descidedFailure", "desireSize", "desivedError", "descirederror", "desiredEvent"], "mse": [" mge", "MSE", " mte", " mze", " mSE", "mce", "fmse", "fSE", "Mte", "Mse", " mce", "Mce", "fce", "fmte", "gmSE", "mge", "mte", "Mze", "fmze", "gmce", "fse", "gmse", "gmge", "mze", "Mge", "fge", "fmce", "mSE"]}}
{"id1": "11341711", "id2": "12380475", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"makeBackup": ["makePickup", "createbackups", "createbackUp", "createbackup", "makebackdown", "makePickups", "makeCleanup", "makeBackups", "makeCleanUp", "createBackdown", "makeBackUp", "makebackups", "makePickdown", "createBackups", "makebackUp", "makeCleanups", "makeCleandown", "createBackup", "makebackup", "createbackdown", "makePickUp", "makeBackdown", "createBackUp"], "dir": ["folder", "log", "base", "module", "DIR", "done", "root", "direction", "download", "up", "group", "zip", "cache", "ir", "run", "wd", "Directory", "dist", "store", "rc", "path", "d", "work", "dict", "doc", "io", "build", "dest", "diff", "director", "Dir", "manager", "init", "name", "md", "dep", "data", "file", "desc", "pkg", "lib", "config", "source", "db", "url", "directory"], "sourcedir": ["seedIR", "sortedir", "sourcedirs", "sodedore", "sourcesiri", "sodedirs", "ssodedIR", "asourcedIR", "asourcedore", "seedir", "sourcesirs", "sourceddir", "sortedIR", "sourcesIR", "seeddir", "sourcesdir", "sourcesir", "ssourceddir", "ssourcedIR", "sodediri", "ssourcediri", "sodedir", "sortedirs", "sourcesore", "sodedIR", "ssourcedir", "asortedirs", "asourcedir", "sourcedIR", "asortedIR", "asourcedirs", "ssodediri", "sourcedore", "seediri", "sodeddir", "sourcediri", "asortedir", "asortedore", "sortedore", "ssodedir", "ssodeddir"], "destinationdir": ["destinatorDIR", "dominationDir", "Destificationdirection", "destinationDIR", "Destificationfolder", "destificationfolder", "desturationfolder", "destificationdir", "Destinationfolder", "destificationDir", "dominationdir", "desturationdir", "dominatorDir", "destinateDIR", "destinatefolder", "destinatorfile", "dominationDIR", "destinatefile", "destificationdirection", "destinatedirection", "destinationfolder", "DestificationDir", "Destificationdir", "destinationsDir", "destinationsDIR", "destinationdirection", "destinatordir", "dominatorDIR", "destinatedir", "destinationsdir", "dominatordir", "destinatorDir", "desturationDir", "desturationdirection", "destinationDir", "Destinationdir", "destinationfile", "Destinationdirection", "dominatorfile", "destinationsfile", "DestinationDir", "destinateDir", "dominationfile"], "destinationDirEnding": ["destinationDirPassING", "destinationDirectorySignING", "destinationPathEndING", "destinationDirectoryEndining", "destinationDirectoryEndING", "destinationDirBegining", "destinationPathBeginging", "destinationDirEndING", "destinationDirectorySigning", "destinationDirSignening", "destinationDirEndining", "destinationDirPassging", "destinationDirectorySignening", "destinationDirPassing", "destinationDirSignING", "destinationPathBeginING", "destinationDirSignining", "destinationPathBeginning", "destinationDirLeadING", "destinationDirENDing", "destinationDirENDging", "destinationDirLeadining", "destinationDirEndening", "destinationDirSigning", "destinationDirectoryEnding", "destinationPathEndging", "destinationDirEndning", "destinationPathBegining", "destinationPathEnding", "destinationDirBeginning", "destinationDirectorySignining", "destinationDirBeginING", "destinationDirLeading", "destinationPathEndning", "destinationDirEndging", "destinationDirBeginging", "destinationDirectoryEndening", "destinationDirENDING", "destinationDirBeginining", "destinationDirENDning", "destinationDirPassning", "destinationDirBeginening", "destinationDirLeadening"], "files": ["resources", "log", "boxes", "books", "its", "index", "objects", "keys", "locks", "errors", "types", "bugs", "flows", "ls", "runs", "lines", "children", "services", "planes", "sections", "thumbnails", "rules", "ids", "links", "output", "l", "blocks", "events", "iles", "uploads", "tests", "projects", "groups", "rows", "ps", "images", " Files", "split", "Files", "parents", "fields", "actions", "items", "fs", "reports", "users", "xml", "ins", "models", "features", "ips", "docs", "pages", "data", "file", "modules", "classes", "names", "balls", "results", "words", "strings"], "checkdir": ["checkDIR", "checkFolder", "blockdraft", "checklog", "checkfile", "workDIR", "ckdirectory", "workfolder", "workdirectory", " checkDIR", "searchdir", "lockDir", "locklog", "blockdirectory", "ckDir", "checkdraft", "workfile", " checkd", "searchdirectory", "calldirectory", "CheckDIR", " checkDir", "calld", "workdraft", "lockFolder", " checklog", "blockdir", "searchDir", "checkdirectory", "workdir", "checkfolder", "calldir", "Checkfile", "worklog", "callfolder", "blockDir", "workDir", " checkFolder", "ckdir", " checkfile", "checkDir", " checkdirectory", "ckfolder", "CheckDir", "checkd", " checkfolder", "searchdraft", "ckd", "lockdir", "workFolder", "ckfile", "Checkdir"], "date": ["image", "log", "de", "late", "change", "event", "dat", "open", "at", "age", "day", "mu", "rate", "now", "update", "set", "Date", "state", "d", "m", "ate", "doc", "month", "dt", "mate", "sign", "start", "name", "zone", "ime", "ge", "data", "file", "user", "e", "contact", " Date", "time", "config", "tag", "md"], "msec": ["Msecond", "dseconds", "mnsec", "cseconds", " msc", "misec", "lseconds", "mnSec", "csecond", "lss", "dsecond", "rsec", "Msec", "lsecond", "disec", " minsec", "dsec", "msc", "mss", " minif", "mnif", " minSec", "Mseconds", " mif", " mSec", "fmsec", "css", "lsec", "mnsc", "fmisec", "mif", " minsc", "fmseconds", "mSec", "mseconds", "Misec", "fmsecond", "msecond", "rsecond", "csec", "rseconds", "rss"], "checkFile": ["CheckDirectory", " checkDirectory", "checkfile", "CheckFile", "workFiles", "checkLine", "checkDirectory", "workfile", "checkFilename", "changeFilename", "ckFiles", " checkDir", "CheckFiles", "checkFiles", "workFile", "ckFile", "ckDirectory", "Checkfile", "controlfile", "changeLine", "controlFile", "workDir", " checkfile", "checkDir", " checkFiles", "changefile", "changeFile", "controlLine", "controlFilename", "CheckDir", " checkFilename", " checkLine", "ckfile"], "i": ["ini", "index", "j", "field", "oi", "hi", "phi", "ii", "fi", "ix", "slice", "key", "mu", "b", "info", "ui", "ri", "pi", "gi", "li", "ci", "p", "ie", "part", "multi", "si", "xi", "io", "bi", "uri", "v", "x", "ai", "ji", "eni", "y", "ip", "is", "ti", "qi", "id", "e", "iu", "u", "im", "vi", "n", "di", "m", "I"], "f": ["folder", "j", "o", "fr", "q", "feed", "fun", "w", "F", "fe", "fi", "fc", "l", "b", "info", "cf", "r", "fd", "t", "d", "fb", "fl", "p", "v", "df", "fp", "fs", "fx", "h", "file", "fn", "e", "sf", "u", "n", "m"], "g": ["ga", "q", "gar", "G", "gin", "global", "w", "group", "ger", "l", "b", "gg", "rg", "gb", "r", "gh", "gi", "tg", "t", "eg", "d", "m", "ig", "pg", "p", "gc", "sg", "mg", "gd", "gu", "gs", "ge", "h", "erg", "file", "gn", "e", "s", "go", "og", "ng", "bg", "u", "reg", "msg", "n", "vg", "gm", "gp"], "destinationFile": ["destinationsFile", "DestinationFile", "destacementfile", "destiningFile", "DestationDir", "destinationFilename", "destificationDir", "Destinationfile", "destinatorDirectory", "DestinationLocation", "destiningDir", "destiningfile", "DestificationDir", "destificationLocation", "destiningFilename", "destationFile", "destinationsDir", "destinatorFile", "destificationFile", "destacementFile", "DestificationLocation", "DestificationDirectory", "destacementFilename", "destinatorDir", "destinationDir", "destinationfile", "destationfile", "destinatorLocation", "DestationFilename", "destationFilename", "destinationDirectory", "DestinationDir", "DestinationFilename", "DestinationDirectory", "destinationLocation", "Destationfile", "DestificationFile", "destinationsDirectory", "destacementDir", "destationDir", "destificationDirectory", "destinationsLocation", "DestationFile"], "sourceFile": ["sourceDirectory", "srcDir", "ourceDirectory", " sourceModule", "sourceDir", "SourceDir", "ourceFiles", "inputDirectory", "inputDir", " sourcefile", " sourceFiles", "inputFiles", "sourceModule", "SourceFile", "SourceModule", "inputFile", "sourcefile", "Sourcefile", "ourceDir", "srcfile", "srcFile", "sourceFiles", " sourceDir", "srcModule", "ourceFile", " sourceDirectory"], "infile": ["indir", "outf", "windir", "outdir", "inf", "outFile", "inputfile", "diffFile", "inputstream", "inFile", "InFile", "outstream", " instream", "Instream", "diffdir", " inFile", "indata", "difffile", "winstream", "inputdata", "inputFile", "winFile", "diffstream", "instream", "outdata", "winfile", "Inf", " indata", "inputf", "Infile"], "outfile": ["exstream", "intstream", "outline", "Outstream", " outpage", "outFile", "againFile", " outFile", "intFile", "inputfile", "outpage", "Outlive", "againpage", "outfunction", "outstream", "againfile", "inputline", "exfile", " outfunction", "intlive", "Outfunction", " outstream", "againstream", "inputfunction", "inputFile", "outlive", "intfile", "expage", "exFile", " outline", "OutFile", "Outline", "Outfile", " outlive"], "c": ["z", "lc", "enc", "esc", "index", "dec", "in", "ice", "o", "end", "cont", "w", "cl", "pc", "channel", "cu", "l", "ch", "b", "C", "code", "string", "r", "ct", "rc", "t", "d", "k", "ci", "p", "pointer", "v", "x", "cy", "xc", "character", "cm", "col", "ac", "a", "h", "id", "e", "char", "comment", "u", "abc", "n", "uc", "ec", "m", "cr"]}}
{"id1": "11484416", "id2": "5759961", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "label": 0, "substitutes": {"moveFile": ["moveDirectory", "movePath", " movedPath", " moveFiles", " movedFiles", " movedFile", "MoveDirectory", "MoveFile", " movePath", "moveFiles", "MovePath", " movedDirectory", " moveDirectory", "MoveFiles"], "orig": ["origin", "folder", "image", "base", "coord", "temp", "impl", "coll", "transform", "src", "bas", "remote", "bin", "info", "ctr", "raf", "comb", "home", "buf", "array", "original", "org", "real", "build", "frame", "dest", "img", "prev", "raid", "tmp", "init", "internal", "imag", "ext", "proxy", "ori", "exe", "archive", "id", "file", "old", "rb", "iter", "loc", "source", "f", "obj", "Orig", "copy"], "target": ["origin", "force", "base", "resource", "temp", "nt", "this", "current", "to", "format", "eth", "Target", "match", "master", "platform", "remote", "replace", "prot", "object", "auto", "external", "t", "next", "path", "join", "original", "result", "ret", "it", "build", "dest", "manager", " Target", "tmp", "archive", "reference", "parent", "compatible", "arget", "template", "source", "project", "f", "copy"], "buffer": ["repeat", "base", "resource", "feed", "wave", "raw", "sequence", "content", "input", "write", "message", "cache", "slice", "queue", "stack", "b", "bin", "bytes", "bb", "read", "null", "buf", "code", "position", "buff", "padding", "uffer", "result", "frame", "layer", "block", "length", "request", "data", "file", "reference", "binary", "transfer", "header", "iter", "batch", "source", "Buffer", "url", "copy", "address"], "bread": ["fee", "die", "num", "raft", "feed", "circ", "eb", "buck", "cake", "inn", "fen", "beat", "fred", "fe", "fle", "fif", "zip", "grain", "meal", "key", "rub", "bb", "brew", "fall", "broken", "wake", "wen", "rows", "abi", "good", "hello", "fine", "ffe", "cook", "div", "sleep", "width", "four", "choice", "loop", "piece", "design", "length", "food", "knife", "bn", "bare", "ble", "bee", "robe", "rib", "fed", "str", "zero", "bc", "batch", "web", "bat"], "fis": ["lfiss", "ufiss", "ufis", " fIs", "afiss", "afis", "lfIs", "fxIs", "afos", "fils", "ufos", "qos", "lfis", "ufils", "hos", "qils", "hisa", "fIs", "qis", " fils", "his", " fiss", "fisa", "fxis", "fxisa", "fiss", "fxos", "qiss", "hIs", "afIs", "lfos", " fisa"], "fos": ["goss", "foses", " fens", "fens", " foss", "flens", "Fens", " fose", "infaos", "fors", "infors", "flois", "infos", "Fros", " fros", "Foses", "fose", "flos", "flose", "Fose", "faos", "fois", " foses", "floses", "Fos", "infois", "Fis", "flors", "gos", "Foss", "Fois", "Faos", "Fors", "gros", "flaos", "fros", "foss", "gis"]}}
{"id1": "9261777", "id2": "88047", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"source": ["image", "rule", "unit", "force", "index", "in", "resource", "SOURCE", "options", "service", "base", "site", "prefix", "view", "config", "Source", "inner", "sample", "input", "target", "parse", "src", "zip", "text", "slice", "use", "info", "scope", "style", "string", "null", "element", "spec", "session", "token", "path", "sort", "strip", "query", "single", "original", "ource", "result", "se", "uri", "sin", "dest", "flat", "secure", "size", "start", "missing", "name", "proxy", "request", "data", "id", "file", "seed", "parent", "comment", "empty", "shared", "sl", "template", "project", "url", "copy", "address"], "destination": ["destension", "destinator", "destinating", "distinated", "Destination", "Destinating", " destinator", "Destignment", "domuration", "coordinating", "Destinated", "distipping", "Desturation", "destipping", "coordination", "destignment", "Destinator", "homeination", "desturation", "dominated", "homeinator", "Destinate", "databaseuration", " destignment", "Destinations", " destipping", "distension", "coordinate", "dependension", " destinating", "dependination", "dominations", "destinate", "destinated", "databaseinations", "databaseinated", "destinations", " destension", "distination", "dependipping", " destinated", "homeignment", "coordinator", "dependinated", " destinate", "domination", "homeinated", "databaseination"], "is": ["ib", "in", "serv", "isi", "abs", "ops", "mis", "osi", "ii", "zip", "nis", "ir", "src", "lis", "api", "info", "ui", "IS", "ri", "act", "obs", "was", "ic", "ci", "ie", "ris", "io", "se", "isl", "eni", "oss", "ai", "out", "isa", "sis", "fs", "ip", "ins", "iss", "cos", "as", "close", "iso", "init", "are", "bis", "ens", "us", "ori", "ois", "es", "esi", "bs", "id", "ob", "isc", "ios", "Is", "i", "ais", "get", "or", "ar", "sin", "iris", "ics", "s"], "os": ["ou", "o", "vs", "ops", "ls", "osi", "bos", "dos", "mos", "ends", "acs", "oise", "ow", "js", "so", "pos", "obs", "ies", "op", "ds", "boot", "io", "ros", "Os", "nos", "oss", "out", "fs", "cos", "oes", "as", "es", "oS", "ens", "us", "ori", "sys", "bs", "oa", "oses", "ose", "ot", "ob", "ol", "ios", "OS", "ss", "i", "ais", "ks", "or", "los", "aos", "socket", "s"], "buffer": ["image", "base", "feed", "wave", "sequence", "flush", "channel", "slice", "queue", "b", "writer", "bytes", "bb", "page", "copy", "string", "null", "buf", "read", "pad", "position", "buff", "border", "padding", "uffer", "result", "number", "layer", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "Buffer", "url", "header", "address"], "length": ["index", "shape", "section", "feed", "end", "depth", "quote", "point", "of", "offset", "sequence", "duration", "match", "Length", "age", "load", "count", "power", "total", "slice", "key", "l", "full", "object", "left", "string", "code", "style", "position", "strip", "split", "division", "part", "type", "line", "width", "len", "number", "row", "character", "block", "start", "size", "distance", "volume", "ring", "id", "data", "range", "weight", "ob", "limit", "level", "last", "lock", "value", "reader", "get", "lower", "partial", "url", "address"]}}
{"id1": "13499897", "id2": "23452437", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"CopyFile": ["CreateFolder", " CopyDir", "CopyFolder", "CreateFile", "Createfile", " copyFile", " CopyFolder", " copyDir", "CreateDir", " copyfile", "Copyfile", "CopyDir", " copyFolder", " Copyfile"], "sourcefile": ["destfilename", "configlog", "destFile", "deststream", " sourceFile", "configstream", "sinstream", "configFile", "sinFile", "sourcefilename", "Sourcefilename", "sourceFile", "SourceFile", "configfile", "sinlog", "Sourcef", "sourcestream", "Sourcefile", " sourcefilename", "sourcelog", "sinfile", "destf", " sourcef", "sourcef", "destlog"], "destfile": ["destfilename", "sourcestring", "tempFile", "destFile", "DestFile", "targetfilename", "tempfile", "buildfile", "srcfilename", "srcpath", "destroypath", "Destfilename", " desturl", "newfp", "desturl", "tempfilename", "destfp", "targeturl", "deststream", "newfilename", "Destpath", "tempstream", " deststring", "destroyfile", " destFile", "Desturl", "newfile", "buildstring", "srcstream", "deststring", "sourcefilename", "sourceFile", "targetfile", " destpath", "targetFile", "temppath", "destroystream", " destfp", "newFile", "destroyfilename", "Destfp", "srcfile", "destpath", "srcFile", "buildFile", "Destfile", "buildfilename", "targetpath", "sourcepath", " destfilename"], "last": ["nd", "right", "base", "child", "end", "depth", "offset", "latest", "current", "event", "cur", "count", "total", "key", "use", "later", "full", "cat", "after", "left", "style", "code", "from", "route", "core", "path", "next", "recent", "part", "Last", "se", "real", "prev", "first", "ending", "length", "size", "start", "range", "value", "empty", "old", "or", " Last", "max", "ast"], "parent": ["unit", "base", "child", "temp", "section", "point", "root", "fat", "current", "content", "po", "function", "patch", "target", "anc", "exp", "text", "cache", "filename", "key", "remote", "api", "post", "Parent", "home", "string", "null", "pa", "path", "next", "ant", "p", "line", "parents", "part", "pointer", "and", "dest", "mac", "ip", "name", "location", "test", "ac", "search", "data", "file", "id", "valid", "port", "shared", "partial", "loc", "source", "url", "ppa"], "f": ["folder", "j", "base", "o", "feed", "of", "found", "self", "fa", "inf", "lf", "F", "fe", "ref", "fc", "l", "b", "full", "c", "cf", "r", "g", "fd", "t", "d", "fb", "p", "v", "df", "flat", "fp", "fs", "dir", "h", "file", "af", "e", "sf", "i", "m", "s"], "srcChannel": ["srcchannel", " srcConnection", "destchannel", "rcClient", "destChannel", "rcChan", "destConnection", " srcChan", "rcchannel", "sourcechannel", "rcChannel", "srcChan", " srcchannel", "sourceChan", " srcClient", "sourceConnection", "sourceChannel", "destClient", "destChan", "srcClient", "rcConnection", "srcConnection"], "dstChannel": ["drcChannel", "idrcButton", "DstContext", "idstchannel", "DstChannel", "DestChan", "dstschannel", "destchannel", "DstChan", "drcChan", "DestContext", "dstsChan", "idstChan", "ddestContext", "dstButton", "DstBuffer", "destChannel", "dstBuffer", "Dstchannel", "dntChan", "ddestBuffer", "DestBuffer", "idrcChan", "idrcChannel", "dntBuffer", "dstchannel", "destBuffer", "dstsChannel", "drcButton", "idrcchannel", "destContext", "idstChannel", "dsrcChan", "dntContext", "dstChan", "ddestChannel", "destButton", "idstButton", "ddestChan", "drcchannel", "dsrcChannel", "destChan", "dsrcButton", "dsrcchannel", "Destchannel", "DestChannel", "dstContext", "dntChannel"]}}
{"id1": "2017833", "id2": "23335922", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 1, "substitutes": {"hash": ["sha", "html", "base", "create", "hex", "check", "format", "transform", "parse", "message", "add", "replace", "update", "print", "string", "set", "crypt", "build", "number", "block", "ash", "Hash", "sum", "dump", "h", "str", "get"], "text": ["image", "letter", " Text", "hex", "content", "format", "input", "pattern", "version", "message", "key", "output", "password", "bytes", "object", "struct", "string", "txt", "code", "class", "font", "contract", "buffer", "Text", "token", "path", "template", "source", "translation", "number", "out", " TEXT", "secret", "length", "context", "name", "EXT", "test", "ext", "word", "data", "binary", "str", "value", "TEXT", "url", "editor"], "UnsupportedEncodingException": ["UnsupportedEncgorithmception", "UnsupportedEncasingException", "UnsupportedEncodedWarning", "UnsupportedEncodedException", "UnsupportedEncasingWarning", "UnsupportedEncasingception", "UnsupportedEncodingWarning", "UnsupportedEncgorithmException", "UnsupportedEncodingception", "UnsupportedEncgorithmWarning", "UnsupportedencodedException", "UnsupportedEncodedception", "Unsupportedencodingception", "UnsupportedencodingWarning", "UnsupportedencodingException", "UnsupportedencodedWarning", "Unsupportedencodedception"], "md": ["dd", "nm", "sha", "cmd", "bm", "am", "dig", "metadata", "amd", "ma", " MD", "um", "hd", "mm", "mad", "mo", "message", "ms", "ld", "wd", "mp", "vd", "mand", "d", "m", "ind", "bd", "ad", "ds", "pm", "mt", "mg", "mac", "gd", "od", "MD", "mod", "mag", "rm", "dm", "mc", "f", "mb", "hm", "bf", "meta"], "sha1hash": ["sha3hash", "sha2match", "sha4sum", "sha256h", "sha3hex", "shaonehex", "ha1hex", "sha5h", "SHA1hash", "sha1h", "SHA2hash", "shaonehash", "ha2hex", "sha256Hash", "sha256hash", "sha2sum", "SHA1h", "sha4Hash", "ha2sum", "sha5hash", "SHA1hex", "SHA1Hash", "ha1hash", "sha3sum", "sha4hex", "sha2hex", "sha5hex", "sha4hash", "sha2Hash", "SHA1sum", "sha5Hash", "shaonematch", "SHA2Hash", "sha3match", "sha2hash", "shaonesum", "ha1sum", "sha1hex", "sha2h", "ha2match", "sha5sum", "sha1sum", "sha1Hash", "sha256sum", "ha1match", "SHA2h", "sha1match", "ha2hash", "SHA2sum"]}}
{"id1": "14758866", "id2": "18211588", "code1": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"getResourceAsStream": ["getResourcesAsStream", "getResourceASStream", "getResourceToStream", "getResourceasSteam", "getResourcesAsSteam", "getResourcesasFile", "getResourceasString", "getResourceToFile", "getResourcesasStream", "getResourceAsString", "getResourceASFile", "getResourceasStream", "getResourceAsFile", "getResourceToSteam", "getResourceAsSteam", "getResourceASSteam", "getResourcesAsString", "getResourceToString", "getResourcesAsFile", "getResourcesasString", "getResourcesasSteam", "getResourceasFile", "getResourceASString"], "name": ["base", "resource", "NAME", "prefix", "alias", "domain", "version", "cache", "filename", "key", "remote", "info", "full", "object", "string", "hash", "ame", "path", "Name", "type", "part", "uri", "named", "ip", "size", "location", "word", "data", "file", "id", "parent", "username", "time", "str", "names", "connection", "config", "source", "memory", "address"], "inputStream": ["pullSteam", "InputChannel", "inputBody", "cacheSteam", "inputstream", "InputFeed", "currentBody", " inputChannel", "InputSteam", "inputChannel", "currentSteam", "inputConnection", "cachestream", " inputBody", " inputSteam", "currentstream", "cacheStream", "cacheFeed", "inputSteam", "InputBody", " inputConnection", "pullChannel", "InputStream", " inputFeed", "pullConnection", "pullStream", " inputstream", "currentStream", "inputFeed", "Inputstream", "InputConnection"], "in": ["re", "image", "err", "log", "inner", "input", "din", "In", "src", "rec", "bin", "read", "c", "r", "IN", "buffer", "path", "Out", "ins", "data", "reader", "m", "source", "exec", "socket"], "out": ["err", "log", "pool", "cmd", "outer", "raw", "temp", "point", "flush", "debug", "pre", "cli", "inter", "window", "up", "ref", "group", "cache", "output", "OUT", "list", "writer", "bin", "conn", "object", "ger", "page", "key", "r", "params", "buffer", "state", "outs", "query", "line", "part", "io", "proc", "Out", "client", "bar", "dump", "server", "data", "file", "user", "sys", "gen", "lock", "error", "ex", "println", "msg", "obj", "copy"], "url": ["image", "log", "URL", "base", "resource", "service", "feed", "stream", "coll", "event", "download", "Url", "open", "http", "cache", "remote", "l", "b", "api", "full", "object", "page", "update", "string", "left", "r", "bel", "route", "path", "li", "source", "result", "rel", "https", "uri", "org", "pull", "client", "ur", "ssl", "socket", "loc", "server", "data", "file", "ob", "gl", "user", "browser", "sl", "connection", "config", "location", "web", "f", "address"], "remoteName": ["RemoteUrl", "remoteKey", "RemotePath", "RemoteName", "localPath", "fullKey", "localKey", " remoteKey", "fullname", " remotename", "remoteUrl", "RemoteKey", " remoteUrl", "remotePath", "fullPath", "fullName", "localUrl", "Remotename", " remotePath", "remotename"], "localName": ["globalString", " localUrl", "locString", "remoteKey", " localPath", "remoteString", "LocalPath", " localString", "LocalKey", "localPath", "locName", "globalPath", "globalFile", "localKey", "locname", "globalKey", "locPath", "remoteFile", "locUrl", "localname", "LocalName", "remoteUrl", "globalName", " localname", "remotePath", "localString", "Localname", " localKey", "localUrl", "localFile", " localFile", "globalname", "remotename"], "host": ["service", "localhost", "hard", "prefix", "format", "domain", "head", "Host", "target", "arch", "http", "src", "remote", "conn", "hop", "home", "string", "driver", "path", "type", "uri", "addr", "ip", "dir", "proxy", "h", "loc", "server", "username", "database", "config", "header", "address"], "prot": ["nat", "conv", "serv", "pt", " protocols", "prefix", "config", "ht", "cli", "pattern", "channel", "ref", "platform", "cert", "api", "password", "conn", "att", "txt", "pos", "def", "pass", "family", "part", "lat", "stat", "proc", "Prot", "addr", "prop", "client", "ocol", "ssl", " plat", "col", " protocol", " proto", "ios", "afi", "rot", "pro", "rel"], "port": ["ports", "index", "service", "priority", "point", "direction", "patch", "phone", "target", "version", "slice", "password", "pr", "hop", "string", "pi", "future", "position", "pass", "path", "pid", "ort", "p", "type", "allow", "Port", "width", "uri", "number", "rest", "ip", "length", "size", "proxy", "PORT", "server", "file", "limit", "value", "timeout", "time", "select", "project", "f", "address"], "cacheFile": ["storageFile", "cacheHandle", "tempFile", "outputMessage", " cacheMessage", " cacheDir", " cacheDirectory", " cacheHandle", "tempfile", "outputConnection", "remoteLine", "localFiles", "CacheUrl", "fakeUrl", "proxyfile", "proxyHandle", "acheFile", "cacheDir", "proxyDir", "cacheLine", "cachePlace", "sessionFile", "CacheDir", "baseMessage", "localDirectory", "storageFiles", "fakeLine", " cachePlace", "cacheFiles", "tempDir", "achePlace", "sessionDir", "sessionUrl", " cacheLine", "CacheFile", "remoteFile", "cacheMessage", " cacheFiles", "localfile", " cachefile", "acheFiles", "baseConnection", "remoteUrl", "baseFile", "proxyFile", "cacheDirectory", "storagePlace", "Cachefile", "remotefile", " cacheConnection", "CacheDirectory", "cacheConnection", "tempHandle", "outputfile", "cachefile", "cacheUrl", "fakeFile", "basefile", "fakefile", "CacheFiles", "localFile", "sessionFiles", "outputFile", " cacheUrl", "localDir"], "urlConnection": ["httpResponse", "httpCommand", "URLConnect", "URLConn", "sslResponse", " urlCommand", "httpConnection", "URLConnection", "urlFile", "webConnection", "urlCode", "httpPool", "httpconnection", " urlCode", " urlChannel", "downloadEntry", "URLconnection", "cacheConn", "httpCode", "sslFile", "slChannel", "sslConn", "httpChannel", " urlFile", "fileConnect", " urlEntry", "fileConn", "urlconnection", "urlPool", "httpCon", " urlConn", "filePart", "httpConn", " urlPart", "urlCommand", "webCon", "httpConnect", "webConnect", "URLPart", "urlConn", " urlConnect", " urlPool", "webconnection", "URLResponse", "slCommand", "cacheConnect", "downloadFile", "downloadConnection", "cacheConnection", " urlconnection", "urlCon", "sslEntry", "urlConnect", "sslConnection", "slConnection", "urlResponse", "cachePool", "slCode", "sslConnect", "urlEntry", "sslconnection", "downloadconnection", "urlChannel", "fileConnection", "URLCon", "urlPart"], "httpURLConnection": ["httpUrlStatement", "httpDOMconnection", "httpREStatement", "httpCLConnector", "httpURLConnector", " httpHTTPFunction", "httpFormConnection", "currentURLconnection", " httpLLConn", " httpLLconnection", "httpRLConnector", "httpRNode", "shortSLconnection", "httpSLConnect", "urlUrlConnection", "httpURLConnect", "httpWSTransaction", "httpURNode", "httpLLConnection", "httpDOMConnection", "httpDateConnection", "httpRLClient", "httpBLFunction", "httpRConnection", "httpLLConn", "httpFormconnection", "httpURLQuery", "httpMLFunction", "httpDOMFunction", "httpSLConnection", "httpMconnection", "httpSLCode", "cacheURLConnection", "httpDateConn", " httpURLQuery", "cacheUrlConnector", "httpURLconnection", "httpUrlClient", "httpLLconnection", "httpURconnection", "httpurlConnection", "shortSLConnection", " httpHTTPConnection", "httpURLConstruction", "httpURLStatement", "httpHTTPOperation", " httpHTTPQuery", "httpBLOperation", " httpUrlConnect", "httpHTTPQuery", " httpUrlconnection", "cacheURLConnector", "httpREconnection", "httpUrlconnection", "shortURLConnection", "cacheUrlConnection", "httpMConnect", "httpURLNode", "httpWSConnection", "httpURTransaction", "httpurlClient", "httpFormConnect", "urlURLconnection", "httpRconnection", "upperURLconnection", "shortSLConnect", "httpURFunction", "httpSLconnection", "httpREClient", "httpURQuery", "httpLLConstruction", "httpURLConn", "httpCLClient", "urlURLStatement", "upperRConnection", "httpRLconnection", "cacheURLConnect", "upperRconnection", "httpMLConnect", "httpCLConnection", " httpURLOperation", "httpMLConnection", " httpLLConnection", "cacheURLClient", "httpDateconnection", " httpURLconnection", "httpREConnection", "upperRTransaction", "urlURLClient", "httpURConnection", "httpHTTPFunction", " httpUrlConnection", "upperRNode", "urlUrlconnection", "httpURLTransaction", "httpDOMConnect", "upperURLConnection", "httpMConnection", "httpRTransaction", " httpURLConstruction", "currentURLConnect", "upperURLNode", " httpLLConstruction", " httpURLConnect", "httpURLFunction", "httpBLConnection", "httpUrlConnect", "httpURLOperation", "currentURLCode", "upperURLTransaction", "shortURLconnection", "httpRLConnect", " httpUrlFunction", " httpURLFunction", "httpHTTPConnection", "httpUrlConnection", "httpMCode", "httpURLClient", "currentURLConnection", "httpurlconnection", "httpMLconnection", "httpBLQuery", "httpCLConnect", "cacheUrlConnect", "httpUrlConnector", " httpURLConn", "httpDateConstruction", "httpUrlFunction", " httpHTTPOperation", "httpWSconnection", "shortURLConnect", "cacheUrlClient", "urlURLConnection", "httpREConn", "httpurlStatement", "httpRLConnection", "httpUROperation", "httpURLCode", "urlUrlClient", "httpWSNode", "urlUrlStatement", "httpREConstruction"], "responseCode": ["statusCount", "ResponseType", "statusCode", "replyCode", "responseCount", "statusMessage", "ResponseStatus", "ResponseCount", "replyType", " responseType", "responseStatus", "statusType", " responseMessage", "ResponseCode", "replyCount", "responseMessage", " responseStatus", "ResponseMessage", "responseType", "statusStatus", "replyMessage"], "lastModified": ["lastmodied", "lastModification", "lastModined", "nextModIFIED", "lastMODIFIED", "lastMinied", "nextMODification", "lastMODification", "nextMODed", "New", "lastMODined", " lastModined", "nextModified", "lastEdified", "lastMinified", "lastMinIFIED", "nextMODIFIED", "s", " lastMODIFIED", "this", "nextModed", "nextModification", "lastMODified", "lastModed", "lastEdIFIED", "lastModIFIED", "lastEded", "nextMODified", " lastMODified", "_", "lastmodified", "lastmodification", "lastEdification", " lastModied", "lastmoded", "lastmodIFIED", "nextMODied", " lastModIFIED", " lastMODied", "lastMODed", "lastMinined", " lastMODined", "lastModied", "nextModied", "lastMODied"]}}
{"id1": "14882263", "id2": "18433984", "code1": "    private void UploadActionPerformed(ActionEvent evt) {\n        JFileChooser chooser = new JFileChooser();\n        FileNameExtensionFilter filter = new FileNameExtensionFilter(\"*.jpg\", \"jpg\");\n        chooser.setFileFilter(filter);\n        File dir = new File(System.getProperty(\"user.home\"));\n        chooser.setCurrentDirectory(dir);\n        Component parent = null;\n        int returnVal = chooser.showOpenDialog(parent);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            UserStatus.setText(\"Bitte warten\");\n        }\n        try {\n            Pic.setVisible(false);\n            FTPClient client = new FTPClient();\n            client.connect(\"showus.de\");\n            client.login(\"web2\", \"kcinnay88\");\n            client.enterLocalActiveMode();\n            client.setFileTransferMode(FTPClient.BINARY_FILE_TYPE);\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            int reply = client.getReplyCode();\n            System.out.println(\"Connect returned: \" + reply);\n            FileInputStream in = new FileInputStream(chooser.getSelectedFile().getAbsolutePath());\n            System.out.println(\"Uploading File\");\n            client.storeFile(\"/html/Applet/user/\" + Config.id + \".jpg\", in);\n            client.logout();\n            in.close();\n            System.out.println(\"done\");\n            UserStatus.setText(\"Upload fertig, Bild wird aktuallisiert\");\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            UserStatus.setText(\"Fehler beim Upload\");\n            e.printStackTrace();\n        }\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"UploadActionPerformed": ["UploadActionReumed", "UploadButtonOccformed", "UploadButtonPerced", "UploadButtonOccced", "UploadActionPerumed", "UploadButtonPerformed", "UploadActionEnformed", "UploadButtonPeruted", "UploadActionOccced", "UploadActionReuted", "UploadButtonOccuted", "UploadActionOccuted", "UploadActionPerced", "UploadActionEnuted", "UploadButtonOccumed", "UploadActionEnced", "UploadActionOccformed", "UploadActionReced", "UploadButtonPerumed", "UploadActionOccumed", "UploadActionPeruted", "UploadActionEnumed", "UploadActionReformed"], "evt": [" Evts", " Evt", "Evtf", " Evtf", " Evte", " averte", " avert", " evts", "Evte", " avertf", " averts", " evtf", "Evts", " evte", "Evt"], "chooser": ["Choosite", "closed", "compcho", "chocho", "coose", "Choosen", "promosen", "closer", "joosed", "compose", "choose", "promoe", "choiner", "promo", "dialcho", "promosite", "coosed", "compo", "Choose", "choosen", "Choosing", "comboser", "dialoser", "joose", "composen", "cooser", "promose", "choo", "coosite", "combosed", "Chooser", "joiner", "cooe", "joosen", "promoser", "dialosen", "closen", "choosed", "closing", "combiner", "coiner", "choosing", "choosite", "Chooe", "Chocho", "Choosed", "joo", "combose", "chooe", "jooser", "dialose", "composer", "joosing"], "filter": ["method", "model", "force", "plugin", "self", "form", "format", "ff", "pattern", "match", "aff", "cache", "atter", "list", "b", "finder", "object", "class", "path", "query", "sort", "handler", "fl", "fil", "type", "flat", "Filter", "name", "ext", "map", "search", "user", "file", "sf", "limit", "lock", "config", "acl", "f", "url"], "dir": ["folder", "log", "base", "DIR", "root", "dat", "direction", "project", "zip", "cache", "ir", "area", "info", "home", "store", "dist", "fd", "path", "handler", "db", "doc", "type", "part", "conf", "uri", "out", "Dir", " directory", "loader", "name", "loc", "id", "file", "user", "data", "lock", "pkg", "config", "source", "f", "url", "directory"], "parent": ["image", "folder", "resource", "child", "section", "point", "root", "self", "current", "directory", "channel", "menu", "object", "Parent", "page", "home", "path", "handler", "pid", "p", "part", "parents", "div", "container", "ip", "name", "component", "id", "file", "user", "document", "port", "instance", "location", "url", "editor"], "returnVal": ["Returnval", " returnVol", "ReturnObj", "ReturnVal", "returnObj", "errorval", "continueValue", "returnValue", " returnObj", "returnVol", "ReturnValue", " returnValue", "continueObj", "ReturnVol", "continueval", "errorVal", "errorValue", " returnval", "errorVol", "continueVal", "returnval"], "client": ["quit", "force", "base", "service", "end", "Client", "cl", "cli", "google", "phone", "pc", "net", "open", "channel", "http", "cache", "standard", "local", "use", "remote", "api", "help", "conn", "connection", "simple", "queue", "contract", "pi", "c", "session", "external", "core", "custom", "cloud", "p", "grid", "https", "friend", "out", "ce", "ip", "util", "secure", "close", "app", "cm", "ssl", "clean", "proxy", "request", "co", "con", "server", "user", "file", "cell", "call", "connect", "i", "per", "get", "complete", "contact", "default", "console", "config", "web", "plugin", "socket"], "reply": ["err", "action", "link", "answer", "send", "write", "ry", "reason", "req", "mode", "message", "count", "ply", "parse", "sync", "repl", "back", " replies", "Reply", "respond", "info", "post", "like", "status", "code", "exit", " replied", "ise", "state", "resp", "rc", "next", "query", "result", "uri", "rr", "response", "close", "xxxxxxxx", "id", "error", " response", "connection", "msg"], "in": ["ini", "image", "resource", "login", "serv", "stream", "gin", "inn", "inner", "input", "cgi", "In", "pc", "up", "fc", "rec", "l", "bin", "conn", "pin", "IN", "r", "again", "tin", "ic", "p", "source", "nin", "io", "min", "out", "ins", "is", "ac", "con", "data", "file", "ax", "on", "id", "ex", "i", "reader", "n", "din", "f", "socket", "inc"]}}
{"id1": "1586662", "id2": "17083703", "code1": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "code2": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doOne": ["DoSync", "goOne", "goone", "Doone", "Do1", "go1", "loOne", "DoOne", "do1", "goSync", "lo1", "doone", "doSync", "loone", "loSync"], "bid": ["wid", "vid", "paid", "sha", "base", "bm", "ud", "aud", "rid", "mad", "ban", "ref", "bon", "bas", "bit", "b", "bb", "bh", "cb", "bed", "ld", "aba", "uid", "ed", "abi", "pid", "ad", "year", "lay", "oid", "bi", "auth", "bt", "hid", "sid", "mid", "la", "chid", "bn", "du", "received", "id", "seed", "rb", "bc", "bf", "batch", "ast"], "tid": ["paid", " taid", "ptaid", "tiden", "tids", "pids", " tbase", " tids", "ptid", "Tbase", "timID", "trid", "tID", "timbid", "pbase", "tide", "trID", "ptinfo", "trids", "tbase", "trbid", "pid", "ptiden", "pide", " tide", "timid", "Tid", "Tids", "pinfo", "taid", "tbid", "Tbid", "TID", "piden", "Tide", " tiden", "tinfo", " tinfo", "timids"], "aid": ["paid", "dd", "sha", "ga", "said", "ay", "aud", "alias", "order", "lan", "lied", "mad", "ase", "anc", "ca", "ada", "bas", "acid", "aida", "sat", "idd", "da", "aa", "ays", "ed", "aned", "pa", "d", "au", "Aid", "ad", "lay", "oid", "ai", "cas", "sd", "na", "ady", "auth", "aim", "man", "sid", "du", "ased", "ac", "a", "ara", "id", "af", "az", "aed", "ding", "added", "delay", "ab", "ast", "ia"], "delta": ["Dota", "ddDelta", "edetime", "ddelta", "sdelta", "sdelt", "dta", "dada", "dDelta", " dada", "ndDelta", "ndta", "Delta", "lelta", "lada", "adelt", "dota", "d\n", "edDelta", "sdta", "adota", "ldelt", "sdDelta", "D\n", "edelta", "adDelta", "adada", "ndelta", "ldota", "d_", "lelt", " delt", "Dada", "sdota", "ndota", "ddota", " d_", "ndelt", "DDelta", "edta", "sdetime", "ndata", "lota", " dota", "detime", " d\n", " dDelta", "D_", "data", "sdata", "delt", "ddelt", "ldDelta", "ldelta", "Delt", "adelta", "ndetime"], "aBalance": ["sabalance", "aaHalf", "aCost", "bHalf", "aaWeight", "saBalance", "eaBalance", " aCredit", " abalance", "aaBalance", "eabalance", "eaBal", "abalance", "bAmount", "aBal", "aWeight", " aWeight", "aaCredit", "bBalance", " aAmount", "eaCost", "pBalance", "aabalance", " aCost", "pbalance", "aHalf", "saBal", "saCost", " aBal", "pWeight", "pCredit", "bCredit", "aCredit", " aHalf", "aAmount", "aaAmount"], "RS": ["RE", "JS", "RN", "VS", "SW", "RC", "DS", "DR", "FS", "KR", "NRS", "RD", "RR", "RT", "KS", "SS", "RO", "RW", "Rs", "LS", "IS", "CL", "TS", "SH", "MC", "RB", "RL", "POST", "Res", "Vs", "VR", "US", "BS", "IR", "MR", "MS", "rs", "CD", "LL", "OSS", "RM", "Ms", "AR", "RI", "OS", "PS", "GR", "JR", "TR", "HS", "CS", "RP", "SR"], "Stmt": ["LMT", "stbl", "Stut", "Cmn", "Strau", "Stmn", "stMT", "Stp", "stmp", " StMT", "Strmp", "Cmt", " Stmp", "STut", "Stgr", "Stmp", " Stpr", "Lmp", "Cut", " Sttm", " Stau", "STTr", " StTr", "STp", "Stau", "Cmp", "STMT", " Stbl", "Stpr", "stp", "CMT", "Firstmt", "STbl", "StMT", " stmp", "Firstpr", "Firstmb", " Stmn", "Cau", "StTr", "stmt", " Stmb", " Stut", " stMT", "stgr", " Stp", " stmt", "Lgr", "Sttm", "STmn", " stgr", "stmb", "Firsttm", "sttm", "stpr", "Strmt", "Stmb", "Stbl", "STmt", "StrMT", "Lmt", "stTr"], "Query": ["File", "Time", "Check", "Raw", "Factory", "Command", "Form", "Database", "Model", "Stage", "Driver", "Body", "Source", "Route", "Statement", "Report", "Url", "Range", "Table", "Force", "SQL", "Connection", "Qu", "Display", "Line", "Function", "Comment", "Format", "Update", "query", "Array", "Request", "Do", "This", "Db", "Service", "Row", "Cache", "Common", "Code", "Server", "Scan", "Method", "Exp", "Test", "Script", "Option", "Document", "URI", "Filter", "Init", "Msg", "Fixed", "Style", "Previous", "Rule", "Module", "Join", "Info", "Flow", "Str", "Conn", "Q", "Error", " query", "Key", "Condition", "ERY", "QL"], "res": ["re", "RE", "ES", "vals", "resh", "Gr", "Response", "runs", "js", "gr", "resp", "rows", "RES", "Resources", "Res", "ches", "Results", "lets", "ras", "rest", "Resp", "Ret", "rem", "PS", "results", "reg", "Cons", "obj"]}}
{"id1": "646016", "id2": "15472181", "code1": "    public void elimina(Cliente cli) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorCliente.elimina()\");\n        int id = cli.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            sql = \"DELETE FROM persona WHERE id =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt.executeUpdate(sql);\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        }\n    }\n", "code2": "    private InputStream getInputStream(String item) {\n        InputStream is = null;\n        URLConnection urlc = null;\n        try {\n            URL url = new URL(item);\n            urlc = url.openConnection();\n            is = urlc.getInputStream();\n            current_source = url.getProtocol() + \"://\" + url.getHost() + \":\" + url.getPort() + url.getFile();\n        } catch (Exception ee) {\n            System.err.println(ee);\n        }\n        int i = 0;\n        udp_port = -1;\n        udp_baddress = null;\n        while (urlc != null) {\n            String s = urlc.getHeaderField(i);\n            String t = urlc.getHeaderFieldKey(i);\n            if (s == null) {\n                break;\n            }\n            i++;\n            if (\"udp-port\".equals(t)) {\n                try {\n                    udp_port = Integer.parseInt(s);\n                } catch (Exception e) {\n                }\n            } else if (\"udp-broadcast-address\".equals(t)) {\n                udp_baddress = s;\n            }\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"elimina": [" elimita", " elimini", "elimerina", "elrimini", " elrimini", " elrimada", "elimalini", "elimerita", "elimalita", "elimini", "elimerini", "elimada", "elimalina", "elrimita", "elrimada", " elimada", " elrimina", " elrimita", "elimita", "elimerada", "elrimina", "elimalada"], "cli": ["lc", "cmd", "API", "cci", "sci", "hi", "Client", "cgi", "oci", "osi", "ctrl", "cu", "api", "l", "conn", "ui", "uci", "ctl", "CL", "c", "cfg", "gi", "colo", "dl", "li", "ci", "gui", "xi", "uri", "client", "gd", "util", "GUI", "server", "lo", "i", "ctx", "di", "connection", "lu"], "id": ["ident", "vid", "num", "index", "model", "in", "login", "q", "resource", "email", "val", "entry", "active", "version", "ids", "zip", "key", "info", "uid", "patient", "style", "status", "code", "admin", "path", "d", "pid", "en", "p", "type", "ql", "ID", "aid", "it", "x", "oid", "Id", "client", "ip", "start", "name", "sid", "mid", "md", "h", "server", "f", "value", "i", "database", "error", "connection", "like", "db", "kid", "url", "address"], "sql": ["err", "log", "sol", "cmd", "lc", "html", "script", "base", "nl", "lua", "function", "ls", "SQL", "details", "zip", "cop", "generic", "sex", "repl", "liquid", "l", "shell", "sync", "js", "string", "status", "null", "sal", " SQL", "params", "query", "job", "lang", "type", "result", "ql", "sg", "sv", "sb", "eps", "su", "os", "util", "il", "sq", "auth", "name", "ssl", "statement", "lv", "sys", "live", "ln", "data", "layout", "seed", "ll", "sf", "general", "str", "sl", "i", "no", "rl", "comment", "dl", "msg", "db", "install", "url"], "stmt": ["fMT", " stmm", "Stmm", "Stmt", "estmt", "putsql", "stMT", "fm", "stmp", "sthmt", "sthm", "instm", "putmb", "instdr", " sttr", "instdd", "Stdb", "stmd", " stsql", "sthdr", "stsql", "Stmp", "estnt", "sttr", "estmn", "stpt", "stnt", "stmn", "shtr", "putpt", "estmb", "stmm", " stdd", "Stmd", "StMT", " stmp", "stdd", " stmb", "stm", "fmt", " stMT", "instmt", "putmt", " stnt", " stpt", "esttr", "sthdd", "estpt", "estmd", "shmt", "Stm", "shmn", " stm", "estdb", "estmm", " stdr", "stmb", " stdb", "fmp", "stdb", "stdr", "shnt", " stmd", "estsql", " stmn"]}}
{"id1": "11840277", "id2": "10131427", "code1": "    protected static void clearTables() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"delete from Objects\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (1, 'Money value')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (2, 'Date')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (3, 'Unix path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (4, 'Dos path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (5, 'Time')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (6, 'IP address')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (7, 'Internet hostname')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (8, 'Number')\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"clearTables": ["cacheTableows", "createStaches", "clearTemings", "clearBables", "clearBings", "clearStaces", "clearTableables", "clearTations", "clearContows", "clearTemables", "cacheTableations", "cacheTables", "createTables", "clearStables", "clearTings", "cacheTableings", "clearTaces", "createTaches", "cacheTations", "clearStaches", "clearTableings", "createStaces", "clearContaces", "clearBaches", "createStables", "clearTemations", "clearContaches", "cacheTows", "clearBations", "clearBaces", "clearTows", "cacheTableables", "clearTemows", "createTows", "clearStows", "cacheTings", "createTaces", "clearTableations", "clearTaches", "clearBows", "clearContables", "createStows", "clearTableows"], "conn": ["enc", "ou", "lc", "log", "jc", "nt", "config", "coll", "dc", "oci", "nc", "open", "Connection", "ca", "ns", "cache", "exec", "ch", "wd", "cat", "ann", "cb", "bb", "act", "c", "sql", "cf", "ct", "session", "state", "rc", "path", "di", "ci", "p", "pg", "cmp", "org", "oss", "ai", "mt", "client", "cc", "pub", "close", "cm", "ssl", "cp", "col", "ac", "co", "con", "h", "cn", "server", "ob", "dn", "cond", "connect", "lock", "sth", "Conn", "mc", "error", "n", "ctx", "Connect", "connection", "loc", "db", "conf", "obj"], "stmt": [" stma", "stlt", "estmt", "stma", "actmt", "est", "ctmt", "actmn", " stmi", " stager", "tct", "dmt", "sttor", " stmc", "Stap", "stmn", "Sttx", "ewd", "stmm", "Stmd", "putwt", "STgr", "putml", "putlt", "Sttor", "stgr", "putmt", "putmm", "putma", "stprint", "ftbm", "str", "ldmn", "emt", "stsst", "tnt", "ctm", "STmt", "putager", "Stmt", " stct", "Stwt", "stsmt", "stwd", "ctr", "ldma", "Stlt", "stnt", "actnt", "strlt", "STbm", "STlt", "stsprint", "ssbm", "putap", "StMT", "stwt", "estwt", "istmt", "stml", "ctql", "stbm", "Stm", " stm", "dm", " stql", "istMT", " stmd", "STmd", "ctmd", "dr", "Stmm", "sswt", " stml", "Stmn", "stMT", "playwt", "puttor", "ssmt", "sttx", "stmi", "stap", "ftmn", "Stnt", "stql", "Stml", "estm", "putMT", "STMT", " stlt", "istgr", "STwd", "stst", "actmi", " stap", "dql", "STmn", " stgr", "stmc", " stmn", "putm", " stbm", "playtor", "stct", "ctgr", "strml", "tm", "stmd", "strMT", "Stgr", "istmn", "putbm", "Stmc", "playtx", "eprint", "Stct", "Stmi", "stager", "playmt", "puttx", "stswd", "putmn", " str", "stm", "strmt", "ldmt", "STmc", " stnt", "ftlt", "STst", "STprint", "estmm", "ldager", "tmt", "ftmt", "ssmn", " stwt"]}}
{"id1": "8000624", "id2": "14758866", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": [" transferto", "copyto", "CopyFrom", " transferFrom", " copyTo", " copyFile", "copyFrom", "CopyFile", " copyFrom", "copyTo", " transferTo", "copyFile", " copyto", " transferFile", "Copyto"], "dest": ["folder", "wb", "die", " destination", "temp", "cont", "done", "content", "w", "transform", " Dest", "write", "target", "them", "src", "filename", "output", "later", "bin", "table", "object", "sup", "comb", "txt", "class", "orig", "exit", "dist", "path", "opt", "flat", "img", "rest", "tmp", "name", "test", "Dest", "data", "file", "desc", "delete", "destroy", "source", "obj"], "in": ["re", "image", "ini", "kin", "login", "wave", "fa", "inner", "inn", "gin", "input", "din", "In", "up", "l", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "plus", "source", "nin", "sin", "x", "cin", "issue", "pull", "ins", "as", "init", "inside", "ac", "thin", "h", "con", "ln", "rin", "ax", "isin", "id", "reader", "i", "win", "n", "vin", "lib", "connection", "m", "inc", "f", "lin", "s"], "out": ["err", "ou", "image", "o", "outer", "temp", "other", "this", "inner", "outside", "w", "net", "target", "our", "up", "or", "cache", "sync", "output", "OUT", "writer", "b", "conn", "bin", "object", "url", "pin", "external", "again", "outs", "not", "plus", "nin", "part", "io", "x", "Out", "client", "off", "app", "name", "ext", "data", "file", "vert", "user", "call", "ex", "i", "no", "timeout", "n", "one", "lib", "inc", "exec", "socket", "copy"], "c": ["enc", "lc", "esc", "o", "config", "dc", "content", "exc", "cl", "pc", "fc", "cu", "ca", "l", "ch", "cb", "arc", "C", "code", "cf", "r", "ct", "buffer", "rc", "t", "ic", "d", "ci", "p", "sc", "pointer", "v", "x", "ce", "cy", "xc", "cc", "oc", "cm", "col", "ac", "e", "char", "u", "comment", "i", "abc", "n", "uc", "bc", "ec", "m", "cr", "f"]}}
{"id1": "18989018", "id2": "4164833", "code1": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 0, "substitutes": {"doSetInput": ["doGetInput", "doGetText", "dosetInput", "doSetOutput", " doGetText", "doProcessInput", "doGetContent", " doSetContent", "dosetOutput", "doProcessText", "dosetText", " doGetOutput", "doSetText", " doSetOutput", "doProcessOutput", " doGetContent", "doSetContent", " doSetText", "doGetOutput", "dosetContent", "doProcessContent", " doGetInput"], "input": ["image", "argument", "model", "method", "field", "resource", "q", "child", "raw", "submit", "agent", "storage", "view", "inner", "current", "temp", "form", "inf", "audio", "head", "impl", "project", "Input", "entry", "active", "text", "parser", "output", "key", "list", "remote", "null", "element", "definition", "act", "IN", "initial", "session", "select", "type", "upload", "progress", "container", "insert", "pull", "img", "command", "client", "util", "context", "xml", "expression", "present", "request", "operator", "magic", "instance", "error", "reader", "enter", " inputs", "config", "exec", "install", "inc"], "monitor": ["mi", "method", "unit", "resource", "bm", "system", "module", "config", "directory", " monitoring", "metadata", "meter", "param", "channel", " monitors", "mon", "summary", "pin", "mx", "Monitor", "condition", "subject", "state", "handler", "p", "progress", "counter", "pm", "out", "client", "manager", "wm", "loader", "report", "cm", "mod", "watch", "dm", "callback", "mc", "reader", "timer", "timeout", "console", "m", " Monitor", "processor"], "root": ["folder", "slave", "base", "resource", "system", "storage", "this", "directory", "mount", "owner", "target", "Root", "cms", "src", "http", "process", "output", "remote", "table", "writer", "media", "roots", "home", "null", "array", "r", "store", "collection", "work", "node", "m", "p", "result", "container", "out", "region", "manager", "location", "archive", "server", "instance", "tx", "n", "or", "config", "host", "parent", "plugin", "cover", "library"], "format": ["image", "unit", "plugin", "base", "service", "model", "temp", "config", "event", "form", "transform", "function", "et", "pattern", "at", "version", "filter", "atter", "parser", "filename", "output", "api", "writer", "Format", "object", "style", "string", "class", "act", "element", "spec", "handler", "ant", "type", "attribute", "record", "util", "name", "title", "term", "data", "fn", "magic", "FORM", "feature", "template", "location", "f"], "source": ["image", "rule", "unit", "service", "resource", "SOURCE", "storage", "view", "Source", "content", "inner", "target", "channel", "src", "text", "slice", "output", "remote", "use", "rate", "info", "object", "scope", "via", "string", "driver", "spec", "session", "token", "node", "ource", "result", "container", "client", "secure", "size", "proxy", "component", "data", "id", "reference", "description", "instance", "reader", "connection", "config", "parent"], "in": ["resource", "In", "element", "c", "again", "p", "it", "img", "ins", "name", "isin", "include", "str", "value", "connection", "m", "parent", "f", "body", "login", "gin", "src", "slice", "bin", "conn", "read", "r", "from", "session", "pass", "token", "doc", "nin", "io", "pull", "is", "init", "inside", "id", "reader", "win", "get", "din", "ini", "err", "inner", "inn", "version", "text", "update", "IN", "container", "out", "data", "on", "or", "inc", "socket", "image", "index", "download", "pin", "buffer", "ource", "min", "con", "i", "n", "config"], "path": ["model", "resource", "step", "filename", "full", "p", " filename", "dir", "name", "thin", "component", "binary", "str", "value", "host", "parent", "directory", "folder", "log", "child", "point", "this", "content", "alias", " string", "pattern", "src", "sync", "slice", "api", "password", "string", "PATH", "code", "session", "core", "token", "loader", "id", "reader", "template", "loc", "method", "base", "Path", "text", "remote", "object", "walk", "node", "type", "pointer", "container", "out", "data", "port", "one", "location", "mount", "image", "link", "index", " Path", "key", "route", "work", "part", "ath", "true", "config"], "s": ["folder", "o", "service", "storage", "share", "stores", "abs", "ls", "sa", " storage", "services", "sharing", "ns", "src", "http", "slice", "sync", "l", "b", "space", "ws", "js", "scope", "c", "r", "store", "spec", "g", "session", "ps", "d", "p", "settings", "ds", "si", "S", "os", "sv", "v", "sb", "an", "fs", "secure", "ssl", "gs", "sys", "h", "e", "sf", "sym", "ss", "sl", "i", "n", "m", "f"], "file": ["File", "image", "folder", "base", "unit", "resource", "feed", "section", "storage", "content", "audio", "ile", "open", "up", "filename", "use", "slice", "l", "b", "info", "full", "object", "remote", "output", "media", "string", "future", "pe", "files", "Image", "store", "node", "p", "io", " File", "x", "fp", "dir", "FILE", "il", "xml", "icon", "name", "archive", "data", "fn", "binary", "e", "sf", "port", "value", "lib", "f", "copy", "directory"], "uri": ["image", "rule", "base", "URL", "resource", "service", "prefix", "storage", " URI", "iri", "cli", "Url", "entry", "http", "text", "filename", "api", "ui", "object", "uid", "ri", "pi", "gi", "route", "query", "abi", "handler", "uni", "io", "attribute", "dir", "util", "URI", "name", "location", "term", "qi", "server", "data", "id", "range", "username", "i", "database", "connection", "address"], "url": ["link", "image", "URL", "base", "resource", "fr", "ul", "Url", "channel", "ref", "http", "src", "text", "key", "l", "object", "string", "ri", "store", "ource", "io", "rel", "layer", "name", "ssl", "location", "sr", "data", "id", "user", "str", "sl", "config", "address"], "cd": ["dd", "nd", "de", "CR", "dr", "dc", "xd", "arch", "ca", "cb", "vd", "C", "cf", "c", "def", "ct", "rc", "d", "ci", "ds", "ck", "cs", "CF", "ce", "cy", "xc", "cc", "gd", "cm", "CD", "cp", "clean", "co", "lab", "DC", "pd", "CE", "CC", "CS", "cr", "md", "cand"], "valid": ["vals", " invalid", "Invalid", "stable", "current", "val", "pattern", "VAL", "available", "active", "bad", "standard", "local", "cert", "list", "required", "full", "visible", "regular", "vari", "style", "post", "array", "def", "broken", " Valid", "supported", "legal", "good", "Valid", "multi", "v", "allowed", "all", "acceptable", "sign", "multiple", "secure", "defined", "correct", "missing", "present", "data", "id", "compatible", "value", "empty", "complete", "normal", "iter", "successful"], "stream": ["image", "body", "video", "model", "flow", "resource", "feed", "raw", "temp", "content", "form", "draw", "transform", "trans", "channel", "serial", "message", "output", "writer", "object", "string", "read", "handler", "container", "v", "row", "response", "client", "context", "clean", "data", "reader", "sw", "Stream"], "document": ["image", "_", "video", "model", "resource", "system", "feed", "ocument", "this", "Source", "content", "metadata", "text", "filename", "output", "media", "writer", "object", "style", "collection", "author", "doc", "Filename", "record", "io", "response", "xml", "Document", "material", "data", "description", "Reader", "reader", "template", "parent"]}}
{"id1": "9261777", "id2": "530882", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"source": ["image", "rule", "unit", "force", "index", "in", "resource", "SOURCE", "options", "service", "base", "site", "prefix", "view", "config", "Source", "inner", "sample", "input", "target", "parse", "src", "zip", "text", "slice", "use", "info", "scope", "style", "string", "null", "element", "spec", "session", "token", "path", "sort", "strip", "query", "single", "original", "ource", "result", "se", "uri", "sin", "dest", "flat", "secure", "size", "start", "missing", "name", "proxy", "request", "data", "id", "file", "seed", "parent", "comment", "empty", "shared", "sl", "template", "project", "url", "copy", "address"], "destination": ["destension", "destinator", "destinating", "distinated", "Destination", "Destinating", " destinator", "Destignment", "domuration", "coordinating", "Destinated", "distipping", "Desturation", "destipping", "coordination", "destignment", "Destinator", "homeination", "desturation", "dominated", "homeinator", "Destinate", "databaseuration", " destignment", "Destinations", " destipping", "distension", "coordinate", "dependension", " destinating", "dependination", "dominations", "destinate", "destinated", "databaseinations", "databaseinated", "destinations", " destension", "distination", "dependipping", " destinated", "homeignment", "coordinator", "dependinated", " destinate", "domination", "homeinated", "databaseination"], "is": ["ib", "in", "serv", "isi", "abs", "ops", "mis", "osi", "ii", "zip", "nis", "ir", "src", "lis", "api", "info", "ui", "IS", "ri", "act", "obs", "was", "ic", "ci", "ie", "ris", "io", "se", "isl", "eni", "oss", "ai", "out", "isa", "sis", "fs", "ip", "ins", "iss", "cos", "as", "close", "iso", "init", "are", "bis", "ens", "us", "ori", "ois", "es", "esi", "bs", "id", "ob", "isc", "ios", "Is", "i", "ais", "get", "or", "ar", "sin", "iris", "ics", "s"], "os": ["ou", "o", "vs", "ops", "ls", "osi", "bos", "dos", "mos", "ends", "acs", "oise", "ow", "js", "so", "pos", "obs", "ies", "op", "ds", "boot", "io", "ros", "Os", "nos", "oss", "out", "fs", "cos", "oes", "as", "es", "oS", "ens", "us", "ori", "sys", "bs", "oa", "oses", "ose", "ot", "ob", "ol", "ios", "OS", "ss", "i", "ais", "ks", "or", "los", "aos", "socket", "s"], "buffer": ["image", "base", "feed", "wave", "sequence", "flush", "channel", "slice", "queue", "b", "writer", "bytes", "bb", "page", "copy", "string", "null", "buf", "read", "pad", "position", "buff", "border", "padding", "uffer", "result", "number", "layer", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "Buffer", "url", "header", "address"], "length": ["index", "shape", "section", "feed", "end", "depth", "quote", "point", "of", "offset", "sequence", "duration", "match", "Length", "age", "load", "count", "power", "total", "slice", "key", "l", "full", "object", "left", "string", "code", "style", "position", "strip", "split", "division", "part", "type", "line", "width", "len", "number", "row", "character", "block", "start", "size", "distance", "volume", "ring", "id", "data", "range", "weight", "ob", "limit", "level", "last", "lock", "value", "reader", "get", "lower", "partial", "url", "address"]}}
{"id1": "21063400", "id2": "13891080", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"doImageProcess": ["doFileProcess", " doimageprocess", " doimageFile", "doImageprocess", "doThumbnailProcess", "doThumbnailprocess", "doimageFile", "doFileFile", " doimageProcess", "doImageFile", " doImageFile", "doThumbnailFile", " doImageprocess", "doimageprocess", "doFileprocess", "doimageProcess"], "request": ["image", "method", "model", "resource", "stream", "input", "req", "message", "writer", "object", "application", "path", "query", "Request", "type", "result", "client", "xml", "report", "name", "server", "data", "instance", "reader", "config", "url", "header"], "response": ["image", "onse", "body", "model", "index", "service", "resource", "pool", "feed", "wave", "video", "site", "view", "Response", "json", "version", "http", "message", "cache", "output", "queue", "api", "respond", "writer", "full", "object", "page", "application", "status", "example", "more", "collection", "resp", "session", "next", "success", "result", "out", "client", "report", "ception", "location", "server", "document", " Response", "error", "description", "results", "complete", "default", "connection", "host", "reply"], "imgSize": [" imgScale", "bgScale", "largeSize", "imgType", "hrType", "imageScale", "imgLen", " imgLen", " imgFamily", "imgName", "imageName", "imagType", "bgFamily", "bgWidth", " imgLength", "dimHeight", "dimSize", "imagsize", "ifName", "augFamily", "imagSize", "refLength", "refHeight", "imgLength", "largeType", "imgScale", " imgWidth", "ifSize", "imageLength", "refSize", "hrC", "imsize", "ifLen", " imgName", "imLength", "hrsize", "imgC", "imgsize", "imgFamily", "augLen", "bgLength", "imHeight", "imgWidth", " imgsize", "hrSize", "largesize", "imageLen", "refsize", "imSize", "augWidth", "dimsize", "bgSize", "ifsize", "imageSize", "imagC", "imgHeight", "augSize", "dimLength", "imagesize", "largeC", "bgLen"], "imageInputStream": ["imageInputView", "imageUploadSteam", "imageContentStream", " imageInputFile", "imageReadstream", "photoReadSteam", "imageReadFile", "imageStreamStream", "fileInputLength", "imageInLength", "fileInputString", "fileInputStream", "photoInputSteam", "fileReadstream", "fileReadStream", "imageFilestream", "imageFileString", "imageReadSteam", "pictureUploadSteam", "imageUploadFile", " imageOutputStream", "imageInString", "imageReadString", "photoReadFile", "imageContentView", " imageOutputFile", "imageStreamstream", "imageOutputstream", "imageUploadView", "imageInputstream", "imageOutputStream", "imageUploadstream", "imageInStream", "pictureUploadstream", " imageOutputSteam", "pictureInputFile", "fileReadString", "imageUploadStream", "fileReadLength", "imageStreamFile", "pictureInputstream", "imageFileLength", "imageFileStream", "photoInputStream", "photoInputFile", "imageOutputFile", "imageReadStream", "imageInputString", "imageOutputSteam", "photoReadstream", " imageInputSteam", "imageOutputView", "pictureUploadStream", "pictureUploadFile", "imageInstream", " imageInputView", "photoReadStream", "imageStreamSteam", "imageContentSteam", "pictureInputStream", "fileInputstream", "imageReadLength", "imageInputFile", "pictureInputSteam", "imageInputLength", "imageContentFile", "photoInputstream", " imageOutputView", "imageInputSteam"], "imageBytes": ["fileBlocks", "audioBuffer", "viewData", "viewUrl", "pictureBlocks", "imgBuffer", "audioByte", "imageData", "fileData", "ImageData", "viewbytes", "pictureData", "imgUrl", "Imagebytes", "imagebytes", "imgData", "ImageBytes", " imageByte", " imageData", "fileBytes", "imageBuffer", "imgbytes", "pictureBytes", " imageUrl", "ImageBlocks", "imageUrl", "picturebytes", "filebytes", "imgBytes", "audiobytes", " imagebytes", "viewBytes", "imgByte", "imageByte", "audioBytes", "imageBlocks", " imageBuffer"]}}
{"id1": "12236729", "id2": "21316706", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    @Override\n    protected URLConnection openConnection(URL url, Proxy proxy) throws IOException {\n        if ((url == null) || (proxy == null)) {\n            throw new IllegalArgumentException(Messages.getString(\"luni.1B\"));\n        }\n        return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy);\n    }\n", "label": 0, "substitutes": {"copy": [" dup", "clone", "download", "py", " copied", " copying", " Copy", "paste", "zip", "cop", "sync", "replace", "cat", "clip", "split", "p", "cmp", "upload", "io", "diff", "dump", "Copy", "transfer", "php", "get", "cp", " transfer"], "inputFile": [" inputPath", " inputFiles", "inputPath", "currentFile", "inputfile", "outputDir", " inputDir", "sourcePath", "inputDir", " inputfile", "currentfile", "inputFiles", "sourceFile", "sourcefile", "currentDir", "outputFiles", "outputfile", "outputPath", "currentFiles", "sourceFiles"], "outputFile": [" outputDirectory", "tempFile", "referenceFile", "tempfile", "OutputFile", "inputfile", "outputDir", "outputFilename", "tempDir", "inputDir", "referencefile", " outputfile", " outputDir", "Outputfile", "OutputDirectory", "tempDirectory", "outputfile", "referenceFilename", "outputDirectory", " outputFilename", "referenceDir", "inputFilename", "OutputDir"], "in": ["ini", "err", "kin", "image", "login", "inner", "inn", "gin", "input", "In", "up", "l", "bin", "conn", "read", "pin", "IN", "r", "again", "source", "nin", "sin", "cin", "min", "pull", "ins", "into", "is", "lin", "as", "init", "inside", "a", "con", "ln", "id", "file", "e", "lock", "reader", "i", "win", "n", "get", "connection", "din", "f", "socket", "inc", "s"], "out": ["err", "log", "o", "outer", "temp", "outside", "w", "write", "plain", "over", "net", "at", "obj", "up", "cache", "sync", "output", "OUT", "writer", "bin", "b", "extra", "conn", "post", "null", "again", "outs", "plus", "line", "io", "v", "Out", "off", "file", "parent", "error", "ex", "i", "one", "n", "inc", "exec", "socket"], "c": ["lc", "esc", "o", "cl", "pc", "count", "cu", "fc", "l", "b", "cd", "ch", "C", "code", "cf", "r", "ct", "rc", "d", "k", "ci", "p", "sc", "line", "pointer", "v", "x", "ce", "cy", "xc", "cc", "character", "cm", "col", "a", "id", "char", "e", "u", "i", "n", "uc", "ec", "m", "cr", "f"]}}
{"id1": "21182766", "id2": "3801655", "code1": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "label": 0, "substitutes": {"load": ["resources", "setup", "resource", "create", "check", "write", "download", "find", "parse", "add", "process", "use", "info", "update", "read", "set", "loaded", "class", "LOAD", "store", "path", "loading", "proc", "build", "start", "loader", "init", "pack", "construct", "dump", "include", "call", "Load", "loads", "get", "delete", "config", "install", "copy", "save"], "propsName": ["comppsPath", "proPSNames", "comppertiesname", "propertiesPath", "propertiesName", "proPSPath", "comppertiesName", "comppertiesPath", "proPSName", "profsname", "pepertiesPath", "pepsname", "profsPath", "comppsDesc", "propsDesc", "comppsName", "pepsNames", "pepertiesNames", "propertiesDesc", "pepsPath", "proPSDesc", "profsName", "pepsName", "propertiesname", "profsDesc", "propsname", "profsNames", "pepertiesName", "propertiesNames", "comppsname", "pepertiesname", "proPSname", "propsPath", "propsNames", "comppertiesDesc"], "props": ["crops", "croperties", "propos", "compbs", "prps", "perpos", "perbs", "prots", "prids", "prpps", "pecs", "prips", "perps", "cropps", "Procs", "properties", "comppos", "procs", "compps", "Props", "pebs", "prperties", "prpr", "Prots", "pribs", "prebs", "propps", "prets", "protps", "cropr", "probs", "protpps", "propr", "protperties", "Probs", "protpr", "pripos", "peps", "prods", "compds", "preps", "precs", "pets", "perds"], "url": ["URL", "base", "resource", "service", "feed", "config", "stream", "event", "cl", "Url", "channel", "ref", "src", "http", "l", "b", "api", "page", "r", "bel", "buffer", "path", "not", "fl", "uri", "xml", "loader", "name", "location", "ssl", "server", "data", "file", "user", "gl", "e", "id", "ob", "browser", "sl", "i", "jar", "source", "f"]}}
{"id1": "8329093", "id2": "11968328", "code1": "    public void parse(ParserEvent event) {\n        logger.debug(\"parse() called for link \" + event.getLink().getURI());\n        if (event.getLink().getURI().matches(itemFilter)) {\n            logger.debug(\"Content \" + event.getLink().getURI() + \" matched\");\n            Statement stmt = null;\n            ResultSet rs = null;\n            long checksum1 = 0;\n            try {\n                URL url = new URL(event.getLink().getURI());\n                checksum1 = url.openConnection().getLastModified();\n            } catch (MalformedURLException mfe) {\n                logger.error(\"Malformed url \" + event.getLink().getURI() + \" - \" + mfe.getMessage());\n                return;\n            } catch (IOException ioe) {\n                logger.error(\"Couldn't read \" + event.getLink().getURI() + \" - \" + ioe.getMessage());\n                return;\n            }\n            if ((checksum1 == 0) || (checksum1 == 1)) {\n                Adler32 adler32 = new Adler32();\n                NodeList nodes = (NodeList) event.getPageData().getData();\n                adler32.update(nodes.toHtml().getBytes());\n                checksum1 = adler32.getValue();\n            }\n            try {\n                stmt = conn.createStatement();\n                rs = stmt.executeQuery(\"SELECT * FROM documents WHERE url='\" + event.getLink().getURI() + \"'\");\n                if (rs.first()) {\n                    long checksum2 = rs.getLong(\"checksum\");\n                    if (checksum1 == checksum2) {\n                        stmt.executeUpdate(\"UPDATE documents SET checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    } else {\n                        stmt.executeUpdate(\"UPDATE documents SET checksum=\" + checksum1 + \", checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    }\n                } else {\n                    stmt.executeUpdate(\"INSERT INTO documents VALUES \" + \"(DEFAULT, '\" + event.getLink().getURI() + \"', \" + checksum1 + \", '\" + providerId + \"', \" + String.valueOf(System.currentTimeMillis()) + \")\");\n                }\n            } catch (SQLException e) {\n                logger.error(\"Could't perform database query or update - \" + e.getMessage());\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    rs = null;\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    stmt = null;\n                }\n            }\n        }\n    }\n", "code2": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"parse": [" explode", " assemble", " scan", "patch", " setup", "parser", "process", "replace", "info", "apply", " merge", " split", " read", " parsing", "se", " discover", " patch", "Parser", "handle", " serve", "pack", " dissect", " parser", " sniff", "arse", " extract", " analyse", " build"], "event": ["image", "flow", "action", "resource", "other", "view", "stream", "this", "content", "input", "function", "open", "entry", "version", "load", "message", "cache", "text", "events", "info", "environment", "object", "update", "style", "element", "g", "item", "vent", "handler", "node", "author", "original", "type", "attribute", "result", "v", "x", "entity", "response", "ce", "layer", "context", "xml", "app", "request", "data", "ev", "document", "Event", "e", "user", "instance", "error", "comment", "actual", "config", "source", "parent", "address"], "stmt": ["stbl", "Stmt", " stct", "stct", "tct", "Stmb", "adbl", "stmd", "tm", "dmt", "adnt", "adql", "stql", "stpt", "tmb", " stmn", "rpt", "stnt", "stmn", "Stct", "tbl", "rnt", "dnt", " start", "spmt", "Stmd", "STm", " stmb", "stm", "tmd", " stbl", "start", "rmt", "Stpt", "dpt", "adpt", " stpt", "spbl", "rql", "adart", "STmn", "dql", "tpt", "Stm", " stm", "admt", "STmt", "spmd", "stmb", "spart", "tmt", " stmd", "Stbl", "STmd", "tmn", "admd"], "rs": ["resources", "ars", "sels", "vals", "rys", "eers", "odes", "RC", "ls", "runs", "lines", "rt", "details", "maps", "vers", "ges", "src", "repl", "events", "ms", "otes", "ws", "Rs", "pr", "rd", "r", "xs", "rows", "rc", "ps", "ats", "obs", "ows", "ds", "relations", "ris", "result", "acks", "ros", "rr", "ras", "cs", "mr", "opens", "qs", "ins", "hs", "hr", "ys", "sr", "gs", "icks", "nas", "bs", "RS", "results", "res", "ks", "ts", "stats", "rss"], "checksum1": [" checksum0", "checksums1", "checksque1", "checksque0", "checksnum91", " checkssum100", " checkssumOnce", "checksumi2", "checksum0", "checksumm2", "checksullOne", "checksnum1", " checkssum2", "checksummer91", "checksque2", " checksum3", " checksum91", "checksam2", "checksull61", "checksumi1", "checkssum1", " checksumOne", "checksumb2", "checksnumOne", "checksummOne", "checksUM3", " checkssum3", "checksumi3", "checksam100", "checksum61", "checksum100", "checksnum0", "checksum3", "checksums2", " checkssum91", "checksumbOne", "checksull1", "checkssum3", "checksumsOnce", "checksumm1", "checksUM2", "checksummer1", " checksum61", "checkssum91", "checkssum2", "checksUMOne", " checkssum1", " checkssumOne", "checksull2", "checksam0", "checkssum100", "checksumOne", "checksUM1", "checksummer0", "checksumb1", " checksum100", " checkssum0", "checksam1", "checksummer2", "checksum91", "checksnum2", "checksque100", "checksnum3", "checkssum0", "checkssumOnce", " checksumOnce", "checksnum61", "checkssumOne", " checkssum61", "checkssum61", "checksumOnce", "checksumsOne", "checksumbOnce"], "url": ["image", "link", "html", "URL", "base", "resource", "www", "Link", "impl", "stream", "coll", "content", "ul", "Url", "ball", "ls", "channel", "match", "http", "message", "text", "l", "b", "conn", "api", "object", "page", "string", " URL", "r", "bel", "buffer", "path", "job", "fl", "org", "uri", "pull", "layer", "blog", "orb", "xml", "URI", "ssl", "server", "data", "file", "ll", "user", "ob", "id", "el", "sl", "error", "connection", "loc", "location", "web", "f", "address"], "adler32": ["adlr40", "aclr16", " adler2", "adlr2", "adler31", "adger40", "adger32", "adlor32", " adger16", "adlr52", " adlr2", " adger31", "acler16", "adle32", "adlor2", "adlor16", "adlor52", "aclr52", "adder31", "adder40", "adder32", "adler40", " adler40", "aclr2", "aclr32", "adder16", "adle16", " adlr32", "adlr16", "acler52", "acler2", "adler52", "adlr32", "adle40", " adler31", "adger16", " adlr16", "acler32", " adler16", " adger40", " adlr40", "adger31", " adger32", "adler16", "adger2", "adler2", "adlr31", "adle2", "adger52"], "nodes": ["nubes", "snode", " nobs", "sents", "sode", "snodes", "nods", "Node", "Nobs", " node", "Nubes", " nubes", "todes", "tods", "node", "sods", "nents", "tents", "tode", "sodes", "snobs", "snubes", "Nents", "Nods", "Nodes", "nobs"], "checksum2": [" checksum0", "checksums1", "checkssum1", "checkssum0", "checksub2", " checkssum82", "checksummer82", "checksha1", "checksub1", " checksum82", "checksummer1", "checksums0", "checksha2", "checksha0", "checkssum2", "checksum0", " checkssum1", "checkssum82", " checkssum2", "checksub0", "checksummer0", "checksums2", "checksum82", " checkssum0", "checksha82", "checksummer2"]}}
{"id1": "12097948", "id2": "17337238", "code1": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL url = loader.getResource(id);\n        if (url == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream inStream = url.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }\n", "code2": "    private Retailer create() throws SQLException, IOException {\n        Connection conn = null;\n        Statement st = null;\n        String query = null;\n        ResultSet rs = null;\n        try {\n            conn = dataSource.getConnection();\n            st = conn.createStatement();\n            query = \"insert into \" + DB.Tbl.ret + \"(\" + col.title + \",\" + col.addDate + \",\" + col.authorId + \") \" + \"values('\" + title + \"',now(),\" + user.getId() + \")\";\n            st.executeUpdate(query, new String[] { col.id });\n            rs = st.getGeneratedKeys();\n            if (!rs.next()) {\n                throw new SQLException(\"\u041d\u0435 \u0443\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c generated key 'id' \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 retailers.\");\n            }\n            int genId = rs.getInt(1);\n            rs.close();\n            saveDescr(genId);\n            conn.commit();\n            Retailer ret = new Retailer();\n            ret.setId(genId);\n            ret.setTitle(title);\n            ret.setDescr(descr);\n            RetailerViewer.getInstance().somethingUpdated();\n            return ret;\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (Exception e1) {\n            }\n            throw e;\n        } finally {\n            try {\n                rs.close();\n            } catch (Exception e) {\n            }\n            try {\n                st.close();\n            } catch (Exception e) {\n            }\n            try {\n                conn.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"systemID": ["SystemRI", " systemRI", " systemIDS", "sysIDs", "classURI", "systemIDs", "SystemId", "SystemIDs", "systemURI", "sysRI", "classID", "sysName", " systemIDs", "SystemID", " systemId", " systemURL", "systemName", "SystemName", "classId", "systemURL", "systemId", "systemRI", " systemURI", "sysId", "systemIDS", "SystemURL", "SystemIDS", "sysURI", "sysID", "sysURL", "classIDS", "SystemURI", " systemName"], "id": ["ident", "image", "base", "in", "resource", "create", "end", "rid", "entry", "ids", "http", "modified", "key", "info", "uid", "style", "string", "code", "element", "did", "path", "ide", "pid", "ad", "type", "part", "uri", "ID", "it", "aid", "oid", "and", "Id", "ip", "is", "xml", "start", "init", "name", "sid", "mid", "data", "file", "layout", "f", "error", "i", "value", "one", "like", "source", "kid", "address"], "loader": ["lc", "folder", "log", "pool", "resource", "module", "system", "impl", "cl", "up", "load", "cache", "parser", "rar", "l", "builder", "class", "loaded", "driver", "Loader", "buffer", "path", "handler", "er", "lang", "container", "loading", "layer", "util", "init", "user", "file", "lock", "reader", "loc", "acl", "library"], "url": ["link", "image", "rule", "URL", "service", "resource", "fr", "base", "lr", "feed", "impl", "this", "stream", "coll", "event", "download", "Url", "ls", "http", "src", "l", "api", "b", "string", "r", "buffer", "rc", "path", "job", "io", "uri", "pull", "client", "il", "xml", "ur", "name", "location", "ssl", "server", "file", "ll", "sl", "rl", "lib", "loc", "source", "f", "address"], "inStream": ["innSocket", "INSteam", " inReader", " inStreamer", "INString", "innstream", "inputstream", "innStream", "inSteam", "inputStream", "INStreamer", "INStream", "outstream", " instream", "Instream", "conStreamer", "innSteam", "InSteam", " inString", "inReader", "inString", " inSteam", "InSocket", "outSteam", "inputSteam", "outStream", "outSocket", "InStream", "inputReader", "instream", "conSteam", "outReader", "inStreamer", "inSocket", "conString", "conStream"], "constraints": ["constraint", "constrains", "containt", "contains", "Constions", "concomplaint", "Constraint", "constaints", "Constraints", "constains", "contions", "Constrions", "Constaints", "concomplions", "concomplaints", "Constaint", "containts", "constaint", "constions", "concomplains", "constrions", "Constrains", "Constains"]}}
{"id1": "9449064", "id2": "15409512", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 1, "substitutes": {"readExp": [" readEx", "loadExp", "writeExpl", "loadEx", "readEXP", "ReadEXP", "ReadExpl", "ReadExp", " readexp", " readEXP", " readExpl", "Readexp", "readExpl", "loadExpl", "readEx", "writeEx", "loadExt", " readExt", "readExt", "loadexp", "writeExt", "writeexp", "readexp", "loadEXP"], "writeExp": ["WriteExt", "writeExpl", " writeexp", "writingEx", "writingExp", " writeCom", "writingCom", "Writeexp", "writingexp", "WriteExpl", "readExpl", "readEx", "writeEx", " writeExpl", "readExt", "WriteExp", "writeExt", "writeexp", "WriteEx", "readexp", "writeCom", "WriteCom", " writeEx", " writeExt"], "expFile": ["EXPFile", "EXPfile", "ExpFile", " experimentPlace", "expSourceFile", "expLine", " expPlace", "ExpSourceFile", " expSourceFile", "EXPLine", "expressSourceFile", "expDir", "xpFile", " experimentLine", "xpfile", "expressLine", "expressDir", "xpDir", "expressfile", " experimentFiles", "EXPPlace", "xpFiles", "ExpLine", "ExpDir", "expPlace", "EXPSourceFile", "xpString", " experimentFile", "expressFile", "xpLine", "ExpPlace", "expressPlace", "expfile", "EXPString", "expString", "EXPDir", "Expfile", "xpPlace", " expFiles", " expLine", "ExpString", " expDir", "expFiles"], "exp": ["ef", "lc", "model", "expl", "vec", "serv", "inf", " experiment", "EXP", "prov", "form", "project", "rep", " expansion", "fe", "feat", "zip", "nz", "asm", "jp", "pr", "scope", "example", "act", "spec", "push", "query", "pl", " expanded", "p", "sc", "express", "div", "plus", "x", "dj", "Exp", "expr", "xp", "iz", " exam", "app", "test", "ext", "host", "inst", " expand", "str", "i", "ng", "acc", "imp", "f", "obj"], "fi": ["ini", "yi", "ifi", "sci", "fa", "isi", "Fi", "py", "lli", "ii", "fe", "osi", "fc", "ifa", "info", "pi", "cf", "abi", "fb", "li", "ci", "ani", "flo", "ffe", "si", "xi", "ni", "bi", "eni", "ji", "fp", "FI", "qi", "wi", "fy", "sf", "i", "afi", "zi"], "oi": ["ini", "ski", "ilo", "ahi", "cci", "isi", "oci", "lli", "ii", "osi", "ofi", "shi", "ui", "oni", "uci", "abi", "li", "avi", "ci", "flo", "ani", "si", "io", "ni", "bi", "eni", "oid", "eye", "ji", "ai", "odi", "obb", "omi", "agi", "eu", "ogi", "edi", "oxy", "ori", "ois", "qi", "ti", "oa", "i", "di", "asi", "ki", "obi"], "jf": ["Jfx", "djfm", "jjfx", " jfx", "Jfe", "jfp", " jfs", "ujfs", "jb", "jpb", "ujf", "je", "appfx", "JF", " jF", "ff", " jfp", " jtf", "fe", "djf", " jfe", "jcf", "jfs", "jfr", " jp", "jarf", "jjf", "xf", "appf", "jtf", "jp", "ujfp", "zcf", "jfm", "Jb", "pp", "jpcf", "jF", "ffp", "jjcf", "xcf", "xfp", "uje", "jfe", "appcf", "ztf", " jcf", "pf", " jfm", "zfp", "jjfm", "pfr", "jfx", "appfe", "jarp", "xtf", "pb", "Jf", " jb", " je", "jpfx", "Jcf", "jpf", "jarb", "zf", " jfr", "ffs", "djfx", "djcf", "jarfr", "jpF"], "sp": ["html", "service", "bsp", "serv", "spe", "sci", "sk", "ap", "py", "fe", "space", "ch", "jp", "mp", "js", "page", "bp", "sup", "pr", "so", "pp", "cf", "scope", "spec", "wp", "amp", "ps", "SP", "pl", "sc", "p", "esp", "vp", "osp", "si", "op", "se", "ep", "sb", "sh", "sv", "sm", "fp", "app", "Sp", "tp", "inst", "sf", "s", "ss", "sl", "str", "sw", "ctx", "cp", "imp", "gp"], "e": ["ef", "event", "w", "et", "fe", "events", "pe", "t", "ie", "en", "se", "ent", "ep", "v", "x", "ce", "es", "ception", "ext", "ae", "ev", "Event", "el", "ctx", "ec", "exc", "ee"], "fo": ["bo", "yo", "o", "foo", "osa", "fa", "FO", "po", "py", "fe", "mo", " lo", "info", "tto", "olo", "so", "oooo", "obo", "ato", "zo", "ph", "flo", "ao", "io", "ho", "os", "ooo", "la", "ko", "co", "jo", "vo", "lo", "wo", "ico", "f", "obj"], "oo": ["bo", "ou", "ilo", "o", "foo", "osa", "oh", "FO", "po", "loo", "elo", "ox", "mo", "argo", "oda", "que", "olo", "ollo", "so", "oooo", "aco", "obo", "oe", "ao", "flo", "io", "oid", "os", "oto", "ooo", "OO", "va", "obe", "la", "ko", "co", "goo", "bean", "oa", "lo", "wo", "qa", "ico", "oos", "cro"], "ex": ["com", "err", "re", "expl", "EX", "event", "aux", "cl", "except", "ignore", "ix", "Ex", "Exc", "sex", "pex", " Ex", " exc", "js", "null", "class", "act", "def", "exit", "tex", "ct", "ic", "fail", "Exception", "se", "su", "used", "x", "es", "ception", "ext", "con", "ass", "rex", "ax", "error", "nex", "tx", "res", "six", "lex", "exc", "obj", "inc"]}}
{"id1": "16232202", "id2": "8667872", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"doPost": ["doPOST", " doSend", "didSend", "didPost", "doingPost", "doingPOST", "didPut", "doSend", "doingSend", "doingPut", "didPOST", "doPut", " doPut", " doPOST"], "request": ["re", "image", "method", "register", "resource", "create", "child", "q", "submit", "view", "self", "current", "event", "input", "order", "project", "req", "parse", "load", "message", "use", "remote", "rate", "queue", "info", "post", "QUEST", "object", "page", "list", "application", "rf", "condition", "initial", "session", "subject", "state", "external", "route", "next", "query", "store", "join", "Request", "er", "hello", "type", "upload", "result", "row", "client", "context", "xml", "report", "server", "user", "data", "e", "parent", "instance", "error", "reader", "web", "enter", "press", "complete", "get", "you", "select", "url", "save"], "response": ["re", "onse", "image", "de", "index", "pool", "service", "resource", "body", "feed", "model", "site", "serv", "view", "Response", "forward", "fire", "http", "message", "output", "api", "respond", "writer", "environment", "object", "shell", "page", "we", "application", "status", "exit", "session", "resp", "subject", "wa", "next", "query", "en", "result", "su", "uri", "report", "ception", "tree", "ae", "esi", "server", "document", "e", " Response", "error", "complete", "res", "web", "parent", "reply"], "cu": ["ou", "lc", "UC", "uu", "U", "cci", "Cu", "ku", "coll", "ul", "cli", "usa", "cur", "aca", "ue", "ca", "ui", "uci", "c", "cf", "vc", "cul", "chu", "rc", "ci", "asu", "uni", "su", "cin", "ce", "VC", "xc", "cy", "cc", "cum", "eu", "gu", "nu", "hu", "cus", "ucc", "agu", "du", "co", "ac", "tc", "loc", "CA", "tu", "cca", "CI", "u", "CU", "mc", "uc", "ru", "lu"], "ud": ["dd", "uda", "ou", "udi", "uu", "wik", "uli", "storage", "ku", "ub", "um", "utils", "cli", "usa", "usc", "ue", "ada", "ut", "uf", "ui", "uid", "uv", "vd", "da", "gb", "usr", "rc", "chu", "au", "li", "ci", "ad", "stri", "ck", "asu", "upload", "su", "uri", "df", "uds", "util", "od", "eu", "UD", "auth", "gu", "cus", "ur", "bug", "du", "pub", "us", "user", "tu", "pd", "u", "uc", "ru", "lu", "ug", "db"], "returnTo": ["replyTO", "accessto", "exitto", "replyFrom", "exitTO", "outputto", "backFrom", "accessTO", "exitTo", "ReturnTo", "exitFrom", "returnto", "replyTo", "Returnto", "outputTO", "returnTO", "backto", "ReturnFrom", "backTo", "accessFrom", "ReturnTO", "returnFrom", "accessTo", "replyto", "outputTo", "backTO", "outputFrom"], "password": ["encrypted", "Password", "sha", "email", "mask", "login", "account", "patch", "message", "key", "wallet", "wd", "pad", "string", "code", "null", "params", "crypt", "token", "pa", "padding", "confirmed", "pg", "phrase", "diff", "mac", "secret", "auth", "name", "PASS", "sum", "word", "ass", "data", "user", "username", "sword", "address"], "md": ["dd", "sha", "cmd", "meta", "am", "dc", "dig", "amd", "ma", " MD", "hd", "mm", "mad", "mo", "cd", "ms", "wd", "mp", "vd", "mn", "d", "mand", "bd", "pg", "df", "diff", "sm", "mg", "mac", "mt", "od", "managed", " Md", "MD", "mag", "rm", "dm", "mc", "f", "mb", "m", "rpm", "db"], "hash": ["her", "sha", "base", "raw", "hex", "dig", "version", "ref", "cache", "total", "key", "code", "array", "kh", "confirmed", "diff", "number", "rh", "sh", "mac", "secret", "row", "block", "ash", "auth", "Hash", "sum", "hed", "h", "ass", "user", "char", "no", "dot", "tag", "db", "url"], "pass": ["login", " def", " login", "text", " mac", "ref", "key", "conn", "wd", "string", "Pass", "def", "pos", " mess", "r", "act", "pa", "push", "strip", " Pass", "phrase", "mess", "fail", "ask", "diff", "row", "sign", "mac", "secret", "auth", "PASS", " passed", "sum", "ass", "id", "user", " auth", "gen", "az", " secret", "sl", "ss", "db", "conf"], "vis": ["vid", "tri", "nat", "shape", "circ", "vest", "cross", "fac", "view", "coll", "dc", "lit", "VIS", "san", "nic", "mis", "ravis", "skip", "feat", "exp", "ref", "mit", "visible", "virt", "style", "class", "status", "c", "act", "att", "miss", "state", "access", "wa", "type", "stat", "su", "sign", "secret", "ip", "design", "see", "gu", "na", "name", "Vis", "lab", "keep", "nav", "rib", "id", "vert", "spot", "qa", "ex", "press", "travel", "acc", "host"]}}
{"id1": "21491791", "id2": "2936678", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "label": 0, "substitutes": {"run": ["unit", "log", "create", "func", "worker", "process", "code", "apply", "running", "fork", "work", "job", "build", "all", "loop", "command", "start", "app", "spawn", "test", "runner", "call", "Run", "execute", "exec", "invoke"], "input": ["image", "flow", "index", "in", "resource", "raw", "feed", "storage", "view", "stream", "inner", "form", "audio", "Input", "worker", "active", "entry", "up", "text", "reading", "parser", "conn", "read", "driver", "initial", "state", "readable", "work", "control", "io", "out", "client", "context", "loader", "internal", "request", "data", "file", "user", "iterator", "instance", "connection", "config", "source", "address"], "output": ["writing", "image", "letter", "log", "written", "unit", "generated", "resource", "index", "temp", "outer", "end", "office", "write", "target", "text", "cache", "filename", "queue", "later", "environment", "object", "page", "application", "exit", "path", "job", "writers", "control", "console", "out", "response", "network", "Writer", "operation", "Output", "file", "data", "document", "user", "put", "web", "connection", "config", "source", "parent"], "reader": ["image", "slave", "in", "resource", "system", "view", "stream", "rer", "inner", "audio", "entry", "worker", "parser", "reading", "read", "driver", "builder", "ri", "r", "oder", "handler", "er", "author", "io", "row", "client", "context", "ner", "manager", "riter", "loader", "request", "peer", "wrapper", "server", "Reader", "source", "book", "owner", "rator"], "writer": ["writing", "her", "written", "wb", "outer", "office", "inner", "w", "write", "player", "wan", "entry", "worker", "wer", "ws", "engine", "builder", "driver", "ew", "r", "creator", "wa", "wr", "work", "er", "writers", "author", "wire", "nw", "out", "ner", "manager", "riter", "Writer", "word", "request", "ter", "wrapper", "data", "war", "maker", "rw", "writ", "or", "connection", "editor"], "pump": ["pamp", "prump", "Pumper", "camp", "ppump", "Pump", "dmp", "pdump", "ppumps", "humper", "dumps", "prdump", "pram", "Pdump", " pumping", " pam", "mump", "Pam", "prumper", "Pmp", " pmp", "Pumps", "hprint", " pamp", " pdump", "cumper", "pam", "Pprint", "Pumping", "pumping", "hump", "cump", "pumper", "dump", "pmp", "Pamp", "mprint", "ppumping", "mumps", " pumps", " pumper", "ppumper", "mumper", "pumps", "cumping", "humps", "pprint", "dumper"], "counter": ["num", "repeat", "index", "ver", "lr", "outer", "walker", "offset", "continue", "current", "inner", "step", "sequence", "order", "meter", "ener", "entry", "worker", "inter", "consumer", "version", "master", "count", "ger", "now", "race", "page", "builder", "code", "clock", "starter", "r", "collection", "rew", "author", "er", "hello", "Counter", "result", "pointer", "progress", "currency", "number", "row", "loop", "layer", "ner", "cookie", "loader", "trace", "ception", "runner", "keep", "ter", "server", "seed", "const", "instance", "second", "keeper", "center", "timer", "zero", "comment", "enter", "parent", "url", "processor"], "buffer": ["base", "resource", "entry", "channel", "text", "message", "queue", "uf", "page", "buf", "position", "buff", "uffer", "layer", "length", "loader", "server", "data", "file", "document", "reference", "port", "limit", "binary", "iter", "batch", "source", "Buffer", "url", "header", "address"], "off": ["flow", "o", "offs", "end", "offset", "of", "inner", "art", "head", "open", "ff", "Offset", "offer", "ref", "less", "area", "info", "ui", "now", "auto", "left", "set", "ord", "pos", "OFF", "fail", "opt", "addr", "out", "own", "start", "low", "on", "down", "oa", "unknown", "Off", "eno"], "len": ["body", "log", "lc", "in", "end", "lit", "val", "lf", "fin", "lan", "ref", "count", "ler", "lon", "den", "l", "bin", "ld", "pos", "fd", "li", "fl", "en", "line", "Len", "width", "lim", "all", "elt", "layer", "length", "size", "name", "ln", "on", "ll", "lt", "gen", "limit", "lock", "el", "n", "lib", "loc", "url", "lin"], "rd": ["dd", "nd", "dr", "lr", "fr", "rx", "ud", "val", "rid", "xd", "rt", "RD", "RR", "adr", "ld", " prod", " r", "rod", "ord", "rf", "r", "rc", "fd", "d", "ind", "db", "rob", "ds", "rand", "red", "rr", "nr", "rh", "raid", "ra", "rs", "hr", "rn", "rm", "rss", "rb", "rw", "rl", "ru", "cr", "dra"]}}
{"id1": "11562173", "id2": "18433984", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["checkOutputSteam", "checkInputstream", "checkFileChannel", " checkInputChannel", " checkInputstream", "checkOutputChannel", " checkOutputstream", "checkInputSteam", "checkFileSteam", " checkOutputSteam", " checkInputSteam", "checkIOSteam", "checkFileStream", "checkIOstream", "checkIOChannel", "checkInputChannel", "checkIOStream", "checkOutputStream", "checkOutputstream", " checkOutputStream", "checkFilestream", " checkOutputChannel"], "in": ["ini", "image", "index", "login", "inner", "inn", "input", "In", "up", "src", "bin", "c", "IN", "ack", "again", "ic", "plus", "p", "source", "io", "x", "min", "comp", "ins", "is", "into", "as", "con", "isin", "data", "reader", "connection", "din", "inc"], "cmp": ["com", "lc", "np", "index", "conv", "prefix", "coll", "pre", "pc", "match", "omp", "ctrl", "up", "cop", "cache", "ch", "roc", "cb", "mp", "sup", "code", "c", "spec", "cpp", "amp", "rc", "clip", "upp", "sort", "ci", "p", "op", "cs", "diff", "proc", "comp", "mom", "fp", "cc", "pixel", "prev", "cho", "co", "asc", "loc", "cup", "comment", "ctx", "cp", "config"], "all": ["coll", "am", "global", "both", "cl", "none", "except", "match", "alpha", "always", "process", "local", "total", "list", "l", "full", "auto", "ann", "null", "array", "not", "p", "ALL", "allow", "and", "All", "any", "only", "each", "a", "sum", "asc", "al", "best", "valid", "call", "one", "default", "partial", "acl", "parent"], "stream": ["model", "pool", "temp", "raw", "feed", "cont", "impl", "this", "self", "coll", "form", "track", "transform", "input", "trans", "channel", "up", "src", "platform", "stack", "output", "round", "object", "speed", "null", "string", "ack", "progress", "result", "steam", "v", "comp", "response", "client", "context", "test", "ream", "wrapper", "host", "user", "document", "roll", "port", "instance", "iterator", "reader", "per", "sw", "Stream", "source", "socket"], "out": ["image", "index", "o", "outer", "other", "prefix", "point", "this", "project", "exp", "up", "sync", "output", "OUT", "list", "full", "bin", "extra", "b", "null", "option", "array", "c", "again", "outs", "not", "p", "part", "io", "result", "v", "x", "response", "Out", "block", "name", "sum", "data", "user", "comment", "inc", "parent", "obj", "copy"], "i": ["ini", "lc", "mi", "index", "j", "oi", "end", "hi", "ii", "ix", "fi", "slice", "key", "l", "b", "info", "ui", "ri", "pi", "c", "r", "gi", "abi", "k", "ind", "li", "d", "ci", "p", "type", "multi", "si", "io", "xi", "I", "bi", "v", "x", "ai", "ji", "uri", "it", "start", "init", "ti", "h", "id", "qi", "e", "strength", "u", "n", "di", "f"]}}
{"id1": "18339787", "id2": "7911686", "code1": "    private void reload() {\n        if (xml != null) {\n            try {\n                String currentDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n                if (currentDate.equalsIgnoreCase(exchangeRateDate)) {\n                    return;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        XPath xpath = null;\n        try {\n            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            URLConnection conn = null;\n            URL url = new URL(\"http://www.ecb.int/stats/eurofxref/eurofxref-daily.xml\");\n            conn = url.openConnection();\n            xml = docBuilder.parse(conn.getInputStream());\n            xpath = XPathFactory.newInstance().newXPath();\n            exchangeRateDate = xpath.evaluate(\"/Envelope/Cube/Cube/@time\", xml);\n            xpath = XPathFactory.newInstance().newXPath();\n            NodeList currenciesNode = (NodeList) xpath.evaluate(\"/Envelope/Cube/Cube/Cube[@currency]\", xml, XPathConstants.NODESET);\n            currencies = new String[currenciesNode.getLength()];\n            for (int i = 0; i < currencies.length; i++) {\n                currencies[i] = currenciesNode.item(i).getAttributes().getNamedItem(\"currency\").getTextContent();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"reload": ["refill", "preloading", "refloading", "reffill", "prefill", "refload", "overfill", "preload", "overload", "preresh", "refresh", "reresh", "reloading", "overresh", "overloading"], "currentDate": ["CurrentKey", "currentTime", "reportedDay", "currentName", "newKey", "CurrentName", " currentDay", "newDate", " currentKey", " currentName", "CurrentDay", " currentUpdate", "currentUpdate", "newUpdate", "reportedTime", "newDay", "currentDay", "reportedName", "CurrentDate", "currentKey", " currentTime", "reportedDate", "CurrentTime", "CurrentUpdate"], "xpath": ["exstream", "xstream", "exath", "exparent", "xath", " xath", " xprop", "exPath", " xparent", "Xp", "expath", " xp", "lexparent", "axPath", "Xpath", "exp", "xPath", " xPath", "xparent", "axpath", "Xstream", "lexPath", "txstream", "txpath", "xcase", "exprop", "XPath", "Xcase", "lexstream", "txPath", "xp", "axcase", " xcase", "Xath", "axath", " xstream", "xprop", "Xprop", "lexpath"], "docBuilderFactory": ["projectbuilderInterface", "projectBuilder2", "docBuildFactor", "projectbuilderFactor", "docManagerFactor", "docBuilderInterface", "docbuilder2", "docBuilder2", "docManager2", "projectBuilderFactory", "docbuilderF", "docBuilderService", "docManagerInterface", "docbuilderFactory", "documentBuildFactory", "documentBuildF", "docBuilderF", "projectBuilderFactor", "documentBuilderF", "docBuildService", "projectbuilder2", "projectBuilderInterface", "docbuilderService", "docBuildInterface", "projectbuilderFactory", "docBuildFactory", "docbuilderFactor", "docBuildF", "docBuild2", "docBuilderFactor", "documentBuildService", "documentBuilderService", "documentBuilderFactory", "docbuilderInterface", "docManagerFactory"], "docBuilder": ["fileFactory", "fileBuilder", "DocBuild", "DocBuilder", "documentbuilder", "docbuilder", "fileBook", "documentBuild", " docBook", " docBuild", " docFactory", "docBook", "documentParser", "xmlBuild", "docParser", "xmlParser", "xmlbuilder", "DocParser", "xmlBuilder", "documentFactory", "documentBook", "Docbuilder", "documentBuilder", "fileBuild", "docFactory", "docBuild"], "conn": ["enc", "lc", "body", "log", "URL", "conv", "cmd", "nt", "config", "serv", "coll", "cli", "Url", "nc", "channel", "Connection", "http", "l", "ch", "api", "cb", "ann", "c", "ct", "session", "path", "db", "ci", "out", "client", "loader", "cm", "ssl", "socket", "con", "server", "cn", "connect", "lock", "Conn", "ctx", "cp", "connection", "loc", "uc", "exec", "conf"], "url": ["image", "err", "log", "URL", "base", "resource", "fr", "www", "feed", "impl", "serv", "coll", "download", "Url", "ls", "channel", "http", "l", "string", "bel", "path", "db", "org", "uri", "build", "client", "blog", "loader", "ssl", "server", "data", "file", "ll", "ob", "gl", "str", "sl", "connection", "config", "host", "web", "f"], "xml": ["image", "model", "html", "log", "graph", "email", "feed", "temp", "office", "wl", "stream", "event", "content", "root", "input", "json", "arr", "children", "parse", "zip", "http", "events", "writer", "update", "page", "element", "txt", "atom", "example", "wt", "dom", "path", "node", "doc", "ml", "x", "response", "apache", "context", "tree", "request", "data", "file", "document", "layout", "php", "el", "rss", "reader", "date", "config", "address"], "exchangeRateDate": ["excurrencyTimeFile", "expireRatePrice", "exchangeRatingFormat", "exchangeFactorDate", "exchangeRatingPrice", "expirePriceFormat", "expireRateFormat", "expirePriceDate", "exchangeWeightFormat", "excurrencyTimeDuration", "expirePricePrice", "exchangePricePrice", "exchangePriceKey", "exchangeFactorTime", "exchangeFactorDuration", "exchangeRatingDate", "excurrencyTimeDate", "exchangePriceFormat", "exchangeTimeDate", "excurrencyRateFile", "expireRateDate", "exchangeRateDuration", "exchangeRatePrice", "expirePriceKey", "exchangeRateKey", "exchangeRateFile", "excurrencyRateDuration", "exchangeWeightDate", "exchangeRateFormat", "excurrencyRateDate", "exchangeWeightPrice", "exchangePriceDate", "exchangeTimeDuration", "exchangeRatingKey", "excurrencyTimeTime", "exchangeWeightKey", "exchangeRateTime", "exchangeFactorFile", "excurrencyRateTime", "exchangeTimeTime", "expireRateKey", "exchangeTimeFile"], "currenciesNode": ["cururrenciesArray", "curatorsNode", "curcurrencyElement", "comportsElement", "curratesRoot", "contractrenciesBlock", "contractrenciesNode", "currenciesDocument", "curriesRoot", "courrenciesNode", "curratesDocument", "contracturrenciesDocument", "cururrenciesContainer", "courrenciesnode", "curitiesNode", "contracturrenciesBlock", "contractrenciesDocument", "curratesNode", "curcurrencyBlock", "curlationsPath", "comportsNode", "currenciesContainer", "comrenciesElement", "currenciesBlock", "curatorsContainer", "corenciesnode", "currenciesElement", "comrenciesNode", "curriesBlock", "curportsPath", "contracturrenciesNode", "cururrenciesnode", "cururrenciesRoot", "currenciesnode", "cururrenciesDocument", "comportsPath", "currenciesArray", "comrenciesPath", "corenciesNode", "currenciesRoot", "curportsNode", "currenciesPath", "curratesBlock", "cururrenciesBlock", "curitiesnode", "curportsElement", "curriesNode", "curcurrencyPath", "curcurrencyNode", "curatorsArray", "cururrenciesNode", "corenciesContainer", "curatorsnode", "comrenciesBlock", "curlationsNode", "courrenciesContainer", "curportsBlock", "curlationsBlock", "curitiesContainer", "curlationsElement", "curitiesArray", "contracturrenciesRoot", "comportsBlock", "contractrenciesRoot", "courrenciesArray", "corenciesArray", "curriesDocument"], "currencies": ["churrency", "cururrency", " curums", "chales", "urversions", "curries", "charrency", " curries", "scheries", "scherencies", "charrencies", "carrencies", "perversions", "uracters", "curcoins", "perums", " curacters", "locrencies", "urums", "locurrency", "chcoins", "curums", "loccoins", "chrencies", "perrencies", "cururrencies", "currency", "carales", " curversions", "curales", "peracters", "curversions", "curacters", "scheurrencies", " cururrencies", "carcoins", "scherency", "charurrencies", "charries", " currency", "urrencies", "carurrency", "locales"], "i": ["z", "lc", "index", "j", "o", "in", "q", "oi", "chi", "yi", "end", "hi", "phi", "ii", "fi", "slice", "mu", "l", "b", "info", "ui", "ri", "pi", "c", "r", "gi", "g", "t", "abi", "li", "ci", "p", "multi", "si", "io", "xi", "uri", "it", "v", "x", "ai", "bi", "eni", "y", "ji", "ip", "start", "ti", "qi", "id", "e", "iu", "u", "f", "n", "di", "m", "I"]}}
{"id1": "23672408", "id2": "4468255", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyIconFiles": [" copyIconFile", "copyFileImages", " copyiconImages", "copyiconFiles", "copyFileFile", "copyiconFile", "copyImageFile", "copyiconTypes", " copyiconFile", "copyFileFiles", "copyIconImages", " copyiconTypes", "copyFileTypes", "copyIconTypes", " copyiconFiles", " copyIconImages", "copyIconFile", "copyiconImages", "copyImageTypes", "copyImageImages", " copyIconTypes", "copyImageFiles"], "clazz": ["Claz", "Closs", " cluster", "cllass", "Clclass", "clab", "closed", "slod", "glazz", " clobe", "closer", "cluster", "clance", "slaz", "pllass", "hellazz", "Clab", " closed", "plclass", " cllass", "sllass", "flazz", "llasso", "flunk", " clclass", "clod", "sluster", " clab", "Cllass", "classo", "llazz", "hellasse", "Closer", " closer", "CLod", " classo", "closs", "Cluster", "glod", " closs", "slazz", "hellasso", "claz", "sloss", "glance", "llclass", "slance", "fluster", "glaz", " claz", "hellosed", " classe", "Clazz", "llasse", "ploser", "llab", "CLaz", "Clunk", "slosed", "helllass", "CLance", " clunk", "classe", "clunk", "CLazz", " clance", "hellance", "clobe", "llobe", "flaz", "hellobe", "plazz", "llaz", "clclass"], "i16": ["pi64", "ii16", "i64", "l64", "pi15", "si24", "int24", "io24", "si14", "ai16", "ii2016", "i14", "si64", "pi24", "i17", "ai2016", "I15", "int15", "io2016", "l24", "i15", "si2016", "l15", "pi16", "int2016", "ini15", "io15", "I17", "si15", "ini14", "ini2016", "ii17", "ini17", "io16", "ai15", "ini16", "l16", "ii15", "I16", "I14", "i24", "ii14", "si16", "i2016", "int16", "ii24", "ai14"], "fileType": ["fileLike", " filePatch", "playSpread", "iconType", "filePath", "singleType", "playFamily", "FileUnit", " fileAuth", "playType", "wordAuth", "wordType", " fileFamily", "feedInfo", "fileFamily", "imagePath", " fileState", "iconPath", "fileKey", "iconKey", "feedType", " fileStyle", "fileTime", "iconAuth", "feedtype", "messagePatch", "imageUnit", "wordLength", "messagetype", "fileBlock", "fileStyle", "singleStyle", "messagePath", "FileLocation", " fileLocation", " fileKey", " fileInfo", "fileFile", "feedPath", "messageType", " fileTy", "fileInfo", "imageTime", "iconLength", "transferTy", "fileTy", " fileBlock", "FileLike", " fileTime", " filePath", " fileLike", " fileUnit", "singleFile", "filetype", "documentState", "FileInfo", "transferType", "letterTy", "imageType", "fileSpread", " fileFile", "playTy", "FileFamily", "filePatch", "fileLength", "imageFamily", "imageFile", "feedPatch", "letterState", "documenttype", "letterSpread", "letterType", "wordTy", "letterFamily", "imageStyle", "lettertype", "transferFamily", "FileStyle", "fileState", "iconTy", "transferSpread", "documentType", "documentBlock", "imageKey", "feedLocation", " fileLength", "fileLocation", "feedLike", "singleTime", "letterBlock", "FileType", " filetype", "fileAuth", "fileUnit", "iconStyle"], "desti16": ["targeti2016", "destI15", "targeti16", "combini32", "desturi64", "targetI16", "desturi32", "destini16", "destf15", "combini15", "desti15", "destf16", "desti2016", "destini64", "destsi32", "targetI15", "desti016", "destabi2016", "destf2016", "combini64", "destabi016", "destini15", "destI016", "destini32", "destsi64", "combini16", "destsi16", "desturi15", "destI2016", "desti64", "combi15", "desturi16", "targeti016", "destf016", "combi32", "targeti15", "combi16", "targetI2016", "destabi15", "destabi16", "combi64", "targetI016", "destI16", "destsi15"], "src": ["resource", "thumbnails", "filename", "cb", "uv", "url", "null", "usr", "rc", "grad", "img", "sel", "file", "desc", "rb", "pkg", "uc", "lib", "scene", "source", "s", "in", "gz", "input", "cur", "target", "sync", "output", "b", "front", "r", "sc", "upload", "pull", "crop", "tmp", "sys", "scenes", "ser", "rl", "bh", "console", "loc", "ug", "support", "conv", "stream", "req", "iv", "gb", "dist", "st", "rob", "cmp", "https", "attr", "sq", "secure", "ssl", "sr", "data", "cv", "default", "socket", "image", "video", "func", "view", "root", "coll", "download", "hub", "ctrl", "http", "load", "back", "buf", "cdn", "ource", "uri", "proc", "dest", "bs", "gl", "inst", "sl", "ctx", "config", "rss"], "dst": ["sdsl", "sdsc", "adst", "adbl", "dput", "dedost", "dedst", "Dst", "rdst", "ldbl", "adct", "dsost", " dste", "drsc", "rdST", "rdsc", "dsput", "Dost", "Ddr", "Dsts", "sddest", "nrest", " dsl", "dste", "sdst", "dsts", "dbl", "idest", "Dput", "drd", "Dbl", "sdest", "idst", "drput", " ddest", "nst", "dsdr", "ldst", "drST", " drest", " dest", "nste", "sdrd", "idrd", "ddest", " dput", "ddr", "drst", "ldost", " dsts", "nsts", "dsst", "dedput", "idsl", " drd", " dbl", "sdbl", "idsc", "deddr", "adost", "dost", "ldct", "idbl", "drest", "dct", "Dct", "dest", "dsl", "dsc", "Dste", " dsc", "dST", "Drest", "iddest", " dST", "rdput"], "i32": ["I35", "ri33", "i42", "I30", "si33", "ui34", "qi32", "ini35", "ui32", "I32", "in33", "iu32", "i31", "I31", "iu33", "i30", "I33", "in15", "ini32", "i15", " i35", "ri42", "i34", "i33", " i42", " i31", "si22", "ini33", "ri32", " i34", "ui30", "in32", "qi15", "I42", "qi33", "ui31", "i22", "i35", "si32", " i33", "in34", " i22", "iu15", "iu34", "ini22", "qi34", " i30", "I34", "ri35", "si35"], "desti32": ["destsi15", " destsi32", "targeti32", "targetiu34", "destii28", "destiu34", " destsi16", "destii33", "targeti34", "desti15", "destic22", "destsi32", "destsi22", " desti22", " destsi15", "destiu33", "destin28", " desti15", "destin33", "destsi16", "destic16", "destin34", "targetiu32", "destic32", "targeti28", "destiu32", "destabi22", "targetiu28", "targeti33", "destabi32", "desti28", "destin32", "destiu28", "destic15", " destsi22", "destabi15", "destii32", "destabi16", "desti34", "desti22", "destii34", "targetiu33", "desti33"]}}
{"id1": "7351534", "id2": "7149578", "code1": "    public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception {\n        InputSource source = null;\n        InputStream stream = null;\n        if (resolver != null) {\n            try {\n                source = resolver.resolveEntity(null, systemId);\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (source != null) {\n            try {\n                stream = source.getByteStream();\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (stream == null) {\n            URL url = new URL(systemId);\n            stream = url.openStream();\n        }\n        return stream;\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 0, "substitutes": {"getStreamFromSystemIdentifier": ["getStreamFromSystemIdifier", "getStreamFromsystemidentifer", "getStreamFromsystemidentification", "getStreamFromSystemidentification", "getStreamFromSystemIdentifer", "getStreamFromsystemIdentifiers", "getStreamFromSystemidentifier", "getStreamFromSystemIdentifiers", "getStreamFromSystemIdifiers", "getStreamFromsystemidentifiers", "getStreamFromSystemidentifiers", "getStreamFromsystemIdentifer", "getStreamFromsystemidentifier", "getStreamFromSystemIdification", "getStreamFromSystemIdifer", "getStreamFromSystemidentifer", "getStreamFromSystemIdentification", "getStreamFromsystemIdentification", "getStreamFromsystemIdentifier"], "systemId": ["Systemid", " systemPath", "serverId", "customid", "customId", "systemPath", "machineId", "SystemId", "serverID", "securityName", " systemID", "SystemID", "ystemID", "securityid", "ystemId", "customName", "systemName", "SystemName", "securityId", "servicePath", "machineID", "serviceId", "sysId", "securityID", "sysid", "sysPath", "systemID", " systemid", "machineid", "customID", "serviceid", "ystemName", "ystemid", " systemName", "systemid", "serverid"], "resolver": [" resol", "Resol", "reolver", "presolving", "Resolution", "resolve", "Resolve", "resolution", "reolve", " resolve", "presolver", "reolving", "resol", "reolution", " resolving", "reol", " resolution", "Resolver", "resolving", "presolution", "presolve", "Resolving"], "source": ["resources", "unit", "model", "slave", "service", "resource", "SOURCE", "o", "storage", "Source", "target", "channel", "parse", "src", "text", "slice", "sync", "remote", "info", "object", "scope", "ources", "string", "null", "class", "element", "position", "from", "spec", "session", "creator", "path", "large", "handler", "type", "ource", "result", "container", "uri", "entity", "response", "ce", "client", "secure", "context", "size", "name", "proxy", "component", "data", "server", "document", "seed", "e", "id", "instance", "sl", "reader", "i", "iter", "connection", "parent"], "stream": ["body", "image", "model", "log", "pool", "service", "resource", "child", "feed", "temp", "cont", "view", "event", "content", "form", "input", "trans", "channel", "load", "src", "message", "zip", "output", "wh", "speed", "object", "string", "read", "flash", "session", "buffer", "path", "handler", "result", "allow", "steam", "dest", "row", "response", "client", "length", "context", "report", "clean", "proxy", "wrapper", "host", "data", "live", "document", "valid", "port", "file", "server", "instance", "sl", "reader", "sw", "Stream", "or", "connection", "parent"], "url": ["link", "image", "URL", "service", "resource", "base", "feed", "Url", "channel", "http", "src", "zip", "l", "object", "page", "string", "path", "large", "control", "ource", "uri", "client", "loader", "ssl", "location", "proxy", "server", "id", "file", "data", "host", "gl", "sl", "connection", "loc", "web", "address"]}}
{"id1": "942693", "id2": "10547671", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 0, "substitutes": {"convert": ["oconversion", "CONversion", "oconverting", " deconverted", "CONverting", " deconvert", "conception", "CONception", " deconverting", "unverted", "subversion", "CONverted", "Conception", " deconversion", "oconvert", "unversion", "converted", "unception", "subvert", "conversion", "Convert", "unvert", "Converted", "subverted", "subverting", "converting", "oconverted", "Converting", "Conversion", "CONvert"], "src": ["video", "resource", "storage", "config", "stream", "Source", "impl", "gz", "RC", "input", "download", "feat", "req", "ref", "load", "back", "filename", "slice", "href", "cb", "prot", "url", "string", "code", "buf", "gb", "spec", "dist", "cpp", "rc", "stage", "sn", "path", "st", "sc", "cmp", "upload", "ource", "uri", "sb", "proc", "SourceFile", "sin", "img", "fp", "supp", "attr", "sit", "secure", "tmp", "name", "ssl", "Dest", "sel", "sys", "component", "file", "fn", "inst", "username", "sth", "reader", "rb", "rl", "ctx", "scene", "loc", "source", "obj", "s"], "dest": [" destination", "temp", "cont", "dc", "dat", "target", "bin", "home", "null", "txt", "class", "orig", "lib", "dist", "path", " dst", "img", "dir", "std", "tmp", "test", "Dest", "fn", "di", "source", "obj", "disk"], "in": ["ini", "err", "login", "stream", "inn", "inf", "val", "input", "In", "up", "bin", "pin", "r", "IN", "ps", "t", "pass", "d", "doc", "source", "io", "ins", "is", "as", "inas", "a", "data", "isin", "file", "ex", "i", "reader", "win", "n", "din", "f", "inc"], "p": ["np", "j", "o", "po", "pre", "py", "P", "pc", "cop", "parser", "l", "b", "jp", "pr", "bp", "lp", "pi", "pp", "sp", "pe", "c", "r", "wp", "g", "ps", "t", "pa", "d", "op", "pg", "part", "pm", "v", "fp", "pb", "h", "tp", "pd", "e", "i", "per", "cp", "m", "f", "s"], "ds": ["ths", "dp", "vals", "ls", "services", "ads", "ld", "lp", "groups", "dt", " ps", "os", "ins", "icks", "nas", "ts", "dates", "scripts", "s", "dc", "dat", "Ds", "points", "els", "sync", "tools", "ipes", "xs", "obs", "sts", "d", "ils", "dds", "hs", "gs", "docs", "sys", "pd", "dm", "ss", "dl", "des", "posts", " DS", "utils", "cons", "lines", "ns", "ges", "da", "tests", "ays", "dist", " props", "eps", "cs", "df", "uds", "gd", "qs", "ys", "data", "ded", "ks", "words", "di", "db", "parts", "dd", "ants", "vs", "amps", "ans", "DS", "dos", "plugins", "styles", "js", "ps", "rs", "ups", "models", "bs", " sd"], "format": ["letter", "model", "unit", "nat", "plugin", "prefix", "form", "function", "pattern", "at", "feat", "filter", "version", "parser", "atter", "filename", "sche", "api", "table", "Format", "struct", "style", "string", "class", "scale", "act", "spec", "t", "fd", "path", "handler", "ant", "template", "source", "type", "record", "part", "frame", "fp", "name", "language", "host", "data", "file", "layout", "fn", "magic", "config", "tag", "f", "url"], "hasPixelData": ["hasPixelStyle", "haspixeldata", "showsByteDATA", "hasByteStyle", " hasPixelSize", "hasByteDATA", "showsPixelDATA", "hasPixelDATA", "hasPictureSize", "hasPixeldata", "hasByteData", "hasPixelSize", "showsPixelData", "haspixelData", "hasPicturedata", "showsByteData", "hasByteSize", "showsByteStyle", "haspixelSize", "showsPixeldata", "showsBytedata", "showsPixelStyle", "hasBytedata", "hasPictureData", " hasPixeldata"], "inflate": ["inadequode", "infloation", "inadequATE", "InFlace", "infloace", "Inflation", "inflation", "InFlate", "Inflated", "inflode", "infolode", "insflating", "invenate", "insvenate", "infolate", "Inflate", "infolATE", "infolating", "InFlated", "insvenATE", "invenating", "inFlace", "inflace", "insflode", "invenode", "inadequating", "insvenating", "inffate", "InFlation", "insflate", "inffation", "invenATE", "infloated", "inffated", "inflating", "inFlate", "Inflace", "insflATE", "infface", "infloate", "inFlated", "inadequate", "insvenode", "inflated", "inflATE", "inFlation"], "pxlen": ["pxden", "pxdata", "mxlen", "campos", "pxln", "mxln", "pxlon", "camln", "mxcount", "pxlin", "pngsize", "xplength", "fxln", "xpsize", "pgden", "ppl", "pplen", "fxden", "pxsize", "pxcount", "fxpos", "axlin", "pclon", "ppLen", "pnglength", "txlon", "pnglen", "pxl", "mxlength", "xplen", "xpcount", "axlen", "txlin", "txln", "pxpos", "ppden", "mxdata", "pglen", "pgLen", "mxpos", "pxlength", "fxl", "pclen", "pgl", "camlen", "pclin", "camdata", "axln", "txlen", "pcln", "fxLen", "pxLen", "mxsize", "fxdata", "pngcount", "fxlen", "axlon"], "out": ["re", "err", "log", "point", "step", "cli", "inter", "up", "group", "cache", "output", "OUT", "list", "conn", "post", "page", "pad", "store", "session", "state", "again", "outs", "work", "query", "line", "io", "v", "Out", "co", "dump", "sys", "server", "user", "gen", "lock", "error", "lib", "parent", "obj", "copy"]}}
{"id1": "4602568", "id2": "18613870", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"storeImage": ["processIcon", "processVideo", "storeMedia", " storeVideo", "processImage", " storeMedia", "storeVideo", "processMedia", " storeIcon", " transferIcon", "storeIcon", " transferMedia", " transferImage", " transferVideo"], "inStream": [" inReader", "winStream", "winSteam", "winVideo", "inputPath", "inputstream", "inSteam", "inputStream", "winReader", "INStream", "inCh", " instream", "inPath", " inVideo", "INPath", "INCh", " inPath", "inReader", " inSteam", " inCh", "inputSteam", "INstream", "inputReader", "instream", "inputVideo", "inVideo", "inputCh"], "fileName": ["httpname", "fileNames", " filePath", "imageName", "httpName", "filePath", "FILEName", "resourceInfo", "filename", "imageNames", "FileInfo", " fileNames", " filePart", " fileNode", "FILEPath", "FilePart", "FilePath", "fileInstance", "filePart", "imagename", "FILEInstance", "FileName", "FileInstance", "Filename", " fileInstance", " filename", "FileNames", "fileNode", "FILEname", "resourceName", " fileInfo", "httpPath", "resourceNode", "fileInfo", "httpPart", "imagePath", "FILENode", "resourcename", "FILEInfo"], "resize": [" Resized", " Resizes", "resizes", " Resizer", " resizer", " Resize", "resized", "Resize", " resizes", "Resizer", "resizer", " resized", "Resizes", "Resized"], "rightNow": ["thirdThen", "straightAccount", "thirdnow", "thirdCurrent", "dayNOW", "thirdNOW", " rightnow", "thirdNow", "thirdToday", "dayNow", "dayToday", " rightAccount", "RightAccount", "rightNOW", "rightAccount", "straightToday", "dayCurrent", "RightToday", "rightnow", " rightToday", "straightNow", " rightThen", " rightNOW", " rightCurrent", "Rightnow", "RightNow", "rightToday", "straightnow", "RightCurrent", "RightNOW", "rightCurrent", "rightThen"], "dayNamedFolderName": ["dayNestedDirectoryname", "dayNamedFoldername", "dayNamedFolderPath", "dayNamedAreaSize", "dayNamedFolderInfo", "dayNamedfolderName", "dayNamedFolderSize", "dayNestedFolderSize", "dayNestedFolderName", "dayNamedFileKey", "dayNamedFileInfo", "dayNamingFolderName", "dayNamedfolderInfo", "dayNestedDirectorySize", "dayNnamedFolderInfo", "dayNestedDirectoryName", "dayNestedDirectoryPath", "dayNamedDirName", "dayNamingFolderKey", "dayNamedDirInfo", "dayNamingFolderSize", "dayNamedAreaname", "dayNamedAreaName", "dayNnamedFolderSize", "dayNamedDirectoryName", "dayNnamedFolderName", "dayNestedFoldername", "dayNamedFilePath", "dayNamedDirSize", "dayNamedfoldername", "dayNnamedFolderPath", "dayNamedDirectoryname", "dayNamedfolderPath", "dayNamedDirectorySize", "dayNamingFolderInfo", "dayNamedfolderSize", "dayNestedFolderPath", "dayNamedFolderKey", "dayNamedDirectoryPath", "dayNamedFileName", "dayNamedFileSize", "dayNamedAreaPath", "dayNamedDirKey"], "uploadDirRoot": [" uploadFileRoot", "uploadFolderroot", "inputDirName", " uploadDirroot", " uploadDirHome", "uploadFolderBase", "uploadFilePath", "uploadDirectoryBase", "inputDirRoot", "UploadFolderRoot", "uploaddirroot", "uploadBaseroot", "uploadBaseRoot", "uploadDbHome", "UploadDirroot", "uploadBasePath", "inputDirectoryName", "UploadFolderroot", "uploadDirPath", "UploadFolderBase", "uploadFileRoot", "uploadDirectoryPath", "uploadDbRoot", "uploadDirroot", "inputDirectoryHome", "UploadDirPath", "uploadDirectoryRoot", "uploadFolderRoot", "uploadFileHome", "uploadDirHome", "inputDirPath", "inputDirectoryPath", "UploadDirRoot", "uploadDirBase", "uploadDbName", "inputDirHome", "uploaddirHome", "inputDirectoryRoot", "uploadDirectoryHome", "uploadDirName", "uploadBaseBase", "UploadFolderPath", "uploadDbPath", "uploadFileroot", "uploadDirectoryName", "uploadDirectoryroot", "uploaddirRoot", " uploadFileHome", "uploadFolderPath", "uploadFileName", "UploadDirBase", " uploadFileroot"], "file": ["File", "image", "folder", "log", "base", "flow", "unit", "service", "child", "model", "force", "view", "rule", "function", "ile", "entry", "fe", "up", "http", "zip", "local", "b", "full", "object", "auto", "page", "home", "url", "class", "pe", "files", "path", "work", "handler", "p", "line", "part", "out", "fp", "book", "dir", "FILE", "name", "user", "document", "e", "comment", "per", "lib", "connection", "parent", "f", "directory"], "extension": ["exversion", "exion", "extend", "exension", "intension", "xtend", "ExtION", "intION", "EXTdivision", "Extend", "intend", "xtion", "interion", "interension", "exdivision", "EXTversion", "xtION", "extdivision", "extversion", "extION", "interdivision", "Extension", "EXTension", "Extion", "intion", "interversion", "xtension", "extion", "EXTion"], "outFileName": ["outLineLocation", " outFileSystem", "inLinePath", "outPathType", "inFilePath", "inFileKey", "OutDirInfo", "OutFileInfo", "outFileKey", "outPathPath", "outfileLocation", " outFilename", "outDirInfo", "outFileType", "inFileInfo", "outLinePart", "outFolderLine", "outPlaceAddress", "outPlaceSystem", "OutDirLength", "outLinename", "outFileLength", "inLineInfo", " outPlaceLine", "outFieldSystem", " outFilePath", "outFolderInfo", "OutDirName", "outLineSize", "outLineName", "outfileLength", "outPathName", "outFileInfo", "outDirName", "outLineType", "outfileName", "outFolderPath", "inLinePart", " outFileAddress", "outFileLine", "outDirPart", "outPlaceLocation", " outPlaceAddress", "outfileSize", "outFullKey", "OutFileName", "outPlaceSize", "inLineName", "outLinePath", "outLineKey", "outFullPart", "outPathname", "outLineLength", " outPlaceLocation", "outFilePart", "outFieldLine", " outPlacePath", "outFieldAddress", "outfilePath", " outFileSize", "outFilePath", "outFilename", "outDirLength", "outFileSize", "outFileLocation", "OutDirPath", " outFileLine", "inLineKey", " outPlacename", " outPlaceSystem", "outLineInfo", "outPlaceLine", "outFolderName", "inFileLine", "outPlaceName", " outFileType", "outfileInfo", "outFieldName", " outPlaceName", " outPlaceSize", "outPlaceType", "OutFileLength", "outPlacename", "outDirLine", "outDirKey", "outFullPath", "outFolderAddress", "OutFilePath", "inFileName", "inLineLine", "outFolderSystem", "outPlacePath", "outDirPath", "outFileAddress", " outFileLocation", " outPlaceType", "outFileSystem", "inFilePart", "outFullName", "outLineLine"], "outPathAndName": ["outPathANDPath", "outNameOrAddress", "outPathOrRam", "outpathAndTime", "outNameOrName", "outpathOrPath", "outPathANDRam", "outNameOrPath", "outPathandNames", "outPathANDNames", "outPathOrPath", "outNameOrRam", "outpathOrNames", "outPathANDAddress", "outpathAndname", "outPathOrname", "outPathOrTime", "outNameAndRam", "outpathAndName", "outPathANDTime", "outNameAndPath", "outNameAndAddress", "outPathandPath", "outPathOrNames", "outPathOrAddress", "outPathAndPath", "outPathandName", "outPathAndRam", "outPathAndname", "outpathAndNames", "outpathAndPath", "outPathAndNames", "outPathOrName", "outNameAndName", "outPathAndAddress", "outPathAndTime", "outPathANDname", "outPathANDName", "outpathOrName"], "uploadedFile": ["uploadenedFile", "UploadpedFiles", "uploadendedPath", "uploadatedFiles", "UploadedImage", "uploadedImage", "uploadizedImage", "uploadedFull", "uploadededFull", "uploadchedF", "processedF", "uploadedF", "processedPath", "UploadedFolder", "uploadizedFull", "uploadenedFiles", "processchedF", "uploadedfile", "UploadedFull", "UploadpedImage", "uploadendedF", "uploadedFolder", "uploadratedfile", "uploadededImage", "processchedPath", "uploadratedPath", "UploadpedFull", "uploadchedFile", "processedfile", "uploadatedfile", "uploadpedfile", "uploadratedFile", "uploadchedPath", "uploadedPath", "UploadpedFile", "uploadatedFolder", "UploadpedFolder", "processedFile", "UploadedFile", "uploadpedFull", "processchedfile", "Uploadpedfile", "uploadendedfile", "uploadizedFiles", "processchedFile", "uploadedFiles", "uploadpedFile", "uploadenedfile", "uploadatedFile", "uploadededFiles", "uploadededFile", "uploadizedFile", "uploadratedF", "uploadpedFolder", "Uploadedfile", "uploadpedImage", "uploadendedFile", "uploadchedfile", "uploadpedFiles", "UploadedFiles", "uploadenedFolder"], "outStream": ["_", "tempFile", "URL", "format", "outFile", " outFile", "Url", "tempSteam", "inFile", "inSteam", "Type", "Bytes", "Directory", "tempBuffer", "New", "inBuffer", " outBuffer", "outSteam", "tempStream", "Copy", "s", " outSteam", "url", "outBuffer"]}}
{"id1": "2642914", "id2": "9846843", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTarGsgz", "addFileToZipGgz", "addFileToZipGzi", "addFileToTarggz", "addFileToZipGzip", "addFileToZipGszi", "addFileToTarGzip", "addFileToTarGszip", "addFileToZipGsz", "addFileToTarGux", "addFileToTarGargz", "addFileToTarGarzip", "addFileToTarGarx", "addFileToTarGarzi", "addFileToTarGsz", "addFileToTarGuz", "addFileToZipGz", "addFileToZipGarx", "addFileToZipGarz", "addFileToTarGarz", "addFileToTargx", "addFileToTargzip", "addFileToTarGuzip", "addFileToTarGgz", "addFileToTarGuzi", "addFileToTargz", "addFileToZipGarzi", "addFileToZipGsgz", "addFileToTarGszi", "addFileToTargzi", "addFileToZipGarzip", "addFileToZipGszip", "addFileToTarGzi", "addFileToZipGx", "addFileToTarGx"], "taro": ["tara", "atro", "Taron", "thaco", "faco", " taco", "Tabo", "toro", "staro", " tero", " tara", "Toro", "fargo", "ptargo", "targo", "taco", "ptabo", "ptaro", "Taro", "Taco", " targo", " taron", "too", "Toran", "stamar", "Tro", "storo", "toran", "loran", "lro", "tero", "stero", "tabo", " tabo", "ptaron", "faro", " too", "Tara", "tharo", "ataro", "Tamar", "atoran", "tamar", "taron", "Targo", "laro", "Tero", "thamar", "Too", "atargo", "thoro", "stoo", "tro", "staco", "largo", "stro", " tro", "ptaco", "fara"], "path": ["image", "folder", "log", "resource", "Path", "root", "pattern", "ref", "text", "cache", "filename", "key", "object", "string", "PATH", "c", "from", "route", "p", "type", "source", "pointer", "uri", "ath", "dir", "name", "id", "file", "fn", "data", "str", "loc", "location", "parent", "url", "directory"], "base": ["index", "resource", "site", "prefix", "root", "default", "pre", "ase", "http", "cache", "bas", "back", "key", "area", "api", "b", "extra", "home", "string", "from", "store", "buffer", "core", "Base", "p", "type", "part", "uri", "dir", "start", "name", "server", "id", "file", "absolute", "bf", "relative", "parent", "url", "address"], "f": ["fo", "j", "fr", "feed", "of", "fac", "this", "fa", "self", "found", "form", "lf", "w", "inf", "F", "fen", "fe", "aff", "ref", "fc", "l", "b", "raf", "cf", "c", "r", "rf", "g", "t", "fd", "d", "fb", "p", "v", "df", "flat", "fp", "fs", "fx", "framework", "tf", "h", "fold", "file", "fn", "af", "e", "sf", "i", "n", "bf", "m", "url", "s"], "entryName": ["elementTime", "entryname", "archiveName", "fileName", " entryname", "EntryName", "fileType", "filePath", "fileTime", "elementName", "entryPath", "resourcePath", "entryType", " entryPath", "elementPath", "entryTime", "archiveSize", "EntryType", "entrySize", " entryTime", "elementType", "resourceName", "resourceSize", " entryType", "EntryPath", "archivename", "EntryTime", "archivePath", " entrySize", "resourcename"], "goIn": ["loIns", "GOIns", "goIN", "GOOut", "coIn", "coIns", "GOIn", "GOin", "loIN", "GoIn", "poIn", "gain", "poin", "loIn", "goIns", "coin", "GOIN", "gaIn", "poIN", "Goin", "poIns", "coOut", "gaIN", "loin", "gaIns", "goOut", "GoIN", "GoIns", "poOut", "goin"], "tarEntry": ["tarFile", "rarInfo", "zipInfo", " Tarentry", "zipEnt", "TarElement", " tarentry", " tarEnt", "Tarentry", "rarEntry", " tarFile", "TarEntry", "rarFile", "tarentry", "zipEntry", " TarEntry", "tarInfo", "zipFile", " tarInfo", " tarElement", " TarElement", "rarEnt", "tarElement", "tarEnt"], "children": ["iblings", "ports", "pool", "sub", "other", "packages", "feed", "current", "content", "ul", "open", "plugins", "which", "output", "blocks", "roots", "bars", "when", "files", "ools", "rows", "far", "ales", "parents", "ren", "jobs", "all", "well", "values", "opens", "ins", "members", "Children", "many", "name", "each", "pes", "h", "pages", "father", "data", "scenes", "balls", "web", "kids", "words", "loc", "parent"], "child": ["slave", "pool", "in", "feed", "root", "entry", "kid", "channel", "count", "key", "hel", "l", "ch", "shell", "page", "leaf", "code", "c", "lib", "cel", "Child", "cloud", "job", "build", "and", "row", "pull", "layer", "client", "name", "server", "data", "file", "id", "comment", "i", "per", "or", "connection", "parent", "draft"]}}
{"id1": "21998571", "id2": "14390569", "code1": "    private String readTwitterFead() {\n        StringBuilder builder = new StringBuilder();\n        HttpClient client = new DefaultHttpClient();\n        HttpGet httpGet = new HttpGet(\"http://twitter.com/statuses/user_timeline/vogella.json\");\n        try {\n            HttpResponse response = client.execute(httpGet);\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n            if (statusCode == 200) {\n                HttpEntity entity = response.getEntity();\n                InputStream content = entity.getContent();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(content));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    builder.append(line);\n                }\n            } else {\n                Log.e(AndroidJsonTestingActivity.class.getName(), \"Failed to download file\");\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return builder.toString();\n    }\n", "code2": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "label": 0, "substitutes": {"readTwitterFead": ["downloadFacebookJead", "downloadTwitterFleead", "downloadTwitterFFees", "downloadFacebookFees", "downloadTwitterFleee", "downloadTwitterFee", "downloadTwitterFFee", "downloadTwitterFrequency", "downloadTwitterJee", "downloadTwitterFees", "downloadFacebookFead", "downloadTwitterFlerequency", "downloadFacebookFee", "downloadTwitterJead", "downloadTwitterFead", "downloadTwitterFleees", "downloadTwitterFFrequency", "downloadFacebookJrequency", "downloadTwitterJrequency", "downloadFacebookJees", "downloadTwitterJees", "downloadFacebookJee", "downloadTwitterFFead", "downloadFacebookFrequency"], "builder": ["image", "letter", "base", "address", "board", "entry", "worker", "http", "message", "parser", "Builder", "atter", "writer", "b", "upper", "object", "we", "driver", "string", "null", "array", "r", "store", "buffer", "oder", "built", "er", "builders", "result", "container", "build", "sb", "row", "layer", "block", "loader", "trace", "runner", "bean", "wrapper", "server", "sf", "instance", "building", "keeper", "database", "iter", "db", "f", "url", "holder", "editor"], "client": ["method", "force", "service", "resource", "Client", "cli", "google", "channel", "http", "bird", "queue", "api", "conn", "url", "class", "application", "c", "session", "cloud", "handler", "io", "https", "ce", "app", "request", "proxy", "tc", "con", "server", "host", "connect", "i", "per", "get", "contact", "connection", "config", "project", "plugin", "socket"], "httpGet": ["HTTPSend", "HttpGet", "HttpDo", "HTTPget", " httpDo", " httpget", "HttpSplit", "ttpSplit", "ttpDo", "httpSend", "urlGet", "httpPut", "HTTPGet", " httpSend", " httpFind", "HttpPut", "httpget", "urlFind", "httpFind", "httpSplit", "urlSend", "HTTPFind", "ttpPut", "httpDo", " httpSplit", " httpPut", "ttpGet", "urlget"], "response": ["body", "onse", "service", "resource", "wave", "stream", "event", "Response", "json", "http", "message", "output", "api", "writer", "respond", "full", "object", "page", "status", "application", "collection", "resp", "session", "success", "handler", "successful", "result", "report", "ception", "received", "request", "server", "data", "document", "error", "connection", "reply"], "statusLine": ["contentLine", "statusBlock", "httpEntry", "StatusLine", "statResponse", "responseEntry", "statusResponse", "statLine", "StatusEntry", "contentStatus", "statEntry", " statusEntry", "responseResponse", "responseLine", "statusEntry", "httpBlock", "contentEntry", "responseCode", "statCode", "StatusBlock", "StatusStatus", "httpLine", "contentBlock", "statusStatus", " statusResponse", "httpStatus"], "statusCode": ["contentLine", "statusCount", "StatusLine", "contentCode", "stateStatus", "StatusCount", "StatusCode", " statusType", "statusType", "contentCount", "stateType", "contentType", "StatusStatus", "stateCode", "statusStatus", "StatusType", " statusCount", " statusStatus"], "entity": ["enc", "body", "model", "resource", "agent", "stream", "coll", "event", "et", "json", "entry", "http", "media", "writer", "object", "page", "status", "code", "element", "application", "collection", "er", "result", "type", "ent", "xml", "article", "server", "data", "file", "document", "e", "person", "el", "activity", "Entity", "connection", "source"], "content": ["body", "image", "resource", "Content", "feed", "raw", "child", "cont", "stream", "input", "json", "entry", "channel", "text", "message", "load", "output", "media", "writer", "conn", "object", "page", "status", "read", "driver", "collection", "buffer", "handler", "result", "pointer", "layer", "xml", "loader", "server", "data", "file", "activity", "source"], "reader": ["in", "resource", "stream", "rer", "input", "worker", "reading", "ler", "parser", "rar", "bird", "writer", "read", "ri", "r", "buffer", "oder", "handler", "er", "io", "rr", "row", "ner", "loader", "server", "data", "ser", "Reader", "i", "per", "iter", "or", "editor"], "line": ["link", "body", "letter", "lc", "base", "feed", "end", "liner", "point", "sheet", "lf", "write", "lines", "entry", "inline", "LINE", "text", "message", "Line", "sync", "key", "l", "object", "page", "style", "string", "code", "pe", "r", "buffer", "pass", "part", "row", "ip", "block", "le", "character", "name", "data", "file", "id", "cell", "e", "char", "str", "sl", "i", "comment", "one", "iter", "connection", "source", "url", "lin"]}}
{"id1": "20751378", "id2": "16931472", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"hashPassword": ["hashPass", "cryptpassword", "signpassword", "hashWord", "cryptPass", "signPass", " hashPass", "cryptPassword", "hashpassword", " hashWord", "signWord", " hashpassword", "signPassword", "cryptWord"], "password": ["encrypted", "Password", "sha", " Password", "prefix", "content", "w", "input", "plain", " passwords", "pattern", "text", "message", "cache", "key", "wd", "pad", "string", "code", "pass", "crypt", "token", "path", "padding", "phrase", "p", "number", "mac", "secret", "command", "auth", "name", "PASS", "word", "user", "data", "seed", "username", "security", "sword", "description", "database", "words", "python", "address"], "hash": ["her", "sha", "height", "hex", "history", "format", "json", "proof", "result", "number", "ashes", "length", "Hash", "search", "call", "value", "pkg", "host", "memory", "log", "html", "pool", "oh", "check", "dig", "cache", "style", "string", "code", "math", "gh", "kh", "phrase", "uild", "build", "handle", "secret", "ssh", "mod", "id", "user", "error", "msg", "copy", "base", "match", "version", "text", "bolt", "replace", "ruby", "update", "array", "addr", "rh", "mac", "sum", "hed", "dump", "ha", "alt", "put", "security", "tag", "address", "index", "root", "square", "message", "key", "work", "sh", "ash", "auth", "h", "url"], "md": ["dd", "nd", "nm", "sha", "cmd", "am", "dig", "metadata", "ma", "amd", " MD", "hd", "mm", "mad", "xd", "ME", "ms", "wd", "vd", "km", "gb", "der", "grad", "mand", "d", "m", "kg", "bd", "pm", "df", "sm", "mg", "mac", "mt", "gd", "od", "sd", "MD", "Cmd", "mod", "dh", "pd", "mag", "dm", "mc", "f", "mb", "hm", "meta"]}}
{"id1": "16550855", "id2": "7633336", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    private JSONObject executeHttpGet(String uri) throws Exception {\n        HttpGet req = new HttpGet(uri);\n        HttpClient client = new DefaultHttpClient();\n        HttpResponse resLogin = client.execute(req);\n        BufferedReader r = new BufferedReader(new InputStreamReader(resLogin.getEntity().getContent()));\n        StringBuilder sb = new StringBuilder();\n        String s = null;\n        while ((s = r.readLine()) != null) {\n            sb.append(s);\n        }\n        return new JSONObject(sb.toString());\n    }\n", "label": 1, "substitutes": {"readPage": ["getFile", "readpage", "readFile", "getpage", "findpage", "getPage", "openPage", "findFile", "openpage", "readPages", "findPage", "openPages", "getPages", "findPages", "openFile"], "ignoreComments": ["oreTags", "ignoreTags", "useComments", "includecomments", "includeComment", "ignoreQuotes", " ignorecomments", " ignoreQuotes", "ignorecomments", "useQuotes", "useTags", " ignoreTags", "oreComments", "usecomments", "includeComments", "orecomments", "ignoreComment", "includeTags", "oreQuotes", " ignoreComment", "oreComment"], "in": ["ini", "re", "err", "image", "kin", "index", "login", "stream", "inner", "inn", "gin", "input", "In", "version", "http", "rec", "bin", "b", "c", "r", "IN", "buffer", "again", "t", "token", "source", "nin", "it", "min", "out", "client", "ins", "into", "is", "lin", "as", "loader", "init", "socket", "ssl", "inside", "h", "con", "data", "on", "user", "id", "e", "file", "isin", "reader", "i", "win", "connection", "m", "din", "f", "url", "inc", "s"], "inputLine": ["installLine", "pullline", "imageLook", "InputLine", "ifLook", "ifLine", "Inputline", "InputPage", "InputName", "inputCo", "requestRow", " inputCell", "imageLine", "rawName", "InputText", "inputCell", "requestLook", "pullLink", "inputName", " inputL", "incL", "InputLook", "requestCo", "installL", "inputline", "InputL", "rawText", "InputLink", " inputLink", " inputPage", "inputRow", "ifline", " inputRow", "incLine", " inputLook", "rawL", "inputPage", "incline", "ifCo", "InputCell", "rawLine", " inputline", "inputL", "commentPage", "commentCell", "pullRow", "requestLine", "pullLine", "requestLink", " inputCo", "requestline", "imageL", "inputLook", "inputText", "inputLink", "rawline", "commentLine", " inputText", "imageline", "incLook", "installLook", " inputName", "rawLink", "installline", "commentline"], "html": ["body", "link", "base", "bsp", "temp", "tt", "www", "hard", "detail", "strong", "view", "content", "tml", "format", "ht", "json", "plain", "inline", "htm", "links", "details", "http", "message", "text", "output", "api", "ui", "js", "page", "home", "show", "summary", "atom", "flash", "gh", "hot", "amp", "template", "doc", "part", "wrap", "result", "css", "attr", "HTML", "img", "flat", "blog", "xml", "article", "title", "tf", "h", "live", "dump", "data", "war", "str", "rss", "high", "bf", "msg", "source", "web", "f", "url", "header", "embed"]}}
{"id1": "701029", "id2": "8801436", "code1": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL url;\n        try {\n            url = getClass().getResource(filename);\n            is = url.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \\n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"loadSourceCode": ["loadsourceFile", "getSourcecode", "loadCodeFile", "loadSourceFile", "getSourceFile", "loadsourceCode", "loadSourcecode", "loadCodecode", "getSourceCode", "loadCodeCode", "loadsourcecode"], "length": ["th", "base", "shape", "depth", "end", "capacity", "content", "duration", "open", "Length", "version", "load", "count", "text", "zip", "total", "filename", "L", "key", "l", "full", "page", "style", "string", "code", "class", "read", "position", "buffer", "path", "work", "ph", "type", "part", "width", "build", "len", "number", "block", "size", "library", "name", "ext", "id", "data", "weight", "limit", "lock", "value", "angle", "delay", "time", "address"], "file": ["File", "flow", "log", "base", "folder", "resource", "force", "image", "feed", "self", "check", "fe", "http", "play", "use", "filename", "l", "b", "full", "object", "page", "class", "files", "pe", "buffer", "path", "io", "fp", "book", "fs", "FILE", "il", "loader", "name", "data", "e", "get", "connection", "source", "db", "f"], "buff": [" arr", " buffer", " buffers", " char", " background", " chunk", " buf", "text", "ch", "uf", "bb", "utf", " chars", "txt", "buf", "buffer", " style", "Buff", "comp", " ch", " rest", " text", "Buffer", " Buffer"], "is": ["err", "ib", "in", "resource", "address", "fr", "serv", "isi", "abs", "http", "src", "ir", "api", "l", "ui", "IS", "iv", "ri", "r", "ie", "p", "ris", "io", "os", "uri", "isl", "it", "isa", "out", "ip", "iss", "il", "as", "ur", "es", "bis", "are", "sr", "ob", "isc", "Is", "i", "ais", "get", "res", "or", "ar", "loc", "web", "s"], "isr": ["isrt", "isrr", " isri", "Isrs", "Islr", "ISrc", "ISr", "aslr", "arsr", "issri", " isrs", "arsrr", " islr", "servrt", "isri", "issrb", "isrs", "ISri", " isrc", "bsrr", "Isrb", "servrr", "servrar", "bsr", "bsrar", "israr", "arsrar", "isrc", "servr", "isrb", "arsrt", "issr", "asr", "issrc", "Isr", "islr", "ISrb", " isrb", "asrb", "bsrt", "asrs"], "cv": ["lc", "CV", "conv", "vr", "vv", "view", "vs", "cam", "cur", "ctrl", "nv", "fc", "cu", "b", "ctr", "cb", "uv", "gg", "vc", "c", "cf", "cpp", "rc", "sc", "vp", "sv", "v", "VC", "cc", "cm", "cp", "lv", "tc", "vert", "hw", "mc", "vm", "bc", "ctx"], "url": ["re", "err", "image", "log", "link", "URL", "base", "resource", "fr", "lr", "feed", "view", "stream", "download", "Url", "http", "l", "api", "page", "string", "r", "path", "fl", "uri", "blog", "il", "ur", "loader", "name", "ssl", "location", "server", "host", "ob", "id", "str", "sl", "el", "rl", "loc", "source", "web", "f", "address"], "reader": ["re", "in", "resource", "rx", "stream", "rer", "inner", "player", "ry", "worker", "http", "parser", "rar", "ler", "reading", "bird", "ir", "l", "writer", "ger", "read", "ri", "builder", "r", "buffer", "rc", "oder", "handler", "er", "io", "rr", "row", "ner", "loader", "cher", "roller", "server", "war", "ser", " readers", "Reader", "i", "iter", "or", "source", "holder", "editor"], "sourceCode": ["ourceText", "SourceCode", "SourceLine", "proxyCode", "SourceContent", "ourceCode", "ourceScript", "sourceScript", "ourcecode", "byteCode", " sourceFile", "parentCode", " sourcecode", "Sourcecode", " sourceText", "sourceText", "byteLine", "sourceFile", "proxyFile", " sourceLine", "ourceContent", "sourcecode", "parentcode", "sourceContent", "bytecode", "sourceLine", "parentText", "SourceScript", " sourceContent", " sourceScript", "proxycode", "ourceFile"], "line": ["hide", "body", "letter", "link", "lc", "base", "in", "model", "unit", "end", "office", "liner", "content", "lf", "pre", "write", "none", "lines", "entry", "inline", "LINE", "parse", "text", "message", "day", "Line", "sync", "key", "l", "auto", "object", "page", "string", "code", "element", "c", "position", "next", "li", "part", "record", "frame", "row", "number", "ip", "character", "le", "word", "data", "on", "id", "cell", "error", "str", "comment", "no", "one", "non", "sl", "source", "lin"]}}
{"id1": "6890417", "id2": "7809093", "code1": "    public static void main(String[] args) throws IOException {\n        PostParameter a1 = new PostParameter(\"v\", Utils.encode(\"1.0\"));\n        PostParameter a2 = new PostParameter(\"api_key\", Utils.encode(RenRenConstant.apiKey));\n        PostParameter a3 = new PostParameter(\"method\", Utils.encode(\"feed.publishTemplatizedAction\"));\n        PostParameter a4 = new PostParameter(\"call_id\", System.nanoTime());\n        PostParameter a5 = new PostParameter(\"session_key\", Utils.encode(\"5.b2ca405eef80b4da1f68d0df64e471be.86400.1298372400-350727914\"));\n        PostParameter a8 = new PostParameter(\"format\", Utils.encode(\"JSON\"));\n        PostParameter a9 = new PostParameter(\"template_id\", Utils.encode(\"1\"));\n        PostParameter a10 = new PostParameter(\"title_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        PostParameter a11 = new PostParameter(\"body_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        RenRenPostParameters ps = new RenRenPostParameters(Utils.encode(RenRenConstant.secret));\n        ps.addParameter(a1);\n        ps.addParameter(a2);\n        ps.addParameter(a3);\n        ps.addParameter(a4);\n        ps.addParameter(a5);\n        ps.addParameter(a8);\n        ps.addParameter(a9);\n        ps.addParameter(a10);\n        ps.addParameter(a11);\n        System.out.println(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        URL url = new URL(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "code2": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "label": 1, "substitutes": {"a1": [" a01", "ga0", "alpha1", "A3", "an01", "ga2", "alpha01", " a0", "A1", "ga01", "alpha0", "a01", "an3", "A2", "alpha2", "a0", "an2", "A01", "ga1", "an1"], "a2": ["p1", "n8", "p4", "A1", "p5", "n2", "A2", "n5", "A4", "A5", "A8", "n4", "p2"], "a3": ["a23", "alpha9", "la3", " a33", "ga2", "la23", "an33", "an3", "alpha5", "an23", "ga5", "alpha2", "alpha3", "ga9", "la33", "ga3", "a33", " a23"], "a4": ["as4", "as5", "A9", "as2", "pa10", "ma10", "pa8", "ma8", "A2", "ga10", "ga8", "A4", "A5", "pa4", "ma4", "as9", "ga4"], "a5": ["alpha8", " a6", "a7", "alpha6", "p5", "n6", "n2", " a7", "n7", "alpha5", "p6", "n5", "A4", "A5", "a6", "A8", "alpha4", "p7", "A6", "p2"], "a8": ["b4", "alpha8", " a6", "a7", "alpha6", "b7", " a7", "b6", "A4", "A11", "alpha11", "an6", "b8", "b10", "an7", "an10", "a6", "b11", "alpha4", "A8", "an8", "A6"], "a9": ["alpha9", "alpha8", "p10", "p9", "A9", "a7", "alpha10", "alpha09", " a7", "alpha7", "p09", " a09", "A11", "alpha11", "a09", "A8", "p7", "A7"], "a10": ["alpha12", "alpha9", "b9", "alpha8", "b09", "A9", "A09", "as8", "an9", "as09", "alpha10", "as10", "an12", "a12", "b8", "A10", "b10", "an10", "a09", " a12", "A8", "an8", "as9"], "a11": ["alpha12", " a13", " a18", "alpha8", "am13", "a7", "am7", "am11", "am10", " a7", "A18", "a12", "A12", "a18", "alpha18", "A11", "A13", "alpha11", "a13", "A10", " a12", "A8", "A7"], "ps": ["ports", "gets", "posts", "vs", "changes", "ops", "py", "ls", "Ps", "lines", "details", "ns", "aps", "points", "ons", "rules", "als", "ams", "pers", "properties", "ms", "jp", "pr", "js", "ws", "hes", "pi", "pp", "pe", "pos", "tests", "files", "params", "pps", "pa", "pass", "ipes", "pres", "ples", "ils", "p", "ds", "settings", "cases", "ras", "eps", "cs", "os", "qs", "ins", "is", "rs", "ups", "es", "pse", "as", "proxy", "pes", "ips", "gs", "alls", "ss", "ases", "PS", "per", "ks", "res", "ts", "parts", "ppa", "s"], "url": ["image", "log", "URL", "service", "base", "www", "download", "Url", "ls", "http", "l", "object", "page", "string", "buffer", "cloud", "fl", "control", "uri", "build", "response", "client", "bug", "ssl", "proxy", "server", "user", "file", "ll", "document", "gl", "browser", "sl", "contact", "connection", "config", "twitter", "web", "f", "address"], "request": ["re", "method", "resource", "create", "temp", "child", "this", "open", "worker", "req", "http", "use", "remote", "rate", "respond", "info", "post", "builder", "pe", "r", "session", "external", "buffer", "push", "access", "next", "Request", "p", "hello", "upload", "result", "response", "rest", "client", "pull", "report", "server", "user", "transfer", "call", "connect", "per", "web", "complete", "connection", "reply"]}}
{"id1": "20995534", "id2": "4164833", "code1": "    private static Properties loadPropertiesFromClasspath(String path) {\n        Enumeration<URL> locations;\n        Properties props = new Properties();\n        try {\n            locations = Thread.currentThread().getContextClassLoader().getResources(path);\n            while (locations.hasMoreElements()) {\n                URL url = locations.nextElement();\n                InputStream in = url.openStream();\n                props.load(in);\n                in.close();\n                logger.config(\"Load properties from \" + url);\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"load properties from classpath \\\"\" + path + \"\\\" failed\", e);\n        }\n        return props;\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 0, "substitutes": {"loadPropertiesFromClasspath": ["loadPropertiesFromClassfile", "loadPropertiesFromSubfile", "loadPropertiesFromSubloader", "loadPropertiesfromClasspath", "loadPropertiesfromclassfile", "loadPropertiesFromclassloader", "loadPropertiesfromclassname", "loadPropertiesfromclassloader", "loadPropertiesfromClassfile", "loadPropertiesFromClassloader", "loadPropertiesfromClassname", "loadPropertiesFromSubpath", "loadPropertiesfromclasspath", "loadPropertiesFromclassname", "loadPropertiesfromClassloader", "loadPropertiesFromclasspath", "loadPropertiesFromclassfile", "loadPropertiesFromClassname", "loadPropertiesFromSubname"], "path": ["enc", "log", "method", "base", "resource", "Path", "prefix", "root", "content", "pattern", "text", "filename", "key", "properties", "full", "object", "PATH", "string", "c", "route", "work", "handler", "p", "template", "type", "source", "part", "pointer", "uri", "ath", "prop", "dir", "context", "xml", "loader", "name", "request", "host", "id", "data", "level", "value", "error", "config", "location", "parent"], "locations": [" locors", "LOCions", " locator", "slibraries", "slations", "locibraries", "slator", "sllements", "operators", " location", "Lococations", "lococations", "operibraries", "Loclements", " locators", "Locations", "LOCATIONS", "locATIONS", "locator", "slation", "Locator", "slators", "locators", "colions", "locions", "LOCations", " locATIONS", "slATIONS", "LOCation", "colATIONS", "operations", "loclements", "locors", "operation", " lococations", "LOCocations", "LOCors", "LocATIONS", "colations", " locibraries", "Location", "Locors", "location", "Locions", " loclements", "colation"], "props": ["peperties", "ppp", "pospp", "produps", "pbros", " propp", " probs", "protros", "suppps", "supppps", " procs", "producs", "properties", " propps", "posps", "procs", "posbs", "pebs", "suppperties", "pps", "produpps", "pbps", "peros", "pbbs", "protbs", "propps", "pbs", "posperties", "produperties", "pperties", "probs", "protps", " properties", "propp", "proros", "protperties", "pbperties", "peps", "suppcs"], "url": ["err", "URL", "resource", "base", "feed", "lr", "coll", "Url", "ls", "obj", "entry", "http", "src", "key", "l", "b", "href", "string", "class", "element", "r", "bel", "route", "source", "ource", "rel", "org", "uri", "out", "layer", "name", "ssl", "user", "file", "ll", "ob", "e", "id", "gl", "el", "sl", "str", "rl", "i", "connection", "loc", "location", "f", "address"], "in": ["ini", "err", "image", "resource", "login", "serv", "impl", "stream", "gin", "inner", "inn", "input", "din", "In", "src", "bin", "conn", "c", "r", "IN", "again", "ic", "source", "nin", "io", "it", "out", "ins", "is", "into", "as", "socket", "init", "a", "ac", "con", "data", "file", "isin", "id", "ex", "i", "reader", "n", "connection", "config", "inc", "f", "lin", "s"]}}
{"id1": "12242903", "id2": "1097147", "code1": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"hashKey": ["hashKEY", "buildKEY", "shaKEY", "buildkey", "HashKEY", "shakey", "buildKey", "shaSecret", "HashKey", "Hashkey", "shaKey", "HashSecret", "buildSecret", "hashkey", "hashSecret"], "key": ["base", "temp", "prefix", "this", "keys", "hex", "check", "mix", "input", "KEY", "text", "message", "cache", "pair", "sync", "cert", "password", "use", "connection", "object", "string", "code", "crypt", "token", "k", "type", "x", "number", "sign", "mac", "secret", "block", "chain", "name", "sum", "word", "data", "id", "user", "seed", "value", "Key", "source", "parent", "address"], "hashed": ["hsash", "Hhed", "hsasha", "shotted", "ahash", "hoded", "hhed", "bhashed", "Hashing", "ahhed", "shoded", " hhed", "shhed", "bhotted", "bhashing", "hsashing", "hhashing", "ahashing", "shash", "ahashed", "bhash", "hsashed", "hotted", "hhashed", "Hasha", " hoded", "hhash", "hasha", "Hash", "hhasha", "Hotted", "shashing", "Hoded", "Hashed", "hashing", "shashed"], "md5": ["mand5", "base5", "MD4", "MD512", "MD5", "mand4", "base62", "md512", "amddown", " md512", "md2", "md4", "mddown", "amd3", " md2", "MD50", "md62", "MDdown", "base2", "base4", " md3", " md50", "md50", " md4", "MD2", "MD3", " md62", "mand512", "amd2", "MD62", " mddown", "amd5", "md3", "mand50"], "hash": ["image", "num", "sha", "base", "her", "log", "html", "hex", "check", "json", "message", "count", "cache", "print", "string", "array", "code", "throw", "abi", "result", "v", "rh", "mac", "carry", "length", "ash", "size", "Hash", "sum", "hed", "h", "search", "shadow", "id", "value", "dot", "f", "url", "copy"]}}
{"id1": "19109981", "id2": "22442270", "code1": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 1, "substitutes": {"startScript": ["startText", "startShell", "endScript", " startText", " startCode", "endCode", "StartCode", "startCode", " startShell", "StartShell", "StartText", "StartScript", "endText", "endShell"], "prop": ["resource", "lit", "ag", "property", "Prop", "exp", "load", "properties", "info", "Property", "object", "jp", "scope", "string", "def", "state", "ps", "path", "op", "p", "type", "part", "proc", "frame", "OP", "pb", "oc", "name", "map", "msg", "data", "str", "reader", "pro", "or", "config", "project", "obj", "owner"], "url": ["image", "log", "URL", "base", "resource", "fr", "feed", "br", "coll", "download", "Url", "ls", "ref", "http", "src", "l", "href", "bb", "page", "style", "string", "rc", "route", "path", "fb", "source", "rel", "uri", "layer", "length", "xml", "location", "ssl", "server", "data", "id", "ll", "file", "ob", "gl", "str", "sl", "rl", "connection", "loc", "host", "f", "address"], "r": ["err", "dr", "lr", "fr", "rx", "vr", "w", "cur", "rt", "ir", "rar", "l", "b", "writer", "ws", "pr", "rg", "ri", "c", "rf", "gr", "rc", "ro", "wr", "er", "p", "rr", "nr", "rh", "mr", "rs", "ur", "hr", "sr", "R", "e", "Reader", "rl", "rb", "rw", "reader", "res", "i", "ar", "br", "cr"], "buffer": ["base", "resource", "feed", "offset", "flush", "input", "entry", "available", "paste", "text", "message", "slice", "queue", "key", "b", "bin", "bb", "writer", "string", "null", "buf", "read", "buff", "border", "fb", "uffer", "job", "line", "number", "row", "layer", "block", "length", "character", "pause", "data", "binary", "seed", "transfer", "ob", "str", "comment", "reader", "value", "timeout", "iter", "batch", "source", "Buffer", "header"], "dialog": ["colag", "dialie", "dlag", "Dialie", "toolect", "toolog", "Dialoc", "toolage", "dialag", "dlect", "Dialag", "cologo", "dlogo", " dialie", "dler", "colog", "dialogue", "dlog", "Dialer", "dlogue", " dialogue", "dialect", "toologo", "dialage", "coler", "dialoc", "confoc", "Dialogue", "confogue", "confog", "dialer", "dlage", "dialogo", " dialoc", "confie", "colect", "colage", "Dialog", "cologue"], "script": ["image", "service", "resource", "module", "escape", "config", "input", "zip", "exec", "process", "style", "code", "stage", "screen", "command", "Script", "request", "proxy", "cript", "file", "document", "javascript", "error", "comment", "scroll", "source", "scripts"]}}
{"id1": "6457199", "id2": "8182932", "code1": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"doRequest": ["doCall", "DoResponse", "runResponse", "DoCall", " doProxy", "doResponse", " doResponse", "doProxy", "runCall", "DoProxy", "DoRequest", "runProxy", "runRequest", " doCall"], "request": ["re", "method", "right", "view", "event", "json", "req", "http", "message", "queue", "object", "application", "string", "session", "route", "buffer", "query", "Request", "hello", "result", "uri", "client", "context", "xml", "name", "report", "server", "user", "reference", "call", "instance", "error", "reader", "complete", "url"], "response": ["re", "onse", "body", "model", "index", "service", "feed", "site", "view", "Response", "respons", "json", "http", "message", "output", "api", "respond", "writer", "object", "page", "status", "application", "more", "resp", "route", "success", "result", "v", "out", "client", "report", "server", "reference", "document", " Response", "error", "results", "connection", "template", "host", "parent", "reply"], "path": ["image", "method", "index", "base", "right", "child", "Path", "end", "prefix", "self", "inner", "content", "alias", "patch", "pattern", "relative", "anc", "http", "message", "text", "slice", "key", "api", "info", "arc", "full", "object", "left", "string", "PATH", "code", "walk", "route", "token", "work", "p", "type", "part", "pointer", "uri", "ath", "dir", "context", "name", "location", "host", "data", "id", "port", "ith", "partial", "template", "source", "url"], "internal": ["origin", "ident", "re", "base", "system", "rx", "prefix", "impl", "inner", "storage", "outside", "alias", "special", "personal", "intern", "inline", "http", "standard", "local", "remote", "api", "regular", "string", "background", "initial", "external", "route", "rc", "custom", "join", "single", "source", "original", "uri", "Internal", "x", "attr", "central", "context", "name", "international", "primary", "inside", "absolute", "binary", "exclusive", "foreign", "shared", "normal", "actual", "relative", "parent", "url"], "resource": ["re", "rule", "resources", "image", "base", "this", "stream", "http", "src", "resolution", "use", "api", "media", "ruby", "string", "r", "external", "buffer", "route", "relation", "rc", "ource", "result", "record", "pointer", "uri", "real", "rest", "client", "context", "manager", "sr", "server", "range", "file", "reference", "rera", "Resource", "res", "connection", "source", "url", "address"], "mimeType": ["pimeTypes", "manceType", "mimesPath", "modtype", "maxName", " mileTypes", "pimetype", "mimetype", "mIMEInfo", "miptype", " mimePath", "mimesTypes", "mpePath", "modInfo", "pipType", "mancetype", "smIMEtype", "mimeInfo", " mimeTypes", "monseType", "mancePath", "mIMEType", "mipPath", "smimeName", "mpeTypes", "smimetype", "mimesInfo", "pipTypes", "smimeType", " mileInfo", "smIMEName", "maxtype", "modType", "mileType", "smIMEInfo", " mimeInfo", "mipTypes", "pimePath", "monseTypes", "monsePath", "manceTypes", "pimeType", "maxType", "smIMEType", " mileType", "mimePath", "mimesType", "mpeInfo", "piptype", "smimeInfo", "mIMEtype", "mimeName", " milePath", "mileInfo", "milePath", "mimeTypes", "mIMEName", "mpeType", "modName", "pipPath", "mipType", "mileTypes", "maxInfo", "monsetype"], "is": ["its", "in", "serv", "isi", "vs", "ops", "http", "nis", "ir", "lis", "api", "info", "ui", "IS", "ri", "ps", "was", "ris", "uri", "ras", "isa", "sis", "fs", "ip", "iss", "as", "iso", "bis", "are", "us", "ois", "ori", "isc", "ios", "Is", "i", "im", "ais", "res", "or", "iris"], "os": ["o", "vs", "ops", "dos", "bos", "osi", "acs", "so", "ps", "outs", "ies", "ows", "io", "ros", "Os", "cs", "oss", "nos", "opens", "cos", "oes", "as", "iso", "oS", "us", "ori", "bs", "oses", "ose", "ios", "OS", "ais", "ols", "res", "los", "aos", "s"]}}
{"id1": "16215393", "id2": "21827619", "code1": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"importSequences": [" importSequements", "importMultipleence", "importInternence", "importsequence", "importMultipleFiles", "importSequence", " importSequence", "importSequements", " importsequences", "importInternements", " importSequFiles", "importInternFiles", "importInternences", " importsequence", " importsequFiles", "importsequFiles", "importMultipleements", " importsequements", "importMultipleences", "importsequements", "importsequences", "importSequFiles"], "names": ["Names", "ports", "they", "paces", "objects", "packages", "codes", "keys", "ans", "lines", "services", "ids", "ns", "ons", "mas", "frames", "views", "files", "pres", "headers", "obs", "ames", "images", "params", "works", "nos", "named", "tags", "hops", "states", "ins", "users", "members", "models", "ens", "modules", "stars", "words", "sheets", "strings"], "sequences": ["equencies", "equence", "variences", "sequence", "contances", "responsences", "occupations", "Sequences", "sequations", "equations", "contencies", "varielines", "sequelines", "responsations", "occupence", "contelines", "variencies", "contences", "sequencies", "variances", "sequances", "responsencies", "equences", "Sequances", "occupencies", "Sequencies", "responsence", "occupences", "Sequelines"], "is": ["its", "in", "isi", "ls", "ir", "lis", "has", "api", "info", "IS", "p", "ris", "os", "it", "isa", "out", "sis", "iss", "ip", "as", "close", "iso", "app", "are", "bis", "es", "us", "init", "h", "isc", "ios", "Is", "i", "ais", "or", "ar", "url", "s"], "helper": ["helpen", " Heller", "hemer", " Helmer", "hyf", "comler", "perpers", "helpmer", "heler", "perler", "helpping", "helppers", "shper", "shler", " helar", "helhel", "Helper", " helping", "thelper", "hyper", "theller", "comhel", "helpper", "compen", "comper", "helf", "Heller", "Helpen", "helpPER", "thelpers", "Helf", "calper", "hypers", "helPER", "thelmer", "helpar", " Helper", "calPER", " Helpers", "Helhel", "helpers", "hepers", "helping", "perf", " helPER", "perper", "heper", "helar", "heller", "Helpers", "shhel", "helmer", "hyler", "helpler", "calping", "shpen", "calar", "permer"], "ch": ["enc", "err", "th", "cmd", "chi", "q", "change", "quote", "sch", "coll", "Ch", "sk", "hex", "cl", "och", "cur", " chunk", "arch", "ech", "qu", "conn", "pr", "code", "c", "chu", "gr", "k", "anch", "ci", "CH", "p", "cmp", "conf", "div", "cht", "se", "cha", "cor", "sh", "ce", "che", "unch", "length", "chan", "ur", "cher", "cho", "col", "cp", "h", "char", "ach", "el", "zh", "bh", "ctx", "ich"], "line": ["lc", "letter", "base", "cle", "end", "nl", "content", "lf", "cl", "lines", "entry", "inline", "LINE", "text", "Line", "sync", "l", "page", "string", "code", "pos", "c", "pass", "job", "part", "frame", "row", "block", "word", "data", "file", "cell", "e", "char", "header", "str", "sl", "iter", "source", "url", "lin"], "tokenizer": ["okeniz", "okenize", "Tokeniz", "tokenizing", " tokeniz", "tokenizers", "Tokenize", "okenizer", "tokeniz", "tokenner", "okenner", " tokenizers", "Tokenizing", " tokenize", "Tokenner", " tokenizing", "tokenize", "Tokenizers", "Tokenizer", "okenizers", " tokenner", "okenizing"], "name": ["letter", "base", "prefix", "NAME", "alias", "filename", "key", "label", "info", "object", "string", "ame", "pass", "next", "Name", "path", "er", "type", "part", "named", "number", "attr", "start", "size", "word", "search", "id", "data", "time", "str", "comment", "n", "non", "default", "connection", "url"], "seq": ["lc", "unit", "conv", "vals", "wave", "feed", "vec", "fast", "sci", "quote", "closure", "sequence", "val", "cl", "feat", "req", "parse", " buf", "zip", "sec", "text", "queue", "que", "list", "info", "cb", "struct", "string", "buf", "c", "resp", "buffer", "iq", "sem", "job", "phrase", "frame", "cas", "length", "chain", "sq", " sequence", "la", "sel", "live", "data", "str", "pkg", "iter", "ctx", "config"]}}
{"id1": "23273706", "id2": "14231545", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectDocumentData", "getprojectTreeMeta", "getProjecttreeData", "getprojectTreeInfo", "getProjectPageMeta", "getProjecttreeMeta", "getProjecttreeInfo", "getProjectTreeDATA", "getprojectTreeDATA", "getProjectDocumentMeta", "getProjectDocumentDATA", "getprojecttreeDATA", "getprojecttreeInfo", "getProjectPageData", "getProjectPageInfo", "getProjectDocumentInfo", "getProjectTreeMeta", "getprojecttreeData", "getProjectPageDATA", "getProjecttreeDATA", "getProjectTreeInfo", "getprojectTreeData", "getprojecttreeMeta"], "treeData": [" treeList", "TreeInfo", "reeDat", "reeText", "TreeString", " treeArray", "treeInfo", "treeList", "bodyData", "TreeArray", " treeDec", " treeText", "treeArray", "reeData", "storyDat", "treeDat", "treeDec", "reeArray", "reeList", "storyData", "contentInfo", "bodyList", "storyDec", "monkeyDec", "reeString", "reeInfo", "TreeList", "monkeyArray", "contentData", " treeString", "contentText", "monkeyData", "treeText", "TreeData", "treeString", "contentDat", " treeDat", "monkeyDat", " treeInfo", "bodyString", "storyArray", "bodyDat"], "filename": ["folder", "whatever", "prefix", "dll", "kn", "sheet", "kj", "metadata", "jpg", "journal", "password", "string", "txt", "files", "fd", "path", "kl", "fil", "Filename", "upload", "uri", "dylib", "SourceFile", "figure", "fp", "FILE", "xml", "tmp", "nil", "name", "title", "wav", "framework", "ername", "data", "file", "fn", "username", "database", "location", "url", "ppa", "directory"], "urlString": ["urlstring", "locationStr", "locationString", "urlUrl", "URLstring", "urlStr", "addressString", " urlUrl", "urlURL", " urlStr", "addressStr", "URLUrl", "URLStr", "URLURL", "addressURL", "locationstring", "addressstring", "locationUrl", "URLString", " urlURL", " urlstring"], "urldata": ["urLDat", "URlfdata", "urlledta", "urlledATA", " urlddata", "urLData", "URlfat", "urLDta", "URldata", "urleddata", "urlfat", " urLDdata", "urlfdata", "urldATA", "urllATA", "URlfata", " urLDATA", "urlldata", "URldat", "urlledata", "urlleddata", "urldta", "URldATA", "urledATA", " urLDta", "urlfATA", "URlfATA", "urllata", "urlddata", "URlddata", " urldta", " urldATA", " urLData", "urledata", "urLDATA", "urlfata", "urledta", "urldat", "urllat", "urLDdata"], "factory": ["ufuild", "fictionary", "cactory", "lictionary", "confactory", "conflier", "fuild", "confiller", " fuild", " filler", "ufactory", "fault", " fFactory", "cfiller", "pactory", " fictionary", "luild", "cfactory", "cflier", "cfFactory", "fFactory", "cault", "cFactory", "lactory", "confFactory", "ciller", "liller", "pault", "piller", "ufictionary", "pFactory", "filler", " flier", "flier", "ufiller", " fault"], "parser": ["plugin", "jack", "pdf", "arser", "root", "utils", "json", "fruit", "up", "parse", "http", "l", "b", "writer", "api", "auto", "raf", "ger", "lp", "builder", "string", "driver", "r", "t", "ph", "handler", "er", "p", "se", "uri", "Parser", "util", "xml", "manager", "library", "loader", "instance", "reader", "monkey", "parent", "s"], "u": ["ou", "o", "uu", "U", "ul", " ur", "http", "cu", "l", "uf", "b", "ui", "uv", "c", "universal", "d", "p", "uni", "io", "su", "uri", "plug", "util", "eu", "hu", "nu", "ur", "us", "yu", "tu", "iu", "ru", "lu", "url", "s"], "is": ["gets", "ib", "its", "in", "serv", "abs", "ops", "mis", "http", "ir", "lis", "has", "api", "info", "ui", "isu", "IS", "ri", "pi", "obs", "ie", "p", "ris", "io", "it", "uri", "isl", "isa", "ai", "fs", "iss", "ip", "as", "iso", "bis", "es", "are", "init", "us", "ori", "ob", "ios", "Is", "ais", "or", "ar", "iris", "s"], "os": ["gets", "o", "ops", "dos", "bos", "osi", "http", "ms", "so", "pos", "obs", "ps", "ils", "io", "ros", "Os", "oss", "fs", "opens", "cos", "oes", "as", "iso", "bis", "es", "ens", "us", "sys", "bs", "oa", "oses", "ose", "ob", "ol", "OS", "ios", "oos", "fits", "or", "los", "aos", "s"], "iBufSize": ["iByteufsize", "iBuffLength", "iLufSt", "iBufferLength", "iLlfSize", "iBufSt", "iLlfLength", "iBuffSize", "iBuffLen", "iLlfsize", "iLufLength", "iLlfSt", "iBuffersize", "iByteufLength", "iBlfLength", "iBufsize", "iBuffSt", "iBlfLen", "iBbufsize", "iBlfsize", "iBuffsize", "iBufferSize", "iBytebufsize", "iLufsize", "iBufferSt", "iBytebufSize", "iBufLen", "iBlfSize", "iBytebufLen", "iBbufSize", "iLufSize", "iBufLength", "iByteufSize", "iBbufLen", "iByteufLen", "iBbufLength", "iBytebufLength", "iBlfSt"], "inBuf": ["inFuf", "outBuffbuf", " inCump", "inBump", "inPlunk", "inPluf", "inDuf", "inBub", "outBub", "inCuff", "inDaf", "inFaf", "inPlump", "inCaf", "inDuff", "outBuf", "outBuffub", "inCump", "inBbuf", " inBbuf", " inBump", " inFbuf", "outBbuf", "outBuffuf", "inBuff", " inCuf", " inBaf", "inBlunk", "inBuffbuf", "inFbuf", " inFuf", " inCunk", "inCuf", "inBluf", "inBlub", " inFaf", " inFuff", "inBuffump", "inPlbuf", "inBlbuf", "inBlump", "inCbuf", " inCbuf", "inbub", "inBuffub", "inDbuf", "inbuf", " inBuff", "outBuffump", "inBuffuf", "inFuff", "inbbuf", "inbump", "inBunk", "outBump", "inBaf", "inCunk", " inBunk"], "iNumRead": ["iNumberBuild", "iValread", "qiValRead", "iLenWritten", "qiNumREAD", "iChanREAD", "iNumREAD", "iNumberread", "qiValBuild", "iChanread", "inumWritten", "iNumberREAD", "qiNumBuild", "iFatWrite", " iFatWrite", "iNumBuild", " iNumWritten", "pNumRead", "iLenRead", "qiNumread", "qiNumRead", "iLenWrite", "pNumWritten", "iNumberWrite", "pNumread", "iChanRead", "iValBuild", "iNumberRead", "iFatWritten", " iFatWritten", "qiValREAD", "iValREAD", "iNumberWritten", "iChanBuild", "pNumWrite", "iNumWritten", "pNumberRead", "pNumberread", "pNumberWrite", " iFatRead", "pNumberWritten", "iValRead", "iFatRead", "iNumWrite", " iNumWrite", "inumWrite", "qiValread", "inumRead", "iNumread", "inumread"], "f": ["j", "o", "fr", "feed", "fa", "F", "ff", "fe", "fi", "fc", "l", "b", "uf", "full", "c", "rf", "r", "g", "t", "fd", "d", "handler", "p", "io", "v", "df", "fp", "fs", "h", "file", "fn", "e", "sf", "n", "m", "s"], "inputstream": ["Inputsw", "outputstream", "contentsystem", "outputchannel", "inputchannel", " inputsw", "inputStream", "contentstream", " inputStream", "inputsystem", " inputchannel", "inputsw", "Inputchannel", "Inputsystem", "contentStream", "outputStream", "InputStream", " inputsystem", "Inputstream", "contentsw"], "document": ["html", "office", "ocument", "content", "window", "Documents", "output", "list", "l", "info", "media", "object", "page", "null", " documentation", "collection", "dom", "t", "d", "node", "doc", "p", "record", "container", "director", "response", "DOM", "context", "xml", "Document", "tree", " documents", "docs", "language", "data", "file", "e", "parent", "n", "m", "source", "project", "directory"], "nodelist": ["nodedesh", " nodesename", "nondeme", "anodedata", " nodeselist", "nODemark", "NODemark", "nozemark", " nodette", "snodette", "Nodestyle", " nodels", "nondata", "nodsette", "nodslist", "nozelist", "nODestyle", "nodedelist", "NODesh", "snodsette", "nodedeme", "nodename", "nodeline", " nodename", "Nodelist", "nodedestyle", "nodeme", "nodesels", "anodata", "snodslist", "nonedelist", "nODesh", "anodedelist", "nODelist", "nodestyle", "nodesette", "nozestyle", "nodlist", "nozette", "nodeata", "Nodesh", "nodeelist", "nodseline", "nodselist", "NODelist", "nonedename", "Nodemark", "nodedestate", "snodeline", "anodedeme", "anodestate", "nODeline", "anodeme", "nozesh", "nodemark", "nodedlist", "snodelist", "anodelist", "snodselist", "nodette", "nondestate", "snodseline", "nodedeline", "nodesh", "nodata", "nodedette", "anodedestate", "nodestate", "nondelist", "nonedels", "snodlist", "nodesename", "nonedette", "nodeestate", "NODestyle", "nODette", "nozename", "nodedata", "nodeselist", " nodesette", "nozels", "nodels", "nodeeme", " nodesels", "nodedemark", "nODlist"], "num": ["np", "index", "dim", "Num", "unit", "nb", "temp", "tri", "umi", "um", "ul", "net", "count", "total", "mu", "comb", "mon", "pos", "nam", "dom", "norm", "node", "en", "part", "uni", "NUM", "div", "multi", "uri", "om", "len", "nr", "number", "lim", "nom", "nu", "init", "col", "sum", "mult", "con", "loc", "span", "zero", "n", "m", "inc", "max"], "i": ["ini", "mi", "j", "index", "o", "in", "yi", "chi", "hi", "isi", "phi", "cli", "ii", "fi", "ix", "slice", "mu", "ik", "l", "b", "info", "ui", "iv", "ri", "pi", "c", "gi", "g", "d", "li", "ci", "p", "ie", "part", "multi", "si", "xi", "io", "I", "eni", "v", "uri", "ai", "bi", "ji", "y", "it", "ip", "x", "start", "col", "ori", "a", "qi", "ti", "id", "iu", "di", "m", "oi"]}}
{"id1": "9210168", "id2": "665420", "code1": "            @Override\n            public void run() {\n                try {\n                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n                    InputStream fis = url.openStream();\n                    InputStreamReader r = new InputStreamReader(fis, \"UTF-8\");\n                    BufferedReader br = new BufferedReader(r);\n                    String line;\n                    StringBuilder sb = new StringBuilder();\n                    while (null != (line = br.readLine())) {\n                        sb.append(line);\n                        sb.append(\"\\r\\n\");\n                    }\n                    br.close();\n                    r.close();\n                    fis.close();\n                    final String text = sb.toString();\n                    SwingUtilities.invokeLater(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            MainPanel.this.source.setText(text);\n                            MainPanel.this.source.setCaretPosition(0);\n                        }\n                    });\n                } catch (Exception ex) {\n                }\n            }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"run": ["image", "register", "unit", "base", "in", "create", "inner", "stop", "render", "launch", "runs", "process", "add", "output", "replace", "un", "update", "show", "home", "code", "background", "display", "apply", "running", "work", "job", "out", "loop", "start", "name", "test", "runner", "call", "Run", "execute", "exec", "invoke"], "url": ["re", "err", "image", "URL", "base", "resource", "fr", "lr", "service", "Url", "http", "remote", "l", "b", "api", "string", "path", "uri", "plug", "nr", "ur", "loader", "ssl", "loc", "server", "user", "file", "id", "browser", "str", "sl", "rl", "source", "f", "address"], "fis": ["Fais", "flisa", "flis", " fIS", "pis", " fIs", "bais", "bIS", "pIs", "piss", "fais", "FIs", "fIs", "bIs", " fisa", " fiss", "Fis", " fais", "fIS", "fisa", "bis", "pisa", "Fiss", "fliss", "fiss", "biss", "FIS", "flIs"], "r": ["err", "resource", "fr", "rx", "vr", "kr", "rt", "ir", "ler", "rar", "l", "b", "pr", "ri", "c", "rf", "rc", "wr", "tr", "d", "er", "p", "rr", "BR", "nr", "rh", "rus", "mr", "is", "rs", "ur", "hr", "sr", "R", "e", "Reader", "reader", "rb", "i", "res", "rl", "ru", "ar", "cr", "f", "s"], "br": ["err", "dr", "lr", "fr", "rx", "vr", "HR", "bl", "arr", "rt", "yr", "bridge", "b", "bb", "ch", "buf", "gr", "tr", "wr", "fb", "bro", "bf", "be", "result", "Br", "BR", "mr", "B", "hr", "sr", "ob", "brush", "browser", "str", "reader", "rb", "res", "bc", "bh", "cr"], "line": ["link", "letter", "lc", "base", "end", "nl", "liner", "lf", "bl", "cl", "lines", "entry", "inline", "LINE", "Line", "key", "column", "l", "b", "shell", "style", "string", "code", "buffer", "pass", "li", "split", "part", "number", "row", "le", "character", "name", "word", "sel", "ge", "data", "file", "id", "cell", "char", "header", "str", "sl", "i", "rl", "comment", "el", "cr", "f", "lin"], "sb": ["ib", "wb", "nb", "bsp", "lr", "bm", "eb", "storage", "zb", "bl", "SB", "ls", "sa", "xb", "src", "amb", "b", "bb", "cb", "bp", "usb", "buf", "gb", "buff", "abb", "buffer", "sn", "fb", "lb", "rob", "bf", "bd", "si", "obb", "sg", "sv", "erb", "bt", "pb", "bis", "bs", "binary", "sf", "sth", "rb", "mb", "bc", "bh", "bj", "BB", "db", "ab"], "text": ["letter", "config", "content", "format", "input", "entry", "obj", "message", "output", "b", "info", "object", "string", "txt", "code", "TEXT", "font", "buffer", "Text", "path", "translation", "result", "name", "title", "test", "ext", "data", "id", "str", "value", "comment", "connection", "source"]}}
{"id1": "9805906", "id2": "7006052", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"dump": ["flush", "download", "load", "zip", " dumps", "info", " dumped", "update", "files", "export", "store", " dumping", "diff", "df", "out", "Dir", "all", "dir", "ln", "data", "ump", "transfer", "println", "db", "f", "copy", "save"], "source": ["unit", "slave", "base", "service", "resource", "SOURCE", "site", "view", "stream", "Source", "current", "this", "input", "src", "http", "slice", "use", "remote", "connection", "ources", "string", "from", "core", "ource", "se", "uri", "series", "start", "server", "file", "s", "iter", "scene", "sin", "parent", "address"], "target": ["force", "base", "resource", "office", "root", "to", "alias", "effect", "Target", "top", "master", "src", "platform", "output", "table", "replace", "object", "null", "next", "path", "large", "goal", "settings", "result", "pointer", "it", "dest", "out", "enemy", "host", "file", "follow", "port", "parent", "database", "arget", "connection", "template", "project", "address"], "is": ["gets", "its", "in", "isi", "abs", "ops", "mis", "ls", "bos", "nis", "lis", "has", "info", "ui", "ws", "IS", "ps", "was", "obs", "ris", "io", "isl", "cs", "oss", "isa", "ai", "opens", "iss", "ip", "ins", "ses", "as", "iso", "bis", "es", "ens", "ori", "us", "ois", "bs", "ists", "oses", "ios", "Is", "i", "im", "ais", "or", "iris", "ics", "s"], "os": ["its", "o", "vs", "ops", "osi", "bos", "dos", "acs", "pos", "ps", "obs", "outs", "ies", "ows", "ues", "boot", "ds", "io", "ros", "Os", "nos", "oss", "cs", "fs", "cos", "oes", "as", "es", "ens", "ori", "us", "ips", "bs", "oa", "oses", "ose", "OS", "ios", "ss", "ais", "oos", "i", "ks", "ols", "or", "los", "aos", "s"], "done": ["enabled", "de", "die", "gone", "foo", "got", "current", "expected", "none", "always", "odo", "nice", "later", "doing", "after", "disabled", "Done", "did", "dad", "future", "loaded", "checked", "running", "once", "confirmed", "next", "part", "progress", "started", "finished", " finished", "yes", " Done", "defined", "dirty", "ready", "data", "last", "made", "empty", "complete", "one", "due"]}}
{"id1": "9109613", "id2": "8182932", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"fileCopy": ["folderCopy", "FileUpload", " fileUpload", "foldercopy", " fileTransfer", " filecopy", "FileCopy", "filecopy", "fileTransfer", "folderTransfer", "FileTransfer", "fileUpload", "Filecopy", "folderUpload"], "from_name": ["from_key", " from_key", "fromqpath", "from__Name", "from_Name", "from_path", "fromameName", " from_time", " from_Name", "fromFullalias", "fromametime", " from__Name", "from_image", " from_address", "from_size", "fromamename", "fromThename", "fromFulladdress", "fromqName", "from__address", "from_word", " from_image", " from_resource", "from__name", "from__alias", " from_path", "from_no", "fromTheName", " from__name", " from_space", "from_time", "from_space", " from_word", " from_filename", " from_no", "from_alias", "fromameno", "from_address", " from_alias", "from_resource", "from_filename", "fromqfilename", "fromThespace", " from__alias", "fromTheword", "fromqname", " from_size", "fromFullname", " from__address", "fromFullName"], "to_name": [" to_key", "to_common", "from_Name", "to_names", "from_path", "tokname", "tokcommon", "To_name", "to_file", "from_names", "to_path", "To_Name", "to_key", "to_Name", "tokName", " to_file", "To_common"], "fromFile": ["sourceLibrary", "sourceDirectory", " fromDir", "fromDir", "FromLibrary", "FromFiles", "fromLine", " fromLibrary", "asFactory", "ofFile", "fromFiles", "sourcePage", "fromPackage", "FromFunction", "connectionfile", " fromFactory", "fromFunction", "FromFile", "ofPackage", "toFactory", "connectionFile", "asfile", " fromModel", "fromFolder", "toLine", "onePage", "fromLibrary", "asFiles", "onefile", "autofile", "autoFile", "FromPage", "FromLine", "oneDir", "fromFactory", "Fromfile", " fromFunction", " fromFiles", "FromModel", "asFile", " fromFolder", " fromPage", "sourceFile", "oneFile", "autoFolder", "toFunction", "fromDirectory", " fromPackage", "oneFunction", "FromFolder", "oneModel", "toFiles", "offile", " fromDirectory", "fromfile", "fromModel", "FromDir", "connectionFolder", "oneFolder", " fromfile", "FromDirectory", " fromLine", "tofile", "ofFolder", "autoPage", "fromPage", "connectionPackage"], "toFile": ["noFile", "fromDir", "tempfile", "baseTable", "TODir", "toFactory", "ToPlace", "aFile", "toLine", "targetFactory", " toFactory", "TOPage", "targetPage", "targetFile", "coFunction", " toSourceFile", "ToLibrary", "baseDir", "targetDir", "fromLine", "cofile", "ToPage", " toLine", "ToLine", "fromFiles", "toDir", "TOPlace", "toLibrary", "nofile", "targetPlace", "ToFactory", "targetFolder", " tofile", "TOFile", "ofDir", "sofile", "ToFiles", " toDirectory", "toFunction", "targetfile", "fromDirectory", "toFiles", "offile", "ToDir", "toPlace", "basefile", " toPage", "tofile", "tempFolder", "ToFile", "noLibrary", " toFiles", "noPage", "soFile", "toSourceFile", "ToDirectory", " toFolder", "aDir", "baseFile", "aFiles", "ToSourceFile", "coDirectory", "fromfile", " toTable", "fromPage", "tempFile", "Tofile", "ToFunction", "ofFile", "toTable", "afile", "targetSourceFile", "toPage", "ofTable", "soPage", "toDirectory", "soLibrary", " toDir", "tempFactory", "coFile", "toFolder", " toFunction"], "parent": ["resource", "current", "full", "page", "null", "class", "pa", "p", "div", "any", "name", "test", "search", "file", "connection", "source", "directory", "lc", "pool", "shape", "child", "point", "content", "patch", "api", "par", "string", "session", "g", "parents", "ip", "server", "id", "user", "loc", "master", "exp", "remote", "pr", "home", "option", "path", "large", "type", "line", "out", "client", "region", "term", "data", "port", "or", "inc", "guard", "location", "address", "rule", "section", "paren", "pt", "root", "key", "Parent", "pe", "part", "and", "manager", "col", "ac", "valid", "complete", "url", "owner"], "dir": ["dec", "folder", "ver", "die", "dr", "dev", "DIR", "root", "coll", "dc", "cur", "or", "group", "exp", "ir", "rec", "wd", "cat", "home", "class", "def", "r", "dis", "dist", "fd", "path", "d", "di", "doc", "dict", "div", "rel", "container", "build", "attr", "out", "Dir", "director", "block", "manager", "name", "col", "keep", "mod", "dep", "file", "lock", "per", "iter", "lib", "loc", "inc", "db", "f", "url", "directory"], "from": ["ou", "link", "de", "base", "o", "in", "fr", "module", "can", "this", "self", "stream", "view", "form", "po", "who", "with", "channel", "parse", "add", "From", "ch", "conn", "api", "auto", "wh", "when", "left", "url", "so", "c", "query", "flo", "part", "io", "se", "out", "ce", "by", "ra", "client", "hand", "start", "name", "cm", "clean", "bean", "con", "low", "range", "file", "user", "component", "e", "empty", "old", "per", "one", "normal", "vol", "or", "connection", "get", "source", "cr", "without"], "to": ["TO", "ver", "base", "o", "office", "fat", "po", "with", "eto", "target", "top", "http", "cache", "sync", "output", "api", "b", "auto", "object", "page", "tto", "via", "so", "pi", "about", "store", "too", "again", "token", "fb", "two", "be", "not", "op", "tom", "type", "flo", "io", "plus", "su", "To", "out", "by", "see", "size", "name", "co", "proxy", "until", "on", "file", "port", "go", "no", "will", "one", "or", "connection", "source", "db", "copy"], "buffer": ["resource", "shape", "feed", "flush", "duration", "channel", "available", "message", "cache", "total", "queue", "table", "bytes", "texture", "device", "page", "string", "read", "buf", "null", "position", "buff", "border", "vector", "Buffer", "padding", "uffer", "result", "number", "row", "layer", "character", "length", "block", "server", "data", "reference", "binary", "seed", "variable", "document", "transfer", "value", "comment", "reader", "iter", "default", "batch", "memory", "header", "address"], "bytes_read": ["bytes_write", "classesavREAD", "lines_put", " bytes_load", "classes_view", "classesavview", "bytesESSput", "bytesayread", "bytes_READ", " bytes_write", "bytesESSread", "bytesESSwritten", "bytesayput", "classes_available", "bytes_available", "lines_received", "bytesavavailable", "bytesavview", "classes_READ", "bytes___available", "bytes_received", "lines_read", "bytes_put", "bytesESSreceived", "classes_read", "bytes___view", "classesavread", "bytes_view", "bytesaywritten", "bytesavREAD", " bytes_written", "bytesavread", "lines_written", "bytes___READ", "classesavavailable", "bytesayreceived", "bytes_written", "bytes_load", "bytes___read"]}}
{"id1": "2676365", "id2": "5138455", "code1": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"reset": ["register", "setup", " Reset", "stop", "flush", "et", " rebuild", "back", "sync", "update", "clear", "set", " reconnect", "commit", " checkpoint", " disconnect", " migrate", "close", "start", "init", "disable", "release", "delete", " shutdown", " restore", "destroy", "activate", "save"], "currentPilot": ["activePiece", "activePilot", "currentPayacket", "currentCPooter", "currentPayistor", "currentCPacket", "currentPooter", "activePistor", " currentPector", "currentPortacket", "currentPacket", "currentpacket", "currentPayiece", " currentCPector", "currentCPector", " currentCPacket", " currentCPilot", "activepilot", "currentPortector", "currentPortilot", "currentPointilot", "currentPiece", "activepiece", "currentPector", "activepacket", "currentPistor", "currentpiece", "currentPointiece", "activePacket", "currentpooter", " currentCPooter", "currentpistor", " currentPacket", "currentPointistor", "activepistor", "currentPointacket", "currentPayilot", "currentpilot", "currentPortooter", "currentpector", " currentPooter", "currentCPilot"], "psta": ["jsa", " psa", " pesta", "Pla", "pesta", "pela", "pesa", "jda", "parsta", "Pasi", "Pste", "pasi", "pppa", " pda", "psa", "Pda", " pppa", "Pesta", " pla", "parsa", " pste", "Psa", "Pppa", "pda", " pasi", "peppa", "jste", "parasi", "Psta", "jsta", "pste", "pla", "paresta"]}}
{"id1": "19944975", "id2": "4118412", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["saveConfig", "writeConfig", " writeConfig", " writeReport", "writeReport", "WriteReport", "WriteConfiguration", "WriteSection", " writeSection", "saveConfiguration", "saveSection", "saveReport", "WriteConfig", "writeSection"], "out": ["err", "pool", "resource", "base", "o", "temp", "prefix", "this", "inner", "flush", "w", "write", "plain", "project", "at", "obj", "window", "exp", "exec", "filename", "output", "OUT", "password", "writer", "conn", "list", "object", "key", "sync", "scope", "string", "c", "IN", "external", "again", "outs", "path", "m", "line", "io", "Out", "client", "xml", "report", "name", "init", "inas", "ext", "dump", "server", "user", "file", "ex", "reader", "res", "lib", "connection", "config", "parent"], "url": ["image", "URL", "base", "resource", "service", "feed", "stream", "Url", "open", "channel", "http", "l", "b", "api", "conn", "object", "page", "string", "r", "path", "io", "rel", "org", "uri", "xml", "location", "ssl", "server", "data", "file", "ll", "ob", "sl", "connection", "config", "source", "web", "f", "address"], "in": ["ini", "err", "kin", "resource", "login", "serv", "stream", "gin", "inner", "inn", "input", "In", "inc", "cms", "bin", "b", "conn", "c", "pin", "r", "IN", "again", "source", "nin", "cin", "min", "ins", "is", "xml", "as", "lin", "socket", "inas", "ssl", "a", "inside", "ac", "data", "rin", "isin", "file", "id", "i", "reader", "win", "n", "din", "f", "copy", "s"]}}
{"id1": "16388708", "id2": "19868933", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFileToStream", "decodeStringToString", "decodeFileAsFiles", "decodeFileAsStream", "decodeString2Files", "decodeStringToFiles", "decodeFile2String", "decodeFile2File", "decodeFileAsString", "decodeStringToFile", "decodeFile2Files", "decodeFileFromFiles", "decodeFileFromFile", "decodeFileFromStream", "decodeFile2Stream", "decodeString2File", "decodeFileToFiles", "decodeStringToStream", "decodeFileToString", "decodeFileAsFile", "decodeString2String", "decodeString2Stream"], "infile": [" infilename", "infiles", "inputfile", "outfiles", "inFile", "InFile", " instream", "minstream", "Instream", "inputfilename", "inbase", " infiles", " infp", " inFile", "minbase", "minFile", "minfile", "outfilename", "outfp", "instream", "inputfiles", "infp", "Inbase", "inputfp", "infilename", " inbase", "Infile"], "outfile": ["outputdatabase", "outFile", "inputfile", " outFile", "outpath", "outputfilename", "inFile", " outpath", "inputdatabase", " outfilename", "outdatabase", "outfolder", "outputfolder", "outputpath", "inputpath", "inputFile", " outfolder", "infolder", "outfilename", " outdatabase", "outputfile", "infilename", "outputFile"], "in": ["re", "err", "ini", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "lin", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "m", "din", "socket", "inc", "s"], "out": ["ou", "err", "log", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "obj", "channel", "In", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "pass", "outs", "work", "job", "line", "io", "Out", "client", "off", "name", "co", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "channel", "count", "cache", "slice", "queue", "b", "bytes", "bin", "bb", "null", "buf", "buff", "border", "padding", "split", "uffer", "type", "result", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "r", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "method", "model", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "open", "better", "message", "growth", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "positive", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "13233761", "id2": "4461350", "code1": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 1, "substitutes": {"executeUpdateTransaction": ["executeInsertSession", "executeDatabaseSession", "executeDatabaseStatement", "executeInsertStatement", "executeInsertTx", "executeUpdateStatement", " executeDatabaseStatement", "executeDatabaseTx", "executeDatabaseTransaction", "executeQueryStatement", " executeUpdateSession", "executeUpdateTx", "executeQuerySession", " executeDatabaseTx", " executeUpdateTx", "executeUpdateSession", "executeQueryTransaction", " executeUpdateStatement", " executeDatabaseTransaction", "executeQueryTx", " executeDatabaseSession", "executeInsertTransaction"], "queries": ["squands", "compests", "compands", "commeries", "quands", "blips", "squeries", "questires", "quips", "squests", "questeries", "comperies", "quires", "squires", "blands", "quests", "questands", "compips", "squips", "commires", "questips", "blests", "bleries", "commands", "commips"], "autoCommit": ["autoDebrit", "autoComitted", "autoCompits", "autocommmit", " autoComitted", "AutoCommrit", "AutoCommit", "autoCommrit", "AutoCommits", "autocommits", "AutoDebit", "AutoCommmit", " autoCommmit", "autoDebits", "autoCommitted", "autoDebit", "autoommit", "autoDebmit", "autoCommits", "autoCompmit", "autoommitted", "AutoDebmit", " autoComit", "autoCompit", " autoComits", "AutoDebits", "autoommits", " autoCommits", "autoommmit", "autoCommmit", "autoCompitted", "autoComit", "AutoDebrit", "autocommit", " autoCommitted", "autoComits", "autocommrit", "autoComrit"], "iterator": ["ski", "interstitial", "index", "section", "outer", "end", "walker", "done", "stream", "inner", "sequence", "step", "metadata", "internet", "encer", "gener", "entry", "inter", "filter", "parser", "slice", "list", "later", "info", "finder", "consider", "string", "set", "collection", "creator", "vector", "next", "handler", "adder", "ie", "division", "pointer", "started", "loop", "series", "context", "start", "size", "population", "loader", "runners", "init", "cher", "runner", "ter", "former", "data", "inst", "instance", "Iterator", "ator", "i", "reader", "database", "iter", "connection", "starter"], "query": ["rule", "action", "q", "Query", "script", "question", "sequence", "entry", "filter", "message", "key", "table", "qu", "update", "style", "string", "sql", "condition", "next", "join", "result", "record", "ql", "uri", "commit", "row", "command", "sq", "expression", "name", "search", "data", "call", "value", "comment", "str", "press", "connection", "select"], "statement": ["action", "unit", "script", "section", "storage", "ment", "flush", "sequence", "Statement", "function", "usage", "parser", "use", "table", "conn", "style", "string", "element", "sql", "condition", "session", "state", "next", "join", "stat", "si", "result", "commit", "mt", "response", "command", "start", "expression", "data", "document", "inst", "comment", "database", "connection", "execute", "s"]}}
{"id1": "21821404", "id2": "12039034", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    public static ArrayList<RoleName> importRoles(String urlString) {\n        ArrayList<RoleName> results = new ArrayList<RoleName>();\n        try {\n            URL url = new URL(urlString);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            StringBuffer buff = new StringBuffer();\n            String line;\n            while ((line = in.readLine()) != null) {\n                buff.append(line);\n                if (line.equals(\"</RoleName>\")) {\n                    RoleName name = ProfileParser.parseRoleName(buff.toString());\n                    results.add(name);\n                    buff = new StringBuffer();\n                } else {\n                    buff.append(NL);\n                }\n            }\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        } catch (ParsingException e) {\n        }\n        return results;\n    }\n", "label": 1, "substitutes": {"getWebPage": ["getVirtualpages", "getVirtualPage", "parseWebpage", "getWebpages", "parsewebpage", "parsewebpages", "getwebpages", "getwebpage", "parseWebpages", "getWebpage", "getVirtualpage", "parsewebPage", "parseWebPage", "getwebPage"], "urlObj": ["URLObj", "blogObject", "urlObject", " urlOb", "strObject", "URLobj", " urlObject", "urlobj", "resourceExt", "URLExt", "UrlObj", "urlExt", "httpobj", " urlExt", "UrlOb", "resourceObject", " urlInst", "httpOb", "strobj", "resourceobj", " urlobj", "httpObj", "strObj", "Urlobj", "blogObj", "blogInst", "urlOb", "blogobj", "resourceObj", "URLObject", "strInst", "urlInst"], "content": ["body", "model", "html", "resource", "Content", "feed", "raw", "section", "cont", "comments", "continue", "coll", "write", "json", "lines", "load", "message", "text", "output", "java", "object", "page", "string", "code", "array", "c", "online", "buffer", "core", "work", "result", "css", "out", "response", "report", "clean", "server", "data", "file", "document", "value", "empty", "comment", "source", "url", "header", "address"], "is": ["its", "in", "site", "isi", "stream", "est", "abs", "ops", "mis", "cms", "nis", "ir", "lis", "does", "problem", "info", "ui", "ires", "IS", "ri", "r", "ise", "you", "ps", "irc", "was", "be", "ie", "ris", "io", "isp", "os", "it", "isl", "x", "isa", "ai", "out", "rest", "fs", "iss", "ip", "ins", "il", "as", "any", "iso", "bis", "es", "us", "ois", "al", "id", "isc", "ser", "ios", "Is", "i", "im", "ais", "or", "ar", "iris", "s"], "reader": ["in", "rx", "stream", "rer", "inner", "worker", "parser", "ler", "reading", "rar", "bird", "l", "writer", " Reader", "read", "ri", "driver", "r", "buffer", "ro", "rc", "oder", "handler", "er", "io", "rr", "x", "row", "director", "actor", "ner", "loader", "h", "server", "e", "ser", "Reader", "i", "iter", "or", "editor"], "line": ["link", "body", "lc", "cle", "section", "lf", "cl", "lines", "entry", "inline", "LINE", "text", "message", "Line", "column", "key", "l", "object", "page", "ine", "string", "code", "buffer", "pass", "item", "strip", "part", "row", "out", "response", "character", "block", "name", "col", "word", " inline", "server", "data", "file", "user", "cell", "char", "str", "comment", "connection", "source", "cr", "f", "url", "lin"]}}
{"id1": "4602568", "id2": "18696387", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"storeImage": ["processIcon", "processVideo", "storeMedia", " storeVideo", "processImage", " storeMedia", "storeVideo", "processMedia", " storeIcon", " transferIcon", "storeIcon", " transferMedia", " transferImage", " transferVideo"], "inStream": [" inReader", "winStream", "winSteam", "winVideo", "inputPath", "inputstream", "inSteam", "inputStream", "winReader", "INStream", "inCh", " instream", "inPath", " inVideo", "INPath", "INCh", " inPath", "inReader", " inSteam", " inCh", "inputSteam", "INstream", "inputReader", "instream", "inputVideo", "inVideo", "inputCh"], "fileName": ["httpname", "fileNames", " filePath", "imageName", "httpName", "filePath", "FILEName", "resourceInfo", "filename", "imageNames", "FileInfo", " fileNames", " filePart", " fileNode", "FILEPath", "FilePart", "FilePath", "fileInstance", "filePart", "imagename", "FILEInstance", "FileName", "FileInstance", "Filename", " fileInstance", " filename", "FileNames", "fileNode", "FILEname", "resourceName", " fileInfo", "httpPath", "resourceNode", "fileInfo", "httpPart", "imagePath", "FILENode", "resourcename", "FILEInfo"], "resize": [" Resized", " Resizes", "resizes", " Resizer", " resizer", " Resize", "resized", "Resize", " resizes", "Resizer", "resizer", " resized", "Resizes", "Resized"], "rightNow": ["thirdThen", "straightAccount", "thirdnow", "thirdCurrent", "dayNOW", "thirdNOW", " rightnow", "thirdNow", "thirdToday", "dayNow", "dayToday", " rightAccount", "RightAccount", "rightNOW", "rightAccount", "straightToday", "dayCurrent", "RightToday", "rightnow", " rightToday", "straightNow", " rightThen", " rightNOW", " rightCurrent", "Rightnow", "RightNow", "rightToday", "straightnow", "RightCurrent", "RightNOW", "rightCurrent", "rightThen"], "dayNamedFolderName": ["dayNestedDirectoryname", "dayNamedFoldername", "dayNamedFolderPath", "dayNamedAreaSize", "dayNamedFolderInfo", "dayNamedfolderName", "dayNamedFolderSize", "dayNestedFolderSize", "dayNestedFolderName", "dayNamedFileKey", "dayNamedFileInfo", "dayNamingFolderName", "dayNamedfolderInfo", "dayNestedDirectorySize", "dayNnamedFolderInfo", "dayNestedDirectoryName", "dayNestedDirectoryPath", "dayNamedDirName", "dayNamingFolderKey", "dayNamedDirInfo", "dayNamingFolderSize", "dayNamedAreaname", "dayNamedAreaName", "dayNnamedFolderSize", "dayNamedDirectoryName", "dayNnamedFolderName", "dayNestedFoldername", "dayNamedFilePath", "dayNamedDirSize", "dayNamedfoldername", "dayNnamedFolderPath", "dayNamedDirectoryname", "dayNamedfolderPath", "dayNamedDirectorySize", "dayNamingFolderInfo", "dayNamedfolderSize", "dayNestedFolderPath", "dayNamedFolderKey", "dayNamedDirectoryPath", "dayNamedFileName", "dayNamedFileSize", "dayNamedAreaPath", "dayNamedDirKey"], "uploadDirRoot": [" uploadFileRoot", "uploadFolderroot", "inputDirName", " uploadDirroot", " uploadDirHome", "uploadFolderBase", "uploadFilePath", "uploadDirectoryBase", "inputDirRoot", "UploadFolderRoot", "uploaddirroot", "uploadBaseroot", "uploadBaseRoot", "uploadDbHome", "UploadDirroot", "uploadBasePath", "inputDirectoryName", "UploadFolderroot", "uploadDirPath", "UploadFolderBase", "uploadFileRoot", "uploadDirectoryPath", "uploadDbRoot", "uploadDirroot", "inputDirectoryHome", "UploadDirPath", "uploadDirectoryRoot", "uploadFolderRoot", "uploadFileHome", "uploadDirHome", "inputDirPath", "inputDirectoryPath", "UploadDirRoot", "uploadDirBase", "uploadDbName", "inputDirHome", "uploaddirHome", "inputDirectoryRoot", "uploadDirectoryHome", "uploadDirName", "uploadBaseBase", "UploadFolderPath", "uploadDbPath", "uploadFileroot", "uploadDirectoryName", "uploadDirectoryroot", "uploaddirRoot", " uploadFileHome", "uploadFolderPath", "uploadFileName", "UploadDirBase", " uploadFileroot"], "file": ["File", "image", "folder", "log", "base", "flow", "unit", "service", "child", "model", "force", "view", "rule", "function", "ile", "entry", "fe", "up", "http", "zip", "local", "b", "full", "object", "auto", "page", "home", "url", "class", "pe", "files", "path", "work", "handler", "p", "line", "part", "out", "fp", "book", "dir", "FILE", "name", "user", "document", "e", "comment", "per", "lib", "connection", "parent", "f", "directory"], "extension": ["exversion", "exion", "extend", "exension", "intension", "xtend", "ExtION", "intION", "EXTdivision", "Extend", "intend", "xtion", "interion", "interension", "exdivision", "EXTversion", "xtION", "extdivision", "extversion", "extION", "interdivision", "Extension", "EXTension", "Extion", "intion", "interversion", "xtension", "extion", "EXTion"], "outFileName": ["outLineLocation", " outFileSystem", "inLinePath", "outPathType", "inFilePath", "inFileKey", "OutDirInfo", "OutFileInfo", "outFileKey", "outPathPath", "outfileLocation", " outFilename", "outDirInfo", "outFileType", "inFileInfo", "outLinePart", "outFolderLine", "outPlaceAddress", "outPlaceSystem", "OutDirLength", "outLinename", "outFileLength", "inLineInfo", " outPlaceLine", "outFieldSystem", " outFilePath", "outFolderInfo", "OutDirName", "outLineSize", "outLineName", "outfileLength", "outPathName", "outFileInfo", "outDirName", "outLineType", "outfileName", "outFolderPath", "inLinePart", " outFileAddress", "outFileLine", "outDirPart", "outPlaceLocation", " outPlaceAddress", "outfileSize", "outFullKey", "OutFileName", "outPlaceSize", "inLineName", "outLinePath", "outLineKey", "outFullPart", "outPathname", "outLineLength", " outPlaceLocation", "outFilePart", "outFieldLine", " outPlacePath", "outFieldAddress", "outfilePath", " outFileSize", "outFilePath", "outFilename", "outDirLength", "outFileSize", "outFileLocation", "OutDirPath", " outFileLine", "inLineKey", " outPlacename", " outPlaceSystem", "outLineInfo", "outPlaceLine", "outFolderName", "inFileLine", "outPlaceName", " outFileType", "outfileInfo", "outFieldName", " outPlaceName", " outPlaceSize", "outPlaceType", "OutFileLength", "outPlacename", "outDirLine", "outDirKey", "outFullPath", "outFolderAddress", "OutFilePath", "inFileName", "inLineLine", "outFolderSystem", "outPlacePath", "outDirPath", "outFileAddress", " outFileLocation", " outPlaceType", "outFileSystem", "inFilePart", "outFullName", "outLineLine"], "outPathAndName": ["outPathANDPath", "outNameOrAddress", "outPathOrRam", "outpathAndTime", "outNameOrName", "outpathOrPath", "outPathANDRam", "outNameOrPath", "outPathandNames", "outPathANDNames", "outPathOrPath", "outNameOrRam", "outpathOrNames", "outPathANDAddress", "outpathAndname", "outPathOrname", "outPathOrTime", "outNameAndRam", "outpathAndName", "outPathANDTime", "outNameAndPath", "outNameAndAddress", "outPathandPath", "outPathOrNames", "outPathOrAddress", "outPathAndPath", "outPathandName", "outPathAndRam", "outPathAndname", "outpathAndNames", "outpathAndPath", "outPathAndNames", "outPathOrName", "outNameAndName", "outPathAndAddress", "outPathAndTime", "outPathANDname", "outPathANDName", "outpathOrName"], "uploadedFile": ["uploadenedFile", "UploadpedFiles", "uploadendedPath", "uploadatedFiles", "UploadedImage", "uploadedImage", "uploadizedImage", "uploadedFull", "uploadededFull", "uploadchedF", "processedF", "uploadedF", "processedPath", "UploadedFolder", "uploadizedFull", "uploadenedFiles", "processchedF", "uploadedfile", "UploadedFull", "UploadpedImage", "uploadendedF", "uploadedFolder", "uploadratedfile", "uploadededImage", "processchedPath", "uploadratedPath", "UploadpedFull", "uploadchedFile", "processedfile", "uploadatedfile", "uploadpedfile", "uploadratedFile", "uploadchedPath", "uploadedPath", "UploadpedFile", "uploadatedFolder", "UploadpedFolder", "processedFile", "UploadedFile", "uploadpedFull", "processchedfile", "Uploadpedfile", "uploadendedfile", "uploadizedFiles", "processchedFile", "uploadedFiles", "uploadpedFile", "uploadenedfile", "uploadatedFile", "uploadededFiles", "uploadededFile", "uploadizedFile", "uploadratedF", "uploadpedFolder", "Uploadedfile", "uploadpedImage", "uploadendedFile", "uploadchedfile", "uploadpedFiles", "UploadedFiles", "uploadenedFolder"], "outStream": ["_", "tempFile", "URL", "format", "outFile", " outFile", "Url", "tempSteam", "inFile", "inSteam", "Type", "Bytes", "Directory", "tempBuffer", "New", "inBuffer", " outBuffer", "outSteam", "tempStream", "Copy", "s", " outSteam", "url", "outBuffer"]}}
{"id1": "5744493", "id2": "10451698", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": [" doBlockCopy", "newBlockWrite", " doBlockcopy", "newBlockProxy", " doFilecopy", " doFileProxy", "newFilecopy", " doFolderWrite", " doFileCopy", " dofileWrite", " dofileProxy", " doBlockProxy", "newBlockcopy", " doFolderProxy", " dofilecopy", " doFolderCopy", "newFileWrite", " doFileWrite", " doBlockWrite", " dofileCopy", " doFoldercopy", "newFileCopy", "newFileProxy", "newBlockCopy"], "in": ["image", "err", "index", "base", "login", "config", "inner", "inn", "input", "In", "bin", "b", "c", "pin", "IN", "buffer", "again", "query", "source", "part", "diff", "min", "ins", "name", "id", "file", "data", "isin", "lock", "ex", "i", "win", "reader", "m", "inc", "url", "lin"], "out": ["image", "base", "o", "temp", "resource", "prefix", "point", "pre", "write", "plain", "target", "cache", "output", "OUT", "b", "conn", "writer", "page", "string", "external", "buffer", "again", "outs", "part", "io", "v", "Out", "off", "name", "ext", "server", "user", "file", "ex", "dot", "default", "connection", "source", "exec", "socket", "copy"], "inChannel": ["outchannel", "inchannel", "binChan", "inputSocket", "INClient", "inChan", "inStream", " inchannel", "inputStream", "InChan", "binChannel", "INStream", "inputChannel", "inClient", "INSocket", "outClient", "binSocket", " inChan", "outChan", "inputChan", "INchannel", "InSocket", " inStream", "outStream", "outSocket", " inClient", "Inchannel", "InStream", "INChan", "InChannel", "INChannel", " inSocket", "inSocket", "binStream"], "outChannel": ["inContainer", "againChannel", " outStream", "outchannel", "inchannel", "inChan", "inStream", " outchannel", "intchannel", "OutStream", "intChannel", "outButton", "inButton", " outSocket", "outChan", "inBuffer", " outBuffer", "outContainer", " outChan", "outStream", "outSocket", "OutBuffer", "OutChannel", "againChan", "againSocket", "OutContainer", "againStream", "intButton", " outContainer", "intChan", "inSocket", "OutChan", " outButton", "outBuffer"], "maxCount": [" maxSize", "MaxSum", "MaxSize", " maxLength", "maxSum", "axCount", "MaxLength", "blockCount", "axcount", "axLength", "maxSize", " maxSum", " maxcount", "blockcount", "maxLength", "Maxcount", "maxcount", "MaxCount", "blockSum", "blockSize", "axSize"], "size": ["ize", "unit", "fee", "shape", "send", "end", "offset", "capacity", "flush", "available", "mode", "count", "bytes", "speed", "cap", "scale", "position", "shift", "p", "en", "type", "sized", "width", "len", "min", "small", "length", "start", "SIZE", "name", "sum", "volume", "data", "range", "transfer", "Size", "limit", "empty", "n", "seek", "time", "loc", "max", "address"], "pos": ["unit", "index", "base", "o", "slot", "offset", "pt", "point", "val", "po", " position", "open", "ref", "count", "slice", "POS", "position", "spec", "pass", "push", "pid", "p", "part", "rel", "Pos", "pointer", "os", "len", "diff", "min", "block", "length", "cos", "start", "off", "neg", "id", "data", "port", "limit", "no", "i", "pose", "iter", "loc", "obj", "address"]}}
{"id1": "3330944", "id2": "3187685", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"extractImage": ["extressImage", "extrateFile", "compressFile", "extressText", "extvertLayer", "compractText", "extressLayer", "extrateImage", "extvertFile", "compressImage", "compressText", "extvertText", "compractLayer", "extvertImage", "extractLayer", "extrateLayer", "compractFile", "extrateText", "extractFile", "compressLayer", "extractText", "extressFile", "compractImage"], "input": ["ini", "image", "base", "SOURCE", "raw", "API", "temp", "prefix", "view", "ink", "current", "inner", "dc", "inf", "form", "audio", "Input", "In", "picture", "text", "standard", "src", "OUT", "media", "bin", "string", "null", "IN", "amp", "rc", "path", "work", "DATA", "type", "sin", "out", "img", "pull", "command", "xml", "tmp", "init", "request", "inside", "PUT", "data", "file", "include", "RAW", "id", "qa", "empty", "i", "reader", "config", "source", "parent", "url", "inc", "address"], "output": ["image", "unit", "generated", "resource", "temp", "prefix", "current", "format", "write", "target", "version", "text", "message", "filename", "password", "page", "string", "exit", "external", "path", "result", "out", "response", "secret", "dir", "name", "Output", "file", "document", "STDOUT", "config", "source", "parent", "address"], "params": ["lc", "resources", "pins", "batch", "base", "options", "Par", "vs", "json", "py", "param", "mm", "plugins", "services", "details", "http", "rules", "mos", "lis", "ams", "properties", "api", "styles", "par", "lp", "pi", "dis", "spec", "ps", "photos", "phrase", "settings", "Parameters", "p", "si", "fps", "proc", "ras", "attr", "pixel", "parts", "xml", "manager", "models", "bis", "features", "phys", "las", "server", "data", "Param", "s", "names", "theme", "reader", "i", "results", "afi", "pro", "ctx", "words", "config", "conf", "obj", "processor"], "w": ["aw", "wb", "wave", "temp", "wl", "write", "worker", "fw", "wic", "widget", "wh", "writer", "ow", "wd", "ws", "we", "W", "wt", "wp", "wa", "wx", "work", "p", "nw", "out", "xml", "wm", "kw", "world", "wi", "war", "hw", "reader", "rw", "pipe", "sw", "wal", "wcs", "m", "web", "f"], "in": ["ini", "image", "kin", "err", "index", "login", "temp", "config", "fa", "gin", "inn", "arin", "cli", "cgi", "In", "src", "bin", "b", "conn", "null", "pin", "IN", "r", "again", "ani", "p", "source", "nin", "part", "cin", "min", "out", "img", "ai", "ins", "lin", "init", "ssl", "inas", "inside", "ac", "thin", "con", "data", "file", "rin", "include", "binary", "id", "qa", "isin", "mc", "ex", "i", "win", "vin", "n", "connection", "m", "din", "f", "socket", "inc"], "dest": ["coord", "folder", "de", "die", "wb", "resource", "temp", "cont", "done", "default", "dc", "dat", " Dest", "beta", "target", "src", "remote", "wd", "sup", "home", "comb", "txt", "style", "null", "exit", "nam", "dis", "dist", "route", "dom", "path", "d", "st", "gui", "doc", "source", "flat", "decl", "img", "rest", "destroy", "dir", "prop", "tmp", "name", "test", "Dest", "loc", "dep", "id", "parent", "desc", "delete", "di", "config", "din", "project"], "bi": ["ini", "ib", "Bi", "nb", "bank", "bm", "chi", "ga", "umi", "isi", "ba", "fa", "phi", "dat", "cli", "oci", "bid", "ii", "fi", "mini", "cu", "bas", "mu", "b", "bin", "bh", "info", "pi", "gb", "BI", "pin", "gi", "abi", "li", "ci", "si", "ni", "sb", "xi", "eni", " bio", "ji", "ai", "agi", "wei", "bis", "ori", "qi", "wi", "bs", "ti", "vi", "i", "bc", "di", "ki", "obi", "oi", "zi"], "os": ["ou", "o", "des", "vs", "ops", "osi", "bos", "dos", "ns", "ws", "pos", "so", "xs", "obs", "ors", "outs", "ds", "io", "Os", "cs", "oss", "nos", "out", "fs", "is", "cos", "oes", "as", "es", "oS", "us", "co", "bs", "oa", " bos", "oses", "ot", "ob", "OS", "ios", "i", "oos", "ks", "fits", "los", "aos", "s"]}}
{"id1": "530882", "id2": "7545002", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static String POST(String url, String[][] props) throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        for (int i = 0; i < props.length; ++i) {\n            conn.addRequestProperty(props[i][0], props[i][1]);\n        }\n        conn.connect();\n        try {\n            return new String((byte[]) conn.getContent());\n        } finally {\n            conn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndrewrites", "readAndRebwrite", "readandrewrite", "readAndSwwrite", "readAndRewwrite", "readAndSwrap", "readAndSwrite", "readandRewrite", "readAndrewrap", "readAndRewrap", "readAndRebrites", "readandrewwrite", "readAndRebrap", "readandRewrap", "readandRewrites", "readAndSwrites", "readandrewrites", "readAndrewrite", "readAndrewwrite", "readAndRebrite", "readandRewwrite", "readAndRewrites", "readandrewrap"], "inFile": ["inFilename", "loginFile", "outFilename", "inputfile", "InFiles", "InFile", " inFiles", "oldFile", "loginFilename", " inSourceFile", "outSourceFile", "InSourceFile", "inputFiles", "outFiles", "oldFiles", " inFilename", "loginFiles", "inputFile", "inSourceFile", "loginfile", "outfile", " infile", "inputFilename", "inFiles", "oldfile", "infile", "oldFilename", "Infile"], "outFile": [" outStream", "offPlace", "outFilename", " outDir", "outputPlace", "outFILE", "OutStream", "outputFilename", "newDir", " outfile", "thisFILE", "outputFile", "offFile", "outDir", "processFilename", "exfile", "exFILE", "newfile", "processPlace", "thisFile", "processFILE", "thisfile", "offFilename", "thisFilename", "outStream", "outPlace", "newFile", "exFile", "exFilename", "outfile", "outputfile", "OutFile", "outputFILE", "OutDir", "offFILE", "processFile", "newStream", "Outfile"], "iis": ["iniis", "Iiss", "iiIs", "iiIS", " iIS", " iIs", "iIs", "iniiss", "ciiss", "ciis", "Iis", "Iais", " iris", "IIS", "ciais", "ciIs", "iiss", "ciris", "iniIS", "iniIs", "iiris", "iiis", "iiiss", "ciIS", "iniris", "iais", " iiss", "iris", "iIS", " iais"], "dcmParser": ["dcmHelper", "dpmarser", "dmcPar", "dmoduleJar", "dmcJar", "dcmPar", "dbmPolicy", "dCMPlugin", "dmoduleParser", "dcmJar", "fcmHandler", "dcrPar", "fpmParser", "dmcarser", "dpmparser", "dbmHelper", "dmissionReader", "dpmLoader", " dpmLoader", "dcrReader", "dbmPlugin", "dCMParser", "dmoduleparser", "dpmPolicy", " dcrParser", "dmPlugin", "dkmHelper", "DcmInstallation", "dmmParser", "dcmparser", " dpmPolicy", " dcmPlugin", "dcmLoader", " dpmHelper", "dmLoader", "dhemReader", "dcmarser", "dpmHelper", "dbmParser", "fpmHandler", "dpmHandler", "dhemParser", "dcrJar", "dpmJar", " dcmLanguage", "fcmParser", "dcrarser", "dcmPolicy", "dkmParser", "dpmInstallation", " dpmJar", "dmodulePlugin", "dmmparser", "dcmLanguage", "dhemInstallation", "dcmInstallation", "fpmparser", "dpmParser", " dpmparser", " dcmPar", "dcmHandler", "dcrPlugin", "dmcParser", " dcmparser", "dcmReader", " dcrReader", "fcmReader", "DcmReader", " dpmPlugin", "dCMparser", "dpmLanguage", " dpmReader", "dmParser", "dmoduleReader", "dmissionPlugin", "dhemJar", " dpmPar", " dcrLoader", "dpmPar", "fpmReader", "dcrParser", "DcmJar", "dmissionParser", " dcmReader", "dCMHandler", "dpmPlugin", " dpmarser", " dpmLanguage", "dmmPlugin", " dcmarser", "dkmPolicy", " dcmHelper", " dcmLoader", "fcmparser", "dpmReader", " dpmParser", "dmReader", " dcmJar", " dcrPlugin", "dCMReader", "dmmLoader", "DcmParser", " dcmPolicy", "dkmPlugin", "dcmPlugin", "dCMLoader", "dcrLoader", "dmissionLanguage"], "ds": ["dd", "dr", "vals", "des", "ants", "os", "vs", "dc", "amps", "dat", "utils", "DS", "ls", "services", "details", "Ds", "ads", "src", "ns", "points", "sync", "ld", "conn", "js", "ws", "da", "ts", "ays", "cdn", "xs", "ps", "session", "d", "ils", "Db", "dt", "ros", "Os", "tes", "cs", "df", "uds", "dds", "ras", "eps", "gd", "ins", "iss", "qs", "is", "rs", "ys", "gs", "icks", "nas", "bs", "data", "sys", "pd", "ss", "tx", "ks", "di", "asi", "db", "parts", "drivers", "s"], "pdReader": ["ddRunner", "hdWriter", "hdLoader", "xdRead", "hdStream", "pcLoader", "pdStream", "pbLoader", "dsLoader", "pbReader", "ddLoader", "pcRead", "ddReader", "pdreader", "xdWriter", "hdReader", "hdRunner", "hdreader", "pbRunner", "ddStream", "pcWriter", "dsreader", "pdLoader", "pbStream", "dsReader", "xdReader", "hdRead", "pdRead", "pcReader", "dsRead", "xdreader", "pdRunner", "dsWriter"], "out": ["flow", "her", "model", "temp", "group", "list", "full", "page", "null", "again", "result", "img", "layer", "name", "file", "lib", "connection", "parent", "s", "device", "in", "o", "login", "outer", "child", "point", "to", "write", "cli", "over", "cache", "sync", "output", "OUT", "password", "conn", "auto", "builder", "code", "session", "pass", "outs", "doc", "io", "Out", "co", "sys", "user", "down", "copy", "err", "base", "inner", " in", "at", "exp", "later", "object", "array", "external", "line", "diff", "client", "ssl", "term", "ext", "data", "gen", "lock", "ex", "default", "inc", "db", "exec", "obj", "image", "dev", "w", "order", "with", "net", "up", "key", "writer", "store", "oder", "part", "director", "manager", "as", "word", "dot", "url"], "dcmEncParam": ["dcmEnParam", "dcmArchArg", "dcmEnPar", "dcmEnArg", "dcmDecParam", "dcmDecType", "dcmDecArg", "dcmElType", "dcmArchParameter", "dcmEncArg", "dcmEnPart", "dcmElPar", "dcmArchParam", "dcmEncType", "dcmSecParam", "dcmEnType", "dcmDecPar", "dcmEstParameter", "dcmDecParameter", "dcmEncPart", "dcmEncParameter", "dcmEstPar", "dcmEncPar", "dcmElParam", "dcmEnParameter", "dcmElParameter", "dcmEstParam", "dcmSecType", "dcmDecPart", "dcmSecPar", "dcmEstType", "dcmSecPart"], "pdWriter": ["htReader", "ddOutput", "htWriter", "hdWriter", "dpWriting", "htWrite", "dsOutput", "PDWrite", "PDWriter", "ddWrite", "ddReader", "hdReader", "pdOutput", "pdWrite", "dpReader", "dsWrite", "ddWriter", "PDReader", "PDWriting", "hdWrite", "dsReader", "pdWriting", "hdOutput", "dpWrite", "dpWriter", "dsWriter", "htWriting"]}}
{"id1": "13499897", "id2": "10674824", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "    @Before\n    public void setUp() throws Exception {\n        final URL url = getClass().getClassLoader().getResource(\"insecureSSL.keystore\");\n        final KeyStore keystore = KeyStore.getInstance(\"jks\");\n        final char[] pwd = \"nopassword\".toCharArray();\n        keystore.load(url.openStream(), pwd);\n        final TrustManagerFactory trustManagerFactory = createTrustManagerFactory();\n        trustManagerFactory.init(keystore);\n        final TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();\n        final KeyManagerFactory keyManagerFactory = createKeyManagerFactory();\n        keyManagerFactory.init(keystore, pwd);\n        final KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();\n        final SSLContext serverSSLContext = SSLContext.getInstance(\"TLS\");\n        serverSSLContext.init(keyManagers, trustManagers, null);\n        localServer_ = new LocalTestServer(serverSSLContext);\n        localServer_.registerDefaultHandlers();\n        localServer_.start();\n    }\n", "label": 0, "substitutes": {"CopyFile": ["CreateFolder", " CopyDir", "CopyFolder", "CreateFile", "Createfile", " copyFile", " CopyFolder", " copyDir", "CreateDir", " copyfile", "Copyfile", "CopyDir", " copyFolder", " Copyfile"], "sourcefile": ["destfilename", "configlog", "destFile", "deststream", " sourceFile", "configstream", "sinstream", "configFile", "sinFile", "sourcefilename", "Sourcefilename", "sourceFile", "SourceFile", "configfile", "sinlog", "Sourcef", "sourcestream", "Sourcefile", " sourcefilename", "sourcelog", "sinfile", "destf", " sourcef", "sourcef", "destlog"], "destfile": ["destfilename", "sourcestring", "tempFile", "destFile", "DestFile", "targetfilename", "tempfile", "buildfile", "srcfilename", "srcpath", "destroypath", "Destfilename", " desturl", "newfp", "desturl", "tempfilename", "destfp", "targeturl", "deststream", "newfilename", "Destpath", "tempstream", " deststring", "destroyfile", " destFile", "Desturl", "newfile", "buildstring", "srcstream", "deststring", "sourcefilename", "sourceFile", "targetfile", " destpath", "targetFile", "temppath", "destroystream", " destfp", "newFile", "destroyfilename", "Destfp", "srcfile", "destpath", "srcFile", "buildFile", "Destfile", "buildfilename", "targetpath", "sourcepath", " destfilename"], "last": ["nd", "right", "base", "child", "end", "depth", "offset", "latest", "current", "event", "cur", "count", "total", "key", "use", "later", "full", "cat", "after", "left", "style", "code", "from", "route", "core", "path", "next", "recent", "part", "Last", "se", "real", "prev", "first", "ending", "length", "size", "start", "range", "value", "empty", "old", "or", " Last", "max", "ast"], "parent": ["unit", "base", "child", "temp", "section", "point", "root", "fat", "current", "content", "po", "function", "patch", "target", "anc", "exp", "text", "cache", "filename", "key", "remote", "api", "post", "Parent", "home", "string", "null", "pa", "path", "next", "ant", "p", "line", "parents", "part", "pointer", "and", "dest", "mac", "ip", "name", "location", "test", "ac", "search", "data", "file", "id", "valid", "port", "shared", "partial", "loc", "source", "url", "ppa"], "f": ["folder", "j", "base", "o", "feed", "of", "found", "self", "fa", "inf", "lf", "F", "fe", "ref", "fc", "l", "b", "full", "c", "cf", "r", "g", "fd", "t", "d", "fb", "p", "v", "df", "flat", "fp", "fs", "dir", "h", "file", "af", "e", "sf", "i", "m", "s"], "srcChannel": ["srcchannel", " srcConnection", "destchannel", "rcClient", "destChannel", "rcChan", "destConnection", " srcChan", "rcchannel", "sourcechannel", "rcChannel", "srcChan", " srcchannel", "sourceChan", " srcClient", "sourceConnection", "sourceChannel", "destClient", "destChan", "srcClient", "rcConnection", "srcConnection"], "dstChannel": ["drcChannel", "idrcButton", "DstContext", "idstchannel", "DstChannel", "DestChan", "dstschannel", "destchannel", "DstChan", "drcChan", "DestContext", "dstsChan", "idstChan", "ddestContext", "dstButton", "DstBuffer", "destChannel", "dstBuffer", "Dstchannel", "dntChan", "ddestBuffer", "DestBuffer", "idrcChan", "idrcChannel", "dntBuffer", "dstchannel", "destBuffer", "dstsChannel", "drcButton", "idrcchannel", "destContext", "idstChannel", "dsrcChan", "dntContext", "dstChan", "ddestChannel", "destButton", "idstButton", "ddestChan", "drcchannel", "dsrcChannel", "destChan", "dsrcButton", "dsrcchannel", "Destchannel", "DestChannel", "dstContext", "dntChannel"]}}
{"id1": "8973505", "id2": "8667872", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 0, "substitutes": {"writeFileType": ["createFileTypes", "writeFileHeader", "writeFILEType", "createFilestype", "writeFileTypes", "writeFilesHeader", "writePageType", "writeFilesTypes", "writeFILEHeader", "writeFILEtype", "writeFiletype", "writeFilesType", "createFileHeader", "writeFILETypes", "createFileType", "createFiletype", "createFilesHeader", "writeFilestype", "writePageHeader", "createFilesType", "createFilesTypes", "writePagetype", "writePageTypes"], "uriFile": ["riFile", "URIfile", "URIUrl", "filenamefile", "uiFiles", "rifile", "URIFile", "filenameFilename", "URIFilename", "uiUrl", "filenameFiles", "filenameFile", "urifile", "riFiles", "riUrl", "riFilename", "uriUrl", "uifile", "URIFiles", "uiFile", "uriFiles", "uriFilename"], "outputfile": [" outputFile", "resourcefiles", "resourcefilename", "Outputfull", "inputfull", "unitstring", "resourcefile", "unitfile", " outputfull", "OutputFile", "inputfile", "outputfilename", "inputfilename", " outputdir", "unitfilename", "outputdir", "outputfull", "outputfiles", "inputFile", "Outputfile", "inputdir", "outputstring", "unitfiles", "inputfiles", "inputstring", "resourcestring", "Outputdir", "outputFile"], "num": ["coord", "index", "nb", "Num", "dim", "unit", "offset", "umi", "common", "master", "count", "nam", "initial", "split", "multi", "NUM", "len", "number", "loop", "length", "nu", "name", "term", "mult", "sum", "col", "con", "span", "limit", "no", "zero", "amount", "n", "batch", "inc"], "writer": ["unit", "temp", "walker", "wl", "format", "window", "journal", "page", "null", "element", "width", "layer", "xml", "report", "per", "source", "editor", "service", "wave", "outer", "write", "function", "wan", "ler", "output", "style", "driver", "builder", "engine", "r", "session", "wr", "handler", "writers", "io", "loader", "server", "document", "writ", "book", "header", "method", "written", "office", "inner", "entry", "worker", "master", "later", "object", "ws", "we", "wt", "external", "creator", "wa", "er", "type", "wire", "out", "riter", "Writer", "data", "lock", "rw", "socket", "ee", "writing", "wb", "index", "feed", "root", "w", "message", "widget", "key", "buffer", "author", "part", "manager", "wrapper", "e"], "uri": ["unit", "resource", "nor", " URI", "filename", "href", "ui", "ri", "element", "collection", "query", "multi", "doi", "context", "verb", "component", "file", "binary", "username", "theme", "connection", "source", "directory", "origin", "folder", "ilo", "umi", "cli", "string", "pi", "gi", "token", "handler", "uni", "URI", "du", "id", "reference", "document", "database", "plugin", "mi", "base", "prefix", "iri", "direction", "remote", "uid", "node", "attribute", "oid", "eni", "nil", "term", "di", "wiki", "location", "address", "link", "course", "sequence", "metadata", "hub", "picture", "http", "message", "route", "li", "winner", "ori", "qi", "range", "i", "feature"], "counter": ["lc", "index", "batch", "repeat", "ver", "outer", "offset", "continue", "current", "coll", "step", "inner", "sequence", "meter", "entry", "inter", "worker", "master", "count", "parser", "info", "race", "page", "clock", "condition", "collection", "creator", "vector", "computer", "handler", "hello", "Counter", "record", "pointer", "result", "currency", "number", "nr", "loop", "controller", "ner", "cookie", "expression", "loader", "name", "trace", "runner", "keep", "ter", "server", "reference", "instance", "comment", "second", "i", "keeper", "timer", "enter", "iter", "cpu", "time", "parent", "book", "processor"], "reader": ["in", "lr", "feed", "rx", "stream", "rer", "inner", "worker", "reading", "ler", "parser", "rar", "bird", "ir", "l", "ger", "ruby", "finder", "read", "driver", "ri", "r", "buffer", "oder", "handler", "er", "io", "rr", "row", "layer", "ner", "loader", "riter", "e", "Reader", "per", "keeper", "iter", "upper", "editor"], "url": ["link", "image", "URL", "base", "resource", "www", "feed", "stream", "download", "Url", "ls", "channel", "http", "text", "l", "page", "string", "ri", "path", "li", "io", "blog", "client", "ssl", "server", "user", "file", "id", "browser", "sl", "connection", "config", "source", "web", "plugin", "address"], "myConnection": ["someConn", "yourConn", "someConnection", "someConnect", "yourconnection", " myConn", "yourConnection", "myconnection", "yourConnector", "MyConnector", "MyConn", " myConnector", "myConnect", " myConnect", "MyConnect", "someReader", "MyReader", "MyConnection", "myConnector", "myConn", " myconnection", "Myconnection"], "myReader": ["myParser", "MyRead", "yourRead", "myWriter", " myWriter", "yourWriter", " myRead", " myParser", "MyWriter", "MyParser", "yourParser", "yourReader", "myRead", "MyReader"], "line": ["look", "link", "rule", "log", "letter", "base", "lc", "feed", "end", "liner", "point", "lf", "cl", "lines", "entry", "inline", "LINE", "parse", "text", "message", "day", "Line", "key", "use", "l", "column", "page", "style", "string", "ri", "code", "element", "pe", "pass", "note", "part", "frame", "row", "response", "le", "block", "name", "du", "word", "data", "file", "range", "id", "cell", "user", "header", "comment", "el", "no", "error", "non", "source", "lin"], "linecount": ["linelen", "letterlen", "Linesize", "lineCount", "linecache", "rowcache", "letterlength", "Linenumber", " linenumber", "rowlen", "lettercount", "linenumber", "Linecount", " linelen", "linesize", "rowlength", " lineCount", " linecache", "Lineindex", "linelength", " linelength", "lettersize", "pageCount", "pagecount", " linesize", " lineindex", "lineindex", "pageindex", "rowcount", "LineCount", "Linecache", "rowsize", "pagenumber"], "hasOWL": ["HasEWLL", "HasEWL", "hasBYDL", "hasODL", "hasEFL", "hasEWLM", "hasOWLA", "hasEWDL", "hasOULL", "hasBYLL", "HasEWLM", " hasOWl", "HasOWL", "HasOWLM", "hasODLL", "hasOWSL", "hasOWDL", "hasEWLL", " hasEWDL", "hasOULA", " hasEWLL", " hasEWLA", "hasODLM", "hasODLA", "hasOUL", "hasEFLM", " hasOWLL", "hasOWLM", " hasEWl", "hasBYL", "HasOWLL", "hasOWSl", "HasOWLA", "hasEFLA", "hasEWl", "hasEWL", "hasEWLA", " hasOWLA", " hasOWLM", "HasEWLA", " hasEWL", "hasOWLL", "hasOULM", "hasOWSLL", "hasBYl", " hasEWLM", " hasOWDL", "hasOWl", "hasEFl", "hasOWSDL", "hasODl"], "hasRDFS": ["hasCDFs", "hasRDPSU", "hasXDPU", "hasCDPs", "hasGRUFS", "hasRDPAST", "hasRdfs", "hasRDFU", "hasRFAST", "hasRNFs", "hasCDPS", "hasRTFs", "hasCDFS", "hasCDPE", "hasRFES", "hasRFs", "hasRUFs", "hasXDPE", "hasGRUFs", "hasRDFAST", "hasRDFs", "hasXDFS", "hasRTFES", "hasXDPS", "hasXDFs", "hasGRDFs", "hasRFS", "hasRdfS", "hasCDFES", "hasRDFES", "hasRNFU", "hasGRDFAST", "hasXDFE", "hasRDPs", "hasRDFE", "hasGRUFSU", "hasRDPE", "hasRDFSU", "hasRDPU", "hasRFE", "hasRNFS", "hasRNFE", "hasRUFS", "hasRFSU", "hasGRDFS", "hasRDPES", "hasCDPES", "hasRdfE", "hasRUFSU", "hasGRDFSU", "hasRDPS", "hasRTFS", "hasRUFAST", "hasRdfU", "hasCDFE", "hasRTFE", "hasXDFU", "hasXDPs", "hasGRUFAST"], "hasRDF": ["hasURFD", "hasRUF", "hasURMF", "yesDDF", "hasRRFD", "HasRDF", "HasRRDEF", "hasRRDF", "hasUOW", "HasRRDF", "hasNRFD", "hasDDF", "hasROW", "HasRDEF", "HasRRDP", " hasRMF", "hasDMF", " hasRUF", " hasRRDF", "hasMRdf", "hasRRUF", " hasRRFD", "hasMRDP", "hasRDP", "yesDOW", "yesROW", "hasRRDP", "yesRDF", " hasRFD", "hasDOW", "hasUDP", "hasRFD", "yesRDP", "hasDDP", "hasRRDEF", "hasRRMF", "hasSRDP", "hasSRDEF", "yesRMF", "hasRMF", "yesDMF", "hasSRDF", "hasNRDF", " hasRRMF", "hasRDEF", "hasMRDEF", "yesDDP", "HasRRdf", "hasNRMF", "hasSRdf", "hasNRUF", "hasUMF", "HasRDP", "hasRdf", " hasRRUF", "hasRRdf", "hasUDF", "HasRdf", "hasURUF", "hasURDF", "hasMRDF"]}}
{"id1": "10176678", "id2": "5744992", "code1": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "code2": "    public void dorequest(Map<String, String> ps, String method) throws IOException {\n        StringBuffer httpResponse = new StringBuffer();\n        URL ourl = new URL(url);\n        HttpURLConnection httpConnection = (HttpURLConnection) ourl.openConnection();\n        httpConnection.setRequestMethod(method);\n        httpConnection.setDoOutput(true);\n        this.setCookie(httpConnection);\n        OutputStream httpOutputStream = httpConnection.getOutputStream();\n        StringBuffer postParams = new StringBuffer(\"\");\n        for (Entry<String, String> entry : ps.entrySet()) {\n            postParams.append(entry.getKey());\n            postParams.append(\"=\");\n            postParams.append(entry.getValue());\n            postParams.append(\"&\");\n        }\n        httpOutputStream.write(postParams.toString().getBytes());\n        BufferedReader httpBufferedReader = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n        httpResponse.append(this.readBufferedContent(httpBufferedReader));\n        text = httpResponse.toString();\n        this.readCookie(httpConnection);\n    }\n", "label": 0, "substitutes": {"testLoadHttpGzipped": ["testLoadHttpgzipipping", "testLoadHttpgzipipped", "testLoadHttpgzipips", "testLoadHttpgzips", "testLoadHttpGozained", "testLoadHttpGozipped", "testLoadHttpGzipping", "testLoadHttpgzained", "testLoadHttpGgzipping", "testLoadHttpgzipped", "testLoadHttpGzipips", "testLoadHttpGgzained", "testLoadHttpGozipping", "testLoadHttpGzipipped", "testLoadHttpGzained", "testLoadHttpGzipained", "testLoadHttpGgzips", "testLoadHttpgzipping", "testLoadHttpGzipipping", "testLoadHttpGozips", "testLoadHttpGzips", "testLoadHttpGgzipped", "testLoadHttpgzipained"], "url": ["image", "log", "method", "URL", "base", "resource", "html", "Url", "pattern", "ls", "ref", "http", "src", "zip", "filename", "key", "l", "info", "page", "string", "class", "route", "buffer", "path", "source", "type", "uri", "response", "xml", "name", "ssl", "loc", "server", "data", "file", "id", "host", "ll", "gl", "error", "sl", "connection", "config", "location", "f", "address"], "loadingInfo": ["loadingObj", "LoadingInf", " loadingManager", "loaderinfo", "lockingManager", "LoadingInfo", "loaderInf", "loadingInf", "lockingInfo", " loadinginfo", "loaderInfo", "loadingConfig", "loadingManager", "LoadingObj", "LoadingManager", "loaderConfig", "LoadingConfig", "Loadinginfo", " loadingInf", "loadinginfo", " loadingConfig", " loadingObj", "lockingObj", "lockingInf"], "contentInputStream": ["contentReadStream", "contentInputString", "contentContentObject", "contentOutputStream", "contentContentStream", "contentByteStream", "ContentOutputString", "contentInputSteam", "ContentInputSteam", "ContentOutputstream", "contentReadstream", "contentOutputString", "contentContentSteam", "contentByteSteam", "contentContentstream", "contentReadString", "contentInputstream", "contentOutputstream", "contentImportSteam", "contentOutputObject", "ContentInputStream", "ContentInputstream", "contentBytestream", "contentImportstream", "contentImportStream", "contentOutputSteam", "ContentInputString", "ContentOutputStream", "ContentOutputSteam", "ContentInputObject", "ContentOutputObject", "contentInputObject", "contentByteString", "contentImportObject", "contentReadSteam"], "actual": ["reported", "older", "found", "current", "event", "content", "truth", "wrong", " Actual", "existing", "als", "pect", "events", "including", "example", "array", "future", "act", "initial", "average", "handled", "affected", "original", "real", "evaluate", "ual", "acceptable", "response", "anticipated", "length", "ception", "actually", "received", "former", "valid", "pects", "fake", "successful", "covered", "failed"], "expected": ["nexpected", " unexpected", "reported", "seen", " expect", "found", "wrong", "always", "pect", "info", "required", "driver", "example", " expecting", "updated", "future", "handled", "original", "real", "allowed", "acceptable", "anticipated", "length", "size", "defined", "ception", "pected", "received", "usual", "data", "needed", "error", "fake", "failed", "cover"]}}
{"id1": "4686922", "id2": "9109613", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourceAsFile", "extractResourcesAsFile", "extractResourcesToFiles", "extractResourcesAsfile", "extractResourceInFile", "extractResourcesAsResource", "extractResourceInResource", "extractResourceAndFiles", "extractResourcesToResource", "extractResourceToResource", "extractResourceInFiles", "extractResourceAsResource", "extractResourcesTofile", "extractResourcesToFile", "extractResourceAndResource", "extractResourceAsFiles", "extractResourcesAsFiles", "extractResourceAndfile", "extractResourceAsfile", "extractResourceAndFile", "extractResourceTofile", "extractResourceInfile", "extractResourceToFiles"], "resourcePath": ["stringPath", "sourceUrl", " resourceFolder", "resourcepath", "stringpath", "stringFolder", "ResourceId", "ResourceUrl", "sourcePath", " resourcepath", "ResourcePath", "sourceId", "servicePath", "Resourcepath", " resourceId", "servicepath", "resourceUrl", "resourceFolder", " resourceUrl", "serviceFolder", "resourceId", "sourcepath"], "dest": ["resources", "folder", "wb", "die", " destination", "resource", "de", "temp", "config", "done", "content", " Dest", "trans", "target", "src", "filename", "output", "later", "sup", "home", "comb", "txt", "class", "contract", "dist", "store", "route", "path", "result", "flat", "prop", "img", "sac", "tmp", "Dest", "data", "file", "const", "transfer", "desc", "default", "destroy", "source", "project"], "in": ["ini", "re", "image", "kin", "resource", "login", "this", "gin", "inner", "inn", "arin", "input", "In", "up", "rec", "bin", "b", "conn", "url", "c", "r", "IN", "again", "pass", "plus", "source", "nin", "cin", "sin", "ins", "is", "as", "lin", "init", "inside", "thin", "con", "id", "file", "rin", "isin", "i", "win", "reader", "n", "connection", "like", "din", "f", "socket", "inc"], "out": ["err", "image", "o", "temp", "outer", "this", "outside", "w", "In", "net", "at", "up", "cache", "sync", "output", "OUT", "bin", "conn", "b", "writer", "auto", "null", "again", "norm", "outs", "boot", "source", "io", "all", "Out", "client", "ins", "cookie", "cos", "off", "app", "socket", "ext", "a", "co", "server", "user", "file", "ax", "parent", "ex", "i", "one", "n", "lib", "inc", "exec", "f", "obj", "copy", "s"]}}
{"id1": "13362846", "id2": "16142024", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"setContenu": ["setContonenuer", "setContonenuit", "setContonenu", "setContenuit", "setContineuit", "setTenues", "setContenues", "setTonenues", "setContennu", "setContonenues", "setTenuer", "setContineuer", "setTonenuit", "setTonenuer", "setTenu", "setTenuit", "setContenuer", "setContennuit", "setContineues", "setTonenu", "setContennuer", "setContineu", "setContennues"], "contenuFichier": ["contenuFrenchier", "contenuFicheieri", "contenuPrefichier", "contenuFactoryiere", "contenuFicheer", "contenuPrefichiere", "contenuMichiere", "contenuFocher", "contenuMichier", "contenuMaffiere", "contenuFochique", "contenuFicher", "contenuFichtique", "contenuFchery", "contenuFicheery", "contenuFochiers", "contenuFicheerer", "contenuFaffique", "contenuFrenchiers", "contenuFichtiere", "contenuFochiere", "contenuFichtier", "contenuFaffiers", "contenuPFichiere", "contenuFichie", "contenuFchier", "contenuFochier", "contenuFrenchiere", "contenuMichiers", "contenuTicherer", "contenuFrencherer", "contenuMrenchique", "contenuFrenchery", "contenuPrefaffiere", "contenuPrefichiers", "contenuFichtie", "contenuMichieri", "contenuFrenchoyer", "contenuPhactoryie", "contenuMichie", "contenuFochie", "contenuFichiere", "contenuFactoryoyer", "contenuPrefaffier", "contenuMrenchie", "contenuFcherer", "contenuPrefaffiers", "contenuMichique", "contenuTicheery", "contenuFichoyer", "contenuPFochier", "contenuFichtieri", "contenuFactoryier", "contenuPrefichie", "contenuMrenchier", "contenuPhichoyer", "contenuPhactoryier", "contenuPhactoryoyer", "contenuFichieri", "contenuTicheier", "contenuFicheiere", "contenuTicheerer", "contenuPFochique", "contenuPFocher", "contenuFichique", "contenuMrenchiere", "contenuMaffieri", "contenuFaffiere", "contenuPrefaffie", "contenuFicier", "contenuFicherer", "contenuPhichie", "contenuPhichier", "contenuTicheiere", "contenuTichery", "contenuMaffie", "contenuFchiere", "contenuFactoryie", "contenuPFochiere", "contenuFichery", "contenuFrenchie", "contenuPhichiere", "contenuFichiers", "contenuFaffier", "contenuFicheie", "contenuFrenchique", "contenuMaffier", "contenuPFichier", "contenuFicheique", "contenuFaffie", "contenuFiciere", "contenuFicoyer", "contenuPFichique", "contenuFicheier", "contenuTichier", "contenuTichiere", "contenuFicie", "contenuMaffiers", "contenuFaffer", "contenuPFicher", "contenuPhactoryiere", "contenuFaffieri"], "fichierElectronique": ["fichierAdministronistic", "fichierElectronie", "fichierElectronsique", "fichierElectpronique", "fichierElectornier", "fichierAustroliques", "fichierElectronica", "fichierAdministronsical", "fichierElectroliere", "fichierElectronsica", "fichierElectolonique", "fichierElectonique", "fichierElectrons\u00e9e", "fichierElectolonica", "fichierAustroniere", "fichierElectromiques", "fichierElectroliques", "fichierAdministronlique", "fichierElectronsiques", "fichierAustroniques", "fichierElectoloniere", "fichierAdministronical", "fichierAdministronsier", "fichierElectaronique", "fichierElectroniques", "fichierElectromistic", "fichierAustroliere", "fichierElectaron\u00e9e", "fichierElectroniere", "fichierElectrolique", "fichierElectronical", "fichierElectproniques", "fichierElectrolica", "fichierElectroneiques", "fichierAustronique", "fichierAustrolique", "fichierElectromique", "fichierElectpronical", "fichierCentornier", "fichierElectronelique", "fichierAdministronsistic", "fichierCentronlique", "fichierElectron\u00e9e", "fichierElectronsier", "fichierElectoloniques", "fichierElectrolie", "fichierElectronslique", "fichierAdministronslique", "fichierElectrol\u00e9e", "fichierElectroneiere", "fichierElectonier", "fichierElectroneie", "fichierElectronsie", "fichierElectornique", "fichierCentorniques", "fichierElectornlique", "fichierAdministronsique", "fichierElectronsical", "fichierAustronier", "fichierCentornique", "fichierCentronier", "fichierCentroniques", "fichierAdministron\u00e9e", "fichierElectronistic", "fichierAdministronique", "fichierAdministroniques", "fichierAdministrons\u00e9e", "fichierElectroneier", "fichierAustrolier", "fichierElectronier", "fichierElectonlique", "fichierElectronlique", "fichierElectroneique", "fichierAdministronsie", "fichierAdministronier", "fichierElectaronier", "fichierElectpronistic", "fichierElectrolier", "fichierCentornlique", "fichierElectonie", "fichierCentronique", "fichierElectronsiere", "fichierElectronsistic", "fichierElectorniques", "fichierAdministronie", "fichierElectromical", "fichierAdministronsiques", "fichierElectaronie"], "utilisateurCourant": ["utilisationCourants", "utilisationCourante", "utilisateurApplicateur", "utilisateurApplicant", "utilisationApplicants", "utilisateurGovernants", "utilisateurApplicante", "utilisateurParticipante", "utilisateurParticipateur", "utilisationCourateur", "utilisateurCourants", "utilisationCourant", "utilisateurGovernante", "utilisationApplicateur", "utilisateurParticipants", "utilisateurParticipant", "utilisateurGovernant", "utilisationApplicante", "utilisateurCourateur", "utilisateurCourante", "utilisateurGovernateur", "utilisateurApplicants", "utilisationApplicant"], "support": ["force", "service", "bank", "system", "storage", "Library", "share", "format", "utils", "accept", "services", "facebook", "protection", "evidence", "media", "info", "concept", "ann", "summary", "supported", "push", "settings", "control", "friend", "allow", "supp", "pull", "client", "know", "util", "proxy", "knowledge", "best", "document", "compatible", "review", "pport", "respect", "feature", "contact", "Support", " Support", "config", "plugin", "help", "cover", "library"], "ficheDocument": ["infraudDoc", "ficheFeature", "foiceDirectory", "facheMatrix", "fetchDoc", "fcheDirectory", "FcheDoc", "fchaDocument", "enficheDocument", "fchedocument", "foineFeature", "foiceCatalog", "FicheDocument", "enficheCompany", "facheDocument", "enfoiceDirectory", "fchaContent", "foiceCompany", " fcheDirectory", "fcheDocuments", "fcheMatrix", "afficheDoc", "ficheMatrix", "fagueDirectory", "fielDocument", "inficheDocument", "afficheFeature", "foineDoc", "enficheDirectory", "fielDirectory", "ficheCatalog", "fichedocument", "fchaDoc", "frauddocument", "financeNumber", "friquedocument", "fcheDocument", "financeDoc", "friqueDocument", "fruitNumber", "fagueDocument", "foiceDocument", "affineFeature", "fineFeature", "fruitDoc", "financedocument", "fraudDoc", "fetchFeature", "ficheDirectory", "affineDocument", "ficheCompany", "FicheDoc", " fcheDocument", "financeDocument", "foinedocument", "fineDocument", "fruitDocument", "affineDoc", " fcheMatrix", "fielCatalog", "FicheContent", "fraudCompany", "fraudCatalog", "ficheDocuments", "fraudDirectory", " ficheDocuments", "Fichedocument", "ficheContent", "inficheNumber", "fetchDocument", "fcheDoc", "fetchdocument", "fraudDocument", "foineDocument", "Fchedocument", "affichedocument", "friqueDoc", " ficheDirectory", "FcheDocument", " fcheDocuments", "fraudNumber", "fruitdocument", "afficheDocument", "facheDirectory", "fchadocument", "enfoiceCompany", "infraudDocument", "enfoiceCatalog", "FcheContent", "fagueMatrix", "facheDocuments", "fineDoc", "infrauddocument", "fagueDocuments", " ficheMatrix", "ficheDoc", "enfoiceDocument", "enficheCatalog", "fcheContent", "fielCompany", "ficheNumber", "friqueContent", "inficheDoc", "infichedocument", "finedocument", "affinedocument", "infraudNumber"], "nomFichier": ["nomFochire", "nomFachrier", "nomWichiere", "nomVicher", "nomPhacherer", "nomFichieri", "nomNicher", "nomFiscer", "nomPrefchier", "nomFachire", "nomPichier", "nomFichtiner", "nomWchery", "nomFichery", "nomWchier", "nomFacher", "nomFichrier", "nomF\u00e9ty", "nomVchieri", "nomFichterer", "nomF\u00e9tery", "nomFchier", "nomWchiere", "nomFochier", "nomFachiner", "nomNichiller", "nomFicherer", "nomPrefichier", "nomVich\u00e8re", "nomFiscy", "nomFcher", "nomWichier", "nomPrefichire", "nomNichtiller", "nomFchy", "nomFachieri", "nomFisciller", "nomFiscier", "nomFichtier", "nomFithiere", "nomFachiere", "nomFchrier", "nomPichy", "nomF\u00e9tier", "nomPrefchrier", "nomFiqurier", "nomPrefchire", "nomPichery", "nomFichiner", "nomWichire", "nomPrefichieri", "nomFochiere", "nomVichieri", "nomPhichieri", "nomFrencher", "nomFrenchier", "nomPchy", "nomNichiner", "nomFichtiere", "nomF\u00e9tien", "nomPchien", "nomFich\u00e8re", "nomFisciner", "nomFchien", "nomFochery", "nomFchery", "nomPhichier", "nomPrefichrier", "nomFichtiller", "nomFithieri", "nomNichtier", "nomFch\u00e8re", "nomFiscien", "nomFchieri", "nomFichiller", "nomFichtieri", "nomFach\u00e8re", "nomFichtire", "nomPrefchieri", "nomWichery", "nomFichiere", "nomFichtery", "nomWchire", "nomFicher", "nomFiquieri", "nomPhichiere", "nomFachiller", "nomFichire", "nomFiquire", "nomFiquier", "nomFrenchieri", "nomPhachiere", "nomFitherer", "nomFichien", "nomPchery", "nomPichien", "nomNichtiner", "nomVchier", "nomFiscery", "nomPhicherer", "nomFchiere", "nomVcher", "nomFachier", "nomFichy", "nomFrench\u00e8re", "nomVch\u00e8re", "nomPhachier", "nomFchire", "nomFithier", "nomFacherer", "nomNichter", "nomPchier", "nomVichier", "nomNichier", "nomPhachieri", "nomFichter"], "extension": ["Extression", "Extime", "exion", "encension", "anchime", "EXTime", "exension", "encception", "exception", "anchensions", "encression", "Extception", "extression", "extensions", "encion", "exression", "extception", "extime", "Extension", "EXTension", "Extion", "Extensions", "anchension", "EXTensions", "extion"], "fichierElectroniqueExistant": ["fichierElectroniqueXist", "fichierElectroniqueexilingual", "fichierElectroniquesXist", "fichierElectroniqueExistance", "fichierElectroniqueExclusive", "fichierElectroniqueXists", "fichierElectroniqueXistant", "fichierElectroniqueExists", "fichierElectroniqueExilingual", "fichierElectroniqueSistant", "fichierElectroniqueXilingual", "fichierElectroniqueexistent", "fichierElectroniquesExivist", "fichierElectroniquesXistance", "fichierElectroniqueexistance", "fichierElectroniqueExistent", "fichierElectroniqueexists", "fichierElectroniquesExclusive", "fichierElectroniquesExists", "fichierElectroniqueexivist", "fichierElectroniquesXclusive", "fichierElectroniqueExplclusive", "fichierElectroniquesXists", "fichierElectroniqueXivist", "fichierElectroniqueExplistance", "fichierElectroniqueXistance", "fichierElectroniqueexist", "fichierElectroniqueExist", "fichierElectroniquesXistant", "fichierElectroniquesExilingual", "fichierElectroniqueSilingual", "fichierElectroniquesExistent", "fichierElectroniqueexistant", "fichierElectroniqueSistent", "fichierElectroniquesExistant", "fichierElectroniqueExivist", "fichierElectroniqueExplists", "fichierElectroniquesXilingual", "fichierElectroniqueSistance", "fichierElectroniqueexclusive", "fichierElectroniqueExplivist", "fichierElectroniqueXistent", "fichierElectroniqueExplist", "fichierElectroniqueExplistant", "fichierElectroniquesXistent", "fichierElectroniqueXclusive", "fichierElectroniquesExist", "fichierElectroniquesXivist", "fichierElectroniquesExistance"], "idIgid": ["idIgenid", "idIgID", "idEgid", "idIGids", "idIgids", "idIogids", "idEGids", "idIogbit", "idUguid", "idEGid", "idIgname", "idEgbit", "idIgmids", "idEgids", "idIguname", "idUguname", "idIgbit", "idIgenids", "idEgdid", "idUgids", "idIgnID", "idIogdid", "idIGid", "idIguid", "idIguids", "idIgudid", "idUgname", "idIggid", "idIgod", "idIgdid", "idIGbit", "idUgid", "idIgenname", "idIgnids", "idIgubit", "idUgID", "idIggID", "idIgnod", "idIggod", "idIgenID", "idIgnid", "idIggids", "idEGdid", "idIgmid", "idUguids", "idEGbit", "idIGdid", "idIogid", "idUguID", "idIgmname", "idIgmID", "idIguod", "idIguID"], "inputStream": ["outputstream", "eventStreamer", " inputLength", "inputstream", "InputSteam", "inputLength", "InputStreamer", "eventSteam", " inputThread", "eventstream", "outputSteam", " inputSteam", "inputSteam", "inputStreamer", "inputThread", "outputLength", "InputThread", "InputLength", "InputStream", "outputStreamer", "eventStream", " inputstream", "Inputstream", "outputThread"], "outputStream": ["outputstream", "OutputSteam", " outputSteam", "entityStream", "inputContext", "outputContext", "OutputStream", "inputstream", " outputContext", "entityStreamer", "entitystream", "officeSteam", "outputSteam", "officestream", "officeStreamer", "inputSteam", "Outputstream", "inputStreamer", "OutputContext", "OutputStreamer", " outputstream", "outputStreamer", "entitySteam", "officeStream"], "typeMime": ["typeMatimes", "TypeSmide", "typeSmide", "typeMide", "typeMatangle", "typeMetimes", "TypeSmimes", "TypeMimes", "typeMatide", "TypeSmime", "typeMatime", "typeSmime", "typeSmimes", "typeMangle", "TypeMangle", "typeMetime", "typeSmangle", "typeMetide", "TypeMime", "TypeMide", "TypeSmangle", "typeMetangle", "typeMimes"], "tailleFichier": [" tailleFignie", " tailleFichie", " taillefochie", " tailleFichiers", " tailleFicheie", " tailleFocher", " tailleFignier", " tailleFicher", " tailleFicheiers", " tailleFochie", " tailleFigniers", " taillefochiers", " tailleFigner", " tailleficher", " taillefocher", " tailleFicheer", " taillefichiers", " tailleFochiers", " tailleFochier", " taillefichie", " taillefichier", " tailleFicheier", " taillefochier"]}}
{"id1": "2642914", "id2": "12172485", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTarGsgz", "addFileToZipGgz", "addFileToZipGzi", "addFileToTarggz", "addFileToZipGzip", "addFileToZipGszi", "addFileToTarGzip", "addFileToTarGszip", "addFileToZipGsz", "addFileToTarGux", "addFileToTarGargz", "addFileToTarGarzip", "addFileToTarGarx", "addFileToTarGarzi", "addFileToTarGsz", "addFileToTarGuz", "addFileToZipGz", "addFileToZipGarx", "addFileToZipGarz", "addFileToTarGarz", "addFileToTargx", "addFileToTargzip", "addFileToTarGuzip", "addFileToTarGgz", "addFileToTarGuzi", "addFileToTargz", "addFileToZipGarzi", "addFileToZipGsgz", "addFileToTarGszi", "addFileToTargzi", "addFileToZipGarzip", "addFileToZipGszip", "addFileToTarGzi", "addFileToZipGx", "addFileToTarGx"], "taro": ["tara", "atro", "Taron", "thaco", "faco", " taco", "Tabo", "toro", "staro", " tero", " tara", "Toro", "fargo", "ptargo", "targo", "taco", "ptabo", "ptaro", "Taro", "Taco", " targo", " taron", "too", "Toran", "stamar", "Tro", "storo", "toran", "loran", "lro", "tero", "stero", "tabo", " tabo", "ptaron", "faro", " too", "Tara", "tharo", "ataro", "Tamar", "atoran", "tamar", "taron", "Targo", "laro", "Tero", "thamar", "Too", "atargo", "thoro", "stoo", "tro", "staco", "largo", "stro", " tro", "ptaco", "fara"], "path": ["image", "folder", "log", "resource", "Path", "root", "pattern", "ref", "text", "cache", "filename", "key", "object", "string", "PATH", "c", "from", "route", "p", "type", "source", "pointer", "uri", "ath", "dir", "name", "id", "file", "fn", "data", "str", "loc", "location", "parent", "url", "directory"], "base": ["index", "resource", "site", "prefix", "root", "default", "pre", "ase", "http", "cache", "bas", "back", "key", "area", "api", "b", "extra", "home", "string", "from", "store", "buffer", "core", "Base", "p", "type", "part", "uri", "dir", "start", "name", "server", "id", "file", "absolute", "bf", "relative", "parent", "url", "address"], "f": ["fo", "j", "fr", "feed", "of", "fac", "this", "fa", "self", "found", "form", "lf", "w", "inf", "F", "fen", "fe", "aff", "ref", "fc", "l", "b", "raf", "cf", "c", "r", "rf", "g", "t", "fd", "d", "fb", "p", "v", "df", "flat", "fp", "fs", "fx", "framework", "tf", "h", "fold", "file", "fn", "af", "e", "sf", "i", "n", "bf", "m", "url", "s"], "entryName": ["elementTime", "entryname", "archiveName", "fileName", " entryname", "EntryName", "fileType", "filePath", "fileTime", "elementName", "entryPath", "resourcePath", "entryType", " entryPath", "elementPath", "entryTime", "archiveSize", "EntryType", "entrySize", " entryTime", "elementType", "resourceName", "resourceSize", " entryType", "EntryPath", "archivename", "EntryTime", "archivePath", " entrySize", "resourcename"], "goIn": ["loIns", "GOIns", "goIN", "GOOut", "coIn", "coIns", "GOIn", "GOin", "loIN", "GoIn", "poIn", "gain", "poin", "loIn", "goIns", "coin", "GOIN", "gaIn", "poIN", "Goin", "poIns", "coOut", "gaIN", "loin", "gaIns", "goOut", "GoIN", "GoIns", "poOut", "goin"], "tarEntry": ["tarFile", "rarInfo", "zipInfo", " Tarentry", "zipEnt", "TarElement", " tarentry", " tarEnt", "Tarentry", "rarEntry", " tarFile", "TarEntry", "rarFile", "tarentry", "zipEntry", " TarEntry", "tarInfo", "zipFile", " tarInfo", " tarElement", " TarElement", "rarEnt", "tarElement", "tarEnt"], "children": ["iblings", "ports", "pool", "sub", "other", "packages", "feed", "current", "content", "ul", "open", "plugins", "which", "output", "blocks", "roots", "bars", "when", "files", "ools", "rows", "far", "ales", "parents", "ren", "jobs", "all", "well", "values", "opens", "ins", "members", "Children", "many", "name", "each", "pes", "h", "pages", "father", "data", "scenes", "balls", "web", "kids", "words", "loc", "parent"], "child": ["slave", "pool", "in", "feed", "root", "entry", "kid", "channel", "count", "key", "hel", "l", "ch", "shell", "page", "leaf", "code", "c", "lib", "cel", "Child", "cloud", "job", "build", "and", "row", "pull", "layer", "client", "name", "server", "data", "file", "id", "comment", "i", "per", "or", "connection", "parent", "draft"]}}
{"id1": "149935", "id2": "23335922", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 0, "substitutes": {"convert": ["oconversion", "CONversion", "oconverting", " deconverted", "CONverting", " deconvert", "conception", "CONception", " deconverting", "unverted", "subversion", "CONverted", "Conception", " deconversion", "oconvert", "unversion", "converted", "unception", "subvert", "conversion", "Convert", "unvert", "Converted", "subverted", "subverting", "converting", "oconverted", "Converting", "Conversion", "CONvert"], "src": ["video", "resource", "storage", "config", "stream", "Source", "impl", "gz", "RC", "input", "download", "feat", "req", "ref", "load", "back", "filename", "slice", "href", "cb", "prot", "url", "string", "code", "buf", "gb", "spec", "dist", "cpp", "rc", "stage", "sn", "path", "st", "sc", "cmp", "upload", "ource", "uri", "sb", "proc", "SourceFile", "sin", "img", "fp", "supp", "attr", "sit", "secure", "tmp", "name", "ssl", "Dest", "sel", "sys", "component", "file", "fn", "inst", "username", "sth", "reader", "rb", "rl", "ctx", "scene", "loc", "source", "obj", "s"], "dest": [" destination", "temp", "cont", "dc", "dat", "target", "bin", "home", "null", "txt", "class", "orig", "lib", "dist", "path", " dst", "img", "dir", "std", "tmp", "test", "Dest", "fn", "di", "source", "obj", "disk"], "in": ["ini", "err", "login", "stream", "inn", "inf", "val", "input", "In", "up", "bin", "pin", "r", "IN", "ps", "t", "pass", "d", "doc", "source", "io", "ins", "is", "as", "inas", "a", "data", "isin", "file", "ex", "i", "reader", "win", "n", "din", "f", "inc"], "p": ["np", "j", "o", "po", "pre", "py", "P", "pc", "cop", "parser", "l", "b", "jp", "pr", "bp", "lp", "pi", "pp", "sp", "pe", "c", "r", "wp", "g", "ps", "t", "pa", "d", "op", "pg", "part", "pm", "v", "fp", "pb", "h", "tp", "pd", "e", "i", "per", "cp", "m", "f", "s"], "ds": ["ths", "dp", "vals", "ls", "services", "ads", "ld", "lp", "groups", "dt", " ps", "os", "ins", "icks", "nas", "ts", "dates", "scripts", "s", "dc", "dat", "Ds", "points", "els", "sync", "tools", "ipes", "xs", "obs", "sts", "d", "ils", "dds", "hs", "gs", "docs", "sys", "pd", "dm", "ss", "dl", "des", "posts", " DS", "utils", "cons", "lines", "ns", "ges", "da", "tests", "ays", "dist", " props", "eps", "cs", "df", "uds", "gd", "qs", "ys", "data", "ded", "ks", "words", "di", "db", "parts", "dd", "ants", "vs", "amps", "ans", "DS", "dos", "plugins", "styles", "js", "ps", "rs", "ups", "models", "bs", " sd"], "format": ["letter", "model", "unit", "nat", "plugin", "prefix", "form", "function", "pattern", "at", "feat", "filter", "version", "parser", "atter", "filename", "sche", "api", "table", "Format", "struct", "style", "string", "class", "scale", "act", "spec", "t", "fd", "path", "handler", "ant", "template", "source", "type", "record", "part", "frame", "fp", "name", "language", "host", "data", "file", "layout", "fn", "magic", "config", "tag", "f", "url"], "hasPixelData": ["hasPixelStyle", "haspixeldata", "showsByteDATA", "hasByteStyle", " hasPixelSize", "hasByteDATA", "showsPixelDATA", "hasPixelDATA", "hasPictureSize", "hasPixeldata", "hasByteData", "hasPixelSize", "showsPixelData", "haspixelData", "hasPicturedata", "showsByteData", "hasByteSize", "showsByteStyle", "haspixelSize", "showsPixeldata", "showsBytedata", "showsPixelStyle", "hasBytedata", "hasPictureData", " hasPixeldata"], "inflate": ["inadequode", "infloation", "inadequATE", "InFlace", "infloace", "Inflation", "inflation", "InFlate", "Inflated", "inflode", "infolode", "insflating", "invenate", "insvenate", "infolate", "Inflate", "infolATE", "infolating", "InFlated", "insvenATE", "invenating", "inFlace", "inflace", "insflode", "invenode", "inadequating", "insvenating", "inffate", "InFlation", "insflate", "inffation", "invenATE", "infloated", "inffated", "inflating", "inFlate", "Inflace", "insflATE", "infface", "infloate", "inFlated", "inadequate", "insvenode", "inflated", "inflATE", "inFlation"], "pxlen": ["pxden", "pxdata", "mxlen", "campos", "pxln", "mxln", "pxlon", "camln", "mxcount", "pxlin", "pngsize", "xplength", "fxln", "xpsize", "pgden", "ppl", "pplen", "fxden", "pxsize", "pxcount", "fxpos", "axlin", "pclon", "ppLen", "pnglength", "txlon", "pnglen", "pxl", "mxlength", "xplen", "xpcount", "axlen", "txlin", "txln", "pxpos", "ppden", "mxdata", "pglen", "pgLen", "mxpos", "pxlength", "fxl", "pclen", "pgl", "camlen", "pclin", "camdata", "axln", "txlen", "pcln", "fxLen", "pxLen", "mxsize", "fxdata", "pngcount", "fxlen", "axlon"], "out": ["re", "err", "log", "point", "step", "cli", "inter", "up", "group", "cache", "output", "OUT", "list", "conn", "post", "page", "pad", "store", "session", "state", "again", "outs", "work", "query", "line", "io", "v", "Out", "co", "dump", "sys", "server", "user", "gen", "lock", "error", "lib", "parent", "obj", "copy"]}}
{"id1": "4223002", "id2": "17161805", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"getPasswordMD5": ["getpasswordMD5", "getpasswordSHA512", "getPasswordMD256", "getPasswordSHA5", "getpasswordSHA1", "getPasswordMac1", "getpasswordMD1", "getpasswordMD256", "getpasswordSHA5", "getPasswordMAC5", "getPasswordMD1", "getPasswordSHA512", "getPasswordMac5", "getPasswordMAC512", "getpasswordSHA256", "getPasswordMAC1", "getPasswordSHA256", "getpasswordMD512", "getPasswordMac256", "getPasswordMac512", "getPasswordMD512", "getPasswordMAC256", "getPasswordSHA1"], "algorithm": ["omalgo", "Alrator", "alignment", "fgo", "Alphabet", "algo", "aggorithm", " algorith", "alphabet", " alger", " alphabet", "fgorith", "Alest", "geest", "gem", "alger", "gegorithm", "aggo", "omalgorith", "calgo", "Algorith", "algorith", "fgebra", "alrator", "agrator", "Alignment", "alest", " alest", " algo", "algebra", "Algebra", "alm", "Alm", "geger", "calgorith", "calgebra", "fgorithm", "agignment", "omalgorithm", "Algo", "Alger", " alm", "omalphabet", " alrator", "Algorithm", " alignment", "calgorithm"], "messageDigest": ["phraseDigEST", "messageDest", "messageDigester", " messagedigEST", "phraseDigest", "messageDested", "messageDigEST", "MessageDigEST", "MessageModester", "phrasedigest", "messageModString", "messageModested", "messageDigString", "phraseDigester", "MessageDigest", "messageMDEST", " messagedigester", "phrasedigester", " messageDigester", "phraseDigested", "MessageModEST", " messagedigString", "messageMDester", "MessageDigester", "messagedigested", "phrasedigEST", "messageMDString", "MessageModest", "messageDester", "messageMDest", "messageModEST", "messagedigString", "messagedigEST", " messagedigest", "messageModester", "messagedigester", "messageDEST", " messageDigString", "MessageModested", "messageDigested", "messageModest", "phrasedigested", "messagedigest", " messageDigEST", "MessageDigested"], "hexString": ["byteString", " hexstring", "shortBuffer", "hexLine", "textLine", "hashString", "shortArray", "byteArray", "byteStream", " hexLine", "hexStr", "shortstring", "checkBuffer", "textArray", " hexStr", " hexStream", "textBuffer", "byteLine", "hexBuffer", "checkString", "hashBuffer", "shortString", "hashFunction", " hexFunction", "textstring", "textStream", " hexArray", "hexstring", "hexArray", "checkStr", " hexBuffer", "hashStr", "textString", "hexStream", "checkFunction", "hexFunction"], "i": ["mi", "index", "j", "o", "in", "oi", "chi", "end", "hi", "phi", "ii", "ix", "fi", "slice", "key", "mu", "l", "b", "info", "ui", "ri", "pi", "c", "r", "gi", "t", "abi", "d", "li", "ci", "p", "type", "multi", "si", "io", "xi", "I", "bi", "v", "x", "ai", "uri", "a", "volume", "h", "ti", "id", "e", "u", "n", "di", "m", "f", "zi", "s"]}}
{"id1": "21979717", "id2": "19784131", "code1": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static String getMD5Hash(String original) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            StringReader sr = null;\n            int crypt_byte = 0;\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(original.getBytes());\n            byte[] digest = md.digest();\n            sr = new StringReader(new String(digest, \"ISO8859_1\"));\n            while ((crypt_byte = sr.read()) != -1) {\n                String hexString = Integer.toHexString(crypt_byte);\n                if (crypt_byte < 16) {\n                    hexString = \"0\" + hexString;\n                }\n                sb.append(hexString);\n            }\n        } catch (NoSuchAlgorithmException nsae) {\n        } catch (IOException ioe) {\n        }\n        return sb.toString();\n    }\n", "label": 0, "substitutes": {"upload": ["create", "submit", "download", "open", "accept", "paste", "up", "load", "add", "process", "run", " download", " Upload", "post", " submit", "start", "Upload", "init", "Submit", "request", "archive", "execute", "transfer", "select", " transfer", "save"], "fileResult": ["fpResult", "downloadResult", "fileresult", "fileResults", "filesResults", "FileRank", "fpRank", "FileResults", "filesRes", "fileRes", " fileResults", "downloadRank", "filesResult", "downloadResults", "filesresult", " fileresult", "fpRes", "FileResult", "fileRank", " fileRes", "Fileresult", "fpResults", "downloadRes", "FileRes"], "in": ["ini", "image", "kin", "login", "inner", "gin", "inn", "arin", "input", "In", "up", "cache", "bin", "info", "conn", "c", "pin", "IN", "again", "tin", "p", "conf", "cin", "min", "ins", "into", "lin", "init", "socket", "inside", "data", "file", "on", "rin", "isin", "i", "win", "vin", "source", "f", "inc"], "url": ["image", "log", "URL", "www", "impl", "coll", "ul", "cl", "Url", "ls", "channel", "http", "l", "b", "conn", "api", "c", "bel", "path", "pl", "fl", "org", "uri", "pull", "client", "ur", "socket", "ssl", "server", "file", "gl", "ob", "sl", "connection", "host", "web", "f", "address"], "con": ["re", "ver", "log", "conv", "login", "sub", "func", "can", "fa", "syn", "fun", "cl", "cons", "plain", "open", "pc", "cur", "pen", "ctrl", "http", "ca", " conn", "fc", "run", "sync", "remote", "ch", "conn", "un", "CON", "ran", "c", "cf", "pin", "rc", "rou", "en", "part", "min", "client", "Con", "close", "cm", "ssl", "socket", "request", "co", "ec", "cn", "on", "ocon", "gen", "connect", "Conn", "per", "non", "bc", "cp", "connection", "uc", "exec", "conf"], "out": ["image", "err", "base", "pool", "o", "outer", "login", "can", "resource", "this", "input", "at", "obj", "cache", "output", "OUT", "bin", "conn", "b", "object", "ch", "c", "external", "again", "outs", "line", "io", "v", "Out", "client", "as", "ssl", "server", "on", "file", "ex", "win", "connection", "inc", "parent", "conf", "socket", "copy"], "in2": ["IN2", "IN4", " in1", "InTwo", "out4", "outtwo", "in02", "in4", "err1", "In1", "In4", " inTwo", "intwo", "In2", "errTwo", "errtwo", "out1", "err2", " in02", "input2", "in1", " in4", " intwo", "input4", "inTwo", "input02", "inputTwo", "INTwo", "out2", "outTwo", "IN02"], "buf": ["dec", "base", "box", "pool", "vec", "done", "ba", "av", "ff", "feat", "text", "bag", "uf", "b", "bytes", "cb", "bin", "cat", "cap", "home", "utf", "fab", "font", "buff", "cf", "buffer", "rc", "fd", "fb", "lb", "db", "bd", "bf", "seq", "Buff", "block", "cas", "la", "ha", "data", "cv", "rb", "bc", "bh", "batch", "br", "uc", "Buffer"], "bytesRead": ["byteWrite", "bytesread", " bytesUse", "rowsUse", "BytesLength", "bytesUse", "rowsread", " bytesLoad", "BytesRead", "rowsWrite", "rowsRead", "blocksRead", " bytesLength", "linesRead", "tesWrite", "tesRead", "byteLength", " bytesWritten", "BytesWrite", "linesWrite", "byteRead", " bytesWrite", "tesRun", "blocksUse", " bytesRun", "blocksWrite", "byteLoad", "linesRun", "bytesWrite", "bytesWritten", "bytesLength", "bytesRun", "linesWritten", "bytesLoad", "blocksread", "BytesLoad", " bytesread", "tesWritten"]}}
{"id1": "4562786", "id2": "3767903", "code1": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"GetResponse": ["ReadReply", "Readresponse", "CheckReply", "CheckResult", "GetResult", " GetResult", " Getresponse", "Checkresponse", "CheckResponse", " GetReply", "GetReply", "ReadResponse", "Getresponse", "ReadResult"], "url": ["image", "URL", "service", "resource", "base", "coll", "Url", "http", "l", "api", "object", "page", "string", "c", "path", "org", "uri", "build", "client", "il", "ur", "ssl", "proxy", "loc", "server", "user", "file", "gl", "ob", "u", "sl", "str", "rl", "el", "or", "connection", "config", "host", "web", "f", "address"], "content": ["body", "err", "method", "lc", "resource", "Content", "section", "temp", "feed", "cont", "raw", "continue", "json", "load", "message", "text", "output", "full", "page", "left", "string", "code", "status", "c", "array", "job", "result", "cover", " Content", "response", "report", "name", "clean", "fully", "request", "data", "value", "description", "comment", "empty", "results", "res", "complete", "connection", "source", "header", "address"], "conn": ["enc", "conv", "nt", "coll", "dc", "cli", "nc", "open", "cur", "rt", "Connection", "http", "ca", "exec", "sync", "ch", "cb", "cat", "ann", "act", "c", "cf", "cr", "ct", "g", "rc", "ci", "p", "en", "cmp", "org", "client", "cc", "pub", "auth", "comm", "close", "init", "ssl", "col", "co", "con", "h", "cn", "loc", "ec", "oa", "connect", "adj", "Conn", "n", "ctx", "cp", "connection", "config", "db"], "br": ["err", "dr", "fr", "coll", "bl", "arr", "src", "ler", "yr", "bridge", "ch", "bb", "b", "cb", "pr", "ctr", "buf", "r", "ber", "gr", "tr", "bro", "bd", "div", "result", "Br", "BR", "mr", "ner", "hr", "bar", "sr", "data", "browser", "str", "reader", "rb", "bc", "bh", "ar", "cr", "obj"], "line": ["body", "letter", "link", "err", "lc", "fr", "feed", "section", "lf", "cl", "lines", "entry", "inline", "LINE", "text", "message", "Line", "key", "l", "page", "string", "code", "c", "r", "pass", "part", "result", "record", "number", "response", "row", "le", "character", "ip", "name", "word", "data", "file", "include", "cell", "e", "char", "str", "comment", "reader", "i", "sl", "source", "cr", "f", "lin"]}}
{"id1": "20623709", "id2": "62362", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"split": ["share", "format", "open", "match", "parse", "add", "process", "run", "sync", "update", "set", "sort", "join", "part", "cmp", "build", "diff", "Split", "start", "init", "archive", "transfer", "delete", "execute", "exec", "append", "copy"], "targetDirectory": ["TargetDir", " targetPath", "basePath", "destFile", "baseFolder", "targetPath", "targetRoot", "TargetDirectory", "TargetDatabase", "outputFolder", "TargetFile", "currentFolder", "TargetRoot", "masterDirectory", "currentDirectory", "targetDatabase", "currentPath", "baseDatabase", "outputDir", "targetFolder", "baseDirectory", "destDirectory", "destFolder", " targetRoot", "TargetFolder", "destDir", "masterDir", "baseFile", " targetFolder", " targetFile", "targetFile", "currentRoot", "TargetPath", " targetDir", "currentDir", "outputDirectory", "masterDatabase", "baseDir", "targetDir", "outputFile", "masterPath"], "prefix": ["folder", "unit", "index", "base", "resource", "temp", "offset", "config", "root", "fix", "sequence", "format", "pre", "domain", "patch", "Pref", "pattern", "ix", "cache", "resolution", "filename", "queue", " suffix", "prot", "string", "txt", "padding", "path", "type", "fixed", "uri", "number", "fp", "first", "name", "FIX", "username", "timeout", "template", "append", "directory"], "maxUnitBases": ["maxunitBases", "maxUnitPlases", "maxunitAliaches", "maxUnitAliails", "maxUnitBasing", "maxUnitEase", "maxUnitQueues", "maxUnitEails", "maxUnitAliases", "maxUnitAliase", "maxunitBaches", "maxUnitQuease", "maxUnitBase", "maxunitBails", "maxunitAliails", "maxUnitQueasing", "maxUnitBues", "maxUnitBaches", "maxUnitAliaches", "maxUnitBails", "maxunitBasing", "maxunitBues", "maxUnitChase", "maxUnitChases", "maxUnitAliasing", "maxunitAliase", "maxunitAliases", "maxUnitPlaches", "maxUnitEaches", "maxUnitChasing", "maxunitAliasing", "maxUnitAliues", "maxUnitChues", "maxUnitPlase", "maxUnitQueases", "maxUnitEases", "maxUnitPlails", "maxunitBase", "maxunitAliues"], "maxUnitEntries": ["maxUnitInties", "maxUnitOrdresses", "maxLineOrdines", "maxLineOrdrations", "maxUnitCountrations", "maxUnitEntryures", "maxUnitAddry", "maxUnitOrdrys", "maxUnitOrdines", "maxunitEnties", "maxunitEntrys", "maxUnitEntryries", "maxUnitAddries", "maxUnitIntrys", "maxUnitEntrys", "maxUnitAddures", "maxUnitOrdries", "maxUnitAddresses", "maxunitEntryries", "maxUnitCountry", "maxUnitEntryresses", "maxunitEntries", "maxUnitEntines", "maxUnitErries", "maxUnitEntryrys", "maxUnitErry", "maxLineOrdry", "maxunitEntryies", "maxLineEntry", "maxUnitErrations", "maxLineOrdries", "maxUnitEntresses", "maxLineEntries", "maxUnitOrdry", "maxUnitOrdrations", "maxUnitEntryry", "maxUnitErines", "maxunitEntresses", "maxUnitEntry", "maxUnitCountines", "maxLineEntrations", "maxUnitOrdies", "maxUnitCountries", "maxunitEntryresses", "maxUnitIntries", "maxUnitEnties", "maxUnitEntryies", "maxUnitIntresses", "maxUnitEntures", "maxunitEntryrys", "maxUnitEntrations", "maxLineEntines"], "fis": ["vai", " fai", " fIs", " fris", " fisc", "fisc", "forisc", "vIs", "vis", "forris", "forIs", "visa", "fIs", "foriss", "forai", "forisa", " fiss", "Fis", "fris", "fisa", "Fiss", "fiss", "foris", "Fisc", "fai", " fisa", "Fris"], "fci": ["hcos", "vai", " fai", "hco", "hai", "efco", "vcos", "fii", "efcos", " fii", "doci", "efai", "dco", "vco", "hci", "bci", "Fii", "bai", "vci", "Fis", "Foci", "dci", " foci", "efci", "bis", "Fci", "Fai", "foci", "fcos", "dii", "Fco", "bco", "fai"], "fos": ["fios", "fo", " fo", "fsios", " fcos", "tos", " fios", "toes", "infoss", "infos", "fso", "Foes", "fscos", "ifios", "foes", "fsos", "infoes", "Fos", "toss", "Fis", "ifo", "Foss", "infis", "ifos", "fcos", "tis", "ifcos", "foss"], "fco": ["hcos", "hgo", " fgo", "Fico", "dcos", "fbo", "hco", "fgo", "fileco", " fcos", "fileico", " fbo", "lci", "lco", "hci", "dco", "fileci", "dro", " fro", "Fbo", "lgo", "lcos", "dci", " fico", "filebo", "fico", "Fci", "fro", "fcos", "Fco", "lro"], "buffer": ["image", "base", "resource", "feed", "offset", "capacity", "view", "flush", "input", "entry", "channel", "window", "cache", "message", "queue", "rate", "bin", "writer", "info", "texture", "pad", "null", "scale", "buf", "read", "buff", "border", "position", "Buffer", "uffer", "translation", "result", "counter", "response", "layer", "block", "length", "context", "size", "expression", "loader", "pause", "bar", "request", "server", "data", "reference", "binary", "document", "transfer", "header", "callback", "comment", "zero", "reader", "timeout", "iter", "bc", "batch", "source", "memory", "copy", "device"], "currentBasesCount": ["currentChasesCount", "currentBatchescount", "currentChaseCount", "currentBasingNum", "currentBasingCounter", "currentBasingcount", "currentBasesCounter", "currentBasingCount", "currentBatchesCounter", "currentBatchesCount", "currentBasesNum", "currentBasescount", "currentBaseNum", "currentBaseCount", "currentChasesCounter", "currentChaseCounter", "currentChasecount", "currentBatchesNum", "currentBaseCounter", "currentChasescount", "currentChaseNum", "currentChasesNum", "currentBasecount"], "currentEntriesCount": ["currentEntrasLimit", "currentEntursOffset", "currentEnturesCount", "currentAddriesSize", "currentAddriesOffset", "currentEnturesOffset", "currentEnturesLimit", "currentEntursCount", "currentAdduresSize", "currentEntursSize", "currentEntrasCount", "currentAdduresCount", "currentAdduresOffset", "currentEntrasSize", "currentEntrasOffset", "currentEnturesSize", "currentEntriesOffset", "currentEntriesLimit", "currentAdduresLimit", "currentAddriesLimit", "currentEntursLimit", "currentAddriesCount", "currentEntriesSize"], "targetCount": ["Targetcount", "patternSize", "argetSum", "argetCount", "patternSum", "targetcount", "TargetSum", "patterncount", "argetcount", "targetSize", "patternCount", "TargetSize", "TargetCount", "targetSum", "argetSize"], "fastaChannel": ["fastABuffer", "fastanChannel", "fastasConnection", "fastanBuffer", " fastaContext", "fastasContainer", "fastaqColumn", "fastAContainer", "fastAChannel", "fastAConnection", "fastaContainer", "fastasBuffer", "fastaColumn", " fastAChannel", "fastanContainer", " fastAColumn", "fastaqBuffer", " fastAConnection", "fastAColumn", "fastasColumn", "fastaContext", "fastasChannel", "fastanContext", " fastaContainer", "fastaqChannel", "fastAContext", "fastasContext", " fastAContainer", " fastaColumn", " fastaConnection", "fastaConnection", " fastAContext", " fastABuffer", "fastaqConnection"], "totalSeqCount": ["totalSeqCounter", "totalQueQcount", "totalSeuxNum", "totalQueQNum", "totalSeqscount", "totalSeuxCounter", "totalSeuxCount", "totalQueqCounter", "totalQueqcount", "totalQueQCounter", "totalQueQCount", "totalSeQCounter", "totalSeuxcount", "totalSeqNum", "totalQueqNum", "totalSeQCount", "totalSeqsNum", "totalSeQNum", "totalSeQcount", "totalSeqsCount", "totalSeqcount", "totalSeqsCounter", "totalQueqCount"], "totalResiduesCount": ["totalResiduingcount", "totalResqueurescount", "totalResiduationCount", "totalResiduationNum", "totalResiduingCount", "totalResqueuesNum", "totalResqueuresSize", "totalResiduresNum", "totalResidurescount", "totalResiduesSize", "totalResiduresSize", "totalResiduesNum", "totalResiduationSize", "totalResiduresCount", "totalResqueuresCount", "totalResqueuesSize", "totalResiduescount", "totalResiduingSize", "totalResqueuescount", "totalResiduingNum", "totalResqueuesCount", "totalResiduationcount", "totalResqueuresNum"], "prevTime": ["PrevSize", "PrevFile", "prevSize", " prevFile", "prevValue", " prevValue", "PrevValue", " prevSize", "prevFile", "commitValue", "commitFile", "PrevTime", "commitTime", "commitSize"], "fastaFileSize": ["fastasHeaderName", "fastaBlockLength", "fastaPageSize", "fastasFileName", "fastaHeaderSize", "fastaBlockSize", "fastasFileSize", "fastaFileAddress", "fastaFileCount", "fastABufferLength", "fastAFileAddress", "fastaBufferSize", "fastaFilesName", "fastaHeaderLength", "fastaFilesAddress", "fastaFilesSize", "fastaLineAddress", "fastaBufferAddress", "fastasHeaderAddress", "fastABufferSize", "fastaLineCount", "fastaPageLength", "fastABufferAddress", "fastaFilesLength", "fastasHeaderLength", "fastaHeaderAddress", "fastaLineSize", "fastaBufferCount", "fastaHeaderName", "fastAFileLength", "fastasFileAddress", "fastaFileName", "fastaBlockAddress", "fastaFileLength", "fastasFileLength", "fastaLineLength", "fastasHeaderSize", "fastAFileCount", "fastAFileSize", "fastaPageAddress", "fastaBlockCount", "fastABufferCount", "fastaPageName", "fastaBufferLength"], "fastaFileReadOffset": ["fastaDirectoryReadOff", "fastaBufferReadoffset", "fastaFileWriteAmount", "fastaFilesWriteoffset", "fastaFilesReadLength", "fastaDirectoryWriteEntry", "fastaFileLoadOffset", "fastaDirectoryWriteOffset", "fastaDirectoryReadoffset", "fastaFileLengthoffset", "fastaFilesWriteOff", "fastaFilereadLength", "fastaFileWriteEntry", "fastaFileStartOff", "fastaFilereadoffset", "fastaFileLoadLength", "fastaFileStartOffset", "fastaFileLengthLength", "fastaBufferReadAmount", "fastaFileReadAmount", "fastaFileRunOffset", "fastaFilereadOff", "fastaFileReadoffset", "fastaFileStartoffset", "fastaFileRunoffset", "fastaFileWriteLength", "fastaFileLengthOff", "fastaFileLoadoffset", "fastaFilesReadoffset", "fastaFileReadOff", "fastaFileStartEntry", "fastaFileRunEntry", "fastaFileRunOff", "fastaBufferReadOffset", "fastaFilereadOffset", "fastaFileLengthAmount", "fastaFileWriteOffset", "fastaDirectoryReadEntry", "fastaDirectoryReadOffset", "fastaFileLengthOffset", "fastaFileReadLength", "fastaBufferReadLength", "fastaDirectoryWriteOff", "fastaDirectoryWriteoffset", "fastaFileReadEntry", "fastaBufferWriteOffset", "fastaFileLoadAmount", "fastaFileWriteoffset", "fastaBufferWriteAmount", "fastaFilesReadOffset", "fastaBufferWriteLength", "fastaBufferWriteoffset", "fastaFilesWriteOffset", "fastaFileWriteOff", "fastaFilesReadOff", "fastaFilesWriteLength"], "partitionStartOffset": ["partitionStopOrder", "partitionsStartRange", "partitionEndOrder", "partitionBufferOrder", "partitionsEndRange", "partitionEndRange", "partitionStopOffset", "partitionStopRange", "partitionsEndOffset", "partitionsEndOrder", "partitionsStartOff", "partitionStartOrder", "partitionBufferRange", "partitionsStartOrder", "partitionsStartOffset", "partitionStartRange", "partitionBufferOffset", "partitionStartOff", "partitionEndOff", "partitionsEndOff", "partitionBufferOff", "partitionStopOff"], "bufferSize": ["BufferCount", "BufferType", "BufferSize", "processC", "bufferSIZE", " bufferType", " bufferC", "processSize", " bufferCount", "BufferSIZE", "bufferCount", "queueCount", "processType", " bufferSIZE", "bufferType", "BufferC", "bufferC", "processSIZE", "queueSize"], "fastaBuffer": ["fastaPtr", "fastABuffer", "fastaBuff", "fastaQueue", " fastasFile", "FastaStream", " fastAFile", " fastasChannel", "fastanChannel", "FastasBuffer", "fastasBuff", "fastanBuffer", " fastasBuffer", "fastAPtr", "fastanQueue", "fastasContainer", "FastaBuff", "fastABuff", "fastaceChannel", "fastAContainer", "fastAChannel", "fastaContainer", "fastasStream", "fastAFile", "FastasStream", " fastaQueue", "fastasBuffer", "fastanStream", "fastasPtr", "FastasBuff", " fastAQueue", "fastaaPtr", " fastAChannel", "FastasChannel", "FastaPtr", "fastanContainer", "FastaBuffer", "fastaceBuff", "fastAQueue", "fastacePtr", "fastaceBuffer", " fastaBuff", "fastasChannel", "FastaChannel", " fastaContainer", "fastaaStream", " fastasContainer", "fastasFile", "FastasPtr", "fastanBuff", "fastaStream", "fastaaBuff", "fastasQueue", " fastABuff", "fastanFile", "fastanPtr", "fastaFile", " fastaFile", "fastaaBuffer", " fastABuffer"], "fastaReadState": ["fastaReaderMode", "fastasReaderState", "fastaReadingMode", "fastaFileState", "fastaReaderState", "fastasReaderstate", "fastaReadingstate", "fastaReadstate", "fastaReaderType", "fastaReadingType", "fastaReadingState", "fastasReaderType", "fastaReaderstate", "fastaFileType", "fastasReadType", "fastasReadstate", "fastaReadType", "fastasReadState", "fastaFileMode", "fastasReadMode", "fastasReaderMode", "fastaFilestate", "fastaReadMode"], "nBytes": ["numFrames", "pByte", "oParts", "NByte", "Nbytes", "lenFrames", "lenbytes", "nFiles", "nFrames", "NParts", " nFrames", "lenFiles", "NFiles", "nbytes", "numbytes", "obytes", "lenBytes", "numBytes", " nFiles", " nbytes", "oFiles", "pbytes", "oBytes", "pParts", " nParts", "nByte", "nParts", "numFiles", " nByte", "pBytes", "NBytes"]}}
{"id1": "17190057", "id2": "13063241", "code1": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"encode": ["encescape", "Enescape", "enccode", "unode", "unescape", "enescape", "enode", "Encode", "uncode", "Enode"], "input": ["image", "in", "temp", "raw", "prefix", "this", "stream", "xxx", "hex", "inf", "form", "format", "audio", "pattern", "Input", "alpha", "text", "output", "password", "string", "null", "array", "def", "buffer", "amp", "crypt", "plus", "result", "addin", "img", "context", "secure", "ssl", "request", "data", "binary", "instance", "str", "empty", "i", "reader", "config", "source", "address"], "NoSuchAlgorithmException": ["NoSuchAlodingError", "NoSuchAlgoWarning", "NoSuchEdryptionement", "NoSuchAlgorithmWarning", "NoSuchEdgorithmException", "NoSuchEdryptionWarning", "NoSuchAlgorithmError", "NoSuchAlryptionError", "NoSuchAlgorithmement", "NoSuchAlodingWarning", "NoSuchAlgoException", "NoSuchEdryptionException", "NoSuchAlodingException", "NoSuchEdryptionError", "NoSuchAlryptionWarning", "NoSuchAlgoError", "NoSuchAlryptionement", "NoSuchEdgorithmWarning", "NoSuchAlryptionException", "NoSuchEdgorithmError", "NoSuchAlgoement", "NoSuchAlodingement", "NoSuchEdgorithmement"], "md": ["dd", "nm", "mi", "sha", "cmd", "dc", "dig", "metadata", "ma", "um", " MD", "amd", "hd", "mm", "mad", "mo", "message", "zip", "key", "ms", "cd", "wd", "mp", "code", "hash", "mand", "d", "m", "bd", "ad", "doc", "pm", "df", "mt", "mac", "od", "me", "MD", "sum", "mod", "pd", "mag", "dm", "mc", "mb", "meta", "db"]}}
{"id1": "17901739", "id2": "20724937", "code1": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public static TopicMap getTopicMap(URL url) {\n        String baseURI = url.toString();\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return getTopicMap(inputStream, baseURI);\n    }\n", "label": 0, "substitutes": {"setMembers": ["SetMethods", "SetMember", "parseMethods", "SetMembers", "parseMembers", "SetJoin", "parseJoin", "setMethods", " setJoin", "setJoin", "setMember", " setMethods", " setMember", "parseMember"], "url": ["image", "URL", "base", "resource", "service", "www", "feed", "email", "Url", "entry", "channel", "hub", "http", "queue", "l", "string", "path", "io", "org", "uri", "client", "blog", "article", "loader", "socket", "ssl", "location", "server", "data", "file", "user", "sl", "connection", "source", "address"], "reader": ["err", "resource", "feed", "stream", "rer", "inner", "input", "entry", "worker", "http", "parser", "ler", "reading", "rar", "bird", "l", "writer", "table", "read", "driver", "builder", "r", "rc", "handler", "er", "io", "rr", "row", "ner", "loader", "report", "server", "file", "e", "iterator", "Reader", "per", "i", "keeper", "iter", "f", "editor"], "buffer": ["resource", "window", "filename", "queue", "bb", "page", "null", "result", "layer", "length", "expression", "received", "file", "binary", "seed", "str", "comment", "rb", "source", "button", "wave", "fr", "flush", "input", "cache", "sync", "output", "password", "bin", "b", "info", "texture", "string", "read", "background", "code", "stage", "phrase", "response", "loader", "pause", "server", "document", "template", "Buffer", "header", "base", "game", "paste", "parse", "text", "bytes", "fb", "uffer", "line", "row", "FFER", "bar", "request", "data", "batch", "address", "image", "video", "feed", "sequence", "player", "http", "message", "writer", "buf", "flash", "buff", "border", "padding", "counter", "uri", "transfer", "iter"], "pattern": ["re", "rule", "letter", "model", "image", "graph", "log", "system", "script", "feed", "child", "config", "event", " Pattern", "format", "function", "patch", "match", "Pattern", "serial", "filter", "group", "cache", "parser", "atter", "slice", "password", "regular", "object", "print", "builder", "string", "array", "position", "condition", "path", "handler", "part", "type", "counter", "df", "number", "layer", "command", "expression", "cher", "app", "file", "document", "str", "template"], "matcher": ["matchches", "motner", "matchched", "matger", "Matter", "mitch", "Matcher", "captter", "matter", "matchpattern", "mircher", " match", "mancher", "matched", "Matner", "attcher", "attger", " matler", "attching", "Matger", "manner", "patchers", "harcher", " mather", "captcher", "mather", "mitchers", "patch", "patner", "motpattern", " matchers", "captatter", "mirher", "patcher", "ratching", "compcher", "patatcher", " matacher", "patter", "matchcher", "linatter", "compches", " matpattern", "Matacher", "manher", "ratacher", "mither", "matner", "patpattern", "reched", "matpattern", "mirpattern", "reach", "matchler", "lincher", "linpattern", "matchers", "matchher", "mitcher", "match", "compach", "statpattern", "harner", "harler", " matner", "compner", "Mather", "matach", "statler", "matchatcher", "captpattern", " matter", "linter", "matler", "manacher", "matchacher", " matatter", "reches", "motcher", "statner", "mirter", "pather", "compched", "matchter", "matacher", "compter", "ratger", "statcher", "Matpattern", "matatter", "harpattern", "motter", "matches", "recher", "matatcher", "compatcher", "matchner", "Matching", "matching", "attacher", "matchach", "ratcher"], "erg": ["urg", "dr", "ga", "igor", "aga", "aug", "jing", "rog", "eng", "game", "ag", "orters", "usa", "clus", "era", "gas", "worker", "feat", "berg", "anger", "gra", "ocr", "gy", "eric", "uster", "ger", "eur", "ERG", "arc", "ander", "gg", "agg", "rg", "git", "ord", "ard", "oga", "der", "irc", "gr", "forge", "ig", "er", "yang", "porter", "progress", "eri", "alg", "ager", "org", "sg", "east", "ung", "gd", "region", "agog", "justice", "ero", "orter", "magic", "gru", "ider", "gae", "og", "ers", "rator"], "start": ["unit", "need", "current", "step", "cost", "begin", "speed", "show", "scale", "state", "grad", "boot", "it", "ish", "fit", "name", "seed", "old", "like", "source", "in", "send", "stop", "check", "grade", "count", "run", "add", "bin", "info", "style", "read", "fill", "sort", "ad", "first", "size", "init", "id", "last", "get", "base", "inner", "none", "End", "match", "something", "pad", "starting", "set", "position", "st", "ind", "ie", "shift", "type", "se", "diff", "rest", "off", "sum", "pend", "max", "address", "sol", "index", "end", "offset", "art", "head", "pick", "open", "find", "load", "space", "pos", "middle", "work", "plus", "part", "stat", "Start", "started", "min", "close", "mid"], "von": ["vid", "ou", "endon", "ver", "mun", "andon", "ten", "kn", "uber", "fat", "don", "fun", "hn", "fin", "fen", "feat", "bon", "lon", "zon", "bin", "tun", "oni", "mon", "aven", "olson", "evin", "wen", "vor", "tin", "flo", "hon", "una", "jen", "su", "eni", "nn", "len", "melon", "bn", "endor", "han", "ln", "onna", "jan", "john", "tu", "dn", "won", "fn", "byn", "vin", "non", "di", "vu", "lu", "anon", "lin"], "bis": ["vals", "offs", "lus", "uno", "bits", "ls", "lins", "uss", "ui", "bb", "ri", "bes", "boot", "os", "nas", "isin", "nexus", "los", "lin", "bat", "pins", "ours", "isi", "bos", "bin", "oni", "pi", "obs", "outs", "onis", "ni", "su", "cedes", "is", "bian", "us", "oris", "BUS", "bus", "zi", "udi", "base", "des", "prefix", "bles", "idis", "bett", "abi", "fb", "eni", "cin", "oss", "sis", "bps", "vin", "di", "vid", "fat", "vs", "val", "bid", "bas", "pos", "buff", "li", "ris", "bi", "len", "phis", "cos", "cus", "ori", "ois", "bs", "ios"], "m_strComponents": ["m_strCommales", "m_intReports", "m_intRepales", "m_strExpenses", "m_strComponentonents", "m_intReponents", "m_strReponents", "m_strExponents", "m_arrCompales", "m_arrComponent", "m_strComponent", "m_strComponentonent", "m_strCommorts", "m_arrCompenses", "m_arrCommenses", "m_intRepenses", "m_strExpales", "m_intCompenses", "m_strCompales", "m_arrComponents", "m_strCommonents", "m_strCommonent", "m_strComponentenses", "m_strCommenses", "m_strComports", "m_strCompenses", "m_strRepenses", "m_strReports", "m_arrCommales", "m_arrCommonent", "m_intComponents", "m_strExports", "m_arrCommonents", "m_strExponent", "m_strComponentales", "m_intCompales", "m_intComports", "m_strRepales"], "m_strPriorities": ["m_strQualifiers", "m_StrPositions", "m_intPriorities", "m_strPosifiers", "m_strPrioritives", "m_strPrefitives", "m_strActivities", "m_strQualities", "m_strPositions", "m_strComparities", "m_intPrioritives", "m_strPrefities", "m_StrPriorifiers", "m_strActivitives", "m_strMonities", "m_strPosity", "m_strMonries", "m_strPrefitions", "m_strPosities", "m_StrPriority", "m_intPriorries", "m_strMonitions", "m_StrPriorities", "m_strPriority", "m_strPriorifiers", "m_intPrefities", "m_strQuality", "m_intPrefitions", "m_strQualitions", "m_strComparity", "m_strPriorries", "m_intPrefitives", "m_strComparitions", "m_StrPrioritions", "m_strActivitions", "m_intPrefries", "m_StrPosifiers", "m_intPrioritions", "m_StrPosities", "m_strActivries", "m_strPrefries", "m_strMonitives", "m_StrPosity", "m_strComparifiers", "m_strPrioritions"]}}
{"id1": "22320592", "id2": "7372311", "code1": "    private static void loadDefaultPreferences() {\n        try {\n            URL url = ClassLoader.getSystemResource(\"OpenDarkRoom.defaults.properties\");\n            preferences.load(url.openStream());\n        } catch (FileNotFoundException e) {\n            log.error(\"Default preferences file not found\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 0, "substitutes": {"loadDefaultPreferences": ["loadStandardPreferences", "loadDefaultConferences", "loadStandardPreerences", "loadStandardPreels", "loadDefaultConfSettings", "loadDefaultpreSettings", "loadDefaultpres", "loadStandardPrefSettings", "loadStandardPreSettings", "loadDefaultPreSettings", "loadDefaultPreerences", "loadStandardPres", "loadDefaultpreerences", "loadDefaultConfels", "loadStandardPrefels", "loadDefaultPrefels", "loadDefaultPrefSettings", "loadDefaultpreels", "loadDefaultPrefs", "loadDefaultConfs", "loadDefaultPreels", "loadDefaultPres", "loadStandardPrefs"], "url": ["image", "URL", "base", "resource", "service", "feed", "stream", "Url", "entry", "ref", "http", "l", "b", "object", "page", "string", "element", "bel", "buffer", "path", "rel", "org", "uri", "xml", "loader", "name", "location", "ssl", "server", "data", "file", "user", "id", "e", "gl", "jar", "browser", "el", "sl", "reader", "config", "source", "f", "address"]}}
{"id1": "20619879", "id2": "19134229", "code1": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyLogic": [" startLexics", " syncLexics", " startLogic", " syncLogic", " syncChic", " startLexication", " syncChics", " syncChically", " syncLexically", " startLogication", " syncTechnically", " syncLexication", " syncTechnication", " syncTechnic", " syncLexic", " startLogically", " syncTechnics", " syncChication", " startLexic", " syncLogically", " syncLogics", " syncLogication", " startLogics", " startLexically"], "sourceChannel": ["SourceStream", "SourceCh", "sessionStream", " sourceStream", "SourceChannel", "sourceQueue", "targetQueue", "inputchannel", "sourceCh", "inputStream", "targetchannel", "sessionCh", "Sourcechannel", " sourceFile", "inputChannel", "inputQueue", " sourceConnection", "sessionChan", "SourceChan", "sourcechannel", "targetStream", "inputChan", "sourceFile", " sourcechannel", "inputFile", "targetChan", "sourceChan", "targetFile", " sourceQueue", "sourceConnection", " sourceChan", "targetChannel", "sessionChannel", "targetConnection", "SourceConnection", "inputCh", "sourceStream"], "destinationChannel": ["destinatingChannel", "Destinationchannel", "destinatedSocket", "DestinatorChannel", "destinatingStream", "destinationchannel", "destinatingSocket", "DestinatorChan", "destinationsStream", "destinatingConnection", "destinationsChannel", "destructionchannel", "destinationConnection", "destinationChan", "DestinationConnection", "DestinatorStream", "destationchannel", "DestinationSocket", "DestinationChannel", "destinatingChan", "destinatingchannel", "destinatorConnection", "destationConnection", "destructionChan", "destinatorStream", "destationChannel", "DestinatorSocket", "Destinatorchannel", "destinatorchannel", "destructionChannel", "destinatorChan", "destinatedChan", "destinationStream", "destinationsConnection", "destinatedChannel", "DestinationStream", "destinatedchannel", "destinatorChannel", "destructionConnection", "destinationSocket", "destationChan", "DestinationChan", "DestinatorConnection", "destinatorSocket", "destinationschannel"]}}
{"id1": "22366505", "id2": "18962382", "code1": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "code2": "    protected void connect() throws SocketException, IOException, LoginFailException {\n        logger.info(\"Connect to FTP Server \" + account.getServer());\n        client = new FTPClient();\n        client.connect(account.getServer());\n        if (client.login(account.getId(), account.getPassword()) == false) {\n            logger.info(\"Fail to login with id=\" + account.getId());\n            throw new LoginFailException(account.getId(), account.getPassword());\n        }\n    }\n", "label": 0, "substitutes": {"incluir": ["incluear", "inclituire", "inCLUire", "inCLuir", "inclurir", "inclUiro", "incluiro", "inclituear", "inclUire", "incluire", "inclUear", "inclurire", "inclituiro", "inclUir", "inclituir", "inclurear", "incluriro", "inCLuiro", "inCLuear", "inCLUir", "inCLUear", "inCLUiro", "inCLuire"], "igreja": ["igreraza", "ligrej", " iggreji", "igruji", "igreraya", " igreji", "igruj", "igcreJa", "igrej", "igr\u00e9je", "igreya", "iggreJa", " igreraja", "igr\u00e9ja", "iggreje", "igruya", "igreji", "ligr\u00e9ja", "iggreya", " iggreja", " igreza", "igruje", "igreje", " igreJa", "ligr\u00e9je", "ligr\u00e9j", " igreraya", "igereja", "igerej", "igereji", "ligrejas", "igrejas", "iggrejas", "igcreji", "igrujas", "igreraji", " igreya", " iggrej", "iggrej", "igcreja", "iggreja", "ligr\u00e9jas", "igruja", "igreJa", "igcrej", "ligreja", " igrej", "iggreza", "igr\u00e9j", "igr\u00e9jas", "igreraja", "igreza", " igreraza", " iggreJa", "iggreji", "igereJa", "igruza", "ligreje", " igreraji"], "connection": ["index", "pool", "graph", "system", "ion", "section", "event", "function", "Connection", "cache", "table", "environment", "conn", "application", "option", "c", "cf", "position", "condition", "engine", "session", "collection", "core", "relation", "BC", "query", "client", "cc", "context", "manager", "statement", "communication", "con", "loc", "server", "union", "document", " Connection", "connect", "lock", "description", "error", "database", "bc", "connected", "config", "ctx", "db", "socket", "machine", "directory"], "sql": ["log", "sol", "setup", "section", "printf", "nl", "function", "ls", "SQL", "filename", "sync", "conn", "csv", "string", "null", "spec", "session", "params", "query", "join", "stat", "ql", "sb", "eps", "sq", "statement", "socket", "ssl", "term", "sys", "ln", "id", "fn", "seed", "sl", "database", "seq", "dl", "select", "db", "url", "s"], "sql2": ["url1", " sql02", " sql1", "sql02", "url2", "ql1", "ql02", "sqltwo", "ssl02", "qltwo", "ssl1", "sqlII", "sql1", "ql2", " sqltwo", "ssl2", "qlII", "urltwo", "sslII", " sqlII"], "stmt": ["STmt", "fmd", "frconn", "strh", "Stmt", "istconn", "strmd", "Stmn", "Stql", "frtr", "frmn", " stmr", "stconn", "Stmb", "ostmn", "frmt", " sttr", "tm", "stmd", "STmd", "Stst", "Stmr", "stql", " stst", "sttr", "ostmd", "istmn", "stpt", "isttr", "ostmr", "stmn", "STmb", " stconn", " stmd", "fh", "Stmd", "fdb", " stmb", "stm", "Stpt", "strmt", "fmt", "stst", "istmt", " stpt", "tpt", "tmr", "Stm", " stm", "ostmt", "sth", "ostql", "STst", " stdb", "stdb", "stmr", "tmt", "strdb", " stql", "stmb", " sth", " stmn"], "stmt2": ["stmd1", " stmt3", "stmp02", "stmd3", "stmt4", "stmp2", " stmt1", " stmr02", "stmp1", " stmt4", " stmtTwo", "stmpTwo", " stmp3", "stmt1", "stmr02", "stmnTwo", " stmp4", " stmp2", "stmd4", "ctmtTwo", "stmr1", "stm4", "ctmt1", "stm2", "stmr3", "stbmTwo", "stmn1", "stmd2", "stbm1", "stmp4", "ctmt2", " stmrTwo", "stmrTwo", " stmt02", "stmt02", " stmr2", "stmtTwo", "ctmpTwo", "stm1", " stmpTwo", " stmp1", "stmp3", "ctmp2", "stbm2", "stmr4", "stmdTwo", "stmr2", "stmt3", " stmr1", "ctmp1", "stbm02", "stmn4", "stmn2"], "rs": ["ars", "rys", "eers", "errors", "rates", "ls", "runs", "details", "vers", "ms", "conn", "pr", "Rs", "rd", "r", "xs", "rows", "rc", "ps", "params", "ows", "ds", "relations", "ris", "ros", "rr", "ras", "cs", "mr", "row", "qs", "ins", "hs", "ys", "sr", "gs", "RS", "ss", "results", "res", "ks", "ts", "cr", "rss", "s"], "retorno": ["Retago", " retro", "respro", "Retorn", "retro", "ntorn", "ntour", "Retro", "retour", " retorn", "Retorno", "resporno", "Retour", "ntro", " retour", "ntorno", "retago", "resporn", "respago", " retago", "retorn"]}}
{"id1": "6840241", "id2": "4716110", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copy": ["image", "slave", "create", "system", "clone", "share", "download", "write", "open", "cop", "load", "process", "sync", "clip", "type", "cmp", "io", "cover", "loop", "ip", "size", "opy", "proxy", "server", "Copy", "transfer", "mop"], "source": ["image", "slave", "service", "resource", "SOURCE", "rice", "this", "stream", "Source", "ink", "inner", "input", "target", "channel", "src", "slice", "use", "ources", "null", "sp", "from", "session", "handler", "ie", "ource", "si", "result", "se", "start", "size", "proxy", "wrapper", "server", "data", "seed", "e", "iterator", "i", "reader", "iter", "connection", "sin", "parent", "address"], "sink": ["tource", "outsinker", "Sinker", "dsinker", "partsink", "Source", "partsource", "asigh", "outsource", "pink", "asink", "tinker", "outsink", "SINK", "tider", "pider", "outsigh", "asinker", "dsink", "asource", "dsource", "pINK", " sinker", "tink", "sigh", " sigh", "pinker", "pource", "Sink", "partsINK", "sider", "sinker", "partsinker", "sINK", "dsider"]}}
{"id1": "15822137", "id2": "19109981", "code1": "    public TableDirectory(RandomAccessFile raf) throws IOException {\n        version = raf.readInt();\n        numTables = raf.readShort();\n        searchRange = raf.readShort();\n        entrySelector = raf.readShort();\n        rangeShift = raf.readShort();\n        entries = new DirectoryEntry[numTables];\n        for (int i = 0; i < numTables; i++) {\n            entries[i] = new DirectoryEntry(raf);\n        }\n        boolean modified = true;\n        while (modified) {\n            modified = false;\n            for (int i = 0; i < numTables - 1; i++) {\n                if (entries[i].getOffset() > entries[i + 1].getOffset()) {\n                    DirectoryEntry temp = entries[i];\n                    entries[i] = entries[i + 1];\n                    entries[i + 1] = temp;\n                    modified = true;\n                }\n            }\n        }\n    }\n", "code2": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"raf": ["raft", " ar", "feed", "fa", "root", " ra", "transform", " af", "fin", "arch", "fif", "rah", "rt", "fc", "ref", "rar", "bas", "ut", "RR", "hel", "uf", " fin", "arc", " rot", "roc", "buf", "rf", "r", " arc", "RB", "RF", "buff", "rc", "fd", "sam", "rou", "fb", "ica", "ro", "bf", "awa", "asu", "io", "upload", "fal", "rr", "mr", "ra", "fs", "fp", "util", "AF", " fa", "file", "fam", "af", "fed", "f", "rss", "reader", "rb", "Rot", "rw", "rot", "cro", "reed", "aft", " priv", "dra", "ab", "arf"], "version": ["ver", "index", "versions", "section", "depth", "prefix", "root", "step", "format", "patch", "vision", "serial", "vers", "scale", "option", "Version", "counter", "row", "VERSION", "ip", "init", "server", "id", "seed", "feature", "parent", "release"], "numTables": ["NumTures", "NumNaces", " numTrees", "numtests", "numTenasks", "numtodes", "numTries", "numtables", "numPartables", "numPartaces", "numPartodes", "numTasks", "NumNabs", "numtures", "numTenaces", " numtables", "numtasks", "numDables", "NumTables", "numTures", "numDures", "Numtaces", "numLures", " numtrees", "numTenries", " numTenries", "numDaces", "numtries", "numTenests", "numTaces", "NumTaces", " numTaces", "numNables", "Numtasks", "numTenables", "numNabs", "numPartrees", "NumTests", "numNures", " numTenures", "numNasks", "numNests", "numTabs", " numTures", " numtodes", "numTenures", "numTodes", "numLables", " numTries", "NumTasks", "NumTabs", "numNodes", "Numtests", "numDabs", "NumNables", "numtrees", "numtabs", "NumNures", "numtaces", "numNaces", " numTodes", "numTests", " numTenests", "Numtables", " numTests", " numTenables", " numtaces", "numLries", "numNrees", "numTrees", "numLests"], "searchRange": ["searchrange", "indexRange", " searchPart", "indexPart", "filterrange", " searchLimit", "filterPart", "searchLimit", " searchrange", "indexrange", "filterRange", "indexLimit", "searchPart", "filterLimit"], "entrySelector": ["sectionAcception", "sectionSelective", "entryProcessored", "entryselectored", "entrySelectored", "entrySelection", "sectionAcceptor", "entryProcessive", "sectionSelection", "sectionAcceptored", "entryselector", "sectionSelector", "entryAcceptive", "sectionSelectored", "entrySelective", "entryProcession", "entryProcessor", "entryAcceptor", "sectionAcceptive", "entryAcception", "entryAcceptored", "entryselective", "entryselection"], "rangeShift": ["tableCut", "rangeshift", "rangeScale", "tableshift", "rangeCut", "queryshift", "tableScale", "queryScale", "tableShift", "queryShift", " rangeScale", " rangeshift", " rangeCut", "queryCut"], "entries": ["insties", "entables", "extances", "equances", "ntables", "endries", "Entables", "entories", "entrys", "objectries", "instries", "ntrys", "emptries", "countries", "objectrying", "extries", "errorrying", "Entry", "intrying", "errorries", "intries", "entsrations", " entrations", "errorrics", "entrying", "entrations", "extrations", "attries", "Entries", "encries", "antries", "entants", "countrys", "instry", "errorrations", "Entants", "entry", "instrance", "endies", "encables", "intrics", "antrys", "anties", "equries", "entrics", "entrance", "encances", "ntrance", "country", "entsries", "encies", "attrations", "countables", "instances", "attrys", "extrys", "endances", "equies", " entants", "attances", "ntry", "Entrys", "instrys", "Entances", "endables", "ntances", "ntants", "antants", "objectrations", "instables", "emptories", "equry", "ntories", "antories", "ntries", "entsants", "objectrics", "intrations", "entances", "emptants", " entrys", "Entrations", "entsrys", "emptrys", "nties", "enties", "antrance"], "i": ["z", "ini", "mi", "lc", "index", "j", "o", "in", "uli", "anti", "hi", "phi", "cli", "ii", "ix", "slice", "ik", "l", "b", "info", "ui", "api", "iv", "ri", "pi", "c", "gi", "g", "abi", "d", "li", "ci", "ie", "p", "multi", "si", "io", "xi", "I", "bi", "v", "x", "ai", "uri", "eni", "y", "it", "ip", "init", "ori", "a", "h", "ti", "id", "qi", "my", "e", "iu", "u", "f", "di", "m", "source", "oi"], "modified": ["closed", " Modified", "stable", "offset", "found", " modifying", " original", "content", "current", "active", "ordered", " altered", " delayed", "formed", "created", "required", "ified", "update", "disabled", "status", "null", "updated", "broken", "hold", "condition", "changed", " modification", "initial", "loaded", "success", "affected", " modifications", "original", "locked", "placed", "restricted", "used", "adjusted", "left", "hidden", " modifier", "interrupted", "dirty", "received", "rolled", "mod", " unchanged", "ended", "id", "valid", " modify", "unknown", " updated", "empty", "edited", "complete", "successful", "failed", " completed", "draft"], "temp": ["z", " adapter", "lc", " orig", "j", "base", " destination", " aux", "stable", " esc", " winner", " swap", "entry", "mini", " extra", " dummy", "local", " source", " zip", " candidate", "extra", "txt", " intermediate", "cel", "ant", "Temp", " wrapper", "result", "v", "dest", "flat", " cleaner", " template", " generator", "tmp", "emp", " fake", " cache", "tc", "porary", "valid", " holder", "fake", "empty", "ex", "iter", "template", "parent", "holder", " vendor"]}}
{"id1": "14191679", "id2": "8665321", "code1": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"EncodeReturn": ["EnodeReturn", "EnodedReturns", "EnodeData", "EncodeReturns", "EncodReturns", "EncodData", "EnccodeReturns", "EnccodeReturn", "EncodeResult", "EnodedReturn", "EncodResult", "EncodeData", "EncodReturn", "EnccodeResult", "EnodedData", "EnodedResult", "EnodeResult", "EnodeReturns", "EnccodeData"], "IOException": ["IPError", " IOError", "Downloadception", "IPception", "DownloadError", "IOError", "IOception", "IPException", "DownloadException", " IOception"], "c": ["enc", "lc", "conv", "dc", "nc", "pc", "cur", "fc", "cu", "cache", "l", "ch", "cd", "b", "C", "cf", "r", "cpp", "ct", "t", "d", "ci", "p", "sc", "cmp", "gc", "cs", "proc", "ce", "xc", "client", "cc", "y", "chain", "ac", "e", "mc", "u", "n", "uc", "cp", "ec", "m", "cr", "f"], "tmpf": ["zipF", "poraryfen", "tmpF", "zipfd", "vmF", " tmpfs", "tempF", " tmpcf", "poraryF", "empf", "tempfd", "tempfs", "empfd", "tempfen", "tmpfen", "vmfs", "vmf", "porarycf", "poraryf", "zipf", " tmpF", "tempf", "empfs", "empF", "zipfs", "tmpcf", "tmpfd", "vmcf", "tempcf", "tmpfs", " tmpfen"], "cw": [" cwe", "psw", "cwd", "Csw", "pwa", "rcw", " cwd", "cW", "lcwe", "fw", "cwe", "ffw", "rcwb", "rcwe", "cfw", "Cws", "lcwd", "fws", "fwa", " cwa", "lcw", " csw", " cws", " cW", "cws", "pw", "rcwd", " cwb", "Cw", "Cwa", "pW", "csw", "cwb", " cfw", "cwa", "lcwb", "CW", "Cfw"], "encdata": ["encdatabase", " encData", "Enckeys", "installdata", "encroot", "Encdata", "secdat", "envroot", "envreader", "inccache", "encdat", "envData", " encdat", " encreader", "extdatabase", "encreader", "envdata", "envdat", "incroot", "EncData", "enccache", "extData", "secdata", "extdata", "secData", " encroot", " encdatabase", "incdata", "installData", "envcache", "installdatabase", "seckeys", " enccache", "extdat", "increader", "encData", "installdat", "envkeys", "Encdat", "enckeys"], "pigdata": ["pigrdata", "pichla", "pocdata", "pippData", "Pigla", "pocresource", "pibdat", "Pigscache", "pigsdata", "Pigcache", "pichdata", "pocData", "pigrData", "Pibdat", "pagdata", "picdat", "Pigresults", "Pigsresults", "pigrresults", "pigscache", "pigsla", "PigsData", "pibresource", "PigData", "Pigdata", "pigresults", "pigsresults", "pichcache", "picdata", "Pigsla", "picresource", "pagdat", "pagresults", "pigresource", "PibData", "Pibdata", "pigrdat", "pippdata", "pigsData", "pigData", "pigdat", "pigla", "pibdata", "Pigsdata", "pigsdat", "pibData", "Pigdat", "Pigsdat", "picData", "Pibresource", "pippla", "pagData", "pippcache", "pichData", "pocdat", "Pigresource", "pigcache"], "pigroute": ["apibrouting", "pigrouter", "apibroute", "pigrroute", "fibroute", "apigroute", "pigrationroute", "apibrroute", "pirmouter", "figrote", "pipelouting", "figroute", "pigrationange", "pibrroute", "pigerote", "pirmoute", "migroute", "migrune", "piarouting", "miarune", "pigrouting", "pigerune", "pibrange", "pipelroute", "piarote", "pigerouting", "pibroute", "pigrationouting", "pipeloute", "pipelange", "pibrouting", "apigrouting", "figrroute", "fibrroute", "pibrote", "fibrange", "apigrouter", "miarote", "apibrouter", "pirmroute", "apigrroute", "piarune", "piaroute", "migrote", "miarouting", "pipelune", "miaroute", "figrange", "fibrote", "pigrationouter", "pigrune", "pigeroute", "pigrote", "pirmouting", "pibrouter", "pigrange", "migrouting", "pipelote", "pigrationote", "pigrationoute"], "fos": ["fo", " fops", "fOS", " foes", " fo", "to", "tos", "pOS", "Foc", "toes", "pos", "poes", "refos", "Foes", "refoes", "foes", "refops", "Fos", "fops", "refOS", " fOS", "toc", "pops", "Fo"], "foc": [" fec", "fac", "Fec", " focol", "Foc", "fec", "Fic", "infoc", "infocol", "infic", " fac", "Fac", "infac", "Focol", "focol", "infec"], "fis": ["cig", "fics", "fig", "Fi", "fi", " fi", "cics", "cic", "Fig", "Fic", " fics", "Fis", "infics", "infis", "infic", " fig", "Fics", "cis", "infi"], "fic": ["pic", "cfoc", "fics", "Fico", "fac", "pis", "rfic", " fisc", "fisc", "rfoc", "cfics", "cfis", "Foc", "cfic", "Fic", " fics", "infoc", "rfics", "Fis", "infics", "rfis", " fico", "infic", "fico", " fac", "cfico", "Fac", "Fics", "poc", "pac", "infisc", "Fisc"]}}
{"id1": "16590954", "id2": "12783713", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"createJAR": ["createPHAR", "createJARS", "createPHARS", "createJPJar", " createPHARS", "createJJar", " createJJar", "createPHAP", " createPHAP", "createAMARS", " createJARS", " createPHAR", " createJAP", " createPHJar", "createJPAP", "createJPAR", "createJPARS", "createJAP", "createAMJar", "createPHJar", "createAMAP", "createAMAR"], "fileString": ["loadString", "linestring", "FileStr", "FileText", "FileString", "baseStr", "fileStream", "resourceStream", "FileFile", "fileName", "lineString", "fileStr", "fileArray", "baseString", "Filestring", " fileName", "modelText", " fileText", " fileStr", "loadstring", "modelStr", " fileFile", "FileName", "lineName", "baseFile", "loadText", "resourceText", "FileStream", "lineArray", "fileFile", "fileText", "resourceString", "resourceStr", "filestring", "basestring", " filestring", "modelString", "loadName", "FileArray", " fileArray", "modelStream"], "ext": ["enc", "end", "content", "format", "version", "req", "exp", "text", "zip", "xt", "filename", "info", "prot", "extra", "txt", "class", "code", "dist", "external", " Ext", "path", "Ext", "type", "v", "x", "app", "name", "EXT", "exe", "dep", "data", "ax", "str", "append", "desc", "ex", "config", "url"], "file": ["File", "folder", "log", "model", "base", "force", "resource", "wave", "unit", "module", "change", "ile", "let", "fe", "up", "http", "cache", "zip", "local", "filename", "use", "queue", "l", "b", "ger", "full", "output", "page", "url", "class", "pe", "files", "buffer", "path", "work", "single", "doc", "part", "line", "place", "it", "build", "flat", "fp", "FILE", "le", "socket", "name", "test", "bar", "h", "binary", "parent", "per", "get", "jar", "source", "db", "f"], "i": ["ini", "mi", "index", "j", "yi", "hi", "phi", "ii", "mini", "slice", "key", "l", "ui", "pi", "c", "abi", "li", "ind", "ci", "p", "uni", "si", "ni", "xi", "multi", "eni", "v", "x", "ai", "uri", "it", "ip", "ori", "qi", "iu", "limit", "f", "di", "I"], "dir": ["folder", "base", "module", "DIR", "prefix", "coll", "format", "direction", "domain", "cur", "src", "zip", "ir", "filename", "output", "area", "info", "string", "class", "dist", "path", "doc", "type", "div", "rel", "uri", "Dir", "manager", " directory", "tmp", "name", "loc", "data", "id", "jar", "str", "pkg", "lib", "config", "db", "url", "directory"], "jarFile": ["tarFile", "jarSourceFile", "javaFile", "javaF", " jarDir", "archiveDir", "sessionfile", "jarfile", "jarFiles", "reportSourceFile", "jarF", "tarSourceFile", "archiveFolder", " jarFiles", "javaFiles", "sessionFile", "reportF", "archiveFiles", " jarLine", " jarFolder", "jarFolder", "javaFolder", "tarF", "jarDir", "sessionLine", " jarfile", "tarfile", "tarLine", "javaDir", "archiveFile", "reportfile", " jarSourceFile", "reportFile", "javaSourceFile", "jarLine", "sessionSourceFile", "javafile"], "fstrm": ["fbrm", "fstrcm", "fsrcm", " fsrM", " fsrm", " fstrcm", " fsrcm", "fsrmd", " fstrum", "Fstrmd", "fbrum", "Fstrcm", "fstmd", "fgrm", "Fsrcm", "fsrum", "fstcm", "fstum", "fstM", "fsrm", "fsrM", " fsrum", "fgrmd", "Fsrm", "fbrM", " fstrM", "fbrcm", "FsrM", "fstm", "fgrM", "fgrcm", "fstrM", "fstrmd", "Fsrmd", "Fstrm", "FstrM", "fstrum"], "in": ["image", "login", "stream", "inner", "inn", "gin", "to", "input", "In", "up", "sync", "l", "bin", "conn", "read", "c", "pin", "IN", "r", "again", "p", "part", "nin", "io", "min", "pull", "ins", "is", "into", "init", "ac", "inside", "rin", "binary", "id", "reader", "n", "or", "m", "din", "f", "socket", "inc", "s"], "out": ["flow", "err", "image", "pool", "resource", "outer", "this", "self", "inner", "to", "outside", "plain", "net", "channel", "group", "exp", "up", "sync", "output", "OUT", "bin", "conn", "b", "writer", "null", "c", "again", "outs", "plus", "doc", "source", "line", "part", "io", "v", "all", "Out", "client", "off", "init", "server", "user", "call", "connection", "m", "inc"], "temp": ["folder", "unit", "base", "storage", "form", "w", "input", " Temp", "or", "zip", "cache", " temporary", "local", "output", "key", "api", "writer", "full", "home", "c", "export", "store", "buffer", "path", "single", "doc", "p", " tmp", "Temp", "template", "wrap", "it", "build", "v", "dest", "controller", "tmp", "test", "emp", "clean", "dump", "archive", "server", "Output", "porary", "fake", "tem", "get", "iter", "pipe", "config", "source", "db", "f", "directory"], "fstrm2": ["fstrp0", "fstrmr1", "fstM1", "fstrm002", "fstrM02", "fstrM002", "fhrm02", "fstm2", "fstM2", "fstrp1", "fstrmr2", "fstrp2", "fstrmr02", "fstm0", "fstrms2", "fstrms0", "fstM0", "fhrm002", "fstrm02", "fhrms2", "fhrm2", "fstrm1", "fstrms1", "fstrmr002", "fstrM1", "fhrms02", "fstrM0", "fstrms002", "fstm1", "fhrm1", "fstrms02", "fhrms1", "fstrm0", "fstrM2", "fhrms002"], "ostrm": ["obrm", "ophm", "ostm", "oscrm", "odmr", "ophmr", "odrt", "oscmr", "oodrob", "obmr", "ostrt", "istmr", "othermr", "istrt", "odm", "obsrem", "otherrm", "oodrem", "istrom", "ostmr", "obrom", "ooprm", "odrm", "obsrm", "istrm", "ooprom", "oscm", "ostrom", "ophrt", "oodrt", "otherrom", "otherrt", "oopmr", "obsrt", "ooprt", "obrt", "oscrt", "ostrob", "ostrem", "oodrm", "obsrob", "ophrm"], "docFile": ["documentFile", "documentF", "DocDir", "documentFiles", " docDir", "documentDir", "DocF", " docFiles", "docFiles", " docF", "docDir", "docF", "DocFiles", "DocFile"]}}
{"id1": "18374598", "id2": "6840241", "code1": "    private synchronized File download() throws AMSpacksException {\n        String a = addr.url.toExternalForm();\n        int p = a.lastIndexOf('/');\n        if (p < 0) {\n            p = a.lastIndexOf('\\\\');\n        }\n        if (p < 0) {\n            a = \"\" + Math.random();\n        } else {\n            a = a.substring(p + 1);\n        }\n        File td = null;\n        try {\n            td = File.createTempFile(a, \"\").getParentFile();\n        } catch (IOException ex) {\n            td = new File(\".\");\n        }\n        File f = new File(td, a);\n        td.delete();\n        long total = addr.update.getSize();\n        int progress = 0;\n        try {\n            InputStream in = new BufferedInputStream(addr.url.openStream());\n            FileOutputStream out = new FileOutputStream(f);\n            byte[] buf = new byte[500];\n            int n;\n            long percentage = 0;\n            callback.updateProgress(percentage);\n            do {\n                n = in.read(buf);\n                if (n > 0) {\n                    out.write(buf, 0, n);\n                    progress += n;\n                    long tmpPercentage = progress * 100 / total;\n                    if (percentage != tmpPercentage) {\n                        percentage = tmpPercentage;\n                        callback.updateProgress(percentage);\n                    }\n                }\n            } while (n > 0);\n            in.close();\n            out.flush();\n            out.close();\n        } catch (Exception ex) {\n            f.delete();\n            throw new DownloadFailedException(\"Error downloading update.\", ex);\n        }\n        long size = f.length();\n        String checksum = CheckSumFinder.checkSum(f);\n        if (size == addr.update.getSize() && checksum.equalsIgnoreCase(addr.update.getChecksum())) return f; else {\n            f.delete();\n            throw new CheckSumMismathchException(\"Checksum mismatch: \" + addr.update.getChecksum() + \" expected but was \" + checksum);\n        }\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 0, "substitutes": {"download": ["setup", "write", "open", "load", "Download", "filename", "output", "update", "string", " Download", "external", "upload", "diff", "pull", "loader", "name", "dump", "archive", "data", "file", "transfer", "release", "get", "exec", "install", "url", "copy"], "a": ["aw", "action", "base", "za", "ga", "tta", "fa", "ba", "am", "audio", "aux", "ma", "input", "art", "sa", "at", "alpha", "ua", "ca", "ada", "area", "l", "b", "A", "ata", "api", "auto", "asa", "url", "string", "da", "array", "c", "about", "aa", "r", "amp", "wa", "pa", "access", "t", "au", "ea", "ad", "an", "cha", "addr", "ppa", "va", "na", "as", "name", "la", "ae", "ac", "sta", "ha", "data", "oa", "file", "af", "e", "qa", "u", "i", "m", "ab", "aaa", "ast", "s"], "p": ["np", "pat", "j", "o", "dp", "q", "po", "w", "ap", "py", "pre", "P", "ping", "api", "b", "l", "jp", "pr", "bp", "after", "pi", "pp", "sp", "c", "pe", "pos", "pa", "t", "d", "op", "part", "v", "x", "fp", "y", "ip", "start", "h", "tp", "e", "u", "i", "cp", "m"], "td": ["dd", "nd", "th", "fr", "tt", "det", "pt", "fa", "ud", "dc", "lf", "dat", "fm", "ht", "tn", "pc", "hd", "ff", "aff", "rt", "fc", "table", "b", "ld", "cd", "tl", "rd", "txt", "cf", "gb", "buff", "tif", "t", "fd", "tr", "d", "fb", "bd", "dt", "sb", "elt", "fp", "od", "sd", "bt", "tmp", "pb", "tf", "tc", "file", "dh", "af", "pd", "sf", "TD", "dl", "db", "ppa"], "f": ["fo", "j", "base", "o", "fr", "feed", "of", "fast", "fa", "form", "lf", "w", "fm", "F", "function", "ff", "fen", "fe", "fi", "aff", "fw", "fc", "xf", "l", "b", "uf", "info", "full", "c", "rf", "r", "cf", "g", "buffer", "t", "fd", "d", "fb", "handler", "fl", "v", "df", "flat", "fp", "fs", "fx", "tf", "h", "fold", "fam", "file", "fn", "e", "sf", "u", "i", "bf", "m"], "total": ["num", "reported", "base", "temp", "nt", "done", "current", "cost", "json", "available", "active", "quant", "serial", "count", "local", "full", "post", "info", "now", "scale", "set", "percent", "recent", "ok", "next", "doc", "otal", "Total", "upload", "used", "finished", "all", "length", "start", "sum", "server", "valid", "last", "error", "complete", "normal", "partial", "parent", "max"], "progress": ["err", "np", "Progress", "num", "resource", "vance", "done", "current", "coll", "step", "content", "cost", "grade", "skip", "active", "count", "process", "rec", "conn", "status", "scale", "summary", "c", "running", "dist", "resp", "path", "success", "next", "recent", "width", "number", "length", "xp", "bar", "roll", "error", "complete", "wait", "partial", "rss"], "in": ["ini", "kin", "login", "o", "stream", "gin", "inner", "inn", "input", "In", "l", "b", "bin", "url", "c", "pin", "r", "IN", "again", "ie", "source", "nin", "io", "v", "cin", "ins", "as", "lin", "init", "ac", "con", "data", "isin", "i", "win", "reader", "vin", "din", "socket", "inc"], "out": ["err", "flow", "log", "o", "inner", "to", "w", "up", "cache", "output", "b", "bin", "conn", "extra", "full", "cb", "ch", "url", "update", "c", "code", "buffer", "again", "outs", "line", "conf", "io", "v", "Out", "client", "ins", "off", "ext", "co", "data", "file", "fn", "parent", "call", "callback", "error", "ex", "inc", "exec", "obj", "s"], "buf": ["wb", "cmd", "box", "raw", "ba", "uno", "ff", "feat", "queue", "bag", "area", "uf", "b", "bytes", "bin", "cb", "pad", "cap", "bh", "bp", "cf", "buff", "border", "buffer", "rc", "padding", "fb", "bf", "Buff", "v", "fp", "tmp", "auc", "loc", "data", "cv", "callback", "pkg", "rb", "bc", "seq", "grab", "br", "uc", "header"], "n": ["z", "np", "num", "j", "nb", "o", "nor", "br", "N", "current", "coll", "w", "none", "nc", "skip", "net", "ns", "ne", "count", "l", "b", "un", "pos", "c", "r", "g", "sn", "d", "node", "not", "en", "len", "nr", "x", "min", "nn", "number", "network", "v", "length", "cn", "nit", "fn", "dn", "rn", "e", "u", "no", "i", "error", "ng", "non", "m"], "percentage": ["percentability", " percentile", "percentrage", "missay", "percentile", "metile", "variide", "parager", "metay", "poundability", "percentide", "Percentile", "percentager", "poundage", "variay", "Percentager", " percentency", "percentency", "percentity", "Percentages", "varirage", "variile", "metage", "latide", "metency", "latage", "variage", "metages", "missage", "parage", "Percentency", "metrage", "compity", "Percentage", "latay", " percentages", "voltages", "parages", "percenture", "parile", "poundages", "voltager", "pardages", "percentages", "variity", "latity", "compay", "compage", "pardure", "pardage", "pardability", "Percentability", "voltage", "poundure", "percentay", "missile", "compide", "Percenture", "voltile", "missrage"], "tmpPercentage": ["cpppercentment", "tmppercentment", "temppercentle", "tmpCompages", "tmppercentages", "tmppercentag", "ptypercentag", "tmpPassency", "temppercentency", "tmpPercentle", "tmpPassment", "tmpMagnrage", "ptypercentency", "tmpPassag", "tmppercentency", "tmpPassage", "tmppercentrage", "tmpPassile", "ptypercentage", "ptyPercentile", "tmpPercentag", "tmpPercentment", "ptyPercentag", "cpppercentrage", "cppPercentage", "ptyPercentency", "tmppercentle", "cpppercentay", "tmppercentay", "tmpComple", "tmpPercentrage", "temppercentages", "tmpMagnage", "cppPercentrage", "cppPercentment", "tmpPercentay", "tmpHalfile", "tmpPassay", "tmpMagnment", "tempPercentage", "tmpMagnay", "tmpPercentages", "tempPercentages", "tmpHalfency", "tmpHalfage", "temppercentage", "tmpHalfag", "tempPercentency", "tempPercentle", "tmpCompency", "tmpPercentency", "tmpPercentile", "cpppercentage", "tmpCompage", "cppPercentay", "tmppercentile", "tmppercentage", "ptyPercentage", "tmpPassrage", "ptypercentile"], "size": ["fee", "ize", "esc", "unit", "send", "offset", "capacity", "content", "grade", "sec", "ne", "count", "speed", "scale", "code", "c", "external", "core", "sn", "rc", "sized", "len", "width", "small", "length", "SIZE", "name", "clean", "sum", "data", "e", "Size", "error", "empty", "i", "time", "loc", "max", "address"], "checksum": [" Checksme", "cksam", "ckssum", " checksal", "getsum", "getsam", "getsumm", "timesums", "checkum", " checksig", "cksums", "cksumm", "timesig", "getssum", " checksumm", "checksam", "checksig", " checksme", "checkssum", "checksal", " Checksal", "cksum", "checksme", "checkme", " Checkssum", " Checksum", " checksums", "checksumm", "timesum", " checksam", "checkal", " checkssum", "checksums", "cksig", "timessum"]}}
{"id1": "11183087", "id2": "11005804", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"doPost": ["doPOST", "handleSearch", "doingPost", "handlePOST", "handlePost", "doingPOST", "handlePut", " doSearch", "doingPut", "doSearch", "doPut", " doPut", "doingSearch", " doPOST"], "request": ["image", "model", "right", "resource", "q", "create", "child", "view", "current", "event", "forward", "input", "order", "project", "req", "http", "message", "have", "use", "rate", "queue", "info", "post", "QUEST", "object", "remote", "application", "rf", "pe", "r", "initial", "route", "subject", "external", "state", "buffer", "query", "join", "Request", "er", "hello", "type", "result", "frame", "pull", "client", "context", "xml", "report", "the", "server", "user", "data", "e", "call", "parent", "instance", "error", "press", "web", "complete", "enter", "get", "config", "url"], "response": ["onse", "body", "model", "pool", "resource", "site", "view", "Response", "http", "message", "output", "api", "writer", "respond", "object", "page", "status", "application", "resp", "next", "result", "client", "report", "server", "document", "guide", "parent", "results", "res", "connection", "template", "web", "reply"], "senha": ["renha", "senwa", " senwa", "senlah", "zenha", "senhi", "tonHa", "zenca", " senca", "sanwa", "tonwa", "renaka", "zenhi", "sensha", "senla", "tonlah", "senaka", "suithi", " senaka", "sanha", "tonha", "snha", " senHa", "snsha", "suitsha", "zenHa", "zensha", "suitha", "zenaka", "sanHa", "sanlah", "suitla", "senca", "renca", "senHa", "zenla", "renHa", "snla", " senlah", "snhi"], "email": ["letter", "model", "mail", "service", "login", "office", "account", "Email", "mobile", "alias", "zip", "message", "label", "password", "environment", "home", "string", "example", "hello", "phrase", "line", "secret", "ip", "xml", "business", "name", "language", "server", "data", "file", "id", "user", "e", "username", "fax", "url", "address"], "messageDigest": ["messageDigher", "messageDest", "messageDigester", "messageMailester", " messagedigEST", "messageDher", "meDigEST", "messageDigEST", "messagedigend", "meDigester", "messageMailest", "medigEST", "messageMailEST", "medigher", "medigester", " messagedigester", " messageDigester", "meDigest", "medigest", " messageDend", " messageDest", "messageDend", "messageDester", "messagedigEST", "messagedigher", " messageDigend", " messageDEST", "meDigher", " messagedigest", "messagedigester", "messageDigend", "messageDEST", "messageMailend", " messageDester", "messagedigest", " messageDigEST"], "usuario": ["suuario", "usuarium", "ususariat", "usuillo", "ussuario", "ussuasio", "usueillo", " usuarium", " usuasio", "usguillo", "usituario", " usuiasio", "ususarius", "ussuarium", " usuiarium", "ususillo", "sulurio", "usuariat", " ususillo", " usuariat", "usueario", "usguarius", "usueariat", " usuarius", "usluario", "usuitario", "usuearius", " usuiario", "usuitasio", "usituarial", "usuitrio", "usguario", " usuirio", "uslurio", " ususariat", "usuarial", "suluasio", "usuarius", "usluasio", "usuiarium", "suuasio", " usuillo", "usuirio", "usuitarium", "usuiasio", "suurio", "usluarial", "usguariat", "suluarial", " usurio", "usuiario", "usurio", " ususario", "ussurio", "usuasio", "ususario", " ususarius", "suuarial", "usituasio", "ussuarial", "suluario", "usiturio"], "redirect": ["Redurl", "redrict", "predirection", "indirect", "predroute", " redition", "Redrict", "Redition", "predirect", "redirection", " redRECT", " redurl", "preduce", "Redroute", "Redirect", "RedRECT", " redirection", "induce", " reduce", "edurl", "indrict", " redrict", "reroute", "edirection", "predrict", "edition", "Redirection", "reirection", "redRECT", "rerict", "reirect", "reduce", "redroute", "predRECT", "edirect", "redition", "redurl", "indirection"], "session": ["image", "service", "child", "system", "site", "storage", "view", "event", "input", "group", "http", "message", "cache", "use", "info", "object", "page", "sp", "flash", "state", "query", "node", "result", "ession", "client", "cookie", "Session", "app", "sid", "ssl", "proxy", "server", "data", "user", "document", "browser", "comment", "sl", "person", "connection", "config"]}}
{"id1": "15645004", "id2": "15351863", "code1": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"unzip": ["Unarchive", "unpatch", "Unress", "unarchive", " unpatch", "Unzip", " unress", "freezip", " unarchive", "freeress", "freepatch", "freearchive", "Unpatch", "unress"], "filename": ["File", "folder", "prefix", "wl", "sheet", "metadata", "download", "json", "zip", "journal", "queue", "l", "via", "string", "txt", "files", "fd", "path", "kl", "Filename", "upload", "uri", "SourceFile", "out", "fp", "FILE", "il", "xml", "manager", "nil", "name", "location", "socket", "ssl", "loader", "word", "archive", "file", "binary", "fn", "document", "username", "iterator", "database", "connection", "source", "f", "url", "directory"], "in": ["ini", "kin", "ilo", "login", "impl", "inner", "gin", "inn", "arin", "input", "In", "zip", "cache", "rec", "bin", "info", "pin", "IN", "zin", "orig", "again", "ie", "oin", "source", "nin", "line", "io", "cin", "out", "ins", "is", "into", "lin", "ssl", "inas", "internal", "inside", "con", "ln", "isin", "file", "i", "win", "reader", "vin", "afi", "fin", "din", "obj", "inc"], "entry": ["ident", "image", "lc", "de", "folder", "log", "draft", "module", "section", "feed", "ga", "service", "child", "office", "inner", "je", "install", "ry", "parse", "zip", "Entry", "parser", "exp", "key", "info", "object", "auto", "page", "url", "string", "element", "ace", "path", "next", "ie", "part", "line", "record", "si", "ent", "it", "container", "entity", "row", "out", "country", "article", "name", "internal", "ge", "archive", "server", "file", "jo", "id", "cell", "iterator", "reader", "database", "enter", "or", "connection", "source", "plugin", "obj", "inc", "directory"], "first_entry": ["first_element", "first_enter", "empty_section", "firstxreader", " first_reader", " first_element", "empty_enter", "first_ent", "first_Entry", " first_zip", "first_zip", " first_ent", "firstxEntry", "empty_ent", "first_section", "empty_entry", "firstxentry", "first_connection", " first_Entry", "firstxconnection", " first_connection", "first_reader"], "subdir": ["subdb", "Subfile", "singdir", "ubdir", "singclass", "ubfile", "partdirectory", "ubdb", "Subdirectory", "superDir", "Subdist", "subdist", "partfile", "partDir", "ubDir", " subdirectory", "partdir", "ubclass", "singdb", "superdir", "singDir", "subdirectory", "superfolder", " subclass", " subdb", " subDir", " subfile", " subdist", "ubfolder", "Subdir", "ubdist", "ubdirectory", "subfile", "subDir", "superfile", "SubDir", " subfolder", "subclass", "subfolder"], "dir": ["folder", "log", "base", "dr", "module", "DIR", "prefix", "done", "root", "coll", "direction", "domain", "window", "target", "group", "http", "zip", "ir", "area", "finder", "wd", "Directory", "home", "dist", "spec", "rc", "path", "sort", "db", "doc", "div", "uri", "build", "diff", "Dir", "manager", " directory", "tree", "du", "mod", "id", "file", "lock", "desc", "pkg", "iter", "lib", "loc", "host", "parent", "url", "draft", "directory"], "outfile": ["infiles", "execdir", "inurl", "execf", "Outdir", "outf", "indir", "Outf", "Outurl", "outFile", "fullfile", " outFile", "outfiles", "outpath", "Outfiles", "inFile", "fullf", "fullfolder", "execfolder", "exdir", "outfolder", "exurl", "outputFile", "outputpath", "Outfolder", "exfile", " outfiles", "outputdir", "outurl", " outfolder", "execfile", " outf", "exFile", "outputfile", "OutFile", "fulldir", "infile", "Outpath", "inpath", "Outfile"], "outdir": ["indir", "Outdir", "outputdirectory", " outDir", "outfolder", "outputfolder", "Outdirectory", "indirectory", "Outfolder", "outDir", "outputdir", " outfolder", "infolder", " outdirectory", "outputfile", "OutDir", "inDir", "outdirectory", "infile", "Outfile"], "fo": ["bo", "o", "osa", "FO", "po", "mo", "gio", "prof", "info", "tra", "olo", "so", "obo", "oo", "ro", "oe", "zo", "op", "flo", "ao", "io", "ho", "os", "iso", "bis", "co", "ko", "jo", "fam", "lo", "wo", "ob", "ico", "obj"], "bos": ["bo", "zos", "osa", "kos", "ops", "bits", "dos", "osi", "lins", "mos", "bas", "bin", "so", "gb", "obo", "rows", "obs", "ubis", "outs", "zo", "bes", "flo", "ros", "bi", "os", "oss", "uds", "fs", "bott", "iso", "bis", "oS", "ko", "oops", "bs", "opus", "lo", "ob", "ios", "tis", "oos", "fits", "bc", "bh", "los", "aos", "obi"], "read": ["index", "create", "feed", "send", "raw", "end", "shape", "child", "current", "check", "tell", "write", "input", "scan", "open", "skip", "find", "parse", "load", "count", "run", "Read", "add", "text", "use", "sync", "play", "reads", "ride", "fill", "pos", "c", "pe", "buffer", "pass", "readable", "next", "ind", " load", "en", "io", "allow", "x", "ip", "length", "start", "size", "pack", "READ", "e", "level", "call", " Read", "put", "connect", "transfer", "i", "reader", "get", "n", "wait", "seek", "select", "inc", "copy"], "data": ["body", "image", "raw", "feed", "dat", "input", "write", "alpha", "load", "message", "cache", "ada", "slice", "bin", "bytes", "pad", "style", "da", "aa", "buffer", "next", "d", "DATA", "result", "number", "response", "block", "length", "start", "memory", "size", "str", "zero", "reader", "no", "results", "one", "value", "empty", "batch", "i", "address"], "read_position": ["read_limit", " read_length", "read_pos", " read_pos", "read_length", " read_limit"]}}
{"id1": "12380475", "id2": "149935", "code1": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"transport": ["transprocess", "ranspoint", "protprocess", "ransports", "ransprocess", "ransporter", "protmission", "transpoint", " transporter", "ransport", " transpoint", "protport", "transporter", "ransmission", " transports", "protports", " transprocess", "transmission", "protpoint", "protporter", " transmission", "transports"], "file": ["File", "image", "log", "model", "base", "folder", "resource", "service", "change", "stream", "content", "project", "ile", "entry", "channel", "http", "cache", "local", "filename", "queue", "use", "full", "info", "object", "auto", "page", "url", "string", "class", "route", "path", "handler", "single", "db", "type", "line", "io", "out", "fp", "handle", "dir", "FILE", "name", "socket", "server", "data", "document", "user", "e", "comment", "reader", "connection", "source", "parent", "f", "directory"], "files": ["books", "boxes", "objects", "keys", "phones", "flows", "lines", "ls", "thumbnails", "blocks", "events", "views", "iles", "facts", "headers", "images", "Files", "ions", "cells", "issues", "items", "fs", "dir", "ins", "ums", "users", "ups", "models", "pes", "features", "pages", "bs", "sites", "names", "classes", "balls", "results", "f", "s"], "i": ["ini", "mi", "index", "j", "o", "chi", "oi", "end", "hi", "ii", "slice", "key", "b", "info", "ui", "ri", "pi", "c", "abi", "d", "li", "k", "ci", "p", "multi", "si", "xi", "io", "it", "uri", "v", "x", "ai", "ni", "ip", "col", "h", "ti", "id", "e", "u", "f", "vi", "n", "di", "m", "I"], "inChannel": ["outchannel", "InCh", "outFile", "inChan", "outMessage", "inFile", "inStream", " inchannel", "InChan", "inputStream", "InFile", "inCh", "inputChannel", " inChan", "InMessage", " inFile", "inputChan", " inStream", " inCh", "outStream", "Inchannel", "InStream", "InChannel", " inMessage", "inchannel", "inputCh", "inMessage"], "outChannel": ["inConnection", " outStream", "outchannel", "ioChannel", "ioHandler", "inChan", "inStream", " outchannel", "inHandler", "OutStream", "Outchannel", "ioChan", "outChan", "outHandler", " outChan", "outStream", "OutChannel", " outHandler", "ioConnection", " outConnection", "inchannel", "OutChan", "outConnection"]}}
{"id1": "5237257", "id2": "23452437", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"download": ["log", "register", "submit", "open", "paste", "zip", "load", "run", "process", "Download", "output", "update", "url", "upload", " downloading", "start", "report", "pack", "dump", "archive", "file", "transfer", "complete", "delete", "select", "exec", "release"], "fileName": ["FileUrl", "FileDirectory", " fileFolder", "fileType", "FileFolder", "resourcePath", " fileDirectory", "FilePath", "fileFolder", "FileName", " fileUrl", " fileType", "resourceDirectory", "FileCode", "resourceName", "fileDirectory", "fileUrl", "resourceType", "fileCode", "resourceCode", "resourceFolder", "resourceUrl", "FileType", " fileCode"], "filePath": ["resourceFile", "Filepath", "FileFile", "resourcepath", " filePart", "resourcePath", "FilePart", "FilePath", "filePart", " fileFile", "FileName", "resourcePart", "fileLocation", "FileLocation", " fileLocation", "resourceName", "fileFile", "filepath", " filepath", "resourceLocation"], "in": ["re", "err", "ini", "image", "login", "resource", "this", "inner", "gin", "inn", "input", "cgi", "In", "up", "sync", "l", "bin", "b", "url", "spin", "pin", "r", "IN", "again", "work", "source", "nin", "io", "cin", "x", "issue", "ins", "is", "as", "lin", "name", "init", "a", "ac", "inside", "con", "id", "file", "data", "ax", "rin", "on", "isin", "i", "reader", "win", "n", "m", "din", "f", "socket", "inc", "copy"], "out": ["err", "image", "log", "base", "o", "cmd", "outer", "office", "prefix", "point", "this", "view", "inner", "to", "write", "with", "at", "In", "obj", "net", "up", "exp", "cache", "sync", "output", "OUT", "password", "bin", "writer", "conn", "extra", "url", "null", "string", "option", "IN", "lib", "again", "outs", "path", "nin", "line", "io", "x", "by", "Out", "client", "off", "name", "ext", "server", "id", "file", "user", "on", "call", "error", "ex", "one", "n", "or", "source", "exec", "socket", "copy"]}}
{"id1": "13657527", "id2": "12085127", "code1": "    synchronized List<String> getDatasetsList(String surl) {\n        if (datasetsList == null) {\n            datasetsList = new HashMap<String, List<String>>();\n        }\n        List<String> result = datasetsList.get(surl);\n        if (result == null) {\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(surl + \"?server=list\");\n                reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s = reader.readLine();\n                ArrayList<String> list = new ArrayList<String>();\n                while (s != null) {\n                    list.add(s);\n                    s = reader.readLine();\n                }\n                datasetsList.put(surl, list);\n            } catch (IOException ex) {\n                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                throw new RuntimeException(ex);\n            } finally {\n                try {\n                    reader.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return datasetsList.get(surl);\n    }\n", "code2": "    public final void navigate(final URL url) {\n        try {\n            EncogLogging.log(EncogLogging.LEVEL_INFO, \"Navigating to page:\" + url);\n            final URLConnection connection = url.openConnection();\n            final InputStream is = connection.getInputStream();\n            navigate(url, is);\n            is.close();\n        } catch (final IOException e) {\n            EncogLogging.log(EncogLogging.LEVEL_ERROR, e);\n            throw new BrowseError(e);\n        }\n    }\n", "label": 0, "substitutes": {"getDatasetsList": ["getDatAsetSearch", "getDatasetlist", "getDatasuresSearch", "getDatasetsSearch", "getDatasetSearch", "getDatasenciesList", "getDatAsetList", "getDatasetList", "getDatasureslist", "getDatAsetsSearch", "getDatAsetlist", "getDatAsetsList", "getDatAsetslist", "getDatasencieslist", "getDatasenciesSearch", "getDatasuresList", "getDatasetslist"], "surl": ["Slog", "sUrl", "lsUrl", "sURL", "jssl", "tsl", "sinurl", "nsuri", "wsurl", " shttp", "Sfeed", "slog", "sllog", "dsuri", "sinfeed", "nsurl", "dsurl", "duri", "Surl", "jsuri", "jsurl", "turi", "nsfile", "SURL", "sesurl", "dlayer", "slurl", "ssuri", "slrule", "jslayer", "wsuri", "osurl", "wslayer", "osuri", "tfile", "suri", "dsfile", "osfile", " sURL", "SUrl", "Srule", "ssjob", "nsjob", "ssurl", "sinlog", "sesfile", "shttp", "sjob", "durl", "dsl", "lsURL", "ssl", "lshttp", "slfeed", "sfile", "turl", "lsurl", "dssl", "ossl", "sfeed", "srule", "slayer", "ssfile", "sinrule", "Shttp", " sUrl", "sesjob", "sesuri", "wssl"], "datasetsList": ["datasetsTable", "datasetsCollection", "datascetsString", "datasagesCollection", "datrasetsL", "datrasureslist", "datasiteslist", "datastersCollection", "datasETSPool", "datrasetsMap", "datascencesCollection", "datasureslist", "datastersString", "datassetsMap", "dataschesList", "datrasuresList", "datasetlist", "datrasuresMap", "datasagesPool", "dataschesMap", "datasitesL", "datassetsList", "datetsetsList", "datrasETSMap", "datrasuresL", "datasETSMap", "datasETSlist", "datasuresList", "dataselinesTable", "datetetslist", "datrasetsList", "datassETSPool", "datasetslist", "datastersList", "datrasetsTable", "datasetMap", "datascencesList", "datascheslist", "datasetsL", "datasencesList", "datascencesMap", "dataschesTable", "datassETSMap", "datetsetsMap", "dataselinesList", "datasitesList", "datastersMap", "datrasETSList", "datetetsMap", "datasetsString", "datassetsL", "datassetsPool", "datasetL", "datasuresCollection", "datasuresMap", "datasetsPool", "datetetsL", "datetsetsL", "datascencesString", "datassetslist", "datassetsCollection", "datassETSList", "datasagesMap", "datasitesMap", "datetetsList", "datascetsList", "datasETSTable", "datasETSCollection", "datrasETSTable", "datasETSList", "datasetList", "datetsetslist", "datasuresL", "datascetsMap", "datascetsCollection", "datrasetslist", "datasencesMap", "datasagesList", "datasencesString", "datasuresString", "datasencesCollection", "dataselinesMap", "datassETSCollection", "datasetsMap", "datrasETSlist", "datasETSL", "dataselineslist"], "result": ["re", "rule", "resource", "fr", "end", "Result", "found", "inner", "event", "match", "entry", "load", "message", "rar", "repl", "info", "page", "status", "r", "rc", "success", "part", "record", "ret", "row", "response", "ner", "report", "test", "request", "runner", "ge", "user", "valid", "card", "instance", "comment", "results", "res", "default"], "reader": ["err", "her", "dr", "lr", "older", "feed", "rx", "resource", "stream", "rer", "inner", "input", "over", "entry", "worker", "http", "reading", "parser", "ler", "rar", "slice", "l", "writer", "ger", "read", "driver", "builder", "r", "buffer", "oder", "handler", "er", "io", "rr", "row", "layer", "ner", "loader", "cher", "ssl", "runner", "roller", "server", "file", "ser", "Reader", "per", "i", "keeper", "iter", "upper", "editor"], "url": ["rule", "image", "log", "URL", "base", "lr", "resource", "feed", "service", "stream", "Url", "entry", "hub", "http", "l", "b", "page", "string", "element", "driver", "bel", "buffer", "io", "uri", "client", "ur", "loader", "socket", "ssl", "server", "user", "file", "ll", "browser", "str", "sl", "iter", "connection", "source", "f", "address"], "s": ["o", "comments", "site", "abs", "ops", "ls", "lines", "services", "details", "ns", "less", "sync", "l", "b", "ws", "js", "string", " lines", "r", "spec", "ps", "t", "ds", "p", "line", "source", "si", "S", "os", "sb", "su", "ins", "is", "ses", "rs", "es", "ssl", "ings", "search", "server", "e", "ss", "sl", "u", "i", "str", "sets", "words", "n", "strings", "f"], "list": ["lc", "letter", "base", "view", "coll", "LIST", "val", "ul", "bl", "cl", "ls", "entry", "load", "queue", "key", "table", "l", "left", "string", "set", "null", "array", "collection", "li", "pl", "join", "listed", "lists", "type", "ml", "record", "and", "all", "chain", "la", "test", "server", "data", "ll", "str", "el", "default", "batch"]}}
{"id1": "4593012", "id2": "5725177", "code1": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "code2": "    @Override\n    protected <T> T execute(final HttpMethod method, final String url, Parameters parameters, final Handler<T> handler) throws FoursquareException {\n        HttpURLConnection connection = null;\n        try {\n            switch(method) {\n                case GET:\n                    connection = openConnection(url.concat(\"?\").concat(formEncode(parameters)));\n                    connection.setRequestMethod(\"GET\");\n                    connection.connect();\n                    break;\n                case POST:\n                    connection = openConnection(url);\n                    connection.setRequestMethod(\"POST\");\n                    connection.setDoOutput(true);\n                    connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                    connection.connect();\n                    final OutputStream out = connection.getOutputStream();\n                    out.write(formEncode(parameters).getBytes());\n                    out.flush();\n                    out.close();\n                    break;\n            }\n            final int statusCode = connection.getResponseCode();\n            if (statusCode / 100 != 2) {\n                final Error error = parseBody(connection.getErrorStream(), new ErrorHandler());\n                if (error == null) throw new FoursquareException(connection.getResponseMessage()); else if (\"error\".equals(error.getType())) throw new FoursquareException(error.getMessage()); else if (\"unauthorized\".equals(error.getType())) throw new AuthenticationException(error.getMessage()); else if (\"ratelimited\".equals(error.getType())) throw new RateLimitingException(error.getMessage()); else throw new FoursquareException(connection.getResponseMessage());\n            }\n            return parseBody(connection.getInputStream(), handler);\n        } catch (final IOException e) {\n            throw new FoursquareException(e);\n        } catch (final ParserConfigurationException e) {\n            throw new FoursquareException(e);\n        } catch (final SAXException e) {\n            throw new FoursquareException(e);\n        } finally {\n            if (connection != null) connection.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"upgradeSchema": ["upgradeCatalogMeta", "upgradeSchement", "upgradeDatabasement", "upgradingscheMeta", "upgradeCatalogma", "upgradeScheMeta", "upgradeCatalogmas", "upgradeDatabaseMeta", "upgradeschemas", "upgradeDatabasemas", "upgradingschement", "upgradeschema", "upgradingScheMeta", "upgradingschema", "upgradeCatalogment", "upgradescheMeta", "upgradingSchemas", "upgradingSchement", "upgradeSchemas", "upgradeDatabasema", "upgradingschemas", "upgradingSchema", "upgradeschement"], "stmt": ["stmsg", "STtm", "Stmt", "pmt", "estmt", "frmp", "STvt", "estmsg", " stmr", "stmp", "frmsg", "frmt", "stvt", "Stdb", " stmit", "Stnt", "stql", "Stmr", "pvt", "hmit", "hmp", "stmit", "estmp", "rmp", "ptm", "stnt", "hmt", "estm", "frm", "ftmp", "ftmit", "pm", "strnt", "STm", " stmsg", " stmp", "strmp", "stm", "strmt", " sttm", "rmr", "rmt", " stnt", " stvt", "hnt", "rql", "strmr", " stm", "strql", " stql", "sttm", "stmr", "strdb", "ftmt", "stdb", " stdb", "ftnt", "STmt"], "i": ["ini", "mi", "index", "j", "in", "o", "yi", "hei", "hi", "isi", "phi", "cli", "ii", "fi", "ix", "count", "slice", "api", "b", "info", "ui", "isu", "ami", "ri", "pi", "c", "r", "gi", "t", "abi", "k", "li", "ci", "ie", "p", "multi", "si", "ni", "xi", "I", "bi", "v", "uri", "ai", "x", "adi", "eni", "it", "ip", "start", "name", "esi", "qi", "ti", "id", "e", "iu", "vi", "u", "f", "n", "di", "ki", "oi", "zi"], "qry": ["quRY", "Qry", " qri", "qrc", "quri", "QRY", "quries", "querri", "qRY", "Qri", " qries", "Qrys", " qcr", " qRY", "querRY", "Qcr", "Qries", "qurys", " qrc", " qrys", "qrys", "qucr", "qury", "querrc", "qcr", "querry", "qri", "qurc", "qries"]}}
{"id1": "8430178", "id2": "4750967", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", "transferFile", "CopyFile", "transferPath", " copyfile", "Copyfile", " copyPath", "copyfile", "copyFiles", "copyPath", "CopyPath", "CopyFiles"], "source_name": ["Source_file", "source_key", "source_uri", "source_Name", "src_name", "src_file", "source_names", "sourceCname", "sourceNtype", "source_size", "source_data", "Source_data", "src_alias", "source_alias", "sourceNname", " source_Name", "Source_name", "source_type", "src_uri", "sourceNalias", "src_size", "sourceNfile", "source_path", "sourceCfile", "sourceCtype", "sourceCalias", " source_path", " source_key", " source_names", "src_type"], "dest_name": ["dest_resource", "destappnames", "dest_id", " dest_path", "destFilename", "destFilenamed", " destination_resource", "dest_none", "dest_word", " destinationFresource", " dest_none", "destflabel", "source_Name", "destRdefinition", "target_names", "destJnames", "destPmodel", "destPtype", "source_names", "dest_definition", "Dest_id", "destPpath", "destPword", "target_type", "destapptype", " dest_type", "dest_names", " dest_names", "destRName", " dest_Name", " destinationFpath", "destRpath", "destRname", " destination_name", "dest_label", "destJname", "destJword", " dest_file", " destination_path", "dest_named", "destFname", " dest_named", "Dest_name", "destFpath", "target_model", "destJName", "destFilelabel", "destfnamed", "dest_model", " dest_word", "destffile", " destinationFinfo", "source_path", " dest_label", " dest_definition", "destPnames", "destPname", "destFilefile", "dest_file", "target_name", "Dest_path", "dest_Name", "dest_type", " destinationFname", "destappname", "dest_path", "destFresource", "dest_info", "destfname", "Dest_Name", "destPName", "destFinfo", "destappmodel", " destination_info"], "source_file": ["source_url", "source_File", "ource_line", "sourcefname", "src_name", "source_class", "src_file", " source_class", "source_files", "source_stream", "source__name", "source__class", "sourceffile", "source__base", "source_base", " source_url", "sourcefFile", "source__file", "ource_file", " source_base", " source_cache", "ource_files", " source_File", "src_files", " source_files", "src_stream", "source_line", "source_cache", "sourcefurl", "ource_name"], "destination_file": ["destention_name", "destination_files", "destination_page", "destination2file", "destation_name", "destention4file", "destinate_files", "destation_folder", "destination2name", "destinationablefile", "destination_path", "destention_source", "destination4file", "destinate_base", "destination4source", "destinationablebase", "destention_path", "destation_function", "destination_folder", "destination_name", "destination_source", "destention_file", "destention4source", "destation_file", "destinationablefiles", "destention4path", "destination2source", "destinate_file", "destination4path", "destinationablepage", "destention4name", "destation_files", "destination_function", "destination4name", "destinate_page", "destination2path", "destination_base"], "source": ["image", "resources", "unit", "slave", "ize", "service", "resource", "SOURCE", "index", "site", "storage", "view", "stream", "Source", "current", "inner", "input", "open", "target", "master", "src", "cache", "load", "local", "slice", "output", "remote", "object", "scope", "ources", "via", "class", "from", "spec", "core", "single", "ource", "result", "uri", "dest", "diff", "client", "secure", "ite", "start", "name", "proxy", "search", "server", "file", "reference", "reader", "get", "connection", "config", "parent", "copy"], "destination": ["Destension", "destension", "foreigninated", "constining", "targetinate", "destinator", " destina", "targetination", "destribution", "Destination", "variinator", " destinator", "testribution", "foreigninator", "Destinated", "destina", " destining", "validination", "dependinate", "variinate", "coordination", "foreigninate", "constribution", "descinated", "testinated", "variination", "Destinator", "identination", "validinator", "testinator", "variinated", "identribution", "identinated", "Destining", "coordinated", "dependination", "targetinator", "destinate", "destinated", "testination", "descination", "constination", "coordension", "identina", "dependinator", "foreignination", "constinator", "Destina", " destinated", "coordinator", "dependinated", "Destribution", " destribution", "descinator", "destining", "validinate", "targetinated", "descension", "validinated"], "buffer": ["image", "pool", "temp", "flush", "sequence", "input", "window", "channel", "text", "cache", "queue", "writer", "bin", "buf", "buff", "Buffer", "padding", "uffer", "block", "binary", "transfer", "limit", "reader", "timeout", "iter", "batch", "memory", "header"], "bytes_read": ["bytesUnRead", "Bytes_set", "bytesUnread", "bytes_set", "bytesUnset", "Bytes_found", "bytesUnfound", "bytes_found", "Bytes_read", "Bytes_Read", "bytes_Read"], "in": ["ini", "image", "re", "log", "resource", "login", "temp", "serv", "stream", "inner", "current", "inn", "val", "input", "din", "In", "fe", "rec", "l", "bin", "b", "read", "r", "IN", "session", "again", "token", "path", "p", "doc", "line", "nin", "container", "min", "out", "ins", "is", "as", "ssl", "a", "request", "con", "h", "data", "file", "id", "lock", "reader", "get", "n", "or", "connection", "f", "url", "inc", "s"], "response": ["re", "body", "onse", "image", "model", "answer", "resource", "feed", "question", "view", "sequence", "Response", "respons", "json", "version", "reason", "offer", "text", "message", "reset", "output", "api", "respond", "object", "update", "status", "example", "string", "application", "r", "resp", "next", "success", "line", "result", "uri", "su", "report", "received", "request", "server", "data", "true", "error", "description", "value", "res", "location", "reply", "dict", "header"], "parentdir": ["parentDir", "parentdict", "parentfile", "partlib", " parentdirectory", "rootdir", "parentsDir", "partdirectory", "Parentdir", "parentdiff", "hostdirectory", "rootfile", "partfile", " parentdict", " parentfile", " parentlib", "partdir", "parentlib", "parentsfile", "rootdirectory", "parentsdir", "rootlib", "homefile", "parentsdiff", "hostdir", "homeDir", "homediff", " parentDir", " parentdiff", "Parentdirectory", "homedir", "Parentdict", "hostdict", "parentdirectory"]}}
{"id1": "10218878", "id2": "3945236", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"DecodeMapFile": ["DecoderFileFile", "DecoderMapfile", "DecoderMapFile", "DecodeDataFile", "DecodeFileFiles", "DecodeFileFile", "DecodeDataFiles", "DecodemapFiles", "DecodeMapFiles", "DecoderMapFiles", "Decodemapfile", "DecodemapFile", "DecoderFilefile", "DecodeDatafile", "DecoderFileFiles", "DecodeFilefile", "DecodeMapfile"], "mapFile": ["MapFile", "filefile", "fileTable", "batchLog", "loadFile", "apperUrl", "addressFile", "batchUrl", "loadfile", "mapFull", "batchFile", "loadTable", "apperLog", "loadFull", "addressTable", "apperFile", "MapUrl", "mapLog", "addressFull", "fileFile", "mapfile", "mapTable", "addressfile", "mapUrl", "fileFull", "MapLog"], "outputFile": ["OutputFolder", "responseFile", " outputStream", "OutputFile", " outputFiles", "outputFolder", "OutputStream", "inputFolder", "outputDir", "OutputFiles", "inputDir", "inputFiles", " outputfile", " outputDir", "inputFile", "Outputfile", " outputFolder", "outputFiles", "outputfile", "responseStream", "outputStream", "responsefile", "OutputDir", "responseFiles"], "magicKey": ["MagicKey", " magickey", " magicChar", "specialKey", "prefixkey", " specialK", " specialKey", " magicK", "prefixKey", "cachekey", " specialkey", "prefixLink", "MagicK", " magicSecret", "magicLink", "magickey", "techkey", " magicKEY", "cacheSecret", "Magickey", "cacheKey", "specialkey", "cacheChar", " magicLink", "techKey", "MagicLetter", "specialChar", "magicChar", "specialSecret", "magicSecret", "magicKEY", "techLink", " magicLetter", "magicLetter", "techKEY", " specialLetter", "magicK", "prefixKEY"], "buffer": ["base", "shape", "wave", "feed", "offset", "input", "cache", "count", "message", "slice", "queue", "stack", "b", "writer", "bb", "pad", "read", "code", "buf", "array", "null", "position", "buff", "token", "uffer", "result", "row", "layer", "length", "memory", "FFER", "pause", "bar", "data", "variable", "document", "binary", "reference", "transfer", "seed", "comment", "reader", "iter", "batch", "source", "Buffer", "url", "header", "address"], "nread": [" nfind", "pwrite", " nwrite", "pRead", "Nreads", "nreader", "nwrite", "enread", "neread", "nfind", "Nreader", "enRead", " nRead", " nreads", " nload", "nereader", "Nload", "newrite", "enwrite", "enfind", "Nread", "nload", "nreads", "Nfind", "nRead", "neRead", "pload", "enreads", "pread", "Nwrite", " nreader", "NRead"], "map": ["image", "flow", "index", "pool", "resource", "wave", "module", "create", "config", "stream", "pre", "ap", "input", "write", "open", "over", "MAP", "group", "master", "parse", "cache", "maps", "message", "pair", "use", "list", "media", "bridge", "key", "pad", "code", "core", "work", "cover", "out", "layer", "client", "block", "app", "cm", "pack", "make", "apper", "data", "file", "transfer", "header", "lock", "per", "one", "m", "source", "copy", "address"], "output": ["image", "ou", "unit", "log", "model", "o", "resource", "module", "outer", "other", "ilo", "office", "global", "utils", "write", "function", "input", "target", "cache", "run", "queue", "connection", "object", "update", "page", "application", "cut", "exit", "export", "external", "core", "sort", "control", "pot", "oper", "number", "out", "response", "layer", "operation", "flow", "Output", "file", "data", "reference", "document", "put", "error", "console", "config", "web", "address"], "i": ["z", "ini", "j", "o", "in", "oi", "uli", "phi", "ii", "slice", "mu", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "t", "li", "ci", "p", "multi", "si", "io", "xi", "it", "bi", "v", "x", "ai", "ji", "uri", "ip", "length", "a", "qi", "ti", "id", "e", "u", "f", "di", "m", "I", "zi"]}}
{"id1": "14001795", "id2": "6009527", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyOverWarFile": ["copyOverwarFile", "copyOverWarFiles", "copyOverwarFiles", "copyOverWarfile", "copyOverWebFile", "copyOverwarPath", "copyOverWARPath", "copyOverWARFiles", "copyOverWarPath", "copyoverwarfile", "copyOverWebPath", "copyoverwarPath", "copyoverWarFile", "copyoverWarFiles", "copyOverWebfile", "copyoverwarFiles", "copyoverWarfile", "copyOverWARFile", "copyOverWARfile", "copyoverWarPath", "copyoverwarFile", "copyOverWebFiles", "copyOverwarfile"], "dir": ["folder", "log", "plugin", "dr", "feed", "DIR", "coll", "dc", "direction", "download", "cur", "window", "up", "group", "zip", "cache", "ir", "http", "direct", "local", "wd", "class", "def", "r", "dist", "store", "fd", "di", "d", "work", "handler", "doc", "part", "build", "df", "director", "Dir", "handle", "manager", " directory", "clean", "keep", "loc", "data", "file", "dn", "parent", "lock", "desc", "pkg", "lib", "config", "db", "md", "url", "draft", "directory"], "ff": ["dd", "ef", "flow", "feed", "ffff", "FF", "lf", "cl", "fe", "aff", "fw", "uf", "bb", "cb", "now", "TF", "fox", "buf", "pp", "cf", "fff", "buff", "rf", "cpp", "uff", "fd", "upp", "fb", "ph", "fl", "bd", "ffe", "df", "eff", "fp", " buff", "fx", "eph", "ft", "fold", "fam", "iff", "sf", "fed", "bf", "xff"], "files": ["objects", "keys", "locks", "fa", "flows", "lines", "ls", "plugins", "fe", "sections", "events", "blocks", "iles", "apps", "rows", "ps", "groups", "images", "split", "Files", "fl", "jobs", "items", "fs", "ums", "users", "models", "features", "pages", "bs", "data", "file", "names", "balls", "classes", "results", "s"], "f": ["fr", "feed", "of", "fa", "inf", "lf", "F", "fen", "fe", "aff", "fc", "filename", "l", "info", "c", "rf", "cf", "fd", "t", "d", "fb", "handler", "fl", "p", "part", "v", "x", "flat", "fp", "fs", "name", "tf", "fold", " fa", "file", "fn", "e", "sf", "i", "n", "bf", " file"], "newFile": ["nextFiles", "newFolder", "nextFolder", "NewFiles", "andDir", "NewFile", "newF", "smallfile", "nextFile", " newFolder", "updatefile", "existingfile", "existingF", "oldFile", "newDir", "NewDir", "smallDir", "oldDir", "NewF", "oldFiles", "newfile", "oldF", "NewFolder", " newLine", "existingFile", " newDir", " newFiles", "andfile", " newF", "andFile", "smallFile", "updateLine", " newfile", "nextDir", "existingLine", "updateFile", "newLine", "newFiles", "updateF"], "fi": ["ini", "afe", "fr", "ifi", "cci", "sci", "fa", "isi", "lf", "Fi", "py", "ii", "fe", "ife", "fw", "fc", "ifa", "shi", "info", "uci", "pi", "cf", "abi", "fb", "fine", "flo", "ffe", "si", "xi", "bi", "fp", "fs", "FI", "qi", "wi", "fy", "sf", "i", "afi", "ico", "fin", "zi"], "fo": ["bo", "afe", "o", "osa", "fa", "FO", "inf", "po", "fe", "fw", "mo", "ofi", "xf", "shi", "uf", "info", "tto", "olo", "so", "cf", "obo", "oo", "ato", "zo", "flo", "io", "si", "ni", "ho", "os", "co", "ko", "lo", "wo", "sf", "afi", "ico", "di", "ki", "obi"]}}
{"id1": "3252116", "id2": "13414771", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getMD5": ["getMAC3", "getMAC512", "getMD512", " getMD3", " getMD4", "getMD4", " getSHA3", "getMAC5", "getMP5", " getSHA4", " getSHA512", "getMD3", "getMP512", " getSHA5", " getMD512", "getSHA512", "getSHA5", "getMP4", "getMP3", "getSHA4", "getSHA3", "getMAC4"], "source": ["body", "base", "service", "resource", "SOURCE", "this", "stream", "Source", "content", "input", "target", "src", "text", "slice", "output", "password", "object", "string", "code", "sp", "from", "buffer", "ource", "result", "uri", "dest", "fp", "secret", "data", "file", "document", "e", "sl", "security", "connection", "config", "parent", "f", "url"], "s": ["its", "ops", "ls", "services", "ns", "ends", "als", "b", "bytes", "js", "ws", "string", "r", "g", "ps", "t", "rows", "d", "p", "ds", "si", "S", "os", "sb", "sg", "series", "fs", "ins", "is", "ses", "rs", "es", "bis", "ssl", "gs", "ings", "h", "e", "sym", "ss", "sl", "results", "n", "sets", "ts", "m", "strings", "f"], "hexDigits": ["hexdigitives", "hexdigings", " hexDigings", "tempSignites", "hashFormits", "hexdigats", "hexSignings", "hexDigats", "hexSignals", "tempDigals", "hexdigases", "hexSignitives", "hexdigits", " hexDigases", "hashDigists", "hexEdites", "hexdigites", "tempSignists", "tempDigits", "hexEdits", "hexEdals", "hexFormats", "hexDigings", "hexFormitives", "hexdigit", "hexSignits", "hexdigists", "hexFormists", "hexSignases", "tempDigites", "hexSignats", "hexDigites", "tempSignits", "hexdigals", "hexEdists", "hexDigit", "hexDigases", "tempDigists", "hexSignit", "hashDigits", "hexSignites", "hexFormits", "hexDigals", "tempSignals", "hashFormists", "hexDigists", "hashDigitives", " hexDigit", "hexDigitives", "hashDigats", "hexSignists", "hashFormitives", "hashFormats"], "md": ["dd", "nm", "mi", "sha", "mail", "cmd", "meta", "am", "dc", "dig", "amd", "ma", "um", " MD", "metadata", "hd", "mm", "mad", "mu", "cd", "wd", "mp", "vd", "mand", "bf", "bd", "pm", "df", "sm", "mg", "mac", "mt", "cm", "MD", "pd", "mag", "rm", "dm", "mc", "em", "mb", "di", "m", "rpm", "f"], "tmp": ["np", "base", "temp", "storage", "config", "pre", "area", "api", "now", "cb", "mp", "sup", "extra", "pad", "bp", "txt", "array", " temp", "sp", "buf", "buff", "pp", "params", "buffer", "cpp", "wp", "fb", "p", "cmp", "pointer", "v", "dest", "proc", "img", "bt", "app", "test", "ppo", "data", "seed", "append", "stuff", "rb", "meta", "obj"], "str": ["enc", "err", "dec", "unit", "j", "dr", "fr", "temp", "hex", "inner", "arr", "cur", "exp", "text", "sec", "exec", " substr", "STR", "ctr", "pr", "style", "string", "code", "pos", "sp", "txt", "r", "spec", "tr", "st", "stri", "dict", "doc", "div", "part", "v", "cs", "hr", "sr", "data", "char", "Str", "ss", "sl", "iter", "br", " sp", "cr", "obj"], "k": ["ek", "j", "o", "q", "ak", "unk", "ku", "sk", "w", "kid", "kat", "key", "b", "ch", "kk", "c", "g", "d", "ok", "kick", "ck", "p", "work", "v", "x", "y", "kw", "mk", "K", "ko", "dk", "id", "e", "u", "n", "ks", "ki", "f"], "i": ["z", "ini", "j", "index", "in", "chi", "oi", "hi", "phi", "ii", "mu", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "t", "abi", "li", "d", "ci", "p", "shift", "multi", "si", "io", "xi", "bi", "uri", "v", "x", "ai", "it", "ji", "y", "ip", "a", "ti", "qi", "e", "iu", "u", "f", "n", "di", "m", "I"], "byte0": ["byte2", " byte5", "word5", "pixel0", "word0", "number00", " byte6", "pixelk", "byte6", "byte1", "word1", "numberk", " byte00", " byte1", "letter00", " byte2", "letterk", "byte5", "pixel5", "number2", "number6", "pixel00", "letter2", "pixel6", "word2", "letter0", "number0", "number1", "bytek", "number5", "pixel2", "byte00"]}}
{"id1": "15241397", "id2": "335223", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", " doPut", "didGET", "handleget", "handleGet", "didGet", "didPut", "didget", " doget", "handlePut", "handleGET", "doPut", "doget", "doGET"], "request": ["image", "method", "resource", "event", "input", "req", "http", "message", "queue", "info", "QUEST", "object", "application", "initial", "subject", "buffer", "query", "Request", "er", "type", "result", "uri", "client", "context", "xml", "report", "received", "server", "data", "user", "document", "instance", "reader", "complete", "web", "connection", "url"], "response": ["onse", "body", "model", "image", "pool", "resource", "wave", "other", "site", "view", "Response", "function", "json", "version", "message", "output", "queue", "respond", "writer", "full", "object", "page", "status", "application", "collection", "resp", "session", "next", "result", "out", "client", "generation", "report", "esi", "server", "data", "document", "error", "results", "connection", "host", "parent", "reply"], "rewrittenQueryString": ["rewwrittenQueryLine", "rewrittenQuestionLine", "rewrittenUrlLine", "rewrittenQueryLine", "rewrittenQuestionArray", "rewrittenRequestService", "rewrittenqueryService", "rewrittenQueryService", "rewrittenUrlService", "rewrittenPageList", "rewrittenqueryLine", "rewwrittenRequestText", "rewrittenqueryStr", "rewrittenRequestList", "rewwrittenQueryStr", "rewrittenQuestionStr", "rewwrittenRequestStr", "rewwrittenRequestArray", "rewrittenRequestArray", "rewrittenRequestText", "rewwrittenQueryList", "rewrittenQuestionList", "rewrittenRequestLine", "rewrittenPageArray", "rewwrittenQueryString", "rewrittenqueryString", "rewwrittenQueryArray", "rewwrittenRequestLine", "rewrittenQueryList", "rewrittenQuestionText", "rewrittenPageLine", "rewwrittenRequestString", "rewrittenUrlText", "rewrittenqueryText", "rewrittenUrlString", "rewrittenPageString", "rewwrittenRequestList", "rewwrittenRequestService", "rewrittenQuestionString", "rewrittenRequestString", "rewrittenQueryText", "rewwrittenQueryText", "rewrittenQueryStr", "rewrittenQueryArray", "rewwrittenQueryService", "rewrittenRequestStr"], "rewrittenUrl": ["RewwrittenJar", "rewrittenLocation", "rewrittenText", "rewriteURL", "rewatchedText", "RewrittenServer", "rewrapedURL", "rewrittenurl", "RewrittenInt", "rerittenUr", "rewatchedURL", "rewedUr", "RewrittenText", "rewatchedUrl", "rewedurl", "rerittenURL", "rewardedUrl", "rewwrittenUrl", "rewodedURL", "rewcraftedLocation", "RewwrittenUr", "rewilledURL", "rewrapedUr", "rewrittenJar", "rewwrittenText", "rewardedJar", "rewardedLanguage", "rewwrittenServer", "rewriteText", "RewrittenFile", "rewriteUrl", "RewwrittenText", "RewwrittenInt", "rewardedFile", "rewilledUrl", "rewwrittenLocation", "rewwrittenFile", "rewmatchedurl", "rewodedLanguage", "rewodedUrl", "rewardedInt", "rewcraftedUrl", "Rewwrittenurl", "rewcraftedUr", "rewrittenInt", "rewrittenURL", "RewwrittenServer", "rewilledJar", "RewwrittenURL", "rewardedUr", "rerittenUrl", "rerittenLanguage", "rewrittenFile", "Rewrittenurl", "rewwrittenUr", "RewrittenUrl", "rewrapedFile", "rewriteServer", "RewwrittenLocation", "rewedUrl", "RewrittenUr", "rewmatchedFile", "rewardedURL", "rewodedFile", "rewardedLocation", "rewwrittenInt", "RewwrittenFile", "RewrittenLocation", "rewedURL", "RewwrittenUrl", "rewedFile", "rewatchedServer", "rewcraftedURL", "rewrapedUrl", "rewwrittenJar", "rewmatchedURL", "rewwrittenURL", "rewrittenLanguage", "rewwrittenLanguage", "rewwrittenurl", "RewrittenURL", "rewilledInt", "rewrittenServer", "rewrittenUr", "RewrittenJar", "rerittenFile", "rewmatchedUrl"], "httpURLConnection": ["httpURLCurrent", "httpGEConnection", "httpURLFlow", "httpURConn", "httpURIconnection", "HttpURLService", "httpChannelService", " httpURLSession", "httpGEConnect", "httpurlCurrent", "httpURLConnect", "HttpURLConnection", "webSSLConnection", " httpStreamconnection", " httpStreamSession", "HttpURLConnect", "httpURIConnect", "httpurlSession", "webSSLContext", "httpPathSession", "httpurlConn", "httpGEFlow", "httpURLconnection", "httpUrlClient", "httpURconnection", "httpurlConnection", "HttpChannelConnection", "apacheGEConnection", "httpPathCurrent", "HttpChannelService", "apacheURLConnection", "httpSSLClient", "httpWebConn", " httpURLCode", "httpChannelconnection", "httpUrlconnection", "apacheURLFlow", " httpStreamConnection", "apacheURLConnect", " httpURConnect", "webURLConn", "webURLClient", "httpELConnection", "webSSLClient", "httpSSLConn", "httpStreamconnection", "httpCLConn", "httpURLConn", "apacheGEConnect", "httpCLConnection", "httpChannelConnection", "httpUrlConn", " httpURLconnection", " httpStreamCurrent", "httpStreamCurrent", "httpURConnection", " httpUrlConnection", "httpURIConnection", "httpPathconnection", "httpCLCode", "httpURLService", "httpURIClient", "httpURService", " httpURConn", "httpUrlCode", "apacheGEFlow", "httpSSLConnection", "httpURIConn", " httpURLConnect", "httpStreamSession", "httpELConnect", "httpURConnect", "httpUrlConnect", "httpurlCode", "HttpChannelConnect", "webURLContext", "httpurlConnect", "apacheURLconnection", "webSSLConn", "httpGEconnection", "HttpChannelconnection", "httpSSLContext", "httpurlFlow", "webURLConnection", "apacheGEconnection", " httpUrlConn", "httpUrlConnection", "httpURLClient", "httpUrlContext", "httpurlconnection", " httpUrlCode", "httpWebConnect", " httpURLConn", "HttpURLconnection", "httpChannelConnect", " httpURLCurrent", "httpUrlService", "httpURIContext", "httpURIFlow", "httpPathConnection", " httpURConnection", "httpStreamConnection", "httpURLSession", "httpELConn", "httpURLCode", "httpWebConnection", "httpURLContext"], "header": ["rule", "her", "index", "field", "dr", "section", "outer", "event", "metadata", "function", "head", "player", "match", "entry", "channel", "consumer", "filter", "version", "master", "group", "message", "back", "pair", "key", "column", "list", "writer", "info", "queue", "bridge", "member", "after", "string", "driver", "definition", "hash", "buffer", "headers", "item", "token", "next", "handler", "er", "author", "line", "attribute", "result", "cover", "part", "director", "layer", "character", "block", "ter", "server", "data", "component", "document", "reference", "Header", "second", "comment", "feature", "date", "error", "iter", "default"], "value": ["letter", "model", "field", "child", "office", "end", "current", "content", "val", "format", "function", "json", "entry", "property", "Value", "version", "text", "message", "key", "label", "media", "info", "now", "object", "password", "string", "set", "element", "V", "option", "gi", "item", "VALUE", "hello", "type", "attribute", "sv", "v", "values", "expression", "name", "language", "server", "data", "variable", "valid", "document", "description", "comment", "get", "default", "parent"], "inputStream": ["outputstream", "resourcestream", "pullSteam", "resourceStream", "InputChannel", "pullstream", "inputstream", "InputSteam", "inputChannel", "InputStreamer", "outputSteam", "pullStreamer", "inputSteam", "outputChannel", "inputStreamer", "resourceSteam", "InputStream", "outputStreamer", "pullStream", "resourceChannel", "Inputstream"], "outputStream": [" outputFile", "outputstream", "OutputSteam", " outputSteam", "responseFile", "externalSteam", "externalStream", "OutputFile", "OutputStream", "inputstream", "responseChannel", "responseSteam", "OutputChannel", "outputSteam", " outputChannel", "externalStreamer", "inputSteam", "outputChannel", "Outputstream", "inputStreamer", "externalstream", "responseStream", "OutputStreamer", "outputStreamer", "outputFile"]}}
{"id1": "20267500", "id2": "23620712", "code1": "    public static AudioInputStream getWavFromURL(String urlstr) {\n        URL url;\n        AudioInputStream ais = null;\n        try {\n            url = new URL(urlstr);\n            URLConnection c = url.openConnection();\n            c.connect();\n            InputStream stream = c.getInputStream();\n            ais = new AudioInputStream(stream, playFormat, AudioSystem.NOT_SPECIFIED);\n            LOG.debug(\"[getWavFromURL]Getting audio from URL: {0}\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return ais;\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getWavFromURL": ["getWavForURL", "getWavefromUR", "getWaveFromUR", "getWavefromurl", "getWavForUR", "getWaveFromURL", "getWavfromUR", "getWavForurl", "getWavefromURL", "getWavFromurl", "getWavefromUrl", "getWaveFromurl", "getWavfromUrl", "getWaveFromUrl", "getWavForUrl", "getWavfromurl", "getWavFromUrl", "getWavFromUR", "getWavfromURL"], "urlstr": ["urlstring", "urlpath", " urlSTR", "urlSTR", "httppath", "fileStr", "llStr", "urlStr", " urlStr", "llSTR", "llstr", " urlpath", "lSTR", "lstring", "lstr", "httpstring", "lStr", "filepath", "filestring", "llstring", "filestr", " urlstring", "httpStr", "httpstr"], "url": ["lc", "image", "log", "URL", "lr", "resource", "feed", "www", "coll", "ul", "cl", "Url", "ls", "cur", "http", "l", "api", "ch", "b", "conn", "page", "string", "path", "li", "fl", "source", "org", "uri", "plug", "build", "ur", "oc", "ssl", "server", "file", "ll", "ob", "e", "u", "sl", "str", "rl", "connection", "loc", "host", "f"], "ais": ["audi", "oi", "ahi", "cci", "aus", "ay", "aud", "audio", " ado", "oci", " arra", "ls", "sa", "mos", "acs", "ians", " ain", "bb", " audi", "ws", "ami", "waves", "aa", "ays", "plays", " au", "au", "avi", "ait", "ci", "ds", "ras", " ads", " sax", "ai", "is", "xml", "as", "rs", " audio", "ac", "ae", "ois", " tapes", "ios", "ss", "rss", "gae", "ava", "asi", "aos", "Audio", "aaa", "ia"], "c": ["enc", "lc", "coll", "dc", "cl", "nc", "pc", "channel", "ctrl", "http", "fc", "cu", "l", "ch", "conn", "cd", "b", "api", "cb", "C", "cf", "ct", "ci", "p", "cmp", "cs", "client", "cc", "cm", "ac", "co", "a", "con", "ec", "cn", "e", "u", "mc", "bc", "cp", "connection", "m", "cr", "f"], "stream": ["video", "in", "uu", "feed", "coll", "form", "w", "audio", "input", "channel", "src", "zip", "cache", "fc", "output", "l", "b", "object", "string", "engine", "path", "d", "p", "io", "context", "cm", "h", "server", "data", "host", "e", "u", "sl", "reader", "sw", "Stream", "uc", "connection", "m", "source", "f", "s"]}}
{"id1": "20011285", "id2": "22046596", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"copy": ["link", "log", "create", "change", "clone", "share", "download", "write", "py", "paste", "cop", "load", "zip", "sync", "replace", "cat", "update", "apply", "clip", "split", "type", "upload", "opy", "Copy", "file", "transfer", "rm", "move", "delete", "get", "cp", " cp", "save"], "sourceFile": ["sourceDirectory", "sourceBook", "ourcePage", " sourcePlace", "apiFilename", " sourcePage", "ourceDirectory", "apiFile", " sourceSourceFile", "SourceDir", "sourceDir", "sourcePage", "apiFiles", "sourceFilename", "SourceBook", " sourceDirectory", "sampleFile", "ourceFiles", "sourceFolder", "sampleFilename", "ourceTime", "targetFolder", " sourceBook", " sourcefile", "sourceSourceFile", "SourcePlace", "SourceDirectory", "sampleFiles", " sourceFiles", "siteFILE", " sourceDir", "slaveFile", "sourceFILE", "slaveFILE", "SourceTime", "ourcefile", "targetPage", "SourceFile", "sourcefile", "apiFILE", "targetFile", "slaveFiles", "Sourcefile", "ourceFolder", "targetFiles", "sourceFiles", "ourceBook", "sampleFILE", "ourcePlace", "sourcePlace", " sourceFILE", "sourceTime", "siteFiles", "targetDirectory", "siteFile", " sourceFilename", "siteFilename", "slaveFilename", "SourceFiles", "SourceSourceFile", "targetDir", " sourceTime", "ourceFile", "ourceSourceFile", " sourceFolder"], "destinationFile": ["destinationFolder", "dominatorFile", "destwayFILE", "destinatefile", "targetinatedFiles", "targetinationFile", "targetinationfile", "destuationFile", "dominationFILE", "destructionfile", "destuationfile", "destinatorSourceFile", "destructionFILE", "destinatedfile", "dominatorfile", "destinationDirectory", "dominatorFILE", "destuationFILE", "dominationfile", "distructionFile", "destinatedFile", "DestinatingFile", "targetinatedFile", "distructionfile", "destinateFolder", "destinatingFiles", "distructionFILE", "desturationFiles", "destwayfile", "desturationSourceFile", "destinatingFile", "DestinationSourceFile", "DestinatingDirectory", "destinatorFile", "destinatorFILE", " destinationfile", " destinatingFolder", "destinateFile", "destinatingDirectory", "destinationFiles", "dominatorPath", " destinatingFile", "desturationDirectory", "distinationFile", "destinatorPath", "destwayFiles", "distinationfile", "destinatorFolder", "dominationPath", "destinatingPath", "DestinatingSourceFile", "destinatorDirectory", "dominatorFiles", "destinatingfile", "targetinatedFolder", "distructionFolder", "targetinationFiles", "destuationFolder", "destinationSourceFile", "destinatingFolder", "destinationfile", "destinatedFolder", "destructionFile", "destinatingSourceFile", "destinationPath", " destinationFiles", " destinatingFiles", "DestinationFile", "DestinationFiles", "destructionFolder", "destinatePath", "targetinatedfile", "dominationFile", "destinatedFiles", " destinatingfile", "destinatingFILE", "targetinationFolder", "destinatorfile", "distinationFolder", "dominationFiles", "destinateFiles", "destwayFile", "desturationFile", " destinationFolder", "DestinatingFiles", "destinatorFiles", "DestinationDirectory", "destinationFILE", "distinationFILE"], "tmp": ["np", "folder", "nb", "temp", "storage", "tab", "current", "dat", "po", "py", "mm", "zip", "cache", "mo", "slice", "area", "list", "media", "api", "bb", "mp", "sup", "page", "csv", "txt", "array", "pp", "files", "apps", "sp", "buf", "pos", "amp", "params", "t", "fb", "st", "handler", "split", "p", "cmp", "upload", "part", "v", "diff", "flat", "dest", "img", "ip", "dir", "pty", "data", "tp", "e", "rm", "vm", "stuff", "rb", "mb", "meta", "db", "obj", "ppa"], "f": ["fo", "j", "o", "fr", "this", "fa", "inf", "lf", "F", "ff", "fe", "fi", "fc", "xf", "l", "b", "info", "full", "uf", "c", "cf", "r", "rf", "g", "t", "fd", "d", "fb", "handler", "fl", "p", "conf", "io", "v", "x", "df", "fp", "fs", "fx", "tf", "file", "fn", "af", "e", "u", "bf", "m"], "i": ["lc", "j", "index", "o", "in", "oi", "hi", "ii", "fi", "ix", "key", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "d", "li", "ci", "p", "ie", "multi", "si", "xi", "io", "uri", "bi", "v", "x", "ai", "ji", "y", "ip", "start", "name", "h", "ti", "id", "qi", "e", "iu", "u", "vi", "ij", "n", "di", "m", "I", "s"], "source": ["force", "slave", "base", "service", "resource", "SOURCE", "site", "storage", "view", "stream", "Source", "current", "this", "input", "grade", "target", "src", "cache", "back", "slice", "use", "scope", "null", "from", "core", "ie", "ource", "si", "result", "io", "uri", "diff", "ce", "client", "secure", "start", "proxy", "ge", "wrapper", "server", "id", "component", "e", "sl", "reader", "get", "connection", "parent"], "destination": ["estinate", "partinator", "combination", "destinator", "Destation", "destinating", "Destination", "Destinating", " destinator", "combinating", "Destinated", "combinated", " destation", "Destinator", "generinator", "generination", "Destinate", "combinator", "generinated", "partinated", "generinate", "estinator", "estinating", "estination", "destinate", "destinated", "combinate", " destinated", "partination", "destation", "partation"]}}
{"id1": "19307120", "id2": "23510383", "code1": "    public static String sendPost(String url, String param) {\n        String result = \"\";\n        try {\n            URL httpurl = new URL(url);\n            HttpURLConnection httpConn = (HttpURLConnection) httpurl.openConnection();\n            httpConn.setRequestProperty(\"Accept-Language\", \"zh-CN\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            PrintWriter out = new PrintWriter(httpConn.getOutputStream());\n            out.print(param);\n            out.flush();\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(httpConn.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = in.readLine()) != null) {\n                result += line;\n            }\n            in.close();\n        } catch (Exception e) {\n            MsgPrint.showMsg(e.getMessage());\n        }\n        return result;\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 0, "substitutes": {"sendPost": ["postPOST", "postSub", "doPOST", "postpost", "executepost", "doSub", "executePost", "dopost", "executeSub", "sendpost", "postPost", "sendPOST", "sendSub", "doPost", "executePOST"], "url": ["link", "html", "URL", "base", "resource", "service", "feed", "www", "Url", "ls", "hub", "http", "remote", "l", "api", "full", "page", "string", "route", "path", "source", "uri", "bug", "ur", "name", "ssl", "location", "server", "file", "ll", "sl", "connection", "loc", "host", "address"], "param": ["base", "resource", "question", "temp", "prom", "ram", "input", "meter", "arm", "patch", "channel", "output", "password", "info", "object", "par", "extra", "page", "string", "params", "path", "query", "arg", "phrase", "p", "part", "proc", "name", "data", "Parameter", "Param", "comment", "error", "connection", "config", "source", "address"], "result": ["err", "answer", "resource", "Result", "found", "current", "function", "grade", "json", "expected", "match", "our", "reason", "load", "message", "output", "extra", "home", "string", "status", "array", "params", "buffer", "work", "success", "ret", "response", "report", "test", "runner", "request", "user", "data", "valid", "true", "comment", "error", "feature", "date", "results", "res", "value", "default", "description", "msg"], "httpurl": ["phpcf", " httpURL", " httpconfig", "phpUrl", "httpconfig", "httpcf", "workcf", "httpURL", "baseURL", "phpURL", "baseconfig", " httpUrl", " httpconn", "phpurl", "workconn", "phpconn", "baseurl", "phpconfig", " httpcf", "httpconn", "workURL", "workurl", "httpUrl", "baseUrl"], "httpConn": ["urlconn", "httpConnection", "webConnection", "phpConnection", "HttpExec", "HttpConnect", " httpCon", "Httpconn", "HttpConnection", "httpsConnection", "perExec", "perConnect", "webConn", "httpExec", "perconn", "httpCon", "httpsConn", "httpsCon", "httpConnect", "webCon", "webConnect", " httpconn", "HttpCon", "urlConnection", "urlConn", "phpconn", " httpConnection", "urlCon", "perConn", "HttpConn", " httpConnect", "urlConnect", "httpconn", "webconn", "phpConnect", " httpExec", "phpConn", "httpsconn"], "out": ["err", "flow", "log", "o", "outer", "temp", "prefix", "inner", "flush", "w", "write", "plain", "cli", "net", "In", "exp", "output", "OUT", "password", "writer", "conn", "b", "key", "extra", "null", "r", "again", "pass", "outs", "plus", "p", "io", "Out", "init", "word", "h", "dump", "user", "file", "ex", "n", "connection", "inc", "parent", "f", "socket", "copy"], "in": ["re", "err", "ini", "kin", "login", "serv", "stream", "inner", "inn", "gin", "input", "In", "rec", "bin", "conn", "b", "read", "pin", "r", "IN", "again", "ic", "nin", "cin", "min", "ins", "is", "into", "lin", "as", "init", "ac", "con", "rin", "isin", "id", "reader", "i", "win", "din", "f", "inc", "s"], "line": ["link", "letter", "log", "unit", "lc", "model", "end", "continue", "lf", "cl", "lines", "entry", "inline", "LINE", "text", "message", "Line", "key", "l", "page", "string", "code", "pe", "pin", "r", "job", "record", "row", "response", "ip", "block", "character", "le", "me", "name", "word", "sel", "ge", "data", "file", "id", "cell", "e", "char", "user", "str", "comment", "i", "reader", "sl", "source", "cr", "lin"]}}
{"id1": "12128591", "id2": "4852691", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"hash": ["log", " hashing", "hex", "check", "parse", "text", "add", "update", "print", "SHA", "code", "crypt", " fingerprint", "build", " hashes", "pack", "Hash", "sum", "dump", "h", "component", "str", " Hash", "get", "copy"], "data": ["body", "image", "in", "base", "hex", "content", "dat", "format", "input", "alpha", "text", "message", "cache", "output", "api", "media", "bytes", "info", "pad", "style", "string", "class", "buffer", "padding", "DATA", "p", "result", "response", "length", "memory", "missing", "name", "a", "s", "str", "value", "database", "connection", "template", "source", "address"], "digest": ["logenge", "logester", "decit", " digger", "logast", "Digenge", "Diger", "mdast", "DigEST", "mdest", "digast", "signEST", "pede", " dige", "digester", "generests", " digests", "logest", "decest", "decester", "Digester", "bigusher", "digenge", "peder", " digit", "generester", "digests", "diger", " diger", "mdester", "pedester", "mdenge", "digit", "generit", "signest", "signester", "digusher", " digusher", "bigester", "Dige", "Digger", "digEST", "Digast", " digEST", "signusher", "generest", "decests", "digger", "Digest", "bigest", "Digusher", "bigger", "pedest", "dige", " digester"]}}
{"id1": "14819747", "id2": "11952735", "code1": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 0, "substitutes": {"debug": ["enabled", "err", "log", "die", "module", "dev", "depth", " debugger", "root", "production", " Debug", "active", "DEBUG", "details", "cache", "play", "remote", "ger", "enable", " DEBUG", "github", "show", "print", "status", "display", "export", "Debug", "store", "admin", "quiet", "doc", "progress", "real", "build", "bug", "development", " debugging", "trace", "test", "reg", "dump", "develop", "file", "error", "comment", "date", "console", "config", "tag", "db", "plugin", "help"], "prologFile": ["proLogHeader", "proconfigString", " prologSourceFile", "proversionPath", "proLogPath", "prologStream", "prolangSourceFile", " proLogStream", "defblogSourceFile", " prologfile", " proLogFiles", "prologModule", "rologFile", "prolangFull", "prologDir", "propathFile", "probaseFile", "procatSource", "proLogfile", " prologStream", "ProLogModule", "prolexString", "probaseStream", "roLogfile", " prologFiles", "problogFull", "proversionFILE", "roLogFile", "PrologString", "defblogfile", "proflowSourceFile", "prollFile", "proLogString", " proLogFile", "rologPath", "prologFILE", "problogStream", "prologString", "defLogFile", " problogFile", "prologFull", "propathSourceFile", "prologFiles", "proflowFile", "proLogStream", "propathDir", "proLogFull", "problogFiles", "defLogPath", " problogFull", "propathfile", "deflogFILE", "probaseHeader", "deflogSourceFile", " problogSourceFile", "prologSource", "Prologfile", "roLogSource", "problogSourceFile", "defblogDir", " prologFull", "proLogModule", "proconfigfile", "ProLogfile", "defblogFile", "deflogPath", "prolexfile", "problogDir", "ProLogString", " proLogHeader", "defLogFILE", "proLogFiles", "ProLogFile", "proversionFile", "proflowfile", "roLogPath", "proconfigPath", "deflogfile", "problogHeader", "prolexModule", "deflogDir", "proconfigFile", "prollPath", "rologfile", "rologSource", "prolexFile", "proLogFILE", "proversionSourceFile", "prologfile", "proLogFile", "proflowDir", "prolangFile", "prollfile", "proLogSourceFile", "prologHeader", "prologSourceFile", "problogFile", "prologPath", "proLogSource", "PrologFile", "PrologModule", "prollSource", "deflogFile", "problogfile", "proconfigSourceFile", "proconfigModule", "procatFile", "prolangfile", "procatPath", "procatfile", " problogfile", "defLogSourceFile", "proconfigFILE", " prologHeader", "probaseFiles"], "targetFile": ["TargetDir", "sourceDirectory", "targetPath", "TargetDirectory", " targetFiles", "sourceDir", "TargetFile", "Targetfile", "outputDir", "sourcePath", "sourceFile", "sourcefile", "targetfile", "TargetPath", "targetFiles", "outputfile", "outputPath", " targetDirectory", "targetDirectory", "TargetFiles", " targetfile", "sourceFiles", "targetDir", "outputFile"], "source": ["body", "unit", "model", "service", "resource", "options", "SOURCE", "config", "view", "Source", "content", "format", "input", "json", "target", "parse", "src", "message", "text", "zip", "slice", "stack", "use", "scope", "style", "string", "class", "position", "session", "buffer", "type", "ource", "result", "uri", "name", "term", "proxy", "language", "data", "file", "id", "str", "sl", "i", "comment", "description", "template"], "myParser": [" myReader", "myJar", "MyProgram", " myJar", "MyParser", "yourProgram", "myReader", "MyJar", "yourJar", "yourReader", "yourParser", "MyReader"], "myProgram": ["MYProgram", "myprogram", " myPlan", "myPlan", " myMath", "yourprogram", "yourPlan", "yourParser", "MyPlan", "theprogram", "Myprogram", "MYprogram", " myprogram", "yourProgram", "MyParser", "theProgram", "theParser", "theMath", "yourMath", "MyProgram", "MYParser", "myMath"], "myVisitor": ["MyVisiter", "myExitors", "myVISIT", " myvisIT", "myExitor", " myVisitable", "myvisiter", "Myvisulator", " myVisit", "myvisitor", "myExiter", "myAudit", "myVisulator", "myvisitors", "myVISitable", "myAuditors", "myDesignIT", "myAuditor", "myVisIT", " myvisitors", "myVISit", "myVisititable", "mySignitor", " myvisitable", "myvisulator", " myvisit", "myVISitor", " myvisitor", "Myvisitor", "myVisiter", " myVisitors", " myVisIT", "MyVisitors", "Myvisiter", "myVisititors", "myvisitable", "myDesignitor", "myExulator", "myVisitors", "Myvisitors", "myVisititor", "myDesignit", "myvisit", "mySignulator", "myVisitable", "MyVisitor", "myVisit", "mySigniter", "myvisIT", "mySignitors", "MyVisulator", "myAuditable", "myVisitit", "myDesignitable"], "adapterLayer": ["acaptersContainer", "acapterLanguage", "adapterContainer", "acapterInfo", "acaptersLayer", "adaptersBuffer", "adaptersLayer", "adviceLayer", "acaptersLanguage", "adviceFactory", "adaptersInfo", "admissionLanguage", "adptionLayer", "acaptersFactory", "acapterContainer", "adptionBuffer", "adviceInfo", "adptionFactory", "adaptersContainer", "adaptersLanguage", "acapterBuffer", "acapterFactory", "adaptersFactory", "adptionInfo", "adapterInfo", "adviceBuffer", "adviceLanguage", "adapterLanguage", "acaptersBuffer", "adviceContainer", "acapterLayer", "admissionLayer", "acaptersInfo", "adapterBuffer", "adapterFactory", "admissionContainer"], "classLoader": ["Classloader", "classPath", "staticloader", "ClassPath", "classDir", "classloader", "staticPath", " classloader", "staticLoader", " classPath", " classDir", "staticDir", "ClassDir", "ClassLoader"], "adapterWriter": ["adAdapterWriter", "attapterwriter", "adAdapterwriter", "attapterWrite", "admissionWriter", "attaptersReader", "adaptersWrite", "attapterswriter", "adapterReader", "attapterWriter", "adAdapterReader", "attapterReader", "adapterwriter", "attaptersWrite", "adapterWrite", "adaptersReader", "admissionWrite", "admissionReader", "adapterswriter", "adaptersWriter", "attaptersWriter", "adAdapterWrite", "admissionwriter"], "annotationGenerator": ["annnotationGencer", "annotationgenators", "annnotationGenators", "annotationGenerators", "annotationGenercer", "annotationGator", "annnotationGeneroder", "annotationGeneroder", "annotationGators", "annotationGoder", "annotationgenator", "annotationGenator", "annnotationGenercer", "annotationGenoder", "annotationGencer", "annotationGenators", "annotationGcer", "annotationgenoder", "annotationgencer", "annnotationGenoder", "annnotationGenerator", "annnotationGenator", "annnotationGenerators"], "out": ["err", "flow", "log", "in", "cmd", "outer", "raw", "temp", "prefix", "point", "pre", "cli", "net", "up", "group", "cache", "sync", "output", "OUT", "list", "conn", "post", "page", "print", "code", "array", "store", "state", "again", "outs", "query", "line", "io", "v", "diff", "Out", "chain", "bar", "dump", "server", "user", "down", "sys", "gen", "lock", "error", "n", "parent", "obj", "copy"]}}
{"id1": "2461169", "id2": "20310134", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFileToStream", "decodeStringToString", "decodeFileAsFiles", "decodeFileAsStream", "decodeString2Files", "decodeStringToFiles", "decodeFile2String", "decodeFile2File", "decodeFileAsString", "decodeStringToFile", "decodeFile2Files", "decodeFileFromFiles", "decodeFileFromFile", "decodeFileFromStream", "decodeFile2Stream", "decodeString2File", "decodeFileToFiles", "decodeStringToStream", "decodeFileToString", "decodeFileAsFile", "decodeString2String", "decodeString2Stream"], "infile": [" infilename", "infiles", "inputfile", "outfiles", "inFile", "InFile", " instream", "minstream", "Instream", "inputfilename", "inbase", " infiles", " infp", " inFile", "minbase", "minFile", "minfile", "outfilename", "outfp", "instream", "inputfiles", "infp", "Inbase", "inputfp", "infilename", " inbase", "Infile"], "outfile": ["outputdatabase", "outFile", "inputfile", " outFile", "outpath", "outputfilename", "inFile", " outpath", "inputdatabase", " outfilename", "outdatabase", "outfolder", "outputfolder", "outputpath", "inputpath", "inputFile", " outfolder", "infolder", "outfilename", " outdatabase", "outputfile", "infilename", "outputFile"], "in": ["re", "err", "ini", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "lin", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "m", "din", "socket", "inc", "s"], "out": ["ou", "err", "log", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "obj", "channel", "In", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "pass", "outs", "work", "job", "line", "io", "Out", "client", "off", "name", "co", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "channel", "count", "cache", "slice", "queue", "b", "bytes", "bin", "bb", "null", "buf", "buff", "border", "padding", "split", "uffer", "type", "result", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "r", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "method", "model", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "open", "better", "message", "growth", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "positive", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "13362846", "id2": "10158738", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"setContenu": ["setContonenuer", "setContonenuit", "setContonenu", "setContenuit", "setContineuit", "setTenues", "setContenues", "setTonenues", "setContennu", "setContonenues", "setTenuer", "setContineuer", "setTonenuit", "setTonenuer", "setTenu", "setTenuit", "setContenuer", "setContennuit", "setContineues", "setTonenu", "setContennuer", "setContineu", "setContennues"], "contenuFichier": ["contenuFrenchier", "contenuFicheieri", "contenuPrefichier", "contenuFactoryiere", "contenuFicheer", "contenuPrefichiere", "contenuMichiere", "contenuFocher", "contenuMichier", "contenuMaffiere", "contenuFochique", "contenuFicher", "contenuFichtique", "contenuFchery", "contenuFicheery", "contenuFochiers", "contenuFicheerer", "contenuFaffique", "contenuFrenchiers", "contenuFichtiere", "contenuFochiere", "contenuFichtier", "contenuFaffiers", "contenuPFichiere", "contenuFichie", "contenuFchier", "contenuFochier", "contenuFrenchiere", "contenuMichiers", "contenuTicherer", "contenuFrencherer", "contenuMrenchique", "contenuFrenchery", "contenuPrefaffiere", "contenuPrefichiers", "contenuFichtie", "contenuMichieri", "contenuFrenchoyer", "contenuPhactoryie", "contenuMichie", "contenuFochie", "contenuFichiere", "contenuFactoryoyer", "contenuPrefaffier", "contenuMrenchie", "contenuFcherer", "contenuPrefaffiers", "contenuMichique", "contenuTicheery", "contenuFichoyer", "contenuPFochier", "contenuFichtieri", "contenuFactoryier", "contenuPrefichie", "contenuMrenchier", "contenuPhichoyer", "contenuPhactoryier", "contenuPhactoryoyer", "contenuFichieri", "contenuTicheier", "contenuFicheiere", "contenuTicheerer", "contenuPFochique", "contenuPFocher", "contenuFichique", "contenuMrenchiere", "contenuMaffieri", "contenuFaffiere", "contenuPrefaffie", "contenuFicier", "contenuFicherer", "contenuPhichie", "contenuPhichier", "contenuTicheiere", "contenuTichery", "contenuMaffie", "contenuFchiere", "contenuFactoryie", "contenuPFochiere", "contenuFichery", "contenuFrenchie", "contenuPhichiere", "contenuFichiers", "contenuFaffier", "contenuFicheie", "contenuFrenchique", "contenuMaffier", "contenuPFichier", "contenuFicheique", "contenuFaffie", "contenuFiciere", "contenuFicoyer", "contenuPFichique", "contenuFicheier", "contenuTichier", "contenuTichiere", "contenuFicie", "contenuMaffiers", "contenuFaffer", "contenuPFicher", "contenuPhactoryiere", "contenuFaffieri"], "fichierElectronique": ["fichierAdministronistic", "fichierElectronie", "fichierElectronsique", "fichierElectpronique", "fichierElectornier", "fichierAustroliques", "fichierElectronica", "fichierAdministronsical", "fichierElectroliere", "fichierElectronsica", "fichierElectolonique", "fichierElectonique", "fichierElectrons\u00e9e", "fichierElectolonica", "fichierAustroniere", "fichierElectromiques", "fichierElectroliques", "fichierAdministronlique", "fichierElectronsiques", "fichierAustroniques", "fichierElectoloniere", "fichierAdministronical", "fichierAdministronsier", "fichierElectaronique", "fichierElectroniques", "fichierElectromistic", "fichierAustroliere", "fichierElectaron\u00e9e", "fichierElectroniere", "fichierElectrolique", "fichierElectronical", "fichierElectproniques", "fichierElectrolica", "fichierElectroneiques", "fichierAustronique", "fichierAustrolique", "fichierElectromique", "fichierElectpronical", "fichierCentornier", "fichierElectronelique", "fichierAdministronsistic", "fichierCentronlique", "fichierElectron\u00e9e", "fichierElectronsier", "fichierElectoloniques", "fichierElectrolie", "fichierElectronslique", "fichierAdministronslique", "fichierElectrol\u00e9e", "fichierElectroneiere", "fichierElectonier", "fichierElectroneie", "fichierElectronsie", "fichierElectornique", "fichierCentorniques", "fichierElectornlique", "fichierAdministronsique", "fichierElectronsical", "fichierAustronier", "fichierCentornique", "fichierCentronier", "fichierCentroniques", "fichierAdministron\u00e9e", "fichierElectronistic", "fichierAdministronique", "fichierAdministroniques", "fichierAdministrons\u00e9e", "fichierElectroneier", "fichierAustrolier", "fichierElectronier", "fichierElectonlique", "fichierElectronlique", "fichierElectroneique", "fichierAdministronsie", "fichierAdministronier", "fichierElectaronier", "fichierElectpronistic", "fichierElectrolier", "fichierCentornlique", "fichierElectonie", "fichierCentronique", "fichierElectronsiere", "fichierElectronsistic", "fichierElectorniques", "fichierAdministronie", "fichierElectromical", "fichierAdministronsiques", "fichierElectaronie"], "utilisateurCourant": ["utilisationCourants", "utilisationCourante", "utilisateurApplicateur", "utilisateurApplicant", "utilisationApplicants", "utilisateurGovernants", "utilisateurApplicante", "utilisateurParticipante", "utilisateurParticipateur", "utilisationCourateur", "utilisateurCourants", "utilisationCourant", "utilisateurGovernante", "utilisationApplicateur", "utilisateurParticipants", "utilisateurParticipant", "utilisateurGovernant", "utilisationApplicante", "utilisateurCourateur", "utilisateurCourante", "utilisateurGovernateur", "utilisateurApplicants", "utilisationApplicant"], "support": ["force", "service", "bank", "system", "storage", "Library", "share", "format", "utils", "accept", "services", "facebook", "protection", "evidence", "media", "info", "concept", "ann", "summary", "supported", "push", "settings", "control", "friend", "allow", "supp", "pull", "client", "know", "util", "proxy", "knowledge", "best", "document", "compatible", "review", "pport", "respect", "feature", "contact", "Support", " Support", "config", "plugin", "help", "cover", "library"], "ficheDocument": ["infraudDoc", "ficheFeature", "foiceDirectory", "facheMatrix", "fetchDoc", "fcheDirectory", "FcheDoc", "fchaDocument", "enficheDocument", "fchedocument", "foineFeature", "foiceCatalog", "FicheDocument", "enficheCompany", "facheDocument", "enfoiceDirectory", "fchaContent", "foiceCompany", " fcheDirectory", "fcheDocuments", "fcheMatrix", "afficheDoc", "ficheMatrix", "fagueDirectory", "fielDocument", "inficheDocument", "afficheFeature", "foineDoc", "enficheDirectory", "fielDirectory", "ficheCatalog", "fichedocument", "fchaDoc", "frauddocument", "financeNumber", "friquedocument", "fcheDocument", "financeDoc", "friqueDocument", "fruitNumber", "fagueDocument", "foiceDocument", "affineFeature", "fineFeature", "fruitDoc", "financedocument", "fraudDoc", "fetchFeature", "ficheDirectory", "affineDocument", "ficheCompany", "FicheDoc", " fcheDocument", "financeDocument", "foinedocument", "fineDocument", "fruitDocument", "affineDoc", " fcheMatrix", "fielCatalog", "FicheContent", "fraudCompany", "fraudCatalog", "ficheDocuments", "fraudDirectory", " ficheDocuments", "Fichedocument", "ficheContent", "inficheNumber", "fetchDocument", "fcheDoc", "fetchdocument", "fraudDocument", "foineDocument", "Fchedocument", "affichedocument", "friqueDoc", " ficheDirectory", "FcheDocument", " fcheDocuments", "fraudNumber", "fruitdocument", "afficheDocument", "facheDirectory", "fchadocument", "enfoiceCompany", "infraudDocument", "enfoiceCatalog", "FcheContent", "fagueMatrix", "facheDocuments", "fineDoc", "infrauddocument", "fagueDocuments", " ficheMatrix", "ficheDoc", "enfoiceDocument", "enficheCatalog", "fcheContent", "fielCompany", "ficheNumber", "friqueContent", "inficheDoc", "infichedocument", "finedocument", "affinedocument", "infraudNumber"], "nomFichier": ["nomFochire", "nomFachrier", "nomWichiere", "nomVicher", "nomPhacherer", "nomFichieri", "nomNicher", "nomFiscer", "nomPrefchier", "nomFachire", "nomPichier", "nomFichtiner", "nomWchery", "nomFichery", "nomWchier", "nomFacher", "nomFichrier", "nomF\u00e9ty", "nomVchieri", "nomFichterer", "nomF\u00e9tery", "nomFchier", "nomWchiere", "nomFochier", "nomFachiner", "nomNichiller", "nomFicherer", "nomPrefichier", "nomVich\u00e8re", "nomFiscy", "nomFcher", "nomWichier", "nomPrefichire", "nomNichtiller", "nomFchy", "nomFachieri", "nomFisciller", "nomFiscier", "nomFichtier", "nomFithiere", "nomFachiere", "nomFchrier", "nomPichy", "nomF\u00e9tier", "nomPrefchrier", "nomFiqurier", "nomPrefchire", "nomPichery", "nomFichiner", "nomWichire", "nomPrefichieri", "nomFochiere", "nomVichieri", "nomPhichieri", "nomFrencher", "nomFrenchier", "nomPchy", "nomNichiner", "nomFichtiere", "nomF\u00e9tien", "nomPchien", "nomFich\u00e8re", "nomFisciner", "nomFchien", "nomFochery", "nomFchery", "nomPhichier", "nomPrefichrier", "nomFichtiller", "nomFithieri", "nomNichtier", "nomFch\u00e8re", "nomFiscien", "nomFchieri", "nomFichiller", "nomFichtieri", "nomFach\u00e8re", "nomFichtire", "nomPrefchieri", "nomWichery", "nomFichiere", "nomFichtery", "nomWchire", "nomFicher", "nomFiquieri", "nomPhichiere", "nomFachiller", "nomFichire", "nomFiquire", "nomFiquier", "nomFrenchieri", "nomPhachiere", "nomFitherer", "nomFichien", "nomPchery", "nomPichien", "nomNichtiner", "nomVchier", "nomFiscery", "nomPhicherer", "nomFchiere", "nomVcher", "nomFachier", "nomFichy", "nomFrench\u00e8re", "nomVch\u00e8re", "nomPhachier", "nomFchire", "nomFithier", "nomFacherer", "nomNichter", "nomPchier", "nomVichier", "nomNichier", "nomPhachieri", "nomFichter"], "extension": ["Extression", "Extime", "exion", "encension", "anchime", "EXTime", "exension", "encception", "exception", "anchensions", "encression", "Extception", "extression", "extensions", "encion", "exression", "extception", "extime", "Extension", "EXTension", "Extion", "Extensions", "anchension", "EXTensions", "extion"], "fichierElectroniqueExistant": ["fichierElectroniqueXist", "fichierElectroniqueexilingual", "fichierElectroniquesXist", "fichierElectroniqueExistance", "fichierElectroniqueExclusive", "fichierElectroniqueXists", "fichierElectroniqueXistant", "fichierElectroniqueExists", "fichierElectroniqueExilingual", "fichierElectroniqueSistant", "fichierElectroniqueXilingual", "fichierElectroniqueexistent", "fichierElectroniquesExivist", "fichierElectroniquesXistance", "fichierElectroniqueexistance", "fichierElectroniqueExistent", "fichierElectroniqueexists", "fichierElectroniquesExclusive", "fichierElectroniquesExists", "fichierElectroniqueexivist", "fichierElectroniquesXclusive", "fichierElectroniqueExplclusive", "fichierElectroniquesXists", "fichierElectroniqueXivist", "fichierElectroniqueExplistance", "fichierElectroniqueXistance", "fichierElectroniqueexist", "fichierElectroniqueExist", "fichierElectroniquesXistant", "fichierElectroniquesExilingual", "fichierElectroniqueSilingual", "fichierElectroniquesExistent", "fichierElectroniqueexistant", "fichierElectroniqueSistent", "fichierElectroniquesExistant", "fichierElectroniqueExivist", "fichierElectroniqueExplists", "fichierElectroniquesXilingual", "fichierElectroniqueSistance", "fichierElectroniqueexclusive", "fichierElectroniqueExplivist", "fichierElectroniqueXistent", "fichierElectroniqueExplist", "fichierElectroniqueExplistant", "fichierElectroniquesXistent", "fichierElectroniqueXclusive", "fichierElectroniquesExist", "fichierElectroniquesXivist", "fichierElectroniquesExistance"], "idIgid": ["idIgenid", "idIgID", "idEgid", "idIGids", "idIgids", "idIogids", "idEGids", "idIogbit", "idUguid", "idEGid", "idIgname", "idEgbit", "idIgmids", "idEgids", "idIguname", "idUguname", "idIgbit", "idIgenids", "idEgdid", "idUgids", "idIgnID", "idIogdid", "idIGid", "idIguid", "idIguids", "idIgudid", "idUgname", "idIggid", "idIgod", "idIgdid", "idIGbit", "idUgid", "idIgenname", "idIgnids", "idIgubit", "idUgID", "idIggID", "idIgnod", "idIggod", "idIgenID", "idIgnid", "idIggids", "idEGdid", "idIgmid", "idUguids", "idEGbit", "idIGdid", "idIogid", "idUguID", "idIgmname", "idIgmID", "idIguod", "idIguID"], "inputStream": ["outputstream", "eventStreamer", " inputLength", "inputstream", "InputSteam", "inputLength", "InputStreamer", "eventSteam", " inputThread", "eventstream", "outputSteam", " inputSteam", "inputSteam", "inputStreamer", "inputThread", "outputLength", "InputThread", "InputLength", "InputStream", "outputStreamer", "eventStream", " inputstream", "Inputstream", "outputThread"], "outputStream": ["outputstream", "OutputSteam", " outputSteam", "entityStream", "inputContext", "outputContext", "OutputStream", "inputstream", " outputContext", "entityStreamer", "entitystream", "officeSteam", "outputSteam", "officestream", "officeStreamer", "inputSteam", "Outputstream", "inputStreamer", "OutputContext", "OutputStreamer", " outputstream", "outputStreamer", "entitySteam", "officeStream"], "typeMime": ["typeMatimes", "TypeSmide", "typeSmide", "typeMide", "typeMatangle", "typeMetimes", "TypeSmimes", "TypeMimes", "typeMatide", "TypeSmime", "typeMatime", "typeSmime", "typeSmimes", "typeMangle", "TypeMangle", "typeMetime", "typeSmangle", "typeMetide", "TypeMime", "TypeMide", "TypeSmangle", "typeMetangle", "typeMimes"], "tailleFichier": [" tailleFignie", " tailleFichie", " taillefochie", " tailleFichiers", " tailleFicheie", " tailleFocher", " tailleFignier", " tailleFicher", " tailleFicheiers", " tailleFochie", " tailleFigniers", " taillefochiers", " tailleFigner", " tailleficher", " taillefocher", " tailleFicheer", " taillefichiers", " tailleFochiers", " tailleFochier", " taillefichie", " taillefichier", " tailleFicheier", " taillefochier"]}}
{"id1": "1966310", "id2": "11704429", "code1": "    public void init() {\n        super.init();\n        Runnable doActions = new Runnable() {\n\n            public void run() {\n                if (_plot == null) {\n                    _plot = newPlot();\n                }\n                getContentPane().add(plot(), BorderLayout.NORTH);\n                int width;\n                int height;\n                String widthspec = getParameter(\"width\");\n                if (widthspec != null) {\n                    width = Integer.parseInt(widthspec);\n                } else {\n                    width = 400;\n                }\n                String heightspec = getParameter(\"height\");\n                if (heightspec != null) {\n                    height = Integer.parseInt(heightspec);\n                } else {\n                    height = 400;\n                }\n                _setPlotSize(width, height);\n                plot().setButtons(true);\n                Color background = Color.white;\n                String colorspec = getParameter(\"background\");\n                if (colorspec != null) {\n                    background = PlotBox.getColorByName(colorspec);\n                }\n                setBackground(background);\n                plot().setBackground(background);\n                getContentPane().setBackground(background);\n                Color foreground = Color.black;\n                colorspec = getParameter(\"foreground\");\n                if (colorspec != null) {\n                    foreground = PlotBox.getColorByName(colorspec);\n                }\n                setForeground(foreground);\n                plot().setForeground(foreground);\n                plot().setVisible(true);\n                String dataurlspec = getParameter(\"dataurl\");\n                if (dataurlspec != null) {\n                    try {\n                        showStatus(\"Reading data\");\n                        URL dataurl = new URL(getDocumentBase(), dataurlspec);\n                        InputStream in = dataurl.openStream();\n                        _read(in);\n                        showStatus(\"Done\");\n                    } catch (MalformedURLException e) {\n                        System.err.println(e.toString());\n                    } catch (FileNotFoundException e) {\n                        System.err.println(\"PlotApplet: file not found: \" + e);\n                    } catch (IOException e) {\n                        System.err.println(\"PlotApplet: error reading input file: \" + e);\n                    }\n                }\n            }\n        };\n        try {\n            SwingUtilities.invokeAndWait(doActions);\n        } catch (Exception ex) {\n        }\n    }\n", "code2": "    public void run() {\n        RandomAccessFile file = null;\n        InputStream stream = null;\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=\" + downloaded + \"-\");\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                error();\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                error();\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            }\n            file = new RandomAccessFile(destination, \"rw\");\n            file.seek(downloaded);\n            stream = connection.getInputStream();\n            while (status == DOWNLOADING) {\n                byte buffer[];\n                if (size - downloaded > MAX_BUFFER_SIZE) {\n                    buffer = new byte[MAX_BUFFER_SIZE];\n                } else {\n                    buffer = new byte[size - downloaded];\n                }\n                int read = stream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                status = COMPLETE;\n                stateChanged();\n            }\n        } catch (Exception e) {\n            error();\n        } finally {\n            if (file != null) {\n                try {\n                    file.close();\n                } catch (Exception e) {\n                }\n            }\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (Exception e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"init": ["ini", "action", "ize", "base", "setup", "plugin", "create", "done", "prep", "open", " Init", "reset", "load", "bin", " initialize", "info", "set", "act", "clear", "initial", "core", "boot", "ci", "it", "build", "Init", "start", "close", "alloc", "pack", "clean", "construct", "initialized", "basic", "gen", "connect", "empty", "config", "exec", "conf"], "doActions": [" animationCactions", " plotAlactions", " plotAAction", " plotCaaction", " plotAlAction", " animationCaactions", " plotCactions", " animationActions", " animationCaAction", " animationAactions", " animationAAction", " plotActionaction", " animationCaaction", " plotActionctions", " plotActions", " plotActionactions", " animationAaction", " plotCaAction", " plotAaction", " plotActionAction", " plotAactions", " plotCaactions", " plotAlctions", " plotAlaction"], "_plot": ["_project", "_fit", "_log", "_chart", "_pl", "_patch"], "width": ["flow", "image", "index", "dim", "shape", "Width", "capacity", "density", "draw", "w", "duration", "write", "window", "age", "fw", "platform", "lon", "filename", "area", "widget", "writer", "space", "speed", "page", "hop", "left", "fill", "style", "fall", "border", "wp", "wa", "padding", "work", "fb", "large", "gender", "number", "pull", "wn", "length", "idth", "size", "crop", "name", "down", "layout", "weight", "port", "west", "value", "high", "amount", "wait"], "height": ["image", "th", "index", "right", "shape", "depth", "capacity", "density", "draw", "duration", "deep", "gap", "head", "window", "stroke", "alpha", "thumbnails", "resolution", "slice", "bottom", "pad", "style", "rows", "padding", "gravity", "wrap", "build", "grow", "row", "pull", "y", "ip", "length", "crop", "size", "arrow", "thin", "volume", "h", "shadow", "id", "quality", "weight", "data", "port", "level", "layout", "radius", "inches", "rank", "Height", "upper", " heights"], "widthspec": ["widthscale", " widthpec", "poolSpec", "widthSpec", "Widthspec", "sizeSpec", "sizestring", "weightSpec", "poolparse", "widthset", "poolset", "weightspec", "lengthset", "weightstring", "widthpec", "widthparse", "Widthpec", "lengthspec", "WidthSpec", "sizescale", " widthSpec", "widthstring", "weightstyle", "lengthparse", "Widthstyle", "widthstyle", "lengthSpec", "weightpec", "sizespec", " widthscale", " widthparse", " widthstring", " widthstyle", "poolspec", " widthset", "weightscale"], "heightspec": ["peatslip", "heowsync", "heetspe", "heekslip", "weowsSpec", "heatspe", "heetslip", "weightspect", "peightslip", "heightslip", "heatspec", "heckspec", "heowsspec", "heaksync", "peightspe", "heightsspec", "weightspec", "weowspec", "heightsync", "peatspe", "peightspec", "weightsSpec", "heatslip", "heowspect", "heatsync", "heetspec", "heckspect", "peatspect", "heekspec", "hecksSpec", "peightspect", "hecksspec", "heaksspec", "heatspect", "weowspect", "heightspe", "heakspec", "peightsspec", "heeksspec", "weightsspec", "peatsync", "heakspect", "heowsSpec", "heightspect", "heowspec", "heatsspec", "peatsspec", "peightsync", "heatsSpec", "weowsspec", "heightsSpec", "heekspe", "heetsspec", "peatspec"], "background": ["image", "support", "base", "pool", "resource", "ghost", "prefix", "ba", "draw", "gray", "pattern", "ignore", "sound", "foundation", "alpha", "back", "brown", "area", "black", "shell", "ruby", "regular", "null", "fill", "summary", "gold", "border", "collection", "buffer", "rc", "clip", "large", "gradient", "pull", "shield", "color", "Background", "ground", "shadow", "blue", "wrapper", "reference", "panel", "ha", "brush", "focus", "callback", "description", "theme", "comment", "bg", "default", "bc", "profile"], "colorspec": ["colororspect", "colloresspec", "coloresSpec", "colororsSpec", "colorespir", "colonsSpec", "Colorship", "Colorespir", "coloresspec", "colandspec", "Colorspace", "coloresnp", "colandspect", "colarspect", "colonspace", "colonsspec", "colorspace", "collorspace", "coloursspec", "Colonsspec", "Colorslip", "colororesspec", "colorslip", "colarsspec", "colionspace", "colionslip", "colarship", "Colorespect", "colororspec", "collorspec", "colorship", "colonship", "colandsSpec", "colionspec", "colororsspec", "collorespec", "Coloreship", "collectionspect", "colionsnp", "colororespec", "colourspec", "colionsspec", "coloreship", "colonspec", "collectionspec", "colionspir", "colorsspec", "colorespec", "Colonspec", "Coloresnp", "Coloresspec", "colorsSpec", "Colorsspec", "collorspect", "colourspect", "colorspir", "colorespect", "colorespace", "Colorspec", "collectionsspec", "colonslip", "Colonspace", "colonspect", "Colorspect", "colourspir", "colororespect", "colorspect", "coloreslip", "Colonslip", "collorsspec", "collorespace", "coloursnp", "collorespect", "colandsspec", "Colorsnp", "colorsnp", "Colorspir", "colourspace", "colororesSpec", "Colorespec", "colarspec"], "foreground": ["forefill", " forecast", "foreGROUND", "undercast", "ftercast", "broadellow", "underparent", "roughpoint", "foreparent", "roughcast", "forepoint", " foreGROUND", "Forecast", "forecast", "backmission", "broadcast", " foreparent", "broadground", "flyellow", "foremission", " forebackground", "fterbackground", "foreellow", "roughellow", "flyfill", "backbackground", "Forebackground", "underground", "roughground", "flyground", "Foreground", "roughbackground", "broadfill", "Foreparent", "ForeGROUND", "fterground", "underbackground", "Foremission", "forebackground", "flycast", "Forepoint", "backpoint", "fterGROUND", "roughmission", "roughfill"], "dataurlspec": [" dataUrlspec", "datafilespace", " datalogspace", " datalogspec", " dataurlstr", " dataurlparse", "dataURLstr", "dataURLparse", "dataURLSpec", "dataurlspace", "datalogstr", "dataURLspe", "datalogspec", " dataUrlSpec", "dataURLspace", "datalogparse", "datastringSpec", "datafilespec", " dataurlspe", "dataurlSpec", "dataurlstr", "dataurlparse", " dataUrlspe", "datalogspace", " dataurlSpec", "datastringspec", " datalogstr", "datafeedspec", "dataurlspe", "dataUrlSpec", "dataUrlspe", " datalogparse", " dataurlspace", "dataUrlspec", "datastringspe", "dataURLspec", "datafileparse", "datafeedSpec", "datafilestr"], "dataurl": ["datafile", "Database", "dataUrl", "DataUrl", "Dataurl", "ataurl", "thisURL", "ataUrl", "DataURL", "ataURL", "thisfile", "atabase", " datafile", " database", " dataUrl", "dataURL", "thisUrl", "thisurl", " dataURL", "database", "Datafile"], "in": ["ini", "body", "err", "image", "resource", "login", "serv", "stream", "inner", "inn", "input", "din", "In", "bin", "b", "c", "IN", "r", "t", "d", "p", "source", "record", "out", "ins", "as", "inas", "socket", "a", "con", "h", "data", "isin", "server", "i", "reader", "win", "inc", "f", "url"]}}
{"id1": "20991673", "id2": "20519261", "code1": "    public NodeId generateTopicId(String topicName) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"No SHA support!\");\n        }\n        if (m_ready) System.out.println(\"Scribe is ready at\" + getNodeId() + \" , topic is \" + topicName);\n        md.update(topicName.getBytes());\n        byte[] digest = md.digest();\n        NodeId newId = new NodeId(digest);\n        return newId;\n    }\n", "code2": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "label": 0, "substitutes": {"generateTopicId": ["generateTopicID", "generatetopicId", "generateTopicInfo", "generatedTopicID", "generatedtopicName", "generateTopicName", "generateTopicsId", "generateTopicsInfo", "generatedtopicInfo", "generatetopicID", "generatetopicInfo", "generatedTopicName", "generatedTopicInfo", "generateTopicsName", "generatedtopicID", "generatetopicName", "generatedTopicId", "generatedtopicId", "generateTopicsID"], "topicName": ["TopicKey", "subjectId", " topicId", "TopicName", "channelKey", "TopicInfo", "topicType", " topicPath", " topicKey", "Topicname", "topicKey", "topicId", "topId", "topName", " topicNames", "TopicNames", "channelId", "TopicId", "topicname", "channelType", "channelName", "subjectName", "subjectType", " topicname", "channelPath", " topicType", " topicInfo", "topname", "topNames", "subjectPath", "topicNames", "topicInfo", "topicPath", "channelInfo"], "md": ["dd", "sha", "cmd", "dr", "meta", "ud", "dc", "am", "dig", "metadata", "ma", "amd", " MD", "po", "hd", "mm", "mo", "ms", "ld", "mp", "vd", "km", "hash", "d", "mand", "bd", "ad", "pm", "df", "sm", "mg", "mac", "mt", "gd", "od", "editor", "cm", "MD", "Cmd", "id", "dh", "pd", "mag", "rm", "dm", "mc", "pkg", "mb", "m"], "digest": ["dighed", "mdested", "dhed", "Diggest", "diggest", "DigEST", "mdest", " diggest", " dighed", "signEST", "digester", "Digests", "cdEST", "dester", "decest", "mdhed", "signests", "Digester", "decEST", "dest", "digests", "mdester", "signest", "cdgest", "digested", "digEST", " digEST", "dested", " digested", "decests", "cdest", "Digest", "cdester", " digester"], "newId": ["nextid", "NewId", " newID", "Newid", "nextId", " newid", "NewInfo", " newInfo", "newInfo", "nextID", "newID", "NewID", "nextInfo", "newid"]}}
{"id1": "88047", "id2": "4716110", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewrites", "readAndRebwrite", "readandrewrite", "readAndSwwrite", "readAndRewwrite", "readAndSwrap", "readAndSwrite", "readandRewrite", "readAndrewrap", "readAndRewrap", "readAndRebrites", "readandrewwrite", "readAndRebrap", "readandRewrap", "readandRewrites", "readAndSwrites", "readandrewrites", "readAndrewrite", "readAndrewwrite", "readAndRebrite", "readandRewwrite", "readAndRewrites", "readandrewrap"], "inFile": ["inFilename", "loginFile", "outFilename", "inputfile", "InFiles", "InFile", " inFiles", "oldFile", "loginFilename", " inSourceFile", "outSourceFile", "InSourceFile", "inputFiles", "outFiles", "oldFiles", " inFilename", "loginFiles", "inputFile", "inSourceFile", "loginfile", "outfile", " infile", "inputFilename", "inFiles", "oldfile", "infile", "oldFilename", "Infile"], "outFile": [" outStream", "offPlace", "outFilename", " outDir", "outputPlace", "outFILE", "OutStream", "outputFilename", "newDir", " outfile", "thisFILE", "outputFile", "offFile", "outDir", "processFilename", "exfile", "exFILE", "newfile", "processPlace", "thisFile", "processFILE", "thisfile", "offFilename", "thisFilename", "outStream", "outPlace", "newFile", "exFile", "exFilename", "outfile", "outputfile", "OutFile", "outputFILE", "OutDir", "offFILE", "processFile", "newStream", "Outfile"], "iis": ["iniis", "Iiss", "iiIs", "iiIS", " iIS", " iIs", "iIs", "iniiss", "ciiss", "ciis", "Iis", "Iais", " iris", "IIS", "ciais", "ciIs", "iiss", "ciris", "iniIS", "iniIs", "iiris", "iiis", "iiiss", "ciIS", "iniris", "iais", " iiss", "iris", "iIS", " iais"], "dcmParser": ["dcmHelper", "dpmarser", "dmcPar", "dmoduleJar", "dmcJar", "dcmPar", "dbmPolicy", "dCMPlugin", "dmoduleParser", "dcmJar", "fcmHandler", "dcrPar", "fpmParser", "dmcarser", "dpmparser", "dbmHelper", "dmissionReader", "dpmLoader", " dpmLoader", "dcrReader", "dbmPlugin", "dCMParser", "dmoduleparser", "dpmPolicy", " dcrParser", "dmPlugin", "dkmHelper", "DcmInstallation", "dmmParser", "dcmparser", " dpmPolicy", " dcmPlugin", "dcmLoader", " dpmHelper", "dmLoader", "dhemReader", "dcmarser", "dpmHelper", "dbmParser", "fpmHandler", "dpmHandler", "dhemParser", "dcrJar", "dpmJar", " dcmLanguage", "fcmParser", "dcrarser", "dcmPolicy", "dkmParser", "dpmInstallation", " dpmJar", "dmodulePlugin", "dmmparser", "dcmLanguage", "dhemInstallation", "dcmInstallation", "fpmparser", "dpmParser", " dpmparser", " dcmPar", "dcmHandler", "dcrPlugin", "dmcParser", " dcmparser", "dcmReader", " dcrReader", "fcmReader", "DcmReader", " dpmPlugin", "dCMparser", "dpmLanguage", " dpmReader", "dmParser", "dmoduleReader", "dmissionPlugin", "dhemJar", " dpmPar", " dcrLoader", "dpmPar", "fpmReader", "dcrParser", "DcmJar", "dmissionParser", " dcmReader", "dCMHandler", "dpmPlugin", " dpmarser", " dpmLanguage", "dmmPlugin", " dcmarser", "dkmPolicy", " dcmHelper", " dcmLoader", "fcmparser", "dpmReader", " dpmParser", "dmReader", " dcmJar", " dcrPlugin", "dCMReader", "dmmLoader", "DcmParser", " dcmPolicy", "dkmPlugin", "dcmPlugin", "dCMLoader", "dcrLoader", "dmissionLanguage"], "ds": ["dd", "dr", "vals", "des", "ants", "os", "vs", "dc", "amps", "dat", "utils", "DS", "ls", "services", "details", "Ds", "ads", "src", "ns", "points", "sync", "ld", "conn", "js", "ws", "da", "ts", "ays", "cdn", "xs", "ps", "session", "d", "ils", "Db", "dt", "ros", "Os", "tes", "cs", "df", "uds", "dds", "ras", "eps", "gd", "ins", "iss", "qs", "is", "rs", "ys", "gs", "icks", "nas", "bs", "data", "sys", "pd", "ss", "tx", "ks", "di", "asi", "db", "parts", "drivers", "s"], "pdReader": ["ddRunner", "hdWriter", "hdLoader", "xdRead", "hdStream", "pcLoader", "pdStream", "pbLoader", "dsLoader", "pbReader", "ddLoader", "pcRead", "ddReader", "pdreader", "xdWriter", "hdReader", "hdRunner", "hdreader", "pbRunner", "ddStream", "pcWriter", "dsreader", "pdLoader", "pbStream", "dsReader", "xdReader", "hdRead", "pdRead", "pcReader", "dsRead", "xdreader", "pdRunner", "dsWriter"], "out": ["flow", "her", "model", "temp", "group", "list", "full", "page", "null", "again", "result", "img", "layer", "name", "file", "lib", "connection", "parent", "s", "device", "in", "o", "login", "outer", "child", "point", "to", "write", "cli", "over", "cache", "sync", "output", "OUT", "password", "conn", "auto", "builder", "code", "session", "pass", "outs", "doc", "io", "Out", "co", "sys", "user", "down", "copy", "err", "base", "inner", " in", "at", "exp", "later", "object", "array", "external", "line", "diff", "client", "ssl", "term", "ext", "data", "gen", "lock", "ex", "default", "inc", "db", "exec", "obj", "image", "dev", "w", "order", "with", "net", "up", "key", "writer", "store", "oder", "part", "director", "manager", "as", "word", "dot", "url"], "dcmEncParam": ["dcmEnParam", "dcmArchArg", "dcmEnPar", "dcmEnArg", "dcmDecParam", "dcmDecType", "dcmDecArg", "dcmElType", "dcmArchParameter", "dcmEncArg", "dcmEnPart", "dcmElPar", "dcmArchParam", "dcmEncType", "dcmSecParam", "dcmEnType", "dcmDecPar", "dcmEstParameter", "dcmDecParameter", "dcmEncPart", "dcmEncParameter", "dcmEstPar", "dcmEncPar", "dcmElParam", "dcmEnParameter", "dcmElParameter", "dcmEstParam", "dcmSecType", "dcmDecPart", "dcmSecPar", "dcmEstType", "dcmSecPart"], "pdWriter": ["htReader", "ddOutput", "htWriter", "hdWriter", "dpWriting", "htWrite", "dsOutput", "PDWrite", "PDWriter", "ddWrite", "ddReader", "hdReader", "pdOutput", "pdWrite", "dpReader", "dsWrite", "ddWriter", "PDReader", "PDWriting", "hdWrite", "dsReader", "pdWriting", "hdOutput", "dpWrite", "dpWriter", "dsWriter", "htWriting"]}}
{"id1": "17792212", "id2": "7499186", "code1": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"createButtonCopyToClipboard": ["createButtonCopyToCLippboard", "createButtonCopyToClippBoard", "createButtonCopyToCliphole", "createButtonCopyToClcliphole", "createButtonCopyToClIPboard", "createButtonCopyToClipphole", "createButtonCopyToClipBoard", "createButtonCopyToCLippbar", "createButtonCopyToClIPbar", "createButtonCopyToCLipphole", "createButtonCopyToCLippBoard", "createButtonCopyToCLipBoard", "createButtonCopyToClipbar", "createButtonCopyToClclipBoard", "createButtonCopyToCLipboard", "createButtonCopyToClclipbar", "createButtonCopyToClippbar", "createButtonCopyToClippboard", "createButtonCopyToCLipbar", "createButtonCopyToClIPhole", "createButtonCopyToCLiphole", "createButtonCopyToClIPBoard", "createButtonCopyToClclipboard"], "buttonCopyToClipboard": ["buttonCopyToCLippline", "buttonCopyToClickboard", "buttonCopyToClickdown", "buttonCopyToClippline", "buttonCopyToClippbar", "buttonCopyToClickline", "buttonCopyToClickbar", "buttonCopyToClippingboard", "buttonCopyToCLipboard", "buttonCopyToCLipbar", "buttonCopyToClippingpanel", "buttonCopyToClipppanel", "buttonCopyToCLipdown", "buttonCopyToClipline", "buttonCopyToClipdown", "buttonCopyToClickpanel", "buttonCopyToCLippboard", "buttonCopyToClIPboard", "buttonCopyToClIPbar", "buttonCopyToCLippanel", "buttonCopyToCLippbar", "buttonCopyToClippingbar", "buttonCopyToClippingline", "buttonCopyToCLipppanel", "buttonCopyToCLipline", "buttonCopyToCLippdown", "buttonCopyToClIPdown", "buttonCopyToClippboard", "buttonCopyToClippdown", "buttonCopyToClIPline", "buttonCopyToClipbar", "buttonCopyToClippanel"], "event": ["change", "end", "view", "this", " Event", "input", "events", "object", "g", "vent", "result", "v", "x", "out", "response", "selected", "ception", "ev", "Event", "e", "instance", "el", "ctx", "ec", "source", "f", "ee"]}}
{"id1": "7872659", "id2": "7122523", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        InstanciaDelegate delegate = RegistroManager.recuperarInstancia(request);\n        if (delegate == null) {\n            ActionErrors errors = new ActionErrors();\n            errors.add(null, new ActionError(\"errors.session\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"fail\");\n        }\n        AyudaPantalla ayudaPantalla = delegate.obtenerAyudaPantalla();\n        TraAyudaPantalla traAyudaPantalla = (TraAyudaPantalla) ayudaPantalla.getTraduccion();\n        String urlSonido = traAyudaPantalla.getUrlSonido();\n        if (urlSonido == null) {\n            return null;\n        }\n        URL url = new URL(urlSonido);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.connect();\n        String tipoMime = urlConnection.getContentType();\n        log.debug(\"Tipo Mime: \" + tipoMime);\n        Map audioOptions = new HashMap();\n        if (tipoMime.indexOf(\"audio\") != -1 || tipoMime.indexOf(\"asf\") != -1 || tipoMime.equals(\"unknown/unknown\")) {\n            audioOptions.put(\"id\", \"MediaPlayer\");\n            audioOptions.put(\"codeBase\", \"http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,7,1112\");\n            audioOptions.put(\"classId\", \"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95\");\n            audioOptions.put(\"mimeType\", \"application/x-mplayer2\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/\");\n        } else if (tipoMime.indexOf(\"real\") != -1) {\n            audioOptions.put(\"id\", \"RVOCX\");\n            audioOptions.put(\"codeBase\", \"\");\n            audioOptions.put(\"classId\", \"clsid:CFCDAA03-8BE4-11cf-B84B-0020AFBBCCFA\");\n            audioOptions.put(\"mimeType\", \"audio/x-pn-realaudio-plugin\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"\");\n        }\n        request.setAttribute(\"audioOptions\", audioOptions);\n        log.debug(\"entra success\");\n        return mapping.findForward(\"success\");\n    }\n", "label": 0, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndmovieindexfile", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndmovieIndexfile", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndMovieIndexPath", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndMovieindexPath"], "completePath": [" completeCh", "iteCh", "completeCorp", "progressPath", "CompleteDir", "donePath", "completeLoader", " completepath", "doneVol", "CompleteHome", "execPath", "flatCorp", "flatPath", " CompletePath", " completeFile", "completeCh", " completeCorp", "correctRoot", "progressLoader", "completePoint", "correctPoint", " CompleteHome", "completeVol", "doneLoader", " completeHome", "completepath", "successMusic", " completeDir", "flatRoot", "successpath", "CompleteFile", " completePoint", "successCh", "completeHome", " CompleteFile", "execpath", "itepath", "completeMusic", "CompletePath", " completeRoot", "iteMusic", "successPath", " CompleteDir", "progressVol", "itePath", "execVol", "correctCorp", "donepath", "completeFile", "progresspath", " completeMusic", "completeRoot", "flatPoint", "completeDir", "execLoader", "correctPath"], "masterFile": [" masterPath", "mastersFILE", "MasterFiles", "MasterFILE", " masterFilename", "MasterFilename", "configFilename", "cacheFILE", "cacheFiles", "configName", "configPath", "MasterFile", "configFile", "MasterName", "cacheFile", "masterName", "masterFILE", "masterFilename", "mastersFiles", "masterFiles", "mastersFile", "mastersPath", "cachePath", " masterName", "masterPath", "MasterPath"], "CustRatingFileName": ["CustIndexFilesPath", "CustRatingFileDesc", "CustIndexFilesType", "CustRateFileName", "CustRatingFilesDesc", "CustRatingFileSize", "CustRateFilenameDesc", "CustRatingClassVersion", "CustRateFilenameName", "CustRatingFilenameName", "CustRatingFilesSize", "CustRatingFullSize", "CustIndexFileType", "CustRatingFilesType", "CustRatingClassType", "CustRateFileSize", "CustRatingFullName", "CustRateFilePath", "CustRatingLineType", "CustIndexFilesName", "CustRatingFullDesc", "CustRateFileDesc", "CustIndexFilesVersion", "CustRatingFilesVersion", "CustRatingFileVersion", "CustRatingFilenamePath", "CustIndexFilePath", "CustRatingLineVersion", "CustRatingFilesPath", "CustRatingFullPath", "CustRatingFilePath", "CustRatingFilenameSize", "CustIndexFileVersion", "CustRateFilenamePath", "CustIndexFileName", "CustRatingFileType", "CustRatingClassPath", "CustRatingLineName", "CustRatingLinePath", "CustRatingFilesName", "CustRatingClassName", "CustRatingFilenameDesc", "CustRateFilenameSize"], "MovieIndexFileName": ["MovieIndexFolderVersion", "MovieIndexFileUrl", "MovieIndexFilename", "MovieConfigFolderVersion", "MovieConfigFileName", "MovieIndexPlaceFile", "MovieEditFSize", "MovieIndexFname", "MovieIndexClassname", "MovieIndexClassName", "MovieIndexFileFile", "MovieIndexFUrl", "MovieEditFName", "MovieIndexFilesname", "MovieIndexClassUrl", "MovieIndexFileSize", "MovieIndexPlaceVersion", "MovieEditFilename", "MovieConfigFolderName", "MovieIndexFSize", "MovieConfigFileFile", "MovieIndexPlaceHandle", "MovieIndexFolderHandle", "MovieConfigFileVersion", "MovieConfigFileHandle", "MovieIndexFileHandle", "MovieEditFUrl", "MovieIndexFilesSize", "MovieIndexFilesName", "MovieIndexClassSize", "MovieEditFileName", "MovieIndexFILEVersion", "MovieIndexPlaceName", "MovieEditFname", "MovieIndexFolderName", "MovieConfigFolderFile", "MovieIndexFileVersion", "MovieIndexFolderFile", "MovieIndexFName", "MovieConfigFolderHandle", "MovieEditFileUrl", "MovieIndexFILEFile", "MovieEditFileSize", "MovieIndexFILEName", "MovieIndexFILEHandle", "MovieIndexFilesUrl"], "inFile": ["outFile", "inputfile", "incSourceFile", "InFile", "inputF", "InF", "inF", " inSourceFile", "outSourceFile", "InSourceFile", "outC", "inputFile", "inputSourceFile", "inSourceFile", "incfile", "incFile", "outfile", " infile", "infile", " inF", "incC", "Infile"], "inC": ["outCC", "innerC", "inCC", "outCL", "inputCC", " inCC", "InCI", "outFile", " inB", "InB", "inputC", "InFile", "inputF", "InF", "inF", "inB", "outC", "inputFile", "outCI", " inCL", "inCI", "InCC", "InCL", "InC", "inCL", "innerCC", "innerFile", "outB", "outF", " inF", "innerCI"], "outFile1": ["outFiles2", "outputfileId", "outPlace2", "outFId", "outputFileId", "outfile2", "outfileId", "outPlaceId", "againC1", "outF2", "outfileName", "outputfile2", "outFileName", "outPathFirst", "outCFirst", "outFiles3", "outputFile2", "outPath2", "againC3", "outfile1", "outFiles1", "outFilesFirst", "againFile1", "outFileId", "againFileFirst", "outF1", "outputFile1", "outPath3", "outC3", "outFile3", "outPath1", "outPlaceName", "againCFirst", "outputfileName", "outPlace1", "againFile3", "againC2", "outputFileName", "outFileFirst", "againFile2", "outputfile1", "outFName"], "outC1": ["outB8", "againC1", "outCOne", "newcOne", "outD2", "outF2", "againB2", "againC8", "outCFirst", "outD81", "outC81", "newCOne", "outF8", "outCF1", "againB8", "newc1", "outC8", "newC81", "outCF81", "outB2", "outF1", "outc1", "newcFirst", "outB1", "againB1", "outc81", "outCFFirst", "newc81", "againCOne", "againBOne", "outFOne", "outcFirst", "outD8", "againC2", "outCFOne", "outDOne", "outcOne", "outD1", "outBOne", "newCFirst", "outDFirst", "newC1"], "outFile2": ["outFiles2", "outputfileTwo", "againLine2", "outChannelTwo", "outfile2", "outFile6", "outfile5", "outDirectory5", "outputfile2", "outDirectory4", "againFileTwo", "outfile4", "againLineTwo", "outLineTwo", "againLine1", "outFiles5", "outputfile4", "outputFile2", "outputFile4", "outFile4", "outFile5", "againFile6", "outFiles1", "outputfile5", "outFilesTwo", "againFile1", "outfileTwo", "outChannel6", "outDirectory2", "outFiles4", "outputFileTwo", "outChannel1", "outChannel2", "outFileTwo", "outDirectoryTwo", "outLine1", "outLine2", "againLine6", "againFile2", "outputFile5", "outFiles6", "outLine6"], "outC2": ["againC1", "outCache2", "outCacheII", "outB4", "outF2", "againB2", "outCTwo", "OutF4", "outCache1", "outF4", "OutF1", "OutFII", "OutCII", "outFile4", "outFTwo", "OutC4", "outB2", "outFileII", "outF1", "outCache4", "OutC1", "againB4", "outB1", "againB1", "outC4", "againC4", "outFileTwo", "againBTwo", "outCII", "OutF2", "OutC2", "outFII", "outBTwo", "againC2", "againCTwo"], "fileSize": ["bufferSize", "resourceAddress", "bufferLength", "FileSIZE", "fileMode", "fileAddress", "imageLength", "FileAddress", "resourceSIZE", "bufferMode", "FileMode", "fileLength", " fileLength", " fileAddress", "resourceSize", "imageSIZE", " fileSIZE", "FileSize", "imageSize", "FileLength", " fileMode", "fileSIZE"], "totalNoDataRows": ["totalNoDataLows", "totalNoPageROWS", "totalNoDataChOWS", "totalNoDataLOWS", "totalNoDataCrows", "totalNoDataCows", "totalNoDataChows", "totalNoDataLrows", "totalNoDataChrows", "totalNoDataCOWS", "totalNoPageRrows", "totalNoDataChues", "totalNoDataCues", "totalNoPageLues", "totalNoPageLOWS", "totalNoDataRrows", "totalNoPageRues", "totalNoDataROWS", "totalNoDataRues", "totalNoPageLows", "totalNoPageLrows", "totalNoDataLues", "totalNoPageRows"], "mappedBuffer": ["Machedbuffer", "mppedBuffer", "mappedURL", "mactedbuffer", "mapedBuffer", "MappedBuffer", "MachedStream", "MachedBuffer", "mappingbuffer", "MappingBuffer", "mappingFile", "Mappedbuffer", "MachedFile", "mippedStream", "mashedFile", "mashedChannel", "machedFile", "mappingChannel", "mapedStream", "machedBuffer", "MachedChannel", "MappingFile", "MappingChannel", "MappedStream", "mactedBuff", "machedStream", "mashedBuffer", "MappedChannel", "MappingBuff", "mappingBuffer", "mippedURL", "mapedFile", "mappedStream", "mppedChannel", "mippedBuff", "mapedURL", "mashedBuff", "mppedBuff", "machedChannel", "machedbuffer", "mappedBuff", "MappedBuff", "MachedURL", "mppedStream", "mappingBuff", "mippedBuffer", "mappingStream", "mapedBuff", "mactedStream", "mappedChannel", "MappedURL", "mactedBuffer", "MappedFile", "mappedbuffer", "machedBuff", "MachedBuff", "mappedFile", "machedURL"], "startIndex": ["useindex", " startindex", "endRow", "stopindex", " startRow", " startPosition", "StartPosition", "endIndex", " startOffset", "useInfo", "stopCode", "startingPosition", "stopIndex", " startCode", "startSection", "startingPoint", "useIndex", "startPoint", "StartOffset", "stopRow", "StartIndex", "endPosition", "endPoint", "initOffset", "initIndex", "endindex", "endInfo", "startInfo", "usePosition", "endCode", "startOffset", "startindex", "startPosition", "Startindex", " startPoint", "StartInfo", " startInfo", "startingSection", " startSection", "startRow", "initindex", "startingIndex", "endSection", "startCode", "initInfo"], "count": ["force", "index", "pool", "child", "other", "depth", "found", "self", "coll", "current", "order", "find", "group", "cache", "add", "total", "key", "list", "code", "c", "more", "ind", "type", "part", "counter", "allow", "len", "all", "number", "loop", "first", "length", "start", "size", "close", "name", "test", "col", "sum", "keep", "id", "follow", "weight", "call", "limit", "thread", "i", "Count", "old", "time", "max"], "currentMovie": ["currentImage", "currentPicture", "currentlyMovie", "defaultFilm", "currentmovie", "CurrentTheme", "defaultImage", "parentPicture", " currentFilm", "validTheme", "reportedTheme", "CurrentFilm", "validFilm", "thisMovie", "Currentmovie", "parentFilm", "currentlyMusic", "defaultMusic", " currentMusic", "reportedMusic", "validmovie", "CurrentMovie", "currentMusic", "currentlyPicture", "reportedmovie", "thismovie", "currentFilm", "defaultMovie", "reportedMovie", " currentImage", "currentTheme", "thisFilm", " currentPicture", "thisPicture", "parentmovie", "reportedPicture", "validMovie", " currentmovie", "reportedFilm", "reportedImage", "parentMovie"], "movieName": ["filmname", "camName", "voiceInfo", "filmNumber", "movieId", "moneyName", " movieId", "MovieNumber", "voiceName", "voicename", " moviename", "Moviename", "filmName", "camFamily", "MovieId", "camname", "moviename", "moneyNumber", "movieNumber", "MovieFamily", " movieFamily", "MovieInfo", " movieInfo", "movieFamily", "voiceId", "MovieName", "movieInfo", "filmFamily", "moneyFamily"], "customer": ["ustomers", "customeri", "Customer", "mixer", "mixers", " customER", "Customor", "Customers", "ustomER", "customers", "mixor", "ustomer", "ustomor", "mixER", "CustomER", "customor", " customers", "Customeri", "customER", "ustomeri", " customeri"], "rating": ["writing", "resource", "rice", "ing", "RC", "rates", "alpha", "http", "reading", "rate", "writer", "info", "ruby", "packing", "including", "string", "setting", "r", "rc", "rage", "padding", "rated", "type", "attribute", "rr", "number", "Rating", "missing", "ring", "id", "data", "range", "score", "radius", "ranking", "value", "comment", "reader", "feature", "error", "rank", "rolling", "url"], "outBuf1": ["outFaf1", "outKbuffOne", "outBuf11", "outKbuf1", "outBbuff1", "outBum1", "outKuf8", "outBbufn", "outBafCloud", "outBum91", "outFuf01", "outDuff3", "outKbuff1", "outBalth3", "outBuf01", "outBuff8", "outFufOne", "outBuff2", "outKuf3", "outCuf1", "outKbuf3", "outDuf3", "outFufCloud", "outBuff3", "outBuff1", "outBiff91", "outBaftn", "outBuf91", "outDuf1", "outBuf0", "outFuf1", "outBuffCloud", "outDufn", "outBafOne", "outBuf8", "outBummerOne", "outFafCloud", "outKbuff8", "outBaf1", "outBufCloud", "outBbuff0", "outKuf2", "outBiff01", "outFbufOne", "outBbuff8", "outBaft3", "outCufOne", "outBum01", "outBuf3", "outBaf0", "outBufOne", "outBaft11", "outCuff1", "outBummerCloud", "outBuffOne", "outBbuf01", "outBbuffOne", "outBbufOne", "outKufOne", "outBiffOne", "outBummer1", "outBuff11", "outCuf0", "outFbuf01", "outBbuf3", "outCuff0", "outBbuf91", "outBiff1", "outBbuf1", "outBbuf11", "outBbuff3", "outKuf1", "outKbuff3", "outBaft1", "outBalth2", "outFuf91", "outBaf8", "outDuff1", "outKbuf2", "outCuffOne", "outDuffn", "outDuf11", "outBaf3", "outBalth1", "outBbuf2", "outBumOne", "outDuff11", "outBufn", "outBuffn", "outFbuf1", "outFafOne", "outBuff0", "outFbuf91"], "outBuf2": ["outFbuff4", "outBbuff1", "outWBuf0", "outBbuffTwo", "outFuf12", "outBbuff82", "outFuf20", "outBbufferB", "outWBuf200", "outBait4", "outBuff8", "outBuff2", "outBufB", "outBuff1", "outFufTwo", "outBoffTwo", "outBbuff4", "outBuber82", "outBbufTwo", "outBuff12", "outBuf0", "outFuf1", "outBait8", "outFbufB", "outWBuf4", "outBuf8", "outFbuff82", "outWBbuff2", "outFbuf4", "outFbuff20", "outWBufTwo", "outBbuff0", "outBbuff8", "outBuffTwo", "outBuf4", "outWBuff8", "outWBuf2", "outBaitTwo", "outWBbuff200", "outBbuff20", "outBbufB", "outBbuf4", "outFbuff8", "outBum82", "outWBuff4", "outBbuffer2", "outBuber8", "outWBuff2", "outBuf20", "outFuf82", "outBum8", "outBait0", "outBufTwo", "outBum2", "outFbuffTwo", "outWBbuff8", "outBbuff2", "outBum20", "outBuf82", "outBuf12", "outBbuffer12", "outFuf2", "outWBuf8", "outBuber2", "outBait2", "outFuf4", "outBuff4", "outBbuf1", "outBait200", "outBbuffer4", "outBoff200", "outBuffB", "outFbuff2", "outBuf200", "outFbuf2", "outBbuff200", "outBoff8", "outFbuff1", "outBoff2", "outBbuf12", "outFufB", "outWBuff0", "outBbuf2", "outFbuf12", "outWBbuffTwo", "outBuff0", "outBuber20", "outFuf8"], "endOfIndexFile": ["endofindexFiles", "endofIndexFiles", "endOfIndexfile", "endofindexFile", "endofLinkFiles", "endOfLinkFiles", "end\n", "endOfLinkTime", " endfile", "endofLinkTime", "endOfIndexDir", "endOfindexTime", "endOfIndexFolder", "endfile", "endOfDatafile", "Endfile", "endOfDataFile", "endOfLinkFile", "endOfDataTime", "endofLinkFile", "endOfDataDir", "End\n", "endOfindexfile", "endofIndexDir", "endOfClientDir", "endOfImageTime", "endedfile", "ended\n", "endofindexFolder", "endOfClientFile", "endOfindexDir", "endOfIndexFiles", "endOfClientTime", "endOfindexFolder", "endOfIndexTime", "endofIndexFolder", "endOfImageFolder", "endofindexTime", "endOfLinkDir", "endofIndexTime", "endOfImageFiles", "endofLinkDir", " end\n", "endOfClientFiles", "endOfLinkfile", "endofIndexFile", "endOfindexFiles", "endOfindexFile", "endOfImageFile"]}}
{"id1": "8953394", "id2": "23531898", "code1": "    private void update(String statement, SyrupConnection con, boolean do_log) throws Exception {\n        Statement s = null;\n        try {\n            s = con.createStatement();\n            s.executeUpdate(statement);\n            con.commit();\n        } catch (Throwable e) {\n            if (do_log) {\n                logger.log(Level.INFO, \"Update failed. Transaction is rolled back\", e);\n            }\n            con.rollback();\n        }\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 1, "substitutes": {"update": ["create", "end", "write", "with", "edit", "up", "UPDATE", "run", "replace", "set", "sql", "updated", "apply", "Update", "query", "join", "select", "place", "build", "alter", "ite", "save", "database", "connection", "execute", "exec"], "statement": ["script", "storage", "ment", "sequence", "Statement", "usage", "text", "message", "use", "string", "status", "sql", "condition", "session", "state", "sn", "query", "join", "stat", "result", "commit", "mt", "response", "command", "expr", "expression", "name", "report", "data", "str", "value", "database", "timeout", "connection", "execute", "source"], "con": ["com", "log", "conv", "login", "ion", "can", "crit", "syn", "cons", "trans", "pc", "cur", "fc", "ca", "exec", "cache", "conn", "CON", "ran", "c", "cf", "cr", "rc", "m", "ci", "en", "container", "an", "commit", "xc", "client", "cc", "Con", "cas", "cm", "co", "tc", "ec", "cn", "connect", "lock", "mc", "Conn", "bc", "ctx", "connection", "uc", "db", "conf"], "do_log": ["Do_log", "do\u00b7put", "do_loc", "Do_print", "do_Log", "do_put", "do_print", "do\u00b7loc", " do_put", "do_bug", "do___put", "Do_bug", "do___log", " do_loc", "Do_Log", "do___loc", "do\u00b7log"], "s": ["j", "in", "o", "ans", "ops", "ls", "services", "ns", "l", "b", "js", "sql", "c", "r", "session", "g", "ps", "t", "d", "p", "ds", "conf", "si", "S", "os", "sb", "fs", "qs", "ins", "is", "ses", "hs", "es", "ssl", "a", "south", "h", "e", "ss", "u", "sl", "i", "n", "ks", "ts", "m", "f"]}}
{"id1": "3958807", "id2": "7499186", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadFbinaryStream", "loadFbinaryInput", "loadBatchFile", "loadBinaryContent", "loadFinaryFile", "loadBInputFile", "loadBInputInput", "loadBinaryFile", "loadBatchContent", "loadBinaryInput", "loadBbinaryInput", "loadFinaryStream", "loadBbinaryStream", "loadBatchInput", "loadBInputContent", "loadFinaryInput", "loadBatchStream", "loadBbinaryFile", "loadFinaryContent", "loadBInputStream", "loadFbinaryContent", "loadFbinaryFile", "loadBbinaryContent"], "streamName": ["streamname", "channelKey", "fileName", "fileType", "filePath", "filename", "resourcePath", "StreamPath", " streamname", "streamType", "Streamname", "channelName", "streamPath", "resourceType", "resourceName", "channelPath", " streamType", "streamKey", " streamKey", " streamPath", "StreamName", "resourcename", "fileKey"], "streamToLoad": ["channeltoload", "channelToLoad", "channelToload", "streamtoUpload", "streamWillUse", "objectToUse", " streamToUse", "streamTOLoad", "streamTOAdd", "streamToload", "streamWillUpload", "streamtoload", "streamtoRead", "streamtoLoad", "streamWithAdd", "streamToRead", "streamToAdd", "objectTOUse", "streamWithRead", "objectTOUpload", "objectToLoad", " streamtoRead", " streamtoUse", "streamTOUse", "streamtoAdd", " streamToAdd", "objectTOLoad", "streamWillLoad", "objectTORead", "objectToRead", " streamtoAdd", "streamTORead", "channeltoLoad", "streamtoUse", "channeltoAdd", "streamWillAdd", " streamtoLoad", "channelToAdd", "streamTOUpload", "streamWillRead", " streamToRead", "streamToUpload", "streamWithLoad", "streamTOload", "streamWithUse", "objectToUpload", "streamToUse"], "sz": ["sze", "ssze", "szes", " szip", "szi", "imszes", "szip", " sze", "ssiz", "wszip", "psze", "pszi", " szi", "imsze", "pszip", "siz", " siz", "wsz", "sszes", "wsze", "imsiz", "ssz", "psz", " szes", "imsz", "wszi"], "req": ["err", "q", "rx", "fr", "serv", "download", "input", "ref", "http", "src", "rec", "respond", "conn", "cb", "def", "r", "wx", "ok", "sem", "Request", "require", "progress", "rr", "inv", "proc", "rh", "response", "client", "Resp", "report", "request", "qt", "f", "rss", "rw", "pkg", "res", "ctx", "requ", "exec", "obj"], "resp": ["re", "err", "body", "html", "wb", "circ", "serv", "Response", "download", "rep", "ref", "http", "zip", "rev", "rec", "output", "respond", "conn", "bb", "jp", "par", "page", "remote", "api", "sp", "wp", "wx", "esp", "cmp", "cook", "ret", "proc", "df", "rh", "response", "prev", "client", "fp", "Resp", "comm", "report", "request", "rem", "server", "rup", "e", "rss", "res", "ctx", "rel", "exec", "reply", "obj"], "out": ["log", "base", "o", "in", "pool", "serv", "gz", "ops", "zip", "cache", "output", "OUT", "b", "bin", "conn", "auto", "object", "ws", "null", "buf", "buffer", "again", "outs", "op", "p", "boot", "io", "os", "response", "img", "Out", "tmp", "co", "data", "fn", "binary", "i", "res", "default", "aos", "exec", "copy", "s"], "bos": ["bo", "pins", "lol", "zos", "osa", "zb", "bot", "mis", "osi", "cro", "bas", "bin", "bb", "obo", "ubis", "obs", "biz", "zo", "abi", "bes", "bro", "rob", "boot", "flo", "ros", "obb", "os", "obos", "bi", "bott", "bis", "ko", "oops", "las", "bs", "bare", "bps", "ob", "lo", "ios", "oos", "fits", "bc", "bh", "los", "aos"]}}
{"id1": "13333160", "id2": "20735941", "code1": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"run": ["module", "submit", "config", "render", "edit", "process", "Main", "update", "read", "apply", "running", "work", "doc", "uri", "evaluate", "loop", "Test", "man", "report", "test", "Process", "runner", "Run", "execute", "exec"], "xmlIn": ["xmlin", "xmlSource", "phpReader", "jsonOut", "inputIns", "mlIns", "jsonReader", "phpSource", "mlIn", "mlOut", "jsonSource", "phpOut", "jsonIn", " xmlin", " xmlIns", "xmlReader", "xmlOut", " xmlReader", "mlin", "phpIn", "inputin", " xmlSource", "inputOut", "xmlIns", "inputIn", " xmlOut"], "out": ["err", "log", "in", "resource", "temp", "prefix", "w", "write", "project", "window", "up", "cache", "output", "OUT", "table", "writer", "bin", "list", "page", "builder", "string", "external", "buffer", "again", "outs", "doc", "io", "result", "dest", "Out", "client", "report", "name", "dump", "server", "file", "ex", "timeout", "res", "connection", "source", "parent"], "dom": ["com", "ver", "html", "base", "dr", "fr", "Dom", "form", "domain", "bot", "hub", "up", "http", "parser", "ch", "home", "builder", "c", "d", "node", "doc", "p", "div", "result", "om", "frame", "df", "img", "DOM", "bug", "xml", "cm", "tree", "h", "live", "nav", "document", "valid", "browser", "dm", "m", "host", "db", "url"], "f": ["Factory", "o", "fr", "fac", "fa", "inf", "w", "fm", "F", "function", "fe", "aff", "http", "fc", "l", "full", "raf", "fab", "c", "cf", "rf", "def", "g", "fd", "t", "fb", "d", "p", "conf", "v", "df", "x", "fp", "fs", "fx", "framework", "tf", "h", "af", "e", "sf", "u", "i", "bf", "m", "s"], "b": ["body", "ib", "base", "br", "ba", "abs", "xb", "Builder", "l", "bb", "builder", "c", "gb", "r", "abb", "bel", "lib", "fb", "d", "be", "lb", "bd", "p", "sb", "v", "build", "B", "orb", "bt", "library", "bar", "h", "bs", "ob", "e", "rb", "bc", "bf", "m", "db", "ab", "s"], "root": ["Dom", "rec", "page", "leaf", "null", "element", "c", "ok", "p", "div", "result", "xml", "article", "Element", "nav", "component", "Supported", "m", "host", "parent", "cover", "html", "child", "found", "this", "Root", "ow", " Root", " Dom", "builder", "string", "r", "core", "supported", " allowed", "legal", "doc", "allow", "allowed", "tree", " Document", "document", "ax", " DOM", "loc", "right", "parse", "master", "Node", "home", "path", "node", "container", "attr", "af", "rss", "default", "obj", "Doc", "ver", " rooted", "transform", "head", "parser", " empty", "writer", " node", "rew", "author", "Valid", "DOM", "Document", "h", "valid", "e", "false", " correct", "url", "owner"], "att": ["aj", "_", "apt", "html", "nat", "nt", "tt", "lit", "utt", "arr", "ht", "art", "av", "at", "text", " ax", "annot", "attach", "cat", "ann", "struct", "mat", "ct", "ack", "atts", "t", "ATT", "ant", "attribute", "aut", "attr", "ai", "ott", " attribute", " Att", "rs", "Attribute", "name", "app", "ac", "Att", "alt", "Info", "adj", "str", " html", "acc", "Attributes", "obj"], "menu": ["image", "video", "resource", "module", "site", "view", "ul", "group", "license", "cache", "cu", "queue", "list", "info", "ui", "page", "gi", "item", "query", "li", "m", "gui", "doc", " menus", "uni", "container", "uri", "v", "command", "Menu", "manager", "us", "nav", "server", "user", "cal", "layout", "category", "u", "theme", "i", "wiki", "config", "parent", "plugin"], "id": ["action", "end", "alias", "rid", "target", "version", "ids", "key", "href", "info", "class", "code", "option", "path", "pid", "ID", "oid", "prop", "start", "name", "sid", "mid", "title", "data", "category", "tag"], "zout": ["azOut", "zenunk", "zconn", "zhagain", "zipOut", "azout", " zagain", "Zobject", "zenagain", "zipagain", "zOut", "azagain", "ezconn", "jin", " zconn", "azzip", "zhouter", "zOUT", "zeagain", "ezouter", "ZOut", "ldagain", "zenzip", "ezio", "Zin", "gzout", "ldOut", "zipio", "zunk", "Zio", "zendiff", "gzin", "zio", "zeout", " zio", "zinner", " zOut", " zin", "zeOut", "ezdiff", "zipin", "gzOUT", "zouter", "ezobject", "zeninner", "ezinner", " zdiff", " zunk", "ldout", "zenOut", "zdiff", "zhinner", "zagain", "jio", "zenouter", "gzagain", "ezagain", "zzip", " zzip", "zenin", "ldOUT", "ezOut", "ezin", "zobject", "ZOUT", "jout", "zeconn", "Zagain", "jobject", "zin", "zenout", "azOUT", "ezunk", "zhout", "zipout", "Zout", "zipOUT", "ezout"], "content": ["model", "resource", "create", "temp", "current", "full", "page", "null", "status", "job", "context", "ontent", "xml", "expression", "search", "file", "const", "value", "time", "connection", "host", "parent", "body", "lc", "child", "cont", "continue", "children", "cache", "ca", "output", "column", "password", "music", "conn", "string", "code", "example", "fill", "response", "handle", "character", "size", "language", "server", "document", "activity", "help", "header", "Content", "script", "version", "text", "process", "update", "left", "path", "gc", "x", " Content", "ce", "ext", "request", "data", "empty", "default", "location", "exec", "address", "image", "section", "gray", "load", "message", "media", "work", "prev", "cm", "title", "word", "wrapper", "complete", "config", "url"], "signal": ["signaled", "ignale", "SIGNale", "signale", "SIGNig", "seal", "mental", "seature", "signals", "Signaled", "signature", "SignAL", "mentig", " signature", "Signal", "SIGNal", "signig", "ignature", "ignal", " signals", "signAL", "ignaled", " signaled", "Signale", "sealed", "mentature", "ignAL", "mentaled", "SIGNature", "seig", "Signig", "Signals", "ignals", "ignig", "Signature", " signig", " signAL"], "n": ["z", "num", "index", "nb", "j", "o", "nor", "nl", "N", "inn", "none", "net", "ns", "ne", "l", "un", "conn", "c", "r", "g", "sn", "norm", "t", "d", "node", "not", "k", "en", "p", "ni", "eni", "nn", "len", "nr", "v", "x", "y", "all", "size", "h", "fn", "e", "adj", "u", "i", "ng", "m", "s"], "entry": ["lc", "letter", "de", "her", "in", "module", "nt", "feed", "system", "child", "this", "inner", "event", "je", "ry", "channel", "zip", "Entry", "parser", "add", "info", "auto", "string", "element", "r", "cel", "next", "record", "ent", "se", "row", " Entry", "archive", "server", "data", "file", "ries", "cell", "e", "no", "reader", "per", "enter", "or", "obj"], "pout": ["pconn", "pOut", "pouter", "lpnet", "patchio", " pOut", "Pin", " pouter", " pnet", "pwriter", "lpout", " pwriter", "pnet", "Pn", "patchout", "patchin", "ppio", "cpout", " pio", " pagain", "print", "prin", "zOut", "pin", "zin", "POut", " pn", "ppnet", " pint", "ppin", "cpio", "prout", "cpconn", "pint", " pconn", "Pwriter", "ppagain", "ppconn", "pn", "prwriter", "pagain", "lpio", "Pio", "Pout", " pin", "Pouter", "cpagain", "Pint", "zouter", "pio", "patchn", "ppout", "lpin"]}}
{"id1": "18782385", "id2": "14317425", "code1": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"saveFile": ["writeFile", "writeDirectory", " saveFiles", " saveImage", "saveFiles", "writeFiles", "uploadFiles", "saveDirectory", " saveDirectory", "saveImage", "uploadFile", "writeImage", "uploadImage", "uploadDirectory"], "window": ["flow", "Window", "ui", "show", "youtube", "wx", "gui", "img", "layer", "command", "gallery", "volume", "file", "layout", "band", "browser", " world", "time", "scroll", "host", "parent", "machine", "directory", "device", "button", "visual", "input", "target", " wizard", "motion", "style", "driver", "session", " dialog", "stage", "doc", " wid", "server", "document", "win", "console", "office", "event", " container", "game", " canvas", "audio", "remote", "home", "wa", " host", "client", "GUI", " Window", "hw", "screen", "menu", "image", "video", "box", "system", " widget", "view", " GUI", "draw", "w", " video", "wall", "widget", "space", "media", "scope", "buffer", "dom", "microsoft", "frame", "manager", "angular", "feature", "project", " office"], "stream": [" upload", " buffer", "w", " video", " prog", " form", " w", "output", " resource", " webpage", " temp", " OUT", " app", " streams", " this", "io", "os", "out", " console", " webcam", "OU", "file", "document", "Stream", " bout", "f"], "outputDoc": [" outputFile", "externalFile", "OutputFile", "OutputDoc", "OutputDiv", "OutputDocument", "outputDir", "inputDocument", "inputDoc", "inputDir", "targetDocument", "externalDiv", "updateDiv", "outputDiv", "externalDoc", "targetDoc", " outputDir", "inputFile", "updateDocument", "targetFile", "updateDir", "outputDocument", " outputDiv", "externalDocument", "targetDiv", " outputDocument", "OutputDir", "updateDoc", "outputFile"], "dtd": ["fddd", "ddt", "dlt", "fdTD", "slt", "sdt", "Ddd", "Ddt", "sTD", " dlt", "Ddl", "ddl", "fdtd", " ddl", "ddd", "fddl", "dTD", "Dtd", "std", " dTD", " ddt", " ddd", "DTD", "Dlt"], "uiElement": ["uiSource", "suEntity", "UIObject", "volumeDocument", "uelement", "uiEl", "UIEl", "guiEl", "uriE", "uiDoc", "uiEle", " UIEditor", "UIE", "cliElement", "uniEntity", "uriEl", "uniEl", "uiDocument", "uiEngine", "suElement", "suEmail", "uiMember", "UIDocument", "luEmail", "clielement", "ouEl", "utilEl", "guiEntity", "luElement", "uriEngine", " UIEl", "luEntity", "uriObject", "utilElement", "UIEditor", "guiElement", "uiE", "guiMember", "ouElement", "cliSource", " UIEle", "guiDoc", "UIDoc", "uriEntry", "uiEntry", "apiEl", "uEl", "cliEntry", "apiEntity", "uiObject", "uriDocument", "guiE", "uiModule", "cliEl", "uElement", "uiEmail", "uSource", "utilDoc", "UIMember", "suEngine", "UIEntry", "volumeObject", "uriEmail", "UIEle", "ouEditor", "UIElement", "ouEle", "urielement", "uniElement", "apiE", "uniE", "ioElement", "ioDoc", "uiEditor", "uiEntity", "volumeEntry", "ioModule", "apiElement", "uniMember", " UIElement", "unielement", "uielement", "guielement", "luEngine", "uriElement", "UISource", "guiModule", "uriEntity", "UIelement", "ioEl", "UIModule"], "currentLFClassName": ["currentLFFunctionPath", "currentLDFClassname", "currentLELFClassName", "currentLDFFileName", "currentLELFCLASSName", "currentLFCLASSAlias", "currentLELFCLASSDesc", "currentLFclassDesc", "currentLFClassPath", "currentLDFFileDesc", "currentLELFClassDesc", "currentLELFClassPath", "currentLELFClassAlias", "currentLDFClassString", "currentLFFunctionAlias", "currentLDFClassName", "currentLDFClassDesc", "currentLFFileDesc", "currentLFCLASSDesc", "currentLFclassPath", "currentLFCLASSPath", "currentLFFunctionDesc", "currentLDFFilename", "currentLFClassDesc", "currentLFClassname", "currentLELFCLASSPath", "currentLFFileString", "currentLFclassname", "currentLFFileName", "currentLFClassString", "currentLFclassAlias", "currentLFCLASSName", "currentLFFunctionName", "currentLDFFileString", "currentLFclassString", "currentLFclassName", "currentLELFCLASSAlias", "currentLFFilename", "currentLFClassAlias"], "systemLFClassName": ["systemLfClassString", "systemLFFullName", "systemLFPackageDesc", "systemLfClassname", "systemLfPackagename", "systemLFClassDesc", "systemLfPackageCode", "systemLfPackageDesc", "systemLFFullString", "systemLFClassname", "systemLfClassCode", "systemLFClassCode", "systemLFFullDesc", "systemLfClassDesc", "systemLfPackageString", "systemLfPackageName", "systemLFPackageName", "systemLfClassName", "systemLFclassDesc", "systemLFPackageCode", "systemLFclassString", "systemLFPackagename", "systemLFclassName", "systemLFClassString", "systemLFPackageString"], "mainWindowElement": ["centralWindowelement", "mainHostBuilder", "mainHostE", "mainScreenelement", "mainTimeEl", "MainWindowElement", "mainWindowFrame", "currentWindowEl", " mainWheelEl", "mainMenuElement", "mainFlowEngine", "currentWindowContainer", " mainWindowE", " mainWebObject", "mainWindowelement", "mainScreenElement", "MainFrameE", "centralWindowElement", "mainWindowContainer", "mainWheelElement", "mainFrameFrame", "mainFrameEl", " mainWindowAddress", "currentFramePage", "mainTimeelement", "mainWindowAddress", "mainFlowObject", "mainFrameelement", "mainWindowsEl", "mainWindowEnvironment", "currentWindowPage", "MainWindowFrame", "mainQueueElement", "currentFrameEl", "centralWindowEl", "mainFrameElement", "mainStreamPage", " mainWebElement", "MainFrameFrame", "mainMenuContainer", " mainWindowObject", "currentFrameElement", "mainGroupElement", "mainWindowsE", "mainWindowE", "currentWindowElement", " mainWebEngine", "mainWheelEl", "mainFrameEnvironment", "mainWindowMember", "mainStreamEl", "mainGroupEngine", "mainWebEnvironment", "mainFlowBuilder", "centralFrameelement", "mainWheelEnvironment", "mainGroupObject", "centralFrameEl", "mainWindowsElement", "mainStreamContainer", "centralFrameElement", "mainQueueEl", "currentFrameContainer", "mainMenuEl", " mainHostAddress", "mainStreamElement", "mainFlowEnvironment", "MainFrameElement", " mainWindowEl", "mainGroupEnvironment", " mainWebEnvironment", " mainHostE", "mainWindowEngine", "mainFlowAddress", "MainWindowE", "mainFramePage", "mainQueueE", "mainTimeElement", "MainWindowEl", "mainFlowElement", "mainFrameContainer", "mainWebAddress", "mainWebBuilder", " mainHostBuilder", "mainWebObject", "mainScreenEl", " mainWindowEngine", "mainHostElement", "mainWebEngine", "mainFrameMember", " mainWheelElement", "mainWindowEl", " mainWindowMember", "mainQueueFrame", " mainWindowEnvironment", "mainWebE", " mainWheelEnvironment", " mainWindowBuilder", "MainFrameEl", "mainWindowsFrame", " mainWheelMember", "mainWebElement", " mainHostElement", "mainWebEl", "mainWindowPage", "mainWebMember", "mainWheelMember", "mainMenuPage", "mainFlowE", "mainWindowBuilder", "mainFrameE", "mainHostAddress", "mainWindowObject"], "volumeElement": ["voiceElement", "VolumeEntry", "volumeEl", "volumeLayer", "VolumeElement", "voiceLayer", "audioPart", "soundPart", "voiceEl", "soundElement", " volumeEl", "volumelement", "audioEngine", "audioLayer", " volumeEntry", "audioEl", " volumeContainer", "soundEl", "audioEntry", "audioElement", "voiceEntry", "soundlement", "audiolement", " volumeLayer", " volumelement", "volumeEntry", "VolumeEl", "voiceContainer", "volumeEngine", " volumeEngine", "volumePart", "volumeContainer", "VolumeContainer", "voiceEngine", " volumePart"], "player": ["video", "aster", "caster", "Play", "audio", "game", "active", "players", "ler", "play", "par", "Player", "driver", "act", "position", "plays", "handler", "able", "er", "ater", "part", "ayer", "ader", "monitor", "min", "layer", "ower", "app", "loader", " Player", "roller", "live", "apper", "file", "mor", "e", "transfer", "ser", "watch", "playing", "per", "profile", "db"]}}
{"id1": "23296117", "id2": "873012", "code1": "    public static void extractNativeLib(String sysName, String name, boolean load, boolean warning) throws IOException {\n        String fullname = System.mapLibraryName(name);\n        String path = \"native/\" + sysName + \"/\" + fullname;\n        URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n        if (url == null) {\n            if (!warning) {\n                logger.log(Level.WARNING, \"Cannot locate native library: {0}/{1}\", new String[] { sysName, fullname });\n            }\n            return;\n        }\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        File targetFile = new File(getExtractionDir(), fullname);\n        OutputStream out = null;\n        try {\n            if (targetFile.exists()) {\n                long targetLastModified = targetFile.lastModified();\n                long sourceLastModified = conn.getLastModified();\n                if (targetLastModified + 1000 > sourceLastModified) {\n                    logger.log(Level.FINE, \"Not copying library {0}. Latest already extracted.\", fullname);\n                    return;\n                }\n            }\n            out = new FileOutputStream(targetFile);\n            int len;\n            while ((len = in.read(buf)) > 0) {\n                out.write(buf, 0, len);\n            }\n            in.close();\n            in = null;\n            out.close();\n            out = null;\n            targetFile.setLastModified(conn.getLastModified());\n        } catch (FileNotFoundException ex) {\n            if (ex.getMessage().contains(\"used by another process\")) {\n                return;\n            }\n            throw ex;\n        } finally {\n            if (load) {\n                System.load(targetFile.getAbsolutePath());\n            }\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n        logger.log(Level.FINE, \"Copied {0} to {1}\", new Object[] { fullname, targetFile });\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"extractNativeLib": ["extractRemoteLib", "extractRemotelib", "extractLibrarylib", "extractednativeLib", "extractednativeLibrary", "extractNativeLibrary", "extractedNativeLibrary", "extractLibraryLib", "extractedNativelib", "extractnativelib", "extractNativelib", "extractLibraryLibrary", "extractedNativeLib", "extractnativeLibrary", "extractednativelib", "extractnativeLib", "extractRemoteLibrary"], "sysName": [" sysTitle", "libTitle", "SysName", "libname", " sysPath", " sysDir", "systemPath", "Sysname", "ysName", "SysDir", "ysPath", "libName", "systemTitle", "systemName", "sysDir", "sysFull", "SysFull", "ysname", "systemDir", "sysPath", "libPath", "SysPath", " sysFull", "systemFull", "systemname", " sysname", "sysTitle", "sysname"], "name": ["nm", "base", "resource", "system", "NAME", "prefix", "root", "cache", "nice", "filename", "key", "label", "string", "nam", "Name", "part", "type", "named", "number", "na", "size", "loader", "title", "word", "data", "file", "id", "username", "no", "n", "default", "connection", "source", "plugin"], "load": ["link", "force", "create", "hack", "check", "download", "cl", "cli", "launch", "open", "write", "skip", "parse", "cache", "add", "zip", "play", "use", "sync", "l", "leaf", "read", "set", "loaded", "null", "LOAD", "rc", "push", "remove", "ck", "progress", "fail", "require", "loading", "pull", "start", "close", "loader", "init", "pack", "test", "oad", "dump", " reload", "include", "call", "lock", "Load", "comment", "loads", "callback", "delete", "get", "wait", "copy", "save"], "warning": ["aw", "resource", "Warning", "blocking", "WARN", "alert", "message", "fw", "random", "auto", "ws", "leaf", "wild", "ew", "initial", " warn", "external", "wa", "success", "weak", "lang", "loading", "breaking", "fp", "generation", "only", "loader", "ww", "warn", "WARNING", "war", "watch", "misc", "error", "comment", "notice", "acl", "web", " warnings"], "fullname": ["fulName", " fullNAME", "realpath", " fullnumber", "fullykey", " fullnamed", "fullkey", "flatpath", "fulkey", "fullyName", "fullnode", "Fullpath", " fullnode", "realnamed", "fullnamed", " fullkey", "realname", "fulbase", "Fullnumber", "Fullnamed", "fullybase", "realName", "fullypath", " fullpath", "flatname", "Fullname", "fullbase", "Fullnode", "fullynumber", "fulname", "fullNAME", "FullNAME", "realNAME", "fullName", "fullyname", " fullName", "flatnamed", "FullName", "fullpath", "fullnumber", "fulnode", " fullbase", "flatName", "fulpath"], "path": ["enc", "link", "image", "log", "method", "base", "resource", "Path", "root", "pattern", "filter", "ref", "text", "cache", "filename", "key", "api", "full", "object", "string", "PATH", "code", "route", "work", "type", "part", "pointer", "uri", "ath", "context", "loader", "id", "file", "data", "str", "config", "location", "parent"], "url": ["link", "image", "log", "URL", "base", "resource", "fr", "www", "service", "lr", "config", "serv", "impl", "coll", "download", "Url", "channel", "http", "src", "l", "api", "bb", "string", "bel", "fl", "org", "uri", "blog", "il", "ur", "loader", "location", "ssl", "server", "file", "ll", "ob", "sl", "rl", "lib", "connection", "loc", "source", "f", "address"], "conn": ["enc", "err", "log", "conv", "nt", "serv", "coll", "cli", "nc", "net", "open", "channel", "rt", "Connection", "http", "sync", "l", "ch", "cb", "api", "ann", "act", "c", "ct", "resp", "rc", "session", "cmp", "io", "org", "fp", "client", "socket", "ssl", "init", "reg", "con", "loc", "cn", "ob", "dn", "connect", "lock", "Conn", "n", "ctx", "cp", "connection", "config", "conf"], "in": ["ini", "err", "image", "kin", "index", "login", "resource", "child", "serv", "this", "inner", "inn", "gin", "pre", "input", "In", "up", "src", "cache", "sync", "bin", "b", "like", "c", "pin", "IN", "r", "again", "ic", "ie", "source", "nin", "part", "cin", "min", "pull", "client", "ins", "lin", "socket", "init", "ssl", "ac", "a", "inside", "con", "request", "data", "on", "file", "id", "lock", "reader", "i", "win", "n", "connection", "config", "din", "exec", "f", "inc", "s"], "targetFile": ["TargetDir", "resourceFile", "sourceDirectory", " targetPath", "targetPath", "TargetDirectory", " targetFiles", "sourceDir", "argetFiles", "resourcefile", " targetLine", "TargetFile", "resourceDir", "sourceFolder", "Targetfile", "argetfile", "targetFolder", " targetStream", "sourcePath", "argetFolder", "hostfile", "argetFile", "hostDir", "TargetStream", "argetClass", "targetStream", "sourceFile", " targetFolder", "targetfile", "sourcefile", "resourceDirectory", "hostFile", "targetClass", "TargetPath", "targetFiles", " targetDir", "targetLine", "TargetClass", " targetDirectory", "hostStream", "sourceLine", "targetDirectory", "TargetFiles", "resourceLine", " targetfile", " targetClass", "argetPath", "sourceFiles", "targetDir"], "out": ["err", "image", "log", "o", "resource", "temp", "outer", "login", "prefix", "cmd", "inner", "w", "plain", "net", "at", "target", "up", "exp", "group", "cache", "sync", "output", "OUT", "key", "bin", "writer", "post", "page", "null", "option", "buf", "again", "token", "doc", "line", "part", "io", "result", "Out", "client", "block", "off", "app", "socket", "init", "ext", "sum", "co", "server", "on", "file", "user", "parent", "call", "lock", "error", "ex", "comment", "one", "n", "default", "connection", "source", "exec", "obj", "inc"], "targetLastModified": ["targetLastPedified", "targetLastSemocked", "targetFirstMODocked", "targetLastMODocked", "targetLastMODified", "targetLastMODamed", "targetFirstModification", "targetLastMined", "targetLastModamed", "targetLastPedamed", "targetLastMinIFIED", "targetFirstModed", "targetLastMinified", "targetLastMODification", "targetLastModification", "targetFirstModamed", "targetFirstModIFIED", "targetLastSemified", "targetLastPedIFIED", "targetFirstModified", "targetFirstMinified", "targetFirstMODified", "targetFirstMODification", "targetLastPeded", "targetLastSemed", "targetLastModocked", "targetFirstMinIFIED", "targetFirstMinamed", "targetLastMed", "targetLastModIFIED", "targetLastSemification", "targetLastModed", "targetFirstModocked", "targetFirstMined", "targetLastMODIFIED", "targetLastMODed", "targetLastMified", "targetLastMification", "targetLastMocked", "targetFirstMODed", "targetLastMinamed"], "sourceLastModified": ["sourceLastMODification", "sourceLastMODed", "sourceFirstModification", "sourceFirstModified", "sourceLastImated", "sourceFirstMODification", "sourceLastModated", "sourceFirstMODated", "sourceLastmodIFIED", "sourceFirstMODed", "sourceFirstMODIFIED", "sourceLastMinIFIED", "sourceFirstModIFIED", "sourceLastMification", "sourceLastImification", "sourceLastMODated", "sourceLastModification", "sourceLastMated", "sourceLastModIFIED", "sourceLastMified", "sourceLastMined", "sourceFirstModed", "sourceFirstModated", "sourceLastmoded", "sourceLastModed", "sourceFirstMODified", "sourceLastMed", "sourceLastImified", "sourceLastMODIFIED", "sourceLastMinified", "sourceLastMODified", "sourceLastmodified", "sourceLastImed"], "len": ["z", "err", "num", "lc", "body", "nt", "end", "val", "lf", "cl", "net", "count", "ler", "lon", "l", "bin", "pos", "li", "fl", "en", "line", "part", "Len", "lim", "min", "le", "length", "size", "ln", "id", "data", "limit", "str", "no", "sl", "el", "n", "iter", "fin", "f", "lin"]}}
{"id1": "2324868", "id2": "4629990", "code1": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "code2": "    private String logonToServer(FTPClient ftpClient, String ftpAddress, int noRetries) {\n        String remoteHomeDir = null;\n        noRetriesSoFar = 0;\n        while (true) {\n            try {\n                ftpClient.connect(ftpAddress, ftpPort);\n                int reply = ftpClient.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftpClient.disconnect();\n                    throw new IOException();\n                }\n                if (!ftpClient.login(user, password)) {\n                    throw new IOException();\n                }\n                remoteHomeDir = ftpClient.printWorkingDirectory();\n                msgEntry.setAppContext(\"logonToServer()\");\n                msgEntry.setMessageText(\"Logged into FTP server \" + ftpAddress + \":\" + ftpPort + \" as user \" + user);\n                logger.logProcess(msgEntry);\n                break;\n            } catch (IOException e) {\n                logoutAndDisconnect(ftpClient);\n                if (noRetriesSoFar++ < noRetries) {\n                    waitBetweenRetry();\n                    notifyAndStartWaitingFlag = false;\n                } else {\n                    notifyAndStartWaitingFlag = true;\n                    errEntry.setThrowable(e);\n                    errEntry.setAppContext(\"logonToServer()\");\n                    errEntry.setAppMessage(\"Unable to login after \" + (noRetriesSoFar - 1) + \" retries. Max Retries.\\n\" + \"Address:\" + ftpAddress + \"\\n\" + \"User:\" + user);\n                    errEntry.setSubjectSendEmail(\"Unable to login to \" + ftpAddress + \" after \" + (noRetriesSoFar - 1) + \" retries.\");\n                    logger.logError(errEntry);\n                    break;\n                }\n            }\n        }\n        return remoteHomeDir;\n    }\n", "label": 0, "substitutes": {"actionPerformed": [" actionExecuted", "actionExecressed", "actionExecuted", "actionExecalled", "actionPerressed", " actionExecressed", "actionCformed", "actionPeralled", "actionExecformed", " actionPerressed", " actionPeruted", "actionOccressed", "actionCressed", "actionCuted", " actionExecalled", "actionPeruted", "actionOccalled", " actionPeralled", "actionOccuted", "actionOccformed", "actionCalled", " actionExecformed"], "e": ["de", "q", "self", "event", "exc", "et", "E", "events", "c", "g", "t", "type", "se", "an", "v", "x", "me", "es", "name", "ception", "a", "ae", "ev", "te", "ctx", "ec", "f", "ee"], "delim": ["selim", "Delam", "Delimmer", "elam", "flcm", "selem", " delam", "flim", "flam", "selam", " delcm", "Delcm", "delimmer", "Delm", "delem", "delcm", " delimmer", "flimmer", "Delem", "Delim", "delam", "selm", "elem", "elm", "elim", "delm"], "r": ["re", "err", "dr", "lr", "fr", "rx", "kr", "w", "rt", "ir", "rar", "l", "writer", "adr", "ws", "pr", "c", "rc", "tr", "ru", "er", "p", "rr", "nr", "rh", "rs", "hr", "sr", "R", "rss", "reader", "rb", "i", "res", "n", "rw", "ar", "br", "rl", "cr", "f", "iter"], "line": ["re", "rule", "link", "log", "look", "lc", "feed", "end", "nl", "val", "lf", "cl", "lines", "entry", "inline", "LINE", "text", "Line", "key", "l", "page", "style", "string", "code", "pe", "pass", "split", "job", "row", "response", "number", "le", "block", "lin", "name", "col", "word", "sel", "id", "file", "data", "cell", "str", "comment", "rl", "reader", "one", "no", "el", "value", "time", "fin", "source", "sl", "header"], "url": ["link", "err", "log", "URL", "base", "resource", "fr", "lr", "www", "nl", "Url", "ls", "http", "l", "string", "path", "fl", "org", "uri", "pull", "blog", "client", "ur", "ssl", "sr", "server", "file", "ob", "jar", "sl", "rl", "connection", "loc", "host", "web", "f"], "conn": ["enc", "err", "conv", "nt", "coll", "dc", "w", "cl", "open", "nc", "cur", "ctrl", "rt", "Connection", "http", "sync", "l", "ch", "api", "cb", "pr", "ann", "sql", "c", "cf", "ct", "gr", "rc", "db", "p", "io", "out", "fp", "client", "pub", "socket", "ssl", "cm", "co", "con", "cn", "rn", "connect", "lock", "Conn", "n", "ctx", "cp", "connection", "loc", "cr", "f"], "wr": ["err", "wb", "dr", "vr", "fr", "rx", "wave", "kr", "wl", "w", "write", "rt", "fw", "rar", "wer", "wh", "writer", "wd", "RW", "pr", "ew", "wt", "gr", "wa", "wx", "wrap", "rr", "nw", "nr", "rh", "wk", "mr", "out", "wm", "rs", "riter", "Writer", "hr", "sr", "war", "Wr", "wy", "WR", "rw", "rb", "res", "wal", "cr", "shr", "rss"], "tokens": ["takoks", "tokenets", "pokelines", "tkens", "toyos", "tOKets", "Takoks", "pargelines", "Tokens", "Tokicks", "takos", "tOKelines", "takicks", "itokets", "torkicks", "tken", "tokets", "tokenos", "torken", "torkoks", "pokets", "toyen", "itokenets", "tokos", "poken", "tokicks", "pokens", "targelines", "toyets", "pargens", "taken", "itokenen", "token", "takens", "Token", "takets", "targen", "tOKen", "tokenens", "Takicks", "itokenos", "pargets", "itokos", "pargen", "itokenens", "Taken", "tkicks", "tkoks", "tOKens", "itoken", "toyens", "tokelines", "targets", "tokenen", "itokens", "takelines", "tokoks", "targens", "Tokoks", "torkens", "Takens"], "in": ["ini", "kin", "err", "inner", "inn", "gin", "arin", "input", "In", "inc", "bin", "pin", "IN", "zin", "again", "tin", "ic", "oin", "nin", "io", "it", "cin", "sin", "min", "out", "pull", "ins", "is", "init", "inas", "thin", "con", "ln", "data", "rin", "isin", "ina", "str", "reader", "win", "i", "n", "vin", "din", "lin"]}}
{"id1": "8973505", "id2": "9824814", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void run() {\n        if (status == COMPLETE) {\n            return;\n        }\n        waitRandom();\n        RandomAccessFile file = null;\n        InputStream inputStream = null;\n        boolean success = false;\n        URL url = null;\n        try {\n            BeatportAccessor beatportAccessor = new BeatportAccessor();\n            if (sessionCookies == null) {\n                sessionCookies = beatportAccessor.getSessionCookies(user, password);\n            }\n            url = new URL(new BeatportAccessor().getTrackDownloadUrl(downloadId, sessionCookies));\n            log.info(\"Open (DownloadWorker.run): \" + url);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", BeatportAccessor.userAgent);\n            connection.setRequestProperty(\"Cookie\", sessionCookies);\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                log.error(\"Unexpected response from server: \" + connection.getResponseCode());\n                error();\n                return;\n            }\n            if (connection.getContentType().indexOf(\"text\") >= 0) {\n                log.error(\"Tried to request: \" + url.toString());\n                log.error(\"Unexpected file content type from server: \" + connection.getContentType());\n                log.error(\"Server replied:\\n\" + getContentAsString(connection));\n                error();\n                return;\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                log.error(\"Invalid content length: \" + connection.getContentLength());\n                error();\n                return;\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            } else if (size != contentLength) {\n                changeTotal(0, contentLength - size);\n            }\n            if (new File(tmpFileName(fileName)).exists()) {\n                if (!new File(tmpFileName(fileName)).delete()) {\n                    throw new Exception(\"Could not delete file: \" + tmpFileName(fileName));\n                }\n            }\n            file = new RandomAccessFile(tmpFileName(fileName), \"rw\");\n            file.seek(downloaded);\n            inputStream = connection.getInputStream();\n            if (started == 0) {\n                started = System.currentTimeMillis();\n                time = started;\n            }\n            statusChangedObserver.statusChanged(status);\n            byte buffer[] = new byte[MAX_BUFFER_SIZE];\n            while (status == DOWNLOADING) {\n                if (size - downloaded < MAX_BUFFER_SIZE) {\n                    buffer = new byte[(int) (size - downloaded)];\n                }\n                int read = inputStream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                changeTotal(read, 0);\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                stopped = System.currentTimeMillis();\n                status = COMPLETE;\n            }\n            statusChangedObserver.statusChanged(status);\n            stateChanged();\n            success = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            error();\n        } finally {\n            try {\n                file.close();\n            } catch (Exception e) {\n            }\n            if (success) {\n                try {\n                    if (!new File(tmpFileName(fileName)).renameTo(new File(fileName))) {\n                        throw new Exception(\"Rename Failed\");\n                    }\n                } catch (Exception e) {\n                    log.error(\"Error moving temp file \" + tmpFileName(fileName) + \" file: \" + fileName, e);\n                }\n            } else {\n                try {\n                    new File(tmpFileName(fileName)).delete();\n                } catch (Exception e) {\n                    log.error(\"Error deleting erroneous temp file: \" + tmpFileName(fileName), e);\n                }\n            }\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                log.error(\"Error closing input stream of: \" + url + \" / \" + fileName, e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"writeFileType": ["createFileTypes", "writeFileHeader", "writeFILEType", "createFilestype", "writeFileTypes", "writeFilesHeader", "writePageType", "writeFilesTypes", "writeFILEHeader", "writeFILEtype", "writeFiletype", "writeFilesType", "createFileHeader", "writeFILETypes", "createFileType", "createFiletype", "createFilesHeader", "writeFilestype", "writePageHeader", "createFilesType", "createFilesTypes", "writePagetype", "writePageTypes"], "uriFile": ["riFile", "URIfile", "URIUrl", "filenamefile", "uiFiles", "rifile", "URIFile", "filenameFilename", "URIFilename", "uiUrl", "filenameFiles", "filenameFile", "urifile", "riFiles", "riUrl", "riFilename", "uriUrl", "uifile", "URIFiles", "uiFile", "uriFiles", "uriFilename"], "outputfile": [" outputFile", "resourcefiles", "resourcefilename", "Outputfull", "inputfull", "unitstring", "resourcefile", "unitfile", " outputfull", "OutputFile", "inputfile", "outputfilename", "inputfilename", " outputdir", "unitfilename", "outputdir", "outputfull", "outputfiles", "inputFile", "Outputfile", "inputdir", "outputstring", "unitfiles", "inputfiles", "inputstring", "resourcestring", "Outputdir", "outputFile"], "num": ["coord", "index", "nb", "Num", "dim", "unit", "offset", "umi", "common", "master", "count", "nam", "initial", "split", "multi", "NUM", "len", "number", "loop", "length", "nu", "name", "term", "mult", "sum", "col", "con", "span", "limit", "no", "zero", "amount", "n", "batch", "inc"], "writer": ["unit", "temp", "walker", "wl", "format", "window", "journal", "page", "null", "element", "width", "layer", "xml", "report", "per", "source", "editor", "service", "wave", "outer", "write", "function", "wan", "ler", "output", "style", "driver", "builder", "engine", "r", "session", "wr", "handler", "writers", "io", "loader", "server", "document", "writ", "book", "header", "method", "written", "office", "inner", "entry", "worker", "master", "later", "object", "ws", "we", "wt", "external", "creator", "wa", "er", "type", "wire", "out", "riter", "Writer", "data", "lock", "rw", "socket", "ee", "writing", "wb", "index", "feed", "root", "w", "message", "widget", "key", "buffer", "author", "part", "manager", "wrapper", "e"], "uri": ["unit", "resource", "nor", " URI", "filename", "href", "ui", "ri", "element", "collection", "query", "multi", "doi", "context", "verb", "component", "file", "binary", "username", "theme", "connection", "source", "directory", "origin", "folder", "ilo", "umi", "cli", "string", "pi", "gi", "token", "handler", "uni", "URI", "du", "id", "reference", "document", "database", "plugin", "mi", "base", "prefix", "iri", "direction", "remote", "uid", "node", "attribute", "oid", "eni", "nil", "term", "di", "wiki", "location", "address", "link", "course", "sequence", "metadata", "hub", "picture", "http", "message", "route", "li", "winner", "ori", "qi", "range", "i", "feature"], "counter": ["lc", "index", "batch", "repeat", "ver", "outer", "offset", "continue", "current", "coll", "step", "inner", "sequence", "meter", "entry", "inter", "worker", "master", "count", "parser", "info", "race", "page", "clock", "condition", "collection", "creator", "vector", "computer", "handler", "hello", "Counter", "record", "pointer", "result", "currency", "number", "nr", "loop", "controller", "ner", "cookie", "expression", "loader", "name", "trace", "runner", "keep", "ter", "server", "reference", "instance", "comment", "second", "i", "keeper", "timer", "enter", "iter", "cpu", "time", "parent", "book", "processor"], "reader": ["in", "lr", "feed", "rx", "stream", "rer", "inner", "worker", "reading", "ler", "parser", "rar", "bird", "ir", "l", "ger", "ruby", "finder", "read", "driver", "ri", "r", "buffer", "oder", "handler", "er", "io", "rr", "row", "layer", "ner", "loader", "riter", "e", "Reader", "per", "keeper", "iter", "upper", "editor"], "url": ["link", "image", "URL", "base", "resource", "www", "feed", "stream", "download", "Url", "ls", "channel", "http", "text", "l", "page", "string", "ri", "path", "li", "io", "blog", "client", "ssl", "server", "user", "file", "id", "browser", "sl", "connection", "config", "source", "web", "plugin", "address"], "myConnection": ["someConn", "yourConn", "someConnection", "someConnect", "yourconnection", " myConn", "yourConnection", "myconnection", "yourConnector", "MyConnector", "MyConn", " myConnector", "myConnect", " myConnect", "MyConnect", "someReader", "MyReader", "MyConnection", "myConnector", "myConn", " myconnection", "Myconnection"], "myReader": ["myParser", "MyRead", "yourRead", "myWriter", " myWriter", "yourWriter", " myRead", " myParser", "MyWriter", "MyParser", "yourParser", "yourReader", "myRead", "MyReader"], "line": ["look", "link", "rule", "log", "letter", "base", "lc", "feed", "end", "liner", "point", "lf", "cl", "lines", "entry", "inline", "LINE", "parse", "text", "message", "day", "Line", "key", "use", "l", "column", "page", "style", "string", "ri", "code", "element", "pe", "pass", "note", "part", "frame", "row", "response", "le", "block", "name", "du", "word", "data", "file", "range", "id", "cell", "user", "header", "comment", "el", "no", "error", "non", "source", "lin"], "linecount": ["linelen", "letterlen", "Linesize", "lineCount", "linecache", "rowcache", "letterlength", "Linenumber", " linenumber", "rowlen", "lettercount", "linenumber", "Linecount", " linelen", "linesize", "rowlength", " lineCount", " linecache", "Lineindex", "linelength", " linelength", "lettersize", "pageCount", "pagecount", " linesize", " lineindex", "lineindex", "pageindex", "rowcount", "LineCount", "Linecache", "rowsize", "pagenumber"], "hasOWL": ["HasEWLL", "HasEWL", "hasBYDL", "hasODL", "hasEFL", "hasEWLM", "hasOWLA", "hasEWDL", "hasOULL", "hasBYLL", "HasEWLM", " hasOWl", "HasOWL", "HasOWLM", "hasODLL", "hasOWSL", "hasOWDL", "hasEWLL", " hasEWDL", "hasOULA", " hasEWLL", " hasEWLA", "hasODLM", "hasODLA", "hasOUL", "hasEFLM", " hasOWLL", "hasOWLM", " hasEWl", "hasBYL", "HasOWLL", "hasOWSl", "HasOWLA", "hasEFLA", "hasEWl", "hasEWL", "hasEWLA", " hasOWLA", " hasOWLM", "HasEWLA", " hasEWL", "hasOWLL", "hasOULM", "hasOWSLL", "hasBYl", " hasEWLM", " hasOWDL", "hasOWl", "hasEFl", "hasOWSDL", "hasODl"], "hasRDFS": ["hasCDFs", "hasRDPSU", "hasXDPU", "hasCDPs", "hasGRUFS", "hasRDPAST", "hasRdfs", "hasRDFU", "hasRFAST", "hasRNFs", "hasCDPS", "hasRTFs", "hasCDFS", "hasCDPE", "hasRFES", "hasRFs", "hasRUFs", "hasXDPE", "hasGRUFs", "hasRDFAST", "hasRDFs", "hasXDFS", "hasRTFES", "hasXDPS", "hasXDFs", "hasGRDFs", "hasRFS", "hasRdfS", "hasCDFES", "hasRDFES", "hasRNFU", "hasGRDFAST", "hasXDFE", "hasRDPs", "hasRDFE", "hasGRUFSU", "hasRDPE", "hasRDFSU", "hasRDPU", "hasRFE", "hasRNFS", "hasRNFE", "hasRUFS", "hasRFSU", "hasGRDFS", "hasRDPES", "hasCDPES", "hasRdfE", "hasRUFSU", "hasGRDFSU", "hasRDPS", "hasRTFS", "hasRUFAST", "hasRdfU", "hasCDFE", "hasRTFE", "hasXDFU", "hasXDPs", "hasGRUFAST"], "hasRDF": ["hasURFD", "hasRUF", "hasURMF", "yesDDF", "hasRRFD", "HasRDF", "HasRRDEF", "hasRRDF", "hasUOW", "HasRRDF", "hasNRFD", "hasDDF", "hasROW", "HasRDEF", "HasRRDP", " hasRMF", "hasDMF", " hasRUF", " hasRRDF", "hasMRdf", "hasRRUF", " hasRRFD", "hasMRDP", "hasRDP", "yesDOW", "yesROW", "hasRRDP", "yesRDF", " hasRFD", "hasDOW", "hasUDP", "hasRFD", "yesRDP", "hasDDP", "hasRRDEF", "hasRRMF", "hasSRDP", "hasSRDEF", "yesRMF", "hasRMF", "yesDMF", "hasSRDF", "hasNRDF", " hasRRMF", "hasRDEF", "hasMRDEF", "yesDDP", "HasRRdf", "hasNRMF", "hasSRdf", "hasNRUF", "hasUMF", "HasRDP", "hasRdf", " hasRRUF", "hasRRdf", "hasUDF", "HasRdf", "hasURUF", "hasURDF", "hasMRDF"]}}
{"id1": "189963", "id2": "1421557", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewrites", "readAndRebwrite", "readandrewrite", "readAndSwwrite", "readAndRewwrite", "readAndSwrap", "readAndSwrite", "readandRewrite", "readAndrewrap", "readAndRewrap", "readAndRebrites", "readandrewwrite", "readAndRebrap", "readandRewrap", "readandRewrites", "readAndSwrites", "readandrewrites", "readAndrewrite", "readAndrewwrite", "readAndRebrite", "readandRewwrite", "readAndRewrites", "readandrewrap"], "inFile": ["inFilename", "loginFile", "outFilename", "inputfile", "InFiles", "InFile", " inFiles", "oldFile", "loginFilename", " inSourceFile", "outSourceFile", "InSourceFile", "inputFiles", "outFiles", "oldFiles", " inFilename", "loginFiles", "inputFile", "inSourceFile", "loginfile", "outfile", " infile", "inputFilename", "inFiles", "oldfile", "infile", "oldFilename", "Infile"], "outFile": [" outStream", "offPlace", "outFilename", " outDir", "outputPlace", "outFILE", "OutStream", "outputFilename", "newDir", " outfile", "thisFILE", "outputFile", "offFile", "outDir", "processFilename", "exfile", "exFILE", "newfile", "processPlace", "thisFile", "processFILE", "thisfile", "offFilename", "thisFilename", "outStream", "outPlace", "newFile", "exFile", "exFilename", "outfile", "outputfile", "OutFile", "outputFILE", "OutDir", "offFILE", "processFile", "newStream", "Outfile"], "iis": ["iniis", "Iiss", "iiIs", "iiIS", " iIS", " iIs", "iIs", "iniiss", "ciiss", "ciis", "Iis", "Iais", " iris", "IIS", "ciais", "ciIs", "iiss", "ciris", "iniIS", "iniIs", "iiris", "iiis", "iiiss", "ciIS", "iniris", "iais", " iiss", "iris", "iIS", " iais"], "dcmParser": ["dcmHelper", "dpmarser", "dmcPar", "dmoduleJar", "dmcJar", "dcmPar", "dbmPolicy", "dCMPlugin", "dmoduleParser", "dcmJar", "fcmHandler", "dcrPar", "fpmParser", "dmcarser", "dpmparser", "dbmHelper", "dmissionReader", "dpmLoader", " dpmLoader", "dcrReader", "dbmPlugin", "dCMParser", "dmoduleparser", "dpmPolicy", " dcrParser", "dmPlugin", "dkmHelper", "DcmInstallation", "dmmParser", "dcmparser", " dpmPolicy", " dcmPlugin", "dcmLoader", " dpmHelper", "dmLoader", "dhemReader", "dcmarser", "dpmHelper", "dbmParser", "fpmHandler", "dpmHandler", "dhemParser", "dcrJar", "dpmJar", " dcmLanguage", "fcmParser", "dcrarser", "dcmPolicy", "dkmParser", "dpmInstallation", " dpmJar", "dmodulePlugin", "dmmparser", "dcmLanguage", "dhemInstallation", "dcmInstallation", "fpmparser", "dpmParser", " dpmparser", " dcmPar", "dcmHandler", "dcrPlugin", "dmcParser", " dcmparser", "dcmReader", " dcrReader", "fcmReader", "DcmReader", " dpmPlugin", "dCMparser", "dpmLanguage", " dpmReader", "dmParser", "dmoduleReader", "dmissionPlugin", "dhemJar", " dpmPar", " dcrLoader", "dpmPar", "fpmReader", "dcrParser", "DcmJar", "dmissionParser", " dcmReader", "dCMHandler", "dpmPlugin", " dpmarser", " dpmLanguage", "dmmPlugin", " dcmarser", "dkmPolicy", " dcmHelper", " dcmLoader", "fcmparser", "dpmReader", " dpmParser", "dmReader", " dcmJar", " dcrPlugin", "dCMReader", "dmmLoader", "DcmParser", " dcmPolicy", "dkmPlugin", "dcmPlugin", "dCMLoader", "dcrLoader", "dmissionLanguage"], "ds": ["dd", "dr", "vals", "des", "ants", "os", "vs", "dc", "amps", "dat", "utils", "DS", "ls", "services", "details", "Ds", "ads", "src", "ns", "points", "sync", "ld", "conn", "js", "ws", "da", "ts", "ays", "cdn", "xs", "ps", "session", "d", "ils", "Db", "dt", "ros", "Os", "tes", "cs", "df", "uds", "dds", "ras", "eps", "gd", "ins", "iss", "qs", "is", "rs", "ys", "gs", "icks", "nas", "bs", "data", "sys", "pd", "ss", "tx", "ks", "di", "asi", "db", "parts", "drivers", "s"], "pdReader": ["ddRunner", "hdWriter", "hdLoader", "xdRead", "hdStream", "pcLoader", "pdStream", "pbLoader", "dsLoader", "pbReader", "ddLoader", "pcRead", "ddReader", "pdreader", "xdWriter", "hdReader", "hdRunner", "hdreader", "pbRunner", "ddStream", "pcWriter", "dsreader", "pdLoader", "pbStream", "dsReader", "xdReader", "hdRead", "pdRead", "pcReader", "dsRead", "xdreader", "pdRunner", "dsWriter"], "out": ["flow", "her", "model", "temp", "group", "list", "full", "page", "null", "again", "result", "img", "layer", "name", "file", "lib", "connection", "parent", "s", "device", "in", "o", "login", "outer", "child", "point", "to", "write", "cli", "over", "cache", "sync", "output", "OUT", "password", "conn", "auto", "builder", "code", "session", "pass", "outs", "doc", "io", "Out", "co", "sys", "user", "down", "copy", "err", "base", "inner", " in", "at", "exp", "later", "object", "array", "external", "line", "diff", "client", "ssl", "term", "ext", "data", "gen", "lock", "ex", "default", "inc", "db", "exec", "obj", "image", "dev", "w", "order", "with", "net", "up", "key", "writer", "store", "oder", "part", "director", "manager", "as", "word", "dot", "url"], "dcmEncParam": ["dcmEnParam", "dcmArchArg", "dcmEnPar", "dcmEnArg", "dcmDecParam", "dcmDecType", "dcmDecArg", "dcmElType", "dcmArchParameter", "dcmEncArg", "dcmEnPart", "dcmElPar", "dcmArchParam", "dcmEncType", "dcmSecParam", "dcmEnType", "dcmDecPar", "dcmEstParameter", "dcmDecParameter", "dcmEncPart", "dcmEncParameter", "dcmEstPar", "dcmEncPar", "dcmElParam", "dcmEnParameter", "dcmElParameter", "dcmEstParam", "dcmSecType", "dcmDecPart", "dcmSecPar", "dcmEstType", "dcmSecPart"], "pdWriter": ["htReader", "ddOutput", "htWriter", "hdWriter", "dpWriting", "htWrite", "dsOutput", "PDWrite", "PDWriter", "ddWrite", "ddReader", "hdReader", "pdOutput", "pdWrite", "dpReader", "dsWrite", "ddWriter", "PDReader", "PDWriting", "hdWrite", "dsReader", "pdWriting", "hdOutput", "dpWrite", "dpWriter", "dsWriter", "htWriting"]}}
{"id1": "19910627", "id2": "11704429", "code1": "    public String getData(DefaultHttpClient httpclient) {\n        try {\n            HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\");\n            get.setHeader(\"Content-Type\", \"application/json\");\n            get.setHeader(\"Accept\", \"*/*\");\n            HttpResponse response = httpclient.execute(get);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            responseMessage = read(instream);\n            if (instream != null) instream.close();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return responseMessage;\n    }\n", "code2": "    public void run() {\n        RandomAccessFile file = null;\n        InputStream stream = null;\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=\" + downloaded + \"-\");\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                error();\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                error();\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            }\n            file = new RandomAccessFile(destination, \"rw\");\n            file.seek(downloaded);\n            stream = connection.getInputStream();\n            while (status == DOWNLOADING) {\n                byte buffer[];\n                if (size - downloaded > MAX_BUFFER_SIZE) {\n                    buffer = new byte[MAX_BUFFER_SIZE];\n                } else {\n                    buffer = new byte[size - downloaded];\n                }\n                int read = stream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                status = COMPLETE;\n                stateChanged();\n            }\n        } catch (Exception e) {\n            error();\n        } finally {\n            if (file != null) {\n                try {\n                    file.close();\n                } catch (Exception e) {\n                }\n            }\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (Exception e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getData": ["readFeed", "readData", "printFeed", "getdata", "readContent", "postdata", "printContent", "postData", "postContent", "readdata", "printdata", "printData", "getContent", "postFeed", "getFeed"], "httpclient": ["ttpserver", "Httpconnection", "httpsserver", " httpserver", "Httpclient", "httpsclient", " httpClient", "httpscache", "httpconnection", " httpcache", "httpsClient", "ttpClient", "ttpcache", "phpClient", "Httpserver", "httpcache", "httpClient", " httpconnection", "phpclient", "phpserver", "httpserver", "HttpClient", "ttpclient", "phpconnection"], "get": ["body", "method", "base", "service", "resource", "create", "send", "check", "write", "json", "open", "find", "parse", "http", "load", "add", "generic", "use", "remote", "api", "enable", "full", "show", "update", "read", "set", "g", "query", "single", "GET", "it", "build", "pull", "handle", "client", "Get", "start", "init", "request", "ge", "make", "e", "call", "put", "i", "like", "exec", "invoke"], "response": ["onse", "body", "resource", "feed", "event", "Response", "json", "http", "message", "output", "api", "respond", "page", "application", "status", "collection", "resp", "success", "result", "out", "client", "report", "ception", "received", "request", "server", "data", "document", "e", "error", "connection", "reply"], "entity": ["body", "image", "unit", "resource", "event", "content", "json", "http", "message", "output", "api", "media", "environment", "object", "application", "element", "pe", "collection", "result", "ent", "issue", "ce", "client", "xml", "article", "component", "data", "file", "document", "server", "e", "person", "el", "activity", "em", "Entity", "connection"], "instream": ["inprogress", "outchannel", "Inform", "inputstream", "inStream", " inchannel", "inputStream", "outstream", "Instream", "Inprogress", "outprogress", " inStream", "outStream", "insfile", "Inchannel", "InStream", "outform", "outfile", "insstream", " infile", "insStream", "inputprogress", " inform", "infile", "inschannel", "inchannel", "inform", "inputform", "Infile"], "responseMessage": [" responsemessage", " responseBody", "ResponseContent", "responseContent", "responseMsg", "respondContent", "respondMsg", "responseBody", "ResponseBody", "responsemessage", "Responsemessage", " responseMsg", "respondBody", " responseContent", "ResponseMsg", "ResponseMessage", "respondmessage", "respondMessage"]}}
{"id1": "149935", "id2": "2668634", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["oconversion", "CONversion", "oconverting", " deconverted", "CONverting", " deconvert", "conception", "CONception", " deconverting", "unverted", "subversion", "CONverted", "Conception", " deconversion", "oconvert", "unversion", "converted", "unception", "subvert", "conversion", "Convert", "unvert", "Converted", "subverted", "subverting", "converting", "oconverted", "Converting", "Conversion", "CONvert"], "src": ["video", "resource", "storage", "config", "stream", "Source", "impl", "gz", "RC", "input", "download", "feat", "req", "ref", "load", "back", "filename", "slice", "href", "cb", "prot", "url", "string", "code", "buf", "gb", "spec", "dist", "cpp", "rc", "stage", "sn", "path", "st", "sc", "cmp", "upload", "ource", "uri", "sb", "proc", "SourceFile", "sin", "img", "fp", "supp", "attr", "sit", "secure", "tmp", "name", "ssl", "Dest", "sel", "sys", "component", "file", "fn", "inst", "username", "sth", "reader", "rb", "rl", "ctx", "scene", "loc", "source", "obj", "s"], "dest": [" destination", "temp", "cont", "dc", "dat", "target", "bin", "home", "null", "txt", "class", "orig", "lib", "dist", "path", " dst", "img", "dir", "std", "tmp", "test", "Dest", "fn", "di", "source", "obj", "disk"], "in": ["ini", "err", "login", "stream", "inn", "inf", "val", "input", "In", "up", "bin", "pin", "r", "IN", "ps", "t", "pass", "d", "doc", "source", "io", "ins", "is", "as", "inas", "a", "data", "isin", "file", "ex", "i", "reader", "win", "n", "din", "f", "inc"], "p": ["np", "j", "o", "po", "pre", "py", "P", "pc", "cop", "parser", "l", "b", "jp", "pr", "bp", "lp", "pi", "pp", "sp", "pe", "c", "r", "wp", "g", "ps", "t", "pa", "d", "op", "pg", "part", "pm", "v", "fp", "pb", "h", "tp", "pd", "e", "i", "per", "cp", "m", "f", "s"], "ds": ["ths", "dp", "vals", "ls", "services", "ads", "ld", "lp", "groups", "dt", " ps", "os", "ins", "icks", "nas", "ts", "dates", "scripts", "s", "dc", "dat", "Ds", "points", "els", "sync", "tools", "ipes", "xs", "obs", "sts", "d", "ils", "dds", "hs", "gs", "docs", "sys", "pd", "dm", "ss", "dl", "des", "posts", " DS", "utils", "cons", "lines", "ns", "ges", "da", "tests", "ays", "dist", " props", "eps", "cs", "df", "uds", "gd", "qs", "ys", "data", "ded", "ks", "words", "di", "db", "parts", "dd", "ants", "vs", "amps", "ans", "DS", "dos", "plugins", "styles", "js", "ps", "rs", "ups", "models", "bs", " sd"], "format": ["letter", "model", "unit", "nat", "plugin", "prefix", "form", "function", "pattern", "at", "feat", "filter", "version", "parser", "atter", "filename", "sche", "api", "table", "Format", "struct", "style", "string", "class", "scale", "act", "spec", "t", "fd", "path", "handler", "ant", "template", "source", "type", "record", "part", "frame", "fp", "name", "language", "host", "data", "file", "layout", "fn", "magic", "config", "tag", "f", "url"], "hasPixelData": ["hasPixelStyle", "haspixeldata", "showsByteDATA", "hasByteStyle", " hasPixelSize", "hasByteDATA", "showsPixelDATA", "hasPixelDATA", "hasPictureSize", "hasPixeldata", "hasByteData", "hasPixelSize", "showsPixelData", "haspixelData", "hasPicturedata", "showsByteData", "hasByteSize", "showsByteStyle", "haspixelSize", "showsPixeldata", "showsBytedata", "showsPixelStyle", "hasBytedata", "hasPictureData", " hasPixeldata"], "inflate": ["inadequode", "infloation", "inadequATE", "InFlace", "infloace", "Inflation", "inflation", "InFlate", "Inflated", "inflode", "infolode", "insflating", "invenate", "insvenate", "infolate", "Inflate", "infolATE", "infolating", "InFlated", "insvenATE", "invenating", "inFlace", "inflace", "insflode", "invenode", "inadequating", "insvenating", "inffate", "InFlation", "insflate", "inffation", "invenATE", "infloated", "inffated", "inflating", "inFlate", "Inflace", "insflATE", "infface", "infloate", "inFlated", "inadequate", "insvenode", "inflated", "inflATE", "inFlation"], "pxlen": ["pxden", "pxdata", "mxlen", "campos", "pxln", "mxln", "pxlon", "camln", "mxcount", "pxlin", "pngsize", "xplength", "fxln", "xpsize", "pgden", "ppl", "pplen", "fxden", "pxsize", "pxcount", "fxpos", "axlin", "pclon", "ppLen", "pnglength", "txlon", "pnglen", "pxl", "mxlength", "xplen", "xpcount", "axlen", "txlin", "txln", "pxpos", "ppden", "mxdata", "pglen", "pgLen", "mxpos", "pxlength", "fxl", "pclen", "pgl", "camlen", "pclin", "camdata", "axln", "txlen", "pcln", "fxLen", "pxLen", "mxsize", "fxdata", "pngcount", "fxlen", "axlon"], "out": ["re", "err", "log", "point", "step", "cli", "inter", "up", "group", "cache", "output", "OUT", "list", "conn", "post", "page", "pad", "store", "session", "state", "again", "outs", "work", "query", "line", "io", "v", "Out", "co", "dump", "sys", "server", "user", "gen", "lock", "error", "lib", "parent", "obj", "copy"]}}
{"id1": "530882", "id2": "364438", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewrites", "readAndRebwrite", "readandrewrite", "readAndSwwrite", "readAndRewwrite", "readAndSwrap", "readAndSwrite", "readandRewrite", "readAndrewrap", "readAndRewrap", "readAndRebrites", "readandrewwrite", "readAndRebrap", "readandRewrap", "readandRewrites", "readAndSwrites", "readandrewrites", "readAndrewrite", "readAndrewwrite", "readAndRebrite", "readandRewwrite", "readAndRewrites", "readandrewrap"], "inFile": ["inFilename", "loginFile", "outFilename", "inputfile", "InFiles", "InFile", " inFiles", "oldFile", "loginFilename", " inSourceFile", "outSourceFile", "InSourceFile", "inputFiles", "outFiles", "oldFiles", " inFilename", "loginFiles", "inputFile", "inSourceFile", "loginfile", "outfile", " infile", "inputFilename", "inFiles", "oldfile", "infile", "oldFilename", "Infile"], "outFile": [" outStream", "offPlace", "outFilename", " outDir", "outputPlace", "outFILE", "OutStream", "outputFilename", "newDir", " outfile", "thisFILE", "outputFile", "offFile", "outDir", "processFilename", "exfile", "exFILE", "newfile", "processPlace", "thisFile", "processFILE", "thisfile", "offFilename", "thisFilename", "outStream", "outPlace", "newFile", "exFile", "exFilename", "outfile", "outputfile", "OutFile", "outputFILE", "OutDir", "offFILE", "processFile", "newStream", "Outfile"], "iis": ["iniis", "Iiss", "iiIs", "iiIS", " iIS", " iIs", "iIs", "iniiss", "ciiss", "ciis", "Iis", "Iais", " iris", "IIS", "ciais", "ciIs", "iiss", "ciris", "iniIS", "iniIs", "iiris", "iiis", "iiiss", "ciIS", "iniris", "iais", " iiss", "iris", "iIS", " iais"], "dcmParser": ["dcmHelper", "dpmarser", "dmcPar", "dmoduleJar", "dmcJar", "dcmPar", "dbmPolicy", "dCMPlugin", "dmoduleParser", "dcmJar", "fcmHandler", "dcrPar", "fpmParser", "dmcarser", "dpmparser", "dbmHelper", "dmissionReader", "dpmLoader", " dpmLoader", "dcrReader", "dbmPlugin", "dCMParser", "dmoduleparser", "dpmPolicy", " dcrParser", "dmPlugin", "dkmHelper", "DcmInstallation", "dmmParser", "dcmparser", " dpmPolicy", " dcmPlugin", "dcmLoader", " dpmHelper", "dmLoader", "dhemReader", "dcmarser", "dpmHelper", "dbmParser", "fpmHandler", "dpmHandler", "dhemParser", "dcrJar", "dpmJar", " dcmLanguage", "fcmParser", "dcrarser", "dcmPolicy", "dkmParser", "dpmInstallation", " dpmJar", "dmodulePlugin", "dmmparser", "dcmLanguage", "dhemInstallation", "dcmInstallation", "fpmparser", "dpmParser", " dpmparser", " dcmPar", "dcmHandler", "dcrPlugin", "dmcParser", " dcmparser", "dcmReader", " dcrReader", "fcmReader", "DcmReader", " dpmPlugin", "dCMparser", "dpmLanguage", " dpmReader", "dmParser", "dmoduleReader", "dmissionPlugin", "dhemJar", " dpmPar", " dcrLoader", "dpmPar", "fpmReader", "dcrParser", "DcmJar", "dmissionParser", " dcmReader", "dCMHandler", "dpmPlugin", " dpmarser", " dpmLanguage", "dmmPlugin", " dcmarser", "dkmPolicy", " dcmHelper", " dcmLoader", "fcmparser", "dpmReader", " dpmParser", "dmReader", " dcmJar", " dcrPlugin", "dCMReader", "dmmLoader", "DcmParser", " dcmPolicy", "dkmPlugin", "dcmPlugin", "dCMLoader", "dcrLoader", "dmissionLanguage"], "ds": ["dd", "dr", "vals", "des", "ants", "os", "vs", "dc", "amps", "dat", "utils", "DS", "ls", "services", "details", "Ds", "ads", "src", "ns", "points", "sync", "ld", "conn", "js", "ws", "da", "ts", "ays", "cdn", "xs", "ps", "session", "d", "ils", "Db", "dt", "ros", "Os", "tes", "cs", "df", "uds", "dds", "ras", "eps", "gd", "ins", "iss", "qs", "is", "rs", "ys", "gs", "icks", "nas", "bs", "data", "sys", "pd", "ss", "tx", "ks", "di", "asi", "db", "parts", "drivers", "s"], "pdReader": ["ddRunner", "hdWriter", "hdLoader", "xdRead", "hdStream", "pcLoader", "pdStream", "pbLoader", "dsLoader", "pbReader", "ddLoader", "pcRead", "ddReader", "pdreader", "xdWriter", "hdReader", "hdRunner", "hdreader", "pbRunner", "ddStream", "pcWriter", "dsreader", "pdLoader", "pbStream", "dsReader", "xdReader", "hdRead", "pdRead", "pcReader", "dsRead", "xdreader", "pdRunner", "dsWriter"], "out": ["flow", "her", "model", "temp", "group", "list", "full", "page", "null", "again", "result", "img", "layer", "name", "file", "lib", "connection", "parent", "s", "device", "in", "o", "login", "outer", "child", "point", "to", "write", "cli", "over", "cache", "sync", "output", "OUT", "password", "conn", "auto", "builder", "code", "session", "pass", "outs", "doc", "io", "Out", "co", "sys", "user", "down", "copy", "err", "base", "inner", " in", "at", "exp", "later", "object", "array", "external", "line", "diff", "client", "ssl", "term", "ext", "data", "gen", "lock", "ex", "default", "inc", "db", "exec", "obj", "image", "dev", "w", "order", "with", "net", "up", "key", "writer", "store", "oder", "part", "director", "manager", "as", "word", "dot", "url"], "dcmEncParam": ["dcmEnParam", "dcmArchArg", "dcmEnPar", "dcmEnArg", "dcmDecParam", "dcmDecType", "dcmDecArg", "dcmElType", "dcmArchParameter", "dcmEncArg", "dcmEnPart", "dcmElPar", "dcmArchParam", "dcmEncType", "dcmSecParam", "dcmEnType", "dcmDecPar", "dcmEstParameter", "dcmDecParameter", "dcmEncPart", "dcmEncParameter", "dcmEstPar", "dcmEncPar", "dcmElParam", "dcmEnParameter", "dcmElParameter", "dcmEstParam", "dcmSecType", "dcmDecPart", "dcmSecPar", "dcmEstType", "dcmSecPart"], "pdWriter": ["htReader", "ddOutput", "htWriter", "hdWriter", "dpWriting", "htWrite", "dsOutput", "PDWrite", "PDWriter", "ddWrite", "ddReader", "hdReader", "pdOutput", "pdWrite", "dpReader", "dsWrite", "ddWriter", "PDReader", "PDWriting", "hdWrite", "dsReader", "pdWriting", "hdOutput", "dpWrite", "dpWriter", "dsWriter", "htWriting"]}}
{"id1": "6988216", "id2": "5061606", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" runBasicConnect", "runRawQuery", " runSimpleConnect", " runBasicQuery", " runBasicSearch", " runSimpleFilter", " runClientSearch", " runClientFilter", "runSimpleConnect", "runSimpleFilter", "runSimpleSearch", " runSimpleQuery", " runBasicFilter", "runRawSearch", " runClientQuery", "runRawConnect", " runClientConnect", " runRawFilter", "runRawFilter", " runSimpleSearch", " runRawSearch", " runRawConnect", " runRawQuery", "runSimpleQuery"], "dummySource": ["puddyService", "dandySource", "dummyType", "dundleContent", "dellyService", "puddyType", "pummySite", "dumbContent", "dummyService", "dundleConfig", "duddyOrigin", "pummySource", "dumbSource", "puddySource", "dellySource", "daddyContent", " dumbSource", "puddyContent", "puddySourceFile", "pummyService", " dummyConfig", "puddySite", "dumbOrigin", "dummySourceFile", "dummySite", "daddySourceFile", "daddyService", "dundleOrigin", "dumbConfig", "duddySourceFile", "dandyClient", "duddyService", "dellyContent", "daddySource", " dumbOrigin", "duddyConfig", " dumbConfig", "pummyType", "duddySite", "duddyContent", "pummySourceFile", "puddyClient", "duddySource", " dummyOrigin", " dumbContent", "duddyType", "pummyContent", "dellyType", "dummyOrigin", "daddyClient", "dandySourceFile", "dummyClient", "daddyType", "dummyConfig", "pummyClient", "dandySite", "dundleSource", "duddyClient", "daddySite"], "os": ["ou", "o", "vs", "ops", "ls", "dos", "osi", "bos", "ox", "ns", "mos", "acs", "ms", "conn", "object", "pos", "obs", "ps", "ok", "ows", "op", "ds", "io", "ros", "om", "Os", "nos", "oss", "css", "out", "fs", "is", "cos", "as", "iso", "oS", "es", "oc", "ens", "us", "ori", "sys", "bs", "oa", "oses", "uns", "ose", "ol", "ios", "OS", "ss", "i", "ols", "oos", "ks", "or", "los", "aos", "s"], "dummyContent": ["DummyContent", "DuckyContent", "dummyReader", " dummyContents", "dellyContents", "dumperBody", "dumpingOutput", " dellycontent", " dummyOutput", "dumpingContent", "DummySource", "duddyReader", "DuckyBody", "dumperContent", "dumperSource", "dumpercontent", "dumpingContents", "DummyBody", "duckyReader", "dellyContent", "dumperContents", " dellyOutput", "dummyBody", " dellyContent", "duckySource", "duckyContent", "dummyContents", "dummyOutput", " dellyContents", "duddyContent", "dumpingcontent", "dumperOutput", "duddyBody", " dummycontent", "dummycontent", "duddySource", "DuckyReader", "dumperReader", "DummyReader", "dellyOutput", "DuckySource", "duckyBody", "dellycontent"], "source": ["resources", "unit", "slave", "service", "resource", "SOURCE", "site", "storage", "stream", "Source", "target", "channel", "src", "text", "cache", "sync", "use", "info", "object", "scope", "ources", "string", "class", "element", "core", "sn", "node", "sc", "ource", "result", "uri", " Source", "sin", "client", "secure", "cos", "size", "proxy", "search", "host", "seed", "e", "ser", "sl", "reader", "i", " sources", "connection", "config", "parent", "url", "s"], "content": ["body", "image", "model", "sol", "html", "service", "resource", "Content", "child", "feed", "comments", "cont", "current", "transform", "input", "children", "target", "match", "version", "text", "load", "cms", "message", "output", "music", "media", "update", "code", "news", "result", "css", "response", "xml", "cos", "size", "expression", "report", "title", "clean", "host", "data", "server", "document", "header", "value", "description", "activity", "comment", "config", "url", "cover", "address"], "qResult": ["qResponse", " qresult", "qresult", "kResults", "QFilter", "iqResults", "kresult", "qSource", "rSource", "rResult", "kResult", "kFilter", "queryResponse", "kRes", "queryRes", "qResults", "kReturn", "QResult", " qResponse", "iqResponse", "QReturn", "queryResult", "querySource", "qRes", "rresult", "qReturn", "iqResult", "queryReturn", "qFilter", "queryFilter", "queryResults", "queryresult", " qResults", "rRes", "kSource", "iqresult", "QResults"], "results": ["resources", "its", "versions", "objects", "errors", "shows", "children", "runs", "lines", "ids", "RESULTS", "details", "vers", "events", "blocks", "tests", "files", "collection", "rows", "groups", "successful", "ions", "result", "items", "response", "values", "qs", "reports", "users", "members", "ins", "models", "features", "docs", "pages", "data", "ries", "res", "Results", "s"], "it": ["IT", "its", "in", "ited", "rit", "lit", "which", "entry", "edit", "slice", "mit", "list", "l", "info", "itted", "pit", "r", "t", "ic", "not", "split", "ati", "ait", "op", "p", "ci", "ort", "si", "stat", "v", "and", "ip", "sit", "ins", "ite", "init", "iti", "the", "ITS", "id", " It", "It", "i", "iter", "or", "you"], "rSrc": ["rAsource", "rDssrc", "rPsource", " rEsource", "rIsRC", " rSsrc", "RSrc", "rEsource", "rIsrec", "rEssrc", " rEsRC", "rAssrc", " rDsource", "rPsRC", "rSource", "rAsrec", " rSource", "rAsrc", "rEsRC", "rSrec", "RIsRC", "RIsrec", "rAsRC", "RIsrc", "RIsource", "rPsrc", "rDsRC", "RSource", "rDsrc", "RSrec", " rSRC", "rEsrc", " rDsrc", "rSRC", "rPssrc", " rDssrc", "rIsrc", " rEsrc", "rIsource", "rDsource", "RSRC", "rSsrc", " rEssrc", " rDsRC"], "rSrcIn": ["rSvcin", "rAsRCIn", "rAsRCOut", "rCsrcOut", "rSRCIn", "rCrcin", "rAsrcOut", "rCRCIn", "rSvcIns", "rSourceOut", "rSourceIn", "rCrcIns", "rSvcIN", "rCrcIN", "rCrcOut", "rSrcOut", "rSRCIN", "rCRCOut", "rCsrcIn", "rCrcIn", "rSrcin", "rSrcIns", "rCRCIns", "rSRCOut", "rAsrcIn", "rSourceIns", "rSvcIn", "rSourcein", "rSsrcin", "rSrcIN", "rSsrcOut", "rSvcOut", "rSsrcIn", "rAsrcin", "rCsrcIN", "rCsrcin", "rAsRCin", "rSsrcIN", "rSRCIns", "rSRCin"], "actualOut": ["realout", " actualBridge", "eventout", "actualIn", "nexpectedOut", "assertOut", " actualout", "assertIn", "operatorout", "eventOUT", "actualOutput", "actualOUT", " ActualBridge", "realWin", " ActualOUT", "illegalOutput", " actualOutput", "illegalOUT", "illegalOut", " ActualOut", " actualOUT", "illegalIn", "publicOut", "operatorIn", "actualout", "operatorOUT", "eventOut", "actualWin", " ActualIn", "realOut", "nexpectedIn", "publicIn", "assertOUT", "nexpectedWin", "eventIn", "assertBridge", "operatorOut", " actualWin", " actualIn", "nexpectedout", "realIn", "publicOUT", "publicOutput", "actualBridge"]}}
{"id1": "10690321", "id2": "11334468", "code1": "    private static void readData() {\n        StringTokenizer sTok;\n        topSet = new HashSet();\n        sTok = new StringTokenizer(tops, \",\");\n        while (sTok.hasMoreTokens()) topSet.add(sTok.nextToken());\n        leftSet = new HashSet();\n        sTok = new StringTokenizer(lefts, \",\");\n        while (sTok.hasMoreTokens()) leftSet.add(sTok.nextToken());\n        rightSet = new HashSet();\n        sTok = new StringTokenizer(rights, \",\");\n        while (sTok.hasMoreTokens()) rightSet.add(sTok.nextToken());\n        farRightSet = new HashSet();\n        sTok = new StringTokenizer(farrights, \",\");\n        while (sTok.hasMoreTokens()) farRightSet.add(sTok.nextToken());\n        vowelSet = new HashSet();\n        sTok = new StringTokenizer(vowels, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            vowelSet.add(ntk = sTok.nextToken());\n            if (maxEwtsVowelLength < ntk.length()) maxEwtsVowelLength = ntk.length();\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        puncSet = new HashSet();\n        sTok = new StringTokenizer(others, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            puncSet.add(ntk = sTok.nextToken());\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet = new HashSet();\n        tibSet = new HashSet();\n        sTok = new StringTokenizer(tibetanConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            tibSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        sanskritStackSet = new HashSet();\n        sTok = new StringTokenizer(otherConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            sanskritStackSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        numberSet = new HashSet();\n        sTok = new StringTokenizer(numbers, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            numberSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet.add(\"Y\");\n        charSet.add(\"R\");\n        charSet.add(\"W\");\n        validInputSequences.put(\"Y\", anyOldObjectWillDo);\n        validInputSequences.put(\"R\", anyOldObjectWillDo);\n        validInputSequences.put(\"W\", anyOldObjectWillDo);\n        sTok = null;\n        top_vowels = new HashSet();\n        top_vowels.add(i_VOWEL);\n        top_vowels.add(e_VOWEL);\n        top_vowels.add(o_VOWEL);\n        top_vowels.add(ai_VOWEL);\n        top_vowels.add(au_VOWEL);\n        top_vowels.add(reverse_i_VOWEL);\n        try {\n            URL url = TibetanMachineWeb.class.getResource(fileName);\n            if (url == null) {\n                System.err.println(\"Cannot find \" + fileName + \"; aborting.\");\n                System.exit(1);\n            }\n            InputStreamReader isr = new InputStreamReader(url.openStream());\n            BufferedReader in = new BufferedReader(isr);\n            System.out.println(\"Reading Tibetan Machine Web code table \" + fileName);\n            String line;\n            boolean hashOn = false;\n            boolean isTibetan = false;\n            boolean isSanskrit = false;\n            boolean ignore = false;\n            while ((line = in.readLine()) != null) {\n                if (line.startsWith(\"<?\")) {\n                    if (line.equalsIgnoreCase(\"<?Consonants?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Other?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Input:Punctuation?>\") || line.equalsIgnoreCase(\"<?Input:Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Tibetan?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Sanskrit?>\")) {\n                        isSanskrit = true;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?ToWylie?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Ignore?>\")) {\n                        isSanskrit = false;\n                        ignore = true;\n                    }\n                } else if (line.startsWith(\"//\")) {\n                    ;\n                } else if (line.equals(\"\")) {\n                    ;\n                } else {\n                    StringTokenizer st = new StringTokenizer(line, DELIMITER, true);\n                    String wylie = null;\n                    DuffCode[] duffCodes;\n                    duffCodes = new DuffCode[11];\n                    int k = 0;\n                    StringBuffer escapedToken = new StringBuffer(\"\");\n                    ThdlDebug.verify(escapedToken.length() == 0);\n                    while (st.hasMoreTokens()) {\n                        String val = getEscapedToken(st, escapedToken);\n                        if (val.equals(DELIMITER) && escapedToken.length() == 0) {\n                            k++;\n                        } else if (!val.equals(\"\")) {\n                            if (escapedToken.length() != 0) {\n                                escapedToken = new StringBuffer(\"\");\n                                ThdlDebug.verify(escapedToken.length() == 0);\n                            }\n                            switch(k) {\n                                case 0:\n                                    wylie = val;\n                                    break;\n                                case 1:\n                                    duffCodes[TM] = new DuffCode(val, false);\n                                    break;\n                                case 2:\n                                    if (!ignore) {\n                                        duffCodes[REDUCED_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 3:\n                                    duffCodes[TMW] = new DuffCode(val, true);\n                                    if (null != duffCodes[TM]) {\n                                        TMtoTMW[duffCodes[TM].getFontNum() - 1][duffCodes[TM].getCharNum() - 32] = duffCodes[TMW];\n                                    }\n                                    if (null != TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32]) throw new Error(\"tibwn.ini is supposed to use the TibetanMachineWeb glyph as the unique key, but \" + val + \" appears two or more times.\");\n                                    TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = duffCodes[TM];\n                                    if (wylie.toLowerCase().startsWith(\"\\\\uf0\")) {\n                                        int x = Integer.parseInt(wylie.substring(\"\\\\u\".length()), 16);\n                                        ThdlDebug.verify((x >= 0xF000 && x <= 0xF0FF));\n                                        NonUnicodeToTMW[x - '\uf000'] = new DuffCode[] { duffCodes[TMW] };\n                                    }\n                                    break;\n                                case 4:\n                                case 5:\n                                case 6:\n                                case 7:\n                                case 8:\n                                case 9:\n                                    if (!ignore) {\n                                        try {\n                                            duffCodes[k - 1] = new DuffCode(val, true);\n                                        } catch (Exception e) {\n                                            System.err.println(\"Couldn't make a DuffCode out of \" + val + \"; line is \" + line + \"; k is \" + k);\n                                        }\n                                    }\n                                    break;\n                                case 10:\n                                    if (!val.equals(\"none\")) {\n                                        StringBuffer unicodeBuffer = new StringBuffer();\n                                        StringTokenizer uTok = new StringTokenizer(val, \",\");\n                                        while (uTok.hasMoreTokens()) {\n                                            String subval = uTok.nextToken();\n                                            ThdlDebug.verify(subval.length() == 4 || subval.length() == 3);\n                                            try {\n                                                int x = Integer.parseInt(subval, 16);\n                                                ThdlDebug.verify((x >= 0x0F00 && x <= 0x0FFF) || x == 0x5350 || x == 0x534D || x == 0x0020 || x == 0x00A0 || x == 0x2003);\n                                                unicodeBuffer.append((char) x);\n                                            } catch (NumberFormatException e) {\n                                                ThdlDebug.verify(false);\n                                            }\n                                        }\n                                        TMWtoUnicode[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = unicodeBuffer.toString();\n                                        char ch;\n                                        if (unicodeBuffer.length() == 1 && UnicodeUtils.isInTibetanRange(ch = unicodeBuffer.charAt(0))) {\n                                            if (null != UnicodeToTMW[ch - '\u0f00'][0] && '\u0f00' != ch && '\u0f02' != ch && '\u0f03' != ch && '\u0f0b' != ch && '\u0f0e' != ch && '\u0f40' != ch && '\u0f42' != ch && '\u0f49' != ch && '\u0f4f' != ch && '\u0f51' != ch && '\u0f53' != ch && '\u0f5e' != ch && '\u0f62' != ch && '\u0f64' != ch && '\u0f67' != ch && '\u0f6a' != ch && '\u0f71' != ch && '\u0f72' != ch && '\u0f73' != ch && '\u0f74' != ch && '\u0f75' != ch && '\u0f76' != ch && '\u0f77' != ch && '\u0f78' != ch && '\u0f79' != ch && '\u0f7a' != ch && '\u0f7c' != ch && '\u0f7e' != ch && '\u0f81' != ch) {\n                                                throw new Error(\"tibwn.ini has more than one TMW fellow listed that has the Unicode \" + val + \", but it's not on the list of specially handled glyphs\");\n                                            }\n                                            UnicodeToTMW[ch - '\u0f00'][0] = duffCodes[TMW];\n                                        }\n                                    }\n                                    break;\n                                case 11:\n                                    if (!ignore) {\n                                        duffCodes[HALF_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 12:\n                                    if (!ignore) {\n                                        DuffCode binduCode = new DuffCode(val, true);\n                                        binduMap.put(duffCodes[TMW], binduCode);\n                                    }\n                                    break;\n                                case 13:\n                                    throw new Error(\"tibwn.ini has only 13 columns, you tried to use a 14th column.\");\n                            }\n                        } else {\n                            if (k == 10) {\n                                throw new Error(\"needed none or some unicode; line is \" + line);\n                            }\n                        }\n                    }\n                    if (k < 10) {\n                        throw new Error(\"needed none or some unicode; line is \" + line);\n                    }\n                    if (!ignore) {\n                        if (null == wylie) throw new Error(fileName + \" has a line ^\" + DELIMITER + \" which means that no Wylie is assigned.  That isn't supported.\");\n                        if (hashOn) {\n                            tibHash.put(Manipulate.unescape(wylie), duffCodes);\n                        }\n                        if (isTibetan) {\n                            StringBuffer wylieWithoutDashes = new StringBuffer(wylie);\n                            for (int wl = 0; wl < wylieWithoutDashes.length(); wl++) {\n                                if (wylieWithoutDashes.charAt(wl) == '-') {\n                                    wylieWithoutDashes.deleteCharAt(wl);\n                                    --wl;\n                                }\n                            }\n                            tibSet.add(wylieWithoutDashes.toString());\n                        }\n                        if (isSanskrit) {\n                            sanskritStackSet.add(wylie);\n                        }\n                        if (null == duffCodes[TMW]) throw new Error(fileName + \" has a line with wylie \" + wylie + \" but no TMW; that's not allowed\");\n                        int font = duffCodes[TMW].getFontNum();\n                        int code = duffCodes[TMW].getCharNum() - 32;\n                        toHashKey[font][code] = Manipulate.unescape(wylie);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"file Disappeared\");\n            ThdlDebug.noteIffyCode();\n        }\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"readData": ["processDATA", "parseText", "processdata", "processData", "readText", "readdata", "parsedata", "parseData", "initDATA", "readDATA", "initText", "initData", "parseDATA", "initdata", "processText"], "sTok": ["hsVo", " sEnc", "sisVal", "testsKo", "sChat", "sOrg", " sOp", "testsTu", "singleMsg", "sesIter", " sOrg", " sDec", "sisTok", "nIter", "sTag", "sisIter", "awsIter", "sOk", "awsTok", "sportsBuild", "sportsKe", "awsEnc", " sVo", "syncTu", "sBuff", "gsDec", "yourMsg", "dsTok", "sslVo", "suTok", "obsKe", "dLoc", "SToken", "synIter", "servicesIter", "submitLex", "nLex", " sChat", "sBu", "sUk", "yourChat", "fsLex", "sisTu", "nChat", " sOk", " sPos", " sLex", "sBuild", "gsTok", "obsTok", "dIter", "sIv", "sportsPop", "hsTok", "sDec", " sVal", "dsTu", "sMsg", "obsBuild", "newKe", "dsVo", "dTok", " sBu", "sAk", "suIter", "sChan", "nUt", "siteIter", " sChan", "singleCorp", " sLoc", " sMsg", "syncVo", " sSk", "lsBuild", "siteTok", "sLex", " sDoc", "fsDec", " sUk", "sPop", "sTu", "SSel", "seToken", " sSel", "sRec", "synOtt", " sBot", "suSk", "sVo", "fsTok", "pToken", " sIter", "tIter", "opensPop", "sportsEh", "servicesTu", " sEh", "sslTok", " sPop", "servicesIv", "testsIter", "newTok", "SOk", "tDoc", "dsAk", "sesAk", "siteTag", "pTok", "dsVal", "sKo", "newUt", "sisOtt", "sesTok", " sBuff", "opensTok", "nTok", "tLoc", "seSel", "sslTu", "singleTok", " sKo", "dsLoc", "submitTok", "sEh", "fsSk", " sTag", "dsUk", "dToken", "sslIter", "hsSk", "sEnc", "sUt", "sportsPos", "yourLoc", "newBot", "pIter", "nLoc", " sCorp", "yourTok", "nBu", "siteOtt", " sToken", "sLoc", "STok", "sSk", "sportsTok", "sVal", "dsOtt", " sIv", "servicesKo", "sisBuff", "siteLoc", "syncIter", "lsTok", "servicesTok", " sOtt", "pLoc", "seTok", "singleSk", "synTok", "gsLex", " sRec", " sKe", "nOp", "lsKe", "submitMsg", "opensPos", "tTok", "seBuff", "sOtt", "SOrg", "sOp", "submitBu", "SBuff", "sIter", "sisChan", "nMsg", "SIter", "sesUk", "sKe", "syncTok", "testsTok", "sDoc", "hsIter", "dsIter", " sTu", "opensEh", " sUt", "awsRec", "servicesLex", "synVal", "sBot", "sCorp", "sPos", "sSel", "sToken", " sAk", "suVo", "awsDoc", "awsLoc", "gsSk"], "topSet": ["pperHat", "pperChan", "TopMap", "topHat", "TOPAdd", "TopChan", "TopSet", "topChan", "pperSet", "topAdd", " topUnit", " topAdd", "TOPChan", "TopUnit", "TOPUnit", " topMap", "TOPSet", "topUnit", "pperMap", " topHat", "TopHat", "TopAdd", "topMap", " topChan"], "leftSet": ["lawSet", "leftHat", " leftKit", "rightKit", "leftUnit", "controlSet", "lawBlock", "controlBlock", "lawCollect", " leftBlock", "controlHat", "rightUnit", " leftUnit", "leftCollect", "smallSet", " leftCollect", "leftKit", "smallUnit", " leftHat", "controlCollect", "lawHat", "smallKit", "leftBlock"], "rightSet": ["rightsChain", "rightsSource", "rightsGet", "rightList", "rightChain", " rightGet", "rightsSet", "RightChain", "RightGet", " rightMap", "rightsUnit", " rightSource", "RightList", "rightUnit", "rightSource", "RightSet", " rightList", "RightSource", " rightUnit", " rightChain", "RightMap", "RightUnit", "rightMap", "rightsMap", "rightsList", "rightGet"], "farRightSet": ["farrightUnit", "farLeftset", "farCorrectSet", "farrightSet", "farLeftChan", " farRightset", "farrightList", "farRightset", " farRightList", " farLeftList", "farLeftSet", "farRightUnit", "farCorrectList", "farRightList", " farLeftUnit", " farRightChan", " farRightUnit", "farCorrectChan", "farRightChan", "farCorrectset", " farLeftSet", "farLeftList", "farLeftUnit"], "vowelSet": ["vowellMap", "vowelMap", "voweleMap", "vowellSet", "voxelSet", "voxelsList", "voulSet", "vowlSet", "vowlList", "voulSize", "voulList", "vowelsMap", "voxelsSet", "vowellSize", "vouelSet", "vowelsList", "vowelSize", "voweleList", "vowelList", "voxelsMap", "vouelSize", "vowellList", "vouelList", "voxelMap", "voxelList", "voweleSet", "vowelsSize", "vowlSize", "vowelsSet"], "ntk": ["NTch", "NTk", "rtwork", "otkg", "ontc", "NTak", "ntuk", "untk", "settg", "ctsk", "ptp", "antr", "ontkg", "ptr", "netc", "etwork", "netok", "notK", "montK", "notks", "settke", "octg", "ntK", "octke", "montsk", "ontwork", "ontK", "untok", "ottwork", "ontsk", "gtc", "ctK", "ctk", "ptk", "ottak", "otp", "NTwork", "ontp", "ptik", "ntc", "gtke", "LTk", "gtok", "ontok", "ptsk", "ntwork", "ntp", "ntch", "ontke", "untch", "untwork", "ontch", "ntku", "etk", "ontik", "NTK", "octsk", "settsk", "ntks", "antku", "rtok", "NTuk", "antK", "antk", "antik", "otku", "gtK", "ctke", "montke", "NTc", "antok", "ontku", "antkg", "ntek", "ottk", "octk", "antwork", "ontg", "notk", "LTok", "ottok", "antp", "ptks", "LTuk", "LTek", "ontks", "ptK", "ontr", "montk", "ntak", "gtk", "antc", "netK", "NTok", "netk", "settk", "ntr", "ntok", "ntkg", "etok", "NTek", "rtk", "otk", "ontk", "rtK", "ntke", "notsk", "ontak", "ntsk", "ntik", "ntg", "etK", "gtsk"], "maxEwtsVowelLength": ["maxEwtsVowelLen", "maxEwtsVowelingLength", "maxEwtsVowselText", "maxEwtsVoyelLen", "maxEwtsVowellText", "maxEwtsVoyellType", "maxEwtsVowselNumber", "maxEwtsVowelingLen", "maxEwtsVowellLength", "maxEwtsVowellType", "maxEwtsVowilType", "maxEwtsVoyellId", "maxEwtsVowselLen", "maxEwtsVowelType", "maxEwtsVowelsType", "maxEwtsVowetLength", "maxEwtsVowsetLength", "maxEwtsVowsetText", "maxEwtsVowelNumber", "maxEwtsVowelingNumber", "maxEwtsVowsetNumber", "maxEwtsVowelText", "maxEwtsVowellId", "maxEwtsVowelsId", "maxEwtsVowilId", "maxEwtsVowelId", "maxEwtsVowetLen", "maxEwtsVowetNumber", "maxEwtsVoyellLength", "maxEwtsVoyelType", "maxEwtsVowelsLength", "maxEwtsVoyellLen", "maxEwtsVowellLen", "maxEwtsVowetText", "maxEwtsVowilLen", "maxEwtsVowellNumber", "maxEwtsVoyelId", "maxEwtsVowelsLen", "maxEwtsVowilLength", "maxEwtsVowselLength", "maxEwtsVoyelLength", "maxEwtsVowsetLen", "maxEwtsVowelingText"], "puncSet": ["pummSet", "pocNum", "pucSet", "puncset", " puccset", "puccset", "PucNum", " puccGet", "PuncNum", " puccSet", "pucGet", "pascalList", "PucSet", "PucList", "PuncSet", " puncset", "PuncList", "puccGet", "puncNum", "pummset", "pucset", "pucNum", "puccSet", "pucList", "pocList", " puncGet", "puncList", "pascalSet", "puncGet", "pummGet", "pascalNum", "pocSet"], "charSet": ["inchLet", "CharSet", "charLet", "inchSet", "characterList", " charMap", "characterSet", "charBlock", "characterMap", " charBlock", "characterLet", "characterBlock", " charList", "charMap", "CharList", "CharBlock", "charList", " charLet", "inchMap"], "tibSet": ["TobSet", "tibiset", "TibiArray", "tibArray", "tilibet", "tibiSet", "Tibiset", "tobet", "tobSet", "tilibSet", "tibEn", "tikArray", "tiket", "TibEn", "tibiet", "Tibiet", "Tibset", "tivet", "tilibEn", "TobEn", "tbiset", "tibet", "tbiArray", "TibSet", "TibiSet", "tivSet", "tikset", "tivEn", "Tibet", "tbiSet", "tbiet", "tikSet", "TibArray", "tibset", "tibiArray", "Tobet", "tobEn"], "sanskritStackSet": ["sanskritRootMap", "sanskriticalRootSet", "sanskritRootset", "sanskriticalRootset", "sanskriticalStackset", "sanskritContextset", "sanskritStackset", "sanskritStackMap", "sanskriticalStackMap", "sanskritContextSet", "sanskriticalRootMap", "sanskritHashMap", "sanskritRootSet", "sanskritContextMap", "sanskriticalStackSet", "sanskritHashSet", "sanskritHashset"]}}
{"id1": "13644374", "id2": "23531898", "code1": "    public byte[] getBytesFromUrl(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toByteArray(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 0, "substitutes": {"getBytesFromUrl": ["getBytesfromRoute", "getBytesFromURL", "getBytesFormString", "getBytesViaRoute", "getBytesViaUrl", "getbytesFormString", "getBytesViaString", "getBytesFromRoute", "getBytesFromString", "getBytesViaURL", "getBytesFormURL", "getBytesfromString", "getbytesFormUrl", "getbytesFormRoute", "getBytesFormUrl", "getbytesFromString", "getBytesfromURL", "getBytesfromUrl", "getbytesFromRoute", "getbytesFromUrl", "getBytesFormRoute", "getbytesFormURL", "getbytesFromURL"], "url": ["method", "URL", "service", "resource", "email", "base", "download", "Url", "json", "ref", "http", "key", "href", "l", "api", "page", "string", "buffer", "route", "path", "source", "result", "uri", "xml", "ur", "name", "location", "request", "server", "data", "str", "sl", "i", "connection", "loc", "host", "address"], "get": ["body", "gets", "method", "service", "resource", "create", "send", "cli", "json", "open", "find", "parse", "http", "load", "use", "api", "update", "like", "read", "set", "query", "GET", "build", "pull", "client", "handle", "Get", "start", "request", "e", "call", "put", "i", "execute", "exec"], "response": ["body", "onse", "method", "resource", "wave", "feed", "content", "Response", "json", "http", "message", "output", "api", "respond", "full", "object", "page", "application", "status", "resp", "success", "result", "out", "report", "tree", "received", "request", "server", "data", "document", "e", "f", "error", "connection", "reply"], "entity": ["body", "image", "model", "action", "resource", "this", "event", "content", "metadata", "json", "entry", "http", "message", "output", "api", "environment", "info", "object", "page", "null", "element", "pe", "collection", "resp", "node", "translation", "result", "ent", "xml", "ale", "server", "data", "file", "document", "e", "instance", "el", "person", "security", "Entity", "connection"]}}
{"id1": "5744992", "id2": "4830847", "code1": "    public void dorequest(Map<String, String> ps, String method) throws IOException {\n        StringBuffer httpResponse = new StringBuffer();\n        URL ourl = new URL(url);\n        HttpURLConnection httpConnection = (HttpURLConnection) ourl.openConnection();\n        httpConnection.setRequestMethod(method);\n        httpConnection.setDoOutput(true);\n        this.setCookie(httpConnection);\n        OutputStream httpOutputStream = httpConnection.getOutputStream();\n        StringBuffer postParams = new StringBuffer(\"\");\n        for (Entry<String, String> entry : ps.entrySet()) {\n            postParams.append(entry.getKey());\n            postParams.append(\"=\");\n            postParams.append(entry.getValue());\n            postParams.append(\"&\");\n        }\n        httpOutputStream.write(postParams.toString().getBytes());\n        BufferedReader httpBufferedReader = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n        httpResponse.append(this.readBufferedContent(httpBufferedReader));\n        text = httpResponse.toString();\n        this.readCookie(httpConnection);\n    }\n", "code2": "    @Override\n    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {\n        final Connection connection = this.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id =  \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \";\n            if (contextName != null) {\n                queryString = queryString + \" context_name LIKE ? AND \";\n            }\n            if (dateFrom != null) {\n                queryString = queryString + \" start_timestamp >= ? AND \";\n            }\n            if (dateTo != null) {\n                queryString = queryString + \" start_timestamp <= ? AND \";\n            }\n            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);\n            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);\n            int indexCounter = 1;\n            if (contextName != null) {\n                preparedStatement.setString(indexCounter, contextName);\n                indexCounter = indexCounter + 1;\n            }\n            if (dateFrom != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            if (dateTo != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            preparedStatement.executeUpdate();\n            preparedStatement.close();\n            connection.commit();\n        } catch (final SQLException e) {\n            try {\n                connection.rollback();\n            } catch (final SQLException ex) {\n                JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex);\n            }\n            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());\n            throw new DatabaseException(\"Error deleting JVM statistics.\", e);\n        } finally {\n            this.releaseConnection(connection);\n        }\n    }\n", "label": 0, "substitutes": {"dorequest": ["doserpatch", "doresq", " dosepatch", "doservent", "doresvent", " dosequest", "dosevent", "dosepatch", " dorepatch", "dorepatch", "doresquest", "doserq", " dosevent", "doreq", "dorespatch", "doserquest", " doreq", " doseq", " dorevent", "doseq", "dorevent", "dosequest"], "ps": ["pt", "posts", "ap", "Ps", "details", "aps", "ams", "pers", "ms", "mp", "pr", "pos", "pp", "pe", "sp", "pps", "params", "pa", "pres", " props", "ples", "p", "ds", "os", "eps", "cs", "rs", "pse", "pes", "gs", "ips", "tp", "PS", "pro", "ts", "ppa", "s"], "method": ["cmd", "resource", "prefix", "format", "direction", "function", "METHOD", "property", "version", "req", "mode", "message", "process", "key", "use", "post", "style", "string", "class", "params", "route", "session", "POST", "subject", "path", "sort", "p", "type", "response", "pull", "Method", "name", "term", "request", "verb", "data", "id", "call", "url", "address"], "httpResponse": ["safeBuffer", "saferesponse", "HttpServer", "httpresponse", "safeResponse", "theResponse", "httpBuffer", "httpsServer", " httpResp", "serverresponse", "HttpConnection", "cacheResponse", "httpsConnection", "serverResponse", "theResp", " httpRequest", "httpServer", "httpResp", "httpRequest", "httpOutput", " httpServer", "theresponse", "cacheResp", "cacheresponse", "safeOutput", "HttpResponse", " httpresponse", " httpOutput", "serverBuffer", " httpBuffer", "HttpRequest", "httpsResponse", "httpsRequest", "cacheRequest", "serverOutput", "theRequest"], "ourl": ["ouriL", "orel", "urL", "OURln", "oursL", "oursln", "urlas", "ourisl", "ourL", "OURl", "OUll", "oursll", "OUL", "oresl", "oreL", "ourll", "OUln", "OUl", "ourlas", "orelas", "ursl", "ourln", "ourilas", "oursl", "OURL", "OURll", "ouril", "url"], "httpConnection": ["buildConnection", "apiSession", " httpService", "apiConnection", "buildFactory", "httpSession", "phpConnection", "cacheconnection", "httpsFile", " httpClient", "httpconnection", "apiResponse", "HttpConnect", "httpsClient", "httpsApplication", "buildconnection", "httpFactory", "httpsconnection", "baseApplication", "HttpConnection", "httpsConnector", "httpsConnection", "httpChannel", "httpCondition", "baseConnector", " httpChannel", "httpService", "phpConnector", "httpsConn", " httpFile", "httpConn", "HttpSession", "apiConnect", "httpContext", "httpClient", "httpConnect", " httpSession", "httpConnector", "baseConnect", "httpsConnect", "baseConnection", "buildContext", "cacheContext", "phpChannel", "httpsInterface", " httpconnection", "httpInterface", "HttpResponse", "httpsChannel", " httpConnector", " httpFactory", "httpFile", "HttpInterface", " httpConn", "cacheConnect", "buildCondition", "cacheConnection", "HttpConn", " httpCondition", " httpApplication", "httpsCondition", "buildClient", "httpsFactory", " httpConnect", "httpsService", "buildConnect", " httpInterface", "phpService", " httpContext", "httpApplication", "HttpFile"], "httpOutputStream": ["httpClientStream", "theOutputStream", "httpoutputSteam", "httpOutputBuffer", "httpsInputBuffer", "httpOutputstream", "httpOutSteam", "httpInputBuffer", "httpWriteBuffer", "httpInputLength", "httpOutputFile", "httpWriteSteam", "httpsInputStream", "httpsInputFile", "httpOutstream", "httpClientSteam", "httpWriteStream", "httpOutputSteam", "httpInputSteam", "httpClientBuffer", "httpInputstream", "theOutputLength", "httpOutLength", "httpWriteFile", "httpClientFile", "theInputStream", "httpoutputStream", "httpsOutputStream", "httpsOutputSteam", "theInputSteam", "theInputLength", "httpOutputLength", "httpsOutputFile", "theOutputstream", "httpoutputLength", "theInputstream", "httpOutStream", "httpsInputSteam", "httpInputFile", "httpInputStream", "httpoutputstream", "httpsOutputBuffer", "theOutputSteam"], "postParams": ["postAras", "postPeras", "postParam", "postVariars", "customparans", "postParamars", "POSTParamParam", "PostParas", "postPparams", "preParamas", "preParparams", "POSTParams", "PostPerars", "postPerparams", "preParars", "POSTParparams", "POSTPas", "postParans", "preParas", "POSTParam", "POSTParamam", "postPams", "PostParams", "postParParam", "postVarians", "POSTParamas", "postParamparams", "postVarias", "customparas", "postparam", "postParparams", "PostPams", "postAram", "postArams", "postParamam", "postPerams", "PostPerparams", "postArparams", "postVariams", "preParamams", "postparas", "customparams", "preParamparams", "PostPas", "POSTParas", "postparans", "postPeram", "PostParparams", "POSTPams", "PostPparams", "POSTPam", "POSTParamams", "postparparams", "customParparams", "customParas", "postPam", "postVariparams", "customParams", "postPas", "PostParars", "preParams", "postParars", "postParamams", "postParamParam", "customParans", "customparparams", "postPerars", "PostPeram", "postVariParam", "postparams", "PostParam", "postPParam", "preParamars", "POSTParParam", "POSTPparams", "postParas", "PostPam", "PostPerams", "postParamas", "postPerans", "postVariam"], "entry": ["image", "letter", "tri", "index", "section", "step", "ry", "parse", "Entry", "pair", "key", "info", "page", "string", "element", "array", "set", "r", "next", "handler", "ie", "translation", "line", "part", "record", "result", "ent", "se", "counter", "entity", "row", "character", "ner", "term", "word", "ge", "the", "data", "id", "cell", "e", "card", "str", "value", "reader", "per", "enter", "or", "connection", "setting"], "httpBufferedReader": ["httpBufferedRead", "httpBuffinedRead", "httpbufferedReader", "httpBuffedRead", "httpBuffinedReader", "httpBufferingWriter", "httpBuffererParser", "httpbuffererReader", "httpBuffererReader", "httpBuffinedParser", "httpBuffedParser", "httpbufferedStream", "httpbuffererRead", "httpBuffedReader", "httpBufferedParser", "httpBuffererStream", "httpbufferedWriter", "httpbufferedRead", "httpbuffererWriter", "httpBuffererRead", "httpBufferedWriter", "httpBuffinedWriter", "httpBufferingRead", "httpBufferedStream", "httpBuffinedStream", "httpBuffedWriter", "httpBufferingReader", "httpbuffererStream", "httpBuffererWriter", "httpBufferingStream"], "text": ["body", "html", "feed", "inner", "content", "input", "password", "info", "object", "status", "txt", "code", "buffer", "Text", "path", "source", "result", "uri", "secret", "name", "ext", "data", "id", "username", "str", "connection", "TEXT", "header"]}}
{"id1": "160739", "id2": "364438", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createInputReader", "createInputStream", " createInputFile", "createOutputSteam", " createIOReader", "createInputFile", " createByteReader", " createByteStream", " createIOStream", " createOutputFile", " createIOFile", "createInputSteam", " createInputSteam", " createByteFile", " createIOSteam", " createOutputSteam", " createOutputReader", " createInputStream", "createInputReader", "createOutputReader", " createByteSteam", "createOutputFile"], "inFile": ["incFiles", "inputfile", "inStream", "inputStream", "insFiles", "outFiles", "inputFiles", "sourceFile", "sourcefile", "inputFile", "outStream", "insfile", "incfile", "incFile", "outfile", "insStream", "incStream", "inFiles", "infile", "insFile", "sourceFiles", "sourceStream"], "outFile": ["workingStream", "workTime", " outStream", "inputfile", " outDirectory", "outTime", "workfile", "workingfile", "inputDir", " outfile", "outDir", "workFile", "workingFile", "targetStream", "inTime", "outDirectory", "workingDirectory", "inputFile", "targetfile", "targetFile", "workDir", "outStream", "inputTime", "outfile", "targetDirectory", "inDir", "infile"], "k_blockSize": ["k_lockLength", "k_bitCount", "k_blockCode", "k_byteCount", "k_byteLength", "k_lockCode", "k_lockLen", "k_blocksSize", "k_blockLen", "k_BlockSize", "k_bitSize", "k_bitInfo", "k_lineSize", "k_lockCount", "k_BlockLength", "k_lineCount", "k_BlockCount", "k_byteLen", "k_blocksLength", "k_byteSize", "k_BlockCode", "k_blockInfo", "k_byteInfo", "k_blockLength", "k_blocksCount", "k_blockCount", "k_lockSize", "k_lineInfo", "k_blocksLen", "k_byteCode"], "byteCount": [" byteSum", " byteLen", "flushSize", "ByteSize", "ByteSum", "blockCount", " bytecount", "byteLen", "characterSize", "flushcount", "Bytecount", "byteLength", "flushLength", "blockLength", " byteSize", "byteSize", "characterLength", "byteSum", "bytecount", " byteLength", "characterCount", "ByteLen", "characterLen", "blockSum", "flushCount", "ByteLength", "blockSize", "ByteCount"], "buf": ["base", "cmd", "feed", "vec", "config", "flush", "feat", "src", "queue", "bag", "uf", "bytes", "b", "cb", "bh", "cap", "background", "font", "buff", "border", "buffer", "rc", "fd", "fb", "bf", "result", "Buff", "len", "img", "cas", "tmp", "alloc", "ucc", "la", "brace", "loc", "data", "cv", "rb", "ctx", "seq", "batch", "Buffer", "exc", "append"], "ofp": ["fort", "afl", "OFp", "OFnp", "OFl", "Oftp", "forp", "Ofc", "afnp", "Ofp", "OFtp", "ofl", "Ofnp", "OFt", "oft", "ofnp", "forc", "oftp", "afp", "Oft", "fortp", "afc", "ofc", "Ofl", "OFc"], "zos": ["z", "iffs", "zes", "zx", "ls", "lins", "oda", "liquid", "webkit", "zon", "tz", "zy", "nox", "forge", "bes", "os", "zers", "zl", "iframe", "rez", "modules", "zen", "fits", "los", "rons", "za", "kos", "gz", "uz", "zar", "ops", "zig", "bos", "hz", "nz", "packs", "ZA", "zn", "inos", "obs", "core", "outs", "zag", "ros", "ossus", "obb", "bitcoin", "dylib", "zona", "oses", "soon", "budget", "zi", "lol", "zb", "utils", "osi", "zip", "zyk", "ws", "ZI", "ogl", "zo", "abi", "ozo", "zik", "robe", "zh", "enos", "zer", "js", "cfg", "zin", "css", "cos", "ses", "owicz", "oS", "bs", "jas"], "osw": ["lswo", "eshell", "osy", "ossow", "osssw", "isnow", "osow", "ossww", "essw", "osswd", "oshell", "bwo", "isd", "eswd", "esow", "osnow", " osow", "osws", "ossfw", "esnow", "osd", " osfw", "issw", "esfw", "esy", "isw", "lsx", "osshell", "ossnow", "osfw", "esww", "esd", "bsws", " osww", "osx", "ossw", "ishell", "oswo", "oswd", "bws", "bsx", "iswd", "osww", "lsw", "bsw", "ossy", "lsws", "esw", "isy", "bx", "bswo", "ossd"], "bw": ["bbw", "Bw", "lw", "Bew", "lbsw", "bbwh", " bws", "bwe", "fr", "owa", "fbW", "bbaw", "oaw", "Bws", "bz", "fbw", "Bwa", "bbew", "abwe", "baw", "lbz", "abw", "fsw", "ebwe", "lbw", "owu", "fw", "fbwe", "bbz", " bew", "ow", "lbws", "ebW", "fwh", "fwa", "lbwh", "lx", "abwd", "ebw", " bwu", "lwa", "bwu", " bwa", "bew", " baw", "fx", "bws", "bwh", "fbwd", "bW", "bbwa", " bz", "lsw", "bwa", "lbwa", "bbwu", "bsw", "bwd", "ebwd", "bbws", "bx", "abW", "lbr", " bwh", "lbx"], "zot": ["zerott", "aziot", "jit", "zita", "zeros", "azor", "zerot", "zerori", "zerit", "azot", " ziot", "azott", "Zot", "zott", "Zott", "Zit", "ziot", "jot", "Zita", "jori", "Zor", "Ziot", "zor", "zori", "jos", "azit", " zori", "zerita", " zor", "azita"], "ifp": ["IFi", "ipb", " iff", "ifi", "Ifi", "ifb", "Ifc", " ifi", " ifl", "IFb", "IFf", "ipl", "IFl", "ifc", " ifb", "Iff", "ipc", "iff", "ifl", "ipp", "IFp", "IFc", "Ifp", " ifc"], "zis": ["jis", "zisi", " zib", "jisi", "jit", " zIS", "xits", " zisi", "zib", "zip", "xais", "xisi", " zits", "zenais", "zeis", "xit", "zenis", "Zis", "zenIS", "jits", "zipits", "zipiss", "xIS", "zeip", "Zits", "Ziss", "Zip", "zeiss", "xis", "zIS", "zeits", "xib", " zais", "zenib", "ziss", "zais", "zits", "zipip", "zipis"], "isr": ["irrc", "rispr", "iscr", "risr", "risrb", "ISrc", "ispr", "ISr", "isscr", " isrs", "issrs", "ISpr", "irr", " issr", "isrs", "irrb", "IScr", "isssr", "isrc", "ISrs", "isrb", "issr", "risrc", "irpr", " iscr", "ISsr", "ISrb"], "br": ["body", "err", "bsp", "lr", "fr", "kr", "HR", "bl", "arr", "cro", "ocr", "yr", " fr", "b", "ch", "ctr", "bp", "sp", "r", "ber", "gr", "tr", " dr", "ibl", "bro", "obl", "div", "Br", "ibr", "BR", "mr", "img", "rs", "hr", " BR", "bar", "sr", "rib", "ob", "browser", "str", "rb", " Br", "bc", "bh", "obi", "shr"], "zit": ["zith", "zite", "xic", "zeita", "zic", "jit", "zita", "zipith", "zipite", "zip", "zipIT", "zenits", "zenit", " zip", "zeIT", "jic", "jita", "zenith", " zits", "zitter", "jip", "zeitter", "xit", "jIT", "zipit", "zipita", "xi", "jite", " zi", " zic", " zite", "jits", "ji", "zipits", "zIT", "zipitter", "zenitter", "zeith", "zeits", "zeit", "xith", " zith", "jith", "zits", "zipip", "zi"]}}
{"id1": "2324868", "id2": "11082670", "code1": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException {\n        StringBuilder json = new StringBuilder();\n        String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n        try {\n            URL url = new URL(requestUrl.toString());\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                json.append(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            throw new GtugsException(e);\n        }\n        List<Event> events = new ArrayList<Event>();\n        JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString());\n        JSONArray results = (JSONArray) jsonObj.get(\"results\");\n        for (int i = 0; i < results.size(); i++) {\n            JSONObject result = (JSONObject) results.get(i);\n            Event e = new Event();\n            e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\")));\n            e.setCity((String) result.get(\"venue_city\"));\n            e.setDescription((String) result.get(\"description\"));\n            e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\")));\n            e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\")));\n            e.setName((String) result.get(\"name\"));\n            Date myDate = null;\n            String time = (String) result.get(\"time\");\n            try {\n                myDate = meetupDateFormat.parse(time);\n                e.setStartTime(timeDateFormat.format(myDate));\n                e.setEndTime(timeDateFormat.format(myDate));\n                e.setStartDate(myDate);\n                e.setEndDate(myDate);\n                String tz = tzDateFormat.format(myDate);\n                if (tz != null && tz.startsWith(\"+\")) {\n                    tz = tz.substring(1);\n                }\n                e.setTimeZone(Integer.toString(Integer.parseInt(tz) / 100));\n            } catch (ParseException ex) {\n                ex.printStackTrace();\n                continue;\n            }\n            e.setState((String) result.get(\"venue_state\"));\n            StringBuilder addressBuilder = new StringBuilder();\n            if (result.get(\"venue_address1\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address1\") + \" \");\n            }\n            if (result.get(\"venue_address2\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address2\") + \" \");\n            }\n            if (result.get(\"venue_address3\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address3\") + \" \");\n            }\n            if (result.get(\"venue_address4\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address4\"));\n            }\n            e.setStreetAddress(addressBuilder.toString().trim());\n            e.setZipCode((String) result.get(\"venue_zip\"));\n            e.setUrl((String) result.get(\"event_url\"));\n            events.add(e);\n        }\n        return events;\n    }\n", "label": 0, "substitutes": {"actionPerformed": [" actionExecuted", "actionExecressed", "actionExecuted", "actionExecalled", "actionPerressed", " actionExecressed", "actionCformed", "actionPeralled", "actionExecformed", " actionPerressed", " actionPeruted", "actionOccressed", "actionCressed", "actionCuted", " actionExecalled", "actionPeruted", "actionOccalled", " actionPeralled", "actionOccuted", "actionOccformed", "actionCalled", " actionExecformed"], "e": ["de", "q", "self", "event", "exc", "et", "E", "events", "c", "g", "t", "type", "se", "an", "v", "x", "me", "es", "name", "ception", "a", "ae", "ev", "te", "ctx", "ec", "f", "ee"], "delim": ["selim", "Delam", "Delimmer", "elam", "flcm", "selem", " delam", "flim", "flam", "selam", " delcm", "Delcm", "delimmer", "Delm", "delem", "delcm", " delimmer", "flimmer", "Delem", "Delim", "delam", "selm", "elem", "elm", "elim", "delm"], "r": ["re", "err", "dr", "lr", "fr", "rx", "kr", "w", "rt", "ir", "rar", "l", "writer", "adr", "ws", "pr", "c", "rc", "tr", "ru", "er", "p", "rr", "nr", "rh", "rs", "hr", "sr", "R", "rss", "reader", "rb", "i", "res", "n", "rw", "ar", "br", "rl", "cr", "f", "iter"], "line": ["re", "rule", "link", "log", "look", "lc", "feed", "end", "nl", "val", "lf", "cl", "lines", "entry", "inline", "LINE", "text", "Line", "key", "l", "page", "style", "string", "code", "pe", "pass", "split", "job", "row", "response", "number", "le", "block", "lin", "name", "col", "word", "sel", "id", "file", "data", "cell", "str", "comment", "rl", "reader", "one", "no", "el", "value", "time", "fin", "source", "sl", "header"], "url": ["link", "err", "log", "URL", "base", "resource", "fr", "lr", "www", "nl", "Url", "ls", "http", "l", "string", "path", "fl", "org", "uri", "pull", "blog", "client", "ur", "ssl", "sr", "server", "file", "ob", "jar", "sl", "rl", "connection", "loc", "host", "web", "f"], "conn": ["enc", "err", "conv", "nt", "coll", "dc", "w", "cl", "open", "nc", "cur", "ctrl", "rt", "Connection", "http", "sync", "l", "ch", "api", "cb", "pr", "ann", "sql", "c", "cf", "ct", "gr", "rc", "db", "p", "io", "out", "fp", "client", "pub", "socket", "ssl", "cm", "co", "con", "cn", "rn", "connect", "lock", "Conn", "n", "ctx", "cp", "connection", "loc", "cr", "f"], "wr": ["err", "wb", "dr", "vr", "fr", "rx", "wave", "kr", "wl", "w", "write", "rt", "fw", "rar", "wer", "wh", "writer", "wd", "RW", "pr", "ew", "wt", "gr", "wa", "wx", "wrap", "rr", "nw", "nr", "rh", "wk", "mr", "out", "wm", "rs", "riter", "Writer", "hr", "sr", "war", "Wr", "wy", "WR", "rw", "rb", "res", "wal", "cr", "shr", "rss"], "tokens": ["takoks", "tokenets", "pokelines", "tkens", "toyos", "tOKets", "Takoks", "pargelines", "Tokens", "Tokicks", "takos", "tOKelines", "takicks", "itokets", "torkicks", "tken", "tokets", "tokenos", "torken", "torkoks", "pokets", "toyen", "itokenets", "tokos", "poken", "tokicks", "pokens", "targelines", "toyets", "pargens", "taken", "itokenen", "token", "takens", "Token", "takets", "targen", "tOKen", "tokenens", "Takicks", "itokenos", "pargets", "itokos", "pargen", "itokenens", "Taken", "tkicks", "tkoks", "tOKens", "itoken", "toyens", "tokelines", "targets", "tokenen", "itokens", "takelines", "tokoks", "targens", "Tokoks", "torkens", "Takens"], "in": ["ini", "kin", "err", "inner", "inn", "gin", "arin", "input", "In", "inc", "bin", "pin", "IN", "zin", "again", "tin", "ic", "oin", "nin", "io", "it", "cin", "sin", "min", "out", "pull", "ins", "is", "init", "inas", "thin", "con", "ln", "data", "rin", "isin", "ina", "str", "reader", "win", "i", "n", "vin", "din", "lin"]}}
{"id1": "13852596", "id2": "19868933", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"execute": ["register", "create", " invoke", "submit", "Exec", "ute", "parse", "load", "run", "process", "code", "apply", "all", "evaluate", "handle", " perform", "start", "report", "test", "server", "transfer", "call", "exec", "install", "copy", "invoke"], "resources": ["rings", "archives", "resource", "objects", "types", "locks", "chains", "stores", "rates", "workers", "flows", "plugins", "services", "maps", "ids", "rules", "thumbnails", "events", "roots", "files", "apps", "projects", "params", "groups", "images", "Resources", "works", "writers", "relations", "ions", "cells", "issues", "items", "series", "reports", "users", "models", "features", "pages", "stars", "classes", "results", "strings", "scripts"], "i": ["ini", "j", "o", "hi", "isi", "phi", "iri", "cli", "ii", "ir", "mu", "l", "info", "ui", "we", "ami", "ri", "pi", "gi", "ic", "abi", "li", "k", "ci", "ie", "p", "ani", "multi", "xi", "si", "io", "bi", "I", "uri", "v", "ai", "eni", "wei", "ip", "is", "ori", "esi", "h", "ti", "qi", "id", "e", "iu", "vi", "f", "u", "di", "oi", "s"], "classFile": ["CLASSFile", "sessionfile", " classClass", " classfile", "ClassEntry", "classGlobal", "packFile", "ClassGlobal", "classUrl", "staticLine", "serviceLine", " classStream", "lassFile", "classDirectory", "CLASSPage", "customEntry", "objectFile", " classFilename", "sessionFactory", "ClassFilename", "CLASSFiles", "serviceFILE", "staticFILE", " classDir", "finalfile", "finalFILE", " classFILE", " classLine", "fileLine", "CLASSLoader", "fileFiles", "ruleFilename", "classPage", "ClassDir", "sessionFile", "ClassFile", "sessionEntry", "CLASSEntry", "classFILE", "ruleLine", "objectFiles", " classFactory", "staticfile", "CLASSUrl", "CLASSfile", "classLine", "classImage", "packEntry", "ruleFiles", "classStream", "ClassPage", "fileFile", "classesPath", "classPath", "objectfile", "basefile", "servicefile", "classEntry", "sessionFiles", "ClassLine", " classPage", " classPath", "lassClass", "classesfile", "filefile", " classLoader", "packfile", "ClassFactory", "classfile", "packFILE", "ClassClass", "baseFILE", "serviceFile", "customFiles", "ClassDirectory", "classesFile", "CLASSFILE", "baseFile", "CLASSDirectory", " classEntry", "Classfile", "objectDir", "finalFile", "fileImage", " classGlobal", "classFactory", "classClass", "CLASSLine", "classFiles", "classLoader", "classesFiles", "lassFiles", "ClassFiles", "ruleFile", "ClassStream", "connectionfile", "staticFile", "ClassFILE", "customFile", "connectionFile", "ClassPath", "finalUrl", "sessionFILE", " classFiles", "classFilename", "CLASSImage", "customFILE", "connectionFiles", "lassGlobal", "fileDirectory", "classDir", "ClassImage", "connectionStream", "fileLoader", "baseUrl"], "inputStream": ["outputstream", "childStream", "inputContext", "binaryStreamer", "importStreamer", "outputSw", "outputContext", "importStream", "inputstream", "binarySteam", "binaryFile", "InputSteam", "InputFile", "importSteam", "InputSw", "InputStreamer", "uploadStream", "outputSteam", "childReader", "inputSw", "initstream", "outputReader", "initStream", "initSteam", " inputSteam", "rawSteam", "uploadstream", "activeSteam", "inputFile", "rawStreamer", "inputSteam", " inputFile", " inputReader", "activestream", "rawStream", "importstream", "activeStream", "inputStreamer", " inputContext", " inputStreamer", "inputReader", "InputStream", "uploadSw", "childstream", "outputStreamer", "initStreamer", "uploadFile", " inputstream", "childContext", "rawFile", "Inputstream", "outputFile", "activeStreamer", "binaryStream"], "reader": ["re", "right", "dr", "resource", "draft", "system", "rx", "stream", "rer", "inner", "arser", "owner", "input", "entry", "worker", "http", "parser", "ler", "reading", "rar", "key", "sync", "ger", "copy", "read", "driver", "builder", "ri", "buffer", "rc", "oder", "reflect", "handler", "er", "writers", "author", "io", "rr", "row", "director", "layer", "client", "ner", "context", "manager", "riter", "loader", "report", "Writer", "request", "wrapper", "server", "war", "seed", "Reader", "per", "shared", "keeper", "iter", "or", "source", "book", "ee", "editor"], "oldSize": ["OldName", "OldLength", "prevSize", "prevName", "prevLength", " oldSc", "oldLength", "oldName", "OldSize", " oldName", "oldSc", " oldLength", "prevSc", "OldSc"], "writer": ["writing", "her", "written", "index", "draft", "resource", "service", "child", "walker", "inner", "dc", "w", "format", "write", "player", "worker", "parser", "ler", "widget", "wer", "object", "builder", "driver", "engine", "read", "string", "r", "element", "creator", "buffer", "wr", "token", "oder", "handler", "er", "writers", "author", "winner", "io", "wire", "row", "director", "ner", "manager", "riter", "Writer", "loader", "report", "word", "wrapper", "data", "war", "document", "e", "Reader", "rw", "writ", "iter", "maker", "ee", "editor"], "b": ["base", "br", "eb", "ba", "w", "l", "bin", "bb", "object", "null", "c", "r", "buffer", "g", "d", "fb", "k", "be", "bd", "p", "boot", "db", "lb", "B", "orb", "pb", "bar", "a", "h", "binary", "ob", "e", "emb", "u", "abc", "rb", "m", "f", "ab"], "outputStream": ["outputstream", "OutputSteam", " outputSteam", "dataSteam", "inputView", "outputView", "OutputStream", "inputstream", "protectedstream", "protectedStreamer", "outputContainer", "outstream", "dataStreamer", " outputContainer", "outputSteam", " outputStreamer", "outStreamer", "inputSteam", "outSteam", "outStream", "Outputstream", "inputStreamer", "OutputView", "inputContainer", " outputstream", "outputStreamer", " outputView", "dataStream", "dataContainer", "OutputStreamer", "protectedStream", "protectedSteam"], "injectedClasses": ["injectedClasss", "injectedclassies", "injectedClassies", "injectedWrities", "injectionClassies", "injectedclasses", "injectedclasss", "injectionclasses", "injectedClassites", "injectedProjects", "injectionclassites", "injectionclassies", "injectionClassites", "injectionclasss", "injectedWritites", "injectedWrites", "injectedProjectites", "injectionClasss", "injectedProjecties", "injectedclassites", "injectedWrits", "injectionClasses", "injectedProjectes"], "newSize": [" newLength", "newFontSize", "NewLength", " newStorage", "newLength", "finalSize", "newStorage", "NewStorage", "NewFontSize", "finalStorage", "finalLength", "finalFontSize", " newFontSize", "NewSize"]}}
{"id1": "21152728", "id2": "13565787", "code1": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "code2": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "label": 1, "substitutes": {"authenticate": [" authenticated", "authicating", "Authenticated", "authentication", "Authenticating", " authenticating", "authenticating", "authicated", "Authentication", "authicate", "authication", "Authenticate", "authenticated", " authentication"], "module": ["rule", "mi", "method", "unit", "base", "model", "resource", "script", "service", "site", "config", "prefix", "mission", "course", " Module", "role", "input", "domain", "py", "entry", "mode", "message", "table", "conn", "member", "object", "device", "scope", "class", "element", " modules", "pin", "query", "m", "require", "io", "pm", "chain", "manager", "name", "cm", "mod", "Module", "server", "data", "file", "modules", "component", "instance", "str", "vm", "lock", "ctx", "connection", "msg", "project", "plugin", "header", "address"], "rand": ["re", "nd", "dd", "right", "in", " random", "bot", "pattern", "NG", "alpha", "rar", "round", "random", "bird", "conn", "pad", "chance", "r", "crypt", "ro", "rc", "grad", "max", "rage", "push", "token", "winner", "Rand", "min", "gram", "out", "raid", "gd", "auth", "init", "sum", "han", "range", "seed", "gen", "ng", "rot", "reg"], "challenge": ["scheenges", " challchall", "schege", " challonge", "passenge", "chalise", "Challise", "Challonge", "challenges", "challonge", "challge", "chge", "chaine", "challise", "buckonge", "Challchall", "Challge", "scheenge", "challchall", "passise", "challaine", "scheise", "chalge", "Challenge", " challge", "buckenge", "scheaine", "passge", "Challaine", "passenges", "buckge", "chise", "chalenges", "chenge", "chalenge", "buckchall"], "b64": ["basebl", "mb58", "base36", "b4", "mb64", "xb62", " b58", "b36", "bb16", " b62", " b36", "bb64", "base62", " b16", "b58", "B4", " b4", "b48", "xbbl", "base16", "bb36", "base48", "B58", " b48", "base58", "xb64", "b16", "B64", "mb4", "base64", "bb58", "b62", "bbl", "mb16", "B16", "xb48", " bbl"], "reply": ["body", "link", "base", "service", "answer", "prefix", "Response", "write", "related", "py", "entry", "reason", "parse", "text", "message", "http", "reset", "back", "repl", "remote", " replies", "Reply", "respond", "info", "queue", "voice", "sync", "replace", "string", "resp", "route", "buffer", "next", "query", "part", "result", "rr", "uri", "frame", "out", "secret", "ridge", "report", "received", "request", "server", "data", "range", "id", "error", "comment", "notice", "connection", "template", "address"], "user": ["rule", "ver", "force", "field", "service", "resource", "login", "address", "account", "using", "role", "write", "open", "match", "entry", "consumer", "text", "use", "key", "password", "User", "full", "replace", "uid", "object", "string", "pin", "USER", "creator", "route", "session", "pass", "token", "query", "author", "type", "result", "allow", "used", "out", "by", "secret", "client", "bug", "users", "me", "manager", "character", "name", "request", "proxy", "word", "server", "id", "data", "valid", "parent", "username", "host", "person", "error", "comment", "lock", "date", "per", "profile", "source", "project", "plugin", "url", "cover", "device"], "response": ["body", "model", "service", "answer", "resource", "account", "Response", "respons", "format", "json", "version", "message", "output", "password", "respond", "api", "object", "string", "status", "session", "resp", "token", "result", "uri", "secret", "request", "server", "data", "description", "error", "connection", "profile", "host", "url", "header", "address"], "secrets": ["SECards", "regurs", "regret", " secredits", "regrets", "subrets", "SECurs", "securityurs", "Secrets", "Secret", "secredits", "Secredits", "Securs", "SECret", "regards", "securityret", "securs", "secards", "secures", "Secards", "SECures", "secret", "securityures", "subredits", "Secures", "subret", "securityrets", " secret", "SECrets"], "md4": [" mdfour", "md5", " MDfour", "MD4", "mad4", " md256", " md44", "md6", "shafour", "mad04", "MDfour", "sha2", "mc4", " md6", "sha5", "mc6", "mc5", " MD2", " md04", "md2", " md2", "MD6", " md5", "MD04", " MD4", "mad2", "md04", "sha6", "sha4", "sha44", "sha04", "md44", "MD2", " MD6", "mad256", "MD256", "md256", "MD44", "mcfour", "mdfour", "madfour"], "line": ["look", "body", "rule", "log", "model", "link", "letter", "lc", "end", "lf", "cl", "lines", "entry", "inline", "LINE", "parse", "text", "message", "Line", "sync", "l", "shell", "object", "page", "style", "string", "code", "status", "definition", "pe", "pass", "strip", "part", "record", "frame", "row", "out", "le", "block", "lin", "name", "server", "data", "file", "range", "cell", "lo", "lock", "str", "comment", "error", "value", "profile", "url", "header"], "passwd": ["Password", "assWD", "passwordpassword", "passwordword", "asswd", " passpass", "assw", "Passpass", "pWD", "passpass", "passpassword", "password", "asspass", "ppass", "passWD", "pwd", "passwordwd", "passwordpass", "pw", "Passwd", " password", "PassWD", "passw", "Passpassword", "Passw", " passpassword"], "hash": ["image", "her", "sha", "html", "body", "base", "hex", "check", "match", "version", "cache", "key", "object", "style", "array", "flash", "kh", "cover", "build", "sh", "rh", "sign", "secret", "block", "ash", "Hash", "sum", "hed", "h", "shadow", "id", "ha", "server", "value", "tag", "url", "header"]}}
{"id1": "16511008", "id2": "8150996", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 0, "substitutes": {"createNewProfilingMessageSymbol": ["createNewProfilingMsgSymmbol", "createNewProfilingMessageYletter", "createNewProfilingMsgSymbol", "createNewProfilingMessageSyletter", "createNewProfilingMsgSyletter", "createNewProfilingMessageSymmbol", "createNewProfilingMessageCymb", "createNewProfilingMessageCymbol", "createNewProfilingMessageYmbol", "createNewProfilingMessageYmb", "createNewProfilingMessageCyletter", "createNewProfilingMessageSymb", "createNewProfilingMsgSymletter", "createNewProfilingMessageSymmb", "createNewProfilingMsgSymb", "createNewProfilingMsgSymmb", "createNewProfilingMessageSymletter"], "configID": [" configURL", "ConfigION", " configId", "projectURL", "ConfigID", "projectID", "configURL", " configUID", "projectION", " configION", "configId", "configUID", "ConfigUID", "projectId", "ConfigURL", "projectUID", "ConfigId", "configION"], "programMessageSymbolID": ["programMessageSyymIP", "programMessageSyklName", "programMessageSychid", "programMessageSymbID", "programMessageSymbolId", "programMessageSyncmbId", "programMessageSyncmbid", "programMessageSymbid", "programMessageSyncmbolName", "programMessageSyklId", "programMessageSyymID", "programMessageSyymName", "programMessageSyntaxID", "programMessageSyncmbolId", "programMessageSyncmbName", "programMessageSychID", "programMessageSyncmbolIP", "programMessageSychId", "programMessageSyntaxid", "programMessageSyncmbID", "programMessageSyncmbIP", "programMessageSyntaxName", "programMessageSymbolIP", "programMessageSyntaxId", "programMessageSymbId", "programMessageSyncmbolid", "programMessageSymbIP", "programMessageSyymId", "programMessageSymbName", "programMessageSyncmbolID", "programMessageSymbolid", "programMessageSyklID", "programMessageSymbolName"], "profilingMessageSymbol": ["profilingFileSymmbol", "profilingMessageYmb", "profilingMessageSynPart", "profilingMessageYmbol", "profilingMessageSymmbol", "profilingApplicationSyletter", "profilingMessageCymb", "profilingApplicationSymmbol", "profilingMessageTyPart", "profilingMessageCyletter", "profilingApplicationSymmb", "profilingFileSymPart", "profilingMessageSymletter", "profilingApplicationSymbol", "profilingMessageSymmb", "profilingMessageSyletter", "profilingMessageSynmb", "profilingMessageTymb", "profilingFileSymbol", "profilingFileSymb", "profilingApplicationSymb", "profilingFileSymmb", "profilingFileSyPart", "profilingMessageTymbol", "profilingMessageCymbol", "profilingMessageSynmbol", "profilingMessageSymPart", "profilingMessageSyPart", "profilingMessageSymb", "profilingApplicationSymletter", "profilingFileSyletter", "profilingFileSymletter", "profilingMessageYletter"], "connection": ["image", "unit", "log", "pool", "index", "section", "ion", "function", "channel", "Connection", "cache", "use", "password", "environment", "conn", "ongo", "table", "driver", "application", "sql", "c", "engine", "position", "condition", "session", "state", "collection", "relation", "result", "si", "response", "client", "command", "context", "manager", "communication", "con", "server", "document", " Connection", "cond", "connect", "lock", "error", "database", "ctx", "connected", "bc", "config", "db", "socket", "machine", "directory"], "statement": ["unit", "Query", "section", "agent", "storage", "ment", "Statement", "function", "ma", "usage", "study", "parse", "Connection", "message", "parser", "use", "table", "writer", "conn", "string", "sql", "summary", "position", "condition", "session", "state", "collection", "relation", "pass", "part", "result", "stat", "si", "se", "commit", "out", "mt", "response", "command", "expression", "Session", "report", "joined", "library", "volume", "document", "connect", "lock", "str", "error", "database", "comment", "timeout", "execute", "db", "directory"], "resultSet": ["ResultGen", "ResultS", "rowS", "ResultRow", " resultList", "ResultSource", " resultLine", "resultSource", " resultSource", " resultS", "dataRow", "ResultSplit", "ResultLine", "replySplit", " resultType", "resultType", "rowType", "responseRow", "dataLine", "rowSet", "responseList", "resultS", "resultGen", "resultLine", "replyLine", "resultsSource", "resultRow", "rowSource", "resultsSet", "dataSource", "dataGen", "ResultList", "ResultSet", "replyList", "ResultType", " resultGen", "responseSet", "resultList", "resultsGen", "replySet", "dataSet", " resultSplit", "dataList", "resultSplit"], "query": ["rule", "eries", "index", "o", "q", "Query", "script", "question", "send", "module", "root", "function", "scan", "filter", "reason", "parse", "message", "key", "table", "qu", "update", "style", "string", "code", "sql", "condition", "work", "join", "type", "result", "ql", "uri", "command", "qs", "sq", "value", "expression", "name", " Query", "report", "request", "search", "execute", "id", "call", "lock", "comment", "error", "description", "str", "database", "feature", "go", "select", "timeout"], "msg": ["err", "log", "html", "nm", "cmd", "dr", "exc", "format", "ma", "ag", "reason", "sim", "text", "message", "bag", "ger", "ms", "agg", "cap", "status", "cfg", "var", "rag", "mn", "g", "gr", "tag", "gor", "op", "doc", "fg", "phrase", "cmp", "lang", "sg", "gm", "rr", "mr", "mt", "mg", "Message", "Msg", "comm", "name", "title", "tool", "map", "gs", "cm", "ge", "loc", "id", "gen", "e", "error", "str", "desc", "og", "pkg", "bg", "m", "ug", "db", "md"]}}
{"id1": "22479286", "id2": "15202804", "code1": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"md5": ["md2", "MD4", "md4", "m2", "sha4", "m512", "MD512", "MD5", "sha512", "m4", "sha2", "sha5", "md512", "m5", "MD2"], "plainText": ["flatTEXT", "flatString", "publicTEXT", "extraByte", "publicContent", "messageSecret", "flatKey", " plainShort", "flatText", "regularString", " plainCode", " plainSecret", "regularSecret", "rubyTEXT", "flatShort", "extraContent", "coreContent", "publictext", "regularShort", "plainSecret", " plainWidth", "messageCode", "regularContent", "plaintext", "flattext", "rubyValue", "extraText", "encryptedContent", " plainValue", "encryptedText", " plainByte", "plainShort", "coreValue", " plainTEXT", "plainWidth", "plainString", "singleTEXT", "singleWidth", " plainKey", "plainValue", "plainCode", "plainByte", "publicText", "plainContent", "publicKey", "coreTEXT", "extraTEXT", " plainString", "plainKey", "regulartext", "rubyByte", "coreText", "plainTEXT", "messageContent", "singleText", "flatWidth", "encryptedtext", "regularCode", "rubyContent", "encryptedTEXT", " plainContent", "rubyText", "regularText", "messageText", " plaintext"], "md": ["dd", "de", "sha", "cmd", "meta", "am", "dig", "metadata", "amd", " MD", "hd", "mm", "mo", "message", "ms", "cd", "wd", "mp", "vd", "hash", "gb", "mand", "d", "bd", "ad", "pm", "df", "mg", "sm", "mac", "mt", "me", "MD", "Cmd", "mod", "pd", "mag", "rm", "dm", "mc", "mb", "hm", "m", "rpm", "f"], "digest": ["compit", "dEST", "dimest", "digitest", "dimested", "dedex", "dedEST", "digitested", "DigEST", "mdest", "mdEST", "digester", "digex", "dedest", "dester", "Digex", "digitester", "dimex", "compEST", "Digester", "dimEST", "dest", "compest", "Digested", "mdit", "digit", "mdger", "Digit", "compger", "Digger", "digEST", "digested", " digEST", "dedested", "dested", " digested", "digitEST", "digger", "Digest", " digester"], "hexString": ["hexSingle", " hexstring", "tempString", "exContent", "stringBuffer", " hexContent", "exService", " hexSingle", "tempService", "longString", "exText", "tempstring", "longService", "stringString", "tempBuffer", "exBuffer", "exString", " hexService", "rawSingle", "hexText", "hexBuffer", "longContent", "rawBuffer", "exstring", "longText", " hexArray", "hexService", "hexstring", "hexArray", "stringArray", "rawString", " hexBuffer", " hexText", "rawArray", "hexContent", "stringSingle"], "i": ["z", "index", "j", "in", "o", "oi", "end", "phi", "at", "ii", "count", "slice", "mu", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "t", "d", "li", "k", "ci", "p", "type", "multi", "si", "io", "part", "it", "uri", "v", "x", "number", "ai", "xi", "bi", "length", "start", "a", "ti", "qi", "id", "e", "u", "f", "n", "di", "m", "I", "s"]}}
{"id1": "9826240", "id2": "17583193", "code1": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public boolean populateRecord(int[] attrIDs) throws IOException {\n        if (device == null) {\n            throw new RuntimeException(\"This is local device service record\");\n        }\n        if (attrIDs == null) {\n            throw new NullPointerException(\"attrIDs is null\");\n        }\n        if (attrIDs.length == 0) {\n            throw new IllegalArgumentException();\n        }\n        for (int i = 0; i < attrIDs.length; i++) {\n            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {\n                throw new IllegalArgumentException();\n            }\n        }\n        int[] sortIDs = new int[attrIDs.length];\n        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);\n        for (int i = 0; i < sortIDs.length; i++) {\n            for (int j = 0; j < sortIDs.length - i - 1; j++) {\n                if (sortIDs[j] > sortIDs[j + 1]) {\n                    int temp = sortIDs[j];\n                    sortIDs[j] = sortIDs[j + 1];\n                    sortIDs[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < sortIDs.length - 1; i++) {\n            if (sortIDs[i] == sortIDs[i + 1]) {\n                throw new IllegalArgumentException();\n            }\n            DebugLog.debug0x(\"query for \", sortIDs[i]);\n        }\n        DebugLog.debug0x(\"query for \", sortIDs[sortIDs.length - 1]);\n        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);\n    }\n", "label": 0, "substitutes": {"checkHashBack": ["checkSumBack", "checkKeyback", "checkHashback", " checkhashBACK", "checkhashBack", "checkhashFront", "checkhashback", " checkHashback", "checkSumback", " checkhashFront", " checkhashback", "checkKeyFront", "checkKeyBACK", "checkKeyBack", "checkHashBACK", " checkhashBack", "checkHashFront", "checkSumBACK", " checkHashBACK", "checkhashBACK", " checkHashFront", "checkSumFront"], "facade": ["facce", " facase", " facce", "Facades", " facale", "factase", "fale", "humce", "Facede", "foke", "factce", "factide", "fade", " facide", "factade", "Facace", " facede", "facades", "facede", "fades", "Facse", " facace", "Facce", "humase", "facoke", "factse", "Facoke", "facale", "fse", "facide", "Facade", "factoke", "facace", "Facale", "face", "humade", "Facase", "facase", "facse", " facades", "Facide", "humede", " facoke", "fase"], "req": ["err", "base", "resource", "q", "fr", "temp", "crit", "view", "form", "w", "cur", "obj", "rt", "http", "cache", "ref", "qq", "rec", "prof", "info", "jp", "cb", "required", "pr", "rf", "def", "r", "resp", "gr", "wx", "query", "sem", "Request", "cmp", "require", "rr", "proc", "response", "fp", "pull", "sq", "util", "xml", "pb", "app", "request", "rb", "pkg", "res", "ctx", "ru", "pro", "requ", "exec", "f", "url"], "txtTransactionID": ["textTaskType", "txtOperationName", "txtOperationId", "textTaskIP", "txtJobIP", "textTaskInfo", "txtOrderType", "txtOperationID", "txtTransactionType", "txtOrderID", "txtOperationType", "txtTaskId", "textTransactionId", "txtTaskID", "txtOrderName", "textTransactionID", "txtOperationInfo", "txtTransactionIP", "txtTransactionId", "txtTransactionName", "textTransactionName", "textTransactionInfo", "txtTaskName", "textTaskId", "txtTaskIP", "txtOrderId", "txtTaskType", "txtJobId", "txtTaskInfo", "textTransactionIP", "txtJobInfo", "txtOperationIP", "textTaskID", "txtJobID", "textTransactionType", "txtTransactionInfo", "textTaskName"], "txtOrderTotal": ["txtEventToken", "xtBlockNum", "txtOrderLast", "xtOrderLast", "txtOrderToken", "txtRequestLast", "txtEventInfo", "xtBlockTotal", "txtJobtotal", "txtBlockTotal", "txtOrdertotal", "xtRequestInfo", "xtRequestLast", "txtAddresstotal", "txtJobTotal", "txtJobLast", "txtOrderInfo", "txtOrderNum", "txtBlockToken", "xtOrderInfo", "txtJobToken", "txtRequestInfo", "xtOrdertotal", "txtRequesttotal", "xtOrderTotal", "xtOrderToken", "txtAddressTotal", "txtBlockNum", "txtAddressInfo", "xtRequestTotal", "txtAddressLast", "txtRequestTotal", "xtBlockToken", "txtJobInfo", "xtRequesttotal", "txtJobNum", "txtBlockInfo", "xtOrderNum", "txtEventNum", "xtBlockInfo", "txtEventTotal"], "txtShopId": ["textShopInfo", "txtShopName", "txtFactoryID", "txtSessionName", "textShopId", "textJobID", "txtOrderID", "txtSessionID", "textShopID", "textJobInfo", "txtSessionInfo", "txtShopInfo", "textJobId", "txtOrderName", "txtOrderInfo", "txtJobName", "txtFactoryName", "txtSessionId", "textJobName", "textShopName", "txtOrderId", "txtFactoryInfo", "txtJobId", "txtFactoryId", "txtJobInfo", "txtShopID", "txtJobID"], "txtArtCurrency": ["txtArtCerc", "txtArtcerc", "txtARTCcurrency", "txtArtcurrency", "txtArtCurrencies", "txtartcurrency", "txtArtLCurrency", "txtArtccurrency", "txtArtculture", "txtARTCurrencies", "txtArtCustomurrency", "txtartccurrency", "txtArtCcurrency", "txtArtcurrencies", "txtartCulture", "txtArtCulture", "txtArtAcurrency", "txtArtCustomcurrency", "txtArtCustomulture", "txtArtCustomerc", "txtARTSculture", "txtArtLCurrencies", "txtartcerc", "txtArtAcerc", "txtArtScurrency", "txtArtScurrencies", "txtartCurrency", "txtARTScurrency", "txtArtAccurrency", "txtArtSccurrency", "txtartCerc", "txtArtAculture", "txtartculture", "txtARTScurrencies", "txtArtLCulture", "txtARTCurrency", "txtartCcurrency", "txtARTCulture", "txtArtLCcurrency", "txtARTSccurrency", "txtArtSculture"], "txtHashBack": ["txtHandleback", "txtCheckback", "textHashReturn", "xtHashRest", "txtCheckSave", "txtHandleRest", "textHashBack", "txtHashback", "txtSumback", "txtHashRest", "txtMessageRest", "xtHashBack", "xtHashBACK", "xtMessageRest", "xtHashback", "txtMessageBack", "txtSumReturn", "xtSumBACK", "txtSHABack", "txtBlockback", "txtStyleBack", "txtBlockFront", "txtHashSave", "txtHashFront", "txtBlockRest", "xtMessageReturn", "txtBlockBack", "xtMessageBack", "txtHandleBack", "xtSumSave", "textSumFront", "txtHashBACK", "txtSumBack", "textHashback", "txtBlockReturn", "xtMessageback", "txtSHAback", "xtSumback", "textHashFront", "xtHashReturn", "txtStyleBACK", "txtMessageReturn", "txtCheckBACK", "textSumback", "xtHashSave", "textSumReturn", "txtHandleReturn", "textSumBack", "txtMessageback", "txtSHAReturn", "txtStyleback", "xtSumBack", "txtSHAFront", "txtCheckBack", "txtHashReturn", "txtSumBACK", "txtStyleSave", "txtSumFront", "txtSumSave"], "hashSeed": ["hashSlql", "HashSlees", "HashSleeds", " hashRead", "hashPreseeds", "HashSleed", " hashSee", " hashReeds", "hashSees", "hashSeriesees", "hashRee", "HashSeed", " hashSead", "hashSleeds", "hashSlead", " hashReed", " hashRee", "hashSeriesql", "HashSees", "HashSeeds", "hashSee", "hashSleed", "hashSead", "hashPreseed", "hashRead", "hashSerieseed", "hashSerieseeds", "hashPresees", "hashSlees", "hashSlee", "hashPresql", "HashSlql", " hashSeeds", "hashSql", "hashReed", "HashSql", "hashReeds", "hashSeeds"], "securityValue": [" securityFile", "secureFile", "SecurityFile", " securityValues", "SecurityKey", "secureKey", "SecurityValue", "SecurityString", "SecurityValues", "securityKey", "securityFile", "secureValue", "secureValues", "securityString", " securityString", " securityKey", "secureString", "securityValues"], "digest": [" Digest", "logester", "digHash", "sended", "Diged", " digence", " digestro", " Digestro", "defge", " digester", "DigEST", "signEST", "digge", "hashed", " Digge", "digester", "logest", "DigHash", "Digester", " Digested", "defested", "Digestro", "sendHash", "defester", "digence", "hashHash", "diged", "Digested", " Digester", "defest", "logusher", "logence", "Digge", "hashEST", "signest", "signester", "digusher", " digusher", "sendEST", "sendest", "digested", "digEST", " digEST", "signested", "Digence", " digested", "Digest", "digestro", "Digusher", "hashest", " DigEST"], "array": ["image", "section", "storage", "integer", "sample", "audio", "arr", "function", "order", "our", "message", "cache", "pair", "area", "list", "environment", "object", "string", "element", "collection", "buffer", "Array", "record", "allow", "number", "row", "arrow", "ray", "archive", "range", "data", "binary", "instance", "value", "error", "database", "angle", "feature", "batch", "address"], "sb": ["ib", "wb", "nb", "bsp", "kb", "bm", "osc", "eb", "zb", "SB", "sa", "xb", "src", "bb", "cb", "sup", "usb", "string", "buf", "gb", "abb", "buffer", "sn", "fb", "lb", "bf", "bj", "si", "obb", "su", "sv", "sg", "nn", "sq", "orb", "pb", "bt", "ssl", "bs", "ob", "sf", "sl", "rb", "mb", "bc", "bh", "bg", "BB", "db", "s"], "j": ["z", "aj", "index", "o", "jc", "section", "jl", "ii", "ix", "dy", "key", "l", "ch", "jp", "js", "pr", "c", "uj", "g", "k", "ind", "d", "li", "m", "p", "part", "ja", "v", "x", "ji", "y", "dj", "length", "jj", "oj", "jo", "J", "e", "u", "i", "ij", "n", "bj", "br", "f", "obj"], "b": ["body", "ib", "wb", "nb", "eb", "ba", "l", "bb", "bin", "cb", "bp", "string", "code", "c", "d", "k", "be", "lb", "job", "p", "bd", "fb", "bi", "x", "B", "bug", "orb", "bar", "a", "bs", "ob", "binary", "e", "i", "rb", "mb", "bc", "bf", "br", "db", "f", "ab"], "hash": ["image", "sha", "html", "oh", "height", "hex", "history", "json", "match", "message", "cache", "dash", "key", "password", "ruby", "math", "flash", "gh", "kh", "confirmed", "ph", "result", "cover", "build", "sh", "number", "rh", "mac", "handle", "block", "ash", "auth", "memory", "ssh", "report", "Hash", "sum", "hed", "h", "search", "ha", "hh", "dh", "lock", "value", "error", "db", "url", "header", "address"]}}
{"id1": "10504714", "id2": "771802", "code1": "    private MediaWikiResult getFromUri(String url) throws OntologyServiceException {\n        try {\n            logger.info(\"getting \" + url);\n            HttpURLConnection connection = (java.net.HttpURLConnection) new URL(url).openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"OntoCat-\" + Math.random());\n            BufferedInputStream bin = new BufferedInputStream(connection.getInputStream());\n            JAXBContext jaxbContext = JAXBContext.newInstance(\"uk.ac.ebi.ontocat.mediawiki.jaxb\");\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n            return (MediaWikiResult) unmarshaller.unmarshal(bin);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new OntologyServiceException(e);\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 0, "substitutes": {"getFromUri": ["getFromUuri", "getFromURuri", "getFromUUrl", "getfromPUri", "getfromPURI", "getfromPUuri", "getfromURI", "getFromURUrl", "getFromRuUrl", "getFromPUuri", "getFromPURI", "getfromUuri", "getFromPUUrl", "getFromURRI", "getFromURri", "getFromRuRI", "getFromPUri", "getfromPUUrl", "getfromUri", "getFromRuuri", "getFromURI", "getfromUUrl", "getFromRuri"], "url": ["image", "rule", "URL", "base", "email", "resource", "lr", "feed", "www", "download", "Url", "ls", "http", "src", "filename", "href", "l", "info", "full", "page", "string", "ri", "buffer", "route", "path", "source", "type", "result", "uri", "build", "layer", "ur", "name", "ssl", "request", "proxy", "language", "server", "data", "ll", "host", "file", "id", "username", "str", "sl", "i", "loc", "location", "address"], "connection": ["image", "j", "index", "in", "service", "section", "ion", "function", "which", "channel", "Connection", "http", "use", "password", "b", "conn", "writer", "object", "application", "c", "position", "condition", "collection", "relation", "handler", "translation", "part", "io", "uri", "network", "number", "response", "client", "character", "context", "socket", "communication", "proxy", "con", "server", " Connection", "connect", "i", "database", "bc", "connected", "config", "db", "directory"], "bin": ["body", "base", "in", "login", "inner", "inn", "input", "bot", "channel", "ban", "bon", "src", "bit", "brain", "output", "b", "bb", "ruby", "conn", "ran", "spin", "pin", "border", "buffer", "abi", "container", "bi", "sin", "bis", "bn", "bean", "data", "file", "binary", "database", "win", "bc", "lib", "din", "plugin", "socket"], "jaxbContext": ["japbSupport", "jaxfSupport", "jaxaText", "jaxacontext", "jjbText", "jaxfbContext", "jaxaContext", "jaxecontext", "japbcontext", "jaxfChannel", "jjbcontext", "japbText", "jaxfbText", "jaxeSupport", "jaxfbcontext", "jaxpChannel", "jaxbSupport", "jaxfbChannel", "japacontext", "jaxaSupport", "japaSupport", "jjfcontext", "jaxpContext", "jaxbcontext", "japaText", "jjfChannel", "jjbChannel", "japaContext", "jaxpcontext", "jjfContext", "jaxfcontext", "jjfText", "japbContext", "jaxfText", "jaxbChannel", "jaxeText", "jaxfContext", "jaxeContext", "jjbContext", "jaxbText", "jaxpText"], "unmarshaller": ["unmarshallER", "unmarshallingender", "unmarshaliner", "unmarshaler", "unmarshalletter", "unmarshdaletter", "unmarshallsiner", "unmarshALLiner", "unmarshullender", "unmarshdalender", "unmarshdaler", "unmarshallers", "unmarshallsER", "unmarshallser", "unmarshALLER", "unmarshallingetter", "unmarshalER", "unmarshalleder", "unmarshallingeder", "unmarshallsers", "unmarshulletter", "unmarshallender", "unmarshALLers", "unmarshallinger", "unmarshulleder", "unmarshalers", "unmarshdaleder", "unmarshALLer", "unmarshalliner", "unmarshuller"]}}
{"id1": "22734545", "id2": "12078471", "code1": "    public void generate(String urlString, String target) throws Exception {\n        URL url = new URL(urlString);\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        BufferedInputStream inputStream = new BufferedInputStream(urlConnection.getInputStream());\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target));\n        byte[] buf = new byte[10 * 1024];\n        int len;\n        while ((len = inputStream.read(buf, 0, buf.length)) != -1) {\n            outputStream.write(buf, 0, len);\n        }\n        inputStream.close();\n        outputStream.close();\n        urlConnection.disconnect();\n    }\n", "code2": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "label": 0, "substitutes": {"generate": ["generATE", "Generate", "generating", " generating", " interpolATE", "Generating", " interpolate", " interpolile", "generile", "GenerATE", " generile", " interpolating", "Generile", " generATE"], "urlString": ["resourceFile", "urlstring", "fileStream", "urlFile", "urlStream", " urlStream", "fileStr", "urlUrl", "addressFile", "urlStr", "addressString", " urlUrl", " urlFile", "httpString", "fileString", "addressUrl", "httpFile", "fileUrl", "fileFile", "httpstring", "resourceString", "resourceStr", "filestring", "httpStr", "resourcestring", "addressStream"], "target": ["base", "resource", "temp", "content", "to", "format", "download", "Target", "match", "top", "src", "text", "filename", "output", "remote", "object", "string", "external", "buffer", "next", "path", "result", "dest", "context", "name", "location", "host", "file", "parent", "database", "timeout", "arget", "connection", "source", "project", "address"], "url": ["image", "log", "URL", "base", "resource", "feed", "www", "this", "stream", "download", "Url", "ball", "ls", "open", "http", "l", "b", "bb", "conn", "page", "string", "c", "r", "buffer", "source", "uri", "plug", "build", "client", "blog", "ssl", "server", "user", "file", "ll", "gl", "sl", "connection", "config", "host", "web", "f"], "urlConnection": ["fileconnection", "URLConnector", "inputconnection", "URLConn", "webConnection", "URLConnection", "httpConnection", "httpconnection", "urlNetwork", "URLPool", "URLUnit", " urlConnector", "URLconnection", "inputPool", "inputConnection", "webConn", "inputConnect", "urlconnection", "urlPool", " urlConn", "httpConn", "URLNetwork", "webUnit", "httpConnect", "inputConnector", "webConnect", "webNetwork", "urlConn", "urlConnector", " urlPool", "webconnection", "inputConn", "fileNetwork", "urlConnect", "fileUnit", "urlUnit", "fileConnection"], "inputStream": ["inConnection", " inputQueue", "inputView", "outputView", "outputConnection", "InputChannel", "inStream", "inSteam", " inputChannel", "InputSteam", "inputChannel", "inputConnection", "inputQueue", "outputSteam", " inputSteam", "inputSteam", "InputQueue", "outputChannel", " inputConnection", "outputQueue", "InputView", "InputStream", "inView", " inputView", "InputConnection"], "outputStream": ["putSteam", "outputstream", "OutputSteam", " outputDirectory", " outputSteam", "resourcestream", "inputView", " outputConnection", "outputView", "outputConnection", "resourceConnection", "resourceStream", "putStreamer", "OutputStream", "inputstream", "putstream", "putStream", "inputConnection", "outputSteam", " outputStreamer", "inputSteam", "OutputDirectory", "Outputstream", "resourceSteam", "OutputView", "outputDirectory", "OutputStreamer", "outputStreamer", " outputstream", " outputView", "inputDirectory"], "buf": ["dec", "num", "wb", "pool", "raw", "br", "func", "vec", "done", "ba", "input", "ff", "count", "queue", "bag", "output", "uf", "bytes", "b", "cb", "blocks", "pad", "cap", "bin", "bh", "c", "bp", "buff", "pos", "gb", "buffer", "rc", "fd", "bb", "fb", "bf", "bd", "job", "cat", "Buff", "v", "block", "cas", "off", "la", "loc", "bs", "data", "cv", "rb", "bc", "seq", "batch", "uc", "Buffer", "ab"], "len": ["err", "base", "in", "nt", "end", "val", "lf", "pre", "count", "ler", "l", "b", "bin", "ann", "cap", "read", "c", "pos", "r", "li", "ie", "en", "fl", "line", "part", "Len", "min", "le", "length", "off", "size", "start", "la", "ln", "data", "limit", "el", "no", "i", "n", "iter", "fin", "db", "f", "lin"]}}
{"id1": "364438", "id2": "14733078", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["oconversion", "CONversion", "oconverting", " deconverted", "CONverting", " deconvert", "conception", "CONception", " deconverting", "unverted", "subversion", "CONverted", "Conception", " deconversion", "oconvert", "unversion", "converted", "unception", "subvert", "conversion", "Convert", "unvert", "Converted", "subverted", "subverting", "converting", "oconverted", "Converting", "Conversion", "CONvert"], "src": ["video", "resource", "storage", "config", "stream", "Source", "impl", "gz", "RC", "input", "download", "feat", "req", "ref", "load", "back", "filename", "slice", "href", "cb", "prot", "url", "string", "code", "buf", "gb", "spec", "dist", "cpp", "rc", "stage", "sn", "path", "st", "sc", "cmp", "upload", "ource", "uri", "sb", "proc", "SourceFile", "sin", "img", "fp", "supp", "attr", "sit", "secure", "tmp", "name", "ssl", "Dest", "sel", "sys", "component", "file", "fn", "inst", "username", "sth", "reader", "rb", "rl", "ctx", "scene", "loc", "source", "obj", "s"], "dest": [" destination", "temp", "cont", "dc", "dat", "target", "bin", "home", "null", "txt", "class", "orig", "lib", "dist", "path", " dst", "img", "dir", "std", "tmp", "test", "Dest", "fn", "di", "source", "obj", "disk"], "in": ["ini", "err", "login", "stream", "inn", "inf", "val", "input", "In", "up", "bin", "pin", "r", "IN", "ps", "t", "pass", "d", "doc", "source", "io", "ins", "is", "as", "inas", "a", "data", "isin", "file", "ex", "i", "reader", "win", "n", "din", "f", "inc"], "p": ["np", "j", "o", "po", "pre", "py", "P", "pc", "cop", "parser", "l", "b", "jp", "pr", "bp", "lp", "pi", "pp", "sp", "pe", "c", "r", "wp", "g", "ps", "t", "pa", "d", "op", "pg", "part", "pm", "v", "fp", "pb", "h", "tp", "pd", "e", "i", "per", "cp", "m", "f", "s"], "ds": ["ths", "dp", "vals", "ls", "services", "ads", "ld", "lp", "groups", "dt", " ps", "os", "ins", "icks", "nas", "ts", "dates", "scripts", "s", "dc", "dat", "Ds", "points", "els", "sync", "tools", "ipes", "xs", "obs", "sts", "d", "ils", "dds", "hs", "gs", "docs", "sys", "pd", "dm", "ss", "dl", "des", "posts", " DS", "utils", "cons", "lines", "ns", "ges", "da", "tests", "ays", "dist", " props", "eps", "cs", "df", "uds", "gd", "qs", "ys", "data", "ded", "ks", "words", "di", "db", "parts", "dd", "ants", "vs", "amps", "ans", "DS", "dos", "plugins", "styles", "js", "ps", "rs", "ups", "models", "bs", " sd"], "format": ["letter", "model", "unit", "nat", "plugin", "prefix", "form", "function", "pattern", "at", "feat", "filter", "version", "parser", "atter", "filename", "sche", "api", "table", "Format", "struct", "style", "string", "class", "scale", "act", "spec", "t", "fd", "path", "handler", "ant", "template", "source", "type", "record", "part", "frame", "fp", "name", "language", "host", "data", "file", "layout", "fn", "magic", "config", "tag", "f", "url"], "hasPixelData": ["hasPixelStyle", "haspixeldata", "showsByteDATA", "hasByteStyle", " hasPixelSize", "hasByteDATA", "showsPixelDATA", "hasPixelDATA", "hasPictureSize", "hasPixeldata", "hasByteData", "hasPixelSize", "showsPixelData", "haspixelData", "hasPicturedata", "showsByteData", "hasByteSize", "showsByteStyle", "haspixelSize", "showsPixeldata", "showsBytedata", "showsPixelStyle", "hasBytedata", "hasPictureData", " hasPixeldata"], "inflate": ["inadequode", "infloation", "inadequATE", "InFlace", "infloace", "Inflation", "inflation", "InFlate", "Inflated", "inflode", "infolode", "insflating", "invenate", "insvenate", "infolate", "Inflate", "infolATE", "infolating", "InFlated", "insvenATE", "invenating", "inFlace", "inflace", "insflode", "invenode", "inadequating", "insvenating", "inffate", "InFlation", "insflate", "inffation", "invenATE", "infloated", "inffated", "inflating", "inFlate", "Inflace", "insflATE", "infface", "infloate", "inFlated", "inadequate", "insvenode", "inflated", "inflATE", "inFlation"], "pxlen": ["pxden", "pxdata", "mxlen", "campos", "pxln", "mxln", "pxlon", "camln", "mxcount", "pxlin", "pngsize", "xplength", "fxln", "xpsize", "pgden", "ppl", "pplen", "fxden", "pxsize", "pxcount", "fxpos", "axlin", "pclon", "ppLen", "pnglength", "txlon", "pnglen", "pxl", "mxlength", "xplen", "xpcount", "axlen", "txlin", "txln", "pxpos", "ppden", "mxdata", "pglen", "pgLen", "mxpos", "pxlength", "fxl", "pclen", "pgl", "camlen", "pclin", "camdata", "axln", "txlen", "pcln", "fxLen", "pxLen", "mxsize", "fxdata", "pngcount", "fxlen", "axlon"], "out": ["re", "err", "log", "point", "step", "cli", "inter", "up", "group", "cache", "output", "OUT", "list", "conn", "post", "page", "pad", "store", "session", "state", "again", "outs", "work", "query", "line", "io", "v", "Out", "co", "dump", "sys", "server", "user", "gen", "lock", "error", "lib", "parent", "obj", "copy"]}}
{"id1": "16556717", "id2": "19912848", "code1": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"getSHADigest": ["getSHADegEST", "getSHADIGest", "getSHAPigher", "getSHAPigester", "getSHAPigest", "getSHADipest", "getSHADIGEST", "getSHAPegher", "getSHADipester", "getSHADipEST", "getSHADegest", "getSHAPigEST", "getSHADigester", "getSHADegher", "getSHADigEST", "getSHADigher", "getSHAPegester", "getSHADipher", "getSHADIGester", "getSHAPegEST", "getSHADIGher", "getSHADegester", "getSHAPegest"], "password": ["encrypted", "Password", "email", "prefix", "input", " passwords", "pattern", "text", "key", "wd", "string", "hash", "code", "Pass", "buffer", "pass", "crypt", "token", "padding", "path", "p", "phrase", "attribute", "secret", "auth", "name", "PASS", "word", "data", "id", "user", "username", "sword", "security", "words", "config", "address"], "digest": ["Digkey", "greatesting", "Digesting", "digkey", "hashkey", "greatEST", "DigEST", "hashress", "hashString", "digString", "hashests", "dighest", "digesting", "hashester", "digester", "Digests", "hexests", "Digester", "hexest", "greatest", " digesting", "Dighest", "generester", "digests", "digress", " digress", "generhest", "Digress", " dighest", "digusher", " digusher", "hexkey", "hexString", "DigString", "digEST", " digEST", "generEST", "generest", "hashusher", "Digest", "Digusher", "hashest", "greatester", " digester"], "sha": ["ka", "slave", "ga", "lambda", "ema", "ba", "alias", "po", "ma", "eta", "sa", "alpha", "ua", "ca", "shi", "acha", "api", "asha", "ami", "SHA", "hash", "da", "pi", "aa", "wa", "pa", "ph", "si", "ah", "sh", " SHA", "mac", "va", "na", "ssh", "la", "a", "sum", "volume", "h", "ha", "oa", "hh", "cca", "qa", "mc", "ta", "meta", "acl", "pg", "ppa", "HA"], "pwhash": [" pwest", "pwhest", "pwash", " pwade", " pwhade", "jpWHash", "jpWHest", " pwhashed", "pwest", "pwa", " pwhest", "pwha", "pphest", "pwheest", "jpWHashed", "jpwhest", " pwashed", "pWHa", "pphash", "pWhade", "jpwhash", "jpwhashed", "pwheash", "pWHash", "pwhea", " pwash", "pWhash", "pWhest", "pwhade", "pWhashed", "pwhashed", "pwashed", "pphade", "jpwha", "pwheashed", "pWHest", "pphashed", "pwade", "pWHashed", "jpWHa"]}}
{"id1": "21656668", "id2": "8079516", "code1": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"copyResourceToFile": ["copyResourceAsFile", "copyResourcesToResource", "copyResource2Files", "copyResourcesFromFile", "copyResourceAsFiles", "copyResourcesToFolder", "copyResource2Resource", "copyResourcesFromFiles", "copyResourcesToFiles", "copyResourcesFromResource", "copyResourceToFolder", "copyResourceToFiles", "copyResourceFromFile", "copyResourceAsFolder", "copyResourceToResource", "copyResourcesToFile", "copyResourceFromFolder", "copyResourceFromFiles", "copyResource2File", "copyResourceAsResource", "copyResourceFromResource", "copyResource2Folder", "copyResourcesFromFolder"], "resourceFilename": ["resourceFile", "Resourcefilename", " resourceFile", "resourcefilename", "sourceString", "sourceFilename", "requestPath", "requestString", "resourcePath", " resourceString", "sourceSourceFile", "ResourcePath", "sourceFile", "requestfilename", " resourcefilename", "resourceSourceFile", "ResourceSourceFile", " resourceSourceFile", "resourceString", "ResourceFilename", " resourcePath", "ResourceFile", "requestFilename", "ResourceString"], "destinationFilename": ["DestificationSourceFile", "destinationFile", "DestinationFile", "destarationFilename", "destationModule", "DestificationThumbnail", "destationSourceFile", "destificationSourceFile", "DestinationSourceFile", "destificationThumbnail", "destignmentThumbnail", "destarationFile", "DestinationThumbnail", "destationFile", "DestificationModule", "destinatorModule", "destificationFilename", "DestificationFilename", "destinatorFile", "destificationFile", "destinationThumbnail", "destinationSourceFile", "destinatorFilename", "destinatorSourceFile", "destignmentFile", "destignmentFilename", "destationFilename", "DestinationFilename", "DestinationModule", "destarationThumbnail", "destificationModule", "DestificationFile", "destinationModule"], "inStream": ["INSteam", " inStreamer", "binSteam", " inSt", "outFile", "ninSteam", "ninstream", "outSt", "inputstream", "ninStream", "inFile", "outCh", "inSteam", "inputStream", "INStreamer", "INStream", "inCh", "outstream", " instream", "binstream", "INFile", "binStreamer", " inFile", "binStream", " inSteam", "outStreamer", " inCh", "outSteam", "inputSteam", "ninStreamer", "inputStreamer", "inSt", "INstream", "instream", "inputSt", "inStreamer", "inputCh"], "outStream": ["workstream", "outputstream", " outPath", "OutPath", "OUTFile", "againDirectory", "Outstream", "outFile", "workSteam", " outFile", "OUTSteam", "inFile", "inSteam", "inputStream", "OUTStreamer", "OutStream", "outstream", "inPath", "OUTStream", "outputSteam", "oneStreamer", " outstream", "againstream", "outDirectory", "outStreamer", "againStreamer", "outSteam", "inputSteam", "againSteam", "oneDirectory", "inputStreamer", "oneStream", "instream", "OutSteam", "againStream", "outputStream", " outStreamer", "oneSteam", "outputStreamer", "outPath", "workStreamer", "inStreamer", " outSteam", "inputDirectory", "workStream"]}}
{"id1": "18504192", "id2": "19335986", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", "transferFile", "transferStream", "CopyFile", " copyStream", " copyfile", "Copyfile", "copyStream", "copyfile", "CopyStream", "copyFiles", "CopyFiles"], "in": ["ini", "image", "index", "base", "login", "inner", "inn", "input", "In", "at", "src", "bin", "info", "b", "c", "IN", "buffer", "again", "d", "part", "io", "diff", "min", "ins", "name", "ac", "id", "file", "data", "i", "reader", "old", "or", "m", "inc", "parent", "url", "copy"], "out": ["err", "base", "o", "temp", "prefix", "point", "w", "target", "cache", "output", "OUT", "password", "b", "writer", "conn", "object", "string", "c", "external", "again", "outs", "p", "line", "part", "io", "dest", "Out", "client", "name", "data", "file", "call", "ex", "n", "connection", "inc", "exec", "obj", "copy"], "source": ["origin", "unit", "slave", "service", "SOURCE", "storage", "view", "stream", "Source", "self", "clone", "input", "project", "target", "channel", "src", "slice", "use", "sync", "writer", "scope", "ources", "null", "from", "core", "ie", "settings", "ource", "se", "dest", "client", "secure", "size", "start", "ssl", "proxy", "server", "component", "sl", "reader", "i", "get", "iter", "connection", "sin", "parent", "copy"], "destination": ["continator", "testinations", "destinator", "Destification", "contining", "contination", "Destination", " destinator", "Destinated", "declinated", " destining", "declination", "declification", " destinations", "testinated", "destification", "Destinator", "testinator", "Destinations", "dependification", "Destining", "dependination", "destinated", "destinations", "testination", "continated", "declinator", "dependinator", " destinated", "dependinated", "destining"]}}
{"id1": "1169642", "id2": "15018553", "code1": "    @Override\n    public void run() {\n        String key = getKey();\n        synchronized (this.lauchedHTTPRequests) {\n            if (this.lauchedHTTPRequests.contains(key)) return;\n            this.lauchedHTTPRequests.add(key);\n        }\n        String st = this.dataSource.getTileURL(this.x, this.y, this.z);\n        URL url;\n        try {\n            url = new URL(st);\n        } catch (MalformedURLException e1) {\n            logger.warning(\"Error in URL: \" + st);\n            return;\n        }\n        String geoJSON = \"\";\n        try {\n            InputStream is;\n            if (\"file\".equals(url.getProtocol())) is = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) is = url.openStream(); else {\n                logger.warning(\"Impossible to load settings from \" + url + \". Unsupported protocol \" + url.getProtocol());\n                return;\n            }\n            BufferedReader in = new BufferedReader(new InputStreamReader(is));\n            String line;\n            while ((line = in.readLine()) != null) geoJSON += line;\n            in.close();\n        } catch (FileNotFoundException e) {\n            return;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n        VectorTile tile = new VectorTile(geoJSON, x, y, z);\n        Geometry[] geoms = new Geometry[tile.getPieces().size()];\n        int i = 0;\n        for (MfGeo geo : tile.getPieces()) {\n            if (geo.getGeoType() == GeoType.GEOMETRY) {\n                geoms[i++] = ((MfGeometry) geo).getInternalGeometry();\n            } else if (geo.getGeoType() == GeoType.FEATURE) {\n                MfFeature mf = (MfFeature) geo;\n                geoms[i++] = mf.getMfGeometry().getInternalGeometry();\n            }\n        }\n        GeometryCollection gc = new GeometryFactory().createGeometryCollection(geoms);\n        this.dataSource.getDataLoader().add(new OpenCartoFeature(this.dataSource.getLayer(), new Rep(gc), this.z));\n        this.dataSource.getLayer().getDisplayCacheLoader().coin();\n        synchronized (this.lauchedHTTPRequests) {\n            this.lauchedHTTPRequests.remove(key);\n        }\n    }\n", "code2": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"run": ["register", "submit", "func", "download", "load", "process", " deploy", " work", "update", " runs", "apply", "running", "work", "sleep", "build", "loop", "start", "init", "request", " solve", "call", " evaluate", "get", "Run", "execute", "exec"], "key": ["rule", "link", "fee", "base", "service", "q", "temp", "change", "prefix", "this", "self", "keys", "check", "ry", "KEY", "req", "cache", "pair", "play", "cert", "ke", "use", "connection", "string", "code", "pe", "ace", "k", "work", "ie", "type", "v", "x", "wk", "ce", "y", "secret", "cy", "client", "sign", "name", "request", "my", "id", "e", "lease", "lock", "value", "Key", "source", "parent", "kid", "ee"], "st": ["nd", "fr", "www", "tt", "pt", "stream", "est", "bl", "fe", "ut", "l", "ld", "struct", "ST", "string", "rd", "contract", "sp", "pe", "sn", "sts", "d", "pl", "sc", "stri", "se", "sb", "ste", "sv", "rest", "std", "sd", "start", "ost", "ur", "St", "sr", "ft", "sta", "inst", "u", "sl", "ss", "str", "ist", "sth", "ast", "s"], "url": ["image", "link", "log", "rule", "URL", "base", "resource", "fr", "lr", "feed", "www", "service", "impl", "config", "email", "stream", "event", "ul", "download", "Url", "ls", "http", "use", "l", "api", "bb", "href", "object", "page", "string", "null", "bel", "buffer", "path", "li", "fl", "rel", "uri", "build", "pull", "layer", "blog", "bug", "il", "secure", "ur", "tool", "ssl", "request", "server", "host", "file", "ll", "ob", "gl", "user", "id", "e", "el", "sl", "rl", "iter", "connection", "loc", "source", "web", "f", "address"], "geoJSON": ["geographicURL", "geoPackage", " geoJ", "geometryPackage", "geographicString", " geometryJSON", "geographicJSON", "gameoURL", "geoInfo", "gameoZip", "geoJ", "geometryJSON", "geographicPackage", "cheoURL", "gepoJSON", "gepoInfo", "geyoJSON", " geometryInfo", "gameometryURL", "cheoString", "cheographicString", "cheographicPackage", "geometryString", " geoInfo", "geoaJSON", "geoString", "gameometryJSON", "geyoJ", "geoURL", "cheoPackage", "geoaPackage", "gepoJ", " geometryURL", "geometryZip", " geoURL", "geometryJ", "gepoURL", "geometryURL", "geographicZip", "cheoJSON", " geometryJ", "geoZip", "geyoInfo", "geoaZip", "geoaURL", "gameometryString", "geyoURL", "cheographicJSON", "geometryInfo", "gameoString", "cheographicURL", "gameometryZip", "gameoJSON", "geoaString"], "is": ["ib", "index", "its", "serv", "stream", "isi", "abs", "mis", "ir", "lis", "has", "api", "l", "info", "ui", "IS", "iv", "ri", "r", "ie", "p", "ris", "it", "os", "uri", "x", "ai", "out", "isl", "isa", "iss", "ip", "ins", "il", "as", "iz", "iso", "bis", "us", "id", "isc", "ios", "Is", "im", "get", "ais", "or", "ar", "s"], "in": ["ini", "kin", "err", "getting", "create", "login", "serv", "stream", "inner", "inn", "arin", "download", "with", "input", "open", "In", "inc", "trans", "parse", "load", "reading", "l", "b", "bin", "update", "read", "ri", "pin", "from", "IN", "r", "again", " In", "ic", "finding", "p", "nin", "io", "it", "loading", "x", "min", "by", "out", "ins", "working", "as", "correct", "init", "adding", "h", "on", "data", "rin", "isin", "e", "el", "ex", "reader", "get", "per", "iter", "ar", "din", "f", "lin", "s"], "line": ["look", "link", "letter", "log", "lc", "end", "val", "lf", "cl", "lines", "entry", "inline", "LINE", "up", "parse", "text", "zip", "ne", "Line", "l", "object", "page", "ine", "string", "code", "style", "pe", "r", "pin", "pass", "li", "part", "record", "frame", "row", "number", "le", "block", "character", "me", "name", "ge", "data", "file", "id", "cell", "e", "lo", "char", "str", "sl", "el", "no", "profile", "source", "cr", "lin"], "tile": ["coord", "image", "model", "fo", "ilo", "shape", "stone", "game", "plane", "tle", "match", "fe", "square", "lore", "info", "texture", "fill", "class", "scale", "cf", "pe", "future", "collection", "t", "pole", "type", "xy", "grid", "lat", "flat", "figure", "league", "layer", "pixel", "edge", "size", "pie", "fit", "tool", "crop", "zone", "map", "ge", "server", "artist", "file", "te", "face", "Tile", "e", "feature", "profile", "project", "f", "surface", "cover"], "geoms": ["gelas", "GEometry", "telements", "elas", " geodes", "Geoms", "neomes", "Geomes", "teodes", "gelements", "geomes", "eoms", "nelements", " geomes", "GEoms", "geodes", "eomes", "GEodes", "geometry", "GElements", "teometry", "Geometry", "teoms", "eometry", "Gelas", "neodes", " geometry", "nelas", "neoms", "neometry", "Geodes"], "i": ["z", "j", "index", "o", "hi", "inner", "phi", "ii", "fi", "mini", "slice", "b", "info", "ui", "ri", "pi", "c", "gi", "d", "li", "ci", "p", "shift", "multi", "si", "io", "xi", "bi", "uri", "eni", "x", "ai", "y", "init", "qi", "ti", "id", "e", "limit", "u", "f", "n", "di", "I", "zi"], "geo": ["GEometry", "aleometry", "gaographic", "geographic", "neo", " topom", "seometry", "geou", "teo", "Geolo", "GEo", "gaometry", "GEou", "gepo", "Geom", "gesom", "geon", " geom", "geson", "gao", "aleou", "gebo", " gepo", "gateometry", "seo", "zeou", "neou", " geon", "geom", " geou", "zepo", "seom", "geolo", "geometry", "alebo", "GEbo", "geoco", "teoco", "seoco", "gateo", "seou", "teometry", "Geometry", "gespo", "Geoco", "zeo", "gateographic", "Geographic", "Geo", " geometry", "geso", " topo", "aleo", "sebo", "zeometry", "teom", "neometry", "gaolo", " topon", "nepo", " toppo", "gateolo"], "mf": ["smf", "Mcf", "rtf", " mfi", "smfs", "pc", "imcf", " mfa", "rfs", "smc", "rf", "rc", "Mf", "ptf", " mcf", "Mfa", "pf", "mfa", "Mfi", "smtf", "imfi", "mfi", "mfs", "imf", "mc", "imfa", "mtf", "mcf", "pfs"], "gc": ["ga", " dc", "GC", "cl", "pc", "ls", " cc", "gt", " rc", "gg", "gb", "gi", "gr", "ct", "collection", " GC", " ic", " ac", "cs", "xc", "cc", "gd", "co", "gs", "GB", "bc", " bc", "vg", "gp"]}}
{"id1": "16549995", "id2": "14691829", "code1": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 1, "substitutes": {"mysqlPasswordHash": ["mysqlpasswordHash", "mysqlPasswordPassword", "mysqlSecretPassword", "mysqlSecretPass", "mysSQLPasswordhash", "mysSQLPasswordHash", "mysqlSecretHash", "mysqlHashPassword", "mysSQLpasswordHash", "mysqlPasswordhash", "mysqlHashHash", "mysSQLpasswordhash", "mysqlpasswordhash", "mysqlpasswordPass", "mysqlPasswordPass", "mysSQLPasswordPassword", "mysqlpasswordPassword", "mysSQLpasswordPassword", "mysqlSecrethash", "mysqlHashhash", "mysqlHashPass", "mysSQLpasswordPass", "mysSQLPasswordPass"], "string": ["letter", "in", "service", "script", "section", "prefix", "duration", "input", "version", "text", "message", "slice", "password", "bytes", "object", "array", "null", "driver", "buffer", "pass", "source", "result", "uri", "number", "name", "word", "ring", "data", "file", "username", "str", "value", "sword", "strings", "address"], "digest": [" Digest", "digitest", "Digtest", "mdested", "Digize", " digtest", "heder", "Digusher", "Digoded", "Diger", "dayested", "encoded", "validester", " Digler", "dayer", "DigEST", "digize", "dayester", "encEST", "mdest", "signEST", "mdEST", "dayest", "digester", "digler", "digtest", "digitester", "encested", "validate", "mdoded", "Digester", "hedEST", "digate", "Digested", "diger", " diger", " Digester", "digitate", "hedest", "signer", "encest", "signest", "signester", "digusher", " digusher", "Digler", "validest", "digitize", "digoded", "digEST", " digler", " Diger", "signusher", " digEST", "hedtest", "validize", " digested", "digested", "Digest", "Digate", " digester"], "encodedPassword": ["encodedPass", "Encodedpassword", "encryptedCode", "EncodedPassword", "Encryptedpassword", "encodedCode", "enodedString", "EncryptedPass", "encryptedPass", "EncryptedCode", "enccodedPassword", "enchedCode", "enccodedPass", "enccodedText", "encodingCode", "encryptedpassword", "enccodedString", "encodedpassword", "enccodedpassword", "enchedPassword", "encodedText", "encodingString", "encachedpassword", "encryptedText", "encryptedString", "EncryptedPassword", "encachedString", "EncryptedText", "encodingText", "encodingPass", "encodedString", "EncodedCode", "EncodedPass", "enodedPassword", "enchedpassword", "enodedpassword", "encachedPassword", "EncodedString", "encodingPassword", "encryptedPassword", "enchedString", "EncodedText", "encodingpassword", "EncryptedString"], "hash": ["ver", "sha", "html", "log", "base", "height", "hex", "check", "history", "dig", "match", "square", "version", "alpha", "parse", "always", "cache", "total", "key", "password", "pad", "style", "code", "array", "null", "ashed", "kh", "pass", "shift", "result", "build", "sh", "number", "rh", "sign", "mac", "row", "carry", "block", "ash", "length", "ashes", "Hash", "hed", "sum", "h", "search", "ha", "id", "user", "valid", "char", "value", "error", "tag", "memory", "url"]}}
{"id1": "2642914", "id2": "7458833", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTarGsgz", "addFileToZipGgz", "addFileToZipGzi", "addFileToTarggz", "addFileToZipGzip", "addFileToZipGszi", "addFileToTarGzip", "addFileToTarGszip", "addFileToZipGsz", "addFileToTarGux", "addFileToTarGargz", "addFileToTarGarzip", "addFileToTarGarx", "addFileToTarGarzi", "addFileToTarGsz", "addFileToTarGuz", "addFileToZipGz", "addFileToZipGarx", "addFileToZipGarz", "addFileToTarGarz", "addFileToTargx", "addFileToTargzip", "addFileToTarGuzip", "addFileToTarGgz", "addFileToTarGuzi", "addFileToTargz", "addFileToZipGarzi", "addFileToZipGsgz", "addFileToTarGszi", "addFileToTargzi", "addFileToZipGarzip", "addFileToZipGszip", "addFileToTarGzi", "addFileToZipGx", "addFileToTarGx"], "taro": ["tara", "atro", "Taron", "thaco", "faco", " taco", "Tabo", "toro", "staro", " tero", " tara", "Toro", "fargo", "ptargo", "targo", "taco", "ptabo", "ptaro", "Taro", "Taco", " targo", " taron", "too", "Toran", "stamar", "Tro", "storo", "toran", "loran", "lro", "tero", "stero", "tabo", " tabo", "ptaron", "faro", " too", "Tara", "tharo", "ataro", "Tamar", "atoran", "tamar", "taron", "Targo", "laro", "Tero", "thamar", "Too", "atargo", "thoro", "stoo", "tro", "staco", "largo", "stro", " tro", "ptaco", "fara"], "path": ["image", "folder", "log", "resource", "Path", "root", "pattern", "ref", "text", "cache", "filename", "key", "object", "string", "PATH", "c", "from", "route", "p", "type", "source", "pointer", "uri", "ath", "dir", "name", "id", "file", "fn", "data", "str", "loc", "location", "parent", "url", "directory"], "base": ["index", "resource", "site", "prefix", "root", "default", "pre", "ase", "http", "cache", "bas", "back", "key", "area", "api", "b", "extra", "home", "string", "from", "store", "buffer", "core", "Base", "p", "type", "part", "uri", "dir", "start", "name", "server", "id", "file", "absolute", "bf", "relative", "parent", "url", "address"], "f": ["fo", "j", "fr", "feed", "of", "fac", "this", "fa", "self", "found", "form", "lf", "w", "inf", "F", "fen", "fe", "aff", "ref", "fc", "l", "b", "raf", "cf", "c", "r", "rf", "g", "t", "fd", "d", "fb", "p", "v", "df", "flat", "fp", "fs", "fx", "framework", "tf", "h", "fold", "file", "fn", "af", "e", "sf", "i", "n", "bf", "m", "url", "s"], "entryName": ["elementTime", "entryname", "archiveName", "fileName", " entryname", "EntryName", "fileType", "filePath", "fileTime", "elementName", "entryPath", "resourcePath", "entryType", " entryPath", "elementPath", "entryTime", "archiveSize", "EntryType", "entrySize", " entryTime", "elementType", "resourceName", "resourceSize", " entryType", "EntryPath", "archivename", "EntryTime", "archivePath", " entrySize", "resourcename"], "goIn": ["loIns", "GOIns", "goIN", "GOOut", "coIn", "coIns", "GOIn", "GOin", "loIN", "GoIn", "poIn", "gain", "poin", "loIn", "goIns", "coin", "GOIN", "gaIn", "poIN", "Goin", "poIns", "coOut", "gaIN", "loin", "gaIns", "goOut", "GoIN", "GoIns", "poOut", "goin"], "tarEntry": ["tarFile", "rarInfo", "zipInfo", " Tarentry", "zipEnt", "TarElement", " tarentry", " tarEnt", "Tarentry", "rarEntry", " tarFile", "TarEntry", "rarFile", "tarentry", "zipEntry", " TarEntry", "tarInfo", "zipFile", " tarInfo", " tarElement", " TarElement", "rarEnt", "tarElement", "tarEnt"], "children": ["iblings", "ports", "pool", "sub", "other", "packages", "feed", "current", "content", "ul", "open", "plugins", "which", "output", "blocks", "roots", "bars", "when", "files", "ools", "rows", "far", "ales", "parents", "ren", "jobs", "all", "well", "values", "opens", "ins", "members", "Children", "many", "name", "each", "pes", "h", "pages", "father", "data", "scenes", "balls", "web", "kids", "words", "loc", "parent"], "child": ["slave", "pool", "in", "feed", "root", "entry", "kid", "channel", "count", "key", "hel", "l", "ch", "shell", "page", "leaf", "code", "c", "lib", "cel", "Child", "cloud", "job", "build", "and", "row", "pull", "layer", "client", "name", "server", "data", "file", "id", "comment", "i", "per", "or", "connection", "parent", "draft"]}}
{"id1": "12055086", "id2": "18748516", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copydeleing", " copyDeletting", " copyDequeing", " copydeletting", " copyDequeging", " copydeletging", " copyDeleteing", " copyDeleteter", " copyDeletging", " copyDeleing", " copyDeleging", " copydeleging", " copyDequeting", " copydeletter", " copyDeleteting", " copyDequeter", " copyDeleter", " copyDeletter", " copydeleting", " copyDeleteging", " copydeleter"], "source": ["image", "base", "resource", "SOURCE", "service", "site", "storage", "view", "stream", "Source", "inner", "input", "target", "master", "src", "cache", "use", "remote", "ources", "from", "route", "path", "ie", "ource", "sin", "archive", "file", "down", "e", "reader", "i", "iter", "connection", "config", "f", "copy", "s"], "dest": ["folder", "de", "wb", "die", " destination", "slave", "temp", "done", "content", "trans", "target", "master", "src", "slice", "later", "bin", "destruct", "comb", "home", "null", "class", "orig", "exit", "dist", "path", "result", "opt", "flat", "img", "dir", "tmp", "Dest", "thin", "file", "desc", "pipe", "default", "destroy"], "buf": ["base", "cmd", "raw", "br", "feed", "vec", "config", "ff", "feat", "src", "queue", "bag", "uf", "b", "cb", "bh", "bytes", "pad", "bp", "txt", "code", "pos", "buff", "buffer", "rc", "fb", "bf", "bd", "result", "len", "img", "length", "off", "tmp", "cp", "data", "cv", "port", "rb", "uc", "seq", "batch", "loc", "ctx", "Buffer", "bc", "append"], "in": ["ini", "image", "login", "stream", "gin", "inn", "inner", "input", "din", "In", "up", "src", "bin", "b", "conn", "read", "c", "pin", "IN", "again", "tin", "plus", "p", "nin", "io", "sin", "min", "ins", "is", "socket", "init", "inside", "thin", "con", "rin", "isin", "data", "id", "file", "i", "win", "reader", "n", "exec", "f", "url", "inc"], "out": ["err", "image", "pool", "o", "outer", "inner", "w", "at", "up", "exp", "sync", "output", "OUT", "bin", "conn", "writer", "b", "buffer", "again", "outs", "part", "io", "img", "Out", "client", "app", "socket", "ext", "file", "down", "parent", "ex", "i", "win", "n", "lib", "exec", "f", "obj", "inc"], "count": ["num", "index", "base", "pool", "child", "feed", "depth", "offset", "coll", "current", "val", "zip", "cache", "key", "use", "b", "ch", "read", "code", "c", "buffer", "path", "ind", "type", "part", "allow", "len", "all", "number", "handle", "length", "close", "start", "size", "name", "sum", "id", "weight", "limit", "cond", "lock", "Count", "n", "parent", "f", "max"]}}
{"id1": "19687456", "id2": "4461350", "code1": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 0, "substitutes": {"testReadPerMemberSixSmall": [" testReadPerMemberFourSquare", " testReadPermembersixSquare", " testReadPerMembersixSmall", " testReadPerMembersixSquare", " testReadPermembersixSmall", " testReadPerMemberSixsmall", " testReadPerMembersixsmall", " testReadPermemberSixsmall", " testReadPermembersixsmall", " testReadPermemberSixSquare", " testReadPermemberSixSmall", " testReadPerMemberFourSmall", " testReadPerMemberSixSquare", " testReadPerMemberFoursmall"], "gzin": ["sslinn", "gcout", "wxout", "zzini", "zlIn", "gzini", "qqins", "syncout", "zlinn", "zini", "zIN", "gzwith", "gzIN", "gcIN", "zznin", "zdin", "cfgin", "zzinas", "qqIn", "sslIN", "zigwith", "wxarin", "zlin", "eznin", "zzinn", "zout", "gzout", "syncdin", "wxIN", "zzIN", "zigin", "cigarin", "ziparin", "zigdin", "znin", "qqin", "cginin", "zlwith", "zigIn", "zipin", "qqIN", "gzinn", "gznin", "gcin", "ziginn", "gzarin", "zzin", "zigIN", "cfginn", "syncin", "cfgwith", "cigIN", "gcIn", "gzIn", "ezIN", "cgiin", "zins", "zzout", "gtout", "cgiinas", "cigout", "ezin", "qqout", "gtnin", "zipIN", "cigin", "sslin", "cgiIN", "ezinas", "qqdin", "zin", "zzdin", "cfgIn", "wxin", "gtin", "gtini", "zipout", "gzins", "ssldin", "syncins", "gzinas", "gzdin", "zIn"], "i": ["j", "index", "o", "chi", "oi", "hi", "phi", "ii", "mini", "fi", "count", "mu", "api", "b", "info", "ui", "pi", "c", "gi", "d", "li", "ci", "p", "ie", "multi", "si", "ni", "xi", "I", "bi", "v", "uri", "ai", "io", "ji", "ip", "h", "ti", "e", "iu", "u", "n", "di", "m", "f", "zi"], "count2": ["count1", "Count02", "name1", "Count1", "count5", "sum1", "CountTwo", "name02", " countTwo", " count5", "countTwo", "sum2", "name2", "Count2", "count02", "Count5", " count4", "sumTwo", " count02", "name5", "sum4", " count1", "count4", "Count4"], "count3": ["count1", "count5", "sum1", "size83", "sum3", "count83", "cache83", "cache2", "size2", "count303", "cache3", "err3", " count5", "err1", " count303", "err15", "err5", "size3", " count83", "count15", "sum15", "cache303", " count15", "sum5", "size303", " count1"], "countEnd": ["refStart", "lenBegin", " countend", "CountEND", "refEND", "lenEnd", "sizeEND", "lenend", "CountEnd", "sizeEnd", "lenEND", "countEND", "countend", " countBegin", "refEnd", "refend", "sizeStart", "Countend", "CountStart", "countBegin", "sizeend", "CountBegin", "countStart", " countEND"]}}
{"id1": "1954410", "id2": "822452", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"doExecute": ["submitexecuteRun", "doExecRun", "submitexecuteute", "doSendApply", "submitexecuteutes", "doSendute", "doExecutes", "submitExecute", "doexecuteRun", "submitExecRun", "doexecuteutes", "doexecuteApply", "doExecApply", "submitexecuteApply", "doSendutes", "doexecuteute", "doSendRun", "submitExecApply", "submitExecutes"], "mapping": ["finding", "minding", "amapping", "fapper", "mapper", " mapper", "amatching", "fapping", "matching", "amapper", "aminding", " matching", " minding", "fatching"], "form": ["flow", "method", "field", "Form", "formation", "feed", "submit", "config", "forms", "format", "transform", "pattern", "post", "object", "page", "builder", "definition", "dom", "control", "command", "xml", "app", "component", "FORM", " forms", "template", "url", "owner"], "request": ["re", "_", "method", "model", "resource", "q", "create", "ware", "submit", "this", "view", "self", "current", "format", "Response", "input", "json", "worker", "req", "message", "add", "queue", "use", "Reply", "object", "QUEST", "Bytes", "application", "Accept", "session", "route", "path", "query", "Request", "hello", "type", "result", "uri", "frame", "pull", "client", "context", "xml", "Upload", "report", "name", "server", "user", "data", "HTTP", "parent", "call", "instance", "s", "reader", "complete", "requ", "url", "address"], "response": ["model", "resource", "view", "Response", "json", "req", "message", "output", "object", "page", "application", "status", "resp", "handler", " responses", "result", "v", "client", "Resp", "xml", "report", "server", "data", " Response", "res", "reply"], "errors": [" calls", " logger", " management", " managers", " changes", " events", " replies", " Messages", " logs", " mess", " streams", " commands", " session", " this", " messaging", "mess", " responses", " payload", " failures", " messenger", " messages", " error", " translations", " status", " flashes", " problems", " updates", " acc", " warnings"], "isMultipart": ["isMultipost", "isMultippart", "isMultiipPart", "isMultippedart", "isMultIPound", "isMultitart", "isMultipated", "isMultitarts", "isMultiarts", "isMultitated", "isMultiIPound", "isMultiIPart", "isMultipound", "isMultiated", "isMultiipart", "isMultipage", "isMultIPart", "isMultiage", "isMultIPost", "isMultompPart", "isMultippedPart", "isMultippedost", "isMultippedound", "isMultIPPart", "isMultiparts", "isMultompound", "isMultitage", "isMultiipound", "isMultippage", "isMultompost", "isMultompart", "isMultipparts", "isMultiIPost", "isMultipPart", "isMultiipost", "isMultiIPPart", "isMultiart", "isMultippated"], "mailInstance": [" emailinstance", "mailManager", "fileManager", " emailInst", " emailInstance", "fileUsage", "mailUsage", "emailInst", " mailManager", "mailinstance", "emailinstance", " mailUsage", " mailinstance", "fileInstance", "fileInst", "emailManager", " mailInst", "mailInst", "emailInstance", " emailUsage", "fileinstance"], "fields": ["archives", "gets", "boxes", "field", "comments", "objects", "posts", "keys", "forms", "types", "locks", "changes", "utils", "input", "flows", "lines", "plugins", "links", "services", "maps", "details", "ments", "packs", "rules", "ids", "properties", "events", "views", "facts", "files", "uploads", "params", "groups", "headers", "rows", "atts", "lists", "cells", "acks", "holders", "checks", "tags", "states", "qs", "users", "members", "models", "features", "pages", "data", "forces", "classes", "loads", "words", "strings", "dates", "parts", "s"], "attachments": ["attachions", "attlements", " attachparts", "suppment", "extions", "exters", "supplements", "achresses", "attment", "attachers", "payresses", "Attachments", "attachps", "payment", " attachment", "attachparts", "payments", "achments", "suppments", "Attachlements", "attachlements", "payparts", "achparts", "attees", "suppees", "Attachps", "attions", "attachment", "extps", "attachresses", "attments", "atters", "achment", "Attachers", "attps", "Attachment", " attachresses", "attachees", "Attachions", "Attachees", "extments"], "items": ["its", "objects", "keys", "types", "locks", "phones", "ops", "children", "lines", "plugins", "links", "orders", "ids", "list", "events", "files", "apps", "groups", "rows", "Items", "lists", "apters", "qs", "ins", "reports", "models", "es", "alls", "ips", "pages", "data", "names", "results", "parts", "ers"], "iter": ["err", "ver", "outer", "end", "walker", "inner", "event", "coll", "ul", "order", "skip", "inter", "edit", "gener", "exp", "zip", "master", "ir", "http", "slice", "list", "finder", "page", "Iter", "li", "er", "itter", "izer", "it", "oper", "loop", "altern", "ip", "ner", "ite", "chain", "cher", "keep", "ter", "former", "file", "ser", "iterator", "el", "Iterator", "ator", "reader", "enter", "i", "loc", "inc", "upper"], "item": ["resource", "temp", "storage", "current", "full", "page", "hop", "element", "next", "result", "it", "layer", "name", "volume", "file", "source", "folder", "service", "slice", "api", "info", "example", "album", "token", "handler", "original", "Item", "issue", "all", "ip", "app", "server", "user", "instance", "reader", "get", "plugin", "base", "other", "inner", "event", "entry", "post", "object", "extra", "update", "atom", "custom", "er", "type", "attribute", "container", "entity", "data", "or", "anything", "obj", "image", "index", "section", "site", "coll", "val", "art", "order", "up", "load", "widget", "area", "more", "li", "missing", "i", "complete", "url"], "aux": ["aw", "lc", "ou", "des", "sub", "packages", "prefix", "aus", "ants", "offs", "abs", "alias", "except", " Aux", "anc", "aff", "ox", "axe", "uf", "extra", "sup", "array", "buf", "amp", "au", " auxiliary", "lang", "cmp", "ras", "etc", "cas", "off", "ups", "ext", "auc", "asc", "union", "data", "ux", "af", "abc", "pkg", "strings", "fax", "uc", "frac", "ru", "aos", "imp"], "part": ["action", "html", "field", "base", "plugin", "section", "change", "point", "step", "val", "po", "format", "pre", "art", "patch", "player", "obj", "group", "ref", "add", "back", "pair", "key", "area", "l", "ch", "b", "full", "object", "list", "info", "fact", "class", "pos", "act", "element", "pi", "join", "p", "type", "and", "diff", "comp", "layer", "block", "start", "but", "name", "joined", "partial", "co", "PART", "word", "component", "data", "user", "file", "on", "id", "instance", "Part", "f", "error", "per", "one", "no", "connection", "parent", " Part", "parts"], "baos": ["abaOs", "baOS", "baoss", " baOS", "BAoss", "bois", "bao", "bais", "boosh", "Bao", "BAos", "BAis", " baoS", "pao", "BAosh", "baot", "boOS", "hao", "BaOs", "Baos", "baosh", " baot", "haos", " bao", "abais", "Bais", "abaosi", "boot", "paos", "paosh", "BAoS", "BAOs", "boos", " bais", "baoS", "BAo", "BaoS", "baOs", "boo", "Baosi", "BAosi", "pais", "paot", "hais", "abaos", " baoss", "haoss", "paOS", "baosi"], "body": ["fee", "html", "resource", "options", "end", "Body", "content", "common", "json", "text", "message", "zip", "output", "shell", "b", "media", "full", "object", "string", "null", "summary", "flash", "params", "headers", "state", "pass", "query", "translation", "type", "parts", "length", "size", "name", "tree", "data", "document", "binary", "port", "description", "comment", "value", "connection", "template", "source", "reply", "url", "header"], "preferencesInstance": ["prefirmsClient", "prefiesInstance", "preffeesinstance", "prefferencesinstance", "prefirmsinstance", "preffeesClient", "prefferencesInstance", "prefiesinstance", "prefiesClient", "prefeesClient", "preffeesInstance", "preferencesinstance", "prefeesInstance", "preferencesClient", "prefirmsInstance", "prefferencesClient", "prefeesinstance"]}}
{"id1": "5951610", "id2": "10728243", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"testNetworkHTTP": ["testNETSSL", " testNetworkHTML", " testNetworkHttp", "testnetworkSSL", "testNetworkHTML", "testInternetSSL", " testNetworkSSL", " testInternetHTML", "testnetworkHTML", "testNETHTTP", "testInternetHTML", "testInternetHttp", " testInternetSSL", " testInternetHTTP", "testNETHTML", "testNetworkSSL", "testnetworkHTTP", "testnetworkHttp", "testNetworkHttp", " testInternetHttp", "testInternetHTTP", "testNETHttp"], "url": ["URL", "resource", "lr", "www", "impl", "ls", "channel", "group", "page", "job", "control", "layer", "ur", "file", "ll", "call", "el", "lib", "connection", "host", "lc", "log", "service", "cl", "output", "github", "r", "ml", "build", "pull", "il", "loader", "tool", "server", "user", "rl", "dl", "loc", "base", "email", "event", "bl", "entry", "text", "use", "l", "shell", "update", "left", "hl", "path", "large", "blog", "util", "ssl", "ol", "rel", "location", "web", "image", "mail", "feed", "nl", "view", "coll", "ul", "Url", "http", "load", "key", "buffer", "cloud", "pl", "fl", "org", "uri", "gl", "ob", "sl", "bf", "config"], "urlConnection": ["URLConnect", "urConnection", "urlReference", "implReference", "sslUnit", "viewconnection", "httpFactory", "emailconnection", " urlContainer", "uriUnit", "urlFactory", "urlConstruction", "uriComputer", "emailConstruction", "urlConn", " urlPool", "webconnection", "lConnect", " urlconnection", "flconnection", "htmlConstruction", "sslConnector", "termConnection", "UrlContainer", "serviceConn", "numberconnection", "numberConnector", "viewConstruction", "urlComputer", "URLConn", "flConstruction", "glConn", "webConnection", "numberConnect", "glConnect", "lConn", " urlEnvironment", "ulUnit", "serviceConnect", "flConnection", "UrlFunction", " urlUnit", "urlconnection", "httpFunction", "httpComputer", "resourceGate", "implEnvironment", "urFactory", "urlGate", "blogconnection", "uriFunction", "termComputer", "urlContainer", "lengthConnection", "emailClient", " urlReference", "UrlConnection", "numberConnection", "ulConnector", "viewConnect", "UrlConnect", "urlEnvironment", "sslConn", "urConn", "termConn", " urlFactory", "blogConnection", "serviceConnection", "emailConnect", "urFunction", "uriConnection", "emailConnection", "UrlReference", "urlFunction", "urlConnector", "urlClient", "blogConnector", "UrlConn", "implConnection", "lConnection", "lengthConnect", "urlConnect", "htmlConnection", "UrlEnvironment", "lengthconnection", " urlComputer", "webPool", "urlUnit", "emailGate", "lengthConstruction", "glConnection", "resourceClient", "lconnection", "ulConn", " urlClient", "URLConnection", "resourceConnection", "httpConnection", "flConnect", "resourceconnection", "htmlconnection", " urlGate", "glFunction", " urlConnector", "URLPool", "URLconnection", "blogConnect", "UrlComputer", "viewConnection", "flConnector", "urlPool", " urlConn", "httpConn", " urlFunction", " urlConnect", "httpUnit", "termContainer", "sslConnection", "ulConnection", "serviceconnection"], "rd": ["dd", "td", "nd", "dr", "lr", "fr", "rx", " reader", "nor", "rowd", "nl", "dig", "lf", "bl", "arr", "rid", "DR", "xd", "rt", "RD", "RR", "adr", "ld", "ird", "wd", "RW", "respond", "rod", "vd", "rg", "usr", "rf", "r", "RL", "RF", "fd", "wr", "tr", "d", "rob", "bd", "erd", "ds", "rand", "bf", "red", "rr", "addr", "rh", "director", "dj", "gd", "std", "own", "rs", "hr", "rown", "sr", "R", "lt", "dh", "pd", "rn", "sth", "Reader", "reader", "rb", "rw", "rl", "ng", "ru", "rss", "db", "dra"], "line": ["lc", "link", "log", "letter", "unit", "login", "end", "nl", "val", "lf", "cl", "write", "lines", "entry", "inline", "skip", "LINE", "day", "ne", "Line", "key", "l", "ld", "page", "string", "code", "status", "pass", "d", "li", "part", "len", "frame", "row", "response", "number", "le", "block", "name", "la", "col", "word", "sel", "ge", "msg", "data", "id", "lo", "cell", "user", "limit", "file", "el", "sl", "rl", "error", "comment", "loc", "source", "lin"]}}
{"id1": "6304373", "id2": "20024612", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    private void parse() throws Exception {\n        BufferedReader br = null;\n        InputStream httpStream = null;\n        URL fileURL = new URL(url);\n        URLConnection urlConnection = fileURL.openConnection();\n        httpStream = urlConnection.getInputStream();\n        br = new BufferedReader(new InputStreamReader(httpStream, \"UTF-8\"));\n        String ligne;\n        String post;\n        String date;\n        String titre;\n        String resume;\n        String url2DL;\n        while ((ligne = br.readLine()) != null) {\n            if (ligne.indexOf(\"div class=\\\"post\\\" id=\\\"post\") != -1) {\n                post = null;\n                date = null;\n                titre = null;\n                try {\n                    post = ligne.substring(ligne.indexOf(\"post-\") + 5, ligne.indexOf(\"\\\"\", ligne.indexOf(\"post-\")));\n                    ligne = br.readLine();\n                    date = ligne.substring(ligne.indexOf(\"<div class=\\\"date\\\"><span>\") + 24);\n                    date = date.replaceAll(\"</span>\", \"\").replaceAll(\"</div>\", \"\").trim();\n                    log.info(\"Post   : \" + post + \" du \" + date);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    titre = ligne.substring(ligne.indexOf(\">\", ligne.indexOf(\"title\")) + 1, ligne.indexOf(\"</a>\"));\n                    titre = titre.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    url2DL = ligne.substring(ligne.indexOf(\"<a href=\\\"\") + 9, ligne.indexOf(\"/\\\"\")).trim();\n                    url2DL = url2DL.replace(\"mega-films.net\", \"mega-protect.com\") + \".php\";\n                    log.info(\"Titre  : \" + titre);\n                    log.info(\"To DL  : \" + url2DL);\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    ligne = br.readLine();\n                    resume = ligne.substring(ligne.indexOf(\"<em>\") + 4, ligne.indexOf(\"</em>\"));\n                    resume = resume.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\");\n                    log.info(\"Resume : \" + resume);\n                } catch (Exception e) {\n                    log.error(\"ERREUR : Le film n'a pas pu etre parse...\");\n                }\n                log.info(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\");\n            }\n        }\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaOrTemplatepl", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrtemFiles", "uploadOrDeleteMediaOrMemplates", "uploadOrDeleteMediaOrTemplateFiles", "uploadOrDeleteMediaOrTemFiles", "uploadOrDeleteMediaOrMemFiles", "uploadOrDeleteMediaOrtempl", "uploadOrDeleteMediaOrMemporary", "uploadOrDeleteMediaOrMempl", "uploadOrDeleteMediaOrtemporary", "uploadOrDeleteMediaOrTemplateplates", "uploadOrDeleteMediaOrTemplateporary", "uploadOrDeleteMediaOrTemporary", "uploadOrDeleteMediaOrtemplates"], "action": ["flow", "method", "service", "resource", "module", "section", "change", "site", "view", "event", "step", "format", "effect", "function", "active", "version", "ction", "api", "environment", "now", "style", "status", "element", "act", "flash", "state", "item", "next", "type", "activation", "part", "actions", "commit", "controller", "Action", "name", "test", "operation", "ACTION", "call", "lock", "error", "activity", "what", "parent", "plugin", "url"], "object": ["image", "letter", "model", "o", "resource", "email", "system", "module", "objects", "office", "service", "directory", "current", "event", "self", "function", "none", "target", "obj", "edit", "version", "mode", "group", "environment", "now", "full", "auto", "string", "element", "class", "subject", "not", "node", "ject", "part", "oid", "number", "article", "zone", "request", "document", "parent", "lock", "instance", "thread", "host", "project", "url", "address"], "numElements": [" numElem", " numelement", " numelements", "numElodes", " numEodes", " numeodes", "numeodes", "numGelem", "numGeodes", "numEodes", "numelement", "numEllements", "numEllem", "numEllement", " numelem", "numelements", "numGelement", "numGelements", "numElem", "numelem"], "req": ["err", "log", "html", "base", "module", "load", "use", "update", "builder", "usr", "r", "params", "g", "resp", "gr", "ro", "next", "mr", "util", "xml", "report", "verb", "res", "ctx", "msg", "parent", "conf", "obj"], "session": ["image", "ESSION", "service", "resource", "temp", "system", "site", "event", "global", "sa", "http", "cache", "local", "use", "scope", "sp", "flash", "state", "subject", "token", "result", "container", "ession", "response", "client", "context", "manager", "Session", "test", "request", "h", "document", "instance", "security", "browser", "thread", "person", "lock", "shared", "ctx", "connection"], "ftp": ["ftP", "ftc", "FTp", "ttp", "ttcp", " ftcp", "FTc", "FTP", "ttc", " ftP", "FTcp", "ttP", "ftcp", " ftc"], "user": ["rule", "image", "log", "ver", "base", "html", "mail", "module", "other", "system", "account", "this", "view", "self", "current", "project", "usa", "match", "profile", "facebook", "group", "use", "User", "info", "full", "member", "page", "home", "string", "hash", "class", "usr", "post", "admin", "pass", "creator", "custom", "path", "state", "db", "er", "author", "type", "result", "record", "used", "by", "client", "bug", "users", "auth", "name", "data", "e", "username", "parent", "person", "lock", "browser", "error", "per", "shared", "comment", "connection", "config", "USER", "url", "ee"], "links": ["link", "linked", "log", "html", "base", "mail", "image", "email", "Link", "posts", "lines", "details", "ids", "styles", "url", "mails", "flash", "headers", "groups", "images", "Links", "actions", "items", "members", "tree", "pages", "results", "menu"], "folders": ["anchors", "filries", "anchries", "handers", "foldages", "foldries", "handors", "anchages", "handages", "filors", "anchers", "handries", "filages", "foldors", "filers"], "folder": ["letter", "email", "resource", "directory", "sample", "Folder", "ignore", "picture", "menu", "license", "zip", "filename", "slice", "area", "device", "scope", "home", "element", "future", "path", "two", "source", "division", "upload", "uri", "flat", "network", "layer", "command", "dir", "region", "editor", "zone", "volume", "archive", "fold", "id", "layout", "document", "level", "append", "database", "theme", "enter", "connection", "location", "project", "plugin", "url", "address"], "server": ["erver", "slave", "service", "resource", "email", "localhost", "outer", "site", "account", "system", "address", "inner", "version", "master", "filename", "remote", "device", "page", "string", "status", "engine", "scale", "token", "node", "type", "uri", "network", "Server", "client", "manager", "socket", "location", "ssl", "peer", "host", "seed", "port", "username", "ser", "value", "database", "reader", "enter", "connection", "source", "url", "directory"], "login": ["log", "mail", "service", "email", "resource", "account", "site", "picture", "profile", "consumer", "group", "blank", "journal", "filename", "bridge", "shell", "info", "label", "status", "string", "pin", "pass", "access", "path", "Login", "network", "blog", "secret", "users", "cookie", "auth", "name", "socket", "ssl", "layout", "skin", "basic", "username", "lock", "database", "connection", "config", "sudo", "plugin", "url", "machine"], "password": ["Password", "slave", "email", "mask", "account", "alias", " passwords", "pattern", "picture", "worker", "filename", "column", "device", "string", "pass", "access", "token", "padding", "strip", "division", "phrase", "secret", "cookie", "manager", "auth", "photo", "name", "PASS", "word", "volume", "language", "ass", "basic", "username", "security", "sword", "database", "timeout", "connection", "profile", "sudo", "plugin", "directory"], "fileTransferFolder": ["fileImportDirectory", "fileAccessFolder", "fileTransformTheme", "mediaTransferfolder", "FileTransferTheme", "fileUploadPath", "fileTransformfolder", "fileTransferDirectory", "fileUploadDirectory", "FileTransferPath", "fileAccessPath", "fileTransferServer", "FileUploadfolder", "mediaTransferDirectory", "fileAccessTheme", "fileUploadfolder", "fileTransformFolder", "fileTransferPath", "mediaTransferFolder", "fileImportServer", "FileTransferFolder", "fileTransferTheme", "fileTransformPath", "fileAccessfolder", "fileTransferfolder", "fileImportFolder", "fileUploadServer", "FileUploadTheme", "FileUploadPath", "mediaUploadFolder", "mediaUploadServer", "fileUploadTheme", "mediaUploadfolder", "fileUploadFolder", "fileImportfolder", "mediaUploadDirectory", "FileTransferfolder", "mediaTransferServer", "FileUploadFolder"], "liveFolder": ["Livefolder", " liveDirectory", "liveDirectory", "PreviewLocation", " livefolder", "PreviewFolder", "LiveFolder", "livefolder", "LiveLocation", "PreviewDirectory", " liveLocation", "Previewfolder", "liveLocation", "LiveDirectory"], "servers": ["servvers", "servls", "Serls", " serations", "serServer", "Servers", "Serations", " serls", "SerServer", "serations", "serls", "servServer", "servations", " serServer"], "message": ["body", "image", "log", "mail", "resource", "email", "module", "content", "menu", "details", "member", "update", "page", "status", "application", "summary", "string", "element", "flash", "array", "buffer", "path", "mess", " messages", "response", "manager", "Message", "request", "document", "error", "description", "msg", "url", "header", "address"]}}
{"id1": "10281203", "id2": "20735941", "code1": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"makeRead": [" manageWrite", " manageREAD", "doSet", " manageRead", " executeRead", "doRead", " manageSet", " makeREAD", "doREAD", " executeWrite", " makeWrite", " makeSet", " executeREAD", "doWrite", " executeSet"], "user": ["log", "field", "site", "alias", "write", "human", "nick", "use", "User", "password", "post", "uid", "url", "string", "home", "usr", "creator", "admin", "custom", "pid", "author", "job", "month", "record", "row", "blog", "bug", "users", "name", "word", "server", "username", "comment", "date", "pod", "host", "USER", "install", "owner"], "databaseID": ["connectionIDs", "connectionName", " databaseIDs", "databaseIDS", "DatabaseId", "collectionName", " databaseId", "dbIDs", "databaseName", "DatabaseIDS", "DatabaseID", "dbID", "collectionIDS", "collectionID", "dbName", " databaseIDS", "collectionId", "databaseIDs", "DatabaseName", "databaseId", " databaseName", "connectionID"], "time": ["Time", "end", "duration", "mode", "times", "key", "rate", "table", "post", "home", "string", "read", "clock", "set", "tz", "TIME", "month", "type", "year", "sleep", "counter", "ip", "length", "size", "start", "name", "ime", "tim", "id", "port", "money", "value", "comment", "etime", "date", "timer", "timeout", "delay", "host"], "query": ["rule", "eries", "cmd", "answer", "q", "Query", "question", "script", "function", "scan", "json", "message", "conn", "post", "connection", "update", "string", "code", "sql", "condition", "params", "work", "join", "result", "ql", "uri", "commit", "command", "sq", "report", "name", "request", "search", "execute", "call", "general", "comment", "error", "database", "select"], "statement": ["rule", "unit", "slave", "script", "section", "agent", "storage", "alias", "Statement", "function", "usage", "ma", "study", "message", "parser", "use", "password", "media", "conn", "table", "style", "status", "sql", "condition", "session", "state", "relation", "st", "join", "note", "part", "stat", "si", "result", "commit", "mt", "response", "command", "start", "expression", "joined", "volume", "language", "server", "jo", "document", "inst", "general", "instance", "comment", "str", "database", "i", "di", "connection", "execute", "db", "s"], "count": ["err", "force", "index", "base", "child", "depth", "offset", "found", "expected", "find", "age", "cache", "process", "total", "key", "table", "list", "code", "set", "c", "state", "part", "type", "diff", "number", "by", "handle", "length", "start", "size", "sum", "id", "limit", "cond", "error", "i", "Count", "get", "batch", "inc"]}}
{"id1": "5125848", "id2": "16969205", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    private List<JarFile> webArchives(ServletContext servletContext) throws IOException {\n        List<JarFile> list = new ArrayList<JarFile>();\n        Set<Object> paths = servletContext.getResourcePaths(WEB_LIB_PREFIX);\n        for (Object pathObject : paths) {\n            String path = (String) pathObject;\n            if (!path.endsWith(\".jar\")) {\n                continue;\n            }\n            URL url = servletContext.getResource(path);\n            String jarURLString = \"jar:\" + url.toString() + \"!/\";\n            url = new URL(jarURLString);\n            JarFile jarFile = ((JarURLConnection) url.openConnection()).getJarFile();\n            JarEntry signal = jarFile.getJarEntry(FACES_CONFIG_IMPLICIT);\n            if (signal == null) {\n                if (log().isTraceEnabled()) {\n                    log().trace(\"Skip JAR file \" + path + \" because it has no META-INF/faces-config.xml resource\");\n                }\n                continue;\n            }\n            list.add(jarFile);\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"combineJs": ["combinedjs", "CombineScript", "CombinateJs", "combinjs", "combinedJS", "CombinateScript", "combinedJs", "Combinatejs", "CombineJS", "combinateJs", "Combinejs", "CombineJs", "combinJS", "combinateJS", "combinateScript", "CombinateJS", "combinatejs", "combinScript", "combineJS", "combinJs", "combinejs", "combinedScript", "combineScript"], "base": ["image", "log", "resource", "site", "prefix", "root", "bot", "relative", "ref", "http", "cache", "bas", "area", "api", "b", "info", "page", "home", "builder", "string", "store", "based", "Base", "part", "uri", "build", "out", "proxy", "server", "data", "file", "absolute", "config", "source", "db", "f", "address"], "linkJs": [" linkScript", "likeJs", "linkedJs", " linkLinks", "linkLinks", " linkJS", " linkjs", "loadJS", "likeJS", "linkedjs", "loadScript", "loadjs", "likejs", "linkedScript", "linkjs", "linkedLinks", "linkJS", "linkScript", "loadJs", "likeLinks", "linkedJS"], "newFiles": [" newLinks", "newResources", "addFiles", "newLinks", "addLinks", " newfiles", "oldResources", "oldLinks", "newfiles", "addResources", "oldfiles", " newResources", "addfiles", "oldFiles"], "dir": ["folder", "log", "plugin", " dep", "in", "module", "DIR", " module", " manager", " Dir", "root", "direction", " d", "download", "domain", "or", " director", "zip", "ir", "cache", "local", " download", "http", "src", "b", "wd", "object", "home", " block", "dist", "session", "d", "work", " folder", "source", "div", "container", "uri", "build", "out", "Dir", " db", " repo", "editor", "manager", " directory", "keep", "dep", "id", "file", "lock", "lib", "loc", "relative", "db", "md", "directory"], "name": [" bundle", " module", " dest", " manager", " info", " init", " abs", " suffix", " source", " id", " zip", " relative", " prefix", " parent", " app", " folder", " root", "Dir", " repo", " title", " cache", " head", " resource", " build"], "minDir": ["MinJar", "miniDir", "MinDest", "minManager", "versionDir", " minDest", "minDriver", "initDirectory", " minDb", "tempMin", "initFolder", "MinDir", "minDb", "versionFolder", "minFolder", " minDirectory", "tempDir", "MinFile", "initManager", "miniFile", "blockdir", "versionDirectory", "Mindir", "minDirectory", "tempdir", "initDir", "tempJar", "minJar", " minDriver", "blockDriver", " minFile", "blockDir", " minFolder", "versionManager", "minFile", "blockFile", "MinDb", "miniDb", "minidir", " minMin", "minMin", " minJar", "MinMin", "miniDriver", "minDest", " mindir", " minManager", "mindir", "miniDest"], "combineFile": ["combicateFile", "CombinateSourceFile", "CombinateLog", "combinedWriter", "CombinateWriter", "joineWriter", "combicateSourceFile", "combinerLog", "joinateFile", "combinateWriter", "joinateWriter", "combineSourceFile", "combinedReader", "combineDir", "combinerWriter", "comboseFile", "combinerSourceFile", "combinateSourceFile", "combinateFile", "combinateLog", "comboseWriter", "joineFile", "combicateWriter", "CombineFile", "comboseReader", "combinateReader", "combinerFile", "combinedDir", "comboseDir", "combinateDir", "joineReader", "combicateLog", "CombinateFile", "combinedFile", "joinateDir", "combineReader", "joinateReader", "CombineLog", "combineLog", "CombineWriter", "joineDir", "CombineSourceFile"], "concatFile": ["concatFiles", "concatsWriter", "ConcatsStream", "concfile", "concatfile", "concentStream", "conateFile", "concentWriter", "ConcatsFiles", "concatsStream", "concWriter", "concatStream", "Concatfile", "concatsfile", "conateDir", "concFiles", "concFile", "ConcatFiles", "Concatsfile", "concatsFile", "conatefile", "concatsDir", "concDir", "ConcatsFile", "conateFiles", "ConcatsDir", "concentFile", "ConcatDir", "concatsFiles", "concatDir", "concStream", "ConcatStream", "concentDir", "ConcatWriter", "ConcatFile", "ConcatsWriter"], "combineWriter": ["ComboseWriter", "mixineWalker", "mixinerRW", "mixineRW", "CombineWrite", "combiseFile", "combinerWalker", "combineWrite", "ComboseReader", "mixineWriter", "combinateWriter", "ComboseFile", "combideReader", "combinerWriter", "combineRW", "comboseFile", "CombineReader", "combideWriter", "combinateFile", "combiseWrite", "comboseWrite", "combiseWriter", "comboseWalker", "combideWalker", "combinateWrite", "comboseWriter", "combiseReader", "CombineFile", "ComboseWrite", "combineWalker", "comboseReader", "combinateReader", "combideRW", "mixinerWriter", "mixinerReader", "mixineReader", "combinerRW", "comboseRW", "combinerReader", "combineReader", "mixinerWalker", "CombineWriter"], "concatWriter": ["concatsWriter", "syncFile", "convertDriver", "convertFile", "syncReader", "convertReader", "concWrite", "ConcatsWrite", "concatsWrite", "syncatFile", "concilFile", "concWriter", "syncWrite", "concatReader", "concReader", "syncWriter", "concilWrite", "ConcatsDriver", "concFile", "concatWrite", "syncatWriter", "syncatWrite", "concatsReader", "convertWriter", "concatsFile", "convertWrite", "ConcatWrite", "concatDriver", "ConcatsFile", "concatsDriver", "ConcatDriver", "syncatReader", "concilDriver", "concilWriter", "ConcatWriter", "ConcatFile", "ConcatsWriter"], "fails": ["foraults", "ifails", "trors", "infalls", "Fls", "ifils", " fakes", "fakes", "infails", "dfailing", "Falls", "Faults", "dfails", "failing", "Failed", "Fakes", "fls", "frors", "fils", "faults", "tils", "tails", "Frors", "dfils", "falls", "infaults", " failed", "Fils", "foralls", "forils", " fils", "infils", "tls", "ifls", " failing", "dfailed", "ifakes", " fls", " frors", "forails", "Fails", "failed", "Failing"], "link": ["dd", "linked", "image", " page", " comment", " Link", " http", "Link", " module", "ink", "open", "match", " anchor", "links", "parse", " location", "load", "add", "message", "l", " source", "connection", "info", "style", " node", " site", "li", "line", " tag", "uri", " entry", " document", "bug", "block", " target", " inline", " config", " item", "e", "comment", " lang", " html", "follow", "loc", " resource", "address"], "path": ["script", "Path", "point", "content", "step", "input", "pattern", "entry", "src", "text", "filename", "key", "href", "info", "wd", "string", "code", "class", "PATH", "route", "node", "type", "attribute", "pointer", "uri", "ath", "attr", "location", "data", "file", "id", "value", "loc", "source"], "url": ["image", "log", "html", "URL", "resource", "www", "stream", "download", "Url", "open", "channel", "http", "key", "l", "b", "api", "page", "string", "ri", "r", "route", "result", "uri", "build", "pull", "xml", "loader", "location", "ssl", "server", "data", "file", "host", "browser", "str", "sl", "connection", "loc", "source", "web", "f", "address"], "inputStream": ["outputstream", "InputChannel", "downStream", "inputWriter", "inputstream", "downReader", " inputChannel", "InputReader", "InputFile", "inputChannel", "InputStreamer", "downStreamer", "outputReader", "inputFile", "outputChannel", "outputWriter", " inputFile", "inputStreamer", "downFile", " inputWriter", "inputReader", "InputStream", "outputStreamer", " inputstream", "InputWriter", "Inputstream", "outputFile"], "jsFile": ["javascriptWriter", "javascriptPath", "javascriptFile", "jsPath", " jsReader", " jsfile", "jsonDir", "scriptSource", "scriptFile", "JsStream", "JsWriter", " jsWriter", "javascriptfile", "jsonSource", " jsLog", "jsStream", "javascriptStream", "javascriptLog", "scriptDir", "JsFile", "javascriptReader", "JsReader", "jsLog", "jsSource", "jsonPath", "JsLog", "javascriptSource", "Jsfile", " jsStream", "scriptPath", "jsfile", "jsReader", "jsDir", "jsonFile", "javascriptDir", "jsWriter"], "fileName": ["FileNumber", "FileSize", "FileName", "fileNumber", "resourcePath", " filePath", "FilePath", "fileSize", " fileNumber", " fileSize", "resourceName", "filePath", "resourceNumber", "resourceSize"], "outputStream": [" outputFile", "responseWriter", "outputstream", "OutputSteam", " outputSteam", "resourceReader", "resourcestream", "resourceStream", "OutputFile", "OutputWriter", "inputWriter", "OutputStream", "responseSteam", "outputSteam", "responseReader", "outputReader", " outputReader", "OutputReader", "inputFile", "inputSteam", "outputWriter", "Outputstream", "resourceSteam", " outputWriter", "responseStream", " outputstream", "outputFile"], "first": ["th", "right", "other", "before", "found", "self", "current", "root", "alpha", "top", "always", "count", "stack", "use", "replace", "full", "now", "auto", "required", "left", "third", "initial", "again", "next", "success", "st", "split", "p", "First", "then", "result", "it", "all", "same", "prev", "start", "only", "must", "primary", "each", "user", "last", "second", "error", "one", "default"], "reader": ["dd", "image", "in", "resource", "feed", "stream", "inner", "input", "entry", "reads", "reading", "parser", "writer", "info", " Reader", "object", "read", "builder", "driver", "r", "buffer", "rc", "handler", "er", "io", "context", "xml", "loader", "report", "h", "server", "data", "file", "e", "Reader", "config", "source", "f"], "jsCompressor": ["jsReporter", "jsRepressor", " jsCompression", "jsExporter", "jsComporter", "jsExpression", "jsRepress", "jsCompression", " jsComporter", "jsRepression", "jsExpress", "jsCompress", " jsCompress", "jsExpressor"], "s": ["gets", "comments", "objects", "ing", "types", "abs", "ls", "lines", "ments", "ns", "l", "ws", "xs", "g", "groups", "t", "ps", "en", "ions", "S", "os", "v", "states", "qs", "fs", "is", "ses", "es", "ens", "gs", "ings", "sys", "ss", "sets", "n", "ts", "words", "m", "strings", "scripts"], "s1": ["atsAP", "esAP", "qsIP", "s81", "etsAP", "ets2", "sB", "sPre", "ys1", "es2", "etsPre", "esIP", "ings1", "s01", "ys2", "ings01", "esB", "sIP", "es1", "ings2", "es01", "esPre", "qs1", "ysB", "ys01", "qs81", "ats2", "ets1", "ingsB", "ats1", "atsPre", "qs2", "sAP", "es81"], "i": ["z", "j", "o", "q", "ing", "phi", "w", "ii", "ik", "l", "b", "ui", "pi", "c", "t", "ic", "d", "p", "ifier", "xi", "si", "bi", "v", "x", "ip", "is", "a", "qi", "id", "e", "u", "f", "m", "I"], "s2": ["ets82", "es82", "qsSecond", "esCloud", "ings12", "sCloud", "setsCloud", "sets82", "ets2", "etsSecond", "es2", "s62", "ingsSecond", "etsCloud", "ings1", "s82", "es1", "ings2", "esSecond", "sSecond", "qs1", "ls1", "ls62", "es12", "es62", "sets2", "ets62", "ets1", "qs12", "sets1", "qs2", "lsSecond", "ls2", "s12"], "i1": ["pi9", "s9", "i0", "pi1", "piFirst", "sFirst", "i4", "a1", "iFirst", "l2", "eFirst", "lOne", "e1", "e2", "s0", "e0", "pi2", "s4", "l0", "i9", "eOne", "i2", "l1", "pi0", "a4", "pi4", "a2", "sOne", "a9", "iOne"]}}
{"id1": "17475530", "id2": "14619453", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    public Set<String> getAvailableRoles() {\n        if (availableRoles == null) {\n            availableRoles = new HashSet<String>();\n            try {\n                Enumeration<URL> resources = org.springframework.util.ClassUtils.getDefaultClassLoader().getResources(ROLE_FILE_LOCATION);\n                while (resources.hasMoreElements()) {\n                    URL url = resources.nextElement();\n                    InputStream is = null;\n                    try {\n                        URLConnection con = url.openConnection();\n                        con.setUseCaches(false);\n                        is = con.getInputStream();\n                        List<String> lines = IOUtils.readLines(is, \"ISO-8859-1\");\n                        if (lines != null) {\n                            for (String line : lines) {\n                                availableRoles.add(line.trim());\n                            }\n                        }\n                    } finally {\n                        if (is != null) {\n                            is.close();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return availableRoles;\n    }\n", "label": 0, "substitutes": {"testAddLinkToImage": ["testAddLinkFromImage", "testAddLinkToFile", "testAddLinkFromPicture", "testAddLinkstoImage", "testAddLinkstoFile", "testAddLinkOfFile", "testAddLinkToLink", "testAddLinkOfLink", "testAddLinkstoLink", "testAddLinktoImage", "testAddLinkOfPicture", "testAddLinkFromLink", "testAddLinktoPicture", "testAddLinktoLink", "testAddLinkFromFile", "testAddLinkToPicture", "testAddLinksToPicture", "testAddLinksToLink", "testAddLinktoFile", "testAddLinkOfImage", "testAddLinksToFile", "testAddLinkstoPicture", "testAddLinksToImage"], "in": ["ini", "image", "err", "index", "resource", "login", "serv", "stream", "gin", "inn", "val", "input", "with", "din", "In", "at", "version", "exp", "bin", "conn", "pin", "r", "IN", "again", "pass", "token", "path", "work", "doc", "nin", "uri", "cin", "diff", "min", "out", "ins", "is", "xml", "as", "socket", "ssl", "name", "ac", "con", "data", "file", "isin", "rin", "ax", "id", "el", "ex", "i", "win", "reader", "n", "get", "or", "connection", "m", "source", "exec", "f", "url", "inc", "copy"]}}
{"id1": "14303294", "id2": "15500892", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"getServerHash": ["getSecureAddress", " getSecureSHA", " getServerAddress", " getSecureSalt", "getServerSalt", "getSessionSHA", "getSessionHash", " getServerSHA", "getServerAddress", "getserverAddress", "getSecureSalt", "getSecureHash", "getserverSalt", "getserverSHA", "getSecureSHA", " getSecureHash", "getSessionAddress", "getServerSHA", " getSecureAddress", " getServerSalt", "getserverHash", "getSessionSalt"], "passwordHash": [" PasswordHash", " PasswordCode", "privatePassword", "passwordCode", "privatehash", "passwordhash", "PasswordHash", " passwordhash", "PasswordPass", "passwordSalt", "privateSalt", "privateHash", "Passwordhash", " passwordCode", "PasswordPassword", "passwordPassword", " passwordPassword", "passwordPass", " passwordSalt", "PasswordCode", " PasswordPass", " passwordPass"], "PasswordSalt": [" PasswordHash", "PASSPassword", "PasswordHash", " passwordSecret", "passwordSalt", "passwordSecret", "PASS256", "PASSHash", "PasswordSecret", "password256", " Password256", " PasswordPassword", "PasswordPassword", "passwordPassword", " passwordPassword", "Password256", " passwordSalt", " PasswordSecret", "PASSSalt"], "hash": ["image", "her", "sha", "base", "html", "pool", "log", "change", "hex", "content", "check", "dig", "message", "cache", "key", "password", "update", "string", "array", "code", "kh", "buffer", "crypt", "work", "result", "build", "sh", "number", "row", "response", "mac", "block", "ash", "size", "auth", "Hash", "sum", "h", "search", "ha", "data", "user", "value", "error", "url", "copy", "address"], "digest": ["digher", "Digher", "integall", "mdested", " digall", " digger", "Digusher", "Diger", "signher", "digall", "integester", "mdest", "digener", " digher", "hashester", "digester", "signger", "Digester", "integested", "integest", "generester", "generested", "hasher", "Digested", "diger", "Digener", " diger", "hashener", "mdusher", "mdester", "signer", "signest", "signester", "digusher", " digusher", "generall", " digener", "Digger", "digested", " digested", "generest", "digger", "Digest", "hashest", " digester"]}}
{"id1": "17083703", "id2": "9347451", "code1": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 0, "substitutes": {"savaRolePerm": ["sqlRoleperms", "sqlRolePerM", "sqlRolePERm", "sqlRolePERM", "sqlRolePERms", "sqlRolePerm", "sqlRolepermission", "sqlRolePERmission", "sqlRoleperm", "sqlRolePerms", "sqlRolePermission", "sqlRoleperM"], "roleid": ["roId", "Roleid", "teamID", "teamId", "teamid", "Roleids", " roleinfo", "roinfo", " rolename", "RoleId", "roleId", "roleinfo", "rolename", "roleID", "roids", "resourceID", " roleids", "teamname", "resourceid", " roleID", "roleids", "resourceId", "Roleinfo", " roleId", "roid", "resourcename"], "role_perm_collect": ["role_perm_Collect", "role_permfcollection", "role_permamcollection", "role_per_map", "role_per_collection", "role_permamcollect", "role_permpCollect", "role_permfCollect", "role_perm_set", "role_perm_col", "role_permfcollect", "role_perm_coll", "role_per_set", "role_per_col", "role_permammap", "role_permfcol", "role_per_cont", "role_perm__collect", "role_perm__map", "role_per_ignore", "role_perm_map", "role_perm__collection", "role_perm_ignore", "role_per_coll", "role_permpcont", "role_permamignore", "role_per_collect", "role_perm_cont", "role_permpcollect", "role_per_Collect", "role_permpcollection", "role_perm__cont", "role_perm__ignore", "role_permpcol", "role_perm_collection"], "cp": ["pool", "dp", "dc", "pc", "cop", "ca", "cd", "cb", "CP", "ch", "bp", "pr", "jp", "mp", "c", "pp", "cf", "ct", "cpp", "orp", "cdn", "hp", "ph", "p", "cmp", "pm", "priv", "proc", "cs", "CF", "fp", "cc", "cm", "DC", "cn", "tp", "pd", "mc", "Conn", "pkg", "ctx", "cr", "pg", "gp"], "conn": ["enc", "ou", "nt", "config", "coll", "dc", "po", "oci", "nc", "pc", "Connection", "ca", "exec", "sync", "ch", "cb", "cat", "pr", "ann", "act", "c", "cf", "sql", "cr", "ct", "orp", "core", "ok", "ci", "p", "cmp", "fail", "org", "oss", "client", "cc", "util", "close", "ssl", "col", "ac", "co", "reg", "con", "ec", "cn", "server", "dn", "connect", "lock", "mc", "Conn", "error", "res", "ctx", "connection", "loc", "n", "db", "pg", "uc"], "rs": ["rx", "RC", " rows", "rep", "ls", "runs", "rt", "ns", "pr", "Rs", "xs", "rows", "rc", "ps", "ows", "ds", "ris", "os", "eps", "cs", "mr", "row", " Rs", "rm", "RS", "ss", "rl", "res"], "pstmt": [" pftnt", "pctpo", "psthml", "pStwd", "pfmb", " pssmt", "pctst", "Pstdt", " pstma", "pctdr", "pfmt", " psthm", "psthst", " pstmn", "Pstm", " pstm", "Pstmp", "pptm", "pftmt", " pssmb", "pstmn", "pftmp", "pstmr", "psthnt", "pfm", "pattmt", "postmb", "pddr", "pstwd", "pftst", " psthmd", " postm", "postmt", "pngmb", "pssmb", "pstpo", "pssnt", "pptmt", "pscmb", "Pctmit", "pvmn", "pctm", "pfmp", "pscmc", " postma", "pctmt", " pftm", " pvmt", "pngm", "postmc", " pstmd", "pctwd", "pftdt", "Pstnt", "pfmr", "pctdt", "pdmt", "pctma", " pstnt", " postnt", "Pctnt", " pftmt", "pssdr", "pctmit", "Pstbm", "Pctm", "pstma", "Pctwd", "pstml", "pdmb", "Pstmb", "pngmit", " pstmb", "pctmr", "pconstwd", " psthmt", "pptnt", " pssdr", "Pstmit", "pconstmb", "pstmb", "pdnt", "pvmb", "pstmp", "pssmt", "pStmt", "pftm", "pstmd", "pconstmt", "pstnt", "postm", "pwdm", "pspm", "Pctmr", "pattpo", "Pctmc", "Pstma", "Pctma", "Pstmr", "pstst", "pctnt", "psthmb", " pvmn", "pftnt", "pctbm", "psthmn", "pscnt", "pctmc", "pstmit", "pptmp", " pstml", "psthpo", "pctml", "psthmd", "pscmt", "pctmp", "pctmd", " psthpo", "Pctmb", "Pctmt", "pctmb", "Pstmc", "pattm", "Pctbm", "pvmt", "pStmb", "pconstma", "postma", " pstpo", " pftmp", "pwdbm", "pwdnt", "pstdt", " pssnt", "pctmn", "pspmt", "Pctst", "Pctmp", "pspmr", "psthmt", "pngmt", "postnt", " pvmb", "psthm", "pfmit", "pStma", " pstmp", "pstm", "Pctdt", "pattmd", "pvml", "pStm", "Pstmt", "pstmc", "pstbm", " postmt", "psthdt", " pvml", "pstdr", "pStnt", "pwdmt", "pspmp", " pstdr", "Pstst", "Pstwd"], "factory": ["Factory", "cixture", "cactory", "FFactory", "fixture", "Flux", "familyFactory", "fille", "miller", "filux", "fiFactory", "vixture", "flux", "mixture", "fiactory", "familylux", "Fille", "fiille", "mlier", "familyactory", "fFactory", "ciller", "mactory", "vlier", "vactory", "filler", "familyille", "viller", "flier", "clier"], "op": [" Operation", " ori", "o", " org", " http", " ops", "Oper", "ops", "Op", "or", " opt", " cop", " os", " operator", " parent", " app", " co", " project", "oper", " Op", "OP", "Operation", "oc", "operation", " auth", " OP", " operate", "Ops"], "role_perm_ir": ["role_priv_iter", "role_per_iter", "role_permiditer", "role_per_ior", "role_permqir", "role_per_ir", "role_permqreader", "role_permidire", "role_perm_nir", "role_perm_IR", "role_priv_nir", "role_perm_irt", "role_perm_ire", "role_permidirt", "role_per_reader", "role_permqior", "role_per_irt", "role_perm_reader", "role_permqiter", "role_per_ire", "role_permidir", "role_priv_IR", "role_priv_ir", "role_perm_ior", "role_perm_iter"], "rolePerm": ["rolePrivmission", "RolePermission", "rolePermission", "roleElm", "rolePERr", " rolePerp", "rolePERM", "rolePm", "RolePerr", "RoleAdm", "RolePartM", "rolePartms", " rolePm", "roleElms", "roleAdm", "RoleAdr", "roleParp", "RolePartm", "rolElms", " rolePp", "RoleAdM", "rolElmission", "rolePerms", "rolePerr", " rolePermission", "RolePerm", "rolePrivms", "rolePartM", "roleParms", "rolePartmission", "rolePrivm", "rolPermission", "rolePmission", "rolPerM", "rolePrivM", "rolepermission", "rolPerms", "roleperp", "rolePms", "rolePERm", "roleElM", " rolePmission", "roleperms", "rolePerp", "RolePartmission", "rolePERms", "RolePartms", "rolePERmission", "rolePrivr", "rolePartm", "roleperm", "rolePerM", " rolePms", "roleElmission", "roleAdM", "rolePp", "roleAdr", "rolElm", "roleParmission", "RolePerms", "rolElM", "RolePerM", "rolPerm", "roleParm", " rolePerms"]}}
{"id1": "4937535", "id2": "812803", "code1": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"loadProperties": ["loadProproperties", "loadPropertyperties", "loadPperties", "loadproproperties", "getProperties", "getproproperty", "loadPproperty", "loadPropertyproperties", "loadprops", "loadPropertyproperty", "loadPps", "loadproperties", "getproproperties", "getprops", "getproperties", "loadProproperty", "getProproperty", "getProps", "loadPproperties", "loadPropertyps", "loadProps", "getProproperties", "loadproproperty"], "properties": ["ports", "resources", "gets", "beans", "options", "objects", "posts", "types", "utils", "bugs", "lines", "plugins", "ls", "property", "obj", "details", "rules", "table", "events", "styles", "info", "object", "prototype", "fixes", "limits", "style", "tests", "params", "groups", "ps", "pps", "ils", "settings", "notes", "os", "fps", "prop", "values", "reports", "pb", "features", "ips", "perties", "results", "pro", "parts", "address"], "url": ["image", "URL", "base", "resource", "in", "event", "Url", "ls", "channel", "entry", "http", "l", "b", "api", "object", "page", "string", "class", "element", "r", "bel", "buffer", "path", "not", "org", "uri", "client", "xml", "article", "loader", "name", "server", "data", "file", "user", "gl", "instance", "sl", "i", "reader", "connection", "source", "f", "address"]}}
{"id1": "12197169", "id2": "22442270", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 1, "substitutes": {"read": ["create", "end", "continue", "stream", "check", "download", "write", "open", "parse", "load", "reading", "Read", "process", "run", "replace", "print", "readable", "work", "loop", "start", "report", "init", "ready", "request", "reader", "println", "get"], "in": ["ini", "err", "image", "log", "index", "login", "fr", "o", "of", "ing", "stream", "inner", "inn", "input", "scan", "In", "at", "cms", "l", "bin", "b", "conn", "info", "c", "r", "IN", "from", "buffer", "again", "token", "path", "er", "doc", "source", "nin", "io", "it", "min", "out", "by", "ins", "is", "ssl", "a", "con", "server", "data", "file", "isin", "id", "e", "on", "error", "ex", "reader", "n", "connection", "din", "f", "url", "inc", "s"], "line": ["link", "lc", "log", "unit", "end", "val", "lf", "lines", "inline", "entry", "LINE", "parse", "text", "message", "ne", "Line", "key", "L", "l", "b", "object", "page", "ine", "string", "code", "status", "buffer", "record", "se", "frame", "row", "le", "block", "name", "col", "ge", "data", "file", "id", "cell", "e", "el", "str", "sl", "comment", "value", "reader", "source", "f", "url", "lin"], "i": ["ini", "ski", "index", "j", "o", "oi", "phi", "ii", "fi", "ix", "slice", "l", "b", "info", "ui", "ri", "pi", "gi", "abi", "li", "ci", "p", "ie", "uni", "si", "io", "ni", "bi", "eni", "xi", "x", "ai", "ip", "is", "ori", "qi", "ti", "e", "u", "f", "n", "di", "I", "zi"], "logDatum": ["logdata", "logDum", "logDsatum", "logDatam", "logDsata", "Logdict", "LogDict", "logDictionary", "LogDum", "logDam", "exDDatum", "exDam", "logDatatum", "logDDam", "exDDictionary", "exDictionary", "logdict", "logDsict", "LogData", "logdatum", "logFictionary", "logDatictionary", "exDDam", "logDDictionary", "exData", "logDatata", "logFam", "LogDatum", "logFata", "logFatum", "logData", "logDict", "Logdatum", "logdum", "Logdum", "logDsum", "exDData", "exDatum", "Logdata", "logDDatum", "logDData", "logDatict"]}}
{"id1": "3731077", "id2": "12306305", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["importFile", " copyFiles", "transferfile", "transferFiles", "importSourceFile", "importFiles", "transferFile", "importfile", "copySourceFile", " copyfile", "copyFiles", "copyfile", "transferSourceFile", " copySourceFile"], "from": ["origin", "base", "o", "resource", "of", "before", "this", "form", "without", "with", "at", " form", "src", "ca", "add", "back", "remote", "From", "left", "url", "c", "front", "about", "path", "d", "original", "part", "io", "se", "by", "ce", "client", "start", "as", "name", "a", "range", "file", "user", "data", "id", "old", "or", "config", "source", "f", "address"], "to": ["TO", "base", "o", "temp", "office", "site", "of", "storage", "root", "this", "point", "po", "with", "at", "eto", "target", "top", "output", "api", "b", "object", "auto", "null", "so", "about", "too", "again", "t", "token", "two", "p", "source", "type", "io", "os", "dest", "To", "by", "client", "size", "as", "name", "location", "socket", "until", "file", "database", "one", "toc", "or", "into", "parent", "f", "copy"], "parentDir": ["outFolder", "rootFile", "rootDir", "currentFile", "outFile", "parentDirectory", "Parentdir", "currentFolder", "ParentDirectory", " parentFile", "parentFile", "outDir", " parentFolder", "rootFolder", " parentDirectory", "ParentFolder", "outDirectory", "currentdir", "parentdir", "ParentFile", "parentFolder", "currentDir", "ParentDir", " parentdir", "rootDirectory"], "in": ["ini", "err", "kin", "image", "o", "login", "inner", "inn", "gin", "form", "arin", "pre", "input", "with", "din", "In", "pc", "fc", "sync", "rec", "l", "bin", "conn", "pin", "IN", "r", "rc", "again", "work", "ie", "source", "nin", "part", "io", "it", "cin", "diff", "min", "ins", "init", "ac", "inside", "con", "on", "isin", "id", "rin", "trial", "i", "win", "reader", "vin", "or", "m", "inc", "exec", "plugin", "url", "lin"], "out": ["ou", "o", "outer", "other", "can", "inner", "gin", "w", "input", "at", "net", "channel", "sync", "output", "OUT", "bin", "conn", "writer", "auto", "option", "c", "about", "again", "outs", "op", "p", "io", "org", "cin", "cy", "Out", "client", "off", "init", "app", "co", "ac", "on", "user", "vert", "ot", "call", "ex", "ico", "win", "or", "inc", "exec", "plugin"], "ic": ["enc", "lc", "pic", "o", "voc", "dc", "nic", "input", "cl", "pc", "ix", "anc", "iac", "fc", "cu", "acs", "sync", "ik", "conn", "auto", "c", "vc", "icc", "ct", "rc", "irc", "ig", "ci", "op", "io", "cin", "cs", "ai", "xc", "cc", "aic", "cus", "ac", "co", "loc", "IC", "mc", "ex", "i", "ico", "bc", "or", "ec", "uc", "inc", "ics"], "oc": ["enc", "o", "circ", "voc", "can", "dc", "nic", "oci", "pc", "cur", "or", "anc", "ca", "fc", "acs", "wic", "roc", "soc", "c", "vc", "aco", "ack", "oco", "ci", "op", "sc", "AC", "io", "org", "xc", "cy", "cc", "OC", "ocol", "oca", "alloc", "cus", "aic", "ac", "co", "mic", "ob", "ocon", "mc", "i", "og", "toc", "uc", "bc", "ec", "loc", "inc"]}}
{"id1": "6188784", "id2": "7499186", "code1": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["create", "change", "clone", "to", "download", " copying", " Copy", "zip", "cop", "sync", "replace", "Cop", "clip", "split", "p", "cmp", "map", "Copy", "file", "transfer", "lock", "move", "put", "cp", " transfer", " cp"], "source": ["origin", "unit", "base", "resource", "SOURCE", "site", "stream", "Source", "inner", "input", "target", "up", "src", "cache", "slice", "use", "sync", "remote", "ources", "from", "route", "path", "ie", "ource", "sin", "ins", "start", "name", "id", "file", "down", "reader", "i", "iter", "connection", "parent"], "dest": ["coord", "folder", "de", "die", "wb", " destination", "temp", "cont", "done", "dc", "which", "target", "src", "later", "bin", "sup", "comb", "home", "style", "orig", "exit", "dist", "d", "result", "flat", "img", "dir", "tmp", "test", "Dest", "thin", "down", "desc", "delete", "destroy"], "in": ["ini", "err", "image", "plugin", "base", "login", "resource", "inner", "gin", "inn", "input", "din", "In", "pc", "up", "src", "bin", "conn", "url", "c", "pin", "r", "IN", "again", "work", "plus", "ie", "nin", "it", "cin", "sin", "min", "issue", "pull", "client", "ins", "into", "as", "init", "name", "inside", "ac", "thin", "con", "id", "include", "file", "isin", "i", "reader", "win", "n", "connection", "m", "parent", "f", "socket", "inc", "s"], "out": ["ou", "err", "pool", "o", "outer", "other", "prefix", "this", "inner", "outside", "w", "plain", "write", "net", "at", "channel", "obj", "our", "up", "exp", "sync", "output", "OUT", "password", "writer", "bin", "conn", "extra", "cat", "option", "buffer", "again", "outs", "not", "part", "io", "Out", "client", "off", "name", "ext", "id", "file", "vert", "down", "parent", "call", "ex", "no", "i", "timeout", "n", "one", "lib", "connection", "exec", "socket"], "size": ["unit", "ize", "ice", "shape", "send", "end", "offset", "capacity", "depth", "content", "flush", "order", "open", "mode", "count", "add", "sec", "sync", "bytes", "speed", "scale", "clear", "export", "en", "si", "sized", "width", "len", "x", "number", "small", "izes", "length", "any", "iz", "start", "close", "SIZE", "name", "sum", "e", "Size", "transfer", "empty", "n", "seek", "time", "loc", "max", "address"], "buf": ["box", "vec", "ba", "coll", "ff", "feat", "src", "bag", "uf", "b", "bytes", "bin", "cb", "cf", "buff", "buffer", "fb", "bf", "bd", "seq", "cmp", "len", "ra", "cas", "la", "map", "ha", "data", "cv", "fam", "BU", "rb", "pkg", "bc", "ctx", "uc", "br", "Buffer"]}}
{"id1": "13783898", "id2": "16825994", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeString2File", "encodeFileFromStream", "encodeFileFromString", "encodeStringToStream", "encodeString2Files", "encodeFiletoStream", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFiles", "encodeFiletoFile", "encodeFileFromFiles", "encodeFileFromFile", "encodeString2Stream", "encodeStringToString", "encodeFileToString", "encodeFile2String", "encodeString2String", "encodeFile2File", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFile2Files", "encodeFileToStream"], "infile": [" infilename", "infiles", "Infilename", "outFile", "inputfile", "outfiles", "inFile", "InFile", "inputfilename", " infiles", " infp", "inputFile", "outfilename", "outfp", "Infiles", "inputfiles", "infp", "inputfp", "infilename", "Infile"], "outfile": ["newfolder", "outname", "outFile", " outFile", "outputfp", "outputfilename", " outfilename", "Outname", "outfolder", "outputfolder", " outfp", "Outfolder", "newfile", "newname", " outfolder", "infolder", "newFile", "outfilename", "outfp", "outputfile", "OutFile", "infp", " outname", "infilename", "Outfile"], "in": ["re", "err", "ini", "image", "base", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "vin", "m", "din", "socket", "inc", "s"], "out": ["err", "ou", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "In", "obj", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "outs", "work", "job", "source", "line", "io", "Out", "client", "off", "name", "co", "on", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "count", "cache", "slice", "queue", "b", "bytes", "bb", "null", "buf", "buff", "border", "padding", "fb", "split", "uffer", "type", "result", "len", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "input", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "close", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "model", "method", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "respons", "open", "better", "message", "growth", "modified", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "19113613", "id2": "12306305", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["create", "change", "clone", "share", "download", "write", "paste", "zip", "cop", "load", "process", "sync", "replace", "Cop", "cat", "update", "clip", "split", "p", "type", "upload", "ssh", "opy", "archive", "Copy", "transfer", "rm", "put", "move", "delete", "get", "cp", " cp", "save"], "in": ["ini", "image", "kin", "plugin", "base", "login", "index", "this", "inner", "inn", "input", "din", "In", "bin", "update", "c", "pin", "IN", "again", "token", "ic", "work", "part", "cin", "sin", "min", "diff", "client", "ins", "lin", "as", "name", "init", "inside", "a", "thin", "id", "data", "on", "i", "reader", "old", "n", "win", "get", "connection", "config", "project", "f", "url", "inc"], "out": ["err", "image", "base", "o", "outer", "other", "resource", "point", "self", "root", "this", "outside", "project", "input", "with", "net", "at", "version", "up", "group", "cache", "output", "OUT", "remote", "bin", "conn", "b", "object", "page", "null", "option", "c", "external", "again", "outs", "path", "work", "goal", "p", "part", "line", "io", "v", "x", "Out", "client", "block", "off", "app", "init", "name", "ext", "user", "vert", "parent", "call", "ex", "no", "dot", "n", "one", "connection", "inc", "exec", "obj"], "source": ["origin", "force", "unit", "base", "service", "resource", "SOURCE", "site", "prefix", "view", "Source", "direction", "format", "src", "use", "scope", "status", "class", "pe", "from", "position", "subject", "route", "family", "type", "ource", "attribute", "uri", "sin", "dest", "ce", "secret", "secure", "size", "missing", "name", "internal", "proxy", "component", "id", "reference", "alt", "parent", "username", "feature", "iter", "project", "url"], "target": ["origin", "force", "base", "service", "resource", "site", "detail", "config", "prefix", "root", "current", "point", "alias", "direction", "format", "wrong", "pattern", "Target", "top", "master", "src", "output", "cat", "home", "null", "about", "tail", "route", "token", "path", "next", "goal", "dest", "name", "host", "component", "reference", "alt", "parent", "value", "arget", "template", "project", "url", "address"], "files": ["resources", "ports", "objects", "keys", "flows", "lines", "ls", "plugins", "links", "children", "sections", "filename", "blocks", "tools", "iles", "apps", "groups", "obs", "images", "Files", "ions", "cells", "jobs", "items", "fs", "ins", "users", "models", "features", "docs", "pages", "data", "classes", "names", "assets", "results", "f", "s"], "file": ["File", "folder", "letter", "unit", "base", "resource", "child", "feed", "current", "function", "ile", "entry", "fe", "load", "local", "filename", "l", "b", "object", "page", "url", "string", "future", "item", "path", "single", "line", "part", "uri", " File", "it", "entity", "fp", "layer", "dir", "FILE", "le", "name", "live", "data", "id", "binary", "e", "el", "per", "lib", "parent", "f", "directory"], "inCh": ["InCh", "inch", "inChan", "InChan", " inChannel", " inch", "outCH", " inChan", "INCh", "outChan", "outChannel", " inCH", "INChan", "inChannel", "Inch", "INCH", "InChannel", "INChannel", "InCH", "inCH", "outch"], "outCh": ["inch", "inChan", " outChannel", "OutCH", "outputChan", "outCH", " outch", "outChan", "outputch", "Outch", "outChannel", "OutChannel", " outCH", "inChannel", "OutCh", "outputCH", "inCH", "OutChan", "outputCh", "outch"]}}
{"id1": "3375724", "id2": "9687813", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" importarEmissoresDosTitulasf", " importarEmissoresDosTitulasFe", " importarEmissoresDosTitulosf", " importarEmissoresDosTitULosPF", " importarEmissoresDosTitularF", " importarEmissoresDosTitulosPF", " importarEmissoresDosTituloFe", " importarEmissoresDosTituloF", " importarEmissoresDosTitularFe", " importarEmissoresDosTitulasF", " importarEmissoresDosTitULoFe", " importarEmissoresDosTitularf", " importarEmissoresDosTitulosF", " importarEmissoresDosTitULoPF", " importarEmissoresDosTitularPF", " importarEmissoresDosTitulosFe", " importarEmissoresDosTituloPF", " importarEmissoresDosTitULosF", " importarEmissoresDosTitulof", " importarEmissoresDosTitULoF", " importarEmissoresDosTitULosf", " importarEmissoresDosTitULof", " importarEmissoresDosTitulasPF", " importarEmissoresDosTitULosFe"], "pArquivoTXT": ["pArquivoDXT", "pArquivaTxt", "pArquivoFEMP", "pArquivoTTP", "pArquivoFxt", "pArquivDBT", "pArquivDXT", "pArquivoOTEMP", "pArquivaTEXT", "pArquivoBxt", "pArquivoLBT", "pArquivaFEXT", "pArquivoBXT", "pArquivaFTP", "pArquivoBEMP", "pArquivoTLS", "pArquivoTEMP", "pArquivTLS", "pArquivaFxt", "pArquivoLXT", "pArquivoQxt", "pArquivoQXT", "pArquivaFEMP", "pArquivoOTTP", "pArquivoFTP", "pArquivoDEXT", "pArquivoLxt", "pArquivoOTxt", "pArquivoBLS", "pArquivoTBT", "pArquivDxt", "pArquivaTEMP", "pArquivoLLS", "pArquivaTTP", "pArquivoQEXT", "pArquivoDLS", "pArquivoFEXT", "pArquivoQBT", "pArquivoDBT", "pArquivoTxt", "pArquivoFBT", "pArquivoFXT", "pArquivaTBT", "pArquivoTEXT", "pArquivaFBT", "pArquivoDxt", "pArquivTXT", "pArquivoBTP", "pArquivTBT", "pArquivDLS", "pArquivTxt", "pArquivoOTXT", "pArquivaFXT", "pArquivaTXT", "pArquivoBBT"], "pAndamento": [" pOrementO", " pOrementos", " pAndmentO", " pOrementoo", " pAndemento", " pAndmentos", " pAndamentO", " pAndementO", " pAndentiono", " pAndementoo", " pAndamentos", " pOramentO", " pAndentionos", " pAndmentoo", " pAndementos", " pOremento", " pAndamentoo", " pOramento", " pAndmento", " pOramentoo", " pAndentionoo", " pAndentionO", " pOramentos"], "numeroDoRegistro": ["numeroDoRegestro", "numeroDoregistro", "numeroDoRegiftorno", "numeroDoRegestrano", "numeroDoRegpectros", "numeroDoregestros", "numeroDoRegiftros", "numeroDoRegestorno", "numeroDoRegpectrano", "numeroDoregistros", "numeroDoregestorno", "numeroDoRegiftrano", "numeroDoregistrano", "numeroDoRegpectro", "numeroDoRegestros", "numeroDoRegiftro", "numeroDoRegpectorno", "numeroDoregistorno", "numeroDoregestro", "numeroDoRegistrano", "numeroDoRegistorno", "numeroDoRegistros", "numeroDoregestrano"], "in": ["ini", "err", "kin", " out", "login", "config", "inn", "scan", "cl", "with", "In", "slice", "l", "b", "bin", "c", " IN", "r", "IN", "session", "g", "again", "t", "query", "nin", "part", "conf", "cin", "out", "ins", "is", "ner", "con", "ln", "span", "rin", "data", "ex", "reader", "i", "n", "connection", "m", "inc", "f", "url", "s"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicioDestaco", "stmtLimpezaInicialDestania", "stmtLimpezaInicioCombario", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialCombination", "stmtLimpezaInicialDestario", "stmtLimpezaInicialDesino", "stmtLimpezaInicioDestario", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialCombania", "stmtLimpezaInicialDesaco", "stmtLimpezaInicioDestao", "stmtLimpezaInicialdestaco", "stmtLimpezaInicioCombaco", "stmtLimpezaInicialDestination", "stmtLimpezaInicialCombino", "stmtLimpezaInicialCombaco", "stmtLimpezaInicialDesao", "stmtLimpezaInicioCombao", "stmtLimpezaInicialCombario", "stmtLimpezaInicialdestao", "stmtLimpezaInicioDestino", "stmtLimpezaInicialCombao", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialDestaco", "stmtLimpezaInicialDestao", "stmtLimpezaIniciaDestania", "stmtLimpezaInicialDesario", "stmtLimpezaInicialdestania", "stmtLimpezaInicialdestino", "stmtLimpezaInicialdestario", "stmtLimpezaInicialdestination", "stmtLimpezaInicioCombino"], "sql": ["err", "body", "log", "sol", "cmd", "setup", "html", "nl", "lua", "json", "ls", "SQL", "details", "zip", "http", "filename", "software", "liquid", "l", "shell", "csv", "string", "spec", " SQL", "params", "sn", "query", "kl", "select", "stat", "result", "ql", "sg", "sv", "sb", "eps", "sq", "expr", "where", "QL", "util", "statement", "ssl", "socket", "term", "sys", "search", "data", "id", "fn", "seed", "layout", "sf", "description", "sl", "comment", "rl", "el", "dl", "msg", "acl", "db", "install", "url", "s"], "stmtDestino": ["stmtCampino", "stmDestino", "stmtDistinos", "stmtDestinos", "stmCampaco", "stmdDestin", "stmtdestin", "stmCampania", "stmtDistino", "stmCampino", "stmdDestorno", "stmtDistaco", "stmtdestaco", "stmdDestino", "stmtDestin", "stmtDestaco", "stmCamporno", "stmtDestania", "stmtDestorno", "stmtDistorno", "stmtCampania", "stmdDestinos", "stmtCamporno", "stmtdestania", "stmtdestino", "stmDestaco", "stmDestania", "stmtDistin", "stmtdestinos", "stmtDistania", "stmDestorno", "stmtCampaco", "stmtdestorno"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABOCALSHOU", "TAMANHO_DO_CABECALCO", "TAMANHO_DO_CABECALSHOU", "TAMANHO_DO_CABECULHOU", "TAMANHO_DO_CABECALHOU", "TAMANHO_DO_CABOCALHO", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABECALSCO", "TAMANHO_DO_CABOCALCO", "TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABISCALHO", "TAMANHO_DO_CABECALLHOU", "TAMANHO_DO_CABISCALLHO", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABISCALLHI", "TAMANHO_DO_CABOCALSCO", "TAMANHO_DO_CABOCALSHO", "TAMANHO_DO_CABECALLCO", "TAMANHO_DO_CABECALSHO", "TAMANHO_DO_CABECARHOU", "TAMANHO_DO_CABOCALHOU", "TAMANHO_DO_CABISCALHI", "TAMANHO_DO_CABISCALLHOU", "TAMANHO_DO_CABISCALHOU", "TAMANHO_DO_CABECARCO", "TAMANHO_DO_CABECALSHI"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPE__DO", "TAMANHO_DO_RODAPJDO", "TAMANHO_DO_RODAPEECPO", "TAMANHO_DO_RODAPE_TO", "TAMANHO_DO_RODAPE__do", "TAMANHO_DO_RODAPJdo", "TAMANHO_DO_RODAP_TO", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAP_Do", "TAMANHO_DO_RODAPEJPO", "TAMANHO_DO_RODAPEJdo", "TAMANHO_DO_RODAPEECDO", "TAMANHO_DO_RODAPEJTO", "TAMANHO_DO_RODAPE_PO", "TAMANHO_DO_RODAP_PO", "TAMANHO_DO_RODAPEECDo", "TAMANHO_DO_RODAPJPO", "TAMANHO_DO_RODAPJDo", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAPE__TO", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAPE__Do", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAPJTO"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADANDOJ", "TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADADOPS_", "TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADADosAD", "TAMANHO_DOS_METADADIESJ", "TAMANHO_DOS_METADADOS___", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADADOAD", "TAMANHO_DOS_METADADOSJ", "TAMANHO_DOS_METADANDOAD", "TAMANHO_DOS_METADANDOS___", "TAMANHO_DOS_METADADOTSAD", "TAMANHO_DOS_METADANDO_", "TAMANHO_DOS_METADADOPS___", "TAMANHO_DOS_METADADIES_", "TAMANHO_DOS_METADADOJ", "TAMANHO_DOS_METADANDOS_", "TAMANHO_DOS_METADADOSAD", "TAMANHO_DOS_METADANDO___", "TAMANHO_DOS_METADADOTS_", "TAMANHO_DOS_METADADOPSJ", "TAMANHO_DOS_METADADO___", "TAMANHO_DOS_METADADIES___", "TAMANHO_DOS_METADANDOSJ", "TAMANHO_DOS_METADANDOSAD"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_PORPRECIES", "TAMANHO_MEDIO_PORPREGES", "TAMANHO_MEDIO_POR_RECAS", "TAMANHO_MEDIO_PORPREGIC", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_PORPRECAS", "TAMANHO_MEDIO_POR_GAS", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_PORPREGAS", "TAMANHO_MEDIO_PORPREGIT", "TAMANHO_MEDIO_POR_REGIT", "TAMANHO_MEDIO_PORPRegES", "TAMANHO_MEDIO_POR_GIES", "TAMANHO_MEDIO_POR_REGAS", "TAMANHO_MEDIO_PORPRegIT", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_POR_EGIS", "TAMANHO_MEDIO_POR_GIC", "TAMANHO_MEDIO_POR_GIS", "TAMANHO_MEDIO_POR_RegIT", "TAMANHO_MEDIO_POR_EGES", "TAMANHO_MEDIO_PORPRegIS", "TAMANHO_MEDIO_POR_EGIES", "TAMANHO_MEDIO_POR_REGIES", "TAMANHO_MEDIO_POR_RegIS", "TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_PORPRECIC", "TAMANHO_MEDIO_POR_RegIC", "TAMANHO_MEDIO_PORPREGIES", "TAMANHO_MEDIO_PORPRegIES", "TAMANHO_MEDIO_POR_EGIT", "TAMANHO_MEDIO_POR_RECIES", "TAMANHO_MEDIO_PORPRECIS", "TAMANHO_MEDIO_POR_RegAS", "TAMANHO_MEDIO_PORPREGIS", "TAMANHO_MEDIO_POR_RegIES"], "tamanhoDosArquivos": ["tamanhoDosArquivalo", "tamanhoDosArQUivlos", "tamanhoDosArquervlos", "tamanhoDosArqIVos", "tamanhoDosArquIVoes", "tamanhoDosArQUivo", "tamanhoDosArquievo", "tamanhoDosArqivos", "tamanhoDosArQUervo", "tamanhoDosArquervo", "tamanhoDosArquievOs", "tamanhoDosArquivo", "tamanhoDosArQUervOs", "tamanhoDosArquIVo", "tamanhoDosArquIVos", "tamanhoDosArqIVlos", "tamanhoDosArquivalos", "tamanhoDosArQUervlos", "tamanhoDosArquervos", "tamanhoDosArquivOs", "tamanhoDosArquievlos", "tamanhoDosArquivallos", "tamanhoDosArquievos", "tamanhoDosArquIVlos", "tamanhoDosArqIVoes", "tamanhoDosArquivlos", "tamanhoDosArQUervos", "tamanhoDosArqIVo", "tamanhoDosArQUivos", "tamanhoDosArqivo", "tamanhoDosArquervoes", "tamanhoDosArQUivOs", "tamanhoDosArquivoes", "tamanhoDosArqivoes", "tamanhoDosArquervOs", "tamanhoDosArquivaloes", "tamanhoDosArqivlos", "tamanhoDosArquIVOs"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimante", "quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstimmante", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstipante", "quantidadeDeRegistrosEstivante", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstivado"], "registro": [" registulo", "regestro", " regestro", " regestros", "registulo", "regastro", "regastration", " registros", " registration", "registration", " regestulo", " regestration", "regestros", "regestration", "registros", "regustros", "regustration", "regastulo", "regestulo", "regustro", "regustulo", "regastros"], "campos": [" campas", "CampOS", "campOS", " casos", "campas", "Campos", " caso", " casOS", "Campo", " campo", "campo", " casas", "Campas", " campOS"]}}
{"id1": "23161545", "id2": "22135199", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandGID", "getRandGid", "getRandomGCID", "getRandGUID", "getRandUid", "getRandomGid", "getRandUuid", "getRandomGCid", "getRandomGID", "getRandGuid", "getRandomGCuid", "getRandomIGID", "getRandUID", "getRandomUUID", "getRandomIGUID", "getRandomUID", "getRandomGCUID", "getRandUUID", "getRandomIGid", "getRandomUuid", "getRandomIGuid", "getRandomGuid", "getRandomUid"], "secure": ["encrypted", "force", "service", "stable", "depth", "sensitive", "debug", "deep", "Secure", "active", " insecure", "zip", "sec", "random", "remote", "use", "protect", "safe", "session", "external", "pure", "confirmed", "weak", "require", "https", "allow", "ce", "secret", "ssl", "unsigned", "secondary", "proxy", "sr", "smart", "server", "seed", "exclusive", "security", "timeout", "config", "host"], "md5": [" mdql", "MD512", " md500", "MD500", "MD5", " MD500", " MD2", "md512", "cmd5", " md512", "md2", " md2", "mdql", " MD5", "MDql", "md11", " md3", "MD3", "MD2", "md500", "cmdql", "MD11", " MD11", " MD3", "cmd512", " md11", "cmd3", "md3"], "sbValueBeforeMD5": ["sbValueBeforeMS0", "sbValuebeforeSD20", "sbValueGivenmd5", "sbValueBeforeSHA005", "sbValueBeforeMAC0", "sbValueBeforeMS3", "sbValueBeforeMAC55", "sbValueBeforeMI5", "sbValueBeforeMD3", "sbValueBeforeMD20", "sbValueAfterMP3", "sbValueBeforeDER1", "sbValueBeforeD3", "sbValueBeforeSD20", "sbValueGivenmd375", "sbValuebeforeMD5", "sbValueBeforeMD7", "sbValueBeforeMC5", "sbValueAfterMS0", "sbValueBeforeMS95", "sbValuebeforeSD1", "sbValueAfterMD20", "sbValueBeforeMI3", "sbValueAfterMD25", "sbValueGivenMD3", "sbValuebeforeSD5", "sbValueBeforeAMD3", "sbValueBeforeMD512", "sbValueAfterMD65", "sbValueBeforeAMD5", "sbValueBeforeMS512", "sbValueBeforemd3", "sbValueBeforeMP5", "sbValueBeforeDER005", "sbValueAfterMS65", "sbValueBeforeMD005", "sbValueAfterMS20", "sbValueAfterMS25", "sbValueBeforeMS75", "sbValueBeforeSD005", "sbValueAfterMS5", "sbValueBeforeMI7", "sbValueAfterMD3", "sbValueBeforeMD0", "sbValueBeforeMP3", "sbValueBeforeDER3", "sbValueBeforemd375", "sbValueBeforeMD55", "sbValueBeforeMD25", "sbValueBeforemd65", "sbValueAfterMS1", "sbValueGivenmd3", "sbValueBeforeMR3", "sbValueBeforemd512", "sbValueAfterMD1", "sbValueBeforeMS375", "sbValueBeforeAMD20", "sbValuebeforeMD1", "sbValueBeforeMD65", "sbValueAfterMD55", "sbValueBeforeDER55", "sbValueBeforeMD75", "sbValueBeforeSHA20", "sbValueBeforeDER0", "sbValueBeforeMD95", "sbValueAfterMP5", "sbValuebeforeSD005", "sbValueBeforeDER5", "sbValueBeforeMP7", "sbValueBeforeD65", "sbValueAfterMS95", "sbValueAfterMS55", "sbValueGivenmd512", "sbValueBeforeSD5", "sbValueAfterMD75", "sbValueBeforeAMD1", "sbValueBeforeMI1", "sbValueBeforeMS5", "sbValueBeforeMI20", "sbValueBeforeSHA5", "sbValueBeforemd75", "sbValueBeforeMS20", "sbValueBeforeMR25", "sbValueAfterMP1", "sbValueAfterMS75", "sbValueBeforeMR5", "sbValueBeforeSD1", "sbValueBeforeMP1", "sbValueBeforemd95", "sbValueBeforeMD1", "sbValueAfterMP7", "sbValueBeforeMAC5", "sbValueBeforeSHA1", "sbValueBeforeMC512", "sbValueBeforemd25", "sbValueBeforeMC375", "sbValueAfterMD0", "sbValueBeforeD5", "sbValueGivenMD375", "sbValueBeforeDER20", "sbValueBeforemd5", "sbValueAfterMS3", "sbValuebeforeMD20", "sbValueGivenMD5", "sbValueBeforeD75", "sbValuebeforeMD005", "sbValueBeforeMS65", "sbValueBeforeMS55", "sbValueBeforeMS25", "sbValueAfterMD7", "sbValueBeforeMD375", "sbValueAfterMD5", "sbValueBeforeMAC3", "sbValueBeforeMS1", "sbValueBeforeMR95", "sbValueBeforeMC3", "sbValueAfterMD95", "sbValueGivenMD512", "sbValueBeforeMS7"], "time": ["Time", "depth", "offset", "event", "cost", "duration", "version", "mode", "count", "times", "random", "slice", "rate", "speed", "race", "tz", "clock", "TIME", "work", "type", "year", "counter", "length", "size", "start", "name", "ime", "tim", "id", "user", "seed", "money", "value", "error", "etime", "date", "timeout", "timer", "delay", "hour", "loc", "host"], "rand": ["rule", "index", "right", "q", "depth", "root", "bot", "order", "pick", "serial", "version", "alpha", "count", "round", "bit", "random", "rate", "chance", "risk", "r", "rage", "ro", "rc", "winner", "lang", "type", "year", "Rand", "rr", "rh", "min", "raid", "clean", "mid", "id", "range", "seed", "gen", "error", "win", "ng", "rank", "delay", "reg", "rol", "res", "cr", "max"], "valueBeforeMD5": ["valueInsideMD85", "valueBeforeAMD5", "valueBeforeMC5", "valueAfterMD2", "valueBeforeMD2", "valueInsideMD3", "valueBeforemd5", "valueBeforeMD53", "valueBeforeAMD3", "valueInsideMD2", "valueAfterAMD3", "valueBeforemd3", "valueBeforeMP3", "valueBeforemd2", "valueAfterMD53", "valueBeforeMD3", "valueAfterMD3", "valueBeforeMC3", "valueBeforeMC2", "valueBeforeAMD2", "valueAfterAMD53", "valueBeforeMD85", "valueBeforemd85", "valueAfterAMD2", "valueInsideMD5", "valueAfterAMD5", "valueBeforeMP53", "valueBeforeMC85", "valueBeforeAMD53", "valueBeforeMP5", "valueBeforeMP2"], "array": ["image", "shape", "section", "storage", "view", "integer", "sample", "audio", "arr", "function", "our", "message", "cache", "pair", "area", "api", "list", "object", "string", "element", "collection", "vector", "Array", "record", "result", "allow", "number", "row", "any", "expression", "app", "arrow", "ray", "archive", "range", "data", "binary", "instance", "value", "error", "angle", "database", "feature", "batch", "air", "address"], "sb": ["ib", "wb", "nb", "bsp", "kb", "bm", "lr", "eb", "zb", "bl", "SB", "sa", "xb", "src", "bb", "cb", "ruby", "usb", "bp", "lp", "buf", "gb", "abb", "buffer", "stab", "fb", "lb", " SB", "bf", "rob", "si", "obb", "sg", "sv", "nn", "sq", "orb", "pb", "bt", "lab", "bs", "ob", "binary", "sbm", "sf", "sth", "sl", "rb", "mb", "bc", "bh", "bj", "BB", "ab", "s"], "j": ["z", "aj", "num", "index", "o", "q", "end", "jl", "ii", "dy", "key", "l", "ch", "jp", "js", "pr", "code", "c", "uj", "g", "d", "k", "li", "job", "ie", "p", "part", "ja", "v", "x", "ji", "out", "y", "length", "jj", "jo", "J", "e", "adj", "i", "ij", "n", "bj", "br", "f", "obj"], "b": ["ib", "nb", "BB", "eb", "bit", "l", "bb", "bin", "cb", "c", "d", "k", "be", "fb", "job", "p", "lb", "bi", "x", "y", "B", "bug", "orb", "pb", "bar", "a", "bs", "ob", "binary", "e", "i", "rb", "mb", "n", "bc", "bf", "br", "db", "f", "ab"], "valueAfterMD5": ["valueAfterMD2", "valueAfterVM5", "valueAfterMP2", "valueBeforeMD2", "valueAfterAMD7", "valueAfterMP7", "valueAfterAMD3", "valueAfterVM7", "valueAfterMD7", "valueBeforeMP3", "valueAfterVM3", "valueBeforeMD3", "valueBeforeMD7", "valueAfterMD3", "valueAfterVM2", "valueBeforeMP5", "valueAfterMP5", "valueAfterAMD2", "valueAfterAMD5", "valueBeforeMP7", "valueAfterMP3", "valueBeforeMP2"]}}
{"id1": "15445861", "id2": "23467091", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public void listen() {\n        String url = \"http://\" + host + \":\" + LISTEN_PORT;\n        HttpURLConnection conn = null;\n        while (true) {\n            try {\n                conn = (HttpURLConnection) (new URL(url).openConnection());\n            } catch (Exception e) {\n                error(\"Could not connect to \" + url + \".\", e);\n                return;\n            }\n            BufferedInputStream in = null;\n            try {\n                conn.connect();\n                in = new BufferedInputStream(conn.getInputStream(), LISTEN_BUFFER);\n                event(\"Connected to stream at \" + url + \".\");\n            } catch (Exception e) {\n                error(\"Could not get stream from \" + url + \".\", e);\n                return;\n            }\n            try {\n                byte[] data = new byte[LISTEN_BUFFER];\n                for (int i = 0; i < delay; i++) {\n                    in.read(data);\n                }\n            } catch (Exception e) {\n                error(\"Stream unexpectedly quit from \" + url + \".\", e);\n                return;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", " copyDirectory", "transferFile", "transferDirectory", "CopyFile", " copyfile", "Copyfile", "copyfile", "CopyDirectory", "copyFiles", "copyDirectory", "CopyFiles"], "srcFile": ["sourceDirectory", " srcPath", "srcDir", "rcFiles", "rcFile", "sourceDir", "destTime", "srcFiles", "srcDirectory", "srcStream", "rcTime", "rcPath", "ourceTime", "destDirectory", "sourcePath", "destDir", " srcFiles", "rcDir", "supfile", " srcDir", " srcStream", "sourceFile", " srcfile", "srcPath", "sourcefile", "srcTime", "rcDirectory", " srcDirectory", "srcPlace", "supStream", "supFile", "srcfile", "ourcePlace", "rcPlace", "rcfile", " srcTime", "ourcePath", "rcStream", "supPath", "sourceFiles", " srcPlace", "ourceFile"], "destFile": ["sourceDirectory", " destTime", "tempFile", "DestFile", "vertFile", "targetPath", "tempfile", "endTime", "vertPath", "destFilename", "destTime", "targetFilename", "stdTime", "vertFiles", "stdFile", "endFile", "DestPath", "destDirectory", "destfile", " destFilename", " destFiles", "inationFiles", " destfile", "inationPath", "stdDirectory", "DestFiles", " destPath", "tempFiles", "sourceFile", "sourcefile", "targetFile", "targetTime", "tempPath", "destFiles", "endFilename", "inationFile", "vertFilename", "destPath", " destDirectory", "sourceTime", "inationFilename", "Destfile", "endPath", "DestFilename", "stdfile"], "in": ["ini", "image", "kin", "base", "login", "serv", "inner", "inn", "gin", "input", "In", "up", "bin", "b", "url", "read", "pin", "r", "IN", "again", "source", "nin", "io", "cin", "min", "pull", "ins", "is", "as", "init", "a", "inside", "ac", "h", "con", "id", "isin", "rin", "ex", "i", "win", "reader", "get", "or", "m", "din", "f", "socket", "inc"], "out": ["err", "base", "o", "other", "inner", "gin", "to", "w", "net", "obj", "up", "exp", "cache", "sync", "output", "OUT", "writer", "conn", "bin", "again", "pass", "outs", "work", "line", "io", "by", "Out", "client", "off", "ext", "user", "file", "parent", "ex", "one", "n", "inc", "exec", "socket"], "buffer": ["base", "wave", "feed", "offset", "flush", "input", "channel", "slice", "queue", "b", "bytes", "read", "null", "buf", "position", "buff", "border", "padding", "uffer", "phrase", "result", "layer", "block", "length", "size", "memory", "pause", "server", "data", "variable", "binary", "document", "transfer", "limit", "reference", "reader", "iter", "batch", "source", "Buffer", "url", "header", "address"], "no": ["num", "index", "o", "nor", "nt", "to", "po", " mo", " number", "none", "which", "nothing", "mo", " lo", "info", "auto", "pos", "so", "from", "wa", "was", "maybe", "type", " NO", "io", "nos", "os", "No", "x", "number", "nr", "yes", "na", "off", "only", "size", "ino", "ko", "co", "data", "id", "lo", "error", "zero", "i", "go", "eno", "NO", " none"]}}
{"id1": "397240", "id2": "6501291", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewrites", "readAndRebwrite", "readandrewrite", "readAndSwwrite", "readAndRewwrite", "readAndSwrap", "readAndSwrite", "readandRewrite", "readAndrewrap", "readAndRewrap", "readAndRebrites", "readandrewwrite", "readAndRebrap", "readandRewrap", "readandRewrites", "readAndSwrites", "readandrewrites", "readAndrewrite", "readAndrewwrite", "readAndRebrite", "readandRewwrite", "readAndRewrites", "readandrewrap"], "inFile": ["inFilename", "loginFile", "outFilename", "inputfile", "InFiles", "InFile", " inFiles", "oldFile", "loginFilename", " inSourceFile", "outSourceFile", "InSourceFile", "inputFiles", "outFiles", "oldFiles", " inFilename", "loginFiles", "inputFile", "inSourceFile", "loginfile", "outfile", " infile", "inputFilename", "inFiles", "oldfile", "infile", "oldFilename", "Infile"], "outFile": [" outStream", "offPlace", "outFilename", " outDir", "outputPlace", "outFILE", "OutStream", "outputFilename", "newDir", " outfile", "thisFILE", "outputFile", "offFile", "outDir", "processFilename", "exfile", "exFILE", "newfile", "processPlace", "thisFile", "processFILE", "thisfile", "offFilename", "thisFilename", "outStream", "outPlace", "newFile", "exFile", "exFilename", "outfile", "outputfile", "OutFile", "outputFILE", "OutDir", "offFILE", "processFile", "newStream", "Outfile"], "iis": ["iniis", "Iiss", "iiIs", "iiIS", " iIS", " iIs", "iIs", "iniiss", "ciiss", "ciis", "Iis", "Iais", " iris", "IIS", "ciais", "ciIs", "iiss", "ciris", "iniIS", "iniIs", "iiris", "iiis", "iiiss", "ciIS", "iniris", "iais", " iiss", "iris", "iIS", " iais"], "dcmParser": ["dcmHelper", "dpmarser", "dmcPar", "dmoduleJar", "dmcJar", "dcmPar", "dbmPolicy", "dCMPlugin", "dmoduleParser", "dcmJar", "fcmHandler", "dcrPar", "fpmParser", "dmcarser", "dpmparser", "dbmHelper", "dmissionReader", "dpmLoader", " dpmLoader", "dcrReader", "dbmPlugin", "dCMParser", "dmoduleparser", "dpmPolicy", " dcrParser", "dmPlugin", "dkmHelper", "DcmInstallation", "dmmParser", "dcmparser", " dpmPolicy", " dcmPlugin", "dcmLoader", " dpmHelper", "dmLoader", "dhemReader", "dcmarser", "dpmHelper", "dbmParser", "fpmHandler", "dpmHandler", "dhemParser", "dcrJar", "dpmJar", " dcmLanguage", "fcmParser", "dcrarser", "dcmPolicy", "dkmParser", "dpmInstallation", " dpmJar", "dmodulePlugin", "dmmparser", "dcmLanguage", "dhemInstallation", "dcmInstallation", "fpmparser", "dpmParser", " dpmparser", " dcmPar", "dcmHandler", "dcrPlugin", "dmcParser", " dcmparser", "dcmReader", " dcrReader", "fcmReader", "DcmReader", " dpmPlugin", "dCMparser", "dpmLanguage", " dpmReader", "dmParser", "dmoduleReader", "dmissionPlugin", "dhemJar", " dpmPar", " dcrLoader", "dpmPar", "fpmReader", "dcrParser", "DcmJar", "dmissionParser", " dcmReader", "dCMHandler", "dpmPlugin", " dpmarser", " dpmLanguage", "dmmPlugin", " dcmarser", "dkmPolicy", " dcmHelper", " dcmLoader", "fcmparser", "dpmReader", " dpmParser", "dmReader", " dcmJar", " dcrPlugin", "dCMReader", "dmmLoader", "DcmParser", " dcmPolicy", "dkmPlugin", "dcmPlugin", "dCMLoader", "dcrLoader", "dmissionLanguage"], "ds": ["dd", "dr", "vals", "des", "ants", "os", "vs", "dc", "amps", "dat", "utils", "DS", "ls", "services", "details", "Ds", "ads", "src", "ns", "points", "sync", "ld", "conn", "js", "ws", "da", "ts", "ays", "cdn", "xs", "ps", "session", "d", "ils", "Db", "dt", "ros", "Os", "tes", "cs", "df", "uds", "dds", "ras", "eps", "gd", "ins", "iss", "qs", "is", "rs", "ys", "gs", "icks", "nas", "bs", "data", "sys", "pd", "ss", "tx", "ks", "di", "asi", "db", "parts", "drivers", "s"], "pdReader": ["ddRunner", "hdWriter", "hdLoader", "xdRead", "hdStream", "pcLoader", "pdStream", "pbLoader", "dsLoader", "pbReader", "ddLoader", "pcRead", "ddReader", "pdreader", "xdWriter", "hdReader", "hdRunner", "hdreader", "pbRunner", "ddStream", "pcWriter", "dsreader", "pdLoader", "pbStream", "dsReader", "xdReader", "hdRead", "pdRead", "pcReader", "dsRead", "xdreader", "pdRunner", "dsWriter"], "out": ["flow", "her", "model", "temp", "group", "list", "full", "page", "null", "again", "result", "img", "layer", "name", "file", "lib", "connection", "parent", "s", "device", "in", "o", "login", "outer", "child", "point", "to", "write", "cli", "over", "cache", "sync", "output", "OUT", "password", "conn", "auto", "builder", "code", "session", "pass", "outs", "doc", "io", "Out", "co", "sys", "user", "down", "copy", "err", "base", "inner", " in", "at", "exp", "later", "object", "array", "external", "line", "diff", "client", "ssl", "term", "ext", "data", "gen", "lock", "ex", "default", "inc", "db", "exec", "obj", "image", "dev", "w", "order", "with", "net", "up", "key", "writer", "store", "oder", "part", "director", "manager", "as", "word", "dot", "url"], "dcmEncParam": ["dcmEnParam", "dcmArchArg", "dcmEnPar", "dcmEnArg", "dcmDecParam", "dcmDecType", "dcmDecArg", "dcmElType", "dcmArchParameter", "dcmEncArg", "dcmEnPart", "dcmElPar", "dcmArchParam", "dcmEncType", "dcmSecParam", "dcmEnType", "dcmDecPar", "dcmEstParameter", "dcmDecParameter", "dcmEncPart", "dcmEncParameter", "dcmEstPar", "dcmEncPar", "dcmElParam", "dcmEnParameter", "dcmElParameter", "dcmEstParam", "dcmSecType", "dcmDecPart", "dcmSecPar", "dcmEstType", "dcmSecPart"], "pdWriter": ["htReader", "ddOutput", "htWriter", "hdWriter", "dpWriting", "htWrite", "dsOutput", "PDWrite", "PDWriter", "ddWrite", "ddReader", "hdReader", "pdOutput", "pdWrite", "dpReader", "dsWrite", "ddWriter", "PDReader", "PDWriting", "hdWrite", "dsReader", "pdWriting", "hdOutput", "dpWrite", "dpWriter", "dsWriter", "htWriting"]}}
{"id1": "2017833", "id2": "22708533", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    public static void insertDocumentToURL(String file, String target) throws IOException {\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(file);\n            final URL url = new URL(target);\n            final URLConnection connection = url.openConnection();\n            os = connection.getOutputStream();\n            TestTools.copyStream(is, os);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (os != null) {\n                os.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"hash": ["sha", "html", "base", "create", "hex", "check", "format", "transform", "parse", "message", "add", "replace", "update", "print", "string", "set", "crypt", "build", "number", "block", "ash", "Hash", "sum", "dump", "h", "str", "get"], "text": ["image", "letter", " Text", "hex", "content", "format", "input", "pattern", "version", "message", "key", "output", "password", "bytes", "object", "struct", "string", "txt", "code", "class", "font", "contract", "buffer", "Text", "token", "path", "template", "source", "translation", "number", "out", " TEXT", "secret", "length", "context", "name", "EXT", "test", "ext", "word", "data", "binary", "str", "value", "TEXT", "url", "editor"], "UnsupportedEncodingException": ["UnsupportedEncgorithmception", "UnsupportedEncasingException", "UnsupportedEncodedWarning", "UnsupportedEncodedException", "UnsupportedEncasingWarning", "UnsupportedEncasingception", "UnsupportedEncodingWarning", "UnsupportedEncgorithmException", "UnsupportedEncodingception", "UnsupportedEncgorithmWarning", "UnsupportedencodedException", "UnsupportedEncodedception", "Unsupportedencodingception", "UnsupportedencodingWarning", "UnsupportedencodingException", "UnsupportedencodedWarning", "Unsupportedencodedception"], "md": ["dd", "nm", "sha", "cmd", "bm", "am", "dig", "metadata", "amd", "ma", " MD", "um", "hd", "mm", "mad", "mo", "message", "ms", "ld", "wd", "mp", "vd", "mand", "d", "m", "ind", "bd", "ad", "ds", "pm", "mt", "mg", "mac", "gd", "od", "MD", "mod", "mag", "rm", "dm", "mc", "f", "mb", "hm", "bf", "meta"], "sha1hash": ["sha3hash", "sha2match", "sha4sum", "sha256h", "sha3hex", "shaonehex", "ha1hex", "sha5h", "SHA1hash", "sha1h", "SHA2hash", "shaonehash", "ha2hex", "sha256Hash", "sha256hash", "sha2sum", "SHA1h", "sha4Hash", "ha2sum", "sha5hash", "SHA1hex", "SHA1Hash", "ha1hash", "sha3sum", "sha4hex", "sha2hex", "sha5hex", "sha4hash", "sha2Hash", "SHA1sum", "sha5Hash", "shaonematch", "SHA2Hash", "sha3match", "sha2hash", "shaonesum", "ha1sum", "sha1hex", "sha2h", "ha2match", "sha5sum", "sha1sum", "sha1Hash", "sha256sum", "ha1match", "SHA2h", "sha1match", "ha2hash", "SHA2sum"]}}
{"id1": "19113613", "id2": "8754809", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["create", "change", "clone", "share", "download", "write", "paste", "zip", "cop", "load", "process", "sync", "replace", "Cop", "cat", "update", "clip", "split", "p", "type", "upload", "ssh", "opy", "archive", "Copy", "transfer", "rm", "put", "move", "delete", "get", "cp", " cp", "save"], "in": ["ini", "image", "kin", "plugin", "base", "login", "index", "this", "inner", "inn", "input", "din", "In", "bin", "update", "c", "pin", "IN", "again", "token", "ic", "work", "part", "cin", "sin", "min", "diff", "client", "ins", "lin", "as", "name", "init", "inside", "a", "thin", "id", "data", "on", "i", "reader", "old", "n", "win", "get", "connection", "config", "project", "f", "url", "inc"], "out": ["err", "image", "base", "o", "outer", "other", "resource", "point", "self", "root", "this", "outside", "project", "input", "with", "net", "at", "version", "up", "group", "cache", "output", "OUT", "remote", "bin", "conn", "b", "object", "page", "null", "option", "c", "external", "again", "outs", "path", "work", "goal", "p", "part", "line", "io", "v", "x", "Out", "client", "block", "off", "app", "init", "name", "ext", "user", "vert", "parent", "call", "ex", "no", "dot", "n", "one", "connection", "inc", "exec", "obj"], "source": ["origin", "force", "unit", "base", "service", "resource", "SOURCE", "site", "prefix", "view", "Source", "direction", "format", "src", "use", "scope", "status", "class", "pe", "from", "position", "subject", "route", "family", "type", "ource", "attribute", "uri", "sin", "dest", "ce", "secret", "secure", "size", "missing", "name", "internal", "proxy", "component", "id", "reference", "alt", "parent", "username", "feature", "iter", "project", "url"], "target": ["origin", "force", "base", "service", "resource", "site", "detail", "config", "prefix", "root", "current", "point", "alias", "direction", "format", "wrong", "pattern", "Target", "top", "master", "src", "output", "cat", "home", "null", "about", "tail", "route", "token", "path", "next", "goal", "dest", "name", "host", "component", "reference", "alt", "parent", "value", "arget", "template", "project", "url", "address"], "files": ["resources", "ports", "objects", "keys", "flows", "lines", "ls", "plugins", "links", "children", "sections", "filename", "blocks", "tools", "iles", "apps", "groups", "obs", "images", "Files", "ions", "cells", "jobs", "items", "fs", "ins", "users", "models", "features", "docs", "pages", "data", "classes", "names", "assets", "results", "f", "s"], "file": ["File", "folder", "letter", "unit", "base", "resource", "child", "feed", "current", "function", "ile", "entry", "fe", "load", "local", "filename", "l", "b", "object", "page", "url", "string", "future", "item", "path", "single", "line", "part", "uri", " File", "it", "entity", "fp", "layer", "dir", "FILE", "le", "name", "live", "data", "id", "binary", "e", "el", "per", "lib", "parent", "f", "directory"], "inCh": ["InCh", "inch", "inChan", "InChan", " inChannel", " inch", "outCH", " inChan", "INCh", "outChan", "outChannel", " inCH", "INChan", "inChannel", "Inch", "INCH", "InChannel", "INChannel", "InCH", "inCH", "outch"], "outCh": ["inch", "inChan", " outChannel", "OutCH", "outputChan", "outCH", " outch", "outChan", "outputch", "Outch", "outChannel", "OutChannel", " outCH", "inChannel", "OutCh", "outputCH", "inCH", "OutChan", "outputCh", "outch"]}}
{"id1": "5061606", "id2": "5237257", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNequccessarily", "createSettingsIfNecesseless", "createSettingsIfNeceseless", "createSettingsIfNecesarily", "createSettingsIfNececnecessary", "createSettingsIfNequccessary", "createSettingsIfNequessnecessary", "createSettingsIfNecccesseless", "createSettingsIfNequccessnecessary", "createSettingsIfNecessnecessary", "createSettingsIfNecccessarily", "createSettingsIfNecccessary", "createSettingsIfNequesseless", "createSettingsIfNecesary", "createSettingsIfNececary", "createSettingsIfNequccesseless", "createSettingsIfNecessarily", "createSettingsIfNequessarily", "createSettingsIfNecesnecessary", "createSettingsIfNececarily", "createSettingsIfNequessary", "createSettingsIfNececeless", "createSettingsIfNecccessnecessary"], "out": ["err", "image", "log", "model", "pool", "o", "index", "prefix", "this", "flush", "write", "plain", "net", "at", "channel", "window", "up", "group", "cache", "sync", "output", "OUT", "password", "bin", "conn", "writer", "object", "page", "url", "null", "array", "exit", "again", "outs", "path", "io", "result", "by", "Out", "client", "cookie", "off", "app", "socket", "init", "name", "a", "server", "data", "file", "user", "parent", "lock", "error", "ex", "i", "timeout", "connection", "config", "source", "exec", "plugin", "obj", "copy", "editor"], "fSettings": ["fsConfig", "FJs", "rfFs", "filesettings", "FConfig", "fConfig", "fettings", "FSetting", "sfettings", "rfSettings", "fmSetting", "fmConfig", "fmSettings", "fsSettings", "FSetup", " fFs", " fConfig", "FSettings", "rfConfig", "fsSetting", "Fsettings", "fJs", "sfsettings", "sfSettings", "fFs", " fSetting", "fileSetting", "fSetting", "fmSetup", " fsettings", "fsFs", " fJs", "fsettings", "sfSetting", "fileSettings", "fileettings", "fsSetup", "fSetup", "sfJs", "rfSetting", " fettings"], "src": ["base", "sub", "storage", "stream", "cur", "req", "ref", "text", "filename", "b", "ctr", "cb", "prot", "string", "gb", "dist", "route", "rc", "path", "st", "sc", "settings", "ource", "uri", "sb", "dest", "attr", "img", "fp", "ins", "tmp", "ssl", "sr", "sel", "loc", "file", "str", "sl", "rb", "lower", "uc", "config", "source", "url"], "in": ["ini", "image", "err", "kin", "index", "login", "stream", "inner", "gin", "inn", "input", "din", "In", "inc", "l", "bin", "b", "c", "IN", "r", "again", "path", "source", "ins", "init", "thin", "con", "data", "file", "rin", "id", "i", "win", "reader", "n", "connection", "sin", "f", "url", "copy", "s"]}}
{"id1": "18097962", "id2": "8079516", "code1": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 0, "substitutes": {"getVersion": ["parseVersion", " getVersions", "getRelease", "showVersions", "parseVersions", "parseRelease", " getVERSION", "showVERSION", "getVERSION", "showRelease", " getRelease", "getVersions", "parseVERSION", "showVersion"], "version": ["image", "action", "model", "ver", "versions", "unit", "resource", "section", "latest", "content", "format", "vision", "text", "message", "output", "python", "info", "object", "update", "string", "option", "status", "driver", "element", "position", "array", "Version", "type", "line", "result", "build", "v", "VERSION", "secret", "bug", "name", "ception", "language", "server", "vert", "instance", "value", "description", "feature", "comment", "source", "project", "install", "release", "cover"], "version_url": ["versioningurl", "ver_file", "ver_url", "version_resource", "version_str", "ver_Url", " version_str", "version_URL", " version_feed", "version_feed", " version_URL", "version_file", "versioningUrl", "versioningfile", "version_Url", "ver_resource", "versioningresource"], "url": ["log", "URL", "base", "resource", "fr", "www", "stream", "cl", "Url", "download", "open", "ls", "channel", "http", "zip", "l", "api", "conn", "bb", "page", "c", "bel", "fl", "uri", "client", "socket", "ssl", "server", "file", "ll", "sl", "rl", "connection", "host", "web", "f"], "con": ["enc", "log", "conv", "login", "stream", "coll", "plain", "open", "cur", "pc", "channel", "Connection", " conn", "http", "fc", "l", "ch", "conn", "b", "bin", "un", "CON", "ran", "c", "IN", "rc", "en", "Con", "ins", "cos", "pub", "close", "socket", "init", "co", "ln", "cn", "connect", "Conn", "win", "uc", "connection", "inc", "exec", "f"], "in": ["ini", "kin", "login", "fac", "impl", "stream", "inner", "inn", "gin", "input", "In", "hel", "rec", "bin", "conn", "b", "c", "pin", "r", "IN", "again", "nin", "cin", "out", "ins", "is", "lin", "as", "init", "ssl", "data", "file", "rin", "on", "isin", "ex", "reader", "i", "connection", "din", "f", "inc", "s"], "inputLine": ["tempLine", "InputLine", "inputValue", "Inputline", "inputStream", " inputPart", "InputFile", " inputStream", "outputline", "rawValue", " inputL", "inputline", " inputValue", "InputL", "InputPart", "inputPart", "inputFile", "templine", "rawL", " inputFile", "outputLine", "InputValue", " inputline", "rawLine", "inputL", "tempStream", "outputStream", "rawline", "outputPart", "outputFile"]}}
{"id1": "2022160", "id2": "5759961", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "label": 0, "substitutes": {"write": ["writing", "flow", "written", "wrote", "service", "create", "send", "feed", "end", "flush", "w", "open", "run", "process", "play", "output", "sync", "add", "writer", "update", "read", "set", "code", "export", "store", "next", "Write", "out", "size", "close", "cycle", "dump", "data", "call", "connect", "put", "writ", "pipe", "kill", "lex", "exec", "append", "copy"], "byteBuffers": ["byteCompares", "bytesPackERS", "byteCornests", "bytebuffiners", "byteBuilderers", "byteOffers", " byteBuffERS", " byteCompares", "bytesBuffered", "byteOrdapers", "byteInfERS", "byteIntegelines", "bytebuffters", "byteCompers", "ByteOrdresses", "bytesDefers", "bytebuffinals", "byteBuffors", "byteBufferelines", " byteOffERS", " byteBuffors", "byteInferers", "bytesCornatters", "byteAkelines", "byteIntegers", "bytebufferers", "byteIntegatters", "byteDefERS", "byteOrderers", "wordBufferers", "byteCornlers", "bytesPackapers", "byteWritizers", "byteDefers", "byteBufferers", "bytesDefatters", " byteOffors", "byteWritlers", "bytesBuffests", " byteBuffiners", "byteChered", "byteAkizers", "byteBuffapers", "byteWritelines", "byteOrdresses", "bytebuffizers", "connectionBuffERS", "byteBuffinals", "connectionbuffERS", "byteChERS", " byteBuffeners", "byteBuffered", "byteComplers", "byteBuildERS", "byteBuffizers", "connectionBuffeners", "connectionBufferers", "byteBuffings", " byteBufferers", "bytesBuffERS", "ByteOrdERS", "byteBuffeners", "bytesCornests", "ByteOrders", "ByteOrderers", "bytesCorners", "byteBuffresses", "bytebuffers", "byteBuffererers", "byteBufflers", "byteHeadERS", "bytesBuffapers", " byteBuffinals", "byteCornatters", "byteOrdeners", "byteOrders", " byteOrdiners", "byteOrdiners", "ByteBufferers", "bytebuffests", "doubleHeadings", " byteBuffares", " byteOffters", "byteBuffereners", " byteOrders", "byteWritiners", "byteCompERS", "bytesBuffers", "byteBuffERS", " byteOrderers", "byteBuffests", "byteDefelines", "bytePackapers", "byteWriterers", "byteCornERS", "byteHeadings", "bytebuffelines", "doubleBuffered", "bytesDefelines", "ByteBufflers", " byteComplers", "byteAkers", " byteOrdeners", " byteBufflers", "wordBuffers", "bytesBuffatters", "byteBufferatters", "byteBuffelines", "bytesBuffelines", "byteHeaders", "ByteBuffERS", "bytebuffERS", "byteOrdinals", "connectionbufferers", " byteBuffters", "byteOffters", "byteBufferapers", "bytesAkelines", "byteHeadered", "byteIntegeners", "doubleBuffERS", "bytebufflers", " byteOffers", "bytebuffings", "byteOffERS", "byteInfers", "bytesPackerers", "byteWriters", " byteOrdinals", "byteChings", "bytesCornered", "bytesBufferers", "byteCornered", "bytesAkizers", "byteIntegERS", "ByteBuffresses", "doubleHeadERS", "bytesAkors", " byteCompers", "ByteBuffers", "connectionBuffers", "bytesPackers", "byteBufferlers", "bytePackerers", "bytebuffered", "wordBuffERS", "bytebuffresses", "byteOffors", "doubleHeaders", "doubleHeadered", " byteOrdERS", "byteDefatters", "bytebuffatters", " byteCompERS", "byteWritors", "bytebuffors", "byteInfatters", "byteChers", "byteBuilders", "bytePackERS", "byteBuffters", "byteBufferERS", "connectionbuffers", "connectionbuffeners", "byteCorners", "bytePackers", "bytesBuffors", "byteCornares", "bytesAkers", "byteOrdERS", "byteAkors", "bytesBuffizers", "byteBuffiners", "byteBuffares", "bytebuffeners", "bytesDefERS", " byteOrdlers", "byteBuffatters", "byteOrdlers", "doubleBuffings", "wordBuffatters", "byteBuildatters", "doubleBuffers", "byteInteginals"], "m_initialOutBuffer": ["m_initialoutLine", "m_initialInChannel", "m_InitialOutputBuffer", "m_finaloutChannel", "m_initialoutBuffer", "m_finalOutBuffer", "m_initialOutMessage", "m_initialInLine", "m_initialClientBuffer", "m_finalOutLine", "m_initialOutBuff", "m_finalInCache", "m_finaloutBuff", "m_initialNewMessage", "m_finalInBuffer", "m_initialAuthAddress", "m_initialAuthLine", "m_initialOutFile", "m_initialInFile", "m_originaloutFile", "m_InitialOutFile", "m_initialOutputLayer", "m_finaloutBuffer", "m_initialInBuffer", "m_initialOutputMessage", "m_initialOutLine", "m_finalOutMessage", "m_initialInMessage", "m_initialSocketBuffer", "m_finalInMessage", "m_originalOutLine", "m_initialNewBuffer", "m_InitialOutBuffer", "m_initialoutAddress", "m_initialOutLayer", "m_finalInFile", "m_initialSocketLayer", "m_initialInLayer", "m_originalOutFile", "m_initialShortFile", "m_InitialOutputFile", "m_originaloutLine", "m_initialoutCache", "m_initialOutChannel", "m_initialShortBuffer", "m_finalOutFile", "m_initialShortCache", "m_initialClientLine", "m_initialNewBuff", "m_finalOutChannel", "m_initialSocketHeader", "m_InitialOutputLayer", "m_InitialOutHeader", "m_originalOutBuffer", "m_initialClientFile", "m_initialoutFile", "m_initialOutputFile", "m_initialInAddress", "m_finalOutCache", "m_initialClientBuff", "m_initialOutputChannel", "m_initialInHeader", "m_initialShortChannel", "m_originaloutAddress", "m_finalOutBuff", "m_originaloutBuffer", "m_initialInBuff", "m_initialSocketFile", "m_initialAuthBuffer", "m_finalInLine", "m_initialOutHeader", "m_initialOutputHeader", "m_initialOutAddress", "m_initialAuthFile", "m_initialOutCache", "m_initialNewFile", "m_originalOutAddress", "m_initialOutputBuff", "m_finalInBuff", "m_initialInCache", "m_InitialOutputHeader", "m_finalInChannel", "m_initialoutChannel", "m_InitialOutLayer", "m_initialoutBuff", "m_initialOutputBuffer", "m_finaloutFile"], "buffer": ["resource", "temp", "window", "channel", "stack", "queue", "page", "null", "layer", "block", "file", "binary", "limit", "comment", "source", "f", "pool", "wave", "flush", "input", "cur", "cache", "slice", "output", "bridge", "table", "engine", "builder", "string", "read", "phrase", "response", "loader", "server", "document", "reader", "timeout", "console", "template", "Buffer", "header", "copy", "re", "base", "event", "worker", "shell", "object", "array", "fb", "uffer", "er", "row", "client", "FFER", "data", "port", "callback", "batch", "address", "feed", "view", "ker", "message", "back", "writer", "buf", "buff", "cell", "transfer", "iter", "bc", "config", "url", "holder"], "buffers": ["Buffers", "buffered", "bufaches", " buffars", "bufered", "buffors", "phresses", " buffler", "buffler", "Bufferers", "bufars", "affers", "buferers", "bufers", "affaches", " buffering", "ufors", "ufers", "buffages", "phers", "bufering", "bufresses", " buffresses", "bufERS", "buffering", "bufators", " buffages", "transformler", "transformering", "buffators", "Buffered", "buffaches", "affors", "ufaches", "transformers", "ufering", "Buffars", "buffERS", " buffERS", "phages", "phators", " buffators", "bufages", "buffresses", "transformERS", "bufler", " bufferers", "bufors", "affering", " buffered", "bufferers", "buffars"], "result": ["re", "err", "ver", "resource", "Result", "view", "inner", "event", "val", "function", "json", "grade", "match", "consumer", "or", "up", "cache", "message", "use", "output", "rate", "info", "status", "driver", "future", "flash", "r", "session", "rc", "success", "successful", "winner", "er", "ret", "diff", "out", "response", "row", "manager", "report", "test", "sr", "runner", "request", "search", "data", "user", "valid", "true", "cup", "card", "error", "comment", "complete", "results", "res", "date", "default", "acc", "f", "url"], "encrypted": ["image", "body", "temp", "stream", "inner", "flush", "entry", "channel", "available", "text", "cache", "packed", "extra", "pad", "flash", "padding", "selected", "layer", "secret", "interrupted", "loader", "internal", "binary", "transfer", "reader", "config", "source", " data"]}}
{"id1": "16572931", "id2": "5135688", "code1": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "code2": "    private boolean saveNodeMeta(NodeInfo info, int properties) {\n        boolean rCode = false;\n        String query = mServer + \"save.php\" + (\"?id=\" + info.getId());\n        try {\n            URL url = new URL(query);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            byte[] body = Helpers.EncodeString(Helpers.ASCII, createURLEncodedPropertyString(info, properties));\n            conn.setAllowUserInteraction(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            setCredentials(conn);\n            conn.setDoOutput(true);\n            conn.getOutputStream().write(body);\n            rCode = saveNode(info, conn);\n        } catch (Exception ex) {\n            System.out.println(\"Exception: \" + ex.toString());\n        }\n        return rCode;\n    }\n", "label": 0, "substitutes": {"unJar": ["addTar", "updateJava", "updateServer", "copyjar", "copyJava", "updateTar", "putJava", "updatejar", "addServer", "putjar", "copyServer", "addjar", "putServer", "putTar", "addJava", "copyTar"], "jarPath": ["JarPath", "javaFile", "garLog", "relFile", " jarDir", "jarpath", "erbName", "jarLog", " jarUrl", " jarPo", "browserpath", "javapath", "jarName", "javaName", "garEntry", "JarDir", "JarEntry", "browserPath", "browserName", "javaPath", "jarUrl", "erbPath", "javaPo", "javaUrl", " jarpath", "garpath", "jarPo", "garPath", "JarUrl", "erbPo", "javaEntry", "JarName", "jarFile", "relDir", "browserEntry", "Jarpath", "jarDir", " jarFile", " jarName", "relEntry", "javaDir", "erbEntry", "javaLog", " jarLog", "JarFile"], "jarEntry": ["jarentry", "JarPath", "javaInfo", " jarDir", "jarInfo", "jarLog", " jarUrl", " jarEnt", "Jarentry", "dropPath", "jarName", "dropInfo", "javaName", "JarEntry", "xmlPath", " jarInfo", "irName", "jarJar", "xmlEntry", "javaPath", "zipUrl", "jarUrl", "irEntry", "javaUrl", "aliasInfo", "aliasEnt", "cookDir", "JarInfo", "cookEnt", "zipName", "javaentry", "javaEntry", " jarentry", "zipEntry", "irentry", "xmlLog", "dropentry", "jarDir", " jarName", "irJar", "jarEnt", "aliasName", "javaDir", "aliasEntry", "cookEntry", "javaJar", "javaLog", "xmlInfo", " jarJar", " jarLog", "dropEntry", "javaEnt", "zipDir", "cookPath"], "path": ["th", "model", "resource", "temp", "step", "skip", "mode", "next", "p", "it", "prop", "dir", "context", "name", "test", "file", "binary", "str", "source", "host", "parent", "directory", "folder", "log", "ion", "this", "content", "po", "patch", "pattern", "src", "sync", "conn", "wd", "cat", "string", "PATH", "code", "cel", "pass", "core", "archive", "id", "loc", "base", "right", "Path", "prefix", "inner", "entry", "text", "zip", "left", "home", "not", "ph", "type", "out", "zone", "request", "data", "lock", "default", "location", "mount", "address", "image", "end", "root", "key", "route", "work", "part", "uri", "ath", "dest", "clean", "config", "project", "url"], "relPath": ["relName", "revPath", "RelEntry", " relUrl", "relType", "Relpath", " relName", "relativeName", "relativePath", "relativeUrl", "revType", "RelType", "RelPath", "RelUrl", "relEntry", "relUrl", " relType", " relpath", "revEntry", "RelName", " relEntry", "relpath", "revpath", "relativepath"], "jar": ["z", "folder", "her", "j", "base", "dr", "tar", "module", "car", "gar", "tab", "Jar", "py", "ball", "gap", "open", "entry", "cur", "fire", "zip", "ler", "rar", "java", "bag", "b", " Jar", "gi", "drop", "job", "er", "ja", "le", "dir", "xml", "zone", "pack", "bar", "archive", "jo", "file", "war", "binary", "browser", "sl", "keeper", "pkg", "lib", "ar", "cook", "plugin", "url"], "ze": ["z", "ipe", "de", "za", "zes", "je", "zzy", "aze", "entry", "zip", "zee", "ke", "zer", "ine", "kee", "zy", "pe", "zed", "zin", "ZE", "oe", "be", "ie", "se", "ja", "zie", "ce", "le", "pse", " je", "ge", "te", "e", "zen", "sl", "ele", "sle", "zi"], "bin": ["kin", "log", "base", "in", "resource", "login", "inner", "bot", "ban", "bon", "zip", "bas", "brain", "bit", "b", "bb", "bed", "spin", "pin", "gi", "abi", "boot", "bi", "len", "cin", "jin", "cookie", "bian", "bis", "pack", "init", "proxy", "data", "file", "binary", "isin", "gen", "lock", "win", "abin", "lib", "sin", "web", "plugin"]}}
{"id1": "1586662", "id2": "9398454", "code1": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"doOne": ["DoSync", "goOne", "goone", "Doone", "Do1", "go1", "loOne", "DoOne", "do1", "goSync", "lo1", "doone", "doSync", "loone", "loSync"], "bid": ["wid", "vid", "paid", "sha", "base", "bm", "ud", "aud", "rid", "mad", "ban", "ref", "bon", "bas", "bit", "b", "bb", "bh", "cb", "bed", "ld", "aba", "uid", "ed", "abi", "pid", "ad", "year", "lay", "oid", "bi", "auth", "bt", "hid", "sid", "mid", "la", "chid", "bn", "du", "received", "id", "seed", "rb", "bc", "bf", "batch", "ast"], "tid": ["paid", " taid", "ptaid", "tiden", "tids", "pids", " tbase", " tids", "ptid", "Tbase", "timID", "trid", "tID", "timbid", "pbase", "tide", "trID", "ptinfo", "trids", "tbase", "trbid", "pid", "ptiden", "pide", " tide", "timid", "Tid", "Tids", "pinfo", "taid", "tbid", "Tbid", "TID", "piden", "Tide", " tiden", "tinfo", " tinfo", "timids"], "aid": ["paid", "dd", "sha", "ga", "said", "ay", "aud", "alias", "order", "lan", "lied", "mad", "ase", "anc", "ca", "ada", "bas", "acid", "aida", "sat", "idd", "da", "aa", "ays", "ed", "aned", "pa", "d", "au", "Aid", "ad", "lay", "oid", "ai", "cas", "sd", "na", "ady", "auth", "aim", "man", "sid", "du", "ased", "ac", "a", "ara", "id", "af", "az", "aed", "ding", "added", "delay", "ab", "ast", "ia"], "delta": ["Dota", "ddDelta", "edetime", "ddelta", "sdelta", "sdelt", "dta", "dada", "dDelta", " dada", "ndDelta", "ndta", "Delta", "lelta", "lada", "adelt", "dota", "d\n", "edDelta", "sdta", "adota", "ldelt", "sdDelta", "D\n", "edelta", "adDelta", "adada", "ndelta", "ldota", "d_", "lelt", " delt", "Dada", "sdota", "ndota", "ddota", " d_", "ndelt", "DDelta", "edta", "sdetime", "ndata", "lota", " dota", "detime", " d\n", " dDelta", "D_", "data", "sdata", "delt", "ddelt", "ldDelta", "ldelta", "Delt", "adelta", "ndetime"], "aBalance": ["sabalance", "aaHalf", "aCost", "bHalf", "aaWeight", "saBalance", "eaBalance", " aCredit", " abalance", "aaBalance", "eabalance", "eaBal", "abalance", "bAmount", "aBal", "aWeight", " aWeight", "aaCredit", "bBalance", " aAmount", "eaCost", "pBalance", "aabalance", " aCost", "pbalance", "aHalf", "saBal", "saCost", " aBal", "pWeight", "pCredit", "bCredit", "aCredit", " aHalf", "aAmount", "aaAmount"], "RS": ["RE", "JS", "RN", "VS", "SW", "RC", "DS", "DR", "FS", "KR", "NRS", "RD", "RR", "RT", "KS", "SS", "RO", "RW", "Rs", "LS", "IS", "CL", "TS", "SH", "MC", "RB", "RL", "POST", "Res", "Vs", "VR", "US", "BS", "IR", "MR", "MS", "rs", "CD", "LL", "OSS", "RM", "Ms", "AR", "RI", "OS", "PS", "GR", "JR", "TR", "HS", "CS", "RP", "SR"], "Stmt": ["LMT", "stbl", "Stut", "Cmn", "Strau", "Stmn", "stMT", "Stp", "stmp", " StMT", "Strmp", "Cmt", " Stmp", "STut", "Stgr", "Stmp", " Stpr", "Lmp", "Cut", " Sttm", " Stau", "STTr", " StTr", "STp", "Stau", "Cmp", "STMT", " Stbl", "Stpr", "stp", "CMT", "Firstmt", "STbl", "StMT", " stmp", "Firstpr", "Firstmb", " Stmn", "Cau", "StTr", "stmt", " Stmb", " Stut", " stMT", "stgr", " Stp", " stmt", "Lgr", "Sttm", "STmn", " stgr", "stmb", "Firsttm", "sttm", "stpr", "Strmt", "Stmb", "Stbl", "STmt", "StrMT", "Lmt", "stTr"], "Query": ["File", "Time", "Check", "Raw", "Factory", "Command", "Form", "Database", "Model", "Stage", "Driver", "Body", "Source", "Route", "Statement", "Report", "Url", "Range", "Table", "Force", "SQL", "Connection", "Qu", "Display", "Line", "Function", "Comment", "Format", "Update", "query", "Array", "Request", "Do", "This", "Db", "Service", "Row", "Cache", "Common", "Code", "Server", "Scan", "Method", "Exp", "Test", "Script", "Option", "Document", "URI", "Filter", "Init", "Msg", "Fixed", "Style", "Previous", "Rule", "Module", "Join", "Info", "Flow", "Str", "Conn", "Q", "Error", " query", "Key", "Condition", "ERY", "QL"], "res": ["re", "RE", "ES", "vals", "resh", "Gr", "Response", "runs", "js", "gr", "resp", "rows", "RES", "Resources", "Res", "ches", "Results", "lets", "ras", "rest", "Resp", "Ret", "rem", "PS", "results", "reg", "Cons", "obj"]}}
{"id1": "23273706", "id2": "6501291", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectDocumentData", "getprojectTreeMeta", "getProjecttreeData", "getprojectTreeInfo", "getProjectPageMeta", "getProjecttreeMeta", "getProjecttreeInfo", "getProjectTreeDATA", "getprojectTreeDATA", "getProjectDocumentMeta", "getProjectDocumentDATA", "getprojecttreeDATA", "getprojecttreeInfo", "getProjectPageData", "getProjectPageInfo", "getProjectDocumentInfo", "getProjectTreeMeta", "getprojecttreeData", "getProjectPageDATA", "getProjecttreeDATA", "getProjectTreeInfo", "getprojectTreeData", "getprojecttreeMeta"], "treeData": [" treeList", "TreeInfo", "reeDat", "reeText", "TreeString", " treeArray", "treeInfo", "treeList", "bodyData", "TreeArray", " treeDec", " treeText", "treeArray", "reeData", "storyDat", "treeDat", "treeDec", "reeArray", "reeList", "storyData", "contentInfo", "bodyList", "storyDec", "monkeyDec", "reeString", "reeInfo", "TreeList", "monkeyArray", "contentData", " treeString", "contentText", "monkeyData", "treeText", "TreeData", "treeString", "contentDat", " treeDat", "monkeyDat", " treeInfo", "bodyString", "storyArray", "bodyDat"], "filename": ["folder", "whatever", "prefix", "dll", "kn", "sheet", "kj", "metadata", "jpg", "journal", "password", "string", "txt", "files", "fd", "path", "kl", "fil", "Filename", "upload", "uri", "dylib", "SourceFile", "figure", "fp", "FILE", "xml", "tmp", "nil", "name", "title", "wav", "framework", "ername", "data", "file", "fn", "username", "database", "location", "url", "ppa", "directory"], "urlString": ["urlstring", "locationStr", "locationString", "urlUrl", "URLstring", "urlStr", "addressString", " urlUrl", "urlURL", " urlStr", "addressStr", "URLUrl", "URLStr", "URLURL", "addressURL", "locationstring", "addressstring", "locationUrl", "URLString", " urlURL", " urlstring"], "urldata": ["urLDat", "URlfdata", "urlledta", "urlledATA", " urlddata", "urLData", "URlfat", "urLDta", "URldata", "urleddata", "urlfat", " urLDdata", "urlfdata", "urldATA", "urllATA", "URlfata", " urLDATA", "urlldata", "URldat", "urlledata", "urlleddata", "urldta", "URldATA", "urledATA", " urLDta", "urlfATA", "URlfATA", "urllata", "urlddata", "URlddata", " urldta", " urldATA", " urLData", "urledata", "urLDATA", "urlfata", "urledta", "urldat", "urllat", "urLDdata"], "factory": ["ufuild", "fictionary", "cactory", "lictionary", "confactory", "conflier", "fuild", "confiller", " fuild", " filler", "ufactory", "fault", " fFactory", "cfiller", "pactory", " fictionary", "luild", "cfactory", "cflier", "cfFactory", "fFactory", "cault", "cFactory", "lactory", "confFactory", "ciller", "liller", "pault", "piller", "ufictionary", "pFactory", "filler", " flier", "flier", "ufiller", " fault"], "parser": ["plugin", "jack", "pdf", "arser", "root", "utils", "json", "fruit", "up", "parse", "http", "l", "b", "writer", "api", "auto", "raf", "ger", "lp", "builder", "string", "driver", "r", "t", "ph", "handler", "er", "p", "se", "uri", "Parser", "util", "xml", "manager", "library", "loader", "instance", "reader", "monkey", "parent", "s"], "u": ["ou", "o", "uu", "U", "ul", " ur", "http", "cu", "l", "uf", "b", "ui", "uv", "c", "universal", "d", "p", "uni", "io", "su", "uri", "plug", "util", "eu", "hu", "nu", "ur", "us", "yu", "tu", "iu", "ru", "lu", "url", "s"], "is": ["gets", "ib", "its", "in", "serv", "abs", "ops", "mis", "http", "ir", "lis", "has", "api", "info", "ui", "isu", "IS", "ri", "pi", "obs", "ie", "p", "ris", "io", "it", "uri", "isl", "isa", "ai", "fs", "iss", "ip", "as", "iso", "bis", "es", "are", "init", "us", "ori", "ob", "ios", "Is", "ais", "or", "ar", "iris", "s"], "os": ["gets", "o", "ops", "dos", "bos", "osi", "http", "ms", "so", "pos", "obs", "ps", "ils", "io", "ros", "Os", "oss", "fs", "opens", "cos", "oes", "as", "iso", "bis", "es", "ens", "us", "sys", "bs", "oa", "oses", "ose", "ob", "ol", "OS", "ios", "oos", "fits", "or", "los", "aos", "s"], "iBufSize": ["iByteufsize", "iBuffLength", "iLufSt", "iBufferLength", "iLlfSize", "iBufSt", "iLlfLength", "iBuffSize", "iBuffLen", "iLlfsize", "iLufLength", "iLlfSt", "iBuffersize", "iByteufLength", "iBlfLength", "iBufsize", "iBuffSt", "iBlfLen", "iBbufsize", "iBlfsize", "iBuffsize", "iBufferSize", "iBytebufsize", "iLufsize", "iBufferSt", "iBytebufSize", "iBufLen", "iBlfSize", "iBytebufLen", "iBbufSize", "iLufSize", "iBufLength", "iByteufSize", "iBbufLen", "iByteufLen", "iBbufLength", "iBytebufLength", "iBlfSt"], "inBuf": ["inFuf", "outBuffbuf", " inCump", "inBump", "inPlunk", "inPluf", "inDuf", "inBub", "outBub", "inCuff", "inDaf", "inFaf", "inPlump", "inCaf", "inDuff", "outBuf", "outBuffub", "inCump", "inBbuf", " inBbuf", " inBump", " inFbuf", "outBbuf", "outBuffuf", "inBuff", " inCuf", " inBaf", "inBlunk", "inBuffbuf", "inFbuf", " inFuf", " inCunk", "inCuf", "inBluf", "inBlub", " inFaf", " inFuff", "inBuffump", "inPlbuf", "inBlbuf", "inBlump", "inCbuf", " inCbuf", "inbub", "inBuffub", "inDbuf", "inbuf", " inBuff", "outBuffump", "inBuffuf", "inFuff", "inbbuf", "inbump", "inBunk", "outBump", "inBaf", "inCunk", " inBunk"], "iNumRead": ["iNumberBuild", "iValread", "qiValRead", "iLenWritten", "qiNumREAD", "iChanREAD", "iNumREAD", "iNumberread", "qiValBuild", "iChanread", "inumWritten", "iNumberREAD", "qiNumBuild", "iFatWrite", " iFatWrite", "iNumBuild", " iNumWritten", "pNumRead", "iLenRead", "qiNumread", "qiNumRead", "iLenWrite", "pNumWritten", "iNumberWrite", "pNumread", "iChanRead", "iValBuild", "iNumberRead", "iFatWritten", " iFatWritten", "qiValREAD", "iValREAD", "iNumberWritten", "iChanBuild", "pNumWrite", "iNumWritten", "pNumberRead", "pNumberread", "pNumberWrite", " iFatRead", "pNumberWritten", "iValRead", "iFatRead", "iNumWrite", " iNumWrite", "inumWrite", "qiValread", "inumRead", "iNumread", "inumread"], "f": ["j", "o", "fr", "feed", "fa", "F", "ff", "fe", "fi", "fc", "l", "b", "uf", "full", "c", "rf", "r", "g", "t", "fd", "d", "handler", "p", "io", "v", "df", "fp", "fs", "h", "file", "fn", "e", "sf", "n", "m", "s"], "inputstream": ["Inputsw", "outputstream", "contentsystem", "outputchannel", "inputchannel", " inputsw", "inputStream", "contentstream", " inputStream", "inputsystem", " inputchannel", "inputsw", "Inputchannel", "Inputsystem", "contentStream", "outputStream", "InputStream", " inputsystem", "Inputstream", "contentsw"], "document": ["html", "office", "ocument", "content", "window", "Documents", "output", "list", "l", "info", "media", "object", "page", "null", " documentation", "collection", "dom", "t", "d", "node", "doc", "p", "record", "container", "director", "response", "DOM", "context", "xml", "Document", "tree", " documents", "docs", "language", "data", "file", "e", "parent", "n", "m", "source", "project", "directory"], "nodelist": ["nodedesh", " nodesename", "nondeme", "anodedata", " nodeselist", "nODemark", "NODemark", "nozemark", " nodette", "snodette", "Nodestyle", " nodels", "nondata", "nodsette", "nodslist", "nozelist", "nODestyle", "nodedelist", "NODesh", "snodsette", "nodedeme", "nodename", "nodeline", " nodename", "Nodelist", "nodedestyle", "nodeme", "nodesels", "anodata", "snodslist", "nonedelist", "nODesh", "anodedelist", "nODelist", "nodestyle", "nodesette", "nozestyle", "nodlist", "nozette", "nodeata", "Nodesh", "nodeelist", "nodseline", "nodselist", "NODelist", "nonedename", "Nodemark", "nodedestate", "snodeline", "anodedeme", "anodestate", "nODeline", "anodeme", "nozesh", "nodemark", "nodedlist", "snodelist", "anodelist", "snodselist", "nodette", "nondestate", "snodseline", "nodedeline", "nodesh", "nodata", "nodedette", "anodedestate", "nodestate", "nondelist", "nonedels", "snodlist", "nodesename", "nonedette", "nodeestate", "NODestyle", "nODette", "nozename", "nodedata", "nodeselist", " nodesette", "nozels", "nodels", "nodeeme", " nodesels", "nodedemark", "nODlist"], "num": ["np", "index", "dim", "Num", "unit", "nb", "temp", "tri", "umi", "um", "ul", "net", "count", "total", "mu", "comb", "mon", "pos", "nam", "dom", "norm", "node", "en", "part", "uni", "NUM", "div", "multi", "uri", "om", "len", "nr", "number", "lim", "nom", "nu", "init", "col", "sum", "mult", "con", "loc", "span", "zero", "n", "m", "inc", "max"], "i": ["ini", "mi", "j", "index", "o", "in", "yi", "chi", "hi", "isi", "phi", "cli", "ii", "fi", "ix", "slice", "mu", "ik", "l", "b", "info", "ui", "iv", "ri", "pi", "c", "gi", "g", "d", "li", "ci", "p", "ie", "part", "multi", "si", "xi", "io", "I", "eni", "v", "uri", "ai", "bi", "ji", "y", "it", "ip", "x", "start", "col", "ori", "a", "qi", "ti", "id", "iu", "di", "m", "oi"]}}
{"id1": "21182766", "id2": "7948308", "code1": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 0, "substitutes": {"load": ["resources", "setup", "resource", "create", "check", "write", "download", "find", "parse", "add", "process", "use", "info", "update", "read", "set", "loaded", "class", "LOAD", "store", "path", "loading", "proc", "build", "start", "loader", "init", "pack", "construct", "dump", "include", "call", "Load", "loads", "get", "delete", "config", "install", "copy", "save"], "propsName": ["comppsPath", "proPSNames", "comppertiesname", "propertiesPath", "propertiesName", "proPSPath", "comppertiesName", "comppertiesPath", "proPSName", "profsname", "pepertiesPath", "pepsname", "profsPath", "comppsDesc", "propsDesc", "comppsName", "pepsNames", "pepertiesNames", "propertiesDesc", "pepsPath", "proPSDesc", "profsName", "pepsName", "propertiesname", "profsDesc", "propsname", "profsNames", "pepertiesName", "propertiesNames", "comppsname", "pepertiesname", "proPSname", "propsPath", "propsNames", "comppertiesDesc"], "props": ["crops", "croperties", "propos", "compbs", "prps", "perpos", "perbs", "prots", "prids", "prpps", "pecs", "prips", "perps", "cropps", "Procs", "properties", "comppos", "procs", "compps", "Props", "pebs", "prperties", "prpr", "Prots", "pribs", "prebs", "propps", "prets", "protps", "cropr", "probs", "protpps", "propr", "protperties", "Probs", "protpr", "pripos", "peps", "prods", "compds", "preps", "precs", "pets", "perds"], "url": ["URL", "base", "resource", "service", "feed", "config", "stream", "event", "cl", "Url", "channel", "ref", "src", "http", "l", "b", "api", "page", "r", "bel", "buffer", "path", "not", "fl", "uri", "xml", "loader", "name", "location", "ssl", "server", "data", "file", "user", "gl", "e", "id", "ob", "browser", "sl", "i", "jar", "source", "f"]}}
{"id1": "2668853", "id2": "8135072", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileToStream", "decodeFiletoFiles", "decodeFileAsFiles", "decodeFileAsStream", "decodeString2Files", "decodeFile2file", "decodeStringToFiles", "decodeFile2File", "decodeFiletoStream", "decodeStringToFile", "decodeString2file", "decodeFiletofile", "decodeFile2Files", "decodeFileTofile", "decodeFile2Stream", "decodeStringTofile", "decodeString2File", "decodeFileToFiles", "decodeStringToStream", "decodeFiletoFile", "decodeFileAsfile", "decodeFileAsFile", "decodeString2Stream"], "infile": [" infilename", "infiles", "outFile", "inputfile", "outfiles", "inFile", "inputfilename", " infiles", "minfp", " inFile", "minfilename", "inputFile", "minFile", "minfile", "outfilename", "outfp", "infp", "inputfiles", "inputfp", "infilename"], "outfile": ["outFile", " outFile", "outputfp", "outputfilename", " outfilename", "outfolder", "outputfolder", " outfp", "Outfolder", "outputfull", "Outfile", "outfull", " outfull", " outfolder", "infolder", "Outfull", "outfilename", "outfp", "outputfile", "OutFile", "infp", "infilename", "outputFile"], "in": ["re", "err", "ini", "image", "login", "this", "inner", "gin", "inn", "input", "In", "up", "bin", "b", "conn", "pin", "r", "IN", "again", "ic", "source", "nin", "cin", "min", "ins", "is", "as", "lin", "init", "inas", "a", "inside", "ac", "con", "data", "rin", "e", "ex", "i", "win", "reader", "m", "din", "f", "socket", "inc", "s"], "out": ["err", "image", "base", "o", "outer", "other", "point", "inner", "to", "write", "net", "target", "obj", "In", "up", "exp", "cache", "sync", "output", "OUT", "writer", "conn", "post", "b", "bin", "home", "exit", "session", "again", "pass", "outs", "work", "op", "line", "io", "Out", "client", "off", "as", "name", "ext", "co", "on", "file", "lock", "error", "ex", "no", "lib", "inc", "exec", "socket", "copy", "s"], "buffer": ["base", "resource", "shape", "wave", "feed", "offset", "flush", "input", "slice", "queue", "b", "bytes", "bin", "bb", "pad", "null", "buf", "buff", "border", "Buffer", "padding", "split", "uffer", "result", "row", "layer", "length", "size", "pause", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "memory", "url", "address"], "read": ["current", "skip", "next", " load", "length", "limit", "lex", "send", "check", "tell", "write", "input", "count", "run", "Read", " use", "play", " send", "sync", "add", "reading", "ride", "fill", "r", "pass", "k", " ride", "ad", "allow", " copy", "size", "id", "connect", "reader", "get", "wait", "seek", " get", "select", "copy", " sleep", " reach", "parse", "reads", " write", "use", " receive", "ind", "line", " connect", "sleep", "se", "x", "READ", "inc", "exec", " request", "index", " find", " parse", "feed", " reader", "end", "open", "find", "load", " r", "work", "start", " check", " Read", "iter"], "success": [" succeed", "Success", "func", "fast", "continue", "found", "done", "default", "content", "warning", "accept", "better", "full", "status", "null", "initial", "safe", "danger", "pass", "again", "ok", "good", " Success", "winner", "job", "result", "fail", "ccess", "cess", "response", "ceed", "selected", "yes", "first", "correct", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "error", "zero", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "18696387", "id2": "14733078", "code1": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 0, "substitutes": {"input": ["image", "index", "raw", "temp", "prefix", "inner", "current", "inf", "form", "format", "audio", "Input", "version", "text", "table", "string", "initial", "buffer", "path", "first", "context", "xml", "name", "request", "host", "data", "file", "down", "include", "id", "instance", "reader", "default", "connection", "config", "source", "url", "address"], "output": ["writing", "image", "letter", "model", "temp", "outer", "office", "prefix", "done", "self", "current", "point", "write", "target", "version", "filename", "remote", "environment", "string", "application", "display", "exit", "position", "external", "job", "result", "response", "secret", "name", "operation", "Output", "file", "reference", "error", "connection", "config", "source", "web", "url", "address"], "fis": [" fIS", "ofos", "bIS", "bos", "fic", "ofic", "ofIS", "Fic", " fiss", "Fos", "Fis", "fIS", " fic", "bis", "Fiss", "fiss", "biss", "FIS", "ofis"], "in": ["ini", "err", "login", "o", "this", "inner", "inn", "In", "inc", "bin", "url", "read", "pin", "IN", "r", "again", "source", "nin", "io", "cin", "pull", "client", "ins", "is", "init", "con", "isin", "rin", "id", "ex", "reader", "win", "i", "vin", "din", "f", "socket", "lin", "s"], "fos": ["foid", "fo", "fdis", "fdo", " fops", "afis", "fdos", "afos", "info", "infos", "afo", "afoid", "fdoid", "foser", "Foser", "infoser", "infops", "Fos", "Fis", " foser", "infoid", "infis", "fops", "Fops"], "out": ["err", "flow", "log", "o", "temp", "outer", "inner", "debug", "to", "w", "write", "plain", "cli", "net", "up", "cache", "OUT", "list", "writer", "bin", "conn", "b", "key", "print", "class", "exit", "IN", "state", "again", "outs", "work", "part", "line", "io", "Out", "off", "socket", "name", "init", "ext", "report", "sys", "data", "file", "user", "parent", "lock", "error", "ex", "i", "reader", "one", "n", "println", "comment", "console", "inc", "exec", "f", "obj", "copy", "s"], "len": ["num", "base", "nt", "end", "inn", "val", "lf", "cl", "lan", "rev", "lon", "l", "bin", "conn", "pos", "split", "li", "fl", "en", "line", "part", "Len", "lim", "all", "le", "length", "size", "start", "off", "la", "ln", "id", "limit", "el", "n", "fin", "f", "lin"], "buf": ["num", "wb", "pool", "conv", "base", " buffer", " buffers", "vec", "ff", "cur", "feat", "text", "src", "queue", "bag", "uf", "bytes", "cb", "b", "bh", "cap", "pos", "buff", " bu", "border", "buffer", "fd", "Buffer", "fb", "bd", "grab", " cmd", "cas", " buff", "off", "la", "ucc", "map", "auc", "loc", "data", "cv", "rb", "uc", "seq", "batch", "br", "ctx", " data", "bc"], "numRead": ["numberWrite", "noRead", " numWrite", " numread", "NumLength", " numLength", "umReader", "NumReader", "noReader", "noread", "noWrite", "NumUse", "numread", "numberRead", "umRead", "umLength", " numReader", "numReader", "numUse", "umWrite", "numberread", "numLength", "Numread", "numWrite", "NumWrite", "numberUse", "NumRead", " numUse"]}}
{"id1": "21998571", "id2": "3809087", "code1": "    private String readTwitterFead() {\n        StringBuilder builder = new StringBuilder();\n        HttpClient client = new DefaultHttpClient();\n        HttpGet httpGet = new HttpGet(\"http://twitter.com/statuses/user_timeline/vogella.json\");\n        try {\n            HttpResponse response = client.execute(httpGet);\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n            if (statusCode == 200) {\n                HttpEntity entity = response.getEntity();\n                InputStream content = entity.getContent();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(content));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    builder.append(line);\n                }\n            } else {\n                Log.e(AndroidJsonTestingActivity.class.getName(), \"Failed to download file\");\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return builder.toString();\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"readTwitterFead": ["downloadFacebookJead", "downloadTwitterFleead", "downloadTwitterFFees", "downloadFacebookFees", "downloadTwitterFleee", "downloadTwitterFee", "downloadTwitterFFee", "downloadTwitterFrequency", "downloadTwitterJee", "downloadTwitterFees", "downloadFacebookFead", "downloadTwitterFlerequency", "downloadFacebookFee", "downloadTwitterJead", "downloadTwitterFead", "downloadTwitterFleees", "downloadTwitterFFrequency", "downloadFacebookJrequency", "downloadTwitterJrequency", "downloadFacebookJees", "downloadTwitterJees", "downloadFacebookJee", "downloadTwitterFFead", "downloadFacebookFrequency"], "builder": ["image", "letter", "base", "address", "board", "entry", "worker", "http", "message", "parser", "Builder", "atter", "writer", "b", "upper", "object", "we", "driver", "string", "null", "array", "r", "store", "buffer", "oder", "built", "er", "builders", "result", "container", "build", "sb", "row", "layer", "block", "loader", "trace", "runner", "bean", "wrapper", "server", "sf", "instance", "building", "keeper", "database", "iter", "db", "f", "url", "holder", "editor"], "client": ["method", "force", "service", "resource", "Client", "cli", "google", "channel", "http", "bird", "queue", "api", "conn", "url", "class", "application", "c", "session", "cloud", "handler", "io", "https", "ce", "app", "request", "proxy", "tc", "con", "server", "host", "connect", "i", "per", "get", "contact", "connection", "config", "project", "plugin", "socket"], "httpGet": ["HTTPSend", "HttpGet", "HttpDo", "HTTPget", " httpDo", " httpget", "HttpSplit", "ttpSplit", "ttpDo", "httpSend", "urlGet", "httpPut", "HTTPGet", " httpSend", " httpFind", "HttpPut", "httpget", "urlFind", "httpFind", "httpSplit", "urlSend", "HTTPFind", "ttpPut", "httpDo", " httpSplit", " httpPut", "ttpGet", "urlget"], "response": ["body", "onse", "service", "resource", "wave", "stream", "event", "Response", "json", "http", "message", "output", "api", "writer", "respond", "full", "object", "page", "status", "application", "collection", "resp", "session", "success", "handler", "successful", "result", "report", "ception", "received", "request", "server", "data", "document", "error", "connection", "reply"], "statusLine": ["contentLine", "statusBlock", "httpEntry", "StatusLine", "statResponse", "responseEntry", "statusResponse", "statLine", "StatusEntry", "contentStatus", "statEntry", " statusEntry", "responseResponse", "responseLine", "statusEntry", "httpBlock", "contentEntry", "responseCode", "statCode", "StatusBlock", "StatusStatus", "httpLine", "contentBlock", "statusStatus", " statusResponse", "httpStatus"], "statusCode": ["contentLine", "statusCount", "StatusLine", "contentCode", "stateStatus", "StatusCount", "StatusCode", " statusType", "statusType", "contentCount", "stateType", "contentType", "StatusStatus", "stateCode", "statusStatus", "StatusType", " statusCount", " statusStatus"], "entity": ["enc", "body", "model", "resource", "agent", "stream", "coll", "event", "et", "json", "entry", "http", "media", "writer", "object", "page", "status", "code", "element", "application", "collection", "er", "result", "type", "ent", "xml", "article", "server", "data", "file", "document", "e", "person", "el", "activity", "Entity", "connection", "source"], "content": ["body", "image", "resource", "Content", "feed", "raw", "child", "cont", "stream", "input", "json", "entry", "channel", "text", "message", "load", "output", "media", "writer", "conn", "object", "page", "status", "read", "driver", "collection", "buffer", "handler", "result", "pointer", "layer", "xml", "loader", "server", "data", "file", "activity", "source"], "reader": ["in", "resource", "stream", "rer", "input", "worker", "reading", "ler", "parser", "rar", "bird", "writer", "read", "ri", "r", "buffer", "oder", "handler", "er", "io", "rr", "row", "ner", "loader", "server", "data", "ser", "Reader", "i", "per", "iter", "or", "editor"], "line": ["link", "body", "letter", "lc", "base", "feed", "end", "liner", "point", "sheet", "lf", "write", "lines", "entry", "inline", "LINE", "text", "message", "Line", "sync", "key", "l", "object", "page", "style", "string", "code", "pe", "r", "buffer", "pass", "part", "row", "ip", "block", "le", "character", "name", "data", "file", "id", "cell", "e", "char", "str", "sl", "i", "comment", "one", "iter", "connection", "source", "url", "lin"]}}
{"id1": "11183087", "id2": "23532405", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "label": 0, "substitutes": {"doPost": ["doPOST", "handleSearch", "doingPost", "handlePOST", "handlePost", "doingPOST", "handlePut", " doSearch", "doingPut", "doSearch", "doPut", " doPut", "doingSearch", " doPOST"], "request": ["image", "model", "right", "resource", "q", "create", "child", "view", "current", "event", "forward", "input", "order", "project", "req", "http", "message", "have", "use", "rate", "queue", "info", "post", "QUEST", "object", "remote", "application", "rf", "pe", "r", "initial", "route", "subject", "external", "state", "buffer", "query", "join", "Request", "er", "hello", "type", "result", "frame", "pull", "client", "context", "xml", "report", "the", "server", "user", "data", "e", "call", "parent", "instance", "error", "press", "web", "complete", "enter", "get", "config", "url"], "response": ["onse", "body", "model", "pool", "resource", "site", "view", "Response", "http", "message", "output", "api", "writer", "respond", "object", "page", "status", "application", "resp", "next", "result", "client", "report", "server", "document", "guide", "parent", "results", "res", "connection", "template", "web", "reply"], "senha": ["renha", "senwa", " senwa", "senlah", "zenha", "senhi", "tonHa", "zenca", " senca", "sanwa", "tonwa", "renaka", "zenhi", "sensha", "senla", "tonlah", "senaka", "suithi", " senaka", "sanha", "tonha", "snha", " senHa", "snsha", "suitsha", "zenHa", "zensha", "suitha", "zenaka", "sanHa", "sanlah", "suitla", "senca", "renca", "senHa", "zenla", "renHa", "snla", " senlah", "snhi"], "email": ["letter", "model", "mail", "service", "login", "office", "account", "Email", "mobile", "alias", "zip", "message", "label", "password", "environment", "home", "string", "example", "hello", "phrase", "line", "secret", "ip", "xml", "business", "name", "language", "server", "data", "file", "id", "user", "e", "username", "fax", "url", "address"], "messageDigest": ["messageDigher", "messageDest", "messageDigester", "messageMailester", " messagedigEST", "messageDher", "meDigEST", "messageDigEST", "messagedigend", "meDigester", "messageMailest", "medigEST", "messageMailEST", "medigher", "medigester", " messagedigester", " messageDigester", "meDigest", "medigest", " messageDend", " messageDest", "messageDend", "messageDester", "messagedigEST", "messagedigher", " messageDigend", " messageDEST", "meDigher", " messagedigest", "messagedigester", "messageDigend", "messageDEST", "messageMailend", " messageDester", "messagedigest", " messageDigEST"], "usuario": ["suuario", "usuarium", "ususariat", "usuillo", "ussuario", "ussuasio", "usueillo", " usuarium", " usuasio", "usguillo", "usituario", " usuiasio", "ususarius", "ussuarium", " usuiarium", "ususillo", "sulurio", "usuariat", " ususillo", " usuariat", "usueario", "usguarius", "usueariat", " usuarius", "usluario", "usuitario", "usuearius", " usuiario", "usuitasio", "usituarial", "usuitrio", "usguario", " usuirio", "uslurio", " ususariat", "usuarial", "suluasio", "usuarius", "usluasio", "usuiarium", "suuasio", " usuillo", "usuirio", "usuitarium", "usuiasio", "suurio", "usluarial", "usguariat", "suluarial", " usurio", "usuiario", "usurio", " ususario", "ussurio", "usuasio", "ususario", " ususarius", "suuarial", "usituasio", "ussuarial", "suluario", "usiturio"], "redirect": ["Redurl", "redrict", "predirection", "indirect", "predroute", " redition", "Redrict", "Redition", "predirect", "redirection", " redRECT", " redurl", "preduce", "Redroute", "Redirect", "RedRECT", " redirection", "induce", " reduce", "edurl", "indrict", " redrict", "reroute", "edirection", "predrict", "edition", "Redirection", "reirection", "redRECT", "rerict", "reirect", "reduce", "redroute", "predRECT", "edirect", "redition", "redurl", "indirection"], "session": ["image", "service", "child", "system", "site", "storage", "view", "event", "input", "group", "http", "message", "cache", "use", "info", "object", "page", "sp", "flash", "state", "query", "node", "result", "ession", "client", "cookie", "Session", "app", "sid", "ssl", "proxy", "server", "data", "user", "document", "browser", "comment", "sl", "person", "connection", "config"]}}
{"id1": "21642215", "id2": "15971794", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"addIDs": ["loadID", "loadIDs", " addIDS", "addLinks", " addLinks", "addIDS", " addID", "loadLinks", "findID", "findIDS", "findIDs", "loadIDS", "findLinks", "addID"], "row": ["index", "feed", "raw", "view", "tab", "scan", "head", "ry", "entry", "group", "up", "column", "key", "table", "ow", "list", "info", "post", "builder", "array", "r", "rows", "ro", "item", "tr", "query", "job", "Row", "record", "result", "bug", "report", "col", "server", "user", "cell", "reader", "per", "batch", "copy"], "name": ["image", "resource", "NAME", "prefix", "alias", "filter", "filename", "key", "info", "connection", "string", "ame", "path", "query", "Name", "type", "named", "number", "size", "start", "title", "word", "search", "file", "username", "str", "description", "n", "time", "source"], "in": ["re", "err", "image", "ini", "login", "resource", "serv", "stream", "inner", "gin", "inn", "input", "with", "din", "In", "at", "http", "cache", "rec", "l", "b", "bin", "conn", "update", "string", "c", "pin", "r", "IN", "session", "buffer", "again", "token", "ic", "query", "path", "doc", "nin", "record", "container", "it", "cin", "diff", "min", "out", "ins", "is", "xml", "as", "socket", "ssl", "init", "a", "con", "user", "file", "gen", "lock", "ex", "reader", "i", "win", "n", "iter", "m", "source", "f", "inc", "s"], "urlName": ["lPath", "toolPath", "UrlType", "fileName", "UrlPath", "urlPath", "filePath", "urlType", "toolName", "filename", "lName", "urlStr", "URLName", " urlStr", "urlname", "filePart", " urlPart", "UrlName", "lType", "UrlPart", "URLPath", " urlname", "Urlname", "URLname", "lStr", " urlType", " urlPath", "lname", "toolname", "UrlStr", "urlPart"], "url": ["link", "image", "URL", "base", "resource", "service", "feed", "stream", "input", "Url", "open", "hub", "channel", "http", "l", "b", " URL", "r", "bel", "buffer", "path", "fl", "io", "org", "uri", "out", "client", "loader", "socket", "ssl", "server", "file", "user", "gl", "sl", "reader", "connection", "source", "web", "f"], "inputLine": ["againLine", "dataline", "accessLine", "InputLo", "dataRoute", "uploadSel", "Inputline", "inputEntry", "dataUrl", "formLINE", "execline", "typeLink", "htmlLINE", "InputRoute", "readLine", "inputStream", "readLook", "requestString", "dataLin", "InputFile", "inputLo", "formLine", "baseline", "accessSync", "execLine", "rawL", "readSync", "updateLINE", " inputWrite", "inputString", "inputL", "formline", "inputLINE", "accessLINE", "requestline", "inputEmail", "inputLook", "inputSel", "readLin", "typeline", "execEmail", "rawFile", " inputString", "inputWrite", "InputLine", "dataLINE", "responseFile", "accessEntry", "issueSel", "readline", "uploadline", "indexLine", "readL", "issueline", "dataWrite", " inputEmail", " inputStream", "dataLine", "dataLo", "againWrite", "execUrl", "InputL", "searchLine", "InputLink", "responseLine", " inputLink", "htmlLine", "againLINE", "inputUrl", "baseLINE", "uploadLine", " inputSel", " inputLook", "InputSource", "htmlString", "requestLine", "inputBlock", "InputStream", "indexLINE", "indexSync", "typeLine", "inputSource", " inputUrl", "requestUrl", "dataFile", " inputLINE", "input\n", "inputline", "inputLin", "baseFile", " inputLo", "responseLink", "baseLine", "inputFile", " inputFile", "updateLine", "requestEmail", "output\n", "dataSource", "requestLINE", " inputSync", " inputEntry", "Input\n", "updateLin", " inputSource", "searchFile", " inputRoute", "inputRoute", "formLin", "searchL", " inputL", "InputBlock", "InputLINE", " inputLin", "searchStream", "indexEntry", "InputSync", "dataBlock", " input\n", "responseLINE", "dataLook", "issueLin", "updateline", "rawLine", " inputline", " inputBlock", "readFile", "dataSync", "typeLINE", "inputLink", "rawline", "againUrl", "uploadLin", "dataLink", "issueLine", "inputSync", "htmlline"], "score": ["fee", "index", "rice", "cost", "game", "grade", "player", " Score", "match", "confidence", "message", "count", "key", "rate", "speed", "status", "code", "gain", "price", "core", "loss", "sc", "winner", "result", "width", "length", "ner", "Score", "fit", "size", "test", "live", "weight", "seed", "level", "scoring", "ranking", "value", "error", "feature", "rank", "time"], "metaboliteID": ["metabolitableName", "metabolizeInfo", "metabolriteInfo", "metabolitionId", "metabolitationIN", "metabolicizeInfo", "metabolriteIndex", "metabolitionIndex", "metovaliteAddress", "metabolriteIDs", "metovaliteId", "metabolidateName", "metabolverseId", "metabolriteSize", "metaboliciteName", "metaboliteType", "metabolheticAddress", "metmboliteID", "metaboliciteScore", "metaboliqueType", "metabolizeScore", "metaboliqueID", "metabolidateID", "metabolverseIN", "metmboliteIndex", "metabolheticID", "metabolitableSize", "metabolidateScore", "metaboliciteID", "metaboliteSize", "metovalriteIndex", "metaboliteIN", "metovalriteID", "metabololeName", "metabolitableId", "metovalriteAddress", "metabolitableIDs", "metabolidateInfo", "metabololeID", "metaboliteIndex", "metovalriteId", "metabolitionAddress", "metabolitableID", "metmboliteIDs", "metabolheticIndex", "metabolheticId", "metabolverseID", "metmbolitableIndex", "metabolriteAddress", "metaboliteId", "metmboliteType", "metabolitableType", "metaboliteScore", "metabolriteType", "metovalriteName", "metabololeSize", "metaboliteIDs", "metabolicizeScore", "metabolriteID", "metmboliqueIDs", "metmboliteSize", "metovaliteIndex", "metabolverseName", "metovaliteIN", "metabolicizeID", "metmbolitableID", "metabolitionID", "metabolicizeName", "metmboliteId", "metaboliciteInfo", "metabolizeName", "metabolriteId", "metmbolitableName", "metmboliteName", "metaboliteInfo", "metovalriteIN", "metabolizeID", "metovaliteName", "metaboliqueIDs", "metabolitationID", "metabolriteIN", "metabolitableIndex", "metabolriteScore", "metabololeIndex", "metovaliteID", "metabolriteName", "metaboliteAddress", "metabolitationName", "metabolitationId", "metmbolitableSize", "metmboliqueId", "metmboliqueType", "metmboliqueID", "metaboliqueId", "metaboliteName"], "dataScore": ["dataWeight", "styleWeight", "dataGrade", "inputSource", " dataWeight", "DataGrade", "styleType", "numberGrade", "laScore", "inputPath", " dataMatch", "dataMatch", "dataRank", " dataPath", "dataSum", "numberType", "videoType", "indexScore", "dataLevel", "DataSum", " dataID", " dataType", "dataSize", " dataGrade", "laSum", "indexPath", "styleScore", " dataRank", "inputSize", " dataLevel", " dataSize", "indexSource", "styleSize", "DataMatch", "inputScore", "dataID", "DataLevel", "DataScore", "doubleType", "videoScore", "DataRank", "numberLevel", "dataType", "DataPath", "laPath", "inputMatch", "indexID", "doubleRank", " dataSource", "dataPath", "DataSize", "doubleScore", "dataSource", "videoSize", " dataSum", "numberScore", "doubleWeight", "inputID", "videoWeight", "numberRank", "laLevel", "numberWeight"], "data": ["image", "body", "resource", "change", "done", "content", "sample", "dat", "input", "json", "picture", "alpha", "text", "zip", "message", "key", "area", "media", "info", "ui", "extra", "pad", "style", "string", "code", "array", "buffer", "split", "DATA", "div", "result", "number", "response", "size", "missing", "map", "weight", "error", "value", "empty", "results", "batch", "ata", "source"], "molecularWeight": ["moleciumWeight", "moleciumWidth", "mosecularWidth", "mosellularFlow", "molesularWeight", "molecularWidth", "moleciumFlow", "molescularSize", "moleculeWeight", "moleculeSize", "molesularWidth", "moleculeFlow", "molellularWeight", "moleularSize", "moleularWeight", "molellularWidth", "mosecularFlow", "moleculeWidth", "moleuralWidth", "molesularSize", "molescularWeight", "mosellularWeight", "mosellularWidth", "moleuralWeight", "molescularWidth", "molellularFlow", "moleularWidth", "mosecularWeight", "molecularFlow", "molecularSize", "moleuralSize"]}}
{"id1": "1954410", "id2": "16556717", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "label": 0, "substitutes": {"doExecute": ["submitexecuteRun", "doExecRun", "submitexecuteute", "doSendApply", "submitexecuteutes", "doSendute", "doExecutes", "submitExecute", "doexecuteRun", "submitExecRun", "doexecuteutes", "doexecuteApply", "doExecApply", "submitexecuteApply", "doSendutes", "doexecuteute", "doSendRun", "submitExecApply", "submitExecutes"], "mapping": ["finding", "minding", "amapping", "fapper", "mapper", " mapper", "amatching", "fapping", "matching", "amapper", "aminding", " matching", " minding", "fatching"], "form": ["flow", "method", "field", "Form", "formation", "feed", "submit", "config", "forms", "format", "transform", "pattern", "post", "object", "page", "builder", "definition", "dom", "control", "command", "xml", "app", "component", "FORM", " forms", "template", "url", "owner"], "request": ["re", "_", "method", "model", "resource", "q", "create", "ware", "submit", "this", "view", "self", "current", "format", "Response", "input", "json", "worker", "req", "message", "add", "queue", "use", "Reply", "object", "QUEST", "Bytes", "application", "Accept", "session", "route", "path", "query", "Request", "hello", "type", "result", "uri", "frame", "pull", "client", "context", "xml", "Upload", "report", "name", "server", "user", "data", "HTTP", "parent", "call", "instance", "s", "reader", "complete", "requ", "url", "address"], "response": ["model", "resource", "view", "Response", "json", "req", "message", "output", "object", "page", "application", "status", "resp", "handler", " responses", "result", "v", "client", "Resp", "xml", "report", "server", "data", " Response", "res", "reply"], "errors": [" calls", " logger", " management", " managers", " changes", " events", " replies", " Messages", " logs", " mess", " streams", " commands", " session", " this", " messaging", "mess", " responses", " payload", " failures", " messenger", " messages", " error", " translations", " status", " flashes", " problems", " updates", " acc", " warnings"], "isMultipart": ["isMultipost", "isMultippart", "isMultiipPart", "isMultippedart", "isMultIPound", "isMultitart", "isMultipated", "isMultitarts", "isMultiarts", "isMultitated", "isMultiIPound", "isMultiIPart", "isMultipound", "isMultiated", "isMultiipart", "isMultipage", "isMultIPart", "isMultiage", "isMultIPost", "isMultompPart", "isMultippedPart", "isMultippedost", "isMultippedound", "isMultIPPart", "isMultiparts", "isMultompound", "isMultitage", "isMultiipound", "isMultippage", "isMultompost", "isMultompart", "isMultipparts", "isMultiIPost", "isMultipPart", "isMultiipost", "isMultiIPPart", "isMultiart", "isMultippated"], "mailInstance": [" emailinstance", "mailManager", "fileManager", " emailInst", " emailInstance", "fileUsage", "mailUsage", "emailInst", " mailManager", "mailinstance", "emailinstance", " mailUsage", " mailinstance", "fileInstance", "fileInst", "emailManager", " mailInst", "mailInst", "emailInstance", " emailUsage", "fileinstance"], "fields": ["archives", "gets", "boxes", "field", "comments", "objects", "posts", "keys", "forms", "types", "locks", "changes", "utils", "input", "flows", "lines", "plugins", "links", "services", "maps", "details", "ments", "packs", "rules", "ids", "properties", "events", "views", "facts", "files", "uploads", "params", "groups", "headers", "rows", "atts", "lists", "cells", "acks", "holders", "checks", "tags", "states", "qs", "users", "members", "models", "features", "pages", "data", "forces", "classes", "loads", "words", "strings", "dates", "parts", "s"], "attachments": ["attachions", "attlements", " attachparts", "suppment", "extions", "exters", "supplements", "achresses", "attment", "attachers", "payresses", "Attachments", "attachps", "payment", " attachment", "attachparts", "payments", "achments", "suppments", "Attachlements", "attachlements", "payparts", "achparts", "attees", "suppees", "Attachps", "attions", "attachment", "extps", "attachresses", "attments", "atters", "achment", "Attachers", "attps", "Attachment", " attachresses", "attachees", "Attachions", "Attachees", "extments"], "items": ["its", "objects", "keys", "types", "locks", "phones", "ops", "children", "lines", "plugins", "links", "orders", "ids", "list", "events", "files", "apps", "groups", "rows", "Items", "lists", "apters", "qs", "ins", "reports", "models", "es", "alls", "ips", "pages", "data", "names", "results", "parts", "ers"], "iter": ["err", "ver", "outer", "end", "walker", "inner", "event", "coll", "ul", "order", "skip", "inter", "edit", "gener", "exp", "zip", "master", "ir", "http", "slice", "list", "finder", "page", "Iter", "li", "er", "itter", "izer", "it", "oper", "loop", "altern", "ip", "ner", "ite", "chain", "cher", "keep", "ter", "former", "file", "ser", "iterator", "el", "Iterator", "ator", "reader", "enter", "i", "loc", "inc", "upper"], "item": ["resource", "temp", "storage", "current", "full", "page", "hop", "element", "next", "result", "it", "layer", "name", "volume", "file", "source", "folder", "service", "slice", "api", "info", "example", "album", "token", "handler", "original", "Item", "issue", "all", "ip", "app", "server", "user", "instance", "reader", "get", "plugin", "base", "other", "inner", "event", "entry", "post", "object", "extra", "update", "atom", "custom", "er", "type", "attribute", "container", "entity", "data", "or", "anything", "obj", "image", "index", "section", "site", "coll", "val", "art", "order", "up", "load", "widget", "area", "more", "li", "missing", "i", "complete", "url"], "aux": ["aw", "lc", "ou", "des", "sub", "packages", "prefix", "aus", "ants", "offs", "abs", "alias", "except", " Aux", "anc", "aff", "ox", "axe", "uf", "extra", "sup", "array", "buf", "amp", "au", " auxiliary", "lang", "cmp", "ras", "etc", "cas", "off", "ups", "ext", "auc", "asc", "union", "data", "ux", "af", "abc", "pkg", "strings", "fax", "uc", "frac", "ru", "aos", "imp"], "part": ["action", "html", "field", "base", "plugin", "section", "change", "point", "step", "val", "po", "format", "pre", "art", "patch", "player", "obj", "group", "ref", "add", "back", "pair", "key", "area", "l", "ch", "b", "full", "object", "list", "info", "fact", "class", "pos", "act", "element", "pi", "join", "p", "type", "and", "diff", "comp", "layer", "block", "start", "but", "name", "joined", "partial", "co", "PART", "word", "component", "data", "user", "file", "on", "id", "instance", "Part", "f", "error", "per", "one", "no", "connection", "parent", " Part", "parts"], "baos": ["abaOs", "baOS", "baoss", " baOS", "BAoss", "bois", "bao", "bais", "boosh", "Bao", "BAos", "BAis", " baoS", "pao", "BAosh", "baot", "boOS", "hao", "BaOs", "Baos", "baosh", " baot", "haos", " bao", "abais", "Bais", "abaosi", "boot", "paos", "paosh", "BAoS", "BAOs", "boos", " bais", "baoS", "BAo", "BaoS", "baOs", "boo", "Baosi", "BAosi", "pais", "paot", "hais", "abaos", " baoss", "haoss", "paOS", "baosi"], "body": ["fee", "html", "resource", "options", "end", "Body", "content", "common", "json", "text", "message", "zip", "output", "shell", "b", "media", "full", "object", "string", "null", "summary", "flash", "params", "headers", "state", "pass", "query", "translation", "type", "parts", "length", "size", "name", "tree", "data", "document", "binary", "port", "description", "comment", "value", "connection", "template", "source", "reply", "url", "header"], "preferencesInstance": ["prefirmsClient", "prefiesInstance", "preffeesinstance", "prefferencesinstance", "prefirmsinstance", "preffeesClient", "prefferencesInstance", "prefiesinstance", "prefiesClient", "prefeesClient", "preffeesInstance", "preferencesinstance", "prefeesInstance", "preferencesClient", "prefirmsInstance", "prefferencesClient", "prefeesinstance"]}}
{"id1": "15500892", "id2": "932225", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 1, "substitutes": {"getRandomGUID": ["getRandGID", "getRandGid", "getRandomGCID", "getRandGUID", "getRandUid", "getRandomGid", "getRandUuid", "getRandomGCid", "getRandomGID", "getRandGuid", "getRandomGCuid", "getRandomIGID", "getRandUID", "getRandomUUID", "getRandomIGUID", "getRandomUID", "getRandomGCUID", "getRandUUID", "getRandomIGid", "getRandomUuid", "getRandomIGuid", "getRandomGuid", "getRandomUid"], "secure": ["encrypted", "force", "service", "stable", "depth", "sensitive", "debug", "deep", "Secure", "active", " insecure", "zip", "sec", "random", "remote", "use", "protect", "safe", "session", "external", "pure", "confirmed", "weak", "require", "https", "allow", "ce", "secret", "ssl", "unsigned", "secondary", "proxy", "sr", "smart", "server", "seed", "exclusive", "security", "timeout", "config", "host"], "md5": [" mdql", "MD512", " md500", "MD500", "MD5", " MD500", " MD2", "md512", "cmd5", " md512", "md2", " md2", "mdql", " MD5", "MDql", "md11", " md3", "MD3", "MD2", "md500", "cmdql", "MD11", " MD11", " MD3", "cmd512", " md11", "cmd3", "md3"], "sbValueBeforeMD5": ["sbValueBeforeMS0", "sbValuebeforeSD20", "sbValueGivenmd5", "sbValueBeforeSHA005", "sbValueBeforeMAC0", "sbValueBeforeMS3", "sbValueBeforeMAC55", "sbValueBeforeMI5", "sbValueBeforeMD3", "sbValueBeforeMD20", "sbValueAfterMP3", "sbValueBeforeDER1", "sbValueBeforeD3", "sbValueBeforeSD20", "sbValueGivenmd375", "sbValuebeforeMD5", "sbValueBeforeMD7", "sbValueBeforeMC5", "sbValueAfterMS0", "sbValueBeforeMS95", "sbValuebeforeSD1", "sbValueAfterMD20", "sbValueBeforeMI3", "sbValueAfterMD25", "sbValueGivenMD3", "sbValuebeforeSD5", "sbValueBeforeAMD3", "sbValueBeforeMD512", "sbValueAfterMD65", "sbValueBeforeAMD5", "sbValueBeforeMS512", "sbValueBeforemd3", "sbValueBeforeMP5", "sbValueBeforeDER005", "sbValueAfterMS65", "sbValueBeforeMD005", "sbValueAfterMS20", "sbValueAfterMS25", "sbValueBeforeMS75", "sbValueBeforeSD005", "sbValueAfterMS5", "sbValueBeforeMI7", "sbValueAfterMD3", "sbValueBeforeMD0", "sbValueBeforeMP3", "sbValueBeforeDER3", "sbValueBeforemd375", "sbValueBeforeMD55", "sbValueBeforeMD25", "sbValueBeforemd65", "sbValueAfterMS1", "sbValueGivenmd3", "sbValueBeforeMR3", "sbValueBeforemd512", "sbValueAfterMD1", "sbValueBeforeMS375", "sbValueBeforeAMD20", "sbValuebeforeMD1", "sbValueBeforeMD65", "sbValueAfterMD55", "sbValueBeforeDER55", "sbValueBeforeMD75", "sbValueBeforeSHA20", "sbValueBeforeDER0", "sbValueBeforeMD95", "sbValueAfterMP5", "sbValuebeforeSD005", "sbValueBeforeDER5", "sbValueBeforeMP7", "sbValueBeforeD65", "sbValueAfterMS95", "sbValueAfterMS55", "sbValueGivenmd512", "sbValueBeforeSD5", "sbValueAfterMD75", "sbValueBeforeAMD1", "sbValueBeforeMI1", "sbValueBeforeMS5", "sbValueBeforeMI20", "sbValueBeforeSHA5", "sbValueBeforemd75", "sbValueBeforeMS20", "sbValueBeforeMR25", "sbValueAfterMP1", "sbValueAfterMS75", "sbValueBeforeMR5", "sbValueBeforeSD1", "sbValueBeforeMP1", "sbValueBeforemd95", "sbValueBeforeMD1", "sbValueAfterMP7", "sbValueBeforeMAC5", "sbValueBeforeSHA1", "sbValueBeforeMC512", "sbValueBeforemd25", "sbValueBeforeMC375", "sbValueAfterMD0", "sbValueBeforeD5", "sbValueGivenMD375", "sbValueBeforeDER20", "sbValueBeforemd5", "sbValueAfterMS3", "sbValuebeforeMD20", "sbValueGivenMD5", "sbValueBeforeD75", "sbValuebeforeMD005", "sbValueBeforeMS65", "sbValueBeforeMS55", "sbValueBeforeMS25", "sbValueAfterMD7", "sbValueBeforeMD375", "sbValueAfterMD5", "sbValueBeforeMAC3", "sbValueBeforeMS1", "sbValueBeforeMR95", "sbValueBeforeMC3", "sbValueAfterMD95", "sbValueGivenMD512", "sbValueBeforeMS7"], "time": ["Time", "depth", "offset", "event", "cost", "duration", "version", "mode", "count", "times", "random", "slice", "rate", "speed", "race", "tz", "clock", "TIME", "work", "type", "year", "counter", "length", "size", "start", "name", "ime", "tim", "id", "user", "seed", "money", "value", "error", "etime", "date", "timeout", "timer", "delay", "hour", "loc", "host"], "rand": ["rule", "index", "right", "q", "depth", "root", "bot", "order", "pick", "serial", "version", "alpha", "count", "round", "bit", "random", "rate", "chance", "risk", "r", "rage", "ro", "rc", "winner", "lang", "type", "year", "Rand", "rr", "rh", "min", "raid", "clean", "mid", "id", "range", "seed", "gen", "error", "win", "ng", "rank", "delay", "reg", "rol", "res", "cr", "max"], "valueBeforeMD5": ["valueInsideMD85", "valueBeforeAMD5", "valueBeforeMC5", "valueAfterMD2", "valueBeforeMD2", "valueInsideMD3", "valueBeforemd5", "valueBeforeMD53", "valueBeforeAMD3", "valueInsideMD2", "valueAfterAMD3", "valueBeforemd3", "valueBeforeMP3", "valueBeforemd2", "valueAfterMD53", "valueBeforeMD3", "valueAfterMD3", "valueBeforeMC3", "valueBeforeMC2", "valueBeforeAMD2", "valueAfterAMD53", "valueBeforeMD85", "valueBeforemd85", "valueAfterAMD2", "valueInsideMD5", "valueAfterAMD5", "valueBeforeMP53", "valueBeforeMC85", "valueBeforeAMD53", "valueBeforeMP5", "valueBeforeMP2"], "array": ["image", "shape", "section", "storage", "view", "integer", "sample", "audio", "arr", "function", "our", "message", "cache", "pair", "area", "api", "list", "object", "string", "element", "collection", "vector", "Array", "record", "result", "allow", "number", "row", "any", "expression", "app", "arrow", "ray", "archive", "range", "data", "binary", "instance", "value", "error", "angle", "database", "feature", "batch", "air", "address"], "sb": ["ib", "wb", "nb", "bsp", "kb", "bm", "lr", "eb", "zb", "bl", "SB", "sa", "xb", "src", "bb", "cb", "ruby", "usb", "bp", "lp", "buf", "gb", "abb", "buffer", "stab", "fb", "lb", " SB", "bf", "rob", "si", "obb", "sg", "sv", "nn", "sq", "orb", "pb", "bt", "lab", "bs", "ob", "binary", "sbm", "sf", "sth", "sl", "rb", "mb", "bc", "bh", "bj", "BB", "ab", "s"], "j": ["z", "aj", "num", "index", "o", "q", "end", "jl", "ii", "dy", "key", "l", "ch", "jp", "js", "pr", "code", "c", "uj", "g", "d", "k", "li", "job", "ie", "p", "part", "ja", "v", "x", "ji", "out", "y", "length", "jj", "jo", "J", "e", "adj", "i", "ij", "n", "bj", "br", "f", "obj"], "b": ["ib", "nb", "BB", "eb", "bit", "l", "bb", "bin", "cb", "c", "d", "k", "be", "fb", "job", "p", "lb", "bi", "x", "y", "B", "bug", "orb", "pb", "bar", "a", "bs", "ob", "binary", "e", "i", "rb", "mb", "n", "bc", "bf", "br", "db", "f", "ab"], "valueAfterMD5": ["valueAfterMD2", "valueAfterVM5", "valueAfterMP2", "valueBeforeMD2", "valueAfterAMD7", "valueAfterMP7", "valueAfterAMD3", "valueAfterVM7", "valueAfterMD7", "valueBeforeMP3", "valueAfterVM3", "valueBeforeMD3", "valueBeforeMD7", "valueAfterMD3", "valueAfterVM2", "valueBeforeMP5", "valueAfterMP5", "valueAfterAMD2", "valueAfterAMD5", "valueBeforeMP7", "valueAfterMP3", "valueBeforeMP2"]}}
{"id1": "14390569", "id2": "18891988", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "label": 1, "substitutes": {"title": ["image", "body", "html", "resource", "section", "prefix", "itle", " Title", "content", "format", "itles", "version", "alpha", "license", "text", "message", "details", "filename", "label", "page", "string", "summary", "heading", "subject", "phrase", "type", "part", "notes", "ppa", "Title", "size", "name", "term", "TIT", "chapter", "data", "id", "layout", "description", "theme", "desc", "msg", "url", "header"], "imageURL": [" imageurl", "mediaUrl", "ImageUrl", "pictureURI", "filePath", "imgPath", "ImagePath", "pictureUrl", "mediaURI", "imgURL", "ImageURI", "imgUrl", "fileURI", "imageURI", "mediaURL", "ImageURL", " imageUrl", " imageURI", "imageurl", "imageUrl", "fileURL", "fileurl", "fileUrl", "pictureurl", "imgURI", "pictureURL", "imagePath"], "jd": [" jdl", "je", "ajD", "qdh", " jdd", "Jb", "jjdh", "jds", "zl", "ajdos", "Jdos", "Je", "jjdo", "jackb", "jackf", "ajdl", "jdom", "ssdo", "Jdo", "jdi", "ajdh", "jobdo", "ssdi", " jdo", "jsdh", "jD", "jjb", "Jds", "adjdos", "qb", "ajdo", "zf", "jsdo", "jsb", "jobD", "zb", "ajdi", "zd", " jdh", "jf", "ajd", "qd", " jds", "jackdd", "jjd", "argdo", "qdo", "Jf", "argf", " je", "zdo", "jsd", " jdi", " jf", "adjdo", "qdom", "JD", "jdos", "zdd", "zds", "jobb", "jdd", "Jl", "Jdom", "jdh", "adjb", "jdo", " jdom", "ze", "ssd", "ajb", "jobd", "argd", "jdl", "Jd", "ajf", "argdl", "jackd", " jD", "ssD", "adjd"], "jl": ["j", "jc", "eb", "nl", "kn", "wl", "kj", "syn", "lf", "bl", "cli", "Label", "l", "label", "ld", "vd", "lp", "NJ", "uj", "hl", "chal", "kl", "li", "dl", "iji", "lb", "ja", "JM", "elly", "ji", "jon", "elt", "dj", "fp", "zl", "il", "jj", "oji", "iol", "bn", "lv", "kel", "ll", "adj", "el", "bj", "lu", "igl"], "icon": ["image", "pic", "action", "resource", "ion", "content", " Icon", "alias", "picture", "text", "fc", "iao", "label", "info", "ui", "ann", "Icon", "core", "token", "ic", "note", "uni", "io", "eye", "uri", "icons", "cha", "css", "img", "size", "bn", " image", "cn", "on", "gn", "artist", "png", "ico", "n", "plugin", "url", "header"], "chooser": ["Chooses", "Choosen", " choressor", "closer", "boosen", " choosen", " chooses", "clressor", "Chooder", "boressor", "choose", " choose", "chooses", "chooder", "choressor", "Choose", " chooder", "choosen", "dialoser", "joose", "boose", "booser", "Chooser", "close", "cler", "dialosen", "jooses", "closen", "dialer", "jooder", "choer", "jooser", "dialose", "Choer"], "jp": ["j", "JP", " pa", " dock", " JM", " cm", " gp", " ax", " pane", " app", " j", " bridge", " dj", "bj", " tmp", "ja", " bar", "ji", " robot", " np", " js", " je", " plugin", "Panel", " pic", " mp", " obj", " sp", " cp"], "jb": ["ajsb", " jcb", "jbb", "djcb", "qf", "jscb", "djb", "jf", " jbb", "ajcb", "ajb", " jsb", "djd", "qsb", "jsbb", "ajf", "qb", "qcb", "jsd", "djbb", " jf", "jcb", "jsb"], "e": ["de", " ate", "in", " fe", "event", "exc", " Event", "je", "et", "E", " E", "c", "pe", "t", "ie", "v", "x", "ce", "ception", "a", "ae", "ev", "te", "ctx", "ec", "f", "ee"], "returnVal": ["Returnval", "returnNum", "resultNum", "ReturnVal", " returnVAL", "ReturnVAL", "resultVal", "returnValue", "ReturnValue", "replyVAL", " returnNum", " returnValue", "replyVal", "resultval", " returnval", "resultValue", "replyval", "replyValue", "returnVAL", "ReturnNum", "returnval"], "file": ["model", "force", "unit", "ban", "filename", "queue", "full", "page", "show", "future", "single", "dir", "name", "binary", "comment", "lib", "parent", "f", "directory", "body", "folder", "log", "pool", "po", "function", "local", "play", "b", "info", "auto", "files", "core", "handler", "io", "build", "fp", "FILE", "il", "user", "document", "get", "book", "File", "base", "module", "ile", "parse", "zip", "use", "l", "object", "home", "path", "line", "type", "out", "data", "lock", "db", "image", "letter", "rule", "die", "picture", "load", "http", "message", "pe", "buffer", "work", "part", "live", "url"], "fileName": ["singlePath", " filePath", "imageName", "binaryPath", "fileType", "filePath", "singleType", "resourceInfo", "FileInfo", "filename", "resourcePath", "binaryUrl", "FilePath", "imagename", "imageInfo", "FileName", " fileUrl", "Filename", " fileType", " filename", "imageUrl", "resourceName", "singleName", "fileUrl", " fileInfo", "singlename", "binaryName", "fileInfo", "FileType", "imagePath", "singleInfo", "resourcename"], "ext": ["enc", "format", "eng", "ension", "feat", "version", "oct", "exp", "sec", "xt", "ch", "extra", "txt", "class", "pe", "orig", "ct", "ace", "t", " Ext", "path", "fb", "p", "Ext", "type", "phrase", "alg", "v", "xp", "name", "EXT", "word", "ax", " extension", "qt", "ex", "desc", "abc", "lib", "f", "obj"], "i": ["z", "ini", "mi", "j", "o", "ion", "ment", "phi", "cli", "ii", "mini", "api", "b", "info", "ui", "ri", "pi", "c", "gi", "li", "ci", "p", "multi", "si", "ni", "io", "xi", "bi", "v", "uri", "ai", "y", "ip", "is", "bis", "a", "ti", "id", "iu", "u", "di", "m", "I"], "doIt": ["DOIt", "DOIT", "DOWhich", " doIT", "doYou", "poIt", "poit", "diIts", "addIt", " doNot", "doNot", "doit", "hoit", "diIT", "diIt", "skipit", "odoIt", "poIT", "poYou", "skipIts", "hoIT", "addIT", "doIts", "doWhich", "doIT", "skipIT", "odoNot", "odoWhich", " doYou", "odoit", " doit", "addit", " doIts", "skipIt", "DOit", " doWhich", "odoIT", "hoIt", "diit", "addNot", "hoYou"], "src": ["conv", "rx", "sub", "impl", "storage", "stream", "gz", "RC", "input", "ff", "cur", "target", "fi", "fc", "slice", "sync", "b", "bb", "cb", "sup", "ources", "buf", "gb", "r", "dist", "cdn", "rc", "sn", "path", "split", "st", "sc", "cmp", "ource", "upload", "rel", "sb", "attr", "img", "pull", "rest", "sq", "secure", "cos", "rs", "tmp", "socket", "ssl", "us", "sel", "Dest", "inst", "sth", "sl", "desc", "rb", "ctx", "uc", "bc", "loc", "source", "url"], "dest": ["wb", "die", "dev", "cont", "config", "done", "dc", "dat", " Dest", "trans", "target", "output", "later", "ctr", "uv", "wd", "sup", "home", "comb", "usr", "exit", "dist", "cdn", "route", "st", "proc", "prop", "destroy", "rest", "img", "gd", "std", "dir", "tmp", "Dest", "dep", "inst", "gen", "desc", "uc", "di", "loc", "source"]}}
{"id1": "3558512", "id2": "21827619", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"serialize": ["Serialify", " serializable", "erialize", "serialization", "erialze", "erialization", "Serialized", "Serializable", "Serialize", "finalze", "normalized", "finalize", " serialze", "Serialze", " serialization", "normalize", "serialze", "serialify", "serializable", "normalify", "erializable", "finalify", "finalized", "Serialization", "serialized", "normalze"], "out": ["err", "image", "pool", "o", "temp", "raw", "content", "w", "up", "cache", "exec", "filename", "output", "OUT", "writer", "conn", "bin", "page", "string", "buffer", "outs", "io", "Out", "client", "loader", "report", "name", "a", "dump", "archive", "server", "data", "file", "gen", "png", "ex", "i", "source", "parent", "obj", "copy"], "parser": ["base", "system", "tt", "arser", "pillar", "worker", "up", "parse", "master", "cache", "rar", "writer", "lp", "builder", "class", "txt", "pp", "pe", "handler", "er", "p", "upload", "Parser", "xml", "as", "manager", "loader", "test", "wrapper", "server", "file", "seed", "php", "instance", "ss", "reader", "per", "pkg", "cp", "parent", "plugin", "copy", "processor"], "on_disk": ["onJdisk", "onjspace", "onJdemand", "onjdrive", "on_delete", "on_drive", "onjfile", "onJlock", "onbookdisk", "onnetdemand", "on_storage", "off_demand", "on_file", "onnetdisk", "onbootdisk", "onnetspace", "onJdrive", "onbookdelete", "on_lock", "off_disk", "off_storage", "onbootlock", "onjdisk", "onnetdrive", "onbookdrive", "onbootstorage", "off_file", "onbootdrive", "off_space", "on_space", "onnetfile", "off_lock", "off_drive", "off_delete", "on_demand"], "in": ["ini", "kin", "o", "login", "stream", "inner", "inn", "input", "In", "bin", "conn", "info", "c", "pin", "IN", "r", "again", "pass", "source", "min", "ins", "lin", "as", "inas", "ac", "thin", "con", "data", "file", "rin", "ax", "reader", "i", "win", "connection", "din", "f", "socket", "inc", "copy"]}}
{"id1": "13946197", "id2": "7545002", "code1": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "code2": "    public static String POST(String url, String[][] props) throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        for (int i = 0; i < props.length; ++i) {\n            conn.addRequestProperty(props[i][0], props[i][1]);\n        }\n        conn.connect();\n        try {\n            return new String((byte[]) conn.getContent());\n        } finally {\n            conn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"transformByMD5": [" transformBymd5", " transformBymd3", " transformByMSecret", " transformByMD4", " transformByMCSecret", " transformByMD3", " transformWithM4", " transformWithM3", " transformByM5", " transformByMC3", " transformWithMD4", " transformByMC4", " transformWithM5", " transformByMC5", " transformByMDSecret", " transformBymd4", " transformWithMDSecret", " transformByM3", " transformBymdSecret", " transformWithMD3", " transformWithMSecret", " transformByM4", " transformWithMD5"], "password": ["Password", "resource", "email", " Password", "login", "account", "prefix", " passwords", "pattern", "channel", "text", "message", "filename", "wd", "object", "wallet", "device", "string", "hash", "params", "crypt", "token", "path", "padding", "phrase", "p", "attribute", "secret", "auth", "name", "PASS", "word", "data", "user", "username", "sword", "database", "connection", "config", "source", "address"], "md5": ["mand5", " mdql", "MD512", "MD5", "material5", "mdfive", "mand4", "md512", "mand45", " md512", "md2", "md4", "mddown", "amd3", " mdse", " md2", " MD45", "MDfive", "MDok", " MDdown", "mandse", "mdql", "md55", "amd512", " MD5", " MD4", "mand55", "MDql", "MDse", "MDdown", "materialfive", " MD55", " md3", " md4", " MDok", " md55", "MD3", "MD2", "mand2", " mdok", "materialql", "mdok", "amd2", "mand3", " MD3", " mddown", "md45", " md45", "amd5", "md3", "material2", " mdfive", "mdse"], "output": ["image", "letter", "unit", "written", "generated", "o", "resource", "outer", "foo", "offset", "prefix", "sequence", "format", "input", "beta", "write", "target", "property", "reason", "text", "message", "queue", "full", "page", "style", "string", "array", "display", "exit", "buffer", "result", "width", "out", "response", "secret", "hidden", "character", "generation", "word", "Output", "reference", "document", "data", "complete", "dot", "console", "config", "address"], "bufferPass": ["ufferScan", "bufferLine", "bufpass", "bufferPack", " bufferLine", "bufferLink", "BufferLink", " bufferComp", "ufferPack", " bufferCopy", " bufferPush", "ufferFeed", " bufferScan", "ufferLine", "bufferComp", "bufScan", " bufferLink", "bufferScan", "bufPass", "Bufferpass", "bufLink", "bufCopy", "bufPush", "bufferpass", " bufferFeed", "BufferComp", "bufPack", " bufferPack", "bufferPush", " bufferpass", "ufferPush", "BufferFeed", "ufferPass", "bufferFeed", "bufLine", "bufferCopy", "bufComp", "bufFeed", "ufferCopy", "BufferPass"], "b": ["body", "wb", "base", "eb", "ba", "w", "bl", " a", "l", "bb", "cb", "bytes", "url", "null", "c", "r", "abb", "buffer", "t", "d", "k", "be", "fb", "lb", "p", "line", "db", "bi", "sb", "v", "x", " eb", "y", "B", "orb", "a", "h", "bs", "binary", "ob", "e", "u", "i", "rb", "n", "bf", "br", "f", "obj", "ab", "s"]}}
{"id1": "23672408", "id2": "947406", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyIconFiles": [" copyIconFile", "copyFileImages", " copyiconImages", "copyiconFiles", "copyFileFile", "copyiconFile", "copyImageFile", "copyiconTypes", " copyiconFile", "copyFileFiles", "copyIconImages", " copyiconTypes", "copyFileTypes", "copyIconTypes", " copyiconFiles", " copyIconImages", "copyIconFile", "copyiconImages", "copyImageTypes", "copyImageImages", " copyIconTypes", "copyImageFiles"], "clazz": ["Claz", "Closs", " cluster", "cllass", "Clclass", "clab", "closed", "slod", "glazz", " clobe", "closer", "cluster", "clance", "slaz", "pllass", "hellazz", "Clab", " closed", "plclass", " cllass", "sllass", "flazz", "llasso", "flunk", " clclass", "clod", "sluster", " clab", "Cllass", "classo", "llazz", "hellasse", "Closer", " closer", "CLod", " classo", "closs", "Cluster", "glod", " closs", "slazz", "hellasso", "claz", "sloss", "glance", "llclass", "slance", "fluster", "glaz", " claz", "hellosed", " classe", "Clazz", "llasse", "ploser", "llab", "CLaz", "Clunk", "slosed", "helllass", "CLance", " clunk", "classe", "clunk", "CLazz", " clance", "hellance", "clobe", "llobe", "flaz", "hellobe", "plazz", "llaz", "clclass"], "i16": ["pi64", "ii16", "i64", "l64", "pi15", "si24", "int24", "io24", "si14", "ai16", "ii2016", "i14", "si64", "pi24", "i17", "ai2016", "I15", "int15", "io2016", "l24", "i15", "si2016", "l15", "pi16", "int2016", "ini15", "io15", "I17", "si15", "ini14", "ini2016", "ii17", "ini17", "io16", "ai15", "ini16", "l16", "ii15", "I16", "I14", "i24", "ii14", "si16", "i2016", "int16", "ii24", "ai14"], "fileType": ["fileLike", " filePatch", "playSpread", "iconType", "filePath", "singleType", "playFamily", "FileUnit", " fileAuth", "playType", "wordAuth", "wordType", " fileFamily", "feedInfo", "fileFamily", "imagePath", " fileState", "iconPath", "fileKey", "iconKey", "feedType", " fileStyle", "fileTime", "iconAuth", "feedtype", "messagePatch", "imageUnit", "wordLength", "messagetype", "fileBlock", "fileStyle", "singleStyle", "messagePath", "FileLocation", " fileLocation", " fileKey", " fileInfo", "fileFile", "feedPath", "messageType", " fileTy", "fileInfo", "imageTime", "iconLength", "transferTy", "fileTy", " fileBlock", "FileLike", " fileTime", " filePath", " fileLike", " fileUnit", "singleFile", "filetype", "documentState", "FileInfo", "transferType", "letterTy", "imageType", "fileSpread", " fileFile", "playTy", "FileFamily", "filePatch", "fileLength", "imageFamily", "imageFile", "feedPatch", "letterState", "documenttype", "letterSpread", "letterType", "wordTy", "letterFamily", "imageStyle", "lettertype", "transferFamily", "FileStyle", "fileState", "iconTy", "transferSpread", "documentType", "documentBlock", "imageKey", "feedLocation", " fileLength", "fileLocation", "feedLike", "singleTime", "letterBlock", "FileType", " filetype", "fileAuth", "fileUnit", "iconStyle"], "desti16": ["targeti2016", "destI15", "targeti16", "combini32", "desturi64", "targetI16", "desturi32", "destini16", "destf15", "combini15", "desti15", "destf16", "desti2016", "destini64", "destsi32", "targetI15", "desti016", "destabi2016", "destf2016", "combini64", "destabi016", "destini15", "destI016", "destini32", "destsi64", "combini16", "destsi16", "desturi15", "destI2016", "desti64", "combi15", "desturi16", "targeti016", "destf016", "combi32", "targeti15", "combi16", "targetI2016", "destabi15", "destabi16", "combi64", "targetI016", "destI16", "destsi15"], "src": ["resource", "thumbnails", "filename", "cb", "uv", "url", "null", "usr", "rc", "grad", "img", "sel", "file", "desc", "rb", "pkg", "uc", "lib", "scene", "source", "s", "in", "gz", "input", "cur", "target", "sync", "output", "b", "front", "r", "sc", "upload", "pull", "crop", "tmp", "sys", "scenes", "ser", "rl", "bh", "console", "loc", "ug", "support", "conv", "stream", "req", "iv", "gb", "dist", "st", "rob", "cmp", "https", "attr", "sq", "secure", "ssl", "sr", "data", "cv", "default", "socket", "image", "video", "func", "view", "root", "coll", "download", "hub", "ctrl", "http", "load", "back", "buf", "cdn", "ource", "uri", "proc", "dest", "bs", "gl", "inst", "sl", "ctx", "config", "rss"], "dst": ["sdsl", "sdsc", "adst", "adbl", "dput", "dedost", "dedst", "Dst", "rdst", "ldbl", "adct", "dsost", " dste", "drsc", "rdST", "rdsc", "dsput", "Dost", "Ddr", "Dsts", "sddest", "nrest", " dsl", "dste", "sdst", "dsts", "dbl", "idest", "Dput", "drd", "Dbl", "sdest", "idst", "drput", " ddest", "nst", "dsdr", "ldst", "drST", " drest", " dest", "nste", "sdrd", "idrd", "ddest", " dput", "ddr", "drst", "ldost", " dsts", "nsts", "dsst", "dedput", "idsl", " drd", " dbl", "sdbl", "idsc", "deddr", "adost", "dost", "ldct", "idbl", "drest", "dct", "Dct", "dest", "dsl", "dsc", "Dste", " dsc", "dST", "Drest", "iddest", " dST", "rdput"], "i32": ["I35", "ri33", "i42", "I30", "si33", "ui34", "qi32", "ini35", "ui32", "I32", "in33", "iu32", "i31", "I31", "iu33", "i30", "I33", "in15", "ini32", "i15", " i35", "ri42", "i34", "i33", " i42", " i31", "si22", "ini33", "ri32", " i34", "ui30", "in32", "qi15", "I42", "qi33", "ui31", "i22", "i35", "si32", " i33", "in34", " i22", "iu15", "iu34", "ini22", "qi34", " i30", "I34", "ri35", "si35"], "desti32": ["destsi15", " destsi32", "targeti32", "targetiu34", "destii28", "destiu34", " destsi16", "destii33", "targeti34", "desti15", "destic22", "destsi32", "destsi22", " desti22", " destsi15", "destiu33", "destin28", " desti15", "destin33", "destsi16", "destic16", "destin34", "targetiu32", "destic32", "targeti28", "destiu32", "destabi22", "targetiu28", "targeti33", "destabi32", "desti28", "destin32", "destiu28", "destic15", " destsi22", "destabi15", "destii32", "destabi16", "desti34", "desti22", "destii34", "targetiu33", "desti33"]}}
{"id1": "23677147", "id2": "6036012", "code1": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "code2": "    public byte[] getClassBytes(String className, ClassLoader classLoader) {\n        URLClassLoader cl = new URLClassLoader(urls, classLoader);\n        String resource = className.replace('.', '/') + \".class\";\n        InputStream is = null;\n        try {\n            URL url = cl.getResource(resource);\n            if (url == null) {\n                throw new RuntimeException(\"Class Resource not found for \" + resource);\n            }\n            is = url.openStream();\n            byte[] classBytes = InputStreamTransform.readBytes(is);\n            return classBytes;\n        } catch (IOException e) {\n            throw new RuntimeException(\"IOException reading bytes for \" + className, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(\"Error closing InputStream for \" + className, e);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"Sample1": [" step01", " step1", " stepInstance", " update1", " update01", " sample1", " updateInstance", " seed01", " seedInstance", " seed1", " sampleInstance", " sample01"], "myField": ["exampleFIELD", " myFIELD", "myColumn", "exampleField", "MyField", "yourColumn", "exampleColumn", "yourCondition", "Myfield", "oneColumn", "onefield", "yourfield", "myfield", "yourFIELD", " myCondition", "MyCondition", "yourField", "myFIELD", "oneField", " myfield", "MyColumn", "examplefield", " myColumn", "myCondition", "oneFIELD"], "condition1": ["ConditionOne", "Condition2", " conditionOne", "cond2", "cond1", "condOne", "conditionOne", "Condition1"], "condition2": ["field4", "condition62", "cond1", "ConditionTwo", "Condition4", "conditionTwo", "field1", "Condition2", " condition62", "reasonTwo", "cond4", "condition4", "cond2", "reason4", "Condition1", "field62", "reason2", "reason1", "cond62", " condition4", "field2", "condTwo"], "connection": ["system", "ion", "section", "function", "Connection", "cache", "password", "environment", "conn", "table", "writer", "management", "driver", "application", "sql", "cf", "c", "engine", "condition", "position", "session", "collection", "relation", "di", "BC", "query", "handler", "p", "ions", "relations", "container", "client", "context", "manager", "statement", "communication", "co", "tc", "con", "h", "server", "union", "user", "document", "e", " Connection", "cond", "connect", "database", "reader", "bc", "connected", "config", "ctx", "db", "pg", "socket", "machine", "directory"], "ps": ["ports", "its", "pt", "posts", "vs", "changes", "po", "pre", "ops", "Ps", "ls", "fe", "details", "aps", "points", "pers", "properties", "conn", "jp", "mp", "pr", "js", "sql", "sp", "pp", "pe", "tests", "pos", "pps", "files", "pa", "params", "ows", "ils", "p", "ds", "pm", "eps", "cs", "ep", "css", "os", "gres", "qs", "ins", "hs", "rs", "ups", "es", "pse", "as", "gs", "proxy", "ips", "bs", "ss", "PS", "per", "ks", "ts", "pg", "parts"], "numChanged": [" numUpdated", "numChanges", "numDelta", "sumDelta", "numberchanged", " numchanged", " numChanges", "NumDelta", "sumchanged", "sumUpdated", "NumUpdated", "numberChanges", "sumChanged", "numberChanged", " numDelta", "NumChanged", "numUpdated", "NumChanges", "numchanged", "Numchanged"]}}
{"id1": "14773782", "id2": "7044685", "code1": "    public void testJPEGRaster() throws MalformedURLException, IOException {\n        System.out.println(\"JPEGCodec RasterImage:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            JPEGImageDecoder dec = JPEGCodec.createJPEGDecoder(istream);\n            Raster raster = dec.decodeAsRaster();\n            int width = raster.getWidth();\n            int height = raster.getHeight();\n            istream.close();\n            System.out.println(\"w: \" + width + \" - h: \" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "label": 0, "substitutes": {"testJPEGRaster": [" testJPEGWatter", " testJPPGRasters", " testJPEGRotasters", " testJPEGRotast", " testJPPGrast", " testJPEGrasters", " testJPEGRotatter", " testJPEGratter", " testJPEGRasters", " testJPPGrasters", " testJPEGRast", " testJPPGraster", " testJPEGRatter", " testJPEGWasters", " testJPEGraster", " testJPEGrast", " testJPPGratter", " testJPPGRaster", " testJPEGWast", " testJPEGRotaster", " testJPPGRatter", " testJPEGWaster", " testJPPGRast"], "IOException": ["IPError", " IOError", "IPception", "OSception", "IOError", "OSException", "IOception", "OSError", "IPException", " IOception"], "start": ["base", "in", "end", "offset", "step", "pre", "art", "order", "load", "use", "info", "speed", "style", "left", "set", "scale", "pos", "starting", "from", "stage", "shift", "Start", "started", "diff", "ish", "min", "first", "length", "size", "init", "sum", "id", "data", "date", "get", "delay", "time", "source", "f"], "i": ["ini", "image", "mi", "index", "j", "oi", "yi", "hi", "inner", "phi", "ii", "ix", "fi", "slice", "key", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "abi", "li", "ci", "p", "ie", "uni", "si", "xi", "ni", "io", "multi", "v", "eni", "ai", "bi", "x", "ip", "qi", "ti", "id", "e", "iu", "f", "u", "di", "m", "I", "zi"], "url": ["image", "URL", "base", "in", "resource", "feed", "www", "download", "Url", "ls", "hub", "channel", "ref", "http", "src", "filename", "l", "href", "page", "string", "route", "album", "path", "fb", "source", "org", "uri", "img", "ur", "name", "id", "file", "data", "sl", "connection", "config", "location", "web", "f", "address"], "istream": ["ISTrib", "instep", "ISTstream", "stream", "step", "irstream", "istsore", "irstound", "ishream", "isep", "istsream", "istestream", "istep", "istsREAM", "istore", "instead", "stead", "istrib", "isagram", "stagram", "isead", "istound", "irstREAM", "ISTream", "istsep", "isream", "istsound", "isteream", "istsstream", "ishREAM", "iststream", "ISTep", "ishound", "instagram", "instream", "ishore", "istREAM", "irstore", "isterib", "isteep", "istagram", "istsrib", "istead"], "dec": ["enc", "de", " DEC", "des", "ode", "fr", "func", "vec", "dc", "cam", "draw", "dig", "exp", "sec", "rev", "rec", "DEC", "da", " decode", "c", "code", "r", "der", "oder", "next", "doc", "div", " Dec", "deg", "out", "img", "decl", "ra", "dir", "director", "neg", "data", "valid", "desc", "ec", "inc", "Dec", "s"], "raster": ["Raster", "arascal", "Roder", "rap", " rascal", "hatter", "araster", "Rap", "ratter", "eratter", "Rascal", "hap", "erasters", "eraster", "hasters", " rasters", "rascal", "rasters", " rap", "haster", " roder", "Ratter", "Rasters", "roder", "eroder", " ratter", "aroder", "arasters"], "width": ["z", "image", "flow", "ize", "dim", "wb", "shape", "Width", "density", "w", "duration", "write", "window", "age", "fw", "widget", "lon", "area", "full", "wd", "page", "left", "style", "scale", "wa", "d", "work", "en", "p", "gender", "frame", "x", "min", "img", "wn", "length", "wm", "size", "h", "layout", "weight", "west", "value", "n", "f"], "height": ["th", "dim", "right", "shape", "depth", "density", "deep", "w", "hd", "head", "window", "stroke", "dy", "pad", "rows", "padding", "work", "d", "k", "build", "v", "x", "rh", "img", "y", "length", "ady", "size", "crop", "thin", "h", "volume", "han", "angle", "inches", "Height", "max"], "stop": ["hide", "address", "shape", "change", "end", "step", "check", "ops", "skip", "output", "b", "speed", "hop", "page", "fill", "set", "summary", "cut", "exit", "drop", "clip", "sort", "remove", "snap", "sleep", "Stop", "number", "sign", "rest", "trip", "pop", "block", "pause", "keep", "spot", "roll", "limit", "comment", "zero", "wait", "delay", "save"]}}
{"id1": "13596891", "id2": "18613870", "code1": "    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n        String szUrl = request.getParameter(\"url\");\n        System.out.println(szUrl);\n        URL url;\n        InputStream is = null;\n        ServletOutputStream sout = null;\n        try {\n            url = new URL(szUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            Enumeration hNames = request.getHeaderNames();\n            while (hNames.hasMoreElements()) {\n                String txt = hNames.nextElement().toString();\n                con.setRequestProperty(txt, request.getHeader(txt));\n            }\n            con.setRequestProperty(\"host\", url.getHost());\n            con.setRequestProperty(\"refer\", szUrl);\n            con.setRequestMethod(method);\n            con.setDoOutput(true);\n            con.setDoInput(true);\n            InputStreamReader inBody = new InputStreamReader(request.getInputStream());\n            char bufCh[] = new char[1024];\n            int r;\n            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());\n            while ((r = inBody.read(bufCh)) != -1) {\n                System.out.println(bufCh);\n                outReq.write(bufCh, 0, r);\n            }\n            outReq.flush();\n            outReq.close();\n            inBody.close();\n            System.out.println(con.getResponseCode());\n            System.out.println(con.getResponseMessage());\n            if (con.getResponseCode() == con.HTTP_OK) {\n                response.setContentType(con.getContentType());\n                response.addHeader(\"Content-Encoding\", con.getContentEncoding());\n                sout = response.getOutputStream();\n                is = con.getInputStream();\n                byte buff[] = new byte[1024];\n                while ((r = is.read(buff)) != -1) {\n                    sout.write(buff, 0, r);\n                    System.out.print(buff);\n                }\n                sout.flush();\n                is.close();\n                sout.close();\n            } else {\n                response.sendError(con.getResponseCode(), con.getResponseMessage());\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"doTransfer": ["handleRequest", " doSend", "makeSend", " doImport", "makeRequest", "handleSend", "handleImport", "doRequest", " doRequest", "makeImport", "doImport", "doSend", "makeTransfer", "handleTransfer"], "request": ["re", "com", "model", "in", "resource", "q", "create", "this", "stream", "current", "event", "form", "input", "version", "req", "http", "message", "queue", "remote", "post", "QUEST", "object", "application", "rf", "condition", "position", "session", "subject", "query", "Request", "type", "result", "record", "client", "command", "requ", "context", "xml", "report", "received", "server", "data", "user", "time", "instance", "reader", "complete", "enter", "connection", "config"], "response": ["re", "onse", "image", "body", "index", "model", "service", "resource", "site", "serv", "view", "event", "warning", "content", "Response", "json", "version", "http", "message", "cache", "output", "remote", "respond", "writer", "full", "object", "page", "application", "status", "session", "resp", "next", "success", "en", "result", "cover", "out", "client", "report", "server", "document", "call", " Response", "error", "results", "res", "default", "connection", "reply", "header"], "method": ["cmd", "resource", "send", "prefix", "content", "format", "direction", "json", "head", "METHOD", "property", "version", "mode", "reason", "text", "message", "process", "use", "string", "class", "status", "position", "subject", "route", "session", "path", "sort", "type", "pull", "sign", "command", "Method", "term", "verb", "call", "callback", "description", "date", "hod", "time"], "servletContext": ["ServletsController", "ServletsContext", " servantProvider", " servantCurrent", " servletConfig", "servApplicationConfig", "servantConfig", "ServletContext", "servLETConfig", "servletsContext", "servApplicationContext", "servApplicationController", "servletsController", "servantContext", "servLETCurrent", "servletController", "servApplicationcontext", "servletcontext", "ServletsConfig", "servleContext", "Servletscontext", "servlexcontext", "servantProvider", "servlexContext", "servletProvider", " servantConfig", "ServletConfig", "Servletcontext", "servleCurrent", "servleProvider", "servlexConfig", "servleConfig", " servletCurrent", "servLETProvider", "ServletController", " servletProvider", "servletConfig", " servantContext", "servletsConfig", "servlexController", "servLETContext", "servletscontext", "servletCurrent", "servantCurrent"], "wac": ["wsac", " wae", "wae", "wsacs", " Wac", " wAC", " WAC", "wAC", "wsAC", " Wae", "wsae", " wacs", "wacs", " Wacs"], "szUrl": ["sizPath", "szerFrame", " sizURL", "asizFrame", " szURL", "sziURL", "aszURL", " szurl", "szFolder", "aszurl", "szaUr", "sizURL", "sznurl", "aszFrame", "sizFolder", "szurl", "szeFrame", "szerUrl", "szeURL", "szenFolder", " sizUrl", "szenUrl", "sznPath", "aszUr", "asizURL", " sizFolder", "aszUrl", " szFolder", "sizFrame", "szerUr", "sziUrl", "sziurl", "szUr", "szaURL", "sziUr", "szeUr", "sizUr", "szeUrl", "aszPath", "szFrame", "szenURL", "sznUr", "szaPath", "asizurl", "sizurl", "sizUrl", "szenurl", "asizPath", "sznUrl", "szaUrl", "sznURL", "szeurl", "szerURL", "szeFolder", "asizUr", "asizUrl", " sizurl", "szPath", "szURL"], "url": ["re", "log", "base", "URL", "resource", "service", "www", "impl", "config", "stream", "event", "ul", "Url", "obj", "http", "key", "l", "conn", "page", " URL", "string", "buffer", "cloud", "li", "lb", "fl", "source", "rel", "org", "uri", "client", "il", "xml", "context", "ur", "name", "ssl", "socket", "location", "server", "user", "file", "ll", "gl", "el", "sl", "rl", "get", "connection", "loc", "host", "web", "f"], "is": ["ib", "rx", "serv", "isi", "ii", "src", "cms", "ir", "lis", "has", "info", "isu", "IS", "ri", " bis", "isf", "rc", "was", "ci", "ils", "ris", "io", "os", "uri", "it", "x", "ai", "isa", "isl", "oss", "ip", "iss", "il", "as", "iso", "bis", "us", "bs", "isc", " are", "ios", "Is", "i", "im", "ais", " isn", "web"], "sout": ["souts", "Sin", "SOUT", " souts", "Sout", "sOUT", "SOut", "sOut", " sOUT", " sdata", "Sdata", "sdata", "Souts", " sOut", " sin", "sin"], "con": ["com", "crit", "fa", "san", "Connection", "status", "cf", "c", "ct", "rc", "query", "single", "const", "uc", "connection", "m", "lc", "login", "cl", "wan", "pc", "cur", "ca", "cache", "run", "java", "conn", "CON", "ran", "core", "Common", "co", "server", "user", "ocon", "connect", "general", "win", "get", "non", "re", "conv", "don", "event", "common", "fun", "pre", "cons", "nc", "fe", "version", "fc", "remote", "l", "un", "wa", "type", "Internal", "xc", "client", "Con", "util", "ssl", "cn", "on", "gen", "cp", "ec", "inc", "exec", "web", "conf", "ver", "func", "can", "view", "syn", "coll", "open", "net", "pen", "ctrl", "http", "C", "pin", "subject", "author", "en", "ren", "min", "cc", "cos", "close", "internal", "bc", "ctx"], "hNames": ["ihNames", " hName", "HVs", "hrFiles", "hFiles", "hTypes", "HFiles", "hName", "hBlocks", "hVs", "ihBlocks", "hrNs", "hrKeys", "hostNs", " hKeys", "hrName", "ihVs", "hostKeys", "ihName", "hNs", "hKeys", " hNs", " hTypes", "HNames", "hostTypes", " hBlocks", "HName", " hFiles", " hVs", "hostNames", "hrTypes", "HTypes", "HBlocks", "hrNames"], "txt": ["nm", "in", "q", "nt", "inet", "section", "rx", "xxx", "vt", "gz", "utt", "et", "py", "ht", "htm", "XT", "text", "zip", "xt", "key", "gt", "cb", "csv", "jp", "struct", "prot", "git", "kt", "gi", "wt", "ct", "Text", "t", "tin", "wx", "phrase", "dt", "rr", "sv", "v", "elt", "fp", "bt", "fx", "name", "lv", "lt", "binary", "value", "str", "tx", "qt", "ctx", " text", "TEXT", "obj", "header"], "inBody": [" inReader", "INReader", "outbody", "outFile", "inStream", "inFile", "InFile", "insBody", "INStream", "INFile", "InReader", " inFile", "outBody", "inReader", "insReader", " inStream", " inbody", "outStream", "Inbody", "InStream", "INbody", "inbody", "insStream", "INBody", "insFile", "InBody"], "bufCh": ["bufC", "queueCol", "buffC", "ufChar", "bufferCh", " bufCH", "bufch", " bufCol", "ufC", "buffCh", "queuech", "ufCH", "ufCh", " bufch", "bufferch", "ufCol", "buffCH", "bufCol", "queueCh", "queueCH", "bufferChar", "bufCH", "ufch", "buffch", " bufChar", " bufC", "bufferCH", "bufChar"], "r": ["re", "err", "lr", "q", "br", "fr", "w", "rt", "ror", "b", "pr", "ri", "rg", " rg", "c", "rd", "rf", "g", "rc", "k", "d", "er", "p", "u", "result", "rr", "v", "nr", "x", "rh", "ner", "rs", "hr", "sr", "R", "range", "ar", "e", "str", "f", "i", "rb", "rl", "rw", "reader", "ru", "reg", "m", "n", "cr", "res"], "outReq": [" outRce", "outReque", "outRsh", "outRsq", "outSeq", "outEque", "outRq", " outEreq", " outRque", "outRecq", "outEreq", " outReh", " outSeck", "outRecque", "outRce", "outREh", "outSeck", "outReck", " outRereq", " outRq", "outRsque", "outSece", "outEq", " outSeq", "outConque", "outDece", "outSeque", " outEck", "outREck", "outRecce", "outRck", "outDeq", "outRequest", "outREce", " outRece", " outSeque", "outREq", "outREque", "outConce", "outRecreq", "outRque", "outRecck", " outSece", " outEq", "outRquest", "outConh", " outRquest", "outDequest", "outRece", " outRsq", "outRreq", "outReh", " outRequest", "outConq", " outReque", " outRsque", "outRsce", "outSequest", " outRsce", "outDeque", " outReck", "outEck", " outRsh", " outEque", "outRereq"], "buff": ["num", " buffers", "lines", " chunk", "uf", "bb", "info", "b", "ch", "array", "buf", "buffer", "Pad", "p", "Buff", " Buff", "Msg", "map", "Ptr", "data", "file", "Info", "Buffer", "f", " Buffer"]}}
{"id1": "14473711", "id2": "3514286", "code1": "    public static String str2md5(String str) {\n        try {\n            MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE);\n            alga.update(str.getBytes());\n            byte[] digesta = alga.digest();\n            return byte2hex(digesta);\n        } catch (NoSuchAlgorithmException ex) {\n            return str;\n        }\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"str2md5": ["str2digse", "str2MD5", "str2dig512", "str2dig3", "str2h3", "str2MD3", "str2dig5", "str_MDse", "str2h5", "str_md3", "str_mdse", "str2h512", "str2MDse", "str_md512", "str2MD512", "str_MD3", "str2hse", "str2md3", "str2md512", "str_MD5", "str_md5", "str_MD512", "str2mdse"], "str": ["enc", "err", "dr", "in", "fr", "br", "kr", "hex", "inner", "format", "input", "arr", "exp", "text", "STR", "bytes", "url", "string", "txt", "code", "sp", "r", "spec", "buffer", "t", "tr", "pass", "st", "er", "p", "dict", "source", "result", "name", "test", "sr", "data", "char", "Str", "empty", "i", "msg", "strings", "cr", "f", "obj", "s"], "alga": ["alca", " alqa", "Alga", " alda", "ALja", "elgas", "alsga", "ala", "ALgas", "Algas", " ala", "Alja", "ALsa", "ela", "alsqa", "ALda", "alsca", " alca", " alja", "alsa", "alqa", "elda", "elga", " algas", "ALqa", "ALga", "alda", "Alsa", "ALa", "algas", "alja", "alsda", "ALca", " alsa"], "digesta": ["igza", "badza", "finesta", "badera", "igesta", "igosta", "digza", "codeste", "igera", "codsta", "diffesta", "diffsta", "diffosta", "finsta", "digeste", "codera", "codosta", "digosta", "digsta", "codesta", "diffeste", "fineste", "digera", "badosta", "codza", "badesta", "finosta"]}}
{"id1": "17580775", "id2": "7118860", "code1": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "code2": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "label": 1, "substitutes": {"runInternal": ["doInternal", "processExternal", "doImpl", " runImpl", " runSync", "processSync", "runImpl", "runSync", "processInternal", "doExternal", " runExternal", "runExternal", "doSync", "processImpl"], "connection": ["resource", "current", "channel", "Connection", "c", "collection", "layer", "command", "context", "expression", "communication", "volume", "component", "source", "machine", "directory", "body", "lc", "log", "graph", "service", "ion", "function", "cache", "password", "builder", "driver", "engine", "session", "relation", "handler", "character", "operation", "server", "document", "connect", "error", "database", "reader", "timeout", "loc", "inner", "event", "entry", "version", "use", "remote", "object", "option", "position", "creator", "translation", "container", "entity", "client", "request", "port", "default", "connected", "location", "socket", "image", "index", "section", "message", "environment", "application", "condition", "statement", "proxy", "con", "wrapper", "description", "config"], "visited": ["visITED", "VISitted", "viewITED", "viewitted", "invitted", "VISed", "invited", "VisITED", "viewed", "invITED", "invalled", "Vised", "Visalled", "viewited", "VISited", "visalled", "VISITED", "VISalled", "vised", "visitted", "Visited", "Visitted"], "startTimeStamp": ["startTimeEstng", "startLineStamp", "startTimestamp", "startTimeStamps", "startTimeestng", "startTimeStng", "startTimeestamps", "startLineEstamp", "startTimestamped", "startLineEstamps", "startLineEstng", "startTimestng", "startLineStamps", "startLineStamped", "startLineEstamped", "startTimeestamped", "startTimeEstamped", "startTimeStamped", "startTimeEstamp", "startTimeestamp", "startTimeEstamps", "startLineStng", "startTimestamps"], "delayedProgress": ["eladedProgress", "delayedContent", "elayedStatus", "deladedContent", "delivedProgress", "eladedComplete", "delayedStatus", "elayedComplete", "deliverComplete", "delivedContent", "deliverProgress", "delayedComplete", "eladedContent", "deladedStatus", "deliverContent", "delivedComplete", "deladedProgress", "elayedContent", "eladedStatus", "deliverStatus", "elayedProgress", "delivedStatus", "deladedComplete"], "conn": ["enc", "lc", "conv", "nt", "config", "dc", " con", "cli", "nc", "ls", "open", "obj", "channel", "Connection", "http", "exec", "sync", "l", "ch", "cb", "connected", "ann", "att", "act", "c", "cf", "ct", "rc", "ci", "ad", "cmp", "io", "client", "cc", "comm", "ssl", "co", "con", "h", "cn", "connect", "mc", "Conn", "n", "ctx", "cp", "loc", "uc", "db"], "fileName": [" filePath", "imageName", "contentSpace", "filePath", "urlPath", "urlKey", "fileArea", "filename", " fileSpace", "FilePath", "contentName", "fileSpace", "imagename", "FileName", " filename", "FileArea", "contentname", " fileKey", "imagePath", "FileKey", "urlArea", "contentPath", " fileArea", "urlName", "imageSpace", "fileKey"], "disp": ["disap", "schep", "Disap", "Dispend", "Disps", "detp", "interpp", "disps", "defpart", "Dispatch", "dispe", "broadps", "Disp", "broadpart", "dispart", "defpend", "prope", "Dispr", "Dispe", "interap", "interpe", "broadpend", "defps", "Dispose", "dispose", "dispend", "dispp", "dispr", " dispr", "DisP", " dispe", "dispatch", "detpp", "interp", "prop", "Dispart", "defp", "interpatch", "scheap", "schepatch", "detpatch", " dispose", "detP", "propr", "propose", "schepe", "broadp", "Dispp", "disP", "interP"], "p": ["np", "index", "pat", "o", "j", "q", "end", "point", "po", "pre", "ap", "patch", "rep", "P", "at", "ping", "l", "b", "api", "jp", "pr", "after", "lp", "bp", "pi", "c", "pe", "r", "pp", "sp", "pos", "g", "pa", "t", "d", "m", "pl", "op", "vp", "part", "v", "y", "ip", "col", "h", "tp", "e", "i", "n", "loc", "f"], "response": ["body", "image", "model", "index", "resource", "feed", "site", "found", "Response", "respons", "function", "json", "version", "http", "message", "reset", "output", "api", "respond", "prot", "page", "status", "code", "collection", "resp", "path", "success", "next", "successful", "en", "result", "pointer", "uri", "ception", "received", "request", "server", "data", "id", "radius", "error", "value", "description", "timeout", "complete", "reply"], "contentType": ["documentTyp", "documentLength", "messageInfo", "ContentTyp", "contentTyp", "contentName", "documentType", "contentLength", "contentInfo", " contentInfo", "ContentLen", "ContentInfo", "messageLength", "ContentLength", " contentLength", " contentName", "messageType", "ContentName", "documentName", "messageLen", " contentTyp", "ContentType"], "contentEncoding": ["loadEncasing", "contentencoder", "contentEnaring", "contentDecoding", "contentCasing", "ContentEncReading", "contentencReading", "contentLocasing", "contentEncasing", "loadEnaring", "ContentDecoding", "contentEncoder", "contentEnoding", "ContentDecoder", "contentEoding", "loadEnryption", "contentCryption", "contentLocaring", "contentEReading", "ContentEncoding", "contentEocol", "contentLocryption", "contentencocol", "contentEnasing", "contentEnryption", "ContentEncocol", "contentEncryption", "contentEncaring", "contentEncocol", "loadEnasing", "ContentEncoder", "contentDecocol", "contentLocoding", "contentCoding", "loadEncoding", "contentDecoder", "contentEoder", "contentencoding", "contentEncReading", "loadEnoding", "contentDecReading", "ContentDecReading", "loadEncaring", "ContentDecocol", "contentCaring", "loadEncryption"], "contentLen": [" contentlen", "resourceLen", "resourcelen", "contentLength", " contentSl", "contentSize", "contentlen", "Contentlen", "activitySl", "ContentLen", "ContentLength", "resourceSize", "ContentSl", " contentLength", " contentSize", "contentSl", "activityLength", "activitySize", "activityLen", "resourceLength", "ContentSize"], "is": ["ion", "can", "ub", "mis", "net", "version", "un", "IS", "igh", "not", "ig", "ync", "isp", "os", "it", "isl", "out", "iss", "ip", "are", "ys", "us", "isc", "ot", "ios", "ss", "im"], "url": ["image", "link", "log", "html", "URL", "service", "resource", "email", "feed", "download", "Url", "json", "channel", "http", "text", "page", "status", "string", "buffer", "path", "source", "org", "uri", "layer", "client", "context", "socket", "ssl", "location", "server", "user", "file", "document", "username", "str", "sl", "config", "host", "address"], "loadNext": ["checkPrevious", "loadingPrevious", "loadsFirst", "checkNext", "loadsLast", "loadingFirst", "loadsNext", "checkLast", "loadingLast", "loadPrevious", "loadsPrevious", "loadingNext", "checkFirst", "loadFirst", "loadLast"], "itemsLoadedPartially": ["itemsLoadedCopials", "itemsLoadedCopial", "itemsLoadedPartials", "itemsLoadedpartial", "itemsLoadippedPartial", "itemsLoadedPartial", "itemsLoadippedPartally", "itemsLoadedCopally", "itemsLoadedPARTial", "itemsLoadedCopially", "itemsLoadippedPartially", "itemsLoadedPARTials", "itemsLoadippedpartially", "itemsLoadedPARTally", "itemsLoadippedpartial", "itemsLoadippedpartally", "itemsLoadedPartally", "itemsLoadedpartials", "itemsLoadedPARTially", "itemsLoadedpartially", "itemsLoadippedPartials", "itemsLoadedpartally", "itemsLoadippedpartials"]}}
{"id1": "13886238", "id2": "8921716", "code1": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"init": ["setup", "check", "launch", "art", "open", " Init", "parse", "load", "reset", "info", "update", "destruct", "strap", "it", "build", "rest", "Init", "start", "test", "construct", "initialized", " reload", "error", "config", " discover", "activate"], "backupFile": ["BackureFile", "backacyFile", "lookoutFile", "backbackFILE", "BackdownFile", "backdownFile", "BackdownFiles", "backbookStream", "backoutFile", "lookoutFILE", "backUPFiles", "backupsFile", "BackureFiles", "backupsDir", "backureFile", "backbookF", "backoutFolder", "backrapFile", "backrapFiles", "backoutfile", "backupFolder", "BackupStream", "backbookFile", "backUPFile", "backUPStream", "backacyFILE", "BackupFiles", "backureSourceFile", "backdownF", "BackupSourceFile", "backureDir", "BackupDir", "backupF", "backupfile", "backupFiles", "lookupFILE", "BackureDir", "lookupfile", "backureFiles", "backupSourceFile", "backacyfile", "backrapSourceFile", "BackdownStream", "backbookFiles", "backdownStream", "lookoutFolder", "BackureSourceFile", "backdownFiles", "backbackFolder", "lookupFile", "backUPF", "backupsFiles", "backbackfile", "BackupF", "BackdownF", "backbackFile", "lookoutfile", "backupStream", "backrapDir", "backacyFolder", "backoutFILE", "backupFILE", "BackupFile", "backupDir", "lookupFolder", "backupsSourceFile"], "buff": ["cast", "cmd", "shape", "feed", "ffff", "bind", "gz", "flush", "ff", "fe", "oct", "zip", "load", "back", "slice", "now", "uf", "bb", "cb", "b", "ch", "pad", "utf", "fab", "txt", "buf", "pp", "gb", "bound", "comb", "uff", "buffer", "font", "cod", "ph", "fb", "bf", "boot", "sb", "Buff", "build", "comp", "gg", "length", "pb", "app", "ob", "char", "cond", "comment", "rb", "mb", "bg", "cp", "grab"], "in": ["ini", "image", "login", "serv", "stream", "inner", "inn", "gin", "input", "In", "up", "slice", "l", "bin", "b", "url", "c", "pin", "IN", "r", "again", "pass", "nin", "part", "cin", "diff", "min", "ins", "lin", "ssl", "ac", "inside", "con", "data", "id", "isin", "e", "el", "reader", "i", "win", "n", "get", "or", "connection", "old", "din", "exec", "f", "socket", "inc", "s"], "out": ["err", "o", "serv", "prefix", "inner", "net", "up", "exp", "sync", "output", "OUT", "writer", "bin", "conn", "b", "IN", "again", "pass", "outs", "doc", "line", "part", "io", "Out", "client", "ins", "ext", "co", "user", "file", "ax", "gen", "ex", "reader", "win", "one", "n", "lib", "inc", "exec", "conf", "socket", "copy"], "read": ["bind", "current", "skip", "next", "ok", "ask", "block", "length", "search", "lex", "log", "send", "child", "check", "write", "input", "count", "reading", "Read", "run", "add", "play", "sync", "b", "ride", "fill", "r", "pass", "d", "k", "ad", "build", "ip", "size", "id", "connect", "last", "reader", "get", "wait", "seek", "select", "reach", "copy", "ink", "parse", "reads", "text", "use", "readable", "ind", "sleep", "se", "x", "row", "data", "READ", "level", "lock", "exec", "max", "index", "feed", "raw", "end", "view", "open", "find", "load", "buffer", "work", "en", "close", "start", "roll", " Read", "i", "n", "iter"], "reportWriter": ["reportDriver", "reviewDriver", " reportReader", "reviewWrite", "commentWriter", "commentStream", "reportedDriver", "summaryStream", "reportWrite", "exportHelper", "reportHelper", " reportHelper", "reportEditor", " reportWalker", " reportJournal", "summaryPublisher", "ReportReader", "reportedEngine", " reportEngine", " reportPublisher", "reportReader", "ReportApplication", " reportApplication", "reportWs", "reviewTime", "reviewEditor", "summaryWrite", "exportPublisher", "reportEngine", "reportStream", "reportedWriting", "ReportWrite", " reportTime", "reportWriting", "reportPage", "exportReader", " reportDriver", "reportedWriter", "exportApplication", "ReportWs", "exportJournal", "reportApplication", " reportWs", "exportWalker", "reportTime", " reportWriting", "reportedWrite", "exportWriter", "summaryWriter", "reportedReader", "resultWriter", "reportedTime", "reviewEngine", "ReportWriter", "commentPage", " reportWrite", "reportedHelper", "reportedEditor", "reportWalker", "exportWrite", "reportJournal", "reportedWs", "reportPublisher", "commentWrite", "summaryPage", "ReportWriting", "summaryJournal", " reportEditor", "resultWrite", "resultPage", "resultStream", "reviewWriter", "reportedWalker"], "restarting": ["restarmed", "Restartable", "restartsating", "restarsing", "restartING", "restartable", "restritING", "Restarted", "Restartating", "restartsING", "Restarting", "restartsting", "restartating", "Restrited", "restarmable", "restrupted", "restritting", "Restartting", "restarmING", "restritable", "restarming", "RestritING", "restritating", "restarsING", "RestartING", "restarsating", "Restritable", "restarted", "restartting", "Restritting", "restarsting", "Restriting", "restruptING", "Restritating", "restrupting", "restruptable", "restartsing", "restrited", "restriting"]}}
{"id1": "3375724", "id2": "22366505", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" importarEmissoresDosTitulasf", " importarEmissoresDosTitulasFe", " importarEmissoresDosTitulosf", " importarEmissoresDosTitULosPF", " importarEmissoresDosTitularF", " importarEmissoresDosTitulosPF", " importarEmissoresDosTituloFe", " importarEmissoresDosTituloF", " importarEmissoresDosTitularFe", " importarEmissoresDosTitulasF", " importarEmissoresDosTitULoFe", " importarEmissoresDosTitularf", " importarEmissoresDosTitulosF", " importarEmissoresDosTitULoPF", " importarEmissoresDosTitularPF", " importarEmissoresDosTitulosFe", " importarEmissoresDosTituloPF", " importarEmissoresDosTitULosF", " importarEmissoresDosTitulof", " importarEmissoresDosTitULoF", " importarEmissoresDosTitULosf", " importarEmissoresDosTitULof", " importarEmissoresDosTitulasPF", " importarEmissoresDosTitULosFe"], "pArquivoTXT": ["pArquivoDXT", "pArquivaTxt", "pArquivoFEMP", "pArquivoTTP", "pArquivoFxt", "pArquivDBT", "pArquivDXT", "pArquivoOTEMP", "pArquivaTEXT", "pArquivoBxt", "pArquivoLBT", "pArquivaFEXT", "pArquivoBXT", "pArquivaFTP", "pArquivoBEMP", "pArquivoTLS", "pArquivoTEMP", "pArquivTLS", "pArquivaFxt", "pArquivoLXT", "pArquivoQxt", "pArquivoQXT", "pArquivaFEMP", "pArquivoOTTP", "pArquivoFTP", "pArquivoDEXT", "pArquivoLxt", "pArquivoOTxt", "pArquivoBLS", "pArquivoTBT", "pArquivDxt", "pArquivaTEMP", "pArquivoLLS", "pArquivaTTP", "pArquivoQEXT", "pArquivoDLS", "pArquivoFEXT", "pArquivoQBT", "pArquivoDBT", "pArquivoTxt", "pArquivoFBT", "pArquivoFXT", "pArquivaTBT", "pArquivoTEXT", "pArquivaFBT", "pArquivoDxt", "pArquivTXT", "pArquivoBTP", "pArquivTBT", "pArquivDLS", "pArquivTxt", "pArquivoOTXT", "pArquivaFXT", "pArquivaTXT", "pArquivoBBT"], "pAndamento": [" pOrementO", " pOrementos", " pAndmentO", " pOrementoo", " pAndemento", " pAndmentos", " pAndamentO", " pAndementO", " pAndentiono", " pAndementoo", " pAndamentos", " pOramentO", " pAndentionos", " pAndmentoo", " pAndementos", " pOremento", " pAndamentoo", " pOramento", " pAndmento", " pOramentoo", " pAndentionoo", " pAndentionO", " pOramentos"], "numeroDoRegistro": ["numeroDoRegestro", "numeroDoregistro", "numeroDoRegiftorno", "numeroDoRegestrano", "numeroDoRegpectros", "numeroDoregestros", "numeroDoRegiftros", "numeroDoRegestorno", "numeroDoRegpectrano", "numeroDoregistros", "numeroDoregestorno", "numeroDoRegiftrano", "numeroDoregistrano", "numeroDoRegpectro", "numeroDoRegestros", "numeroDoRegiftro", "numeroDoRegpectorno", "numeroDoregistorno", "numeroDoregestro", "numeroDoRegistrano", "numeroDoRegistorno", "numeroDoRegistros", "numeroDoregestrano"], "in": ["ini", "err", "kin", " out", "login", "config", "inn", "scan", "cl", "with", "In", "slice", "l", "b", "bin", "c", " IN", "r", "IN", "session", "g", "again", "t", "query", "nin", "part", "conf", "cin", "out", "ins", "is", "ner", "con", "ln", "span", "rin", "data", "ex", "reader", "i", "n", "connection", "m", "inc", "f", "url", "s"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicioDestaco", "stmtLimpezaInicialDestania", "stmtLimpezaInicioCombario", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialCombination", "stmtLimpezaInicialDestario", "stmtLimpezaInicialDesino", "stmtLimpezaInicioDestario", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialCombania", "stmtLimpezaInicialDesaco", "stmtLimpezaInicioDestao", "stmtLimpezaInicialdestaco", "stmtLimpezaInicioCombaco", "stmtLimpezaInicialDestination", "stmtLimpezaInicialCombino", "stmtLimpezaInicialCombaco", "stmtLimpezaInicialDesao", "stmtLimpezaInicioCombao", "stmtLimpezaInicialCombario", "stmtLimpezaInicialdestao", "stmtLimpezaInicioDestino", "stmtLimpezaInicialCombao", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialDestaco", "stmtLimpezaInicialDestao", "stmtLimpezaIniciaDestania", "stmtLimpezaInicialDesario", "stmtLimpezaInicialdestania", "stmtLimpezaInicialdestino", "stmtLimpezaInicialdestario", "stmtLimpezaInicialdestination", "stmtLimpezaInicioCombino"], "sql": ["err", "body", "log", "sol", "cmd", "setup", "html", "nl", "lua", "json", "ls", "SQL", "details", "zip", "http", "filename", "software", "liquid", "l", "shell", "csv", "string", "spec", " SQL", "params", "sn", "query", "kl", "select", "stat", "result", "ql", "sg", "sv", "sb", "eps", "sq", "expr", "where", "QL", "util", "statement", "ssl", "socket", "term", "sys", "search", "data", "id", "fn", "seed", "layout", "sf", "description", "sl", "comment", "rl", "el", "dl", "msg", "acl", "db", "install", "url", "s"], "stmtDestino": ["stmtCampino", "stmDestino", "stmtDistinos", "stmtDestinos", "stmCampaco", "stmdDestin", "stmtdestin", "stmCampania", "stmtDistino", "stmCampino", "stmdDestorno", "stmtDistaco", "stmtdestaco", "stmdDestino", "stmtDestin", "stmtDestaco", "stmCamporno", "stmtDestania", "stmtDestorno", "stmtDistorno", "stmtCampania", "stmdDestinos", "stmtCamporno", "stmtdestania", "stmtdestino", "stmDestaco", "stmDestania", "stmtDistin", "stmtdestinos", "stmtDistania", "stmDestorno", "stmtCampaco", "stmtdestorno"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABOCALSHOU", "TAMANHO_DO_CABECALCO", "TAMANHO_DO_CABECALSHOU", "TAMANHO_DO_CABECULHOU", "TAMANHO_DO_CABECALHOU", "TAMANHO_DO_CABOCALHO", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABECALSCO", "TAMANHO_DO_CABOCALCO", "TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABISCALHO", "TAMANHO_DO_CABECALLHOU", "TAMANHO_DO_CABISCALLHO", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABISCALLHI", "TAMANHO_DO_CABOCALSCO", "TAMANHO_DO_CABOCALSHO", "TAMANHO_DO_CABECALLCO", "TAMANHO_DO_CABECALSHO", "TAMANHO_DO_CABECARHOU", "TAMANHO_DO_CABOCALHOU", "TAMANHO_DO_CABISCALHI", "TAMANHO_DO_CABISCALLHOU", "TAMANHO_DO_CABISCALHOU", "TAMANHO_DO_CABECARCO", "TAMANHO_DO_CABECALSHI"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPE__DO", "TAMANHO_DO_RODAPJDO", "TAMANHO_DO_RODAPEECPO", "TAMANHO_DO_RODAPE_TO", "TAMANHO_DO_RODAPE__do", "TAMANHO_DO_RODAPJdo", "TAMANHO_DO_RODAP_TO", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAP_Do", "TAMANHO_DO_RODAPEJPO", "TAMANHO_DO_RODAPEJdo", "TAMANHO_DO_RODAPEECDO", "TAMANHO_DO_RODAPEJTO", "TAMANHO_DO_RODAPE_PO", "TAMANHO_DO_RODAP_PO", "TAMANHO_DO_RODAPEECDo", "TAMANHO_DO_RODAPJPO", "TAMANHO_DO_RODAPJDo", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAPE__TO", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAPE__Do", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAPJTO"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADANDOJ", "TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADADOPS_", "TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADADosAD", "TAMANHO_DOS_METADADIESJ", "TAMANHO_DOS_METADADOS___", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADADOAD", "TAMANHO_DOS_METADADOSJ", "TAMANHO_DOS_METADANDOAD", "TAMANHO_DOS_METADANDOS___", "TAMANHO_DOS_METADADOTSAD", "TAMANHO_DOS_METADANDO_", "TAMANHO_DOS_METADADOPS___", "TAMANHO_DOS_METADADIES_", "TAMANHO_DOS_METADADOJ", "TAMANHO_DOS_METADANDOS_", "TAMANHO_DOS_METADADOSAD", "TAMANHO_DOS_METADANDO___", "TAMANHO_DOS_METADADOTS_", "TAMANHO_DOS_METADADOPSJ", "TAMANHO_DOS_METADADO___", "TAMANHO_DOS_METADADIES___", "TAMANHO_DOS_METADANDOSJ", "TAMANHO_DOS_METADANDOSAD"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_PORPRECIES", "TAMANHO_MEDIO_PORPREGES", "TAMANHO_MEDIO_POR_RECAS", "TAMANHO_MEDIO_PORPREGIC", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_PORPRECAS", "TAMANHO_MEDIO_POR_GAS", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_PORPREGAS", "TAMANHO_MEDIO_PORPREGIT", "TAMANHO_MEDIO_POR_REGIT", "TAMANHO_MEDIO_PORPRegES", "TAMANHO_MEDIO_POR_GIES", "TAMANHO_MEDIO_POR_REGAS", "TAMANHO_MEDIO_PORPRegIT", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_POR_EGIS", "TAMANHO_MEDIO_POR_GIC", "TAMANHO_MEDIO_POR_GIS", "TAMANHO_MEDIO_POR_RegIT", "TAMANHO_MEDIO_POR_EGES", "TAMANHO_MEDIO_PORPRegIS", "TAMANHO_MEDIO_POR_EGIES", "TAMANHO_MEDIO_POR_REGIES", "TAMANHO_MEDIO_POR_RegIS", "TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_PORPRECIC", "TAMANHO_MEDIO_POR_RegIC", "TAMANHO_MEDIO_PORPREGIES", "TAMANHO_MEDIO_PORPRegIES", "TAMANHO_MEDIO_POR_EGIT", "TAMANHO_MEDIO_POR_RECIES", "TAMANHO_MEDIO_PORPRECIS", "TAMANHO_MEDIO_POR_RegAS", "TAMANHO_MEDIO_PORPREGIS", "TAMANHO_MEDIO_POR_RegIES"], "tamanhoDosArquivos": ["tamanhoDosArquivalo", "tamanhoDosArQUivlos", "tamanhoDosArquervlos", "tamanhoDosArqIVos", "tamanhoDosArquIVoes", "tamanhoDosArQUivo", "tamanhoDosArquievo", "tamanhoDosArqivos", "tamanhoDosArQUervo", "tamanhoDosArquervo", "tamanhoDosArquievOs", "tamanhoDosArquivo", "tamanhoDosArQUervOs", "tamanhoDosArquIVo", "tamanhoDosArquIVos", "tamanhoDosArqIVlos", "tamanhoDosArquivalos", "tamanhoDosArQUervlos", "tamanhoDosArquervos", "tamanhoDosArquivOs", "tamanhoDosArquievlos", "tamanhoDosArquivallos", "tamanhoDosArquievos", "tamanhoDosArquIVlos", "tamanhoDosArqIVoes", "tamanhoDosArquivlos", "tamanhoDosArQUervos", "tamanhoDosArqIVo", "tamanhoDosArQUivos", "tamanhoDosArqivo", "tamanhoDosArquervoes", "tamanhoDosArQUivOs", "tamanhoDosArquivoes", "tamanhoDosArqivoes", "tamanhoDosArquervOs", "tamanhoDosArquivaloes", "tamanhoDosArqivlos", "tamanhoDosArquIVOs"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimante", "quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstimmante", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstipante", "quantidadeDeRegistrosEstivante", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstivado"], "registro": [" registulo", "regestro", " regestro", " regestros", "registulo", "regastro", "regastration", " registros", " registration", "registration", " regestulo", " regestration", "regestros", "regestration", "registros", "regustros", "regustration", "regastulo", "regestulo", "regustro", "regustulo", "regastros"], "campos": [" campas", "CampOS", "campOS", " casos", "campas", "Campos", " caso", " casOS", "Campo", " campo", "campo", " casas", "Campas", " campOS"]}}
{"id1": "21425787", "id2": "8330057", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public void getHttpURL() throws Exception {\n        boolean display = true;\n        boolean allHeaders = false;\n        String url = null;\n        url = \"http://localhost/cubigraf2\";\n        url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\";\n        url = \"http://www.uni.pt/img/home-direito.gif\";\n        url = \"http://www.google.com\";\n        URLConnection uc = new URL(url).openConnection();\n        println(\"HEADERS:\");\n        if (allHeaders) {\n            Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator();\n            while (itHeaders.hasNext()) {\n                Map.Entry<String, List<String>> e = itHeaders.next();\n                Iterator<?> itValues = e.getValue().iterator();\n                while (itValues.hasNext()) {\n                    println(e.getKey() + \": \" + itValues.next());\n                }\n            }\n        } else {\n            showObjectProperty(uc, \"getContentEncoding\");\n            showObjectProperty(uc, \"getContentLength\");\n            showObjectProperty(uc, \"getContentType\");\n            showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP);\n        }\n        ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString());\n        if (display) {\n            println(\"BODY:\");\n            ExtendedReader reader = new ExtendedReader(in);\n            for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                println(s);\n            }\n        } else {\n            println(\"(BODY saved to a file)\");\n            String contentType = uc.getContentType();\n            StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\");\n            filename.append(\".\");\n            filename.append(contentType.substring(contentType.indexOf(\"/\") + 1));\n            File file = new File(filename.toString());\n            ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.getAbsolutePath());\n            Streams.copy(in, out);\n            out.close();\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", "transferFile", "transferStream", "CopyFile", " copyStream", " copyfile", "Copyfile", "copyStream", "copyfile", "CopyStream", "copyFiles", "CopyFiles"], "in": ["ini", "image", "index", "base", "login", "inner", "inn", "input", "In", "at", "up", "bin", "b", "c", "IN", "again", "work", "source", "io", "min", "ins", "name", "a", "ac", "id", "file", "data", "ex", "reader", "i", "or", "connection", "m", "inc", "exec", "url"], "out": ["base", "o", "temp", "prefix", "point", "to", "w", "at", "target", "up", "cache", "output", "OUT", "writer", "conn", "b", "object", "c", "again", "outs", "p", "part", "io", "result", "v", "dest", "x", "Out", "client", "off", "name", "server", "data", "file", "user", "call", "ex", "n", "connection", "source", "exec", "inc"], "sourceChannel": ["SourceStream", "resourceChan", "resourceConnection", " sourceStream", "ourceSocket", "SourceChannel", "targetchannel", "Sourcechannel", " sourceConnection", "SourceChan", "sourcechannel", "targetStream", "srcChan", "srcSocket", " sourceSocket", "ourceChannel", " sourcechannel", "ourcechannel", "sourceSocket", "targetChan", "sourceChan", "resourceChannel", "ourceConnection", "resourcechannel", "sourceConnection", " sourceChan", "targetChannel", "srcChannel", "SourceConnection", "ourceChan", "srcConnection", "sourceStream"], "destinationChannel": ["destinatingChannel", "Destinationchannel", "destinationFile", "DestinationFile", "destinatorManager", "destinatedStream", "DestinatingStream", "destinatingStream", "destinationchannel", "DestinatorChannel", "DestinatorChan", "DestinatingChannel", "destinationConnection", "destinationChan", "DestinationConnection", "destationchannel", "DestinatingChan", "DestinationChannel", "destinatingChan", "destinatorConnection", "destinateChan", "destationConnection", "destructionChan", "destinatorStream", "destationChannel", "destinateChannel", "DestinatorFile", "destationFile", "Destinatorchannel", "destinatorchannel", "destructionChannel", "destinatedManager", "DestinationManager", "destinatorFile", "destinatorChan", "destinatedChan", "destinationStream", "destinatedChannel", "DestinationStream", "destinatedchannel", "destinationManager", "destinateConnection", "destinatorChannel", "destructionConnection", "DestinationChan", "DestinatingManager", "DestinatorConnection", "destinatedFile", "destinatedConnection", "destinatingManager"]}}
{"id1": "20028790", "id2": "22993368", "code1": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"setBundleInfoName": ["setBundleIdPart", "setBindingIdList", "setBundleIdList", "setBindingIdPart", "setBundleInfoDefault", "setBundleDirPart", "setBindingInfoName", "setBundleInfoPart", "setBundleInformationPart", "setBindingInfoPart", "setBindingIdName", "setBindingInfoList", "setBundleIdName", "setBundleInformationDefault", "setBundleInfoList", "setBindingInfoDefault", "setBundleDirList", "setBundleIdDefault", "setBundleInformationName", "setBundleDirDefault", "setBundleInformationList", "setBindingIdDefault", "setBundleDirName"], "location": ["link", "folder", "URL", "base", "resource", "localhost", "site", "point", "directory", "content", "message", "filename", "area", "href", "l", "remote", "string", "selection", "position", "path", "node", "type", "uri", "LOC", "region", "xml", "library", "loader", "language", "server", "data", "file", "layout", "Location", "description", "station", "database", "loc", "address"], "list": ["detail", "coll", "sequence", "LIST", "cl", "cli", "entry", "group", "load", "stack", "queue", "pair", "table", "l", "object", "later", "we", "string", "set", "array", "collection", "li", "listed", "lists", "part", "record", "result", "all", "see", "chain", "name", "tree", "keep", "the", "data", "range", "there", "i", "mentioned", "batch", "parent"], "url": ["err", "URL", "base", "resource", "fr", "lr", "service", "stream", "Url", "open", "http", "l", "b", "bb", "string", "r", "bel", "buffer", "source", "io", "org", "uri", "plug", "orb", "socket", "ssl", "loc", "server", "data", "file", "user", "jar", "browser", "sl", "reader", "connection", "f", "address"], "br": ["body", "err", "dr", "fr", "stream", "bl", "arr", "obj", "ler", "yr", "bridge", "b", "bb", "ch", "buf", "sp", "r", "ber", "gr", "tr", "bro", "er", "io", "result", "Br", "BR", "mr", "img", "handle", "hr", "bar", "sr", "data", "ob", "brush", "jar", "browser", "str", "reader", "rb", "i", "res", "bc", "bh", "ar", "cr"], "line": ["look", "link", "letter", "log", "lc", "rule", "lr", "section", "nl", "lf", "cl", "lines", "entry", "inline", "LINE", "license", "parse", "text", "zip", "up", "Line", "sync", "l", "b", "shell", "page", "style", "string", "status", "code", "pass", "strip", "split", "job", "part", "result", "row", "response", "le", "block", "character", "lin", "name", "word", "data", "file", "lo", "cell", "e", "band", "lock", "str", "error", "non", "connection", "phase", "source", "header"], "pos1": ["index1", "part1", "index0", "posN", "PosN", "POS3", "position2", " posOne", "part3", " pos3", "posOne", "pos3", "part2", "Pos0", "POS1", "PosOne", "Pos1", " posN", "indexOne", "Pos2", "index2", "pos2", "position1", "Pos3", "pos0", "position3", "POSOne", "position0", "POSN", " pos2", "positionOne"], "bundleSymbolicName": ["bundleSymbicallyWord", "bundleSymbolicname", "bundleSymbicallyName", "bundleSymbolicString", "bundleSymbriticalName", "bundleSyembolicKey", "bundleSymbicKey", "bundleSysembuousWord", "bundleSymbicalModule", "bundleSymbriticalUrl", "bundleSymbillyName", "bundleSymbularPath", "bundleSymbularString", "bundleSyMBolicPart", "bundleSymbolicInfo", "bundleSysembolicName", "bundleSyMBicalString", "bundleSyembolicInfo", "bundleSysembolicWord", "bundleSysembuousUrl", "bundleSyMBolicString", "bundleSymbicalKey", "bundleSymbuousWord", "bundleSysembuousname", "bundleSymbriticalWord", "bundleSymbolicUrl", "bundleSymbicName", "bundleSymbolicModule", "bundleSymbularPart", "bundleSymbicalInfo", "bundleSymbillyInfo", "bundleSymbularName", "bundleSysembolicname", "bundleSyMBicalName", "bundleSymbolicWord", "bundleSymbillyKey", "bundleSymbuousname", "bundleSymbigiousPath", "bundleSyembicInfo", "bundleSymbolicPart", "bundleSymbillyModule", "bundleSymbigiousPart", "bundleSymbicModule", "bundleSymbolicKey", "bundleSymbigiousName", "bundleSyMBicalPart", "bundleSyMBolicName", "bundleSyembolicName", "bundleSyembicName", "bundleSymbicalPath", "bundleSymbicallyUrl", "bundleSymbicalString", "bundleSymbriticalname", "bundleSyMBolicPath", "bundleSyembicModule", "bundleSymbolicPath", "bundleSymbicalPart", "bundleSyMBicalPath", "bundleSymbuousUrl", "bundleSymbicallyname", "bundleSysembolicUrl", "bundleSysembuousName", "bundleSymbicInfo", "bundleSymbicalName", "bundleSyembolicModule", "bundleSyembicKey", "bundleSymbigiousString", "bundleSymbuousName"], "bundleName": ["bblInfo", "rbpluginInfo", "babiInfo", "BundleID", "BendorInfo", "bpackageDesc", "bridgeDesc", "rbpluginname", "bridgeInfo", "babiName", "babiDesc", "BendorName", "Bendorname", "boodleID", "bendorName", "bendorInfo", "Bundlename", "rbpluginType", "bblname", "BpackageName", "rbundlename", "boodlename", "bpluginType", "bpackagename", "bundleDesc", "bendorname", "BpackageInfo", "baffleType", "bundleID", "bridgeName", "babiname", "rbpluginName", "bundleType", "bendorID", "rbundleType", "BundleDesc", "bpluginName", "BundleInfo", "boodleName", "bpackageInfo", "bblID", "bpluginname", "bendorType", "bblName", "bpackageName", "bridgename", "rbundleName", "BpackageDesc", "bundlename", "BendorID", "BundleName", "baffleInfo", "rbundleInfo", "Bpackagename", "bafflename", "bundleInfo", "bpluginInfo", "boodleInfo", "baffleName"], "info": ["link", "image", "fo", "index", "base", "child", "end", "of", "inf", "check", "alias", "py", "ignore", "entry", "available", "filter", "parse", "zip", "fw", "key", "b", "api", "object", "extra", "string", "def", "gi", "next", "li", "handler", "op", "type", "part", "result", "diff", "by", "bug", "start", "off", "name", "tf", "archive", "data", "file", "INFO", "id", "Info", "error", "comment", "i", "f", "obj"]}}
{"id1": "9096314", "id2": "15810440", "code1": "    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                log.warn(\"\\'\" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" ignored - table already  has an open record \");\n            } else {\n                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());\n                long outageID = -1;\n                ResultSet seqRS = getNextOutageIdStmt.executeQuery();\n                if (seqRS.next()) {\n                    outageID = seqRS.getLong(1);\n                }\n                seqRS.close();\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement newOutageWriter = null;\n                if (log.isDebugEnabled()) log.debug(\"handleNodeLostService: creating new outage entry...\");\n                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);\n                newOutageWriter.setLong(1, outageID);\n                newOutageWriter.setLong(2, eventID);\n                newOutageWriter.setLong(3, nodeID);\n                newOutageWriter.setString(4, ipAddr);\n                newOutageWriter.setLong(5, serviceID);\n                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));\n                newOutageWriter.executeUpdate();\n                newOutageWriter.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeLostService : \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" recorded in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            }\n        } catch (SQLException sqle) {\n            log.warn(\"SQL exception while handling \\'nodeLostService\\'\", sqle);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"handleNodeLostService": ["handleNodeUnknownService", "handleNodeUnknownServer", "handleNodeLostFunction", "handlenodelostService", "handleNodeErrorFunction", "handleNodeErrorService", "handlenodelostServer", "handlenodelostServices", "handlenodeLostServices", "handleNodelostService", "handlenodelostFunction", "handleNodeLostServices", "handleNodeErrorServer", "handlenodeLostFunction", "handleNodeUnknownServices", "handlenodeLostServer", "handleNodelostServices", "handleNodeUnknownFunction", "handlenodeLostService", "handleNodeErrorServices", "handleNodelostServer", "handleNodelostFunction", "handleNodeLostServer"], "eventID": ["eventid", "documentID", "nodeName", "EventName", "eventType", " eventId", " eventid", "sessionID", "documentId", " eventType", "nodeId", "resourceID", "sessionName", "EventID", "serviceId", "resourceid", "serviceName", "resourceName", " eventName", "eventId", "nodeType", "eventName", "EventId", "documentName", "resourceId", "sessionId", "nodeid", "EventType"], "nodeID": ["Nodeid", " nodeName", "eventid", "nodeName", "eventInfo", " nodeURL", " nodeInfo", " nodeId", "nodeURL", "objectName", "networkId", "nodeId", "resourceID", "networkID", "serviceId", "networkInfo", "serviceName", "resourceid", "resourceName", "objectid", "eventId", "NodeID", "objectId", " nodeid", "eventName", "NodeURL", "serviceid", "resourceId", "objectID", "eventURL", "nodeid", "nodeInfo", "NodeId"], "ipAddr": ["epaddr", "apiAddri", " ipAttrs", "apiAddrs", " ipAddri", "ipChl", "ipAddl", "apiAddr", "ipAddresso", "ipAtter", " ipChri", " ipAddrer", "epaddl", "apiAttr", "ipAttrs", "ipAttress", "ipAddrs", "apiAttrs", "ipAddressl", "ipAddresser", "ipAddp", "epAddl", " ipAddo", "ipAttrer", " ipAdder", "ipaddress", "ipChr", "ipaddri", "ipAttp", "ipAddressp", "ipAdder", "ipAtto", "ipAddressri", "ipChri", "apiAddp", "ipAttr", " ipAtter", "ipChrs", "ipaddl", "apiAttri", "epAddrs", "epAddrer", " ipAttr", "ipAddo", "ipaddr", " ipAtto", " ipAddrs", "ipAddressrs", "apiAttp", "ipAddrer", "epaddrer", "ipaddo", "ipAddress", "ipAddressr", " ipChrs", "ipAttri", "ipAddressrer", "epaddrs", "ipaddrer", "ipadder", " ipChrer", " ipChr", "ipChp", " ipAddress", "ipaddrs", "epAddr", "ipAddri", "ipChrer"], "serviceID": ["imageUID", "eventIDs", "ServiceId", "ServiceName", "networkid", "siteid", "roleIP", "eventid", "serviceIP", "featureID", "networkName", "roleId", "eventIP", "featureId", " serviceid", "eventType", "siteID", " serviceName", "ServiceType", "imageId", " serviceId", "siteIP", "networkId", "roleid", "serviceIDs", "roleID", "ServiceIDs", "networkID", "imageID", "ServiceIP", "featureUID", "serviceId", "serviceName", "ServiceID", "eventId", "serviceUID", " serviceIP", "eventName", "serviceType", " serviceType", "serviceid", "siteId", " serviceUID", " serviceIDs"], "eventTime": ["EventName", "serverName", " eventInfo", "EventInfo", "eventName", "EventTime", "serverInfo", "servertime", "serverTime", "eventtime", "Eventtime", " eventtime", " eventName", "eventInfo"], "log": ["model", "crit", "sec", "ger", "full", "class", "c", "job", "it", "Log", "ge", "call", "thread", "lex", "host", "f", "pool", "stop", "debug", "cl", "write", "cache", "output", "info", "cat", "contract", "where", "tool", "user", "lo", "error", "get", "reg", "pg", "base", "event", "entry", "exp", "use", "l", "LOG", "path", "type", "blog", "low", "gen", "level", "port", "lock", "put", "or", "tag", "guard", "db", "feed", "w", "net", "http", "key", "writer", "pe", "pl", "en", "stat", "plug", "sign", "loop", "bug", "proxy", "cell", "og", "config", "url"], "dbConn": [" dbSession", "DbDr", "databaseDr", "DBCs", "webCtrl", "sqlCo", "webNC", "Dbconn", "DBConn", "databaseConnection", "DBCt", " dbCt", "dbConnection", "dbColl", "dbCon", " dbConnection", "webCt", "logCtrl", " dbCo", "DbCt", "DbConn", "webConn", "DbCs", "DbSession", " dbconn", "dbconn", "databaseConn", "dbDr", "libconn", " dbCon", "libCon", "logColl", "DbCtrl", "dbSession", " dbDr", "DbConnection", " dbCs", "libConn", "DbConnect", "sqlConn", "DBConnect", "sqlSession", " dbNC", "DbCo", "dbCo", "sqlCtrl", "dbCtrl", "dbNC", " dbCtrl", "databaseconn", "libCt", "logConn", "DbColl", "sqlconn", " dbConnect", "sqlNC", "logConnect", "DbCon", "dbCt", "dbCs", " dbColl", "sqlCt", "dbConnect"], "getNextOutageIdStmt": ["getNextOutageIdCMT", "getNextOutageIdCnt", "getNextOutageIdSr", "getNextOutageIdRb", "getNextOutageIdstMT", "getNextOutageIdSnt", "getNextOutageIDStMT", "getNextOutageIdStr", "getNextOutageIdstr", "getNextOutageIdCmt", "getNextOutageIdstmt", "getNextOutageIdSMT", "getNextOutageIdstnt", "getNextOutageIdStnt", "getNextOutageIdSb", "getNextOutageIDSb", "getNextOutageIdRr", "getNextOutageIDStnt", "getNextOutageIDStb", "getNextOutageIdRmt", "getNextOutageIDSMT", "getNextOutageIdCr", "getNextOutageIDSnt", "getNextOutageIDStr", "getNextOutageIdRMT", "getNextOutageIDStmt", "getNextOutageIdCb", "getNextOutageIdStMT", "getNextOutageIdSmt", "getNextOutageIDSmt", "getNextOutageIDSr", "getNextOutageIdStb"], "outageID": ["outflowID", "inageId", "outagingName", "outrageID", "outrageHandle", "outagingId", "outagementName", "outAGEURL", "outAGEId", "outrageName", "outageId", "OutrageId", "inrageID", "outAGEName", "outageName", "inageURL", "OutageName", "outAGEID", "OutageId", "outAGESecret", "outrageId", "OutrageID", "outageHandle", "outageURL", "inrageURL", "outissueId", "inrageUID", "outageUID", "outagementId", "outagingSecret", "OutageHandle", "outrageSecret", "outagementHandle", "OutageSecret", "outissueURL", "outrageURL", "inrageId", "outissueUID", "outrageUID", "inageID", "inageUID", "OutrageName", "outflowId", "outagementID", "outagingID", "outflowName", "outflowHandle", "OutrageHandle", "OutrageSecret", "outageSecret", "outissueID", "OutageID", "outAGEUID"], "seqRS": ["structrs", "seqRC", "sqMR", "seqTS", "reqRL", "sequTS", "reqRR", " sequenceRS", "seqRT", " sequenceMR", " seqRT", "eqRR", "sequenceRS", "sequenceRs", "colRT", "seqMR", "colRR", "eqRs", "seqSR", "sequRL", "sqRC", "invRS", "sequRS", " sequenceRT", "invSR", "structRs", " seqMR", "reqTS", "reqRT", "seqRR", " seqTS", "seqrs", " sequenceRC", "reqRS", "seqRL", "sqRT", "structRS", "reqRs", "sequenceSR", " seqRL", "structSR", "eqRS", "invrs", "colRS", "sqRS", "invRs", "sequRC", "seqRs", "sequencers", "eqRT", "reqRC", " seqRC", "colRs"], "newOutageWriter": ["newOutpaceRW", "newOutagementWrit", "newOutpacewriter", "newExagewriter", "newoutageReader", "newOutflowWrit", "newOutlineReader", "newOutpointWrite", "newExlineReader", "newOutureInfo", "newOutageWrite", "newExageWrite", "newOutageWrit", "newOutrageRW", "newInageRW", "newOutageRW", "newOutissueWrite", "newExlineWriter", "newInflowWrite", "newoutureWriter", "newInageWriter", "newOutpaceWriter", "newOutlineWrite", "newInflowRW", "newoutageRW", "newOutrageWriter", "newoutageWriter", "newOutureWrite", "newOutagewriter", "newOutflowWriter", "newInageWrit", "newOutrageWrit", "newoutageInfo", "newOutagementRW", "newOutartWrite", "newoutageWrite", "newOutureReader", "newOutflowRW", "newOutartWriter", "newOutissueWriter", "newOutpointWriter", "newOutpointRW", "newOutflowInfo", "newOutageInfo", "newOutpaceReader", "newOutartInfo", "newExageReader", "newOutagementWrite", "newOutissuewriter", "newOutureRW", "newOutflowWrite", "newExageWriter", "newOutageReader", "newInageWrite", "newOutissueReader", "newOutartRW", "newoutureWrite", "newOuturewriter", "newOutflowReader", "newOutlineWriter", "newExlinewriter", "newOutrageWrite", "newouturewriter", "newExlineWrite", "newInflowWriter", "newOutagementWriter", "newOutflowwriter", "newoutureRW", "newoutureInfo", "newOutlinewriter", "newoutagewriter", "newOutureWriter", "newOutpointReader", "newoutureReader", "newInflowWrit"]}}
{"id1": "18891988", "id2": "3184073", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["getString", "loadString", "downloadString", "getFilename", "loadFilename", "GetFile", "loadfile", "getfile", "GetFilename", "downloadfile", "Getfile", "loadFile", "downloadFile", "downloadFilename", "GetString"], "serviceName": ["ServiceName", "ServicePath", "packagePath", "ServiceUrl", " serviceUrl", "packageUrl", "servicename", "serviceUrl", "projectPath", "ServiceType", " servicePath", " servicename", "servicePath", "projectName", "packagename", "serviceType", "packageName", " serviceType", "Servicename", "projectType", "projectUrl"], "wsdlLocation": ["wslDirectory", "awslLocation", "awsdlFile", "wsdlFolder", "wllFolder", "awslFile", "wdlAddress", "wsdlFile", "wsllUrl", "wdlDirectory", "awslDirectory", "wsllLocation", "wssdFolder", "wslUrl", "wslFile", "wdlFolder", "wsDLFile", "wslLocation", "wsdlUrl", "wsDLUrl", "wsllAddress", "wsDLDirectory", "awsdlLocation", "wddlFile", "wslFolder", "awsdlUrl", "wsslFolder", "wsslAddress", "wsllFolder", "wssdAddress", "wddlLocation", "awsdlDirectory", "wllLocation", "wdlFile", "wslpFolder", "wsdlDirectory", "wslpDirectory", "wllAddress", "wllFile", "wdlLocation", "wsllFile", "wsdlAddress", "wddlFolder", "wssdFile", "wsslFile", "wsDLLocation", "wsllDirectory", "wslpLocation", "wslpFile", "awslUrl", "wsslLocation", "wddlDirectory", "wssdLocation"], "endpoint": ["enpoint", "startpoint", " endocol", "endpointer", "ENDination", "Endination", "ENDpoint", "Endpoints", "Endpoint", "enPoint", "ENDpoints", " endword", "endspo", "endpoints", "startpointer", " endpo", "endaddress", "enination", "endocol", "Endpo", "startPoint", "endword", "Endocol", "endpo", "endPoint", " endpointer", "endination", "enaddress", "startaddress", "enpointer", "ENDPoint", "enpoints", "Endword", "EndPoint", " endPoint", "endsword", " endaddress", "endspoint", "endsocol"], "fileLocation": [" fileUrl", "FileURI", "FILELocation", " fileDirectory", "FileUrl", "FileLocation", "FileDirectory", " fileURI", "fileURI", "FILEDirectory", "fileDirectory", "fileUrl", "FILEUrl", "FILEURI"], "tempDir": ["tmpVer", "TempPath", "TempDir", " tempPath", "tmpDirectory", "TempDirectory", " temporaryVer", "tmpdir", " tempVer", "tmpDir", "tempdir", " tempDirectory", "tempVer", "Tempdir", "tempDirectory", "tempPath", "tmpPath", " temporaryDirectory", " tempdir", " temporaryDir", " temporaryPath"], "url": ["image", "log", "URL", "service", "base", "www", "stream", "coll", "ul", "download", "Url", "open", "ls", "channel", "http", "l", "conn", "string", "path", "fl", "source", "io", "uri", "pull", "client", "ur", "socket", "ssl", "server", "file", "ll", "el", "sl", "contact", "connection", "config", "host", "web", "f", "address"], "WSDLFile": ["WSDlfile", "WDDlSourceFile", "WSDELFile", "WSDDLSourceFile", "WSDELFiles", "WDDLPath", "WINDELFiles", "WSDLLBase", "WSDDLPath", "WSDlSourceFile", "WINDELFile", "WINDLFile", "WSDDLFiles", "WDDLFolder", "WSDlFolder", "WSDLBase", "WINDELPath", "WSDLFolder", "WSDlFile", "WSDDLFile", "WDDLFile", "WSDDLfile", "WSDLfile", "WSDELFolder", "WDDlPath", "WDDLSourceFile", "WDDLBase", "WSDLLFolder", "WINDLFiles", "WDDLfile", "WSDLFiles", "WSDELPath", "WDDlBase", "WSDDLBase", "WSDLLFiles", "WSDLLfile", "WSDLSourceFile", "WDDlfile", "WDDlFile", "WSDLLFile", "WSDLLPath", "WSDDLFolder", "WINDLFolder", "WDDlFolder", "WSDlBase", "WSDLPath", "WSDLLSourceFile", "WINDELFolder", "WSDlPath", "WINDLPath"], "tmpWSDLFile": ["tmpWSDLLUrl", "tmpWDDELFile", "tmpWSDlFile", "tmpWDDlUrl", "tmpWSDLFolder", "tmpWSDLLocation", "tmpWSDlFiles", "tmpWSDDLLocation", "tmpWSDLFiles", "tmpWSDLLFiles", "tmpWSDLLFolder", "tmpWDDLUrl", "tmpWDDlFiles", "tmpWSDlLocation", "tmpWSDDLUrl", "tmpWDDLFolder", "tmpWDDELLocation", "tmpWSDDLFile", "tmpWDDLLocation", "tmpWSDLLFile", "tmpWSDELLocation", "tmpWSDELFolder", "tmpWSDDLFiles", "tmpWDDELFiles", "tmpWDDlFolder", "tmpWSDELFile", "tmpWDDLFiles", "tmpWSDELFiles", "tmpWDDELUrl", "tmpWSDlFolder", "tmpWDDlFile", "tmpWSDLUrl", "tmpWSDELUrl", "tmpWSDlUrl", "tmpWDDLFile"], "inputFile": ["tempFile", " inputFiles", "tempPlace", "inputBuffer", "InputUrl", "tempfile", "InputPage", "inputBase", " inputUrl", "inputfile", "inputFactory", "requestfile", "requestFiles", "inFile", "InputFiles", "inputStream", "inputPlace", "InputFile", "outputDir", " inputStream", " inputDir", "inputDir", " inputPlace", "tempBuffer", "inPage", " inputfile", "inputFiles", " inputPage", "inputUrl", "tempPage", "inputPage", "InputBuffer", "InputDir", " inputFactory", "requestFile", "InputBase", " inputBase", "tempFactory", "tempBase", "outputFiles", "outputfile", "requestStream", "InputStream", "inDir", "InputFactory", "infile", "InputPlace", "tempUrl", " inputBuffer", "Inputfile", "outputFile"], "tmpFile": ["tempFile", "tmpFiles", "uploadDocument", "tempDocument", "TempPage", "tmpDirectory", "inputStream", "TempDirectory", " tmpPage", "inputDocument", " tmpFiles", "uploadStream", " tmpDirectory", "inputFiles", "uploadFiles", "tempFiles", "tempPage", "TempFile", "tempDirectory", "tempStream", "tmpStream", "uploadFile", "TempFiles", "tmpPage"], "in": ["image", "login", "impl", "inner", "inn", "gin", "input", "In", "up", "l", "bin", "conn", "c", "pin", "IN", "r", "again", "p", "source", "client", "ins", "is", "lin", "init", "ssl", "data", "file", "on", "id", "lock", "reader", "win", "connection", "m", "din", "f", "socket", "inc"], "out": ["image", "err", "log", "conv", "o", "outer", "can", "inner", "to", "input", "net", "In", "channel", "up", "group", "cache", "sync", "output", "OUT", "bin", "writer", "conn", "ch", "c", "IN", "again", "outs", "source", "line", "part", "io", "Out", "client", "name", "co", "server", "on", "file", "error", "timeout", "connection", "inc", "parent", "conf", "socket", "copy"], "con": ["kin", "com", "conv", "can", "inner", "gin", "plain", "nc", "open", "channel", "ctrl", "fc", "sync", "rec", "ch", "conn", "un", "CON", "ran", "c", "IN", "rc", "en", "client", "Con", "ins", "close", "cm", "ssl", "co", "thin", "cn", "connect", "Conn", "win", "bc", "uc", "connection", "inc", "conf", "socket"], "fileLength": ["Filelength", "FileWidth", "fileSize", "channelLength", "filelength", "channelWidth", "contentlength", " fileWidth", " fileSize", "contentLength", "channelLen", "contentSize", " filelength", " fileLen", "fileLen", "channelSize", "FileSize", "contentLen", "FileLen", "FileLength", "fileWidth"], "channelIn": ["connectionConn", "channelIN", " channelIN", "ChannelIN", "resourcein", "channelin", "resourceIn", "characterOut", "ChannelConn", "ChannelIn", " channelin", "connectionOut", "characterIN", "ChannelOut", "Channelin", " channelConn", "resourceIN", "characterIn", "resourceOut", "channelConn", "connectionIn", "characterin", "connectionin"], "channelOut": [" channelOutput", "chanIn", "ChannelOutside", "canOut", "connectionOutput", "connectionOutside", "ChannelIn", "connectionOut", "channelout", "Channelout", "canIn", "ChannelOut", "chanout", " channelout", "channelOutside", "channelOUT", "connectionout", "ChannelOUT", "canOUT", "connectionIn", "canOutside", "chanOUT", "channelOutput", "ChannelOutput", "chanOut", "chanOutside"], "tmpDocument": ["newDocument", "tmpdocument", "tempFile", "mpFile", "tempDocument", "tmpNode", "mpDoc", "tmDocument", "mpNode", "tempContent", " tmpContent", "tmFile", "tmpContent", "tempDoc", " tmpdocument", "newContent", " tmpDoc", " tmpNode", "newdocument", "newFile", "tmpDoc", "tmNode", "tempNode", "tempdocument", "tmdocument", "mpDocument"], "nl1": ["klFirst", "jlone", "klone", "nlone", "ln1", "NL0", "nn11", "nn0", "kl5", "jlFirst", "ln11", "jl1", "arl5", "nl0", "nn2", "nn1", "nl2", "arl1", "nl6", "nl5", "arlone", "NL2", "dl0", "nlFirst", "NL1", "dl1", "nn6", "kl1", "NL11", "ln2", "ln6", "arlFirst", "nl11", "NL6", "jl5", "dl2"], "i": ["ini", "z", "mi", "index", "j", "o", "oi", "chi", "yi", "uli", "hi", "phi", "ii", "ix", "fi", "slice", "mu", "l", "b", "info", "ui", "ri", "pi", "gi", "abi", "d", "li", "ci", "p", "ie", "part", "multi", "si", "ni", "xi", "uri", "bi", "v", "io", "ai", "ji", "eni", "y", "it", "ip", "qi", "ti", "id", "e", "iu", "f", "u", "n", "di", "m", "I"], "node1": ["n1", " node2", "nodeOne", "package1", "packageone", "Node0", "n0", "nodeone", "NodeOne", "shape1", " nodeOne", "Node2", "package91", "shape91", "node91", "node2", " nodeone", "n2", "layerOne", " node91", "Node91", "layer91", "node0", "layer1", "nOne", "layer2", " node0", "shapeone", "packageOne", "shapeOne", "Node1"], "tmpOut": ["tempWriter", "tempFile", " tmpOUT", "vmOUT", "tmpout", "cacheIn", "ptyIn", "tmpOutput", "ptyOutput", "txtOut", " tmpout", "tempOutput", "vmIn", "vmOut", "ptyout", "tempOUT", " tmpWriter", "txtWriter", "ptyOut", "tmpIn", " tmpIn", "cacheFile", "tempout", "txtout", "tempIn", " tmpOutput", "cacheOut", "tmpOUT", "tempOut", "tmpWriter", "vmout", "txtOutput", "cacheOUT"], "retVal": ["valRet", "retObj", "valObj", "RETval", "retRet", "retval", " retRet", "valVal", "RETRet", " retObj", " retval", "RETVal", "RETObj", "valval"]}}
{"id1": "1954410", "id2": "6840241", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 1, "substitutes": {"doExecute": ["submitexecuteRun", "doExecRun", "submitexecuteute", "doSendApply", "submitexecuteutes", "doSendute", "doExecutes", "submitExecute", "doexecuteRun", "submitExecRun", "doexecuteutes", "doexecuteApply", "doExecApply", "submitexecuteApply", "doSendutes", "doexecuteute", "doSendRun", "submitExecApply", "submitExecutes"], "mapping": ["finding", "minding", "amapping", "fapper", "mapper", " mapper", "amatching", "fapping", "matching", "amapper", "aminding", " matching", " minding", "fatching"], "form": ["flow", "method", "field", "Form", "formation", "feed", "submit", "config", "forms", "format", "transform", "pattern", "post", "object", "page", "builder", "definition", "dom", "control", "command", "xml", "app", "component", "FORM", " forms", "template", "url", "owner"], "request": ["re", "_", "method", "model", "resource", "q", "create", "ware", "submit", "this", "view", "self", "current", "format", "Response", "input", "json", "worker", "req", "message", "add", "queue", "use", "Reply", "object", "QUEST", "Bytes", "application", "Accept", "session", "route", "path", "query", "Request", "hello", "type", "result", "uri", "frame", "pull", "client", "context", "xml", "Upload", "report", "name", "server", "user", "data", "HTTP", "parent", "call", "instance", "s", "reader", "complete", "requ", "url", "address"], "response": ["model", "resource", "view", "Response", "json", "req", "message", "output", "object", "page", "application", "status", "resp", "handler", " responses", "result", "v", "client", "Resp", "xml", "report", "server", "data", " Response", "res", "reply"], "errors": [" calls", " logger", " management", " managers", " changes", " events", " replies", " Messages", " logs", " mess", " streams", " commands", " session", " this", " messaging", "mess", " responses", " payload", " failures", " messenger", " messages", " error", " translations", " status", " flashes", " problems", " updates", " acc", " warnings"], "isMultipart": ["isMultipost", "isMultippart", "isMultiipPart", "isMultippedart", "isMultIPound", "isMultitart", "isMultipated", "isMultitarts", "isMultiarts", "isMultitated", "isMultiIPound", "isMultiIPart", "isMultipound", "isMultiated", "isMultiipart", "isMultipage", "isMultIPart", "isMultiage", "isMultIPost", "isMultompPart", "isMultippedPart", "isMultippedost", "isMultippedound", "isMultIPPart", "isMultiparts", "isMultompound", "isMultitage", "isMultiipound", "isMultippage", "isMultompost", "isMultompart", "isMultipparts", "isMultiIPost", "isMultipPart", "isMultiipost", "isMultiIPPart", "isMultiart", "isMultippated"], "mailInstance": [" emailinstance", "mailManager", "fileManager", " emailInst", " emailInstance", "fileUsage", "mailUsage", "emailInst", " mailManager", "mailinstance", "emailinstance", " mailUsage", " mailinstance", "fileInstance", "fileInst", "emailManager", " mailInst", "mailInst", "emailInstance", " emailUsage", "fileinstance"], "fields": ["archives", "gets", "boxes", "field", "comments", "objects", "posts", "keys", "forms", "types", "locks", "changes", "utils", "input", "flows", "lines", "plugins", "links", "services", "maps", "details", "ments", "packs", "rules", "ids", "properties", "events", "views", "facts", "files", "uploads", "params", "groups", "headers", "rows", "atts", "lists", "cells", "acks", "holders", "checks", "tags", "states", "qs", "users", "members", "models", "features", "pages", "data", "forces", "classes", "loads", "words", "strings", "dates", "parts", "s"], "attachments": ["attachions", "attlements", " attachparts", "suppment", "extions", "exters", "supplements", "achresses", "attment", "attachers", "payresses", "Attachments", "attachps", "payment", " attachment", "attachparts", "payments", "achments", "suppments", "Attachlements", "attachlements", "payparts", "achparts", "attees", "suppees", "Attachps", "attions", "attachment", "extps", "attachresses", "attments", "atters", "achment", "Attachers", "attps", "Attachment", " attachresses", "attachees", "Attachions", "Attachees", "extments"], "items": ["its", "objects", "keys", "types", "locks", "phones", "ops", "children", "lines", "plugins", "links", "orders", "ids", "list", "events", "files", "apps", "groups", "rows", "Items", "lists", "apters", "qs", "ins", "reports", "models", "es", "alls", "ips", "pages", "data", "names", "results", "parts", "ers"], "iter": ["err", "ver", "outer", "end", "walker", "inner", "event", "coll", "ul", "order", "skip", "inter", "edit", "gener", "exp", "zip", "master", "ir", "http", "slice", "list", "finder", "page", "Iter", "li", "er", "itter", "izer", "it", "oper", "loop", "altern", "ip", "ner", "ite", "chain", "cher", "keep", "ter", "former", "file", "ser", "iterator", "el", "Iterator", "ator", "reader", "enter", "i", "loc", "inc", "upper"], "item": ["resource", "temp", "storage", "current", "full", "page", "hop", "element", "next", "result", "it", "layer", "name", "volume", "file", "source", "folder", "service", "slice", "api", "info", "example", "album", "token", "handler", "original", "Item", "issue", "all", "ip", "app", "server", "user", "instance", "reader", "get", "plugin", "base", "other", "inner", "event", "entry", "post", "object", "extra", "update", "atom", "custom", "er", "type", "attribute", "container", "entity", "data", "or", "anything", "obj", "image", "index", "section", "site", "coll", "val", "art", "order", "up", "load", "widget", "area", "more", "li", "missing", "i", "complete", "url"], "aux": ["aw", "lc", "ou", "des", "sub", "packages", "prefix", "aus", "ants", "offs", "abs", "alias", "except", " Aux", "anc", "aff", "ox", "axe", "uf", "extra", "sup", "array", "buf", "amp", "au", " auxiliary", "lang", "cmp", "ras", "etc", "cas", "off", "ups", "ext", "auc", "asc", "union", "data", "ux", "af", "abc", "pkg", "strings", "fax", "uc", "frac", "ru", "aos", "imp"], "part": ["action", "html", "field", "base", "plugin", "section", "change", "point", "step", "val", "po", "format", "pre", "art", "patch", "player", "obj", "group", "ref", "add", "back", "pair", "key", "area", "l", "ch", "b", "full", "object", "list", "info", "fact", "class", "pos", "act", "element", "pi", "join", "p", "type", "and", "diff", "comp", "layer", "block", "start", "but", "name", "joined", "partial", "co", "PART", "word", "component", "data", "user", "file", "on", "id", "instance", "Part", "f", "error", "per", "one", "no", "connection", "parent", " Part", "parts"], "baos": ["abaOs", "baOS", "baoss", " baOS", "BAoss", "bois", "bao", "bais", "boosh", "Bao", "BAos", "BAis", " baoS", "pao", "BAosh", "baot", "boOS", "hao", "BaOs", "Baos", "baosh", " baot", "haos", " bao", "abais", "Bais", "abaosi", "boot", "paos", "paosh", "BAoS", "BAOs", "boos", " bais", "baoS", "BAo", "BaoS", "baOs", "boo", "Baosi", "BAosi", "pais", "paot", "hais", "abaos", " baoss", "haoss", "paOS", "baosi"], "body": ["fee", "html", "resource", "options", "end", "Body", "content", "common", "json", "text", "message", "zip", "output", "shell", "b", "media", "full", "object", "string", "null", "summary", "flash", "params", "headers", "state", "pass", "query", "translation", "type", "parts", "length", "size", "name", "tree", "data", "document", "binary", "port", "description", "comment", "value", "connection", "template", "source", "reply", "url", "header"], "preferencesInstance": ["prefirmsClient", "prefiesInstance", "preffeesinstance", "prefferencesinstance", "prefirmsinstance", "preffeesClient", "prefferencesInstance", "prefiesinstance", "prefiesClient", "prefeesClient", "preffeesInstance", "preferencesinstance", "prefeesInstance", "preferencesClient", "prefirmsInstance", "prefferencesClient", "prefeesinstance"]}}
{"id1": "17999474", "id2": "18433984", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipAtFile", "getZipAtfile", "getZipAsDir", "getZipasFile", "getTempAsDir", "getZipasPlace", "getTempAsfile", "getTempAsFile", "getZipAtDir", "getZipasDir", "getZipAsPlace", "getZipAtPlace", "getZipasfile", "getZipAsfile", "getTempAsPlace"], "digOb": ["signObject", "DigObject", "signob", " digObject", "digob", "dimObj", "DigOb", " digOl", "signOB", "dimObject", "digObject", " digob", "digObj", "DigOl", "digOB", " digObj", "signObj", "ditOb", "signOb", "ditOB", " digOB", "ditob", "ditObject", "dimOb", "digOl", "dimOl", "DigObj", "Digob"], "folderName": ["folderPath", "FolderPath", "packagePath", "fileName", " folderDir", "filePath", "FolderInfo", "foldername", "filename", "foldInfo", "folderDir", "packageDir", " folderPath", "foldname", "foldPath", "foldName", "packagename", "fileInfo", "Foldername", "packageName", "folderInfo", "FolderName", "FolderDir", " foldername"], "tmpFolder": [" tmpManager", "tempFolder", "mpDirectory", " temporaryManager", "tempManager", " tmpDir", "tmpManager", "tmpDirectory", "mpfolder", "mpFolder", "tempDir", " tmpDirectory", "tmpDir", " tmpfolder", "mpDir", "tmpfolder", " temporaryFolder", "tempDirectory", "tempfolder", " temporaryDirectory", " temporaryfolder"], "zip": ["z", "flow", "folder", "ulp", " ZIP", "temp", "feed", "gz", "download", "install", "py", "json", "ignore", "cop", "slice", "bag", "cf", "ze", "clip", "job", "ie", "p", "wrap", "upload", "io", "flat", "ce", "fp", "ip", "lex", "xml", "tmp", "zone", "pack", "proxy", "archive", "Zip", " zipper", "file", "seed", "lock", "sl", "ipped", "pkg", "pipe", "ress", "lib", "jar", "source", "f", "url", "copy"], "out": ["z", "flow", "err", "log", "base", "in", "o", "temp", "child", "box", "this", "gz", "flush", "write", "cli", "download", "plain", "cache", "sync", "output", "OUT", "writer", "info", "conn", "object", "page", "url", "null", "again", "outs", "path", "line", "upload", "io", "result", "os", "Out", "client", "is", "loader", "socket", "a", "user", "file", "gen", "ex", "connection", "source", "parent", "f", "obj", "copy"]}}
{"id1": "5998352", "id2": "530882", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"testStandardTee": ["testStandardBae", "testStandardFae", "teststandardTae", "teststandardTeed", "testStandardFees", "testStandardMeed", "teststandardMeed", "testStandardMae", "teststandardTees", "testStandardMee", "testStandardBeed", "testStandardTae", "testStandardTees", "teststandardMee", "teststandardMae", "testStandardMees", "testStandardTeed", "testStandardFee", "teststandardMees", "testStandardBees", "testStandardFeed", "teststandardTee", "testStandardBee"], "reference": ["re", "index", "resource", "rice", "ference", "prefix", "directory", "sequence", "format", "forward", "order", "relative", "target", "version", "ref", "message", "pair", "filename", "output", "remote", "string", "code", "c", "collection", "external", "buffer", "relation", "path", "single", "hello", "type", "attribute", "pointer", "uri", " Reference", "number", "specified", "see", "length", "name", "location", "test", "Reference", "request", "primary", "report", "archive", "proxy", "server", "distance", "References", "REF", "variable", "binary", "compatible", "document", "description", "database", "connection", "memory", "url", "copy", "address"], "source": ["service", "resource", "SOURCE", "temp", "view", "Source", "input", "target", "fe", "ref", "src", "text", "slice", "output", "table", "writer", "object", "string", "driver", "code", "r", "g", "buffer", "ie", "ource", "io", "result", "se", "ce", "context", "proxy", "server", "e", "reader", "i", "iter", "connection", "config", "parent", "url", "copy"], "destination1": ["destensionOne", "Destination0", "Destension1", "destinationOnce", "destinations2", "destension0", "constinator01", "DestensionOne", "DestinateOnce", "destarationOne", "constination2", "destinator1", "destinator01", "destination01", "destination0", "destinateOne", "Destinate1", "destinations01", "destension1", "destaration0", "constinator1", "destinatorOne", "destinateOnce", "destributionOne", "destinate01", "destribution0", "constinatorOne", "destribution1", "destaration1", "destentionOnce", "destinations1", "DestinationOnce", "Destination1", "constination01", "constinationOne", "destinator2", "destinationsOne", "destinate2", "Destension0", "destention1", "constination1", "destinatorOnce", "destentionOne", "destinate1", "DestinationOne", "constinator2", "destinationOne", "DestinateOne"], "destination2": ["destination8", "Destinationtwo", "destinations2", "Destinate2", "destignment02", "coordinate2", "coordination2", "destignment1", "desticationSecond", "destinationSecond", "destribution8", "destation2", "destinate8", "destribution22", "destinate4", "descinationsSecond", "Destinatetwo", "destinating2", "descinations02", "coordination22", "Destinate1", "descination1", "destication2", "descinations2", "destignment2", "destributionSecond", "descinations1", "destinating1", "destinatetwo", "destication8", "coordinate22", "destation1", "destinateSecond", "destinations1", "destination22", "Destination1", "destinationsSecond", "destinate22", "destationtwo", "destignmentSecond", "destinate02", "destribution2", "Destination4", "destinations02", "destinate2", "destinating4", "descinationSecond", "descination02", "destinationtwo", "descination2", "coordinationSecond", "destination02", "destinate1", "destination4", "coordination8", "destation4", "coordinateSecond", "Destinate4", "destinatingtwo", "Destination2", "destication22", "coordinate8"], "tee": ["chee", "ceea", " teee", "TEea", " tei", "eeee", " tepe", " tef", "eeec", "tei", "tec", "chepe", " teec", "eeffe", " teea", "teffe", "leffe", "chef", "seae", "cee", "ettee", "teec", "lei", "sef", "lef", "teea", "teee", "eee", "TEe", "see", "lepe", "TEc", "teae", "chei", "TEee", " teae", " tec", "tepe", "etteee", "leec", "seee", " teffe", "etteae", "ceee", "leee", "ettef", "tef", "lee", "cec"]}}
{"id1": "7948308", "id2": "21489105", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "code2": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"getRandomGUID": ["getRandomCuid", "getRandGID", "getRandomMID", "getRandomMUID", "getRandGUD", "getRandomUUD", "getRandGUID", "getRandomCUID", "getRandomMuid", "getRandUuid", "getRandomMUD", "getRandUUD", "getRandomGID", "getRandGuid", "getRandUID", "getRandomUUID", "getRandomCUD", "getRandomGUD", "getRandomCID", "getRandomUID", "getRandUUID", "getRandomUuid", "getRandomGuid"], "secure": ["force", "service", "script", "stable", "depth", "sensitive", "debug", "deep", "Secure", "active", " insecure", "zip", "sec", "random", "use", "remote", "accessible", "safe", "session", "rc", "external", "weak", "require", "https", "allow", "ce", "secret", "client", "ssl", "unsigned", "smart", "proxy", "secondary", "sys", "server", "seed", "exclusive", "security", "forced", "timeout", "config", "host"], "md5": ["mand5", "MD4", "mp5", " mdql", "mandss", "MD5", "mand4", " MD2", "md512", "MDle", "cmd5", " md512", "md2", "MDss", "md4", "mp512", " md2", " md64", "mp64", "mdql", " MD5", "mdss", "MDql", "mdle", "md11", " md3", " MDql", " md4", "MD2", "MD3", "mp4", "mand2", " mdle", " mdss", "MD11", "mandle", " MD11", "md64", "mand3", "cmd512", "cmd64", " md11", "md3", "cmd4"], "sbValueBeforeMD5": ["sbValueBesidesSD20", "sbValueBeforeMC1", "sbValueFirstMD5", "sbValueBeforeMS05", "sbValueBeforeMD05", "sbValueBeforeMSFive", "sbValueBeforeMD8", "sbValueBeforeMS3", "sbValueBeforeMI5", "sbValueBeforeMD3", "sbValueBeforeMD20", "sbValueAfterAMD8", "sbValueBeforeM5", "sbValueBeforeSD20", "sbValueBeforeMD7", "sbValueBeforeMC5", "sbValueBesidesMD20", "sbValueBeforeM3", "sbValueAfterAMD3", "sbValueAfterMD20", "sbValueBeforeMI3", "sbValueBeforeMOD5", "sbValueAfterMD25", "sbValueFirstMT05", "sbValueBesidesMD5", "sbValueBeforeMAC20", "sbValueBeforeMD512", "sbValueBeforeAMD3", "sbValueBeforeMC7", "sbValueWithoutMC3", "sbValueBeforeMAC512", "sbValueAfterMD65", "sbValueAfterMC3", "sbValueBesidesMD3", "sbValueBeforeAMD5", "sbValueBeforeMP5", "sbValueBeforeMT05", "sbValueAfterMS65", "sbValueAfterMDFive", "sbValueAfterMS20", "sbValueBeforeMI65", "sbValueBeforeMD50", "sbValueBesidesSD65", "sbValueAfterMS5", "sbValueBeforeMI7", "sbValueAfterMC7", "sbValueWithoutMD1", "sbValueAfterMD3", "sbValueBesidesSD3", "sbValueWithoutMD512", "sbValueBeforeMOD3", "sbValueBeforeMP3", "sbValueBeforeMT8", "sbValueAfterMD512", "sbValueAfterAMD25", "sbValueFirstMT50", "sbValueFirstMD05", "sbValueBeforeMOD50", "sbValueBeforeMD25", "sbValueAfterMS1", "sbValueWithoutMC5", "sbValueBeforeMR8", "sbValueBeforeMT25", "sbValueAfterMC5", "sbValueBeforeMR3", "sbValueAfterMD1", "sbValueBeforeMPFive", "sbValueBeforeMT50", "sbValueBeforeMS50", "sbValueBeforeMD65", "sbValueWithoutMD5", "sbValueBeforeAST5", "sbValueAfterMSFive", "sbValueBeforeMT3", "sbValueFirstMD50", "sbValueBeforeMOD05", "sbValueBeforeAST65", "sbValueWithoutMC1", "sbValueBeforeSD3", "sbValueBeforeSD65", "sbValueBeforeAST20", "sbValueBeforeMAC1", "sbValueAfterMC512", "sbValueBeforeSD5", "sbValueBeforeMT5", "sbValueBeforeMI512", "sbValueBeforeMS5", "sbValueWithoutMC512", "sbValueAfterMD8", "sbValueBeforeMI20", "sbValueAfterAMD5", "sbValueBeforeSHA5", "sbValueFirstMD3", "sbValueBeforeMDFive", "sbValueBeforeSHAFive", "sbValueBesidesMD65", "sbValueBeforeAMD8", "sbValueBeforeMS20", "sbValueBeforeMR25", "sbValueBeforeMR5", "sbValueBeforeMP1", "sbValueBeforeMD1", "sbValueBeforeM1", "sbValueFirstMT3", "sbValueBeforeMAC5", "sbValueBeforeAST3", "sbValueBeforeSHA1", "sbValueBeforeMC512", "sbValueBeforeM512", "sbValueFirstMT5", "sbValueBeforeAMD25", "sbValueBeforeMAC65", "sbValueBesidesSD5", "sbValueAfterMS3", "sbValueWithoutMD3", "sbValueBeforeMS65", "sbValueAfterMD7", "sbValueAfterMD5", "sbValueBeforeMAC3", "sbValueBeforeMS1", "sbValueBeforeMC3", "sbValueBeforeSHA3"], "time": ["Time", "est", "event", "cost", "duration", "version", "mode", "count", "times", "random", "rate", "speed", "race", "tz", "clock", "TIME", "work", "type", "year", "counter", "sleep", "length", "size", "start", "name", "ime", "tim", "id", "seed", "money", "value", "etime", "date", "timeout", "timer", "delay", "hour", "host"], "rand": ["rule", "index", "right", "q", "depth", "root", "order", "pick", "pattern", "serial", "version", "alpha", "count", "round", "bit", "random", "rate", "chance", "r", "rage", "ro", "rc", "winner", "year", "Rand", "rr", "rh", "min", "raid", "row", "chain", "mid", "clean", "live", "loc", "range", "id", "seed", "gen", "win", "ng", "rank", "delay", "reg", "res", "rol", "cr", "max"], "valueBeforeMD5": ["valueBeforeAMD5", "valueAfterMC1", "valueBeforeMC5", "valueAfterMD2", "valueBeforeMD2", "valueAfterMP2", "valueBeforemd5", "valueBeforeDER2", "valueBeforeMC1", "valueBeforeAMD3", "valueBeforeDER0", "valueAfterMC5", "valueBeforeDER3", "valueAfterMD73", "valueBeforemd3", "valueBeforeMP3", "valueBeforemd73", "valueBeforeMD73", "valueBeforemd1", "valueBeforeMD1", "valueBeforeDER5", "valueAfterMD1", "valueBeforeMD3", "valueAfterMD3", "valueBeforeMP5", "valueBeforeMC3", "valueBeforeMD0", "valueAfterMC73", "valueBeforeAMD2", "valueBeforeMP0", "valueBeforeAMD0", "valueAfterMP5", "valueAfterMC3", "valueAfterMP0", "valueAfterMD0", "valueAfterMP3", "valueBeforeMC73", "valueBeforeMP2"], "array": ["image", "index", "shape", "section", "integer", "view", "sample", "audio", "arr", "function", "our", "message", "pair", "area", "list", "api", "object", "string", "element", "r", "collection", "vector", "Array", "record", "result", "allow", "v", "number", "row", "bug", "any", "expression", "app", "arrow", "a", "ray", "archive", "range", "data", "binary", "instance", "value", "error", "angle", "database", "feature", "batch", "address"], "sb": ["ib", "wb", "nb", "bsp", "kb", "bm", "lr", "eb", "zb", "bl", "SB", "sa", "xb", "src", "bb", "cb", "ruby", "usb", "bp", "lp", "buf", "gb", "abb", "buffer", "fb", "lb", " SB", "bf", "bj", "rob", "obb", "sg", "erb", "sq", "orb", "pb", "tmp", "bt", "lab", "bs", "ob", "binary", "sf", "sth", "sl", "rb", "mb", "bc", "bh", "bg", "BB", "db", "ab", "s"], "j": ["z", "aj", "num", "index", "o", "q", "section", "jl", "ii", "dy", "key", "l", "ch", "jp", "js", "pr", "c", "uj", "g", "k", "d", "li", "p", "part", "bi", "ja", "v", "x", "ji", "y", "dj", "block", "length", "jj", "oj", "jo", "J", "e", "adj", "i", "im", "ij", "n", "bj", "br", "f", "obj"], "b": ["ib", "nb", "base", "wb", "br", "eb", "beta", "bit", "l", "bb", "bin", "cb", "c", "d", "fb", "be", "lb", "job", "p", "k", "bi", "x", "y", "B", "bug", "length", "orb", "pb", "bar", "a", "bs", "ob", "e", "i", "rb", "mb", "n", "bf", "BB", "db", "f", "ab"], "valueAfterMD5": ["valueBeforeMD25", "valueAfterMP25", "valueAfterMC5", "valueBeforeMP3", "valueAfterMCql", "valueAfterMPql", "valueBeforeMPql", "valueBeforeMD3", "valueAfterMDql", "valueAfterMD25", "valueAfterMD3", "valueBeforeMP5", "valueAfterMC25", "valueBeforeMDql", "valueBeforeMP25", "valueAfterMP5", "valueAfterMC3", "valueAfterMP3"]}}
{"id1": "189963", "id2": "13783549", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndrewrites", "readAndRebwrite", "readandrewrite", "readAndSwwrite", "readAndRewwrite", "readAndSwrap", "readAndSwrite", "readandRewrite", "readAndrewrap", "readAndRewrap", "readAndRebrites", "readandrewwrite", "readAndRebrap", "readandRewrap", "readandRewrites", "readAndSwrites", "readandrewrites", "readAndrewrite", "readAndrewwrite", "readAndRebrite", "readandRewwrite", "readAndRewrites", "readandrewrap"], "inFile": ["inFilename", "loginFile", "outFilename", "inputfile", "InFiles", "InFile", " inFiles", "oldFile", "loginFilename", " inSourceFile", "outSourceFile", "InSourceFile", "inputFiles", "outFiles", "oldFiles", " inFilename", "loginFiles", "inputFile", "inSourceFile", "loginfile", "outfile", " infile", "inputFilename", "inFiles", "oldfile", "infile", "oldFilename", "Infile"], "outFile": [" outStream", "offPlace", "outFilename", " outDir", "outputPlace", "outFILE", "OutStream", "outputFilename", "newDir", " outfile", "thisFILE", "outputFile", "offFile", "outDir", "processFilename", "exfile", "exFILE", "newfile", "processPlace", "thisFile", "processFILE", "thisfile", "offFilename", "thisFilename", "outStream", "outPlace", "newFile", "exFile", "exFilename", "outfile", "outputfile", "OutFile", "outputFILE", "OutDir", "offFILE", "processFile", "newStream", "Outfile"], "iis": ["iniis", "Iiss", "iiIs", "iiIS", " iIS", " iIs", "iIs", "iniiss", "ciiss", "ciis", "Iis", "Iais", " iris", "IIS", "ciais", "ciIs", "iiss", "ciris", "iniIS", "iniIs", "iiris", "iiis", "iiiss", "ciIS", "iniris", "iais", " iiss", "iris", "iIS", " iais"], "dcmParser": ["dcmHelper", "dpmarser", "dmcPar", "dmoduleJar", "dmcJar", "dcmPar", "dbmPolicy", "dCMPlugin", "dmoduleParser", "dcmJar", "fcmHandler", "dcrPar", "fpmParser", "dmcarser", "dpmparser", "dbmHelper", "dmissionReader", "dpmLoader", " dpmLoader", "dcrReader", "dbmPlugin", "dCMParser", "dmoduleparser", "dpmPolicy", " dcrParser", "dmPlugin", "dkmHelper", "DcmInstallation", "dmmParser", "dcmparser", " dpmPolicy", " dcmPlugin", "dcmLoader", " dpmHelper", "dmLoader", "dhemReader", "dcmarser", "dpmHelper", "dbmParser", "fpmHandler", "dpmHandler", "dhemParser", "dcrJar", "dpmJar", " dcmLanguage", "fcmParser", "dcrarser", "dcmPolicy", "dkmParser", "dpmInstallation", " dpmJar", "dmodulePlugin", "dmmparser", "dcmLanguage", "dhemInstallation", "dcmInstallation", "fpmparser", "dpmParser", " dpmparser", " dcmPar", "dcmHandler", "dcrPlugin", "dmcParser", " dcmparser", "dcmReader", " dcrReader", "fcmReader", "DcmReader", " dpmPlugin", "dCMparser", "dpmLanguage", " dpmReader", "dmParser", "dmoduleReader", "dmissionPlugin", "dhemJar", " dpmPar", " dcrLoader", "dpmPar", "fpmReader", "dcrParser", "DcmJar", "dmissionParser", " dcmReader", "dCMHandler", "dpmPlugin", " dpmarser", " dpmLanguage", "dmmPlugin", " dcmarser", "dkmPolicy", " dcmHelper", " dcmLoader", "fcmparser", "dpmReader", " dpmParser", "dmReader", " dcmJar", " dcrPlugin", "dCMReader", "dmmLoader", "DcmParser", " dcmPolicy", "dkmPlugin", "dcmPlugin", "dCMLoader", "dcrLoader", "dmissionLanguage"], "ds": ["dd", "dr", "vals", "des", "ants", "os", "vs", "dc", "amps", "dat", "utils", "DS", "ls", "services", "details", "Ds", "ads", "src", "ns", "points", "sync", "ld", "conn", "js", "ws", "da", "ts", "ays", "cdn", "xs", "ps", "session", "d", "ils", "Db", "dt", "ros", "Os", "tes", "cs", "df", "uds", "dds", "ras", "eps", "gd", "ins", "iss", "qs", "is", "rs", "ys", "gs", "icks", "nas", "bs", "data", "sys", "pd", "ss", "tx", "ks", "di", "asi", "db", "parts", "drivers", "s"], "pdReader": ["ddRunner", "hdWriter", "hdLoader", "xdRead", "hdStream", "pcLoader", "pdStream", "pbLoader", "dsLoader", "pbReader", "ddLoader", "pcRead", "ddReader", "pdreader", "xdWriter", "hdReader", "hdRunner", "hdreader", "pbRunner", "ddStream", "pcWriter", "dsreader", "pdLoader", "pbStream", "dsReader", "xdReader", "hdRead", "pdRead", "pcReader", "dsRead", "xdreader", "pdRunner", "dsWriter"], "out": ["flow", "her", "model", "temp", "group", "list", "full", "page", "null", "again", "result", "img", "layer", "name", "file", "lib", "connection", "parent", "s", "device", "in", "o", "login", "outer", "child", "point", "to", "write", "cli", "over", "cache", "sync", "output", "OUT", "password", "conn", "auto", "builder", "code", "session", "pass", "outs", "doc", "io", "Out", "co", "sys", "user", "down", "copy", "err", "base", "inner", " in", "at", "exp", "later", "object", "array", "external", "line", "diff", "client", "ssl", "term", "ext", "data", "gen", "lock", "ex", "default", "inc", "db", "exec", "obj", "image", "dev", "w", "order", "with", "net", "up", "key", "writer", "store", "oder", "part", "director", "manager", "as", "word", "dot", "url"], "dcmEncParam": ["dcmEnParam", "dcmArchArg", "dcmEnPar", "dcmEnArg", "dcmDecParam", "dcmDecType", "dcmDecArg", "dcmElType", "dcmArchParameter", "dcmEncArg", "dcmEnPart", "dcmElPar", "dcmArchParam", "dcmEncType", "dcmSecParam", "dcmEnType", "dcmDecPar", "dcmEstParameter", "dcmDecParameter", "dcmEncPart", "dcmEncParameter", "dcmEstPar", "dcmEncPar", "dcmElParam", "dcmEnParameter", "dcmElParameter", "dcmEstParam", "dcmSecType", "dcmDecPart", "dcmSecPar", "dcmEstType", "dcmSecPart"], "pdWriter": ["htReader", "ddOutput", "htWriter", "hdWriter", "dpWriting", "htWrite", "dsOutput", "PDWrite", "PDWriter", "ddWrite", "ddReader", "hdReader", "pdOutput", "pdWrite", "dpReader", "dsWrite", "ddWriter", "PDReader", "PDWriting", "hdWrite", "dsReader", "pdWriting", "hdOutput", "dpWrite", "dpWriter", "dsWriter", "htWriting"]}}
{"id1": "11840277", "id2": "12454178", "code1": "    protected static void clearTables() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"delete from Objects\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (1, 'Money value')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (2, 'Date')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (3, 'Unix path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (4, 'Dos path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (5, 'Time')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (6, 'IP address')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (7, 'Internet hostname')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (8, 'Number')\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "label": 1, "substitutes": {"clearTables": ["cacheTableows", "createStaches", "clearTemings", "clearBables", "clearBings", "clearStaces", "clearTableables", "clearTations", "clearContows", "clearTemables", "cacheTableations", "cacheTables", "createTables", "clearStables", "clearTings", "cacheTableings", "clearTaces", "createTaches", "cacheTations", "clearStaches", "clearTableings", "createStaces", "clearContaces", "clearBaches", "createStables", "clearTemations", "clearContaches", "cacheTows", "clearBations", "clearBaces", "clearTows", "cacheTableables", "clearTemows", "createTows", "clearStows", "cacheTings", "createTaces", "clearTableations", "clearTaches", "clearBows", "clearContables", "createStows", "clearTableows"], "conn": ["enc", "ou", "lc", "log", "jc", "nt", "config", "coll", "dc", "oci", "nc", "open", "Connection", "ca", "ns", "cache", "exec", "ch", "wd", "cat", "ann", "cb", "bb", "act", "c", "sql", "cf", "ct", "session", "state", "rc", "path", "di", "ci", "p", "pg", "cmp", "org", "oss", "ai", "mt", "client", "cc", "pub", "close", "cm", "ssl", "cp", "col", "ac", "co", "con", "h", "cn", "server", "ob", "dn", "cond", "connect", "lock", "sth", "Conn", "mc", "error", "n", "ctx", "Connect", "connection", "loc", "db", "conf", "obj"], "stmt": [" stma", "stlt", "estmt", "stma", "actmt", "est", "ctmt", "actmn", " stmi", " stager", "tct", "dmt", "sttor", " stmc", "Stap", "stmn", "Sttx", "ewd", "stmm", "Stmd", "putwt", "STgr", "putml", "putlt", "Sttor", "stgr", "putmt", "putmm", "putma", "stprint", "ftbm", "str", "ldmn", "emt", "stsst", "tnt", "ctm", "STmt", "putager", "Stmt", " stct", "Stwt", "stsmt", "stwd", "ctr", "ldma", "Stlt", "stnt", "actnt", "strlt", "STbm", "STlt", "stsprint", "ssbm", "putap", "StMT", "stwt", "estwt", "istmt", "stml", "ctql", "stbm", "Stm", " stm", "dm", " stql", "istMT", " stmd", "STmd", "ctmd", "dr", "Stmm", "sswt", " stml", "Stmn", "stMT", "playwt", "puttor", "ssmt", "sttx", "stmi", "stap", "ftmn", "Stnt", "stql", "Stml", "estm", "putMT", "STMT", " stlt", "istgr", "STwd", "stst", "actmi", " stap", "dql", "STmn", " stgr", "stmc", " stmn", "putm", " stbm", "playtor", "stct", "ctgr", "strml", "tm", "stmd", "strMT", "Stgr", "istmn", "putbm", "Stmc", "playtx", "eprint", "Stct", "Stmi", "stager", "playmt", "puttx", "stswd", "putmn", " str", "stm", "strmt", "ldmt", "STmc", " stnt", "ftlt", "STst", "STprint", "estmm", "ldager", "tmt", "ftmt", "ssmn", " stwt"]}}
{"id1": "20190303", "id2": "5049453", "code1": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "code2": "    private BingResponse queryBing(BingRequest request) throws BingException {\n        try {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Searching through bing...\");\n            }\n            String query = request.getQuery();\n            query = URLEncoder.encode(query, \"UTF-8\");\n            URL url = new URL(\"http://api.bing.net/json.aspx?\" + \"AppId=\" + request.getAppId() + \"&Query=\" + query + \"&Sources=\" + request.getType().toString());\n            URLConnection connection = null;\n            if (useProxy) {\n                if (proxyType == null) {\n                    throw new BingException(\"Please set a proxy first before trying to connect through a proxy\", new Throwable());\n                }\n                connection = ProxyWrapper.getURLConnection(url.toString(), proxyType.toString(), proxyHost, proxyPort);\n            } else {\n                connection = new URL(url.toString()).openConnection();\n            }\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            String response = builder.toString();\n            ResponseParser parser = new ResponseParser();\n            parser.getError(response);\n            return parser.getResults(response);\n        } catch (MalformedURLException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        } catch (IOException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        }\n    }\n", "label": 0, "substitutes": {"test01_ok_failed_500_no_logo": ["test01_ok_failed_500_no__log", "test01_ok_failed_500_no1blog", "test01_ok_failed_500_no__ban", "test01_ok_failed_500_NO__log", "test01_ok_failed_500_NO_blog", "test01_ok_failed_500_no_Log", "test01_ok_failed_500_NO_log", "test01_ok_failed_500_NO__ban", "test01_ok_failed_500_no1log", "test01_ok_failed_500_NO__blog", "test01_ok_failed_500_no1ban", "test01_ok_failed_500_no_log", "test01_ok_failed_500_no__Log", "test01_ok_failed_500_NO_ban", "test01_ok_failed_500_NO__Log", "test01_ok_failed_500_no_blog", "test01_ok_failed_500_no1Log", "test01_ok_failed_500_no_ban", "test01_ok_failed_500_NO_Log", "test01_ok_failed_500_no__blog"], "client": ["method", "force", "pool", "service", "resource", "child", "this", "self", "Client", "cli", "channel", "http", "cache", "api", "conn", "class", "c", "session", "handler", "p", "https", "uri", "console", "secure", "manager", "app", "socket", "ssl", "request", "proxy", "tc", "con", "server", "host", "port", "call", "php", "connect", "instance", "per", "wait", "connection", "config", "web", "plugin", "url"], "post": ["method", "feed", "submit", "end", "posts", "self", "to", "pre", "patch", "head", "entry", "http", "load", "zip", "process", "api", "object", "after", "builder", "code", "set", "apply", "POST", "pass", "next", "success", "upload", "build", "test", "request", "proxy", "server", "port", "call", "php", "pod", "Post", "project", "f", "copy"], "response": ["body", "onse", "method", "model", "pool", "index", "resource", "service", "feed", "site", "view", "Response", "respons", "json", "http", "message", "output", "api", "respond", "object", "page", "status", "application", "resp", "throw", "next", "success", "successful", "result", "report", "request", "server", "data", "document", "error", "connection", "reply"]}}
{"id1": "3584508", "id2": "7425022", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"copyResource": [" downloadResource", " downloadFile", " downloadUrl", " copyFile", "copyUrl", "transferFile", "transferResource", " copyresource", " copyUrl", "transferUrl", "transferresource", "copyFile", "copyresource", " downloadresource"], "url": ["re", "image", "URL", "base", "resource", "lr", "feed", "www", "stream", "Url", "download", "ls", "ref", "http", "src", "remote", "l", "object", "page", "string", "r", "bel", "path", "ource", "uri", "xml", "loader", "name", "ssl", "server", "data", "file", "host", "id", "sl", "connection", "loc", "source", "web", "f", "address"], "input": ["image", "index", "base", "in", "resource", "temp", "feed", "this", "stream", "current", "inner", "inf", "form", "audio", "open", "Input", "active", "accept", "parse", "http", "cache", "load", "l", "api", "bb", "bin", "element", "act", "ack", "buffer", "session", "plus", "progress", "upload", "out", "pull", "client", "context", "xml", "but", "socket", "ssl", "request", "data", "file", "binary", "qa", "instance", "error", "i", "reader", "get", "connection", "config", "source", "exec", "f", "inc", "address"], "output": ["image", "flow", "unit", "log", "ou", "resource", "outer", "other", "stream", "current", "production", "write", "target", "cache", "queue", "writer", "environment", "object", "application", "external", "buffer", "control", "result", "console", "out", "response", "layer", "network", "operation", "Output", "file", "data", "binary", "document", "put", "default", "connection", "config", "source", "web", "socket", "copy", "address"], "b": ["base", "nb", "br", "abs", "bit", "l", "bb", "bin", "cb", "buf", "c", "r", "buffer", "d", "k", "lb", "fb", "be", "p", "line", "bi", "sb", "v", "x", "B", "pb", "bar", "a", "h", "bs", "file", "ob", "binary", "e", "i", "rb", "mb", "n", "bc", "bf", "batch", "m", "db", "f", "ab"]}}
{"id1": "7757297", "id2": "18631594", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "label": 0, "substitutes": {"submit": ["register", "login", "send", "sub", "form", "download", "input", "write", "open", "accept", "run", "process", " submission", "post", "update", "apply", "success", "type", "close", "start", "report", "Submit", "init", "request", "complete", "execute", "save"], "uri": ["URL", "base", "resource", "directory", " URI", "format", "iri", "cli", "Url", "duration", " ur", "http", "text", "message", "filename", "href", "api", "ui", "string", "ri", "route", "path", "source", "io", "response", "URI", "xml", "report", "server", "id", "file", " Uri", "data", "absolute", "username", "description", "i", "database", "location", "plugin", "address"], "Exception": ["Interface", "Adapter", "Response", "except", "End", "Ex", "Record", "Connection", "Exc", "A", "Except", "Timeout", "Application", "Request", "Description", "Problem", "ceptions", "Null", "Document", "ception", " exception", "Exit", "Event", "Error", "Transaction"], "encodedrdf": ["encodedrtrf", "encodedude", "encodingrdF", "encodedwdrf", "encodingwdF", "encodedwdef", "encoderdrf", "encodedwdF", "encodedrdF", "encodedrrrf", "encodedrtbf", "encodingwdrf", "encodingrdbf", "encodedrdef", "encodedrrf", "encodingwdf", "encodedvrf", "encodingrdf", "encodedrtF", "encodedrref", "encodedudf", "encodedwde", "encodedrde", "encodingwdbf", "encodedvrF", "encoderdf", "encodeude", "encodedrtf", "encoderdef", "encodedrdbf", "encodedvrbf", "encodeudf", "encoderde", "encodeudrf", "encodedrre", "encodedvrrf", "encodedrdrf", "encodingrdrf", "encodedudrf", "encodedudef", "encodeudef", "encodedwdf", "encodedwdbf"], "url": ["image", "link", "URL", "base", "service", "resource", "config", "Url", "open", "channel", "text", "Connection", "http", "use", "l", "conn", "page", "string", "position", "session", "relation", "path", "job", "control", "client", "name", "ssl", "socket", "location", "proxy", "server", "user", "file", "connect", "database", "contact", "loc", "source", "address"], "connection": ["link", "URL", "in", "service", "section", "config", "function", "open", "channel", "version", "Connection", "text", "http", "use", "l", "b", "conn", "password", "writer", "connected", "application", "string", "driver", "c", "position", "condition", "session", "relation", "handler", "io", "org", "number", "response", "client", "character", "context", "socket", "communication", "proxy", "con", "server", "document", " Connection", "connect", "database", "contact", "n", "or", "loc", "source", "directory"], "lastUser": [" lastCategory", " lastWord", "latestCategory", "LastRow", "latestWord", "latestRow", "latestUser", "LastWord", " lastRow", "LastUser", "lastCategory", "lastRow", "LastCategory", "lastWord"], "out": ["temp", "global", "window", "list", "full", "page", "again", "result", "name", "file", "call", "comment", "editor", "log", "pool", "in", "o", "cmd", "outer", "login", "flush", "check", "write", "cli", "cache", "sync", "output", "OUT", "password", "bin", "conn", "builder", "outs", "doc", "io", "commit", "Out", "init", "server", "user", "down", "error", "no", "copy", "err", "office", "prefix", "inner", "at", "req", "exp", "extra", "external", "line", "client", "off", "dump", "data", "lock", "exec", "obj", "socket", "image", "view", "w", "plain", "up", "key", "writer", "part", "word", "wrapper"]}}
{"id1": "3309233", "id2": "8164056", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doInAsync", " doUsingBackground", " doInConsole", " doAsyncConsole", " doUsingStudio", " doAsyncBackground", " doUsingAsync", " doInStudio", " doAsyncAsync", " doAsBackground", "buildInConsole", " doAsConsole", "buildInAsync", " doAsStudio", "buildUsingConsole", " doAsyncStudio", "buildUsingBackground", "buildUsingAsync", "buildInStudio", "buildUsingStudio", " doUsingConsole", "buildInBackground", " doAsAsync"], "params": ["pins", "resources", "comments", "options", "arms", "objects", "posts", "Par", "keys", "types", "json", "py", "ls", "lines", "services", "details", "parse", "ams", "properties", "par", "page", "sp", "files", "ps", "p", "settings", "Parameters", "phrase", "type", "mes", "pm", "ds", "eps", "values", "reports", "data", "Param", "s", "names", "los", "i", "strings", "results", "ctx", "config", "source", "parts", "address"], "param": ["lc", "model", "pool", "temp", "camp", "prom", "am", "ram", "project", "meter", "arm", "mm", "pc", "channel", "aram", "ams", "password", "conn", "object", "par", "page", "km", "string", "null", "contract", "option", "amp", "path", "mand", "pri", "single", "p", "part", "pm", "monitor", "proc", "iam", "gram", "pb", "cm", "name", "cp", "rem", "prem", " parameter", "mor", "Param", "Parameter", "comment", "vm", "ctx", "default", "connection", "config", "parent", "conf", "address"], "client": ["force", "base", "service", "resource", "self", "Client", "cli", "cl", "google", "channel", "http", "bird", "api", "conn", "url", "c", "session", "handler", "p", "comp", "response", "ce", "apache", "secure", "app", "cm", "ssl", "request", "proxy", "con", "server", "host", "connect", "cp", "connection", "config", "project", "plugin", "help"], "post": ["dd", "body", "base", "create", "send", "feed", "posted", "submit", "form", "pre", "install", "head", "patch", "json", "entry", "http", "zip", "load", "add", "api", "hop", "set", "pos", "pp", "c", "wp", "POST", "push", "next", "query", "op", "p", "part", "upload", "proc", "and", "response", "pb", "request", "server", "e", "put", "comment", "pod", "Post", "f"], "resp": ["re", "body", "enc", "err", "resource", "serv", "content", "Response", "download", "json", "rep", "req", "ref", "http", "fc", "rec", "api", "respond", "conn", "par", "page", "status", "sp", "success", "handler", "rh", "response", "Resp", "comm", "received", "request", "server", "e", "error", " response", "res", "rel", "exec", "reply", "obj"], "entity": ["enc", "body", "ity", "model", "unit", "base", "resource", "agent", "coll", "event", "content", "json", "entry", "output", "conn", "connection", "object", "string", "code", "element", "status", "node", "translation", "line", "attribute", "ent", "response", "xml", "article", "data", "e", "instance", "el", "person", "activity", "Entity", "ec", "obj"], "result": ["resource", "Result", "content", "json", "match", "entry", "property", "details", "text", "message", "output", "object", "page", "status", "string", "success", "translation", "line", "source", "record", "ret", "place", "row", "response", "report", "name", "data", "instance", "value", "description", "desc", "results", "res", "default", "location", "url", "address"]}}
{"id1": "8430178", "id2": "17792212", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", "transferFile", "CopyFile", "transferPath", " copyfile", "Copyfile", " copyPath", "copyfile", "copyFiles", "copyPath", "CopyPath", "CopyFiles"], "source_name": ["Source_file", "source_key", "source_uri", "source_Name", "src_name", "src_file", "source_names", "sourceCname", "sourceNtype", "source_size", "source_data", "Source_data", "src_alias", "source_alias", "sourceNname", " source_Name", "Source_name", "source_type", "src_uri", "sourceNalias", "src_size", "sourceNfile", "source_path", "sourceCfile", "sourceCtype", "sourceCalias", " source_path", " source_key", " source_names", "src_type"], "dest_name": ["dest_resource", "destappnames", "dest_id", " dest_path", "destFilename", "destFilenamed", " destination_resource", "dest_none", "dest_word", " destinationFresource", " dest_none", "destflabel", "source_Name", "destRdefinition", "target_names", "destJnames", "destPmodel", "destPtype", "source_names", "dest_definition", "Dest_id", "destPpath", "destPword", "target_type", "destapptype", " dest_type", "dest_names", " dest_names", "destRName", " dest_Name", " destinationFpath", "destRpath", "destRname", " destination_name", "dest_label", "destJname", "destJword", " dest_file", " destination_path", "dest_named", "destFname", " dest_named", "Dest_name", "destFpath", "target_model", "destJName", "destFilelabel", "destfnamed", "dest_model", " dest_word", "destffile", " destinationFinfo", "source_path", " dest_label", " dest_definition", "destPnames", "destPname", "destFilefile", "dest_file", "target_name", "Dest_path", "dest_Name", "dest_type", " destinationFname", "destappname", "dest_path", "destFresource", "dest_info", "destfname", "Dest_Name", "destPName", "destFinfo", "destappmodel", " destination_info"], "source_file": ["source_url", "source_File", "ource_line", "sourcefname", "src_name", "source_class", "src_file", " source_class", "source_files", "source_stream", "source__name", "source__class", "sourceffile", "source__base", "source_base", " source_url", "sourcefFile", "source__file", "ource_file", " source_base", " source_cache", "ource_files", " source_File", "src_files", " source_files", "src_stream", "source_line", "source_cache", "sourcefurl", "ource_name"], "destination_file": ["destention_name", "destination_files", "destination_page", "destination2file", "destation_name", "destention4file", "destinate_files", "destation_folder", "destination2name", "destinationablefile", "destination_path", "destention_source", "destination4file", "destinate_base", "destination4source", "destinationablebase", "destention_path", "destation_function", "destination_folder", "destination_name", "destination_source", "destention_file", "destention4source", "destation_file", "destinationablefiles", "destention4path", "destination2source", "destinate_file", "destination4path", "destinationablepage", "destention4name", "destation_files", "destination_function", "destination4name", "destinate_page", "destination2path", "destination_base"], "source": ["image", "resources", "unit", "slave", "ize", "service", "resource", "SOURCE", "index", "site", "storage", "view", "stream", "Source", "current", "inner", "input", "open", "target", "master", "src", "cache", "load", "local", "slice", "output", "remote", "object", "scope", "ources", "via", "class", "from", "spec", "core", "single", "ource", "result", "uri", "dest", "diff", "client", "secure", "ite", "start", "name", "proxy", "search", "server", "file", "reference", "reader", "get", "connection", "config", "parent", "copy"], "destination": ["Destension", "destension", "foreigninated", "constining", "targetinate", "destinator", " destina", "targetination", "destribution", "Destination", "variinator", " destinator", "testribution", "foreigninator", "Destinated", "destina", " destining", "validination", "dependinate", "variinate", "coordination", "foreigninate", "constribution", "descinated", "testinated", "variination", "Destinator", "identination", "validinator", "testinator", "variinated", "identribution", "identinated", "Destining", "coordinated", "dependination", "targetinator", "destinate", "destinated", "testination", "descination", "constination", "coordension", "identina", "dependinator", "foreignination", "constinator", "Destina", " destinated", "coordinator", "dependinated", "Destribution", " destribution", "descinator", "destining", "validinate", "targetinated", "descension", "validinated"], "buffer": ["image", "pool", "temp", "flush", "sequence", "input", "window", "channel", "text", "cache", "queue", "writer", "bin", "buf", "buff", "Buffer", "padding", "uffer", "block", "binary", "transfer", "limit", "reader", "timeout", "iter", "batch", "memory", "header"], "bytes_read": ["bytesUnRead", "Bytes_set", "bytesUnread", "bytes_set", "bytesUnset", "Bytes_found", "bytesUnfound", "bytes_found", "Bytes_read", "Bytes_Read", "bytes_Read"], "in": ["ini", "image", "re", "log", "resource", "login", "temp", "serv", "stream", "inner", "current", "inn", "val", "input", "din", "In", "fe", "rec", "l", "bin", "b", "read", "r", "IN", "session", "again", "token", "path", "p", "doc", "line", "nin", "container", "min", "out", "ins", "is", "as", "ssl", "a", "request", "con", "h", "data", "file", "id", "lock", "reader", "get", "n", "or", "connection", "f", "url", "inc", "s"], "response": ["re", "body", "onse", "image", "model", "answer", "resource", "feed", "question", "view", "sequence", "Response", "respons", "json", "version", "reason", "offer", "text", "message", "reset", "output", "api", "respond", "object", "update", "status", "example", "string", "application", "r", "resp", "next", "success", "line", "result", "uri", "su", "report", "received", "request", "server", "data", "true", "error", "description", "value", "res", "location", "reply", "dict", "header"], "parentdir": ["parentDir", "parentdict", "parentfile", "partlib", " parentdirectory", "rootdir", "parentsDir", "partdirectory", "Parentdir", "parentdiff", "hostdirectory", "rootfile", "partfile", " parentdict", " parentfile", " parentlib", "partdir", "parentlib", "parentsfile", "rootdirectory", "parentsdir", "rootlib", "homefile", "parentsdiff", "hostdir", "homeDir", "homediff", " parentDir", " parentdiff", "Parentdirectory", "homedir", "Parentdict", "hostdict", "parentdirectory"]}}
{"id1": "13757855", "id2": "9096319", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"process": ["resource", "create", "submit", "view", "transform", "project", "parse", "load", "run", "processing", "output", "update", "code", "path", "build", "proc", "cess", "evaluate", "handle", "Process", "request", "construct", "call", "exec", "processor"], "tpl": ["Tpp", "templates", "tml", "Tbl", "qtple", "lPL", "atpl", "psl", "itpl", " tplug", "Tplates", "ttemplate", "tmpl", "tplates", " tple", " tper", " tplate", "lml", "temPL", "atplate", "tplate", " ttemplate", "tcp", "Ttemplate", "fplug", "Tml", "lcl", "TPL", "tbl", "Tsl", " tfc", "fplate", "tipl", "latcp", " tipl", "Tpl", "atml", "stPL", "Tipl", "pipl", " tbl", "qtcp", "lplate", "tplug", "Tple", "qtpl", "atplug", "Tper", "itplates", "tsl", "temtemplate", "tfc", "tple", "qtbl", "latpl", "lpl", "fpl", "tPL", "itPL", "pPL", "tpp", " tcl", "tcl", "lper", "tmyl", "itplate", " tPL", "ppl", "latyl", "tmcp", "qtfc", " tplates", "tper", "pcl", "stpl", " tsl", " tpp", "lple", "qtyl", "tmple", "templ", "latple", "stpp", "stplate", "Tfc", "Tcl", "fml", "Tplate", "tyl", " tml"], "model": ["body", "log", "graph", "module", "Model", "config", "json", "param", "message", "media", "params", "node", "m", "doc", "result", "command", "where", "xml", "models", "language", "data", "document", "location", "project", "conf", "copy"], "packageName": ["PackageNames", "PackageName", " packagename", "groupName", "packageUrl", "modulename", "contextName", "groupUrl", "packageKey", " packageNames", "moduleUrl", "moduleKey", "contextInfo", "projectKey", "Packagename", "groupKey", "contextname", " packageInfo", "groupname", "projectName", "moduleName", "packageNames", "packagename", "projectUrl", "contextNames", "projectname", "PackageInfo", "packageInfo"], "outFileName": ["inFilePath", "outFileTime", "diffFileOnce", "OutDirNames", "outDirEnd", " outFullType", "inDirPath", "outBufferHalf", "outDirInfo", "outFileType", "outDirname", "outFullInfo", "outfileMode", "difffileInfo", "outfileOnce", "outLinename", "outDirCopy", "OUTFileHalf", " outFileInfo", "inDirEnd", "outDirTime", "diffFileInfo", "outFullType", " outFilePath", "outLineNames", "outFileOnce", "outFullTime", "outFileHalf", "outfileCopy", "OutDirName", "outRuleType", "outLineName", "outFilenameHalf", " outDirPath", "outLineOnce", "OUTBufferHalf", "outFullNames", "outFilenameCopy", "outFilesLine", "OUTBufferMode", "diffFileTime", "outFileInfo", " outFullInfo", "outDirName", "inDirCopy", "OUTBufferName", "outfileName", "difffileName", "outFileLine", "outFileEnd", " outFileTime", "OutFileName", "OutDirLine", "outFilenameName", "outFilesPath", "inFileCopy", " outDirTime", "OutFileNames", "OUTFileName", "outFileCopy", "outDirOnce", "diffFileName", "outfileTime", "outfilePath", "outFilePath", "OutDirname", "outFilename", "outBufferMode", "OUTFileNames", "OUTBufferNames", "outFilenamePath", " outFileLine", "difffileTime", "outStreamInfo", "outStreamType", "outLineInfo", " outDirName", " outFileType", "outfileInfo", "outFilenameEnd", "OutFileLine", "outFileMode", "outfileHalf", "outBufferName", "outDirLine", " outDirLine", "outFullname", "outfileEnd", "outFullPath", "outRuleInfo", "outBufferNames", "outStreamName", "OutFilename", "outRuleName", "inFileName", "outFullLine", "outfileNames", "outFilesTime", "outDirPath", "inFileEnd", "OUTFileMode", "outFilenameNames", "outFilesName", "outLineTime", "inDirName", "outDirNames", "outFullName", "outFilenameMode", "outFileNames", "outLineLine", "difffileOnce", " outFullName"], "xsltParam": ["xldVal", "xldMode", "xslicParam", "xsltparam", "xltVal", "xslpVal", "xsldVal", "xslpparam", "xslicVal", "xldParam", "xslpMode", "xslicparam", "xltparam", "xslpParam", "xsldParam", "xslicMode", "xsltMode", "xsldMode", "xsltVal", "xltParam", "xsldparam", "xldparam", "xltMode"], "artifact": ["aratifacts", "Artifact", "Artribution", "adverturation", "Artfact", "aratifact", " artribution", "arturation", "aratifest", "artfact", " artifacts", "ARTifacts", "ARTifact", "aratfact", "advertifacts", " arturation", "artifacts", "Artifest", "artribution", "Arturation", "ARTifest", "artifest", "advertifact", "ARTfact", "advertribution", "Artifacts"], "destinationPath": ["destiningpath", "distinatorName", "destinationspath", "constinationsPoint", "destiningName", "destinationsPath", "constinationWidth", "destinatedString", "restificationPoint", "destinationHandler", "datinatePath", "distributionCase", "destplingPath", "tempinationHalf", "desticationKey", "combinationHandler", "destinationPoint", "destinerPath", "desticationFile", "DestinationPart", "destiningDir", "constinationDir", "restinationHalf", "combinatorpath", "destributionDir", "desticationStep", "destinatedPoint", "distinationCase", "destinationsName", "destificationLog", "constinatorUrl", "destinationPart", "destinationStep", "destationLocation", "destificationName", "tempinatedHalf", "destinatorWidth", "destinateHalf", " destificationAuth", "destiningContext", "DestinationPoint", "constinatorWidth", "destinateDir", "destinationLocation", "destinatorContext", "constinationsPath", " destificationLog", "destinatingpath", "destinatedFile", "destationpath", "distinatorStep", "DestinatingPath", "destinatePart", "restinatorPath", "destificationLocation", "combinatorName", "tempinatedpath", "destinatedCase", "destplingUrl", "distinatorPath", "destplingLog", "destinationHalf", "DestinationText", "destributionCase", "datinationTime", "destinatorCase", "destinerContext", "destinatePoint", "destignmentCry", "restificationPath", "desticationPath", "datinationPath", "destinatepath", "tempinatedPath", "destinationCry", "constinationPoint", "destributionpath", "combinationPath", "destensionText", "destinatedDir", "combinationName", "destinatorFile", "destinatingText", "constinatorDir", "datinatepath", "destinatedKey", "DestificationName", "restificationLocation", "destignmentCase", "distinatorFile", "constinationspath", "constinationContext", "DestinatingText", "destcreationPath", "distinatorKey", "constinatorPath", "destinationName", "distinationDir", "restinationLocation", "destinateTime", "destificationPart", "destensionPath", "desticationPart", "distinatorCase", "destinateHandler", "restinationPoint", "destiationAuth", "destinatorUrl", "destificationAuth", "combinatorPath", "destinatorPath", "destplingAuth", "distinationFile", "destinationFile", "datinateTime", "destributionCry", "DestinatingPoint", "destiningPath", "destiationDir", "constinatorpath", "datinationLocation", "tempinationDir", "constinationUrl", "destinateText", "destensionPoint", "desturationHandler", "destiningPoint", "destificationDir", "destignmentPath", "destinatingPath", "tempinationPath", "desturationPath", "destinatorpath", "combinationpath", "destinationKey", "destinationpath", "constinatorContext", "destificationpath", "destinatorKey", " destinationLog", "destinateString", "datinateLocation", "destificationPoint", "destinatingLocation", "restificationpath", "destationPath", "destinationWidth", "destributionPath", "distinationPath", "destributionName", "destinatorString", "distinationKey", "destinatorCry", "tempinatedDir", "destinationAuth", "destinatingPoint", " destificationDir", "destcreationUrl", "DestificationPath", "destinerpath", "DestinationPath", "destinationLog", "destinationDir", "destplingDir", "distributionpath", "tempinationpath", "datinationpath", "destinatorHalf", "distinationStep", "destinationText", "restinatorString", "restinationPath", "distinationpath", "constinationsName", "restinationString", "destinatingName", "constinationName", "destinateName", "destiationLog", " destinationDir", "destinatorHandler", "destinatePath", "restinatorPoint", "destensionName", "destinatorTime", "distributionPath", "destinationCase", "destinatorPoint", "combinatorHandler", "desturationName", " destificationPath", "destinatorStep", "destinationsPoint", "destinatedPath", "destignmentName", "destiationPath", "distinationName", "destinationContext", "destinateLocation", "desturationpath", "destificationPath", "destinatedHalf", "destinatedStep", "DestinationName", "distributionDir", "destinatorName", "destinationTime", "destcreationWidth", " destinationAuth", "destinatorDir", "DestificationPart", "desticationName", "DestinatingName", "restinationpath", "destplingWidth", "destinatorLocation", "destationTime", "destinationString", "constinationPath", "destinatedpath", "distinatorCry", "destinationUrl", "distinationCry", "constinationpath", "destinerDir", "restinatorHalf"], "in": ["image", "input", "In", "cache", "bin", "c", "r", "IN", "t", "d", "doc", "source", "x", "min", "ins", "name", "con", "data", "ex", "reader", "i", "n", "connection", "config", "din", "inc"], "out": ["err", "log", "index", "pool", "o", "outer", "temp", "prefix", "point", "w", "write", "cli", "with", "version", "group", "up", "cache", "exec", "ne", "output", "OUT", "writer", "key", "list", "bin", "conn", "page", "post", "string", "full", "store", "session", "state", "again", "outs", "path", "free", "doc", "line", "part", "io", "result", "all", "Out", "client", "manager", "name", "sys", "dump", "user", "file", "server", "Output", "gen", "lock", "error", "ex", "comment", "str", "lib", "connection", "msg", "source", "parent", "obj", "copy"], "root": [" roots", "resources", "_", "index", "graph", "module", "options", " result", "history", "transform", "format", "json", "pattern", "Root", "cache", "roots", "cat", "r", "collection", "params", "path", "query", "node", "values", "xml", "loader", "tree", "id", "include", "modules", "instance", "results", "meta", "parent", "url"]}}
{"id1": "8329093", "id2": "21063400", "code1": "    public void parse(ParserEvent event) {\n        logger.debug(\"parse() called for link \" + event.getLink().getURI());\n        if (event.getLink().getURI().matches(itemFilter)) {\n            logger.debug(\"Content \" + event.getLink().getURI() + \" matched\");\n            Statement stmt = null;\n            ResultSet rs = null;\n            long checksum1 = 0;\n            try {\n                URL url = new URL(event.getLink().getURI());\n                checksum1 = url.openConnection().getLastModified();\n            } catch (MalformedURLException mfe) {\n                logger.error(\"Malformed url \" + event.getLink().getURI() + \" - \" + mfe.getMessage());\n                return;\n            } catch (IOException ioe) {\n                logger.error(\"Couldn't read \" + event.getLink().getURI() + \" - \" + ioe.getMessage());\n                return;\n            }\n            if ((checksum1 == 0) || (checksum1 == 1)) {\n                Adler32 adler32 = new Adler32();\n                NodeList nodes = (NodeList) event.getPageData().getData();\n                adler32.update(nodes.toHtml().getBytes());\n                checksum1 = adler32.getValue();\n            }\n            try {\n                stmt = conn.createStatement();\n                rs = stmt.executeQuery(\"SELECT * FROM documents WHERE url='\" + event.getLink().getURI() + \"'\");\n                if (rs.first()) {\n                    long checksum2 = rs.getLong(\"checksum\");\n                    if (checksum1 == checksum2) {\n                        stmt.executeUpdate(\"UPDATE documents SET checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    } else {\n                        stmt.executeUpdate(\"UPDATE documents SET checksum=\" + checksum1 + \", checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    }\n                } else {\n                    stmt.executeUpdate(\"INSERT INTO documents VALUES \" + \"(DEFAULT, '\" + event.getLink().getURI() + \"', \" + checksum1 + \", '\" + providerId + \"', \" + String.valueOf(System.currentTimeMillis()) + \")\");\n                }\n            } catch (SQLException e) {\n                logger.error(\"Could't perform database query or update - \" + e.getMessage());\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    rs = null;\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    stmt = null;\n                }\n            }\n        }\n    }\n", "code2": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "label": 0, "substitutes": {"parse": [" explode", " assemble", " scan", "patch", " setup", "parser", "process", "replace", "info", "apply", " merge", " split", " read", " parsing", "se", " discover", " patch", "Parser", "handle", " serve", "pack", " dissect", " parser", " sniff", "arse", " extract", " analyse", " build"], "event": ["image", "flow", "action", "resource", "other", "view", "stream", "this", "content", "input", "function", "open", "entry", "version", "load", "message", "cache", "text", "events", "info", "environment", "object", "update", "style", "element", "g", "item", "vent", "handler", "node", "author", "original", "type", "attribute", "result", "v", "x", "entity", "response", "ce", "layer", "context", "xml", "app", "request", "data", "ev", "document", "Event", "e", "user", "instance", "error", "comment", "actual", "config", "source", "parent", "address"], "stmt": ["stbl", "Stmt", " stct", "stct", "tct", "Stmb", "adbl", "stmd", "tm", "dmt", "adnt", "adql", "stql", "stpt", "tmb", " stmn", "rpt", "stnt", "stmn", "Stct", "tbl", "rnt", "dnt", " start", "spmt", "Stmd", "STm", " stmb", "stm", "tmd", " stbl", "start", "rmt", "Stpt", "dpt", "adpt", " stpt", "spbl", "rql", "adart", "STmn", "dql", "tpt", "Stm", " stm", "admt", "STmt", "spmd", "stmb", "spart", "tmt", " stmd", "Stbl", "STmd", "tmn", "admd"], "rs": ["resources", "ars", "sels", "vals", "rys", "eers", "odes", "RC", "ls", "runs", "lines", "rt", "details", "maps", "vers", "ges", "src", "repl", "events", "ms", "otes", "ws", "Rs", "pr", "rd", "r", "xs", "rows", "rc", "ps", "ats", "obs", "ows", "ds", "relations", "ris", "result", "acks", "ros", "rr", "ras", "cs", "mr", "opens", "qs", "ins", "hs", "hr", "ys", "sr", "gs", "icks", "nas", "bs", "RS", "results", "res", "ks", "ts", "stats", "rss"], "checksum1": [" checksum0", "checksums1", "checksque1", "checksque0", "checksnum91", " checkssum100", " checkssumOnce", "checksumi2", "checksum0", "checksumm2", "checksullOne", "checksnum1", " checkssum2", "checksummer91", "checksque2", " checksum3", " checksum91", "checksam2", "checksull61", "checksumi1", "checkssum1", " checksumOne", "checksumb2", "checksnumOne", "checksummOne", "checksUM3", " checkssum3", "checksumi3", "checksam100", "checksum61", "checksum100", "checksnum0", "checksum3", "checksums2", " checkssum91", "checksumbOne", "checksull1", "checkssum3", "checksumsOnce", "checksumm1", "checksUM2", "checksummer1", " checksum61", "checkssum91", "checkssum2", "checksUMOne", " checkssum1", " checkssumOne", "checksull2", "checksam0", "checkssum100", "checksumOne", "checksUM1", "checksummer0", "checksumb1", " checksum100", " checkssum0", "checksam1", "checksummer2", "checksum91", "checksnum2", "checksque100", "checksnum3", "checkssum0", "checkssumOnce", " checksumOnce", "checksnum61", "checkssumOne", " checkssum61", "checkssum61", "checksumOnce", "checksumsOne", "checksumbOnce"], "url": ["image", "link", "html", "URL", "base", "resource", "www", "Link", "impl", "stream", "coll", "content", "ul", "Url", "ball", "ls", "channel", "match", "http", "message", "text", "l", "b", "conn", "api", "object", "page", "string", " URL", "r", "bel", "buffer", "path", "job", "fl", "org", "uri", "pull", "layer", "blog", "orb", "xml", "URI", "ssl", "server", "data", "file", "ll", "user", "ob", "id", "el", "sl", "error", "connection", "loc", "location", "web", "f", "address"], "adler32": ["adlr40", "aclr16", " adler2", "adlr2", "adler31", "adger40", "adger32", "adlor32", " adger16", "adlr52", " adlr2", " adger31", "acler16", "adle32", "adlor2", "adlor16", "adlor52", "aclr52", "adder31", "adder40", "adder32", "adler40", " adler40", "aclr2", "aclr32", "adder16", "adle16", " adlr32", "adlr16", "acler52", "acler2", "adler52", "adlr32", "adle40", " adler31", "adger16", " adlr16", "acler32", " adler16", " adger40", " adlr40", "adger31", " adger32", "adler16", "adger2", "adler2", "adlr31", "adle2", "adger52"], "nodes": ["nubes", "snode", " nobs", "sents", "sode", "snodes", "nods", "Node", "Nobs", " node", "Nubes", " nubes", "todes", "tods", "node", "sods", "nents", "tents", "tode", "sodes", "snobs", "snubes", "Nents", "Nods", "Nodes", "nobs"], "checksum2": [" checksum0", "checksums1", "checkssum1", "checkssum0", "checksub2", " checkssum82", "checksummer82", "checksha1", "checksub1", " checksum82", "checksummer1", "checksums0", "checksha2", "checksha0", "checkssum2", "checksum0", " checkssum1", "checkssum82", " checkssum2", "checksub0", "checksummer0", "checksums2", "checksum82", " checkssum0", "checksha82", "checksummer2"]}}
{"id1": "160739", "id2": "22046596", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"createOutputStream": [" createInputReader", "createInputStream", " createInputFile", "createOutputSteam", " createIOReader", "createInputFile", " createByteReader", " createByteStream", " createIOStream", " createOutputFile", " createIOFile", "createInputSteam", " createInputSteam", " createByteFile", " createIOSteam", " createOutputSteam", " createOutputReader", " createInputStream", "createInputReader", "createOutputReader", " createByteSteam", "createOutputFile"], "inFile": ["incFiles", "inputfile", "inStream", "inputStream", "insFiles", "outFiles", "inputFiles", "sourceFile", "sourcefile", "inputFile", "outStream", "insfile", "incfile", "incFile", "outfile", "insStream", "incStream", "inFiles", "infile", "insFile", "sourceFiles", "sourceStream"], "outFile": ["workingStream", "workTime", " outStream", "inputfile", " outDirectory", "outTime", "workfile", "workingfile", "inputDir", " outfile", "outDir", "workFile", "workingFile", "targetStream", "inTime", "outDirectory", "workingDirectory", "inputFile", "targetfile", "targetFile", "workDir", "outStream", "inputTime", "outfile", "targetDirectory", "inDir", "infile"], "k_blockSize": ["k_lockLength", "k_bitCount", "k_blockCode", "k_byteCount", "k_byteLength", "k_lockCode", "k_lockLen", "k_blocksSize", "k_blockLen", "k_BlockSize", "k_bitSize", "k_bitInfo", "k_lineSize", "k_lockCount", "k_BlockLength", "k_lineCount", "k_BlockCount", "k_byteLen", "k_blocksLength", "k_byteSize", "k_BlockCode", "k_blockInfo", "k_byteInfo", "k_blockLength", "k_blocksCount", "k_blockCount", "k_lockSize", "k_lineInfo", "k_blocksLen", "k_byteCode"], "byteCount": [" byteSum", " byteLen", "flushSize", "ByteSize", "ByteSum", "blockCount", " bytecount", "byteLen", "characterSize", "flushcount", "Bytecount", "byteLength", "flushLength", "blockLength", " byteSize", "byteSize", "characterLength", "byteSum", "bytecount", " byteLength", "characterCount", "ByteLen", "characterLen", "blockSum", "flushCount", "ByteLength", "blockSize", "ByteCount"], "buf": ["base", "cmd", "feed", "vec", "config", "flush", "feat", "src", "queue", "bag", "uf", "bytes", "b", "cb", "bh", "cap", "background", "font", "buff", "border", "buffer", "rc", "fd", "fb", "bf", "result", "Buff", "len", "img", "cas", "tmp", "alloc", "ucc", "la", "brace", "loc", "data", "cv", "rb", "ctx", "seq", "batch", "Buffer", "exc", "append"], "ofp": ["fort", "afl", "OFp", "OFnp", "OFl", "Oftp", "forp", "Ofc", "afnp", "Ofp", "OFtp", "ofl", "Ofnp", "OFt", "oft", "ofnp", "forc", "oftp", "afp", "Oft", "fortp", "afc", "ofc", "Ofl", "OFc"], "zos": ["z", "iffs", "zes", "zx", "ls", "lins", "oda", "liquid", "webkit", "zon", "tz", "zy", "nox", "forge", "bes", "os", "zers", "zl", "iframe", "rez", "modules", "zen", "fits", "los", "rons", "za", "kos", "gz", "uz", "zar", "ops", "zig", "bos", "hz", "nz", "packs", "ZA", "zn", "inos", "obs", "core", "outs", "zag", "ros", "ossus", "obb", "bitcoin", "dylib", "zona", "oses", "soon", "budget", "zi", "lol", "zb", "utils", "osi", "zip", "zyk", "ws", "ZI", "ogl", "zo", "abi", "ozo", "zik", "robe", "zh", "enos", "zer", "js", "cfg", "zin", "css", "cos", "ses", "owicz", "oS", "bs", "jas"], "osw": ["lswo", "eshell", "osy", "ossow", "osssw", "isnow", "osow", "ossww", "essw", "osswd", "oshell", "bwo", "isd", "eswd", "esow", "osnow", " osow", "osws", "ossfw", "esnow", "osd", " osfw", "issw", "esfw", "esy", "isw", "lsx", "osshell", "ossnow", "osfw", "esww", "esd", "bsws", " osww", "osx", "ossw", "ishell", "oswo", "oswd", "bws", "bsx", "iswd", "osww", "lsw", "bsw", "ossy", "lsws", "esw", "isy", "bx", "bswo", "ossd"], "bw": ["bbw", "Bw", "lw", "Bew", "lbsw", "bbwh", " bws", "bwe", "fr", "owa", "fbW", "bbaw", "oaw", "Bws", "bz", "fbw", "Bwa", "bbew", "abwe", "baw", "lbz", "abw", "fsw", "ebwe", "lbw", "owu", "fw", "fbwe", "bbz", " bew", "ow", "lbws", "ebW", "fwh", "fwa", "lbwh", "lx", "abwd", "ebw", " bwu", "lwa", "bwu", " bwa", "bew", " baw", "fx", "bws", "bwh", "fbwd", "bW", "bbwa", " bz", "lsw", "bwa", "lbwa", "bbwu", "bsw", "bwd", "ebwd", "bbws", "bx", "abW", "lbr", " bwh", "lbx"], "zot": ["zerott", "aziot", "jit", "zita", "zeros", "azor", "zerot", "zerori", "zerit", "azot", " ziot", "azott", "Zot", "zott", "Zott", "Zit", "ziot", "jot", "Zita", "jori", "Zor", "Ziot", "zor", "zori", "jos", "azit", " zori", "zerita", " zor", "azita"], "ifp": ["IFi", "ipb", " iff", "ifi", "Ifi", "ifb", "Ifc", " ifi", " ifl", "IFb", "IFf", "ipl", "IFl", "ifc", " ifb", "Iff", "ipc", "iff", "ifl", "ipp", "IFp", "IFc", "Ifp", " ifc"], "zis": ["jis", "zisi", " zib", "jisi", "jit", " zIS", "xits", " zisi", "zib", "zip", "xais", "xisi", " zits", "zenais", "zeis", "xit", "zenis", "Zis", "zenIS", "jits", "zipits", "zipiss", "xIS", "zeip", "Zits", "Ziss", "Zip", "zeiss", "xis", "zIS", "zeits", "xib", " zais", "zenib", "ziss", "zais", "zits", "zipip", "zipis"], "isr": ["irrc", "rispr", "iscr", "risr", "risrb", "ISrc", "ispr", "ISr", "isscr", " isrs", "issrs", "ISpr", "irr", " issr", "isrs", "irrb", "IScr", "isssr", "isrc", "ISrs", "isrb", "issr", "risrc", "irpr", " iscr", "ISsr", "ISrb"], "br": ["body", "err", "bsp", "lr", "fr", "kr", "HR", "bl", "arr", "cro", "ocr", "yr", " fr", "b", "ch", "ctr", "bp", "sp", "r", "ber", "gr", "tr", " dr", "ibl", "bro", "obl", "div", "Br", "ibr", "BR", "mr", "img", "rs", "hr", " BR", "bar", "sr", "rib", "ob", "browser", "str", "rb", " Br", "bc", "bh", "obi", "shr"], "zit": ["zith", "zite", "xic", "zeita", "zic", "jit", "zita", "zipith", "zipite", "zip", "zipIT", "zenits", "zenit", " zip", "zeIT", "jic", "jita", "zenith", " zits", "zitter", "jip", "zeitter", "xit", "jIT", "zipit", "zipita", "xi", "jite", " zi", " zic", " zite", "jits", "ji", "zipits", "zIT", "zipitter", "zenitter", "zeith", "zeits", "zeit", "xith", " zith", "jith", "zits", "zipip", "zi"]}}
{"id1": "16511008", "id2": "5998352", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "label": 0, "substitutes": {"createNewProfilingMessageSymbol": ["createNewProfilingMsgSymmbol", "createNewProfilingMessageYletter", "createNewProfilingMsgSymbol", "createNewProfilingMessageSyletter", "createNewProfilingMsgSyletter", "createNewProfilingMessageSymmbol", "createNewProfilingMessageCymb", "createNewProfilingMessageCymbol", "createNewProfilingMessageYmbol", "createNewProfilingMessageYmb", "createNewProfilingMessageCyletter", "createNewProfilingMessageSymb", "createNewProfilingMsgSymletter", "createNewProfilingMessageSymmb", "createNewProfilingMsgSymb", "createNewProfilingMsgSymmb", "createNewProfilingMessageSymletter"], "configID": [" configURL", "ConfigION", " configId", "projectURL", "ConfigID", "projectID", "configURL", " configUID", "projectION", " configION", "configId", "configUID", "ConfigUID", "projectId", "ConfigURL", "projectUID", "ConfigId", "configION"], "programMessageSymbolID": ["programMessageSyymIP", "programMessageSyklName", "programMessageSychid", "programMessageSymbID", "programMessageSymbolId", "programMessageSyncmbId", "programMessageSyncmbid", "programMessageSymbid", "programMessageSyncmbolName", "programMessageSyklId", "programMessageSyymID", "programMessageSyymName", "programMessageSyntaxID", "programMessageSyncmbolId", "programMessageSyncmbName", "programMessageSychID", "programMessageSyncmbolIP", "programMessageSychId", "programMessageSyntaxid", "programMessageSyncmbID", "programMessageSyncmbIP", "programMessageSyntaxName", "programMessageSymbolIP", "programMessageSyntaxId", "programMessageSymbId", "programMessageSyncmbolid", "programMessageSymbIP", "programMessageSyymId", "programMessageSymbName", "programMessageSyncmbolID", "programMessageSymbolid", "programMessageSyklID", "programMessageSymbolName"], "profilingMessageSymbol": ["profilingFileSymmbol", "profilingMessageYmb", "profilingMessageSynPart", "profilingMessageYmbol", "profilingMessageSymmbol", "profilingApplicationSyletter", "profilingMessageCymb", "profilingApplicationSymmbol", "profilingMessageTyPart", "profilingMessageCyletter", "profilingApplicationSymmb", "profilingFileSymPart", "profilingMessageSymletter", "profilingApplicationSymbol", "profilingMessageSymmb", "profilingMessageSyletter", "profilingMessageSynmb", "profilingMessageTymb", "profilingFileSymbol", "profilingFileSymb", "profilingApplicationSymb", "profilingFileSymmb", "profilingFileSyPart", "profilingMessageTymbol", "profilingMessageCymbol", "profilingMessageSynmbol", "profilingMessageSymPart", "profilingMessageSyPart", "profilingMessageSymb", "profilingApplicationSymletter", "profilingFileSyletter", "profilingFileSymletter", "profilingMessageYletter"], "connection": ["image", "unit", "log", "pool", "index", "section", "ion", "function", "channel", "Connection", "cache", "use", "password", "environment", "conn", "ongo", "table", "driver", "application", "sql", "c", "engine", "position", "condition", "session", "state", "collection", "relation", "result", "si", "response", "client", "command", "context", "manager", "communication", "con", "server", "document", " Connection", "cond", "connect", "lock", "error", "database", "ctx", "connected", "bc", "config", "db", "socket", "machine", "directory"], "statement": ["unit", "Query", "section", "agent", "storage", "ment", "Statement", "function", "ma", "usage", "study", "parse", "Connection", "message", "parser", "use", "table", "writer", "conn", "string", "sql", "summary", "position", "condition", "session", "state", "collection", "relation", "pass", "part", "result", "stat", "si", "se", "commit", "out", "mt", "response", "command", "expression", "Session", "report", "joined", "library", "volume", "document", "connect", "lock", "str", "error", "database", "comment", "timeout", "execute", "db", "directory"], "resultSet": ["ResultGen", "ResultS", "rowS", "ResultRow", " resultList", "ResultSource", " resultLine", "resultSource", " resultSource", " resultS", "dataRow", "ResultSplit", "ResultLine", "replySplit", " resultType", "resultType", "rowType", "responseRow", "dataLine", "rowSet", "responseList", "resultS", "resultGen", "resultLine", "replyLine", "resultsSource", "resultRow", "rowSource", "resultsSet", "dataSource", "dataGen", "ResultList", "ResultSet", "replyList", "ResultType", " resultGen", "responseSet", "resultList", "resultsGen", "replySet", "dataSet", " resultSplit", "dataList", "resultSplit"], "query": ["rule", "eries", "index", "o", "q", "Query", "script", "question", "send", "module", "root", "function", "scan", "filter", "reason", "parse", "message", "key", "table", "qu", "update", "style", "string", "code", "sql", "condition", "work", "join", "type", "result", "ql", "uri", "command", "qs", "sq", "value", "expression", "name", " Query", "report", "request", "search", "execute", "id", "call", "lock", "comment", "error", "description", "str", "database", "feature", "go", "select", "timeout"], "msg": ["err", "log", "html", "nm", "cmd", "dr", "exc", "format", "ma", "ag", "reason", "sim", "text", "message", "bag", "ger", "ms", "agg", "cap", "status", "cfg", "var", "rag", "mn", "g", "gr", "tag", "gor", "op", "doc", "fg", "phrase", "cmp", "lang", "sg", "gm", "rr", "mr", "mt", "mg", "Message", "Msg", "comm", "name", "title", "tool", "map", "gs", "cm", "ge", "loc", "id", "gen", "e", "error", "str", "desc", "og", "pkg", "bg", "m", "ug", "db", "md"]}}
{"id1": "5441579", "id2": "19322946", "code1": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "code2": "    @Test\n    public void test_lookupType_FullSearch_MatchingWordInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupType/cluster\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":29055,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":29056,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29065,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":29066,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29069,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":29070,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29095,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":29096,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":21013,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Sensor Cluster\\\",\\\"icon\\\":\\\"54_03\\\"},{\\\"itemTypeID\\\":21014,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":32241,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Drive Cluster EDF-285\\\",\\\"icon\\\":\\\"24_11\\\"},{\\\"itemTypeID\\\":5279,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"F-23 Reciprocal Sensor Cluster Link\\\",\\\"icon\\\":\\\"03_09\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11534,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":17340,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11536,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":17333,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11535,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":17345,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6218,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6222,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected LADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6226,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6230,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Multi-Frequency Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6234,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected RADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":7895,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7893,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7914,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7896,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Omni Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7892,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Radar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11537,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":17336,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Gravimetric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6241,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed LADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Magnetometric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6239,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Multi-Frequency Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6225,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed RADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":20238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20244,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20250,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20260,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20240,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20246,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20252,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20262,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":21722,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Sleeper Nanite Cluster\\\",\\\"icon\\\":\\\"55_15\\\"},{\\\"itemTypeID\\\":20242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20248,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20254,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20264,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"createPseudoUUID": [" createPseudoPUD", " createPseudoPUID", " createPseudoUUUID", " createPseudoUUD", " createPseudoUMD", " createPseudoUUMD", " createPseoUMD", " createPseudoUuid", " createPseoUuid", " createPseudoUUUD", " createPseudoPuid", " createPseoUUID", " createPseudoPMD", " createPseoUUD", " createPseudoUUuid"], "messageDigest": ["messageDesignester", "maildigest", " messageDesting", "messageDesignusher", "messageSignener", "messagedigse", "mailDigest", "messageDer", "messageBuildesting", "messageDester", "messagedigEST", "messageDigesting", "MessageSignest", "messageBuilder", "messageDigested", " messageDester", "messagedigusher", "messageDest", "mailDigEST", "messageDesting", "messageBuildest", "messageDiger", "messageSignested", "messageSignesting", "messagediger", " messageDigesting", "messageSignester", " messageDest", "messagedigest", "MessageSignEST", "MessageDigusher", "messageBuildester", "messageSignEST", "maildigEST", "MessageDigse", "messageDesigner", "messageDigEST", "MessageSignester", "MessageDigest", "messageDigse", "mailDigester", "messageSignse", "messageSigner", "MessageSignusher", "messageSignusher", "messagedigested", "messageDesignEST", "messageDigusher", "messageDigester", "MessageDigEST", "MessageDigener", "maildigester", "messageDigener", "messagedigener", "messageSignest", "mailDiger", " messageDigester", " messageDer", "messageDesignest", "MessageDigester", " messageDiger", "messagedigester", "MessageDigested", "maildiger"], "localHost": ["LocalDomain", "localhost", "foreignAddress", "localAddress", "remoteAddress", "foreignPort", "localPort", "remotehost", "LocalHost", "LocalAddress", "localDomain", " localDomain", " localAddress", " localPort", "foreignHost", " localhost", "Localhost", "LocalPort", "remotePort", "remoteHost", "foreignDomain"], "digestBytes": [" digesterBlocks", "digeterBytes", "digesterGb", "digestPoints", " digengeBytes", "DigesterByte", "digensebytes", "digestampbytes", "digendbytes", "DigestPoints", "DigesterWords", " digastBytes", "digESTBitcoin", " digesterParts", "digesterBitcoin", "digsebytes", "digestedbytes", " digestBitcoin", " digastbytes", "digestsBytes", "digestGb", "digestParts", "digastBytes", "DigesterBitcoin", "DigesterPoints", "digestBlocks", "digestTokens", "digestFiles", "DigestBitcoin", " digesterbytes", "digestPages", "digastTokens", "DigestFiles", " digastByte", " digestBlocks", "Digesterbytes", "digestedBytes", "digESTbytes", "digastbytes", "DigestWords", " digengeByte", "digengeBitcoin", " digestByte", "digestedParts", "digesterPoints", "digendBytes", "digesterWords", "digseBytes", "digestampWords", "Digestbytes", "digestByte", "digestsByte", "digenseBitcoin", "digseTokens", "digESTBytes", "digseByte", "digesterParts", "digestbytes", "digengeByte", "digesterTokens", "digengeBytes", " digestParts", "digenseBytes", "digseBitcoin", "digeterFiles", "digesterByte", "digenseWords", "digenseParts", "DigesterGb", " digestTokens", " digesterBytes", "digestsPoints", " digastTokens", "digESTByte", "digestampBytes", "digesterFiles", "DigestGb", "digeterGb", "digestWords", " digestbytes", "digesterBlocks", "DigestByte", " digengeBitcoin", "digestedBitcoin", "DigestBytes", "digesterBytes", "digESTPoints", "digenseBlocks", " digengePages", "DigesterBytes", "digeterByte", "digestedByte", "digestedBlocks", "DigesterFiles", "digastByte", "digengePages", "digestedPages", "digestampBitcoin", " digestPages", "digsePages", "digesterbytes", "digestBitcoin", "digendBitcoin"], "sb": ["lc", "ib", "wb", "nb", "kb", "bm", "lr", "eb", "nl", "ba", "bl", "SB", "ls", "sa", "fe", "obj", "xb", "src", "shell", "Bs", "b", "bb", "cb", "conn", "usb", "bp", "lp", "txt", "buf", "gb", "ws", "sp", "abb", "buffer", "abi", "fb", "lb", " SB", "bf", "bj", "si", "su", "sg", "nn", "bi", "ai", "sv", "pb", "bt", "ssl", "sr", "bs", "ob", "binary", "sym", "sf", "sth", "ss", "vm", "rb", "sl", "bc", "bh", "bg", "BB", "db", "url", "s"]}}
{"id1": "14878593", "id2": "20019847", "code1": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"hyperlinkUpdate": ["hyperflowStyle", "hyperlinkUpdated", "hyperflowUpdated", "hyperLinkStyle", "hyperimageEvent", "hyperimageStyle", " hyperLinkEvent", " hyperLinkStyle", "hyperimageUpdated", "hyperlinkStyle", "hyperLinkUpdate", " hyperlinkUpdated", " hyperLinkUpdate", "hyperimageUpdate", " hyperlinkStyle", "hyperflowEvent", " hyperlinkEvent", "hyperflowUpdate", "hyperLinkEvent", "hyperlinkEvent", "hyperLinkUpdated", " hyperLinkUpdated"], "e": [" event", "de", "o", "change", "this", "event", "exc", "entry", "exec", "message", "E", "events", "environment", "element", "c", "ed", "g", "t", "handler", "er", "p", "ie", "type", "ea", "it", "v", "x", "ce", "es", "a", "ae", "esi", "ev", "data", "Event", "el", "u", "enter", "ec", "m", "f", "eve", "ee"], "url": ["image", "link", "log", "plugin", "URL", "base", "email", "resource", "service", "video", "view", "event", "download", "Url", "channel", "http", "text", "filename", "l", "object", "page", "string", "element", "buffer", "path", "large", "io", "uri", "layer", "secure", "ssl", "location", "server", "data", "file", "absolute", "host", "browser", "sl", "connection", "config", "source", "f", "address"], "stream": ["image", "log", "video", "pool", "resource", "feed", "raw", "temp", "view", "form", "transform", "input", "trans", "channel", "http", "src", "output", "string", "driver", "engine", "read", "flash", "buffer", "path", "handler", "upload", "io", "oper", "out", "response", "client", "loader", "ssl", "wrapper", "data", "file", "port", "thread", "reader", "per", "sl", "sw", "Stream", "or", "source", "f", "draft"], "writer": ["writing", "letter", "unit", "written", "wrote", "service", "temp", "office", "storage", "this", "inner", "w", "format", "write", "player", "entry", "channel", "worker", "text", "widget", "output", "key", "string", "builder", "null", "engine", "driver", "r", "buffer", "handler", "author", "writers", "io", "xml", "riter", "Writer", "word", "data", "document", "WR", "reader", "rw", "writ", "words", "source", "draft"], "editor": ["video", "html", "o", "button", "options", "office", "this", "content", "owner", "order", "player", "open", "edit", "text", "parser", "journal", "widget", "flower", "area", "api", "info", "ui", "auto", "object", "driver", "builder", "font", "creator", "external", "oder", "fb", "author", "er", "settings", "part", "translation", "ie", "io", "Editor", "director", "attr", "layer", "ner", "manager", "article", "riter", "title", "term", "archive", "server", "layout", "document", "ob", "paper", "browser", "comment", "reader", "edited", "config", "parent", "plugin", "cover"], "name": ["image", "letter", "action", "base", "office", "prefix", "NAME", "alias", "none", "version", "anc", "filename", "key", "label", "info", "full", "object", "style", "string", "home", "ame", "null", "path", "Name", "large", "type", "part", "uri", "named", "number", "size", "title", "word", "id", "file", "data", "username", "time", "names", "value", "comment", "no", "one", "n", "default", "connection", "source", "address"], "dialog": ["plOG", "paloc", "log", "navbox", "flog", "palbox", "dialbot", "fogg", "chobox", "dialob", "llogue", "dembot", "demog", "videoog", "flOG", "dialbox", "videobot", "videoogged", "llOG", "fog", "lob", "videoogg", "navoc", "demogg", "dialogged", "dialogg", "palect", "collogs", "flogue", "fbot", "dialogue", "dialect", "dialoc", "navect", "locob", "plog", "dialogs", "dialOG", "plob", "choog", "plogue", "llog", "fogged", "navog", "palog", "lOG", "llogs", "demogged", "chooc", "locog", "locogue", "collog", "logue", "flogs", "locOG", "choect", "collOG", "collogue"]}}
{"id1": "17475530", "id2": "19251426", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"testAddLinkToImage": ["testAddLinkFromImage", "testAddLinkToFile", "testAddLinkFromPicture", "testAddLinkstoImage", "testAddLinkstoFile", "testAddLinkOfFile", "testAddLinkToLink", "testAddLinkOfLink", "testAddLinkstoLink", "testAddLinktoImage", "testAddLinkOfPicture", "testAddLinkFromLink", "testAddLinktoPicture", "testAddLinktoLink", "testAddLinkFromFile", "testAddLinkToPicture", "testAddLinksToPicture", "testAddLinksToLink", "testAddLinktoFile", "testAddLinkOfImage", "testAddLinksToFile", "testAddLinkstoPicture", "testAddLinksToImage"], "in": ["ini", "image", "err", "index", "resource", "login", "serv", "stream", "gin", "inn", "val", "input", "with", "din", "In", "at", "version", "exp", "bin", "conn", "pin", "r", "IN", "again", "pass", "token", "path", "work", "doc", "nin", "uri", "cin", "diff", "min", "out", "ins", "is", "xml", "as", "socket", "ssl", "name", "ac", "con", "data", "file", "isin", "rin", "ax", "id", "el", "ex", "i", "win", "reader", "n", "get", "or", "connection", "m", "source", "exec", "f", "url", "inc", "copy"]}}
{"id1": "17683082", "id2": "20365090", "code1": "    HttpRepository(Path path) throws IOException {\n        super(path);\n        this.url = new URL(path.toURLString());\n        HttpURLConnection.setFollowRedirects(true);\n        this.connection = (HttpURLConnection) url.openConnection();\n        this.ns = Names.getNamespace(path);\n    }\n", "code2": "        public HttpResponseExchange execute() throws Exception {\n            HttpResponseExchange forwardResponse = null;\n            int fetchSizeLimit = Config.getInstance().getFetchLimitSize();\n            while (null != lastContentRange) {\n                forwardRequest.setBody(new byte[0]);\n                ContentRangeHeaderValue old = lastContentRange;\n                long sendSize = fetchSizeLimit;\n                if (old.getInstanceLength() - old.getLastBytePos() - 1 < fetchSizeLimit) {\n                    sendSize = (old.getInstanceLength() - old.getLastBytePos() - 1);\n                }\n                if (sendSize <= 0) {\n                    break;\n                }\n                lastContentRange = new ContentRangeHeaderValue(old.getLastBytePos() + 1, old.getLastBytePos() + sendSize, old.getInstanceLength());\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_RANGE, lastContentRange);\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sendSize));\n                forwardResponse = syncFetch(forwardRequest);\n                if (sendSize < fetchSizeLimit) {\n                    lastContentRange = null;\n                }\n            }\n            return forwardResponse;\n        }\n", "label": 0, "substitutes": {"IOException": ["IPError", " URIception", " IOError", " URIError", "IPception", "IOError", " URIException", "IOception", "IPException", " IOception"], "url": ["link", "image", "log", "URL", "base", "resource", "service", "feed", "impl", "this", "Url", "channel", "ref", "http", "cache", "l", "conn", "page", "access", "path", "job", "source", "uri", "build", "client", "bug", "manager", "socket", "location", "ssl", "loc", "server", "user", "file", "sl", "config", "host", "web", "address"], "connection": ["link", "index", "service", "resource", "function", "channel", "version", "Connection", "application", "position", "collection", "relation", "handler", "uri", "response", "client", "context", "manager", "loader", "socket", "wrapper", "server", "file", "reader", "database", "config", "location", "directory"], "ns": ["prefix", "domain", "nc", "lines", "net", "ls", "ms", "space", "conn", "object", "ws", "scope", "pos", "params", "ps", "ds", "os", "cs", "fs", " namespace", "NS", "cn", "names", "str", "ss", "n", "db", "obj"]}}
{"id1": "9275622", "id2": "19944975", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFolder", "movefile", "transferFiles", " copyFiles", "transferfile", "moveFile", "moveFolder", "transferFile", " copyfile", "transferFolder", " copyFolder", "copyFiles", "copyfile", "moveFiles"], "_file1": ["_resourceOne", "_fileOne", "_zipOne", "_resourceFirst", "_File01", "_zipone", "_mail2", "_file0", "_fOne", "_fileFirst", "_files01", "_resource1", "_mail01", "_files1", "_zip1", "_zipFirst", "_files0", "_mail1", "_files2", "_fFirst", "_File0", "_file01", "_File2", "_fileone", "_mail0", "_f1", "_fone", "_File1", "_resourceone"], "_file2": [" _files2", "_play2", " _file4", "_Filesecond", "_filesecond", "_file4", " _filesTwo", "_playTwo", "jmodelsecond", "_file3", "jfile5", "jfile1", "_play3", "jmodel5", "_play5", "_model1", "_filesTwo", " _files3", "_fileTwo", "_file5", "_files3", " _file3", "_File5", "jfilesecond", "_modelsecond", "jfile2", " _files4", "_files4", "_playsecond", "_files2", "_model2", "_play4", "_play1", "_File2", "jmodel1", " _fileTwo", "_File1", "_model5", "jmodel2"], "fis": ["lfiss", "afiss", "Fas", " fris", "cfris", "fi", "afis", " fi", "fils", "cfis", "cfiss", "infos", "fais", "lfis", "Fils", " fils", "infils", " fiss", "lfais", " fas", "Fos", "Fis", " fais", "cfas", "cfos", "fris", "Fiss", "infis", "fiss", "infiss", "afi", "lfi", "fas", "afais", "Fris"], "fos": ["fios", "fo", "fOS", "foses", "flis", "feoses", "pis", " foos", " fo", "feos", "infaos", "gus", "goses", " fus", "lis", "infoos", "Fios", "infros", "info", " fios", "pOS", "pos", "infios", "Foses", "Fus", "infus", "infos", "Fros", " fros", "poes", "flos", " faos", "faos", "foes", "lOS", "Fos", "floes", "Fis", "gos", "fus", "foos", "feus", "Faos", "flOS", "Foos", "fros", "Fo", "gis", "loes", "los", "feis"], "canalFuente": ["canallFuencia", "canallFuze", "canallFuence", "canalCraence", "canalKuente", "canalBuze", "canallFuente", "canalFUze", "canalBuence", "canalFUencia", "canalsFuento", "canaledFuje", "canalBuente", "canalFUestro", "canalKuence", "canalKuento", "canalCraencia", "canalFuento", "canalSuze", "canalFUje", "canalsFuente", "canallBuence", "canalFuence", "canalsFuence", "canalBuje", "canalFuestro", "canaledBuje", "canalsBuencia", "canalCraente", "canalBuento", "canalSuestro", "canalFuje", "canallBuencia", "canalSuje", "canalFuencia", "canaledBuente", "canalsFuencia", "canalsBuente", "canalFuze", "canalBuestro", "canaledFuestro", "canallBuze", "canalFUente", "canalsBuento", "canaledFuze", "canallBuente", "canalCraento", "canaledFuente", "canalKuze", "canaledBuze", "canalKuencia", "canalBuencia", "canaledBuestro", "canalFUence", "canalSuente", "canalsBuence"]}}
{"id1": "19934218", "id2": "5808579", "code1": "    public static String doCrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "label": 1, "substitutes": {"doCrypt": [" runExt", "DoCrypt", "DoMac", "DoDec", "DoExt", "murDec", " doMac", "murCrypt", "murExt", " runDec", " doDec", " runMac", " runCrypt", " doExt", "murMac"], "text": ["image", "letter", "in", " Text", "this", "hex", "content", "format", "input", "pattern", "message", "key", "password", "object", "struct", "url", "string", "txt", "class", "code", "font", "contract", "buffer", "crypt", "Text", "token", "path", "source", " TEXT", "secret", "length", "context", "name", "EXT", "ext", "word", "data", "binary", "seed", "str", "value", "connection", "config", "TEXT", "obj", "editor"], "UnsupportedEncodingException": ["UnsupportedEncodedEx", "UnsupportedEncasingException", "UnsupportedEncodedError", "UnsupportedEncodedException", "UnsupportedEncasingError", "UnsupportedEncasingEx", "UnsupportedEncodingEx", "UnsupportedEncoderEx", "UnsupportedEncoderError", "UnsupportedEncodingError", "UnsupportedEncoderException"], "md": ["dd", "body", "nm", "method", "sha", "cmd", "dr", "bm", "ud", "am", "dig", "metadata", "ma", "amd", " MD", "hd", "mm", "mad", "mode", "mo", "message", "ms", "ld", "wd", "mp", "vd", "hash", "code", "def", "mn", "d", "m", "mand", "bd", "ad", "pm", "df", "mt", "mg", "mac", "gd", "od", "sd", "me", " Md", "MD", "map", "Cmd", "mod", "data", "valid", "pd", "mag", "rm", "dm", "mc", "mb", "hm", "bf", "meta"], "sha1hash": ["shaonesha", "sha256h", "md1hash", "shaonehex", "SHA2hex", "sha256sha", "sha6h", "md1h", "SHA1hash", "sha5h", "sha1h", "SHA2hash", "md6h", "md1hex", "sha1sha", "shaonehash", "sha256Hash", "sha2sha", "sha256hash", "sha2sum", "SHA1h", "sha0hash", "SHA1sha", "sha5hash", "SHA1hex", "SHA1Hash", "sha2hex", "sha6hex", "sha6hash", "md6hash", "sha5hex", "SHA1sum", "md6hex", "sha2Hash", "sha5Hash", "sha0sum", "sha0sha", "SHA2Hash", "sha2hash", "sha0hex", "sha1hex", "sha2h", "shaoneh", "SHA2sha", "sha1sum", "sha1Hash", "sha256sum", "md6sha", "sha256hex", "sha5sha", "SHA2h", "sha6sha", "md1sha", "SHA2sum"]}}
{"id1": "8328527", "id2": "4501356", "code1": "    public void insertJobLog(String userId, String[] checkId, String checkType, String objType) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preStm = null;\n        String sql = \"insert into COFFICE_JOBLOG_CHECKAUTH (USER_ID,CHECK_ID,CHECK_TYPE,OBJ_TYPE) values (?,?,?,?)\";\n        String cleanSql = \"delete from COFFICE_JOBLOG_CHECKAUTH where \" + \"user_id = '\" + userId + \"' and check_type = '\" + checkType + \"' and obj_type = '\" + objType + \"'\";\n        try {\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            preStm = connection.prepareStatement(cleanSql);\n            int dCount = preStm.executeUpdate();\n            String sHaveIns = \",\";\n            preStm = connection.prepareStatement(sql);\n            for (int j = 0; j < checkId.length; j++) {\n                if (sHaveIns.indexOf(\",\" + checkId[j] + \",\") < 0) {\n                    preStm.setInt(1, Integer.parseInt(userId));\n                    preStm.setInt(2, Integer.parseInt(checkId[j]));\n                    preStm.setInt(3, Integer.parseInt(checkType));\n                    preStm.setInt(4, Integer.parseInt(objType));\n                    preStm.executeUpdate();\n                    sHaveIns += checkId[j] + \",\";\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            log.debug((new Date().toString()) + \" \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0228\ufffd\ufffd\u02a7\ufffd\ufffd! \");\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n                throw e;\n            }\n            throw ex;\n        } finally {\n            close(null, null, preStm, connection, dbo);\n        }\n    }\n", "code2": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "label": 0, "substitutes": {"insertJobLog": ["createjobEntry", "insertjobHistory", "insertWorkHistory", "insertWorklog", "insertjobLog", "insertJlog", "createJobHistory", "insertWorkEntry", "insertJLog", "createjobHistory", "createjobLog", "insertJobHistory", "insertJoblog", "insertWorkLog", "insertJEntry", "insertJobEntry", "createJobLog", "insertjobEntry", "createjoblog", "insertjoblog", "createJobEntry", "insertJHistory", "createJoblog"], "userId": ["useID", "userData", "userDb", "useName", "customId", " userID", "userName", "useId", "customData", " userData", " userType", "useType", "UserData", "UserName", "userID", "UserID", "USERId", "customDb", "userType", "customID", "USERID", " userDb", "USERName", "UserId", "UserType", "UserDb"], "checkId": ["pullInt", "CheckID", "workerID", "updateId", "pullID", "CheckPath", "updateInt", "jobPath", "jobID", "workerInt", "CheckId", " checkPath", "CheckType", " checkInt", "userPoint", "pullPoint", "jobPoint", "checkPath", "checkPoint", "updateID", "workType", "workID", "pullId", "checkID", "userID", "CheckInt", "workPoint", "updatePoint", "checkInt", "userInt", " checkPoint", "jobId", "pullType", " checkID", "CheckPoint", "workId", "workerId"], "checkType": [" checkTypes", "taskID", "CheckID", "checkTyp", "workInfo", "CheckTyp", "CHECKID", "taskId", "CheckType", "CheckId", "checkTypes", " checkInfo", " checkRole", "blockLength", "blockId", "CheckLength", " checkTyp", "workType", "workID", "checkID", "CheckTypes", "CHECKRole", "blockTypes", "CheckRole", "blockType", "taskInfo", " checkLength", "checkLength", "taskType", "CHECKType", "CHECKTyp", "checkInfo", " checkID", "workId", "checkRole"], "objType": ["checkTyp", "objectTypes", "objectTyp", " objName", "ObjTypes", "ObjType", "checkName", "objectType", "ObjName", " objTy", " objId", "objName", "objectName", "ObjTy", "ObjId", "ObjTyp", "objId", "opTypes", "objTypes", "opId", "objTyp", "opType", "objectId", "objTy", "opName", "objectTy"], "dbo": ["drko", "jBo", "jbf", " dBo", "mbf", " dBO", "mbo", "adBo", "Dbo", "Dbf", "Dbm", "drBo", "dBO", "dbu", "dbm", "adbo", "dbl", "DBO", " dbm", "dbf", "drBO", "drbm", "adbm", "Dko", "Dbl", "mbu", "Dbu", "dBo", "jbu", "adBO", "dko", "jbo", " dko", " dbl", "mBo", "drbl", "drbo", "DBo"], "connection": ["log", "index", "pool", "unit", "graph", "resource", "section", "ion", "service", "config", "current", "function", "channel", "Connection", "cache", "message", "b", "conn", "connected", "management", "application", "engine", "c", "driver", "position", "condition", "session", "collection", "subject", "relation", "BC", "query", "ci", "io", "response", "client", "context", "manager", "statement", "communication", "con", "union", "server", "document", " Connection", "connect", "lock", "mc", "database", "bc", "ctx", "loc", "db", "socket", "directory"], "preStm": [" preStf", "PREStmn", " preRmd", "preInstms", "preStreamM", "preStrms", "preStmn", "PREEstM", "preEdfm", "preTrm", " preStrm", " preStma", "preShv", "preStreamm", "preShmr", "preStrd", "prStf", "preStM", "preRestd", "synEstM", "preConstmt", "preRestm", "preStmd", "synEstd", "preEdrm", " preTrmn", "prDispm", "preStvm", " preShvm", "preSlmt", "preTrmt", "preColv", " preRms", "preEdmd", "preShvm", "prDismr", "preRmn", " preStv", "preEdms", "preEstd", " preStmt", " preShf", "cleanClv", "preEstM", "preShms", "preRM", "preStmr", " preRrm", "cleanClm", "prestm", "preSTmd", "preClm", " preScms", "PREEstms", "preClM", "preRrm", "preEdmt", "preRv", " preTrm", "preStd", "PREStm", "synEstms", "prStm", "preEstvm", "preRestmt", "preSlfm", " preScfm", "preStrm", "preEdmn", " preScvm", "prDism", "preScf", "cleanStm", "preSlmn", "cleanClmn", "preRestmn", " preStfm", "preStreamvm", "preConstam", "preStmt", " preRm", "preTram", "preColm", "preConstm", "preSlm", "preShm", "preScvm", "cleanClM", "preInstfm", "preStam", "preScms", "prestf", "preScv", " preStmn", "preScma", "preSlv", " preStms", "PRERestmn", "preScfm", "preShmt", "preDispm", "preEstm", "preSlf", "preStfm", "preShpm", "preSTms", "preStrM", "PREEstmt", "PREStfm", " preShms", "synStm", "synEstm", "prStmr", "preRestms", " preShma", "preInstvm", "preConstmn", "PRERestmt", "preRmd", "preShma", "PRERestm", "preStma", "prestms", " preScm", "prestpm", "cleanStM", "preSTm", "preDism", "preTrmn", "preInstm", "preRestM", "PREEstm", "preEstms", "prestmr", "preDismr", "PREStmt", "preStf", " preShm", " preStvm", "preEdm", "preRms", "preSlma", "synStd", "preStpm", "preStreamms", "preClmn", "PREStms", " preShv", "PREStM", "preColmn", "preShM", "prStpm", "preRestfm", "preSlam", "PRERestfm", "preClv", "preRm", "cleanStv", " preStmd", "synStms", "cleanStmn", "prestvm", "prDisf", "preEstmt", " preStM", "preColM", " preStam", "prestfm", " preTram", "preScm", " preShM", "preStv", "preStms", "preDisf", "preShf", "preSTrm", "synStM", " preTrmt"], "sql": ["body", "log", "html", "sol", "q", "printf", "nl", "function", "ls", "plan", "SQL", "zip", "sync", "l", "shell", "conn", "string", "params", "sn", "query", "join", "job", "ql", "eps", "sq", "expr", "where", "statement", "ssl", "msg", "fn", "seed", "limit", "str", "sl", "database", "dl", "select", "db", "pg", "url"], "cleanSql": ["cleanEsprintf", " cleanCwl", "cleanPsql", " cleanSsql", "cleanAsprintf", "cleanPsq", "cleanStql", " cleanSQL", "cleanSwl", " cleanAsq", "cleanAsQL", "cleanCsql", "cleanSprintf", "cleanStQL", " cleanCsql", "cleanPssql", "cleanSsql", " cleanCQL", "cleanEsql", "cleanAswl", "cleanCql", "cleanSQL", "cleanCQL", "cleanEssql", " cleanCql", " cleanSwl", "cleanCwl", "cleanStwl", "cleanStsql", " cleanAsprintf", " cleanSq", "cleanAsql", "cleanAsq", " cleanAssql", " cleanSprintf", "cleanEsq", " cleanAsql", "cleanPsprintf", "cleanAssql", "cleanSq"], "dCount": ["dhNumber", "Dcount", "DNumber", "dhCounter", " dcount", "DCounter", "DCount", " dCounter", " dNumber", "dhcount", "dhCount", "dCounter", "dcount", "dNumber"], "sHaveIns": ["phaveWs", "sHavingIns", "sHavingWs", "sAreIns", "phaveINS", " sWithNoINS", "sHadIns", "sWithNoins", "sHaveIn", "sHavingINS", " sHaveINS", "sWithNoIns", "phaveIns", "sHaveins", "shaveIns", "shaveins", " sHaveContents", "sHaveINS", "sHadins", "pHaveIns", " shaveIns", " shaveIn", "sAreContents", "sHasContents", " shaveins", "sAreWs", "sAreINS", " sWithNoContents", "sHadIn", "sAreins", "sWithNoIn", " sHaveins", "sHaveWs", "pHaveWs", "shaveIn", "pHaveINS", "sWithNoINS", "pHaveins", " sHaveIn", " sWithNoIns", "phaveins", "sHasINS", "sHavingins", "shaveWs", "sWithNoContents", "shaveINS", "sHaveContents", "sHasIns"], "j": ["z", "aj", "num", "jc", "fr", "section", "syn", "kj", "jl", "jit", "journal", "key", "l", "b", "ch", "jp", "js", "pr", "uj", "g", "k", "li", "ind", "job", "ie", "p", "part", "ja", "v", "x", "ji", "y", "dj", "jj", "off", "oj", "h", "jet", "jo", "J", "adj", "u", "el", "i", "lock", "ij", "n", "vol", "bj", "br", "f", "obj"]}}
{"id1": "15971794", "id2": "2217889", "code1": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "code2": "    public static InputStream getResourceAsStreamIfAny(String resPath) {\n        URL url = findResource(resPath);\n        try {\n            return url == null ? null : url.openStream();\n        } catch (IOException e) {\n            ZMLog.warn(e, \" URL open Connection got an exception!\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"getWave": ["getSound", "newwave", "readWave", "newWave", "readWire", " getwave", "newSound", " getSound", "readwave", "getwave", "readSound", " getWire", "newWire", "getWire"], "url": ["File", "image", "URL", "Ur", "lr", "wave", "fr", "feed", "base", "resource", "field", "inf", "F", "Url", "ff", "fe", "ref", "http", "filename", "l", "b", "page", "string", "r", "path", "fl", "uri", "fp", "Feed", "name", "word", "host", "file", "fn", "sf", "fax", "loc", "source", "web", "f", "address"], "Word": ["File", "Time", "Content", "Term", "Path", "Field", " word", "F", "Url", "Folder", "Length", "Wire", "Line", "Function", "Frame", "Words", "wd", "Eng", "Language", "W", "string", "Work", "Text", "Name", "Letter", "Token", "Tag", "Wave", "Code", "Gender", "Dir", "Weight", "World", "Class", "Msg", "Message", "Writer", "Hack", "word", "Win", "Rule", "Feature", "Str", "Part", "words", "Stream", "Key"], "FF": ["DF", "URL", "FC", "feed", "ELF", "Field", "Client", "Fi", "F", "RC", "ff", "P", "Folder", "FS", "FW", "TF", "IP", "fd", "FH", "IFF", "FM", "fp", "FILE", "SF", "FE", "Feed", "FB", "Fax", "LL", "DC", "AF", "FL", "FP", "FD", "IF", " ff", "CC", "BB", "FA"], "url2": ["url1", "path1", "urlTwo", "URL2", "pathDB", "pathTwo", "f4", " url3", "l2", "f2", "l4", " url4", "urlDB", " urlTwo", "url4", "URLDB", " url1", "URLTwo", "l3", " urlDB", "l1", "f3", "URL1", "f1", "path2", "url3"], "stream": ["flow", "video", "field", "in", "wave", "fr", "feed", "temp", "raw", "impl", "view", "coll", "form", "w", "forward", "input", "transform", "ff", "channel", "src", "http", "stack", "output", "slice", "writer", "string", "driver", "flash", "ack", "fd", "path", "handler", "source", "io", "steam", "v", "row", "response", "loop", "client", "context", "loader", "socket", "ssl", "live", "server", "file", "roll", "sl", "reader", "thread", "pipe", "sw", "Stream", "host", "f", "draft"], "Fdel": ["fdestroy", "FiDel", "ffin", "Fdestroy", "fdel", " Fdelete", "fdelete", "Ffin", " FDel", "fDel", " Ffin", "Fidelete", "Fifin", "Fdelete", " Fdestroy", "FDel", "Fidestroy", "Fidel"], "outstream": ["outputstream", " outStream", "inreader", "outlog", "outchannel", "outputmodel", "inwriter", "inputlog", "outreader", "outputwriter", "Outform", " outreader", "Outstream", "outputchannel", "inputchannel", "inputstream", "inStream", "outmodel", " outwriter", "inputStream", "outputreader", "OutStream", "outwriter", " outfile", "inlog", "outputform", "outStream", "inmodel", "outform", "outfile", "outputlog", "outputfile", "outputStream", "instream", " outmodel", "inchannel", " outform", "Outfile"], "bwriter": ["bwriters", " breader", " bbuilder", "bbWriter", "Bwrite", "bbwrite", "Breader", "outreader", "bbwriter", "fwriter", "bbwr", "bbreader", " bwriting", "Bwriter", "bwriting", " bwrite", "outwriter", "freader", " bWriter", "bbwriting", "bwrite", "fbwrite", "bbuilder", " bwr", " bwriters", "fbWriter", "outwr", "outwriting", "bbwriters", "bWriter", "fbwriter", "fbwriters", "bwr", "fbuilder", "breader", "fwrite", "Bbuilder"], "binput": ["outstart", " binpos", "bytestop", "binpos", " binset", "biwrite", "winstart", "biset", " binstart", "bistop", "binset", "winput", "bitset", "bitwrite", "binaryset", "output", "binarylog", "sincut", "byteput", "bipos", "outwrite", "byteset", "binsplit", "libcut", "biput", "libset", "winsell", "binwrite", "bisplit", "sinput", "libput", "sinlog", "binstart", "bincut", "binlog", "binaryput", " binsell", "binsell", " binstop", "bytesplit", "outsell", " binwrite", "binarycut", " binsplit", "sinset", "liblog", "winwrite", "bitput", "binstop", "bitpos"], "len": ["enc", "lc", "num", "base", "end", "coll", "fun", "val", "lf", "pre", "lan", "ls", "count", "rev", "lon", "l", "bin", "label", "ann", "cap", "pos", "hl", "li", "split", "fl", "en", "ie", "line", "part", "Len", "lim", "elt", "le", "length", "size", "la", "ln", "data", "lt", "low", "id", "limit", "el", "sl", " lang", "n", "iter", "seq", "dl", "fin", "lin"]}}
{"id1": "16388708", "id2": "4618237", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFileToStream", "decodeStringToString", "decodeFileAsFiles", "decodeFileAsStream", "decodeString2Files", "decodeStringToFiles", "decodeFile2String", "decodeFile2File", "decodeFileAsString", "decodeStringToFile", "decodeFile2Files", "decodeFileFromFiles", "decodeFileFromFile", "decodeFileFromStream", "decodeFile2Stream", "decodeString2File", "decodeFileToFiles", "decodeStringToStream", "decodeFileToString", "decodeFileAsFile", "decodeString2String", "decodeString2Stream"], "infile": [" infilename", "infiles", "inputfile", "outfiles", "inFile", "InFile", " instream", "minstream", "Instream", "inputfilename", "inbase", " infiles", " infp", " inFile", "minbase", "minFile", "minfile", "outfilename", "outfp", "instream", "inputfiles", "infp", "Inbase", "inputfp", "infilename", " inbase", "Infile"], "outfile": ["outputdatabase", "outFile", "inputfile", " outFile", "outpath", "outputfilename", "inFile", " outpath", "inputdatabase", " outfilename", "outdatabase", "outfolder", "outputfolder", "outputpath", "inputpath", "inputFile", " outfolder", "infolder", "outfilename", " outdatabase", "outputfile", "infilename", "outputFile"], "in": ["re", "err", "ini", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "lin", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "m", "din", "socket", "inc", "s"], "out": ["ou", "err", "log", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "obj", "channel", "In", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "pass", "outs", "work", "job", "line", "io", "Out", "client", "off", "name", "co", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "channel", "count", "cache", "slice", "queue", "b", "bytes", "bin", "bb", "null", "buf", "buff", "border", "padding", "split", "uffer", "type", "result", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "r", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "method", "model", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "open", "better", "message", "growth", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "positive", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "21995302", "id2": "19912848", "code1": "        public void open(Input input) throws IOException, ResolverException {\n            if (!input.isUriDefinitive()) return;\n            URI uri;\n            try {\n                uri = new URI(input.getUri());\n            } catch (URISyntaxException e) {\n                throw new ResolverException(e);\n            }\n            if (!uri.isAbsolute()) throw new ResolverException(\"cannot open relative URI: \" + uri);\n            URL url = new URL(uri.toASCIIString());\n            input.setByteStream(url.openStream());\n        }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"open": ["re", "ize", "o", "resource", "create", "change", " Open", "end", "stream", "fix", "to", " opening", "write", "parse", "load", "add", "process", "use", "un", "update", "set", "initial", " start", "en", "it", "build", " close", "opening", "handle", "xml", "start", "close", "oc", "init", " opener", " opened", " reopen", "get", " OPEN", "res", " transfer", "Open"], "input": ["image", "argument", "base", "in", "resource", "feed", "temp", "this", "stream", "event", "inner", "form", "inf", "ink", "audio", "current", "Input", "accept", "text", "http", "output", "object", "class", "element", "buffer", "state", "type", "upload", "io", "container", "out", "pull", "command", "client", "context", "ssl", "request", "keep", "PUT", "data", "file", "document", "instance", "error", "reader", "i", "connection", "config", "source", "exec", "socket", "inc"], "uri": ["origin", "image", "mi", "base", "service", "resource", "prefix", "directory", " URI", "iri", "direction", "cli", "picture", "http", "bridge", "api", "info", "ui", "object", "uid", "via", "string", "ri", "definition", "element", "pi", "gi", "state", "route", "next", "path", "li", "abi", "ci", "uni", "result", "si", "io", "eni", "adi", "ki", "response", "doi", "URI", "manager", "verb", "qi", "id", "data", "document", "file", "absolute", "username", "instance", "str", "i", "database", "di", "connection", "source", "address"], "url": ["link", "URL", "base", "resource", "feed", "impl", "stream", "coll", "Url", "ball", "ls", "channel", "ref", "http", "text", "l", "api", "b", "string", "bel", "buffer", "state", "path", "li", "io", "plug", "layer", "socket", "ssl", "server", "id", "file", "data", "ob", "char", "browser", "sl", "i", "connection", "config", "source", "f", "address"]}}
{"id1": "18544890", "id2": "7911686", "code1": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"get": ["gets", "resource", "create", "send", "end", "debug", "download", "json", "match", "find", "load", "cache", "remote", "list", "info", "update", "show", "next", "query", "GET", "pull", "start", "Get", "data", "call", "select"], "url": ["image", "rule", "URL", "base", "email", "resource", "feed", "www", "service", "download", "Url", "ls", "http", "key", "queue", "l", "href", "page", "string", "route", "path", "source", "uri", "layer", "ur", "name", "location", "ssl", "server", "id", "file", "ll", "str", "sl", "date", "connection", "loc", "host", "f", "address"], "lat": ["base", "late", "height", "offset", "point", "tile", "game", "bot", "at", "Lat", "local", "play", "l", "home", "pos", "route", "grid", "width", "gal", "out", "league", "length", "la", "distance", "las", "live", "street", "range", "data", "alt", "port", "id", "west", "loc", "location", "address"], "lon": ["log", "base", "depth", "offset", "nl", "fat", "val", "lan", "l", "vel", "left", "pos", "online", "position", "lb", "lang", "width", "len", "number", "layer", "length", "off", "la", "ino", "live", "ln", "on", "lag", "range", "level", "land", "ng", "loc", "location", "lin"], "count": ["log", "num", "batch", "force", "pool", "index", "base", "depth", "offset", "found", "val", "age", "load", "cache", "total", "list", "code", "c", "more", "type", "part", "len", "all", "number", "length", "size", "name", "sum", "id", "file", "follow", "limit", "level", "error", "Count", "amount", "n", "timeout", "time", "scroll", "f"], "req": ["q", "rx", "temp", "ref", "respond", "cb", "c", "cf", "grad", "wx", "next", "ok", "query", "sem", "p", "ur", "fit", "hr", "test", "call", "rb", "pkg", "f", "cmd", "fr", "check", "cur", "cache", "conn", "ctr", "r", "resp", "io", "build", "pull", "bur", "server", "reg", "loc", "requ", "err", "serv", "form", "fe", "worker", "exp", "jp", "post", "pr", "wa", "fb", "rob", "Request", "https", "rr", "client", "sq", "orb", "pub", "ext", "request", "qt", "cp", "fin", "exec", "conf", "socket", "ver", "download", "rt", "http", "rf", "def", "gr", "tr", "work", "require", "fail", "org", "plug", "proc", "dq", "res", "ctx", "ru", "cook"], "gl": ["lc", "lol", "ga", "gre", "fr", "nl", "view", "coll", "global", "ul", "bl", "cl", "fe", "berg", "Gl", "ang", "ger", "l", "gall", "list", "gg", "GL", "rg", "gb", "gold", "bel", "hl", "g", "groups", "gi", "ogl", "pl", "fl", "ml", "gel", "lim", "gal", "img", "il", "fx", "cm", "las", "sel", "bs", "ll", "cal", "gn", "browser", "go", "sl", "rl", "el", "bg", "console", "loc", "gm"], "br": ["body", "err", "dr", "lr", "fr", "stream", "bl", "arr", "ler", "yr", "bridge", "ch", "b", "ctr", "pr", "buf", "sp", "r", "ber", "gr", "tr", "bro", "div", "io", "result", "Br", "BR", "mr", "img", "hr", "bar", "sr", "brush", "browser", "str", "reader", "rb", "res", "bc", "bh", "ar", "cr"], "line": ["look", "rule", "link", "log", "letter", "base", "lc", "cle", "fr", "unit", "end", "nl", "lf", "bl", "cl", "lines", "inline", "entry", "LINE", "text", "ne", "Line", "sync", "key", "l", "page", "ine", "string", "style", "code", "pos", "pe", "row", "le", "block", "name", "ino", "word", "sel", "ge", "co", "live", "data", "file", "lo", "cell", "e", "char", "jo", "str", "el", "sl", "comment", "source", "lin"]}}
{"id1": "20991673", "id2": "15904772", "code1": "    public NodeId generateTopicId(String topicName) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"No SHA support!\");\n        }\n        if (m_ready) System.out.println(\"Scribe is ready at\" + getNodeId() + \" , topic is \" + topicName);\n        md.update(topicName.getBytes());\n        byte[] digest = md.digest();\n        NodeId newId = new NodeId(digest);\n        return newId;\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 1, "substitutes": {"generateTopicId": ["generateTopicID", "generatetopicId", "generateTopicInfo", "generatedTopicID", "generatedtopicName", "generateTopicName", "generateTopicsId", "generateTopicsInfo", "generatedtopicInfo", "generatetopicID", "generatetopicInfo", "generatedTopicName", "generatedTopicInfo", "generateTopicsName", "generatedtopicID", "generatetopicName", "generatedTopicId", "generatedtopicId", "generateTopicsID"], "topicName": ["TopicKey", "subjectId", " topicId", "TopicName", "channelKey", "TopicInfo", "topicType", " topicPath", " topicKey", "Topicname", "topicKey", "topicId", "topId", "topName", " topicNames", "TopicNames", "channelId", "TopicId", "topicname", "channelType", "channelName", "subjectName", "subjectType", " topicname", "channelPath", " topicType", " topicInfo", "topname", "topNames", "subjectPath", "topicNames", "topicInfo", "topicPath", "channelInfo"], "md": ["dd", "sha", "cmd", "dr", "meta", "ud", "dc", "am", "dig", "metadata", "ma", "amd", " MD", "po", "hd", "mm", "mo", "ms", "ld", "mp", "vd", "km", "hash", "d", "mand", "bd", "ad", "pm", "df", "sm", "mg", "mac", "mt", "gd", "od", "editor", "cm", "MD", "Cmd", "id", "dh", "pd", "mag", "rm", "dm", "mc", "pkg", "mb", "m"], "digest": ["dighed", "mdested", "dhed", "Diggest", "diggest", "DigEST", "mdest", " diggest", " dighed", "signEST", "digester", "Digests", "cdEST", "dester", "decest", "mdhed", "signests", "Digester", "decEST", "dest", "digests", "mdester", "signest", "cdgest", "digested", "digEST", " digEST", "dested", " digested", "decests", "cdest", "Digest", "cdester", " digester"], "newId": ["nextid", "NewId", " newID", "Newid", "nextId", " newid", "NewInfo", " newInfo", "newInfo", "nextID", "newID", "NewID", "nextInfo", "newid"]}}
{"id1": "4599372", "id2": "21656668", "code1": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readFixString": ["readAdjustArray", "createFixedstring", "readfixContent", "readFixedString", "readfixstring", "readFixContent", "readFixedstring", "createFixArray", "createFixString", "createFixContent", "createFixedContent", "readfixString", "readFixedContent", "createFixstring", "readAdjustContent", "readAdjustString", "createFixedString", "readFixArray", "readAdjuststring", "readFixedArray", "createFixedArray", "readfixArray", "readFixstring"], "len": ["enc", "body", "lc", "base", "lit", "val", "lf", "count", "l", "list", "lp", "string", "code", "pos", "split", "li", "en", "line", "part", "Len", "le", "length", "size", "ln", "lt", "ll", "fn", "file", "e", "limit", "data", "str", "el", "i", "sl", "n", "loc", "f", "lin"], "sw": ["aw", "wb", "serv", "SW", "stream", "w", "sa", "WS", "fw", "zip", "wh", "writer", "ow", "bb", "ws", "null", "ew", "so", "sp", "wt", "wp", "wa", "sn", "wr", "wx", "iw", "sc", "fl", "io", "sb", "nw", "sh", "sv", "tw", "es", "ww", "sr", "lv", " SW", "wra", "sf", "Sw", "ss", "sl", "hw", "rw"]}}
{"id1": "14794404", "id2": "10391753", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["EncipherSecret", "encressSecret", "encipherString", "EncryptPassword", "encresspassword", "EncryptSecret", "encryptedpassword", "encressString", "encipherpassword", "EncipherPassword", "encryptedString", "encryptedSecret", "encressPassword", "encryptpassword", "encipherPassword", "encryptSecret", "encipherSecret", "encryptString", "Encryptpassword", "Encipherpassword", "EncryptString", "EncipherString"], "password": ["enc", "Password", "resource", "email", "prefix", "content", "input", " passwords", "pattern", "channel", "text", "message", "cache", "wd", "object", "device", "string", "definition", "array", "params", "buffer", "pass", "crypt", "token", "path", "padding", "phrase", "p", "attribute", "secret", "name", "PASS", "word", "data", "username", "sword", "description", "database", "words", "connection", "address"], "encryptedPassword": ["protectedString", "encryptedCode", "lockedString", " encryptedString", "protectedPass", " encryptedpassword", "encryptedPass", "lockedpassword", "encryptedpassword", "protectedCode", "protectedpassword", "ryptedString", "protectedPassword", "ryptedCode", "encryptedString", " encryptedPass", "ryptedpassword", "lockedPassword", "ryptedPass", "ryptedPassword", "lockedPass", " encryptedCode"], "md5": ["MD4", "digdown", "md6", "MD512", "MD5", " md6", "md512", " MD2", "MD45", " md512", "dig45", "md2", "md4", "mddown", " md2", " MD512", "MD6", "dig2", " MD5", "MDdown", "dig4", " md3", "amd4", " md4", "MD2", "MD3", "amd6", "dig3", "dig5", "amd2", " MD3", " mddown", "md45", " md45", "amd5", "md3"], "digest": ["digher", "Digher", "mdested", "Digenge", "digment", "digash", "mdests", "mdest", "mdash", " digher", "mdace", "encester", "digester", "Digests", "mdher", " digash", " digests", "signests", "Digester", " digment", "digenge", " digenge", " digace", "digests", "Digested", "Digace", "mdester", "mdenge", "encest", "signest", "signester", "digace", "encash", "digested", "signested", "Digest", " digester", "mdment", "encment"], "i": ["index", "j", "o", "oi", "hi", "phi", "ii", "ix", "l", "b", "ui", "ri", "pi", "c", "r", "gi", "t", "d", "li", "k", "ci", "p", "ie", "multi", "si", "io", "xi", "bi", "I", "v", "x", "ai", "it", "uri", "ip", "length", "ti", "h", "id", "qi", "e", "u", "di", "f", "zi", "s"], "hex": ["enc", "coord", "letter", "num", "temp", "prefix", "closure", "lit", "check", "mix", "none", "bits", "stick", "ix", "pattern", "serial", "oct", "alpha", "exp", "text", "zip", "bit", "sex", "slice", "bin", "pex", "utf", "ctr", "string", "hash", "null", "buff", "shift", "rh", "comp", "sign", "ip", "pixel", "length", "pack", "digit", "ext", "rex", "data", "id", "nexus", "binary", "char", "str", "ex", "di"]}}
{"id1": "11716816", "id2": "21824901", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"updateFile": ["upFile", "copyFolder", "upDirectory", "importFile", "updateDirectory", "updateBody", "updateFolder", "importBody", "copyBody", "upBody", "copyFile", "copyDirectory", "upFolder", "importDirectory", "importFolder"], "file": ["File", "image", "log", "model", "base", "resource", "this", "current", "content", "input", "up", "load", "cache", "http", "zip", "local", "filename", "queue", "l", "b", "info", "full", "object", "url", "class", "future", "files", "pe", "path", "handler", "db", "single", "type", "part", "line", "io", "fp", "dir", "FILE", "name", "socket", "data", "e", "lock", "get", "connection", "source", "parent", "f"], "IOException": ["TimeoutProblem", "Downloadception", "IOProblem", " IOProblem", "DownloadProblem", "IOception", "TimeoutException", "Timeoutception", "DownloadException", " IOception"], "destFile": [" destFull", " destinationDir", "flatFiles", "DestFile", " destinationFiles", "sourceDir", " destinationFile", "DestFull", "destroyTable", "srcFiles", "sourceFolder", "destFolder", "DestPath", "origfile", "origTable", "destDir", "destfile", " destFiles", "destTable", "destroyfile", " destfile", "origDir", "destroyDir", "DestFiles", "destFull", "flatFile", " destPath", "sourceFile", "srcPath", "flatDir", " destDir", " destTable", "destroyFile", "destFiles", "origFile", "DestDir", "destPath", "srcFile", " destFolder", "Destfile", "flatfile", "srcFolder", "DestFolder", "sourceFiles", " destinationFull"], "in": ["ini", "image", "err", "re", "login", "this", "inner", "inn", "gin", "input", "with", "cl", "In", "up", "sync", "l", "bin", "b", "conn", "c", "pin", "IN", "r", "cf", "again", "pass", "work", "p", "source", "nin", "io", "cin", "min", "pull", "client", "ins", "as", "init", "a", "ac", "inside", "con", "id", "ax", "isin", "on", "lock", "el", "i", "win", "reader", "connection", "din", "f", "socket", "inc", "s"], "out": ["ou", "err", "o", "outer", "resource", "of", "login", "point", "this", "to", "outside", "w", "at", "net", "channel", "obj", "up", "In", "exp", "sync", "output", "OUT", "password", "bin", "b", "conn", "extra", "writer", "url", "option", "c", "again", "pass", "outs", "nin", "io", "Out", "client", "cookie", "off", "name", "ext", "co", "user", "call", "no", "ex", "i", "timeout", "n", "lib", "connection", "inc", "exec", "socket"]}}
{"id1": "4618237", "id2": "13657103", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"writeFileToFile": ["writeFile2Files", "writeFile2File", "writeFilesToFiles", "writeFileAndFiles", "writeFileAsFiles", "writeFileAsFile", "writeFileAsChannel", "writeFile2Channel", "writeFileAndChannel", "writeFilesToStream", "writeFilesAsChannel", "writeFilesAsStream", "writeFileToStream", "writeFilesAsFile", "writeFilesToFile", "writeFile2Stream", "writeFilesAsFiles", "writeFileAsStream", "writeFileToChannel", "writeFileToFiles", "writeFileAndStream", "writeFileAndFile", "writeFilesToChannel"], "fin": ["ini", "pins", "kin", "fr", "fa", "fat", "inn", "inf", "arin", "fm", "FIN", "fen", "fi", "rt", "Fin", "conn", "raf", "rf", "pin", "nir", "fd", "fine", "en", "ris", "inv", "fp", "init", "ori", "thin", "ln", "rin", "file", "fn", "include", "din", "f", "lin"], "fout": ["boff", "bOut", "fOut", "rfout", "Fin", "bin", "rfin", " fOut", "rfOut", "Foff", " fint", "Fint", " foff", "Fout", "foff", "fint", "bout", "FOut", "rfint"], "append": ["enc", "send", "printf", "end", "flush", "adjust", "optional", "open", "except", "text", "add", "want", "atten", "password", "leaf", "pad", "string", "null", "update", "future", "apply", "protect", "push", "padding", "remove", "fail", "flat", "ending", "only", "app", "pack", "ext", "pend", "ended", "vert", "opp", "spread", "batch", "save"], "inChannel": ["inConnection", "outchannel", "loginStream", "inChan", "inStream", "innStream", " inchannel", "inputStream", "InChan", "INStream", "inputChannel", "innChannel", "loginChannel", "inQueue", "loginchannel", "inputConnection", "innerStream", "outChan", "innerChannel", "INQueue", " inQueue", "inputChan", "INchannel", " inStream", "INConnection", "innerConnection", "outStream", "Inchannel", "InStream", "INChan", "outQueue", "innerChan", "InChannel", "innchannel", "INChannel", "inchannel", "innerchannel"], "outChannel": ["outContext", "outchannel", "ioChannel", "externalChannel", "outputchannel", "externalchannel", "ioStream", "inChan", "inStream", " outchannel", "OutStream", "Outchannel", "inContext", "outputChan", "ioChan", "outChan", "iochannel", "externalChan", " outContext", "outputSocket", "outputChannel", " outChan", "outStream", "outSocket", "OutChannel", "externalSocket", "OutContext", "inSocket", "inchannel", "OutChan"]}}
{"id1": "19549489", "id2": "23611770", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"copy": ["create", "clone", " copies", "download", "write", " copying", " copied", " Copy", "paste", "cop", "zip", "Transfer", "sync", " move", "Cop", "split", "p", "upload", "io", "all", "Copy", "file", "transfer", "move", "delete", "source", " transfer"], "sourceFile": ["resourceFile", "sourceDirectory", "searchfile", "SourceFILE", "resourceFiles", "searchFile", "resourcefile", "sourceFilename", "serviceFile", " sourcefile", "SourceDirectory", " sourceFiles", "serviceFilename", "siteFILE", "siteDirectory", "sourceFILE", "searchFilename", "SourceFile", "sourcefile", "resourceDirectory", "Sourcefile", "sourceFiles", "serviceFiles", " sourceFILE", "siteFiles", "servicefile", "siteFile", " sourceFilename", "SourceFiles", "searchFiles", " sourceDirectory"], "destinationFile": ["distinationFiles", "distinationFile", "DestinationFile", "DestinationFiles", "destinationImage", "destinatedDirectory", "destinatedFiles", "destationDirectory", "Destinationfile", "destationFiles", "destinatorDirectory", "destinatorfile", "distinatedFiles", "destinatedImage", "distinatedFile", "distinationDirectory", "DestinatorFiles", "DestinatorFile", "distinatedDirectory", "destationFile", "distinatedImage", "destinatorFile", "destinatedDir", "DestinatorDir", "destationImage", "destinatorDir", "destinatorImage", "destinatedfile", "destinationDir", "distinationImage", "destinationfile", "destationfile", "destinationDirectory", "destinatorFiles", "DestinationDir", "Destinatorfile", "destinationFiles", "destinatedFile", "destationDir"], "sourceFileChannel": ["sourceStreamStream", " sourceFileContext", "sourceDirStream", "sourceLibraryChannel", "sourceLibrarySocket", "sourceStreamChan", "sourceStreamChannel", "sourceFilesService", "targetLibraryChan", "ourceFilechannel", "sourceFileClient", "targetFileChannel", " sourceFileService", "sourceFileConnection", " sourceFilesConnection", "sourceFileSocket", "sourceStreamConnection", "ourceStreamchannel", "sourceDirectoryChannel", "ourceFileStream", "sourceFunctionChannel", "sourceLineClient", "sourceFileChan", "sourceDirChan", "sourceLineChan", "sourceFunctionService", "sourceFilesChannel", "sourceStreamchannel", "sourceFileService", "ourceFileChannel", "sourceLineStream", "sourceFileContext", "targetLibraryChannel", "sourceLibraryClient", "targetFileSocket", " sourceFilesChannel", "sourceLineChannel", "targetFileChan", " sourceFilesService", "ourceStreamChan", "sourceDirectoryClient", "sourceFilesContext", "sourceStreamContext", "sourceFunctionConnection", " sourceFilesContext", "ourceStreamStream", "sourceLinechannel", "targetFileClient", "sourceLineSocket", "targetLibrarySocket", "sourceDirectoryChan", "sourceLibraryChan", "sourceStreamService", "targetLibraryClient", "ourceFileChan", "sourceDirchannel", "sourceFilesConnection", " sourceFileConnection", "ourceStreamChannel", "sourceFileStream", "sourceDirChannel", "sourceFunctionContext", "sourceDirectorySocket", "sourceFilechannel"], "destinationFileChannel": ["destinationFileService", "destinationFileHandler", "destinatorFileChan", "destinationDirectoryHandler", "destinatorFilesChannel", "destinationFilesCache", "destinatorFileCache", "destinationDirectoryClient", "destinatorFileClient", "destinatorFilesCache", "destinatorFileHandler", "destinationDirectoryChannel", "destinationFilesConnection", "destinationLineChannel", "destinationLineHandler", "destinatorFileConnection", "destinationDirectoryConnection", "destinationLineChan", "destinationFileConnection", "destinationFileChan", "destinationFileCache", "destinatorFileChannel", "destinationFilesService", "destinationDirectoryCache", "destinationFileClient", "destinationFilesClient", "destinationIOService", "destinationDirectoryService", "destinationLineConnection", "destinationFilesHandler", "destinatorFilesChan", "destinationIOClient", "destinatorFilesHandler", "destinationFilesChannel", "destinationDirectoryChan", "destinatorFileService", "destinationIOChannel", "destinationLineClient", "destinationLineService", "destinationFilesChan", "destinatorFilesService", "destinatorFilesConnection", "destinationIOCache", "destinatorFilesClient"]}}
{"id1": "4686922", "id2": "9687813", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"extractResourceToFile": ["extractResourceAsFile", "extractResourcesAsFile", "extractResourcesToFiles", "extractResourcesAsfile", "extractResourceInFile", "extractResourcesAsResource", "extractResourceInResource", "extractResourceAndFiles", "extractResourcesToResource", "extractResourceToResource", "extractResourceInFiles", "extractResourceAsResource", "extractResourcesTofile", "extractResourcesToFile", "extractResourceAndResource", "extractResourceAsFiles", "extractResourcesAsFiles", "extractResourceAndfile", "extractResourceAsfile", "extractResourceAndFile", "extractResourceTofile", "extractResourceInfile", "extractResourceToFiles"], "resourcePath": ["stringPath", "sourceUrl", " resourceFolder", "resourcepath", "stringpath", "stringFolder", "ResourceId", "ResourceUrl", "sourcePath", " resourcepath", "ResourcePath", "sourceId", "servicePath", "Resourcepath", " resourceId", "servicepath", "resourceUrl", "resourceFolder", " resourceUrl", "serviceFolder", "resourceId", "sourcepath"], "dest": ["resources", "folder", "wb", "die", " destination", "resource", "de", "temp", "config", "done", "content", " Dest", "trans", "target", "src", "filename", "output", "later", "sup", "home", "comb", "txt", "class", "contract", "dist", "store", "route", "path", "result", "flat", "prop", "img", "sac", "tmp", "Dest", "data", "file", "const", "transfer", "desc", "default", "destroy", "source", "project"], "in": ["ini", "re", "image", "kin", "resource", "login", "this", "gin", "inner", "inn", "arin", "input", "In", "up", "rec", "bin", "b", "conn", "url", "c", "r", "IN", "again", "pass", "plus", "source", "nin", "cin", "sin", "ins", "is", "as", "lin", "init", "inside", "thin", "con", "id", "file", "rin", "isin", "i", "win", "reader", "n", "connection", "like", "din", "f", "socket", "inc"], "out": ["err", "image", "o", "temp", "outer", "this", "outside", "w", "In", "net", "at", "up", "cache", "sync", "output", "OUT", "bin", "conn", "b", "writer", "auto", "null", "again", "norm", "outs", "boot", "source", "io", "all", "Out", "client", "ins", "cookie", "cos", "off", "app", "socket", "ext", "a", "co", "server", "user", "file", "ax", "parent", "ex", "i", "one", "n", "lib", "inc", "exec", "f", "obj", "copy", "s"]}}
{"id1": "7981642", "id2": "21488518", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"update": ["register", "setup", "address", "create", "change", "send", "login", "end", "check", "write", "edit", "up", "text", "UPDATE", "add", "key", "replace", "password", "post", "set", "updated", "apply", "Update", "push", "build", "and", "insert", "sign", "auth", "init", "sum", "h", "user", "data", "put", "append", "u", "delete", "config", "exec", "url", "copy", "save"], "mail": ["folder", "model", "html", "login", "office", "who", "Email", "view", "ul", "phone", "group", "text", "message", "zip", "local", "password", "label", "string", "mails", "front", "m", "hello", "gmail", "source", "company", "uri", "gal", "ip", "dir", "xml", "name", "proxy", "dial", "ge", "server", "user", "file", "id", "alt", "username", "lock", "value", "Mail", "date", "contact", "fax", "old", "msg", "host", "md", "url", "address"], "email": ["folder", "log", "model", "login", "inet", "office", "Email", "phone", "text", "message", "zip", "nick", "password", "info", "wd", "home", "class", "element", "online", "mails", "ail", "cdn", "li", "note", "en", "gmail", "line", "hello", "uri", "addr", "dir", "ip", "xml", "eu", "name", "archive", "cn", "server", "id", "file", "alt", "dn", "username", "description", "el", "Mail", "old", "fax", "n", "enter", "host", "md", "url", "address"], "pwd": ["Pwt", "Pws", " pws", "ppwh", "Ppass", "pwa", "cpws", "pWD", "Pwa", "cpWD", "pppassword", "Pwh", "Ppassword", "pws", "ppass", "PWD", "ppassword", "hpass", "pwh", "pwt", "hwa", " pwh", " pwa", "hWD", "Pwd", "pppass", "cpwt", " pWD", " pwt", "hwd", "ppwd", " ppass", " ppassword", "cpwd"], "firstname": [" firstkey", "hostName", "hostkey", " firstemail", "lastkey", "firstemail", " firstnames", "firstuser", "caseName", "caseemail", " firstuser", " firstpass", "casename", "hostname", "hostemail", " firstName", "firstName", "newname", "newnames", "casepass", "lastnames", "firstkey", "lastpass", "firstnames", "lastemail", "newuser", "firstpass", "lastuser", "lastName"], "lastname": ["fulln", "lastaddress", "firstday", " lastnames", "secondkey", " lastaddress", " lastkey", "lastkey", "lastday", "firstn", " lastn", "fullnames", "lastn", "fullname", " lastday", "firstName", "lastnames", " lastName", "secondName", "firstkey", "secondaddress", "fullName", "firstnames", "fullday", "firstaddress", "secondname", "lastName"], "connection": ["lc", "index", "graph", "pool", "system", "ion", "this", "function", "nc", "Connection", "ca", "b", "conn", "object", "connected", "management", "application", "c", "cf", "condition", "session", "creator", "relation", "di", "m", "handler", "sc", "response", "client", "cc", "context", "manager", "communication", "con", "h", "server", "document", " Connection", "connect", "Conn", "database", "bc", "config", "db", "directory"], "attrs": ["Attps", " attRS", "Attrs", "atributes", "atars", " attars", " attr", "addras", " attRs", "AttRs", "addks", "matars", "attRS", "addps", "addrs", " attributes", "atacts", "attars", "Attr", "attks", "Attras", "addars", "attributes", "addRs", "attacts", "addr", "attr", "matrs", " attks", "Attars", "atRS", "atr", "attps", " attacts", "atps", "atks", "attRs", "Attacts", "attras", " attps", "addributes", "matps", "atrs", "matributes", "addRS", "Attributes", "atras"], "sha": ["ka", "base", "ga", "lambda", "ema", "ya", "hi", "alias", "ma", "eta", "sa", "mm", "alpha", "ua", "ca", "sche", "shi", "password", "asha", "ami", "SHA", "da", "pi", "wa", "pa", "pg", "si", " SHA", "sh", "sm", "mac", "va", "na", "la", "sum", "a", "volume", "h", "ha", "meta", "acl", "md", "HA"], "digest": ["tagcode", "mdested", "mdgest", "Diggest", "Diged", "diggest", "moded", "DigEST", "tagest", " diggest", "mdest", " digcode", "digester", "Digests", "modest", " digests", "digcode", "Digester", "tagester", "tagested", "modEST", "diged", "digests", "Digested", "Digcode", "mdester", "modests", "digested", "digEST", " digEST", " digested", "Digest", " diged", " digester"], "hash": ["enc", "body", "her", "base", "image", "html", "raw", "hex", "dig", "ag", "json", "match", "version", "message", "key", "password", "bin", "code", "array", "kh", "build", "sh", "rh", "mac", "secret", "block", "ash", "auth", "Hash", "sum", "hed", "h", "ha", "user", "value", "bh", "url", "cover"], "ctx": ["lc", "conv", " context", "cci", "cl", "pc", "ctrl", "anc", "fw", "ca", "cu", " conn", "conn", "cb", " rc", "jp", "c", "cf", "vc", "ct", "rc", " cx", "ci", "ck", "sc", "cmp", "cs", "xc", "client", "cc", "cas", "context", "sq", " cs", " c", "cm", "cp", "tc", "loc", "cn", "cv", "cca", "Context", "qa", "hw", "mc", "tx", "pkg", "bc", "config", "cr"], "newName": ["newEmail", "Newname", "oldAddress", "oldname", " newEmail", "newAddress", " newAddress", "NewName", "NewAddress", "oldEmail", "newname", "NewEmail", " newname"], "oldName": ["OldHome", "newAddress", " oldPath", "oldEmail", "origPath", "OldName", "origName", "origname", "OldAddress", "Oldname", "OldPath", "oldAddress", "oldname", " oldname", "newHome", " oldAddress", "oldPath", "oldHome", "OldEmail", "newEmail", " oldHome", "origEmail", " oldEmail"]}}
{"id1": "20190303", "id2": "838844", "code1": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"test01_ok_failed_500_no_logo": ["test01_ok_failed_500_no__log", "test01_ok_failed_500_no1blog", "test01_ok_failed_500_no__ban", "test01_ok_failed_500_NO__log", "test01_ok_failed_500_NO_blog", "test01_ok_failed_500_no_Log", "test01_ok_failed_500_NO_log", "test01_ok_failed_500_NO__ban", "test01_ok_failed_500_no1log", "test01_ok_failed_500_NO__blog", "test01_ok_failed_500_no1ban", "test01_ok_failed_500_no_log", "test01_ok_failed_500_no__Log", "test01_ok_failed_500_NO_ban", "test01_ok_failed_500_NO__Log", "test01_ok_failed_500_no_blog", "test01_ok_failed_500_no1Log", "test01_ok_failed_500_no_ban", "test01_ok_failed_500_NO_Log", "test01_ok_failed_500_no__blog"], "client": ["method", "force", "pool", "service", "resource", "child", "this", "self", "Client", "cli", "channel", "http", "cache", "api", "conn", "class", "c", "session", "handler", "p", "https", "uri", "console", "secure", "manager", "app", "socket", "ssl", "request", "proxy", "tc", "con", "server", "host", "port", "call", "php", "connect", "instance", "per", "wait", "connection", "config", "web", "plugin", "url"], "post": ["method", "feed", "submit", "end", "posts", "self", "to", "pre", "patch", "head", "entry", "http", "load", "zip", "process", "api", "object", "after", "builder", "code", "set", "apply", "POST", "pass", "next", "success", "upload", "build", "test", "request", "proxy", "server", "port", "call", "php", "pod", "Post", "project", "f", "copy"], "response": ["body", "onse", "method", "model", "pool", "index", "resource", "service", "feed", "site", "view", "Response", "respons", "json", "http", "message", "output", "api", "respond", "object", "page", "status", "application", "resp", "throw", "next", "success", "successful", "result", "report", "request", "server", "data", "document", "error", "connection", "reply"]}}
{"id1": "3409084", "id2": "7166270", "code1": "    protected String getRequestContent(String urlText) throws Exception {\n        URL url = new URL(urlText);\n        HttpURLConnection urlcon = (HttpURLConnection) url.openConnection();\n        urlcon.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream()));\n        String line = reader.readLine();\n        reader.close();\n        urlcon.disconnect();\n        return line;\n    }\n", "code2": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "label": 0, "substitutes": {"getRequestContent": ["getResponseString", "getHttpString", "getrequestContent", "readResponseBody", "readRequestString", "getResponseContent", "getRequestText", "getrequestText", "getResponseBody", "readResponseContent", "getHttpContent", "getHttpBody", "getRequestString", "getrequestString", "getResponseText", "getHttpText", "readRequestBody", "readResponseString", "getRequestBody", "getrequestBody", "readRequestText", "readRequestContent", "readResponseText"], "urlText": ["pageString", "resourceContent", "strTEXT", "pageText", "resourceTEXT", "urlString", "httpTEXT", "strtext", "resourcetext", "urlTEXT", " urltext", "urlContent", "urltext", " urlString", "strText", "httpString", "resourceText", "pageTEXT", "httpText", "strContent", " urlTEXT", " urlContent"], "url": ["image", "log", "URL", "base", "resource", "lr", "feed", "www", "this", "Url", "open", "ls", "http", "l", "b", "conn", "full", "object", "api", "page", "c", "r", "path", "fl", "uri", "build", "client", "blog", "ur", "ssl", "server", "user", "ll", "str", "sl", "rl", "bc", "or", "connection", "config", "host", "web", "f"], "urlcon": ["urlconn", "Urlclient", "urrun", "urlconnect", "Urlfc", "webcon", "urlclient", "urlconst", "webconnect", "httpfc", "httprun", "urconn", "urcon", "urlann", " urlconst", " urlenc", "httpconnect", "httpCon", "urlfc", " urlconnect", "httpenc", "webCon", "webenc", " urlrun", "UrlCon", "Urlcon", "httpann", "URLfc", " urlann", " urlCon", "httpclient", "urlCon", "urlenc", " urlconn", "httpcon", "webconn", "httpconn", "URLcon", "webann", "URLclient", "httpconst", "urconst", "urlrun", "URLCon"], "reader": ["her", "in", "rx", "car", "stream", "rer", "inner", "ker", "input", "worker", "reading", "ler", "rar", "parser", "bird", "writer", "finder", "read", "ri", "r", "buffer", "oder", "handler", "er", "io", "result", "rr", "row", "director", "layer", "ner", "loader", "cher", "data", "file", "ser", "Reader", "i", "per", "keeper", "iter", "or", "editor"], "line": ["body", "link", "log", "letter", "email", "feed", "end", "content", "val", "lines", "inline", "entry", "LINE", "text", "message", "Line", "page", "string", "code", "read", "element", "buffer", "pass", "row", "response", "block", "name", "data", "file", "user", "cell", "char", "str", "value", "lin"]}}
{"id1": "822452", "id2": "22875895", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private void readVersion() {\n        URL url = ClassLoader.getSystemResource(\"version\");\n        if (url == null) {\n            return;\n        }\n        BufferedReader reader = null;\n        String line = null;\n        try {\n            reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((line = reader.readLine()) != null) {\n                if (line.startsWith(\"Version=\")) {\n                    version = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Revision=\")) {\n                    revision = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Date=\")) {\n                    String sSec = (line.split(\"=\"))[1];\n                    Long lSec = Long.valueOf(sSec);\n                    compileDate = new Date(lSec);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndrewrites", "readAndRebwrite", "readandrewrite", "readAndSwwrite", "readAndRewwrite", "readAndSwrap", "readAndSwrite", "readandRewrite", "readAndrewrap", "readAndRewrap", "readAndRebrites", "readandrewwrite", "readAndRebrap", "readandRewrap", "readandRewrites", "readAndSwrites", "readandrewrites", "readAndrewrite", "readAndrewwrite", "readAndRebrite", "readandRewwrite", "readAndRewrites", "readandrewrap"], "inFile": ["inFilename", "loginFile", "outFilename", "inputfile", "InFiles", "InFile", " inFiles", "oldFile", "loginFilename", " inSourceFile", "outSourceFile", "InSourceFile", "inputFiles", "outFiles", "oldFiles", " inFilename", "loginFiles", "inputFile", "inSourceFile", "loginfile", "outfile", " infile", "inputFilename", "inFiles", "oldfile", "infile", "oldFilename", "Infile"], "outFile": [" outStream", "offPlace", "outFilename", " outDir", "outputPlace", "outFILE", "OutStream", "outputFilename", "newDir", " outfile", "thisFILE", "outputFile", "offFile", "outDir", "processFilename", "exfile", "exFILE", "newfile", "processPlace", "thisFile", "processFILE", "thisfile", "offFilename", "thisFilename", "outStream", "outPlace", "newFile", "exFile", "exFilename", "outfile", "outputfile", "OutFile", "outputFILE", "OutDir", "offFILE", "processFile", "newStream", "Outfile"], "iis": ["iniis", "Iiss", "iiIs", "iiIS", " iIS", " iIs", "iIs", "iniiss", "ciiss", "ciis", "Iis", "Iais", " iris", "IIS", "ciais", "ciIs", "iiss", "ciris", "iniIS", "iniIs", "iiris", "iiis", "iiiss", "ciIS", "iniris", "iais", " iiss", "iris", "iIS", " iais"], "dcmParser": ["dcmHelper", "dpmarser", "dmcPar", "dmoduleJar", "dmcJar", "dcmPar", "dbmPolicy", "dCMPlugin", "dmoduleParser", "dcmJar", "fcmHandler", "dcrPar", "fpmParser", "dmcarser", "dpmparser", "dbmHelper", "dmissionReader", "dpmLoader", " dpmLoader", "dcrReader", "dbmPlugin", "dCMParser", "dmoduleparser", "dpmPolicy", " dcrParser", "dmPlugin", "dkmHelper", "DcmInstallation", "dmmParser", "dcmparser", " dpmPolicy", " dcmPlugin", "dcmLoader", " dpmHelper", "dmLoader", "dhemReader", "dcmarser", "dpmHelper", "dbmParser", "fpmHandler", "dpmHandler", "dhemParser", "dcrJar", "dpmJar", " dcmLanguage", "fcmParser", "dcrarser", "dcmPolicy", "dkmParser", "dpmInstallation", " dpmJar", "dmodulePlugin", "dmmparser", "dcmLanguage", "dhemInstallation", "dcmInstallation", "fpmparser", "dpmParser", " dpmparser", " dcmPar", "dcmHandler", "dcrPlugin", "dmcParser", " dcmparser", "dcmReader", " dcrReader", "fcmReader", "DcmReader", " dpmPlugin", "dCMparser", "dpmLanguage", " dpmReader", "dmParser", "dmoduleReader", "dmissionPlugin", "dhemJar", " dpmPar", " dcrLoader", "dpmPar", "fpmReader", "dcrParser", "DcmJar", "dmissionParser", " dcmReader", "dCMHandler", "dpmPlugin", " dpmarser", " dpmLanguage", "dmmPlugin", " dcmarser", "dkmPolicy", " dcmHelper", " dcmLoader", "fcmparser", "dpmReader", " dpmParser", "dmReader", " dcmJar", " dcrPlugin", "dCMReader", "dmmLoader", "DcmParser", " dcmPolicy", "dkmPlugin", "dcmPlugin", "dCMLoader", "dcrLoader", "dmissionLanguage"], "ds": ["dd", "dr", "vals", "des", "ants", "os", "vs", "dc", "amps", "dat", "utils", "DS", "ls", "services", "details", "Ds", "ads", "src", "ns", "points", "sync", "ld", "conn", "js", "ws", "da", "ts", "ays", "cdn", "xs", "ps", "session", "d", "ils", "Db", "dt", "ros", "Os", "tes", "cs", "df", "uds", "dds", "ras", "eps", "gd", "ins", "iss", "qs", "is", "rs", "ys", "gs", "icks", "nas", "bs", "data", "sys", "pd", "ss", "tx", "ks", "di", "asi", "db", "parts", "drivers", "s"], "pdReader": ["ddRunner", "hdWriter", "hdLoader", "xdRead", "hdStream", "pcLoader", "pdStream", "pbLoader", "dsLoader", "pbReader", "ddLoader", "pcRead", "ddReader", "pdreader", "xdWriter", "hdReader", "hdRunner", "hdreader", "pbRunner", "ddStream", "pcWriter", "dsreader", "pdLoader", "pbStream", "dsReader", "xdReader", "hdRead", "pdRead", "pcReader", "dsRead", "xdreader", "pdRunner", "dsWriter"], "out": ["flow", "her", "model", "temp", "group", "list", "full", "page", "null", "again", "result", "img", "layer", "name", "file", "lib", "connection", "parent", "s", "device", "in", "o", "login", "outer", "child", "point", "to", "write", "cli", "over", "cache", "sync", "output", "OUT", "password", "conn", "auto", "builder", "code", "session", "pass", "outs", "doc", "io", "Out", "co", "sys", "user", "down", "copy", "err", "base", "inner", " in", "at", "exp", "later", "object", "array", "external", "line", "diff", "client", "ssl", "term", "ext", "data", "gen", "lock", "ex", "default", "inc", "db", "exec", "obj", "image", "dev", "w", "order", "with", "net", "up", "key", "writer", "store", "oder", "part", "director", "manager", "as", "word", "dot", "url"], "dcmEncParam": ["dcmEnParam", "dcmArchArg", "dcmEnPar", "dcmEnArg", "dcmDecParam", "dcmDecType", "dcmDecArg", "dcmElType", "dcmArchParameter", "dcmEncArg", "dcmEnPart", "dcmElPar", "dcmArchParam", "dcmEncType", "dcmSecParam", "dcmEnType", "dcmDecPar", "dcmEstParameter", "dcmDecParameter", "dcmEncPart", "dcmEncParameter", "dcmEstPar", "dcmEncPar", "dcmElParam", "dcmEnParameter", "dcmElParameter", "dcmEstParam", "dcmSecType", "dcmDecPart", "dcmSecPar", "dcmEstType", "dcmSecPart"], "pdWriter": ["htReader", "ddOutput", "htWriter", "hdWriter", "dpWriting", "htWrite", "dsOutput", "PDWrite", "PDWriter", "ddWrite", "ddReader", "hdReader", "pdOutput", "pdWrite", "dpReader", "dsWrite", "ddWriter", "PDReader", "PDWriting", "hdWrite", "dsReader", "pdWriting", "hdOutput", "dpWrite", "dpWriter", "dsWriter", "htWriting"]}}
{"id1": "10385815", "id2": "8047989", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["create", "change", "send", "clone", "download", "write", "open", " Copy", "paste", "zip", "Transfer", "process", "sync", "replace", "Cop", "update", "split", "cmp", "upload", "Copy", "file", "transfer", "put", "move", "delete", "get", "exec"], "fileFrom": ["FileStart", "ioStart", " fileIn", "mailTo", "fileIn", " fileStart", "fileAs", "fileSource", "ioTo", "ioFrom", "FileSource", "FileAs", "FileIn", "fileStart", "mailAs", "FileFrom", " fileAs", "mailFrom", " fileSource", "mailIn", "FileTo", "ioSource"], "fileTo": ["resourceFile", " fileTO", "resourceFrom", "fpTo", "resourceTo", "FileFile", "fpTO", "Fileto", "fileTarget", "FileTO", "fileTO", "fpto", "resourceTarget", "FileFrom", " fileFile", "fpFrom", "FileTo", "fileFile", " fileTarget", "fileto", "FileTarget", " fileto"], "inputStream": ["outputstream", "outputSync", "inputContext", "InputChannel", "InputContext", "outputContext", "inputstream", "InputSteam", "InputFile", "outputSteam", "InputSync", " inputSteam", "inputFile", "inputSteam", " inputFile", " inputContext", "InputStream", " inputstream", " inputSync", "Inputstream", "outputFile", "inputSync"], "outputStream": ["OutputSteam", " outputSteam", "referenceSteam", "OutputPath", "inputPath", "writeSteam", "inputSocket", "OutputStream", "referenceSocket", "fourStreamer", "outputChan", "writeStream", "referenceStream", " outputPath", "outputSteam", "OutputChannel", "referenceChannel", " outputStreamer", "fourSteam", "writeSocket", "inputChan", "outputSocket", "OutputChan", "inputSteam", "writeChannel", "outputPath", "OutputStreamer", "outputStreamer", " outputChan", "fourChannel", "fourStream"], "inputChannel": ["butCommand", " inputSocket", " inputPassword", "inputContext", "InputChannel", "InputContext", "inputSocket", "outputContext", "audioStream", "InputChan", " inputCam", "outputChan", "audioClient", "butChan", "inputCam", "parentChan", "inputClient", "parentPassword", " inputCommand", "outputPassword", "outputCam", "inputPassword", " inputChan", "InputSocket", "butContext", "outputCommand", "inputChan", "outputSocket", "parentStream", "audioCam", "audioChannel", " inputClient", "butChannel", " inputContext", "parentChannel", "InputStream", "inputCommand", "outputClient"], "outputChannel": [" outputQueue", "outContext", "inputContext", " outputchannel", "outputchannel", "outputContext", "inputchannel", "OutputQueue", "OutputStream", " outputContext", "outputChan", "inputQueue", "OutputChannel", "outChan", "inputChan", "OutputChan", "Outputchannel", "outStream", "outChannel", "outputQueue", "OutputContext", " outputChan"]}}
{"id1": "1180878", "id2": "3631989", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public void run() {\n        URL url;\n        try {\n            url = new URL(\"http://localhost:8080/glowaxes/dailytrend.jsp\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((str = in.readLine()) != null) {\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"fetchURLData": ["frieveUrldata", "fetchURLDATA", "frieveURLDATA", "fetchJSONData", "frieveUrlDATA", "fetchHTTPDATA", "fetchUrldata", "fetchURLdata", "fetchUrlDATA", "frieveURLdata", "fetchHTTPdata", "fetchUrlData", "frieveURLData", "fetchHTTPData", "fetchJSONdata", "fetchJSONDATA", "frieveUrlData"], "url": ["image", "html", "URL", "base", "resource", "feed", "www", "view", "download", "Url", "ls", "http", "text", "src", "filename", "l", "href", "api", "page", "string", "path", "fl", "source", "uri", "xml", "ur", "name", "location", "ssl", "server", "data", "file", "user", "gl", "username", "sl", "el", "connection", "loc", "host", "f", "address"], "proxyHost": ["cacheHost", " proxyServer", "serverAddress", "serverPath", " proxyAddress", "baseHost", "baseDomain", "remoteAddress", "proxyHead", "baseAddress", "ProxyHead", "remoteDomain", "ProxyHost", " proxyPath", "proxyhost", "serverServer", " proxyhost", "proxyDomain", "baseHead", "ProxyDomain", "ProxyServer", "cachePort", "proxyPath", "remoteHead", "ProxyPath", "proxyAddress", "proxyServer", "cachehost", "cacheAddress", "ProxyPort", "ProxyAddress", "remoteHost", "Proxyhost", "serverHost"], "proxyPort": ["cacheHost", " proxyServer", " proxyport", " proxyAddress", "httpPort", "ProxyHost", "httpServer", "httpAddress", "cachePort", "Proxyport", "ProxyServer", "cacheport", "proxyAddress", "proxyServer", "proxyport", "cacheAddress", "ProxyPort", "ProxyAddress", "httpHost"], "con": ["com", "fa", "ls", "rec", "ch", "c", "cf", "rc", "ci", "per", "uc", "connection", "cr", "f", "login", "cl", "pc", "cur", "ca", "cache", "run", "sync", "conn", "CON", "ran", "co", "ocon", "cone", "connect", "go", "win", "re", "conv", "change", "sub", "fac", "fun", "don", "common", "pre", "cons", "fc", "remote", "un", "an", "x", "out", "xc", "Con", "pub", "cn", "on", "gen", "mc", "cp", "ec", "inc", "exec", "conf", "socket", "ver", "canon", "func", "can", "syn", "open", "pen", "ctrl", "http", "act", "pin", "fl", "en", "part", "ai", "min", "cc", "cas", "close", "cm", "ac", "n", "bc", "fan"], "is": ["ib", "its", "in", "can", "serv", "isi", "vs", "abs", "ops", "mis", "cms", "ir", "lis", "has", "does", "api", "info", "conn", "isu", "ws", "IS", "js", "ri", "act", "sp", "state", "ps", "was", "ie", "p", "ci", "ris", "si", "os", "it", "cs", "oss", "ai", "out", "isa", "isl", "fs", "iss", "cos", "il", "as", "es", "iso", "are", "bis", "us", "ori", "bs", "isin", "id", "isc", "ios", "Is", "i", "im", "get", "ais", "or", "ar", "iris", "ics", "s"], "u": ["ou", "o", "q", "U", "ul", "up", "ue", "http", "cu", "ut", "l", "un", "b", "ui", "uv", "api", "conn", "uci", "c", "m", "p", "io", "su", "uri", "os", "v", "client", "hu", "fu", "ur", "nu", "us", "h", "user", "file", "yu", "tu", "iu", "i", "uc", "ru", "lu", "f"], "proxy": ["force", "pool", "resource", "create", "clone", "phone", "pc", "fe", "http", "zip", "cache", "cop", " Proxy", "l", "api", "remote", "prot", "XY", "c", "pe", "pin", "Proxy", "pa", "plus", "p", "type", "xy", "uri", "x", "roxy", "ip", "client", "pse", "ssl", "bean", "wrapper", "server", "shadow", "port", "timeout", " proxies", "lib", "connection", "config", "host", "web", "f", "socket", "copy", "address"], "baos": ["abis", "baOS", "caas", "caos", "haOS", "bao", "bais", "BAOS", "BAos", "BAis", "pao", "boOS", "hao", "BaOs", "Baos", "boas", "haos", "calos", "caOS", "paOS", "Bais", "balos", "paos", "baas", "boos", "abOs", "abros", "BAo", "baOs", "aas", "bolos", "Baros", "pais", "hais", "alos", "baros", "BAOs", "aos", "aOS", "abos", "BAros"]}}
{"id1": "17947246", "id2": "16969205", "code1": "    public String readURL(String urlLocation, ArrayList headers, RenderEngine c) throws Exception {\n        URL url = null;\n        HttpURLConnection conn = null;\n        InputStream istream = null;\n        try {\n            url = new URL(urlLocation);\n            conn = (HttpURLConnection) url.openConnection();\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to retrieve URL for '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        loadCookies(urlLocation, conn, c);\n        if (headers != null) {\n            for (int i = 0; i < headers.size(); i++) {\n                String header = (String) headers.get(i);\n                String key = header.substring(0, header.indexOf(\":\"));\n                String value = header.substring(header.indexOf(\":\") + 2);\n                Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                conn.setRequestProperty(key, value);\n            }\n        }\n        Debug.debug(\"Set to use GET, URL=\" + urlLocation);\n        try {\n            istream = conn.getInputStream();\n        } catch (Exception e) {\n            Debug.debug(\"Unable to capture input stream: \" + e.getMessage());\n            throw new Exception(\"Unable to capture input stream from URL '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        Debug.debug(\"'GET' - Got input stream.\");\n        if (conn.getContentLength() == -1) {\n            Debug.debug(\"Content length = unknown\");\n        } else {\n            Debug.debug(\"Content length = \" + conn.getContentLength());\n        }\n        byte data[] = null;\n        int curPos = 0, contentLength = conn.getContentLength();\n        if (conn.getContentLength() == -1) {\n            String byteSize = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.tunable']/property[@type='engine.unknowncontentsize']/@value\");\n            if (byteSize == null) {\n                contentLength = 4096;\n            } else {\n                contentLength = Integer.parseInt(byteSize);\n            }\n            Debug.debug(\"Content length unknown.  Allowing fuzz of \" + contentLength + \" bytes.\");\n        }\n        data = new byte[contentLength];\n        try {\n            int dataRead = 0;\n            while ((dataRead = istream.read(data, curPos, contentLength - curPos)) != -1) {\n                if (dataRead == 0) {\n                    break;\n                }\n                curPos += dataRead;\n            }\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to read data from HTTP connection: \" + e.getMessage());\n        }\n        try {\n            istream.close();\n            conn.disconnect();\n        } catch (MalformedURLException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' is invalid: \" + e.getMessage());\n        } catch (IOException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' failed to connect.\");\n        }\n        String dataOut = new String(data);\n        int counter = 0;\n        data = null;\n        istream = null;\n        conn = null;\n        url = null;\n        return dataOut.trim();\n    }\n", "code2": "    private List<JarFile> webArchives(ServletContext servletContext) throws IOException {\n        List<JarFile> list = new ArrayList<JarFile>();\n        Set<Object> paths = servletContext.getResourcePaths(WEB_LIB_PREFIX);\n        for (Object pathObject : paths) {\n            String path = (String) pathObject;\n            if (!path.endsWith(\".jar\")) {\n                continue;\n            }\n            URL url = servletContext.getResource(path);\n            String jarURLString = \"jar:\" + url.toString() + \"!/\";\n            url = new URL(jarURLString);\n            JarFile jarFile = ((JarURLConnection) url.openConnection()).getJarFile();\n            JarEntry signal = jarFile.getJarEntry(FACES_CONFIG_IMPLICIT);\n            if (signal == null) {\n                if (log().isTraceEnabled()) {\n                    log().trace(\"Skip JAR file \" + path + \" because it has no META-INF/faces-config.xml resource\");\n                }\n                continue;\n            }\n            list.add(jarFile);\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"readURL": ["createurl", "downloadURI", "createUrl", "downloadurl", "loadURI", "readUrl", "loadURL", "readURI", "createURL", "createURI", "loadurl", "downloadUrl", "loadUrl", "downloadURL", "readurl"], "urlLocation": ["urlLocated", "pagelocation", "URLlocation", " urlLoc", "pageLocated", " urlLocated", "filelocation", "filePath", "urlPath", "baseUrl", "urlUrl", "resourcePath", "llocation", "URLLoc", "resourcelocation", " urllocation", "urllocation", " urlUrl", "lLocation", "basePosition", " urlPosition", "URLUrl", "URLContents", "URLPath", "baseLoc", "URLLocation", "fileLocation", "fileUrl", "resourceUrl", "urlLoc", "urlPosition", " urlContents", "lUrl", "resourceLoc", "fileLoc", "baseLocation", "resourcePosition", "resourceLocated", "pageLocation", "urlContents", "lContents", "resourceLocation"], "headers": ["pins", "resources", "archives", "html", "boxes", "comments", "authors", "objects", "codes", "keys", "types", "errors", "ppers", "heads", "head", "lines", "breaks", "plugins", "links", "hers", "ids", "http", "details", "frames", "properties", "events", "blocks", "styles", "limits", "files", "params", "ors", "groups", "drivers", "rows", "writers", "cells", "fields", "liners", "values", "qs", "parts", "users", "features", "pages", "names", "words", "strings", "ers"], "c": ["enc", "lc", "Controller", "o", "dc", "content", "cli", "pc", "cache", "l", "C", "engine", "r", " C", "g", "t", " mc", "d", "m", "ci", "p", "cs", "ce", "client", "cc", "controller", "context", "tc", "con", "h", "server", "e", "mc", "n", "bc", "ctx", "ec", "config", "cr", "f"], "url": ["log", "URL", "base", "resource", "lr", "www", "fr", "q", "config", "nl", "coll", "ul", "Url", "http", "cache", "cert", "l", "b", "ch", "page", "bel", "buffer", "path", "fl", "rel", "org", "uri", "build", "client", "il", "ur", "loader", "socket", "ssl", "location", "con", "server", "file", "ll", "gl", "e", "ob", "el", "sl", "rl", "uc", "connection", "loc", "host", "web", "f"], "conn": ["enc", "err", "conv", "cmd", "nt", "serv", "impl", "coll", "dc", "inner", "utils", "cli", "nc", "pc", "open", "obj", "ctrl", "rt", "http", "Connection", "ca", "ns", "sync", "ch", "cb", "ann", "act", "cf", "ct", "resp", "rc", "cdn", "db", "ci", "pg", "part", "fail", "org", "oss", "ai", "client", "cc", "pub", "auth", "socket", "ssl", "col", "co", "reg", "con", "loc", "cn", "host", "oa", "ob", "dn", "connect", "mc", "Conn", "error", "n", "ctx", "cp", "connection", "config", "uc", "exec", "conf"], "istream": ["istsig", "istsream", "ISTREAM", "ismub", "astorage", "istorage", "isteal", "ismream", "iesteal", "xtorage", "istsREAM", "astream", "xtig", "iestream", "iestub", "ISTream", "xtream", "istub", "ismeal", "asteal", "ismorage", "istig", "istREAM", "astub", "iestorage", "ISTorage", "ISTig", "xtREAM", "istsorage"], "i": ["ini", "j", "index", "in", "o", "hi", "inner", "phi", "ii", "ix", "slice", "mu", "b", "info", "ui", "ri", "pi", "gi", "d", "li", "ind", "ci", "p", "ie", "part", "multi", "si", "io", "xi", "I", "bi", "uri", "v", "ai", "eni", "y", "ip", "ori", "h", "ti", "id", "qi", "iu", "f", "u", "vi", "di", "m", "oi"], "header": ["rule", "body", "index", "field", "dr", "resource", "section", "inner", "event", "content", "metadata", "forward", "head", "param", "entry", "property", "version", "message", "pair", "filename", "column", "writer", "object", "page", "string", "code", "driver", "definition", "hash", "buffer", "token", "handler", "er", "holder", "line", "part", "attribute", "cover", "wire", "uri", "frame", "prop", "response", "layer", "block", "cookie", "character", "name", "request", "h", "server", "id", "document", "variable", "Header", "comment", "feature", "str", "reader", "second", "iter", "host", "upper", "address"], "key": ["link", "ver", "index", "base", "field", "ey", "q", "section", "prefix", "keys", "ky", "val", "owner", "head", "KEY", "ke", "label", "hop", "string", "code", "hash", "element", "pe", "iv", "ace", "core", "k", "query", "ee", "ck", "ie", "type", "part", "wire", "uri", "x", "by", "sign", "cy", "secret", "ip", "kw", "name", "col", "co", "ray", "my", "id", "variable", "lock", "str", "feature", "Key", "parent"], "value": ["ver", "model", "resource", "end", "content", "val", "format", "json", "entry", "target", "property", "version", "Value", "text", "message", "label", "media", "info", "style", "string", "element", "iv", "null", "var", "gi", "VALUE", "hello", "type", "part", "v", "values", "va", "name", "test", "reference", "valid", "alt", "description", "vi", "feature", "default", "parent"], "data": ["body", "offset", "content", "format", "breaks", "cache", "area", "blocks", "media", "info", "bytes", "pad", "string", "class", "array", "buffer", "next", "DATA", "type", "number", "block", "start", "map", "str", "ata"], "curPos": ["serToken", " curToken", " curPosition", "CurEnd", "serPosition", "CurToken", "curToken", "CurPosition", "curPosition", "curEnd", "serEnd", "serPos", "CurPos", " curEnd"], "contentLength": ["loadInfo", "resourceLen", "byteInfo", "loadLength", "byteType", "loadLen", " contentType", "byteLength", " contentLen", "contentInfo", "contentSize", " contentInfo", "loadSize", "ContentLen", "loadType", "resourceType", "ContentLength", "resourceSize", "contentType", " contentSize", "contentLen", "ContentType", "resourceLength", "ContentSize"], "byteSize": [" byteLen", "wordSize", "ByteSize", " byteType", "byteType", "byteLen", "byteLength", "byteTime", "contentTime", "bytesWidth", "wordLength", "contentSize", "bytesSize", "ByteType", " byteWidth", " byteTime", "ByteWidth", " byteLength", "ByteTime", "byteWidth", "wordData", "ByteLen", "byteData", "contentType", " byteData", "wordLen", "bytesLength", "bytesLen", "ByteLength", "bytesData"]}}
{"id1": "8000624", "id2": "1188100", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": [" transferto", "copyto", "CopyFrom", " transferFrom", " copyTo", " copyFile", "copyFrom", "CopyFile", " copyFrom", "copyTo", " transferTo", "copyFile", " copyto", " transferFile", "Copyto"], "dest": ["folder", "wb", "die", " destination", "temp", "cont", "done", "content", "w", "transform", " Dest", "write", "target", "them", "src", "filename", "output", "later", "bin", "table", "object", "sup", "comb", "txt", "class", "orig", "exit", "dist", "path", "opt", "flat", "img", "rest", "tmp", "name", "test", "Dest", "data", "file", "desc", "delete", "destroy", "source", "obj"], "in": ["re", "image", "ini", "kin", "login", "wave", "fa", "inner", "inn", "gin", "input", "din", "In", "up", "l", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "plus", "source", "nin", "sin", "x", "cin", "issue", "pull", "ins", "as", "init", "inside", "ac", "thin", "h", "con", "ln", "rin", "ax", "isin", "id", "reader", "i", "win", "n", "vin", "lib", "connection", "m", "inc", "f", "lin", "s"], "out": ["err", "ou", "image", "o", "outer", "temp", "other", "this", "inner", "outside", "w", "net", "target", "our", "up", "or", "cache", "sync", "output", "OUT", "writer", "b", "conn", "bin", "object", "url", "pin", "external", "again", "outs", "not", "plus", "nin", "part", "io", "x", "Out", "client", "off", "app", "name", "ext", "data", "file", "vert", "user", "call", "ex", "i", "no", "timeout", "n", "one", "lib", "inc", "exec", "socket", "copy"], "c": ["enc", "lc", "esc", "o", "config", "dc", "content", "exc", "cl", "pc", "fc", "cu", "ca", "l", "ch", "cb", "arc", "C", "code", "cf", "r", "ct", "buffer", "rc", "t", "ic", "d", "ci", "p", "sc", "pointer", "v", "x", "ce", "cy", "xc", "cc", "oc", "cm", "col", "ac", "e", "char", "u", "comment", "i", "abc", "n", "uc", "bc", "ec", "m", "cr", "f"]}}
{"id1": "11305840", "id2": "20663364", "code1": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 1, "substitutes": {"setUpdateCliente": ["setUpdateclientes", "setupdateclientes", "setUpdateCompanyen", "setupdateclienteur", "setUpdateCompanye", "setUpdatecliente", "setUpdateclienten", "setUpdateContacten", "setUpdateContacte", "setupdateclienten", "setupdateClientes", "setUpdateCompanyeur", "setupdatecliente", "setUpdateClientes", "setUpdateClienteur", "setUpdateContacteur", "setUpdateCompanyes", "setupdateClienteur", "setupdateCliente", "setupdateClienten", "setUpdateContactes", "setUpdateclienteur", "setUpdateClienten"], "IDcliente": ["IDClientee", "IDprojecte", " IDservere", "IDprojectpe", "IDCliento", "IDquanto", "ENDclientisi", "ENDcliento", "ENDclientee", "IDClientpe", "IDquantisi", "IDclientes", " IDserverpe", "IDserverE", "ID1000ee", "IDprojectee", "ID1000e", "IDservere", "IDquantee", "IDclientee", "IDclientE", "ENDClientee", " IDclientee", " IDserveree", "ENDClientisi", "IDClientisi", "ID1000o", "IDclientisi", "IDserverpe", "IDClientE", "ENDCliento", "ENDCliente", "IDcliento", " IDclientpe", " IDclientE", "IDClientes", " IDserveres", "IDserveree", "IDCliente", " IDclientes", "ENDcliente", "IDclientpe", "IDprojectes", "ID1000isi", "IDquante", "IDserveres"], "nombre": ["nombrero", "numbred", "nombber", " nombred", " nomere", "nuclere", "nomeber", "Nucleres", " nomerero", " nomeber", "nucleber", " nomered", " nombrero", "Nuclere", "Nombres", "numbber", "nomere", "Nombrero", "numbres", "Nuclerero", "nuclerero", " nombber", "nomeres", "nombres", "numbrero", "Nombre", "nugeber", "nucleres", "nomered", "Nucleber", "nugere", "numbre", "nomerero", "nugered", "nombred", "Nombber", "nugerero"], "paterno": ["matern", "pattername", "pasern", "natterNo", "pattern", "materna", "matterno", "matterna", "patterno", "paterNo", "matername", "paserna", "patersn", "mattername", "patterna", "ptername", "naterno", "paterna", "patersname", "patterNo", "patersNo", "natterna", "pterno", "natterno", "naterna", "patern", "naterNo", "paserNo", "paserno", "ptern", "patersna", "mattern", "nattern", "natern", "pterna", "patername", "patersno"], "materno": ["Materna", "matern", "masern", "maserNo", "matersnot", "materNo", "morterNo", "matersNo", "natterNo", "materna", "matterno", "matersn", "mortern", "morterno", "maternot", "mATERno", "maserna", "matersno", "naterno", "mATERNo", "MaterNo", "Materno", "natterno", "MATERna", "naterNo", "matersna", "MATERn", "naternot", "maserno", "MATERNo", "nattern", "mattern", "matterNo", "Matern", "natternot", "morternot", "matternot", "natern", "mATERn", "mATERna", "MATERno"], "ocupacion": ["ocupruction", "ocupacia", "ocupaci", "ocupsaton", "acupacia", "OCupaci", "oculpatio", "acupruction", "ocopaci", "ocuppaton", "OCupaton", "acuppacion", "OCupacion", "ocupsacion", "ocovacia", "ocupatio", "oculpaton", "acuppruction", "ocuppacion", "OCuppacion", "OCuppaton", "ocovruction", "ocuppruction", "acuppaci", "ocuppatio", "ocopacia", "ocupaton", "ocupsatio", "ocopruction", "ocuppacia", "oculpaci", "oculpacion", "ocovaci", "OCupatio", "ocuppaci", "acupaci", "OCuppatio", "acuppacia", "ocupsaci", "acupacion", "OCuppaci", "ocovacion", "ocopacion"], "rfc": ["Rbf", "srfe", "rrf", "rrbf", "Rpc", "rfe", "rrfc", " riff", "rsfc", "rf", "rsiff", "rsfe", "rspc", "rbf", "Rfc", "rrpc", "rpc", "Rf", "riff", "srpc", "sriff", "srfc", " rfe", " rf", " rbf", " rpc"], "stm": [" stbm", "Stmt", "ntm", "stf", "Stf", "ctmt", "STM", "stM", "STf", "ctM", "crm", "stdm", "ntbm", "crbm", "crM", "ctf", "ntM", "STm", "stmt", "crdm", "StM", " stdm", "stbm", " stM", "Stm", "ntdm", "ctm", "STmt"], "update": ["unit", "create", "change", "send", "other", "module", "end", "continue", "current", "event", "check", "draw", "write", "json", "open", "edit", "accept", "up", "load", "UPDATE", "run", "add", "use", "replace", "enable", "fill", "set", "updated", "apply", "Update", "initial", "remove", "ify", "author", "result", "it", "build", "diff", "out", "response", "where", "ite", "equal", "component", "include", "valid", "id", "lock", "error", "database", "complete", "save"]}}
{"id1": "7006052", "id2": "15409512", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copyFileInfo", "copySourceFileTo", "copySourceFileInfo", "copySourceFileFile", "copyFileFile", "copyfileInfo", " copyFileFrom", "copyfileTo", " copyFileFile", "copyFilesFile", "copyFilesFrom", " copyFilesTo", " copyFilesFile", " copyFileInfo", "copyFileFrom", "copyfileFrom", "copySourceFileFrom", "copyfileFile", "copyFilesTo", " copyFilesFrom", " copyFilesInfo", "copyFilesInfo"], "src": ["image", "resource", "sub", "stream", "inf", "filename", "slice", "remote", "href", "sync", "b", "js", "sup", "string", "txt", "code", "rc", "path", "sc", "upload", "uri", "sb", "sin", "img", "rs", "sel", "archive", "loc", "data", "file", "fn", "sl", "old", "rb", "config", "source", "url", "s"], "dest": ["folder", "wb", "die", " destination", "temp", "sub", "des", "done", " Dest", "target", "filename", "output", "later", "bin", "b", "sup", "home", "comb", "txt", "orig", "dist", "route", "result", "opt", "flat", "img", "dir", "secure", "tmp", "name", "test", "Dest", "data", "const", "desc", "delete", "default", "loc", "source", "project"], "destFile": [" destinationDir", "DestFile", " destinationFiles", " destinationFile", "destF", "destDir", "destfile", "DestF", " destFiles", " destF", " destfile", " destinationF", "DestFiles", "targetfile", " destDir", "targetFile", "targetFiles", "destFiles", "DestDir", "Destfile", "targetDir"], "in": ["ini", "err", "kin", "image", "login", "impl", "stream", "inner", "gin", "inn", "input", "trans", "In", "up", "l", "bin", "url", "pin", "IN", "r", "again", "pass", "source", "nin", "cin", "diff", "ins", "is", "lin", "init", "inside", "thin", "con", "ln", "rin", "id", "data", "i", "win", "reader", "n", "din", "f", "socket", "inc", "s"], "out": ["err", "image", "log", "pool", "o", "outer", "other", "this", "inner", "w", "plain", "net", "up", "exp", "cache", "sync", "output", "OUT", "writer", "conn", "post", "bin", "extra", "null", "again", "work", "part", "io", "Out", "client", "cos", "off", "ext", "ac", "user", "file", "data", "parent", "ex", "one", "n", "inc", "exec", "obj", "copy"], "buf": ["pool", "box", "br", "raw", "vec", "bl", "ff", "cache", "queue", "bag", "uf", "bytes", "cb", "b", "blocks", "pad", "cap", "bin", "bh", "c", "orig", "buff", "buffer", "rc", "path", "fb", "bf", "bd", "result", "v", "block", "length", "cas", "off", "tmp", "map", "loc", "data", "cv", "rb", "bc", "seq", "batch", "ctx", "uc", "Buffer"], "len": ["lc", "num", "body", "base", "nt", "end", "coll", "val", "lf", "pre", "count", "rev", "l", "bytes", "cap", "url", "pos", "c", "fd", "split", "ind", "li", "fl", "en", "ie", "line", "part", "Len", "all", "min", "lim", "length", "off", "size", "ln", "data", "id", "el", "no", "n", "iter", "fin", "f"]}}
{"id1": "6966398", "id2": "22801734", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"reader": ["her", "dr", "resource", "o", "feed", "stream", "input", "ry", "load", "reads", "parser", "reading", "ler", "rar", "cms", "writer", "raf", "read", "ri", "builder", "pp", "pe", "r", "driver", "buffer", "rc", "oder", "k", "handler", "er", "p", "io", "rake", "se", "rr", "df", "row", "client", "ner", "context", "manager", "loader", "server", "file", "cer", "instance", "Reader", "rw", "keeper", "per", "iter", "or", "connection", "config", "source", "book"], "ks": ["gets", "kes", "books", "kb", "keys", "ku", "ans", "sk", "vs", "ops", "DS", "ls", "powers", "ns", "reads", "ges", "acs", "KS", "ke", "ms", "acts", "rows", "inks", "ps", "k", "ck", "ds", "akes", "ches", "works", "acks", "CS", "se", "cs", "checks", "opens", "qs", "fs", "hs", "rs", "es", "co", "ko", "ips", "icks", "orks", "bs", "ss", "kies", "ctx", "ki", "ics", "cks"], "key": ["base", "service", "trust", "point", "keys", "ca", "cache", "pair", "ke", "court", "read", "code", "c", "pe", "state", "k", "p", "type", "io", "sign", "ce", "client", "secret", "ssl", "co", "ring", "server", "user", "file", "seed", "transfer", "char", "lock", "value", "Key", "ki", "pg", "ee"], "chain": ["enc", "rule", "image", "base", "box", "Chain", "root", "chains", "coll", "sequence", "wheel", "none", "circle", "cache", "pair", "stack", "table", "list", "slice", "object", "set", "scale", "c", "code", "store", "collection", "crypt", "family", "path", "wrap", "container", "network", "secret", "block", "range", "file", "lock", "mc", "config", "cr"], "os": ["ou", "o", "options", "ops", "osi", "bos", "ms", "object", "pos", "ps", "outs", "op", "p", "ds", "io", "ros", "Os", "oid", "oss", "fs", "opens", "is", "cos", "rs", "iso", "es", " o", " bos", "oses", "ot", "ob", "ol", "ios", "OS", "res", "los", "aos", "rss", "s"], "stamper": ["stample", " nostameper", "_", " nostamper", "spAMper", "this", "stammpe", "function", " nostamler", "starmpper", "spAMmer", "starmper", "stAMpe", "stamepper", "stameper", "stameler", "stammer", "streammer", "spammer", "spampe", "stammmer", "stameple", "g", "stammple", "stammper", "path", "stampper", "stAMmer", "spAMpe", "starmple", "stamler", " nostamepper", "streamler", "spAMler", "streampe", "spamler", "stAMler", " nostameler", "spamper", "stampe", "stAMper", "data", "stammler", "streamper", "starmler", "stammpper", " nostameple", " nostample", " nostampper", "s"], "appearance": ["feedointment", " appence", " appfacing", "Appearing", " appear", " appears", "appaser", "appfacing", "askence", "installear", "installasion", "askeared", " appismo", "atteared", " appeared", "appismo", "attence", "byearing", "signear", "askfacing", "signfacing", "feedfacing", "suppear", " applier", "ppearing", "appasion", "byismo", "installearing", "suppointment", "appeared", "byear", "formearing", "feedear", " appearing", "byearance", "attearance", "installearance", "attfacing", "formaser", "suppasion", "ppear", "signearing", "suppearing", "appointment", "formearance", "formear", "askearance", "Applier", "Appearance", "signlier", "signears", "signointment", "Appears", "suppearance", "feedearance", "appence", "ppearance", "applier", "appearing", "formismo", "ppaser", "ppasion", "suppfacing", " appaser", "appear", "appears", "signearance"]}}
{"id1": "7458833", "id2": "18974466", "code1": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"copyParseFileToCodeFile": [" copyParseFileToMapfile", " copyParseFiletoCodeClass", " copyParseFiletoOutputFile", " copyParseFileToOutputfile", " copyParseFiletoOutputfile", " copyParseFileTocodefile", " copyParseFileTocodeFile", " copyParseFileToOutputFile", " copyParseFiletoOutputFiles", " copyParseFiletoCodeFiles", " copyParseFileToMapFiles", " copyParseFileTocodeClass", " copyParseFileToOutputFiles", " copyParseFileToCodeFiles", " copyParseFileTocodeFiles", " copyParseFileToOutputClass", " copyParseFiletoCodeFile", " copyParseFileToCodefile", " copyParseFiletoOutputClass", " copyParseFiletoCodefile", " copyParseFileToCodeClass", " copyParseFileToMapClass", " copyParseFileToMapFile"], "in": ["ini", "err", "image", "kin", "login", "impl", "stream", "inner", "gin", "inn", "input", "In", "ls", "up", "bin", "read", "pin", "IN", "r", "again", "ic", "oin", "nin", "io", "cin", "min", "pull", "ins", "is", "lin", "as", "init", "inside", "con", "id", "rin", "i", "win", "reader", "n", "get", "m", "din", "f", "socket", "inc"], "out": ["err", "image", "log", "o", "outer", "other", "this", "inner", "w", "plain", "net", "up", "exp", "cache", "sync", "output", "OUT", "writer", "conn", "post", "bin", "again", "outs", "work", "source", "io", "Out", "client", "as", "ext", "server", "user", "file", "parent", "ex", "i", "one", "n", "inc", "exec", "socket"], "buffer": ["base", "shape", "wave", "feed", "raw", "capacity", "event", "sequence", "duration", "input", "channel", "available", "cache", "count", "total", "slice", "queue", "uf", "pad", "string", "read", "buf", "array", "null", "position", "buff", "padding", "fb", "uffer", "result", "number", "layer", "pause", "request", "server", "data", "reference", "document", "binary", "limit", "iter", "batch", "source", "Buffer", "address"], "length": ["repeat", "index", "shape", "feed", "end", "offset", "before", "point", "view", "sequence", "duration", "match", "Length", "load", "count", "total", "slice", "l", "full", "bb", "style", "string", "code", "position", "path", "line", "type", "part", "width", "len", "number", "row", "pull", "block", "character", "size", "start", "partial", "distance", "volume", "range", "id", "ob", "weight", "level", "limit", "lock", "value", "time", "ength", "url", "address"]}}
{"id1": "6403868", "id2": "20924119", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"extractUninstallFiles": ["extractUppackFiles", "extractUppackSources", "extractUnInstallSources", "extractUnInstallFiles", "extractUninstallfiles", "extractUninstallFile", "extractUnzipFiles", "extractUpinstallFile", "extractUnzipfiles", "extractUpinstallSources", "extractUpinstallfiles", "extractUnpackFiles", "extractUnzipFile", "extractUnInstallfiles", "extractUnpackSources", "extractUpinstallFiles", "extractUnInstallFile", "extractUppackFile", "extractUnpackfiles", "extractUppackfiles", "extractUninstallSources", "extractUnpackFile", "extractUnzipSources"], "_destPath": ["_srcPath", "_tmppath", "_distDir", "_downloadFile", "_downloadDirectory", " _destFile", " _destHome", " _sourceFile", "_distFile", "_Destpath", "_downloadPath", "_destHome", "_sourceDir", " _sourcePath", "_srcFile", "_sourceDirectory", "_downloadHome", "_sourceHome", "_distDirectory", "_tmpDir", "_distPath", "_tmpDirectory", "_DestDir", "_DestHome", "_tmpPath", "_sourceFile", "_destDir", " _destDirectory", "_destFile", "_srcDir", "_destDirectory", "_sourcepath", "_DestFile", "_sourcePath", "_srcDirectory", "_DestPath", "_destpath", "_DestDirectory", " _sourceDirectory", " _sourceHome"], "upgrade": [" upge", "duGrade", "upge", "offinstall", "Upgrading", "dugrading", "UpGrade", "offgrade", "offgrades", " upinstall", "dugrade", " upgrades", " upGrade", "duge", "upgrading", "ipinstall", "upgrades", " upgrading", "upinstall", "upGrade", "ipgrading", "offgrading", "Upge", "Upgrade", "ipgrades", "ipgrade"], "lastVer": ["nextver", " lastVersion", "lastver", "firstver", "nextVer", " lastVER", "nextVersion", "prevVer", "lastVers", "firstVER", "firstVer", "LastVersion", "prevVersion", "prevver", "LastVer", "lastVersion", "prevVers", "nextVers", "firstVersion", " lastver", "lastVER", "LastVER", "Lastver", " lastVers"], "oldlog": ["oldpath", "oldertext", "newpath", "Oldpath", "OLDbug", " oldLog", " oldLOG", "newtext", "olderLog", "oldtext", "OLDLog", "newLOG", "oldLog", "newLog", " oldbug", "Oldlog", " oldpath", "newbug", "OldLOG", "oldLOG", "newlog", "OLDlog", "olderLOG", "olderlog", "OldLog", " oldtext", "oldbug"], "destPath": ["postRoot", "srcpath", "destRoot", "doneLog", "Destpath", "exportPath", " destath", "usrpath", "postpath", "descKit", " destKit", "flatDir", "targetFile", "descPath", "constpath", "donepath", "targetpath", "descDir", " destRoot", "targetDir", "descName", "sourceDirectory", "homeName", "secureWin", "destKit", "targetPath", "contpath", "donePath", "homeKit", "DestPath", "DestCh", " destCh", "srcPath", " destpath", " destPATH", "exportPATH", "secureLog", " destWin", "destWin", "DestFile", "targetRoot", "sourceDir", "flatPath", "flatpath", "usrPath", "srcDirectory", "destHome", "contath", "exportpath", "destFolder", "destDirectory", "Destath", "usrFile", " destLog", " destFile", " destName", " destHome", "doneDir", "targetPATH", "postPath", "DestPATH", "DestDir", "DestHome", "srcPATH", "descpath", "homeLog", "contDir", "destPATH", "destFile", "doneWin", "destLog", "contPath", "flatFolder", "securePath", "sourcePath", "destath", "destDir", "constPath", "homepath", "constHome", "sourcepath", "constFile", "destName", "exportDirectory", " destDir", "homePath", "descCh", "destpath", " destDirectory", "DestRoot", " destFolder", "secureDir", "postPATH", "homeDir", "descFile", "DestFolder", "DestDirectory", "destCh"], "lastVerPath": ["nextVerCh", "lastVersionEx", " lastVersionEx", " lastVerDir", "lastverName", "lastVERDir", "lastVEREx", "lastVERpath", "lastVerFile", "lastVersionFile", "lastModName", " lastVerEx", "lastModFile", "lastverDir", "lastModDir", "lastVersCh", " lastVersionpath", " lastVerId", " lastVerCh", "lastVersPath", "lastVERCh", "nextVerpath", "lastVerspath", "lastverpath", "lastverEx", " lastModpath", "lastVersFile", " lastVersionPath", "nextVerFile", "lastVersionId", "lastModpath", "lastTestPath", "lastVerpath", "prevVerName", "lastVerId", "lastVersionPath", "prevVerFile", "lastVerDir", " lastVerFile", "prevverName", " lastVersionCh", "lastverFile", "lastModPath", "lastVerEx", "prevverpath", "lastVerName", "lastverCh", "prevVerpath", "prevVerPath", "lastModCh", "nextverPath", "lastTestpath", " lastModDir", " lastModPath", "lastTestId", " lastVersionId", " lastVersionFile", "lastVerCh", "lastVersionpath", "nextverCh", "nextverFile", "lastTestFile", "lastVERPath", "lastVersionName", "prevverPath", "lastverPath", " lastVerpath", "lastVersionCh", "nextverpath", "nextVerPath", "lastverId", "prevverFile", " lastModCh"], "bkdir": ["bKDir", "bvpath", "bkbloc", "bkDir", "bkdesc", " bkloc", "bkkpath", " bkdesc", "bkpath", "bkkir", "bakDir", "bkfile", "bckdir", "bkgir", " bakDir", "bkkfile", "bckdirectory", "bvDir", "bakloc", "Bkpath", "bvdir", "bvloc", " bkpath", " bakdir", "bkbdir", "bkkloc", "bakdir", " bakloc", " bkfile", "Bkdir", " bktloc", "Bkdirectory", "Bckpath", " bktdir", "bckDir", " bkDir", "bkkDir", "bkloc", "bkbfile", "bktloc", "bckpath", "bkkdesc", "bakpath", " bkir", "BkDir", "bKdirectory", "bkir", "bktfile", "bKdir", " bktdesc", "bkkdir", " bakpath", "bkgDir", "bkgdir", "Bckdir", "BckDir", "bktdir", " bktfile", "bakir", "bkbdesc", "bakdirectory", "bktdesc", "bkdirectory", " bakir", "bKpath", "Bckdirectory"], "oldClassCopied": ["oldFilecopies", "oldClassCopyying", "oldclassCopies", "oldClassCopyified", "oldClassCrossified", "oldClasscopies", "oldClassCrossiated", "oldFileCopied", "oldclassCopie", "oldFileCopyying", "oldClassCopies", "oldFileCopying", "oldFileCopies", "oldClasscopored", "oldClassCopyie", "oldClassCopiated", "oldclassCopied", "oldFilecopied", "oldFilecopie", "oldClassCopified", "oldClassCopyied", "oldclassCopored", "oldClassSkored", "oldClasscopie", "oldClassSkies", "oldClassCrossied", "oldFileCopyied", "oldFileCopyified", "oldFileCopyiated", "oldClassCopyies", "oldClassCopie", "oldFileCopified", "oldFileCopiated", "oldClasscopying", "oldFilecopying", "oldClasscopied", "oldFileCopie", "oldClassSkie", "oldClassCopying", "oldClassCrossying", "oldClassCopored", "oldClassCopyiated", "oldClassSkied"], "ls": ["lc", "lbs", "iffs", "sels", "lr", "wl", "locks", "vs", "irs", "lf", "lines", "ns", "less", "lis", "als", "l", "list", "tl", "LS", "lp", "files", "mails", "lb", "ils", "fl", "lists", "ches", "ails", "fts", "cs", "fs", "qs", "la", "lv", "les", "ln", "ll", "lt", "bps", "bs", "igs", "ols", "rl", "dl", "los", "acl"], "i": ["ini", "z", "mi", "part", "index", "j", "o", "oi", "q", "yi", "uli", "end", "hi", "inner", "phi", "ii", "fi", "ix", "slice", "mu", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "t", "abi", "d", "li", "ind", "ci", "p", "type", "multi", "si", "io", "xi", "it", "uri", "v", "x", "ai", "eni", "min", "y", "ji", "ip", "start", "ti", "qi", "id", "lc", "e", "iu", "u", "f", "ij", "di", "m", "I", "s"]}}
{"id1": "21491791", "id2": "8024375", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"run": ["unit", "log", "create", "func", "worker", "process", "code", "apply", "running", "fork", "work", "job", "build", "all", "loop", "command", "start", "app", "spawn", "test", "runner", "call", "Run", "execute", "exec", "invoke"], "input": ["image", "flow", "index", "in", "resource", "raw", "feed", "storage", "view", "stream", "inner", "form", "audio", "Input", "worker", "active", "entry", "up", "text", "reading", "parser", "conn", "read", "driver", "initial", "state", "readable", "work", "control", "io", "out", "client", "context", "loader", "internal", "request", "data", "file", "user", "iterator", "instance", "connection", "config", "source", "address"], "output": ["writing", "image", "letter", "log", "written", "unit", "generated", "resource", "index", "temp", "outer", "end", "office", "write", "target", "text", "cache", "filename", "queue", "later", "environment", "object", "page", "application", "exit", "path", "job", "writers", "control", "console", "out", "response", "network", "Writer", "operation", "Output", "file", "data", "document", "user", "put", "web", "connection", "config", "source", "parent"], "reader": ["image", "slave", "in", "resource", "system", "view", "stream", "rer", "inner", "audio", "entry", "worker", "parser", "reading", "read", "driver", "builder", "ri", "r", "oder", "handler", "er", "author", "io", "row", "client", "context", "ner", "manager", "riter", "loader", "request", "peer", "wrapper", "server", "Reader", "source", "book", "owner", "rator"], "writer": ["writing", "her", "written", "wb", "outer", "office", "inner", "w", "write", "player", "wan", "entry", "worker", "wer", "ws", "engine", "builder", "driver", "ew", "r", "creator", "wa", "wr", "work", "er", "writers", "author", "wire", "nw", "out", "ner", "manager", "riter", "Writer", "word", "request", "ter", "wrapper", "data", "war", "maker", "rw", "writ", "or", "connection", "editor"], "pump": ["pamp", "prump", "Pumper", "camp", "ppump", "Pump", "dmp", "pdump", "ppumps", "humper", "dumps", "prdump", "pram", "Pdump", " pumping", " pam", "mump", "Pam", "prumper", "Pmp", " pmp", "Pumps", "hprint", " pamp", " pdump", "cumper", "pam", "Pprint", "Pumping", "pumping", "hump", "cump", "pumper", "dump", "pmp", "Pamp", "mprint", "ppumping", "mumps", " pumps", " pumper", "ppumper", "mumper", "pumps", "cumping", "humps", "pprint", "dumper"], "counter": ["num", "repeat", "index", "ver", "lr", "outer", "walker", "offset", "continue", "current", "inner", "step", "sequence", "order", "meter", "ener", "entry", "worker", "inter", "consumer", "version", "master", "count", "ger", "now", "race", "page", "builder", "code", "clock", "starter", "r", "collection", "rew", "author", "er", "hello", "Counter", "result", "pointer", "progress", "currency", "number", "row", "loop", "layer", "ner", "cookie", "loader", "trace", "ception", "runner", "keep", "ter", "server", "seed", "const", "instance", "second", "keeper", "center", "timer", "zero", "comment", "enter", "parent", "url", "processor"], "buffer": ["base", "resource", "entry", "channel", "text", "message", "queue", "uf", "page", "buf", "position", "buff", "uffer", "layer", "length", "loader", "server", "data", "file", "document", "reference", "port", "limit", "binary", "iter", "batch", "source", "Buffer", "url", "header", "address"], "off": ["flow", "o", "offs", "end", "offset", "of", "inner", "art", "head", "open", "ff", "Offset", "offer", "ref", "less", "area", "info", "ui", "now", "auto", "left", "set", "ord", "pos", "OFF", "fail", "opt", "addr", "out", "own", "start", "low", "on", "down", "oa", "unknown", "Off", "eno"], "len": ["body", "log", "lc", "in", "end", "lit", "val", "lf", "fin", "lan", "ref", "count", "ler", "lon", "den", "l", "bin", "ld", "pos", "fd", "li", "fl", "en", "line", "Len", "width", "lim", "all", "elt", "layer", "length", "size", "name", "ln", "on", "ll", "lt", "gen", "limit", "lock", "el", "n", "lib", "loc", "url", "lin"], "rd": ["dd", "nd", "dr", "lr", "fr", "rx", "ud", "val", "rid", "xd", "rt", "RD", "RR", "adr", "ld", " prod", " r", "rod", "ord", "rf", "r", "rc", "fd", "d", "ind", "db", "rob", "ds", "rand", "red", "rr", "nr", "rh", "raid", "ra", "rs", "hr", "rn", "rm", "rss", "rb", "rw", "rl", "ru", "cr", "dra"]}}
{"id1": "18731843", "id2": "4118412", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"doBody": ["DoFile", "DoResponse", "handleBody", "doResponse", "DoBody", " doFile", "DoBytes", " doResponse", "handleResponse", "handleFile", "doFile", "handleBytes", "doBytes", " doBytes"], "req": ["err", "resource", "q", "rx", "fr", "crit", "this", "config", "serv", "download", "cgi", "obj", "ref", "src", "http", "qq", "rec", "respond", "conn", "jp", "info", "def", "r", "spec", "query", "sem", "Request", "rr", "proc", "rh", "comp", "report", "request", "data", "qt", "reader", "res", "reg", "requ", "rss"], "resp": ["re", "err", "html", "serv", "val", "exc", "Response", "respons", "download", "pre", "rep", "ref", "cache", "rev", "rec", "api", "respond", "bb", "jp", "cb", "b", "prot", "pos", "sp", "r", "job", "p", "part", "cmp", "result", "ret", "rr", "inv", "proc", "comp", "response", "Resp", "report", "request", "data", "res", "reply", "obj"], "bis": ["pins", "rots", "atis", "mis", "bits", "iris", "alis", "bid", "lins", "nis", "bas", "lis", "bin", "b", "bb", "usb", "ubis", "obs", "abi", "fb", "bes", "boot", "ris", "obb", "bi", "obos", "sb", "os", "uds", "phis", "sis", "iss", "is", "ses", "bian", "ori", "ois", "bs", "isin", "oris", "bps", "binary", "ios", "ais", "tis", "bh", "los", "sin", "obi"], "bos": ["bo", "lol", "zos", "osa", "ops", "bits", "osi", "lins", "mos", "bas", "bin", "oros", "bris", "bones", "obo", "ubis", "obs", "zo", "abi", "bes", "boot", "ros", "obb", "obos", "os", "oks", "bi", "uds", "phis", "antis", "bott", "oS", "las", "ois", "oops", "bs", "opus", "oses", "bps", "ios", "tis", "oos", "fits", "bh", "los", "aos", "obi"]}}
{"id1": "13563706", "id2": "19096138", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", " doPut", "didGET", "handleget", "handleGet", "didGet", "didPut", "didget", " doget", "handlePut", "handleGET", "doPut", "doget", "doGET"], "request": ["image", "model", "method", "resource", "create", "view", "current", "event", "Response", "input", "req", "message", "queue", "remote", "info", "QUEST", "object", "application", "string", "buffer", "query", "Request", "p", "type", "attribute", "result", "frame", "client", "xml", "report", "server", "user", "data", "document", "instance", "complete", "connection", "config", "url"], "response": ["re", "onse", "image", "model", "body", "pool", "service", "resource", "index", "feed", "site", "view", "Response", "json", "reason", "http", "message", "output", "respond", "writer", "api", "object", "application", "status", "resp", "subject", "wa", "collection", "query", "result", "client", "report", "server", "document", " Response", "error", "description", "results", "res", "connection", "location", "reply", "header"], "selectedPage": ["selectionButton", "selectionHour", " selectedLine", "selectedAction", "lectedHour", "lectedSite", " selectedFile", "electedLine", "namedPage", " selectedSite", "selectedItem", "selectedHour", "selectedButton", "selectionFile", " selectedItem", "namedLine", "lectedAction", " selectedButton", "electedButton", "selectedSite", "electedPage", "lectedLine", "selectionPage", "lectedPage", "selectionpage", "selectedFile", "namedpage", " selectedpage", "namedSite", "selectedpage", "lectedFile", "lectedItem", "electedpage", "lectedpage", "lectedButton", " selectedHour", "selectedLine", "selectionItem", " selectedAction", "selectionAction", "selectionLine", "namedFile"], "page": ["model", "unit", "resource", "ice", "je", "phone", "channel", "queue", "display", "p", "result", "number", "block", "article", "ge", "layout", "per", "connection", "parent", "f", "html", "pool", "child", "account", "point", "po", "cache", "handler", "record", "ip", "peer", "language", "server", "user", "document", "instance", "plugin", "pg", "module", "change", "office", " Page", "fe", "sp", "position", "node", "type", "row", "client", "me", "photo", "Page", "port", "location", "menu", "address", "rule", "image", "section", "site", "view", "age", "message", "pp", "route", "item", "pl", "proxy", "profile", "project", "url"], "portalRequest": ["portalOrder", " portalResponse", "portallingResponse", "portpalAccess", "portugalResponse", "portallServer", "portailResponse", "portelResponse", "portalQuery", "portalAccess", "PortortalPage", "portpalPage", " portalPage", "PortortalRequest", "portallingCommand", "portALResponse", "portialQuery", "portortalAccess", " portalQuery", "portalEvent", "PortalCommand", "PortortalOrder", "PortalRequest", "portpalRequest", "portortalPage", "PortalPage", "portallingPage", "portialPage", "portalResponse", "portialRequest", "portallResponse", " portialRequest", "portelPage", "portailRequest", "PortalResponse", "portALRequest", "portugalUser", "portelCommand", "PortalEvent", " portialQuery", "PortalOrder", "portALEvent", "PortortalResponse", "portialResponse", "portortalOrder", "PortortalUser", "PortalAccess", "portugalOrder", "portbalQuery", "portbalResponse", " portialPage", "portALUser", "portortalRequest", "portortalResponse", "portalPage", "portalUser", "portelRequest", "portortalCommand", "portallingRequest", "portallRequest", "portbalPage", "portallingAccess", "portelQuery", "PortalServer", "PortortalCommand", "PortortalServer", "PortortalAccess", "PortalUser", "portortalEvent", "portailOrder", "portugalEvent", "portailUser", "portpalResponse", "portallUser", "portalCommand", " portialResponse", "portortalServer", "portbalRequest", "PortortalEvent", "portugalServer", "portugalRequest", "portalServer", "portortalUser"], "pageProp": [" pageStr", "pageprop", "PageProp", "agePro", "pluginprop", "pageProperty", "projectPro", "parentProp", "ageprop", "pluginProp", "pageStr", "PageStr", "peerStr", "parentPro", "peerPro", "parentProperty", "parentObj", "pagePro", "projectProperty", "projectprop", "resourceProperty", "resourcePro", " pageProperty", "resourceProp", "PageProperty", "pluginPro", "PageObj", "PagePro", " pagePro", "ageProperty", "resourceprop", "ageProp", "peerProperty", "projectProp", "pageObj", " pageObj", "Pageprop", "pluginProperty", "peerProp"], "possiblePage": ["possibleLine", "PossibilityPages", "patchedLine", "PossiblyLine", "pablePages", "possibilitypage", "puredPage", "possiblyPages", "PossibilityPage", "pablePage", "permanentPage", "patchingPage", "PossiblyOrder", "possibleGroup", "possiblyGroup", "patchedPage", "Possibilitypage", "possiblyOrder", "possibilityPage", "possibleOrder", "possibilityLine", "patchedOrder", "possiblypage", "possiblePages", "Possiblepage", "PossiblePage", "possibleItem", "possiblyItem", "PossibleLine", "PossibleItem", "patchingpage", "PossiblyPage", "permanentLine", "pablepage", "PossibleGroup", "puredItem", "PossiblePages", "PossiblyGroup", "permanentpage", "possiblyPage", "patchingItem", "PossiblyItem", "permanentOrder", "pableLine", "puredpage", "PossibilityLine", "possiblyLine", "patchingGroup", "puredGroup", "PossibleOrder", "patchedpage", "Possiblypage", "possiblepage", "possibilityPages"], "property": ["resource", "section", "config", "prefix", "integer", "duration", "function", "key", "properties", "label", "notation", "table", "Property", "object", "string", "class", "set", "future", "binding", "t", "p", "type", "attribute", "result", "entity", "number", "prop", "layer", "character", "expression", "name", "term", "uration", "operator", "language", "perties", "data", "binary", " Property", "variable", "value", "feature", "maximum", "profile", "project", "f", "header", "address"], "referer": ["Referer", "redrer", "Refre", "Refere", "fere", " refeline", "referers", "afferer", " refiner", "defender", " refre", "refrer", "affere", "redeline", " refrer", " referers", "rederer", " refere", "Refrer", "deferer", "defere", "defber", "defrer", "reerer", "Refender", "Refiner", "Referers", "reiner", " referen", "diffrer", "refender", "refber", "rerer", " refender", "ferers", "referen", "afferen", "diffender", "diffiner", "Referen", "reere", "redber", " refber", "Refeline", "refre", "refeline", "refiner", "frer", "differer", "ferer", "refere", "Refber", "rere", "affrer"], "e": ["err", "de", "o", "eme", "this", "event", "fe", "message", "E", "null", "element", "ed", "d", "er", "ea", "p", "ie", "type", "se", "see", "me", "es", "ception", "a", "ae", "esi", "f", "error", "i", "one", "or", "ele", "exc", "ee"]}}
{"id1": "13122204", "id2": "22264586", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["unpackModel", "UnzipModel", "unzipProject", "UnarchiveModel", "UnarchiveFile", "unpatchFile", "unarchivemodel", "Unzipmodel", "unarchiveFile", "UnzipProject", "Unarchivemodel", "unpatchmodel", "unpackFile", "unarchiveModel", "unpatchModel", "unzipmodel", "unpackProject", "unpatchProject", "unzipFile", "UnarchiveProject", "UnzipFile", "unpackmodel", "unarchiveProject"], "filename": ["File", "folder", "model", "module", "download", "src", "l", "utf", "string", "txt", "files", "fd", "path", "kl", "fil", "Filename", "source", "uri", "SourceFile", "fp", "FILE", "il", "nil", "name", "title", "file", "fn", "username", "database", "fits", "bf", "jet", "loc", "location", "f", "url", "directory"], "tempdir": ["tempath", "TempDir", "tmpdirectory", "tmppath", "temdirectory", "temDir", "TempDIR", "tmpdir", "tempDir", "tmpDir", " tempdirectory", "tmpfolder", "tempdirectory", " tempfolder", "tempDIR", "Tempdirectory", "temfolder", "Tempdir", "temppath", " tempDIR", " tempDir", "tmpDIR", "Tempfolder", "tempfolder", "temdir", " temppath"], "dest": ["folder", "log", "wb", "die", "de", "tar", "temp", "nt", "cont", "walker", "done", "default", "inner", "dc", "dat", "transform", " Dest", "trans", "target", "src", "zip", "sync", "output", "later", "ui", "sup", "home", "comb", "txt", "builder", "usr", "exit", "walk", "export", "dist", "store", "cdn", "session", "st", "handler", "result", "opt", "proc", "flat", "prop", "rest", "dir", "std", "tmp", "test", "Dest", "file", "transfer", "gen", "desc", "delete", "di", "loc", "source", "obj"], "fis": ["filebis", "flisa", "flis", "fbis", " fid", "fsiss", "liss", "fi", "fileis", " fi", "lis", "li", "flbis", "fileid", "fid", "filei", " fiss", "fsisa", "lid", "fisa", "fliss", "fiss", "fsbis", "fileisa", "fsis", "fileiss"], "BUFFER": ["MAPER", " BUFER", " BUFIX", "CUVER", "CUVEN", "TAFFER", " BUUCK", "BUFIX", " BUPER", "SAVER", "TAPER", "BUPER", " BUVER", "TAUCK", "UPFF", "SAFFER", "BOFFER", "MAFIX", "BOFER", "SAPER", "UPVER", "SAUCK", "BOPER", "UPVEN", "TAVER", "BOFIX", "CUFFER", "MAFFER", " BUVEN", "MAFER", "BUFER", "CUUCK", "BUUCK", "CUFF", "BUFF", "UPFFER", " BUFF", "BUVER", "BUVEN", "CUPER"], "zis": ["jis", " ziss", " zisa", "zos", "zists", "jists", "yIS", " zIS", "zbis", "diss", "yis", "yin", "dis", " zas", "zin", "xii", " zbis", "zisa", " zii", "xbis", "zipins", "xists", "dbis", "Zisa", "xi", " zists", " zi", "Zis", "Zas", "zas", "zipas", "ji", " zos", "zipisa", "zi", " zin", "zins", "zipin", "xos", "zipIS", "zipis", "zIS", "jos", "yisa", " zins", "dii", "ziss", "xis", "xiss", "Zins", "zii"], "entry": ["ident", "image", "ou", "de", "lc", "her", "module", "nt", "feed", "end", "inner", "je", "ry", "match", "zip", "Entry", "info", "cat", "element", "pe", "cel", "ace", "spec", "rc", "next", "way", "li", "ie", "source", "part", "line", "record", "result", "ent", "se", "si", "porter", "row", "ce", "la", "pack", "name", "ge", "archive", "server", "file", "ries", "jo", "e", "valid", "id", "iterator", "reader", "enter", "or", "connection", "inc"], "count": ["_", "log", "index", "base", "in", "feed", "end", "coll", "current", "val", "write", "add", "cache", "key", "use", "list", "b", "writer", "read", "code", "pos", "c", "buffer", "core", "next", "ind", "line", "type", "part", "counter", "allow", "len", "number", "length", "start", "size", "name", "sum", "low", "file", "id", "weight", "e", "limit", "cond", "last", "i", "Count", "iter", "time", "f", "max"], "data": ["image", "body", "index", "base", "raw", "feed", "content", "dat", "format", "input", "write", "alpha", "load", "message", "media", "bytes", "info", "read", "pos", "array", "buffer", "next", "d", "DATA", "shift", "record", "result", "len", "number", "block", "length", "size", "start", "name", "pack", "la", "a", "id", "str", "zero", "reader", "value", "batch"], "fos": ["dfops", " fops", "fOS", "afops", " foos", " foes", "bops", "bos", "afis", "afos", "afOS", "dfoes", "dfos", "dfoos", "foes", "xops", "bis", "foos", "xoos", "fops", "xos", "xoes", " fOS", "bOS"]}}
{"id1": "19335986", "id2": "11377441", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["CatchedException", "uncachedException", "CaughtException", "unchandledexc", "Caughtexc", "uncatchedException", "unchandledException", "uncachedexc", "CaughtEvent", "unchandledEvent", "uncatchedEvent", "Catchedexc", "uncachedEvent", "uncaughtEvent", "uncatchedexc", "uncaughtexc", "CatchedEvent"], "t": ["ing", "w", "T", "let", " td", "l", "c", "r", "ed", " T", "g", "tr", "d", "p", "type", "it", "ty", "out", "tree", "title", "te", "tx", "n", "ts", "m", "f", "s"], "e": ["err", "de", "j", "o", "eb", "event", "fe", "ne", "E", "environment", "element", "example", "c", "pe", "code", "r", "ed", "ace", "oe", "d", "be", "ie", "en", "er", "p", "Exception", "se", "ep", "diff", "ce", "me", "eu", "es", "ception", "ae", "esi", "ge", "ev", "data", "error", "f", "i", "el", "enter", "ec", "m", "ele", "exc", "ee", "s"], "display": ["hide", "image", "body", "de", "view", "this", "content", "window", "fe", "profile", "Display", "process", "platform", "play", "object", "show", "page", "status", "style", "summary", "dis", "position", "d", "p", "container", "monitor", "scroll", "design", "me", "app", "report", "host", "layout", "panel", "description", "default", "console", "config", "screen"], "shell": ["image", "body", "log", "mail", "child", "system", "clone", "cl", "launch", "cli", "poll", "sound", "process", "Shell", "l", "b", "environment", "tools", "status", "math", "machine", "buffer", "bash", "gui", "ml", "container", "sb", "sh", "loop", "hell", "xml", "app", "tool", "kernel", " Shell", "h", "server", "live", "sym", "echo", "lock", "el", "console", "m", "host", "exec", "help", "copy"], "message": ["body", "image", "log", "model", "mail", "email", "address", "view", "event", "content", "meter", "essage", "queue", "output", "media", "member", "object", "page", "management", "status", "application", "update", "summary", "flash", "buffer", "mess", "translation", "result", "monitor", " messenger", "response", "xml", "Message", "report", " exception", "request", "msg", "server", "data", "document", "error", "description", "value", "console", "m", "header", "copy"], "e1": ["e3", "E3", " e3", "E1", "E8", " e8", "exc2", "E2", "exc8", "e8", "exc3", "exc1", " e2", "e2"]}}
{"id1": "17791385", "id2": "7276377", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static String checksum(URL url, String algorithm) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(algorithm);\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Could not create an instance of MessageDigest\", ex);\n        }\n        byte[] bytes = new byte[4 * 1024];\n        try {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                int nBytesRead = 0;\n                while ((nBytesRead = in.read(bytes)) > 0) {\n                    messageDigest.update(bytes, 0, nBytesRead);\n                }\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not read message digest for: \" + url.toExternalForm() + \" using algorithm: \" + algorithm);\n        }\n        byte[] checksumValue = messageDigest.digest();\n        return digestAsString(checksumValue);\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", "transferFile", "transferStream", "CopyFile", " copyStream", " copyfile", "Copyfile", "copyStream", "copyfile", "CopyStream", "copyFiles", "CopyFiles"], "src": ["image", "resource", "config", "stream", "inf", "input", "ls", "http", "back", "filename", "b", "sup", "url", "txt", "files", "dist", "ipl", "rc", "st", "sc", "source", "upload", "uri", "sb", "dest", "img", "ins", "sit", "sel", "file", "inst", "sl", "rb", "loc", "sin", "obj", "s"], "dst": ["ststs", "dlt", "stlt", "fdst", "pdfd", "ddfd", "Dst", " dlt", "ddst", "dsts", "fdfd", "ddest", "pdsp", "ddft", "pdst", "pdft", "Ddest", " dsts", "dfd", "dft", "stst", "fdft", "stdest", "dsp", " ddest", "Dsts", "fdsp", "Dlt", "ddsp"], "in": ["ini", "err", "kin", "login", "impl", "inner", "gin", "inn", "input", "In", "bin", "conn", "pin", "r", "IN", "again", "oin", "nin", "sin", "cin", "pull", "ins", "is", "lin", "as", "init", "socket", "inside", "h", "con", "ln", "rin", "id", "file", "data", "i", "win", "reader", "n", "m", "din", "f", "url", "inc"], "out": ["err", "o", "outer", "raw", "temp", "other", "self", "w", "plain", "at", "net", "up", "exp", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "null", "again", "outs", "part", "line", "io", "x", "Out", "client", "off", "ext", "server", "file", "parent", "ex", "i", "n", "inc", "exec", "f", "obj", "copy", "s"], "buf": ["wb", "base", "cmd", "br", "raw", "vec", "val", "bl", "ff", "cur", "count", "queue", "bag", "uf", "b", "cb", "bytes", "cat", "pad", "cap", "bin", "bh", "c", "buff", "buffer", "rc", "fd", "bb", "fb", "bf", "bd", "fl", "v", "lim", "length", "off", "loc", "data", "rb", "bc", "seq", "batch", "uc", "ctx"], "len": ["lc", "err", "base", "nt", "end", "val", "lf", "cl", "ix", "count", "rev", "l", "bin", "cap", "pos", "c", "fd", "split", "ind", "li", "fl", "en", "line", "part", "Len", "all", "lim", "le", "length", "size", "name", "ln", "data", "ll", "lt", "el", "no", "i", "sl", "n", "fin", "f", "lin"]}}
{"id1": "1141361", "id2": "15465293", "code1": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"Usage:  URLDumper <URL> <file>\");\n            System.exit(1);\n        }\n        String location = args[0];\n        String file = args[1];\n        URL url = new URL(location);\n        FileOutputStream fos = new FileOutputStream(file);\n        byte[] bytes = new byte[4096];\n        InputStream is = url.openStream();\n        int read;\n        while ((read = is.read(bytes)) != -1) {\n            fos.write(bytes, 0, read);\n        }\n        is.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"makeRead": ["executeAdd", " executeAdd", "doAdd", " executeREAD", "doRead", " makeREAD", " makePut", "executePut", "doREAD", " executePut", " makeAdd", "executeRead", "doPut", " executeRead", "executeREAD"], "user": ["log", "field", "alias", "write", "mode", "human", "use", "User", "password", "post", "uid", "url", "string", "usr", "USER", "creator", "admin", "item", "token", "custom", "job", "author", "db", "row", "blog", "bug", "users", "name", "word", "server", "username", "comment", "date", "pod", "meta", "host", "project", "install", "owner"], "databaseID": ["DatabaseUID", "databaseKey", " databaseUID", "databaseid", "databaseUID", "DatabaseId", "tableid", " databaseId", "databaseName", "tableKey", "dbUID", "DatabaseID", "connectionid", "dbID", "dbName", " databaseKey", "dbId", "DatabaseName", "databaseId", " databaseid", " databaseName", "connectionID", "tableID", "connectionKey"], "time": ["Time", "depth", "end", "mode", "text", "message", "times", "table", "rate", "post", "tz", "string", "read", "clock", "set", "home", "TIME", "path", "month", "type", "year", "length", "size", "name", "ime", "tim", "host", "id", "port", "money", "value", "str", "comment", "date", "timer", "timeout", "hour", "instance", "source"], "query": ["eries", "q", "Query", "script", "module", "question", "sequence", "function", "filter", "message", "table", "qu", "post", "connection", "update", "string", "code", "sql", "work", "join", "ql", "commit", "command", "sq", "report", "name", "request", "search", "execute", "id", "call", "comment", "error", "database", "timeout", "select", "db"], "statement": ["rule", "opened", "unit", "batch", "slave", "section", "agent", "storage", "this", "ment", "alias", "Statement", "function", "ma", "usage", "study", "message", "parser", "journal", "use", "password", "media", "table", "post", "style", "string", "status", "sql", "builder", "session", "state", "st", "join", "note", "stat", "si", "result", "commit", "mt", "response", "command", "expression", "init", "joined", "volume", "language", "server", "jo", "document", "general", "instance", "comment", "str", "database", "i", "di", "connection", "execute", "memory", "machine", "s"], "count": ["err", "force", "index", "log", "base", "child", "depth", "offset", "found", "content", "check", "expected", "cache", "process", "total", "table", "list", "connection", "code", "more", "state", "part", "type", "counter", "diff", "number", "handle", "cc", "length", "size", "start", "sum", "id", "limit", "cond", "error", "Count", "batch", "inc"]}}
{"id1": "15051083", "id2": "5836744", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getMessagedigature", "getMessageDesignester", "getMessageHashester", "getmessagedigature", "getMessagedigester", "getmessageDigature", "getMessagedigest", "getmessageDigest", "getMessageDesignature", "getMessageDesignest", "getMessageDesignests", "getmessagedigests", "getMessageDigester", "getmessagedigest", "getMessageDigests", "getmessageDigester", "getMessagedigests", "getmessageDigests", "getMessageHashature", "getMessageDigature", "getmessagedigester", "getMessageHashest", "getMessageHashests"], "digest": [" Digest", "dighed", "sandest", "digiter", "feedest", " digger", "hexex", "Digesting", "Diger", "DigEST", " dighed", "Dighed", "digesting", "digester", "Digests", "digex", "hexests", "hexEST", "signiter", " digests", "Digex", "Digester", "hexest", "greatest", " Digeter", "signesting", " digex", "Digeter", "Digiter", "diger", " diger", "greatiter", "digeter", " Digester", "Digested", "sandester", "sandesting", " digeter", "greatested", "signest", "signester", " Dighed", "Digger", "digested", "sandested", " Diger", "signested", "digEST", " digested", " digEST", " Digger", "digger", "Digest", "feedester", "feedested", "digests", "greatester", " digester"], "node": ["index", "resource", "module", "child", "ode", "odes", "point", "self", "root", "event", "global", " Node", "local", "remote", " source", "object", "Node", " nodes", "element", " parent", "route", "path", "source", "uri", " annotation", "entity", "network", " child", "name", " namespace", "internal", "server", "component", "document", "instance", "one", "n", "connection", "config", "location", "parent", "address"], "external": [" External", "resource", "outer", "account", " foreign", "global", "outside", "target", "intern", "local", "remote", "environment", "object", "ternal", "element", "export", " global", " remote", "https", "External", "network", "out", "client", "multiple", "Intern", "name", "internal", "international", "secondary", "reference", "binary", "foreign", "e", "instance", "ex", "n", "source", "tern"], "messageDigest": ["messageDesignester", "messageDest", "messageDigester", "MessageDigenge", "messageMarkest", "messageDested", "messageHashester", "messagedigger", "messageModested", "messageDigenge", "messageMarkenge", "messageSignest", "MessageSignester", "MessageDigest", "messageSignested", " messageHashesting", "messageMarkested", " messageDesignested", " messageDesignger", " messageDigester", " messageHashest", "messageSignenge", "messageHashest", " messageDigesting", "messageSignester", "messageDesignest", " messageDigger", "messageHashested", " messageDesignest", "MessageDigester", "messagedigested", "messageDigger", "MessageSignenge", "messageDesignger", " messageDesignester", "messageDester", " messageDigested", "messageDesignesting", "messageHashesting", "messageModesting", "messageMarkester", "messageModester", "messagedigester", "MessageSignested", "messageDigesting", "MessageSignest", "messageDigested", "messageDenge", " messageHashester", "messageModest", "messageDesignested", "messagedigest", "MessageDigested", " messageHashested"]}}
{"id1": "21395184", "id2": "17158020", "code1": "    @Test\n    public void test30_passwordAging() throws Exception {\n        Db db = DbConnection.defaultCieDbRW();\n        try {\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"5\", 1);\n            PreparedStatement pst = db.prepareStatement(\"UPDATE e_people SET last_passwd_change = '2006-07-01' WHERE user_name = ?\");\n            pst.setString(1, \"esis\");\n            db.executeUpdate(pst);\n            db.commit();\n            p_logout();\n            t30login1();\n            assertTrue(isPasswordExpired());\n            PeopleInfoLine me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().before(DateHelper.now()));\n            t30chgpasswd();\n            assertFalse(isPasswordExpired());\n            me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().after(DateHelper.now()));\n            p_logout();\n            t30login2();\n            assertFalse(isPasswordExpired());\n            t30chgpasswd2();\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"0\", 1);\n            db.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            db.rollback();\n        } finally {\n            db.safeClose();\n        }\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"test30_passwordAging": ["test30_passwordIntroduge", "test30_passwordAgging", "test30_wordAgo", "test30_passwordAggment", "test30_wordAge", "test30_passwordAge", "test30_passwordIntrodugo", "test30_passwordPAge", "test30_wordAggo", "test30_passwordAgo", "test30_passwordPAging", "test30_passwordAgge", "test30_passwordAggo", "test30_passwordIntroduging", "test30_wordAgging", "test30_passwordIntrodugment", "test30_wordAgge", "test30_wordAggment", "test30_wordAging", "test30_passwordPAgo", "test30_passwordAgment", "test30_wordAgment", "test30_passwordPAgment"], "db": ["body", "log", "ver", "base", "nb", "bm", "eb", "storage", "dc", "dat", "pre", "bl", "hub", "DB", "Connection", "cache", "http", "sche", "queue", "table", "b", "conn", "bb", "cb", "bh", "ld", "engine", "driver", "sql", "c", "cf", "gb", "lib", "session", "g", "d", "m", "fb", "bf", "pg", "doc", "Db", "ds", "bd", "bi", "sb", "out", "blog", "dir", "orb", "manager", "pb", "bt", "pub", "con", "loc", "server", "file", "ob", "dh", "lock", "mc", "database", "og", "mb", "n", "bc", "di", "connection", "config", "rb", "f"], "pst": ["psh", "jct", "ppsh", "lst", "prsh", "fst", "ppse", "ppst", "Pct", "prct", "fsts", "psp", "lsp", "pST", "PST", "Pst", "lsts", "ppct", "fST", " pct", "prst", "Pse", "prse", "jsts", " psts", "psts", "pse", "Psts", "jST", "lct", "pct", "Psh", "Psp", "jst", " psp", "fct"], "me": ["kin", "body", "mi", "model", "gone", "fr", "module", "Me", "lia", "site", "meta", "this", "self", "change", "mage", "hi", "ma", "je", "men", "profile", "fe", "age", "master", "ME", "ne", "use", "mu", "que", "ms", "queue", "member", "page", "home", "we", "pe", "My", "oe", "pl", "er", "p", "gui", "line", "mes", "se", "mie", "min", " Me", "le", "where", "la", "ome", "pse", "name", "ae", "ge", "my", "ha", "user", "te", "mor", "e", "life", "go", "theme", "i", "press", "one", "m", "source", "mer", "ee"]}}
{"id1": "3024992", "id2": "20310134", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter_stdIn", "testCopy_readerToWriter_stdin", "testCopy_readerToWriter_Nulls", "testCopy_readerToWriter2nulls", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_writer_", "testCopy_readerToWriter_stds", "testCopy_readerToWriter_null_", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter2nullIn", "testCopy_readerToWriter2null_", "testCopy_readerToWriter2Nullin", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter_writerin", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter_Nullin", "testCopy_readerToWriter_writers", "testCopy_readerToWriter2Nulls", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter_std_", "testCopy_readerToWriter_writerIn", "testCopy_readerToWriter_nulls"], "baout": ["baOUT", "BAouter", "Bain", "baouter", "bonio", "BaOut", "BAOut", " bain", "baash", "Baouter", "baouts", "BAOUT", "Baout", "BAash", "BAio", "bain", "BAin", " baouts", "baOut", "bonin", "bonash", " baOut", "aeOut", "aeouter", "baio", "BAout", "Baash", "aeOUT", "bonout", "Baio", "aeout", "BAouts", "Baouts", "BaOUT"], "out": ["flow", "err", "in", "outer", "write", "output", "OUT", "null", "class", "array", "r", "buffer", "outs", "able", "er", "line", "io", "Out", "Writer", "test", "Output", "file", "reader", "copy", "s"], "writer": ["writing", "her", "letter", "unit", "in", "temp", "outer", "w", "write", "player", "entry", "worker", "wer", "output", "RW", "null", "class", "builder", "driver", "r", "buffer", "wa", "work", "ee", "er", "writers", "io", "pointer", "x", "riter", "Writer", "data", "file", "reader", "rw", "writ", "source", "copy"]}}
{"id1": "19147279", "id2": "14590676", "code1": "    public boolean actualizarDatosFinal(int idJugadorDiv, int idRonda, jugadorxDivxRonda unjxdxr) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET resultado = ?, puntajeRonda = ? \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatementActFinal(unjxdxr);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    public static void download(String address, String localFileName) {\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            URL url = new URL(address);\n            out = new BufferedOutputStream(new FileOutputStream(localFileName));\n            conn = url.openConnection();\n            in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n            System.out.println(localFileName + \"\\t\" + numWritten);\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        } finally {\n            try {\n                if (in != null) in.close();\n                if (out != null) out.close();\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"actualizarDatosFinal": [" actualizarDataoFinal", " actualizarBatosResult", " actualizarBatosComplete", " actualizarBatocResult", " actualizarBatosFinal", " actualizarDataoTotal", " actualizarBatosTotal", " actualizarDatosComplete", " actualizarDatOSFinal", " actualizarBatocTotal", " actualizarDatosResult", " actualizarDataoResult", " actualizarDatOSResult", " actualizarDataoComplete", " actualizarDatosTotal", " actualizarDatocResult", " actualizarDatOSTotal", " actualizarBatocComplete", " actualizarDatocComplete", " actualizarDatOSComplete", " actualizarDatocFinal", " actualizarBatocFinal", " actualizarDatocTotal"], "idJugadorDiv": ["idJugadorDoc", "idJugaderDec", "idJudadorDIV", "idJubordOrd", "idJubadorOrd", "idJugaderDoc", "idJugrarDec", "idJugaderDIV", "idJubordDiv", "idJugordDIV", "idJubordDec", "idJugadeDIV", "idJubadorDoc", "idJubadorDiv", "idJugordDec", "idJubordDoc", "idJudadorDiv", "idJugaderOrd", "idJugordDiv", "idJugaderDiv", "idJugadeDec", "idJugadeDiv", "idJugrarDoc", "idJugordOrd", "idJugadorDIV", "idJubadorDec", "idJudadeDec", "idJugadorOrd", "idJudadeDiv", "idJugordDoc", "idJudadorDec", "idJudadeDIV", "idJugadorDec", "idJugrarOrd", "idJugrarDiv"], "idRonda": ["idGrado", "idGronda", "pidRora", " idronda", "idRona", "idrona", "idrora", "idRhanna", "idRhora", "idGrona", "idRhado", "idGrora", "pidRhora", "idRanna", " idRora", "idRhona", "pidRhado", "idrado", "pidRona", " idRanna", "idRora", "pidRonda", "idronda", " idranna", "pidRado", "pidRhonda", " idrora", " idRona", "idranna", " idrona", "pidRhona", "idRhonda", "idRado"], "unjxdxr": ["unjxdexr", "unjxdxtr", "unjxdxR", "unjxdxxR", "unjxdxtrs", "unjxdxl", "unjxfexrs", "unjxfxR", "unjddxxR", "unjxdxxer", "unjxfexR", "unjxdexrs", "unjxdxtR", "unjxdxter", "unjxdxrs", "unjxfxrs", "unjddxxl", "unjxdxxl", "unjxdddrs", "unjxfxr", "unjddxl", "unjxdexl", "unjddxR", "unjxdexR", "unjddxxer", "unjxdxxr", "unjxdddr", "unjddxxr", "unjxdxtl", "unjxdxer", "unjddxer", "unjxdddR", "unjddxr", "unjxdexer", "unjxfexr"], "intResult": ["IntRate", "intResponse", "IntResponse", "mintOrder", "longResponse", "longCode", "intCode", "INTResult", " intRes", "intRest", "ntResponse", "longRes", "IntReturn", "mintRate", "intOrder", "intReturn", "longResult", " intRest", "IntRest", "ntResult", "intRes", "IntResult", " intReturn", "ntCode", "IntRes", "INTReturn", "INTRes", "ntRes", "mintReturn", "IntOrder", "mintResult", "IntCode", "intRate", " intRate", "INTRest", " intOrder"], "sql": ["dd", "log", "cmd", "section", "printf", "nl", "plan", "SQL", "sync", "l", "conn", "pr", "url", "string", "params", " SQL", "query", "join", "job", "ql", "eps", "sb", "mt", "sq", "socket", "ssl", "statement", "joined", "msg", "search", "fn", "limit", "str", "sl", "comment", "database", "dl", "select", "db", "pg", "QL"], "connection": ["log", "index", "section", "ion", "function", "Connection", "table", "environment", "conn", "writer", "application", "driver", "c", "engine", "position", "condition", "collection", "session", "relation", "BC", "query", "handler", "container", "client", "cc", "character", "context", "manager", "statement", "communication", "cp", "proxy", "con", "loc", "server", "document", "connect", "database", "reader", "ctx", "connected", "config", "bc", "db", "pg", "socket"], "ps": ["ports", "posts", "syn", "changes", "po", "ops", "Ps", "ls", "pc", "details", "ns", "ping", "pers", "ms", "conn", "mp", "pr", "sp", "pe", "pp", "pps", "params", "pa", "p", "ds", "relations", "os", "eps", "cs", "qs", "ins", "hs", "rs", "ups", "pse", "cp", "gs", "proxy", "ips", "bs", "PS", "ks", "ts", "pg", "ppa"]}}
{"id1": "11840277", "id2": "15810440", "code1": "    protected static void clearTables() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"delete from Objects\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (1, 'Money value')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (2, 'Date')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (3, 'Unix path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (4, 'Dos path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (5, 'Time')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (6, 'IP address')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (7, 'Internet hostname')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (8, 'Number')\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"clearTables": ["cacheTableows", "createStaches", "clearTemings", "clearBables", "clearBings", "clearStaces", "clearTableables", "clearTations", "clearContows", "clearTemables", "cacheTableations", "cacheTables", "createTables", "clearStables", "clearTings", "cacheTableings", "clearTaces", "createTaches", "cacheTations", "clearStaches", "clearTableings", "createStaces", "clearContaces", "clearBaches", "createStables", "clearTemations", "clearContaches", "cacheTows", "clearBations", "clearBaces", "clearTows", "cacheTableables", "clearTemows", "createTows", "clearStows", "cacheTings", "createTaces", "clearTableations", "clearTaches", "clearBows", "clearContables", "createStows", "clearTableows"], "conn": ["enc", "ou", "lc", "log", "jc", "nt", "config", "coll", "dc", "oci", "nc", "open", "Connection", "ca", "ns", "cache", "exec", "ch", "wd", "cat", "ann", "cb", "bb", "act", "c", "sql", "cf", "ct", "session", "state", "rc", "path", "di", "ci", "p", "pg", "cmp", "org", "oss", "ai", "mt", "client", "cc", "pub", "close", "cm", "ssl", "cp", "col", "ac", "co", "con", "h", "cn", "server", "ob", "dn", "cond", "connect", "lock", "sth", "Conn", "mc", "error", "n", "ctx", "Connect", "connection", "loc", "db", "conf", "obj"], "stmt": [" stma", "stlt", "estmt", "stma", "actmt", "est", "ctmt", "actmn", " stmi", " stager", "tct", "dmt", "sttor", " stmc", "Stap", "stmn", "Sttx", "ewd", "stmm", "Stmd", "putwt", "STgr", "putml", "putlt", "Sttor", "stgr", "putmt", "putmm", "putma", "stprint", "ftbm", "str", "ldmn", "emt", "stsst", "tnt", "ctm", "STmt", "putager", "Stmt", " stct", "Stwt", "stsmt", "stwd", "ctr", "ldma", "Stlt", "stnt", "actnt", "strlt", "STbm", "STlt", "stsprint", "ssbm", "putap", "StMT", "stwt", "estwt", "istmt", "stml", "ctql", "stbm", "Stm", " stm", "dm", " stql", "istMT", " stmd", "STmd", "ctmd", "dr", "Stmm", "sswt", " stml", "Stmn", "stMT", "playwt", "puttor", "ssmt", "sttx", "stmi", "stap", "ftmn", "Stnt", "stql", "Stml", "estm", "putMT", "STMT", " stlt", "istgr", "STwd", "stst", "actmi", " stap", "dql", "STmn", " stgr", "stmc", " stmn", "putm", " stbm", "playtor", "stct", "ctgr", "strml", "tm", "stmd", "strMT", "Stgr", "istmn", "putbm", "Stmc", "playtx", "eprint", "Stct", "Stmi", "stager", "playmt", "puttx", "stswd", "putmn", " str", "stm", "strmt", "ldmt", "STmc", " stnt", "ftlt", "STst", "STprint", "estmm", "ldager", "tmt", "ftmt", "ssmn", " stwt"]}}
{"id1": "17947247", "id2": "12417893", "code1": "    public String postURL(String urlLocation, ArrayList headers, String content, HashMap postVariables, RenderEngine c) throws Exception {\n        String postContent = null;\n        if (postVariables != null) {\n            boolean firstElement = true;\n            postContent = new String();\n            Iterator elements = postVariables.keySet().iterator();\n            while (elements.hasNext()) {\n                String key = (String) elements.next();\n                String val = (String) postVariables.get(key);\n                if (firstElement) {\n                    postContent += Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                    firstElement = false;\n                } else {\n                    postContent += \"&\" + Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                }\n            }\n            elements = null;\n        } else {\n            postContent = content;\n        }\n        Debug.log(\"Connecting to URL '\" + urlLocation + \"', content '\" + postContent + \"'\");\n        URL url = null;\n        try {\n            url = new URL(urlLocation);\n        } catch (MalformedURLException e) {\n            Debug.log(\"Unable to retrieve URL '\" + urlLocation + \"': \" + e.getMessage());\n            return null;\n        }\n        StringBuffer lines = new StringBuffer();\n        HttpURLConnection conn = null;\n        boolean contentLengthFound = false;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            loadCookies(urlLocation, conn, c);\n            if (headers != null) {\n                for (int i = 0; i < headers.size(); i++) {\n                    String header = (String) headers.get(i);\n                    String key = header.substring(0, header.indexOf(\":\"));\n                    String value = header.substring(header.indexOf(\":\") + 2);\n                    if (key != null && key.equalsIgnoreCase(\"content-length\")) {\n                        contentLengthFound = true;\n                    }\n                    Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                    conn.setRequestProperty(key, value);\n                }\n            }\n            if (!contentLengthFound) {\n                Debug.log(\"Adding new request header 'Content-Length'='\" + postContent.length() + \"'\");\n                conn.setRequestProperty(\"Content-Length\", Integer.toString(postContent.length()));\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(postContent);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                lines.append(line);\n                lines.append(\"\\r\\n\");\n            }\n            handleHeaders(urlLocation, conn.getHeaderFields());\n            wr.close();\n            rd.close();\n            wr = null;\n            rd = null;\n        } catch (IOException e) {\n            if (conn != null) {\n                lines = new StringBuffer();\n                try {\n                    throw new Exception(\"Server returned error code '\" + conn.getResponseCode() + \"': \" + conn.getResponseMessage());\n                } catch (IOException ee) {\n                    throw new Exception(\"Unable to report error codes: \" + ee.getMessage());\n                }\n            }\n            Debug.log(\"I/O Exception occurred while communicating with endpoint: \" + e.getMessage());\n            return lines.toString().trim();\n        } catch (Exception e) {\n        }\n        url = null;\n        conn = null;\n        return lines.toString().trim();\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"postURL": [" posturl", " postSSL", "posturl", "POSTURL", "POSTSSL", " postUrl", "PostSSL", "postSSL", "POSTurl", "postUrl", "PostUrl", "POSTUrl", "PostURL", "Posturl"], "urlLocation": ["urlLocated", "URLlocation", "httpSource", "URLSource", " urlLocated", "URLRegion", "httpLoc", "urlPath", "filePath", "URLAddress", "resourceRegion", "httpDirectory", "queueLOC", "URLDirectory", "slRegion", "httpLocation", "buildPath", "buildLocation", "baseDirectory", "resourcePath", " urlDirectory", "URLLoc", "resourcelocation", " urllocation", "urllocation", "queueLoc", "urlSource", "buildLocated", " urlAddress", "urlRegion", "httpAddress", "URLPath", "baseLoc", "urlAddress", "fileLOC", "queueLocation", " urlSource", "URLLocation", "fileLocation", "resourceDirectory", "buildlocation", "urlLOC", "urlLoc", "slLoc", "resourceLoc", "fileLoc", "baseLocation", "resourceLOC", "slLocation", "httplocation", "queuePath", "baselocation", "sllocation", " urlPath", "urlDirectory", "URLLocated", "resourceLocation"], "headers": ["body", "resources", "archives", "html", "versions", "boxes", "vals", "comments", "books", "authors", "codes", "posts", "keys", "types", "errors", "ppers", "heads", "head", "workers", "plugins", "breaks", "links", "services", "hers", "ids", "http", "details", "players", "frames", "rooms", "vers", "properties", "events", "styles", "limits", "files", "params", "ors", "groups", "drivers", "rows", "quarters", "writers", "builders", "cells", "fields", "liners", "response", "values", "qs", "users", "blogs", "features", "pages", "host", "cats", "names", "results", "strings", "parts", "ers"], "content": ["body", "resources", "model", "html", "resource", "Content", "raw", "temp", "script", "comments", "cont", "create", "stream", "current", "continue", "input", "json", "load", "message", "text", "cache", "output", "media", "object", "page", "string", "code", "status", "array", "cf", "buffer", "container", "response", "context", "xml", "title", "request", "server", "data", "document", "description", "comment", "activity", "connection", "location", "memory", "address"], "postVariables": ["postvariable", "postVarables", "postParars", "Postvariars", " postVariable", "postParables", " postVariams", "postVariars", "postvariams", " postvariable", "postvariants", "postParants", "Postvariables", "postGenerable", "postParatures", "postIteratures", " postvariatures", "postVariants", "Postvariants", "postVariable", "postvariables", "Postvariories", "postVarories", "postVarars", "postIterants", " postvariams", " postVariatures", "postParams", " postvariants", "postIterams", "postParable", "PostVariars", "postvariatures", "postGenerants", " postvariables", " postVariants", "postVariams", "PostVariables", "postvariars", "postVarants", "postVariories", "postGenerams", "PostVariories", "PostVariants", "postVariatures", "postIterables", "postParories", "postGenerables", "postvariories"], "c": ["enc", "lc", " dc", "dc", "w", " controller", "cli", "cache", " cc", "l", "b", "cb", "engine", "C", "driver", "vc", "r", "code", "cf", "g", " C", "rc", "t", "d", "ci", "p", "conf", "container", "cs", " cr", "ce", "client", "cc", "context", "cp", "tc", "h", "e", " ec", "ctx", "or", "ec", "config", "cr", "f"], "postContent": ["precontent", "preContent", "objectValue", "putEntity", "objectMessage", " postText", "preMessage", "objectcontent", "uploadValue", "uploadContent", "ostHeader", "Postcontent", "putValue", "PostText", "ostMessage", "POSTContent", "uploadMessage", "ostContent", "PostString", " postcontent", "endMessage", "postString", "postText", "POSTMessage", "endHeader", "postHeader", "postMessage", "uploadcontent", "PostMessage", "endContent", " postMessage", " postEntity", "PostContent", " postString", "preString", "objectEntity", " postValue", " postHeader", "postValue", "postContents", "postEntity", " postContents", "POSTText", "putcontent", "postcontent", "POSTValue", "putContent", "preValue", "PostValue", "ostContents", "objectContent", "endContents"], "elements": ["Elements", "evers", "eelement", "eulem", "feodes", "selem", "ellers", " evers", "eachers", "eelem", "felement", "nelements", "Elem", "selements", "element", "nelem", "eelements", "felem", "eeodes", "Eators", "nelement", "felements", "eators", "eodes", "belements", "seators", " eators", "eullers", "Eachers", " eachers", " elem", "euachers", "beators", "Element", " element", "elem", "neodes", "Ellers", "belement", "Evers", "eulements", " ellers", "bevers", "severs"], "key": ["model", "field", "q", "temp", "step", "property", "group", "page", "hop", "element", "var", "query", "v", "block", "name", "ge", "ray", "search", "seed", "parent", "f", "service", "child", "point", "check", "function", "patch", "param", "ry", "info", "style", "string", "code", "hash", "k", "ip", "cookie", "id", "variable", "life", "Key", "loc", "base", "right", "change", "fix", "role", "match", "entry", "KEY", "req", "reason", "object", "option", "ie", "type", "wire", "x", "mac", "data", "lock", "ee", "link", "rule", "ver", "index", "letter", "section", "keys", "root", "coll", "order", "head", "pick", "ke", "label", "pe", "ace", "item", "part", "sign", "y", "kw", "start", "col", "word", "my", "cell", "e", "feature"], "val": ["ver", "sol", "base", "vals", "vr", "serv", "pt", "Val", "py", "VAL", "Value", "ref", "text", "string", "element", "iv", "pos", "var", "item", "li", "doc", "arg", "ret", "v", "len", "x", "il", "la", "sel", "loc", "data", "al", "valid", "eval", "alt", "ol", "sl", "el", "vol", "vi", "rel"], "firstElement": [" firstEl", "firstelement", "lastLetter", "firstLine", "firstLetter", " firstAddress", "singleLine", "lastEntry", "lastAddress", "nextElement", "firstEl", "singleelement", "FirstLine", "nextLetter", " firstelement", "lastEl", " firstLetter", "FirstEntry", "singleEntry", "firstEntry", "nextelement", "Firstelement", "lastElement", "FirstAddress", "firstAddress", "FirstElement", " firstLine", "lastelement", "nextEl", " firstEntry", "singleElement"], "url": ["image", "link", "log", "URL", "base", "resource", "service", "www", "fr", "impl", "config", "coll", "download", "Url", "entry", "channel", "ls", "http", "cert", "l", "b", "object", "page", "session", "path", "fl", "result", "org", "uri", "build", "pull", "client", "ur", "loader", "ssl", "location", "proxy", "server", "host", "file", "ll", "gl", "user", "el", "sl", "connection", "loc", "source", "f"], "lines": ["body", " msg", " params", " buffers", " text", "ls", "Line", "l", "b", " r", "string", "buf", "buffer", " results", "result", " Lines", " code", "out", " messages", "response", "data", "str", " strings", "strings", " data", "s"], "conn": ["enc", "conv", "serv", "coll", "dc", "cli", "nc", "pc", "net", "open", "Connection", "http", "ca", "cache", "sync", "exec", "ns", "l", "ch", "cb", "cat", "ann", "act", "cf", "ct", "resp", "rc", "session", "ci", "en", "oss", "client", "auth", "socket", "ssl", "col", "co", "reg", "con", "h", "cn", "loc", "dn", "connect", "lock", "Conn", "ctx", "cp", "connection", "config", "db", "conf"], "i": ["ini", "z", "index", "j", "oi", "chi", "end", "depth", "hi", "inner", "phi", "ii", "fi", "ix", "count", "slice", "mu", "b", "info", "ui", "ri", "pi", "r", "gi", "k", "li", "d", "ci", "p", "type", "multi", "si", "xi", "io", "I", "it", "v", "uri", "ai", "eni", "bi", "x", "y", "ip", "ori", "h", "ti", "id", "qi", "e", "iu", "u", "n", "di", "f"], "header": ["her", "field", "format", "property", "filename", "queue", "page", "result", "layer", "length", "name", "hr", "component", "comment", "connection", "host", "cover", "body", "service", "patch", "protection", "column", "string", "code", "driver", "token", "handler", "response", "handle", "character", "cookie", "server", "Header", "reader", "dr", "prefix", "detail", "inner", "event", "entry", "version", "standard", "member", "definition", "er", "type", "client", "request", "data", "port", "second", "date", "address", "rule", "letter", "index", "section", "offset", "metadata", "head", "player", "filter", "message", "back", "writer", "border", "heading", "buffer", "padding", "frame", "title", "h", "description", "iter", "profile"], "value": ["lc", "letter", "model", "section", "end", "current", "format", "json", "property", "Value", "version", "text", "message", "widget", "label", "media", "object", "style", "string", "element", "definition", "null", "option", "vector", "item", "padding", "VALUE", "hello", "type", "sv", "v", "va", "expression", "name", "test", "language", "server", "data", "range", "valid", "alt", "variable", "vi", "feature", "description", "default"], "contentLengthFound": ["contentlengthLeft", "loadSizefound", "contentBufferfound", "contentLenFound", "contentSizefound", " contentLengthLeft", "contentLengthfound", "contentlengthFound", "contentBufferFound", " contentlengthFound", " contentlengthLeft", "contentBufferLost", "contentLenLost", "loadLengthfound", "contentLengthLost", " contentSizeFound", " contentSizefound", "contentSizeLost", "contentStringFound", "contentLengthLeft", "contentStringfound", "loadSizeFound", "contentLenfound", " contentlengthfound", "contentStringLeft", " contentLengthfound", "contentSizeLeft", " contentSizeLost", "contentlengthfound", "contentSizeFound", " contentLengthLost", "loadLengthFound"]}}
{"id1": "160739", "id2": "14878593", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createInputReader", "createInputStream", " createInputFile", "createOutputSteam", " createIOReader", "createInputFile", " createByteReader", " createByteStream", " createIOStream", " createOutputFile", " createIOFile", "createInputSteam", " createInputSteam", " createByteFile", " createIOSteam", " createOutputSteam", " createOutputReader", " createInputStream", "createInputReader", "createOutputReader", " createByteSteam", "createOutputFile"], "inFile": ["incFiles", "inputfile", "inStream", "inputStream", "insFiles", "outFiles", "inputFiles", "sourceFile", "sourcefile", "inputFile", "outStream", "insfile", "incfile", "incFile", "outfile", "insStream", "incStream", "inFiles", "infile", "insFile", "sourceFiles", "sourceStream"], "outFile": ["workingStream", "workTime", " outStream", "inputfile", " outDirectory", "outTime", "workfile", "workingfile", "inputDir", " outfile", "outDir", "workFile", "workingFile", "targetStream", "inTime", "outDirectory", "workingDirectory", "inputFile", "targetfile", "targetFile", "workDir", "outStream", "inputTime", "outfile", "targetDirectory", "inDir", "infile"], "k_blockSize": ["k_lockLength", "k_bitCount", "k_blockCode", "k_byteCount", "k_byteLength", "k_lockCode", "k_lockLen", "k_blocksSize", "k_blockLen", "k_BlockSize", "k_bitSize", "k_bitInfo", "k_lineSize", "k_lockCount", "k_BlockLength", "k_lineCount", "k_BlockCount", "k_byteLen", "k_blocksLength", "k_byteSize", "k_BlockCode", "k_blockInfo", "k_byteInfo", "k_blockLength", "k_blocksCount", "k_blockCount", "k_lockSize", "k_lineInfo", "k_blocksLen", "k_byteCode"], "byteCount": [" byteSum", " byteLen", "flushSize", "ByteSize", "ByteSum", "blockCount", " bytecount", "byteLen", "characterSize", "flushcount", "Bytecount", "byteLength", "flushLength", "blockLength", " byteSize", "byteSize", "characterLength", "byteSum", "bytecount", " byteLength", "characterCount", "ByteLen", "characterLen", "blockSum", "flushCount", "ByteLength", "blockSize", "ByteCount"], "buf": ["base", "cmd", "feed", "vec", "config", "flush", "feat", "src", "queue", "bag", "uf", "bytes", "b", "cb", "bh", "cap", "background", "font", "buff", "border", "buffer", "rc", "fd", "fb", "bf", "result", "Buff", "len", "img", "cas", "tmp", "alloc", "ucc", "la", "brace", "loc", "data", "cv", "rb", "ctx", "seq", "batch", "Buffer", "exc", "append"], "ofp": ["fort", "afl", "OFp", "OFnp", "OFl", "Oftp", "forp", "Ofc", "afnp", "Ofp", "OFtp", "ofl", "Ofnp", "OFt", "oft", "ofnp", "forc", "oftp", "afp", "Oft", "fortp", "afc", "ofc", "Ofl", "OFc"], "zos": ["z", "iffs", "zes", "zx", "ls", "lins", "oda", "liquid", "webkit", "zon", "tz", "zy", "nox", "forge", "bes", "os", "zers", "zl", "iframe", "rez", "modules", "zen", "fits", "los", "rons", "za", "kos", "gz", "uz", "zar", "ops", "zig", "bos", "hz", "nz", "packs", "ZA", "zn", "inos", "obs", "core", "outs", "zag", "ros", "ossus", "obb", "bitcoin", "dylib", "zona", "oses", "soon", "budget", "zi", "lol", "zb", "utils", "osi", "zip", "zyk", "ws", "ZI", "ogl", "zo", "abi", "ozo", "zik", "robe", "zh", "enos", "zer", "js", "cfg", "zin", "css", "cos", "ses", "owicz", "oS", "bs", "jas"], "osw": ["lswo", "eshell", "osy", "ossow", "osssw", "isnow", "osow", "ossww", "essw", "osswd", "oshell", "bwo", "isd", "eswd", "esow", "osnow", " osow", "osws", "ossfw", "esnow", "osd", " osfw", "issw", "esfw", "esy", "isw", "lsx", "osshell", "ossnow", "osfw", "esww", "esd", "bsws", " osww", "osx", "ossw", "ishell", "oswo", "oswd", "bws", "bsx", "iswd", "osww", "lsw", "bsw", "ossy", "lsws", "esw", "isy", "bx", "bswo", "ossd"], "bw": ["bbw", "Bw", "lw", "Bew", "lbsw", "bbwh", " bws", "bwe", "fr", "owa", "fbW", "bbaw", "oaw", "Bws", "bz", "fbw", "Bwa", "bbew", "abwe", "baw", "lbz", "abw", "fsw", "ebwe", "lbw", "owu", "fw", "fbwe", "bbz", " bew", "ow", "lbws", "ebW", "fwh", "fwa", "lbwh", "lx", "abwd", "ebw", " bwu", "lwa", "bwu", " bwa", "bew", " baw", "fx", "bws", "bwh", "fbwd", "bW", "bbwa", " bz", "lsw", "bwa", "lbwa", "bbwu", "bsw", "bwd", "ebwd", "bbws", "bx", "abW", "lbr", " bwh", "lbx"], "zot": ["zerott", "aziot", "jit", "zita", "zeros", "azor", "zerot", "zerori", "zerit", "azot", " ziot", "azott", "Zot", "zott", "Zott", "Zit", "ziot", "jot", "Zita", "jori", "Zor", "Ziot", "zor", "zori", "jos", "azit", " zori", "zerita", " zor", "azita"], "ifp": ["IFi", "ipb", " iff", "ifi", "Ifi", "ifb", "Ifc", " ifi", " ifl", "IFb", "IFf", "ipl", "IFl", "ifc", " ifb", "Iff", "ipc", "iff", "ifl", "ipp", "IFp", "IFc", "Ifp", " ifc"], "zis": ["jis", "zisi", " zib", "jisi", "jit", " zIS", "xits", " zisi", "zib", "zip", "xais", "xisi", " zits", "zenais", "zeis", "xit", "zenis", "Zis", "zenIS", "jits", "zipits", "zipiss", "xIS", "zeip", "Zits", "Ziss", "Zip", "zeiss", "xis", "zIS", "zeits", "xib", " zais", "zenib", "ziss", "zais", "zits", "zipip", "zipis"], "isr": ["irrc", "rispr", "iscr", "risr", "risrb", "ISrc", "ispr", "ISr", "isscr", " isrs", "issrs", "ISpr", "irr", " issr", "isrs", "irrb", "IScr", "isssr", "isrc", "ISrs", "isrb", "issr", "risrc", "irpr", " iscr", "ISsr", "ISrb"], "br": ["body", "err", "bsp", "lr", "fr", "kr", "HR", "bl", "arr", "cro", "ocr", "yr", " fr", "b", "ch", "ctr", "bp", "sp", "r", "ber", "gr", "tr", " dr", "ibl", "bro", "obl", "div", "Br", "ibr", "BR", "mr", "img", "rs", "hr", " BR", "bar", "sr", "rib", "ob", "browser", "str", "rb", " Br", "bc", "bh", "obi", "shr"], "zit": ["zith", "zite", "xic", "zeita", "zic", "jit", "zita", "zipith", "zipite", "zip", "zipIT", "zenits", "zenit", " zip", "zeIT", "jic", "jita", "zenith", " zits", "zitter", "jip", "zeitter", "xit", "jIT", "zipit", "zipita", "xi", "jite", " zi", " zic", " zite", "jits", "ji", "zipits", "zIT", "zipitter", "zenitter", "zeith", "zeits", "zeit", "xith", " zith", "jith", "zits", "zipip", "zi"]}}
{"id1": "20751378", "id2": "8064604", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"hashPassword": ["hashPass", "cryptpassword", "signpassword", "hashWord", "cryptPass", "signPass", " hashPass", "cryptPassword", "hashpassword", " hashWord", "signWord", " hashpassword", "signPassword", "cryptWord"], "password": ["encrypted", "Password", "sha", " Password", "prefix", "content", "w", "input", "plain", " passwords", "pattern", "text", "message", "cache", "key", "wd", "pad", "string", "code", "pass", "crypt", "token", "path", "padding", "phrase", "p", "number", "mac", "secret", "command", "auth", "name", "PASS", "word", "user", "data", "seed", "username", "security", "sword", "description", "database", "words", "python", "address"], "hash": ["her", "sha", "height", "hex", "history", "format", "json", "proof", "result", "number", "ashes", "length", "Hash", "search", "call", "value", "pkg", "host", "memory", "log", "html", "pool", "oh", "check", "dig", "cache", "style", "string", "code", "math", "gh", "kh", "phrase", "uild", "build", "handle", "secret", "ssh", "mod", "id", "user", "error", "msg", "copy", "base", "match", "version", "text", "bolt", "replace", "ruby", "update", "array", "addr", "rh", "mac", "sum", "hed", "dump", "ha", "alt", "put", "security", "tag", "address", "index", "root", "square", "message", "key", "work", "sh", "ash", "auth", "h", "url"], "md": ["dd", "nd", "nm", "sha", "cmd", "am", "dig", "metadata", "ma", "amd", " MD", "hd", "mm", "mad", "xd", "ME", "ms", "wd", "vd", "km", "gb", "der", "grad", "mand", "d", "m", "kg", "bd", "pm", "df", "sm", "mg", "mac", "mt", "gd", "od", "sd", "MD", "Cmd", "mod", "dh", "pd", "mag", "dm", "mc", "f", "mb", "hm", "meta"]}}
{"id1": "7945594", "id2": "9846843", "code1": "    public static void fileDownload(String fAddress, String destinationDir) {\n        int slashIndex = fAddress.lastIndexOf('/');\n        int periodIndex = fAddress.lastIndexOf('.');\n        String fileName = fAddress.substring(slashIndex + 1);\n        URL url;\n        try {\n            url = new URL(fAddress);\n            URLConnection uc = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n            File file = new File(destinationDir + \"/download.pdf\");\n            FileOutputStream fos = new FileOutputStream(file);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos));\n            int inputLine;\n            while ((inputLine = in.read()) != -1) out.write(inputLine);\n            in.close();\n        } catch (Exception ex) {\n            Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 0, "substitutes": {"fileDownload": [" filePull", "urlDownload", " filedownload", "folderPull", "folderURL", "urlPull", "filedownload", "folderdownload", "urlURL", "urldownload", " fileURL", "fileURL", "folderDownload", "filePull"], "fAddress": ["sfOrder", "rfMessage", "rfAddress", " fEmail", " fPath", " faddress", "urladdress", "urlAdd", "bLocation", " fLocation", " fOrder", "bAddress", "bEmail", "faddress", "baddress", "sfAdd", "fingAddress", "fileAddress", "fPath", "fAdd", "bPath", " fAdd", "sfPath", "fMessage", " fMessage", "fOrder", "sfMessage", "fingAdd", "sfAddress", "urlAddress", "fingaddr", "rfLocation", "urlOrder", "fileLocation", "FAdd", "sfaddress", "FAddress", "fingEmail", "FLocation", "fileAdd", "bAdd", " faddr", "fEmail", "rfaddress", "fLocation", "faddr", "sfLocation", "baddr"], "destinationDir": ["DestributionArea", "destippingArea", "declinatedDar", "destinationPath", "destippingDir", "destinationDIR", "destineDur", "DestributionDir", "declinatedDur", "destinationDar", "destinatedDar", "destippingDirectory", "destinatedPath", "destativeDirectory", "destineDir", "destributionDirectory", "destinationArea", "declinationDar", "destributionDir", "destinationDur", "destributionPath", "destributionDIR", "destinatedDir", "DestributionDIR", "declinationPath", "destinatedDur", "DestributionDirectory", "declinationDir", "destativeDir", "destinePath", "declinatedPath", "destinationDirectory", "DestinationDir", "DestinationDirectory", "destributionArea", "DestinationArea", "destippingDIR", "destativeDIR", "declinationDur", "destributionDur", "DestinationDIR", "destineDar", "destributionDar", "destativeArea", "declinatedDir"], "slashIndex": ["SlashCount", "sllashindex", "Slashindex", "sllashLength", "slushLength", "slashLength", "slashedCount", "slushIndex", "slargeCount", "SlashedIndex", "sllashCount", "slashedIndex", "slashedindex", "SlashIndex", "slushindex", "slashindex", "slashedLength", "slargeLength", "slashCount", "sllashIndex", "SlashLength", "Slashedindex", "SlashedCount", "slargeIndex", "slargeindex", "SlashedLength"], "periodIndex": [" periodStart", "moneyStart", "dollarindex", "periodOffset", " periodOffset", "moneyindex", "moneyIndex", "dollarIndex", "moneyOffset", "dollarStart", "periodindex", " periodindex", "dollarOffset", "periodStart"], "fileName": ["FileName", "filename", "fPath", "Filename", "fileAddress", " filename", "fName", "fname", " filePath", "FilePath", " fileAddress", "filePath", "FileAddress"], "url": ["re", "image", "link", "log", "ou", "URL", "base", "resource", "service", "feed", "uu", "www", "ul", "download", "Url", "open", "channel", "up", "http", "l", "api", "ch", "conn", "page", "string", "c", "bel", "path", "li", "fl", "rel", "org", "uri", "plug", "blog", "bug", "ur", "oc", "socket", "ssl", "proxy", "loc", "server", "user", "ll", "ob", "u", "str", "sl", "rl", "connection", "config", "web", "f"], "uc": ["com", "ou", "lc", "UC", "uu", "cci", "stream", "ul", "um", "nc", "pc", "cur", "usc", "hub", "anc", "http", "fc", "cu", "conn", "uci", "soc", "c", "rc", "sc", "ci", "unc", "cc", "cus", "ucc", "oc", "auc", "ac", "tc", "con", "ec", "union", "u", "mc", "bc", "connection", "exc"], "in": ["ini", "err", "image", "login", "this", "stream", "inner", "inn", "gin", "input", "cli", "In", "up", "bin", "conn", "b", "c", "r", "IN", "rc", "again", "source", "nin", "io", "it", "cin", "ins", "into", "is", "lin", "init", "socket", "ac", "inside", "con", "data", "reader", "i", "n", "din", "f", "inc", "s"], "file": ["File", "folder", "log", "base", "o", "letter", "resource", "rule", "this", "to", "ile", "fe", "up", "zip", "filename", "output", "l", "b", "full", "page", "class", "files", "path", "line", "io", "place", "fp", "book", "dir", "FILE", "name", "socket", "data", "e", "per", "connection", "source", "parent", "f"], "fos": ["fileos", "sfOS", "fo", "fob", "sfos", " fops", "fOS", "fis", " fo", " fob", "FOs", "fileOs", "FOS", "fOs", "Fos", "Fis", "Fob", "sfis", "fops", "Fops", " fOs", " fOS", "fileops", "fileob", "Fo", " fis", "sfo"], "out": ["err", "ou", "log", "o", "outer", "inner", "flush", "to", "w", "write", "plain", "net", "up", "sync", "output", "OUT", "writer", "bin", "b", "update", "string", "again", "outs", "work", "line", "io", "Out", "block", "init", "data", "down", "inc", "exec", "f", "copy", "s"], "inputLine": ["InputLine", "outputRow", " inputEl", "outputBlock", "outputL", "Inputline", "outputEl", "outputline", "errorRow", " inputL", " inputChar", " inputLINE", "InputEl", "InputBlock", "inputline", "InputL", "inputRow", "errorLINE", " inputRow", "InputChar", "inputChar", "outputLine", " inputline", "inputL", " inputBlock", "outputChar", "inputLINE", "inputBlock", "errorLine", "outputLINE", "errorL", "inputEl"]}}
{"id1": "13499897", "id2": "23677142", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "label": 0, "substitutes": {"CopyFile": ["CreateFolder", " CopyDir", "CopyFolder", "CreateFile", "Createfile", " copyFile", " CopyFolder", " copyDir", "CreateDir", " copyfile", "Copyfile", "CopyDir", " copyFolder", " Copyfile"], "sourcefile": ["destfilename", "configlog", "destFile", "deststream", " sourceFile", "configstream", "sinstream", "configFile", "sinFile", "sourcefilename", "Sourcefilename", "sourceFile", "SourceFile", "configfile", "sinlog", "Sourcef", "sourcestream", "Sourcefile", " sourcefilename", "sourcelog", "sinfile", "destf", " sourcef", "sourcef", "destlog"], "destfile": ["destfilename", "sourcestring", "tempFile", "destFile", "DestFile", "targetfilename", "tempfile", "buildfile", "srcfilename", "srcpath", "destroypath", "Destfilename", " desturl", "newfp", "desturl", "tempfilename", "destfp", "targeturl", "deststream", "newfilename", "Destpath", "tempstream", " deststring", "destroyfile", " destFile", "Desturl", "newfile", "buildstring", "srcstream", "deststring", "sourcefilename", "sourceFile", "targetfile", " destpath", "targetFile", "temppath", "destroystream", " destfp", "newFile", "destroyfilename", "Destfp", "srcfile", "destpath", "srcFile", "buildFile", "Destfile", "buildfilename", "targetpath", "sourcepath", " destfilename"], "last": ["nd", "right", "base", "child", "end", "depth", "offset", "latest", "current", "event", "cur", "count", "total", "key", "use", "later", "full", "cat", "after", "left", "style", "code", "from", "route", "core", "path", "next", "recent", "part", "Last", "se", "real", "prev", "first", "ending", "length", "size", "start", "range", "value", "empty", "old", "or", " Last", "max", "ast"], "parent": ["unit", "base", "child", "temp", "section", "point", "root", "fat", "current", "content", "po", "function", "patch", "target", "anc", "exp", "text", "cache", "filename", "key", "remote", "api", "post", "Parent", "home", "string", "null", "pa", "path", "next", "ant", "p", "line", "parents", "part", "pointer", "and", "dest", "mac", "ip", "name", "location", "test", "ac", "search", "data", "file", "id", "valid", "port", "shared", "partial", "loc", "source", "url", "ppa"], "f": ["folder", "j", "base", "o", "feed", "of", "found", "self", "fa", "inf", "lf", "F", "fe", "ref", "fc", "l", "b", "full", "c", "cf", "r", "g", "fd", "t", "d", "fb", "p", "v", "df", "flat", "fp", "fs", "dir", "h", "file", "af", "e", "sf", "i", "m", "s"], "srcChannel": ["srcchannel", " srcConnection", "destchannel", "rcClient", "destChannel", "rcChan", "destConnection", " srcChan", "rcchannel", "sourcechannel", "rcChannel", "srcChan", " srcchannel", "sourceChan", " srcClient", "sourceConnection", "sourceChannel", "destClient", "destChan", "srcClient", "rcConnection", "srcConnection"], "dstChannel": ["drcChannel", "idrcButton", "DstContext", "idstchannel", "DstChannel", "DestChan", "dstschannel", "destchannel", "DstChan", "drcChan", "DestContext", "dstsChan", "idstChan", "ddestContext", "dstButton", "DstBuffer", "destChannel", "dstBuffer", "Dstchannel", "dntChan", "ddestBuffer", "DestBuffer", "idrcChan", "idrcChannel", "dntBuffer", "dstchannel", "destBuffer", "dstsChannel", "drcButton", "idrcchannel", "destContext", "idstChannel", "dsrcChan", "dntContext", "dstChan", "ddestChannel", "destButton", "idstButton", "ddestChan", "drcchannel", "dsrcChannel", "destChan", "dsrcButton", "dsrcchannel", "Destchannel", "DestChannel", "dstContext", "dntChannel"]}}
